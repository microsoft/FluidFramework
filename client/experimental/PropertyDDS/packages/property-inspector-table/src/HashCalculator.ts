/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
import base64js from "base64-js";

/**
 * @fileoverview Utility class to compute an hash for a given set of variables
 * using the murmur3 hash (see https://code.google.com/p/smhasher/)
 *
 * This is a reimplementation of the original C++ code in JavaScript. The original
 * code is licensed under a MIT license.
 */

/**
 * Helper class to store the array buffers needed for the hash computation.
 *
 * TODO: should we cache these classes to avoid unnecessary reallocation of these buffers. Is it worth the effort?
 */
class HashBuffer {
  private readonly hashBuffer: ArrayBuffer;
  public readonly dataView: DataView;
  public readonly Uint8HashArray: Uint8Array;
  public readonly Uint32HashArray: Uint32Array;
  public pos: number;

  public constructor() {
    // This is the internal array buffer we are going to use for conversions
    this.hashBuffer = new ArrayBuffer(32);

    this.dataView = new DataView(this.hashBuffer);
    this.Uint8HashArray = new Uint8Array(this.hashBuffer, 0, 32);
    this.Uint32HashArray = new Uint32Array(this.hashBuffer, 0, 8);

    this.pos = 0;
  }

  /**
   * Shifts the buffers forward by 16 bytes
   */
  public shiftBuffers() {
    this.Uint32HashArray[0] = this.Uint32HashArray[4];
    this.Uint32HashArray[1] = this.Uint32HashArray[5];
    this.Uint32HashArray[2] = this.Uint32HashArray[6];
    this.Uint32HashArray[3] = this.Uint32HashArray[7];
    this.Uint32HashArray[4] = 0;
    this.Uint32HashArray[5] = 0;
    this.Uint32HashArray[6] = 0;
    this.Uint32HashArray[7] = 0;
    this.pos -= 16;
  }
}

// If available, we use the browser imul function, otherwise we emulate it
// Emulation code is from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
// License: public domain, according to https://developer.mozilla.org/en-US/docs/MDN/About#Copyrights_and_licenses:
//   Code samples added on or after August 20, 2010 are in the public domain.
//   No licensing notice is necessary, but if you need one, you can use:
//   "Any copyright is dedicated to the Public Domain.
//    http://creativecommons.org/publicdomain/zero/1.0/".
const imul = Math.imul || function(a, b) {
  const ah = (a >>> 16) & 0xffff;
  const al = a & 0xffff;
  const bh = (b >>> 16) & 0xffff;
  const bl = b & 0xffff;
  // the shift by 0 fixes the sign on the high part
  // the final |0 converts the unsigned value into a signed value
  return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
};

// Helper functions for the hash computation
/**
 * ROT function required for the hash computation
 *
 * @param {number} x - 32 bit integer
 * @param {number} r - amount to shift
 * @return {number} Rotated 32-bit integer.
 */
const rotl32 = function(x, r) {
  return (((x << r) >>> 0) | (x >>> (32 - r))) >>> 0;
};

/**
 * Mixing function for the finalization
 * @param {number} h - 32 bit integer
 * @return {number} The scrambled 32-bit integer.
 */
const fmix32 = function(h) {
  h = (h ^ (h >>> 16)) >>> 0;
  h = imul(h, 0x85ebca6b) >>> 0;
  h = (h ^ (h >>> 13)) >>> 0;
  h = imul(h, 0xc2b2ae35) >>> 0;
  h = (h ^ (h >>> 16)) >>> 0;

  return h;
};

// Constants
const c1 = 0x239b961b;
const c2 = 0xab0e9789;
const c3 = 0x38b34ae5;
const c4 = 0xa1e38b93;

/**
 * Helper class which computes a Murmur3 hash for binary data. The user can successively push data in different binary
 * types into the hash computation function and will then get a hash computed over these fields.
 *
 * NOTE: By default JavaScript uses big-endian byte order. So the hashes generated by this class might correspond to
 * those generated natively on a little-endian architecture.
 */
export class HashCalculator {
  /**
   * The type to use when pushing values
   * @enum
   */
  public static Type = {
    /** Signed integer with 8 bits */
    Int8: 0,
    /** Signed integer with 16 bits */
    Int16: 1,
    /** Signed integer with 32 bits */
    Int32: 2,
    /** Unsigned integer with 8 bits */
    Uint8: 3,
    /** Unsigned integer with 16 bits */
    Uint16: 4,
    /** Unsigned integer with 32 bits */
    Uint32: 5,
    /** Floating point value with 32 bits */
    Float32: 6,
    /** Floating point value with 64 bits */
    Float64: 7,
  };

  private readonly hashBuffer: HashBuffer;
  private _h1: number;
  private _h2: number;
  private _h3: number;
  private _h4: number;
  private length: number;
  private finalized: boolean;
  public constructor(in_seed: number = 1) {
    // Initialize the hash computation with the seed value
    this._h1 = in_seed;
    this._h2 = in_seed;
    this._h3 = in_seed;
    this._h4 = in_seed;
    this.length = 0;
    this.finalized = false;

    this.hashBuffer = new HashBuffer();
  }

  /**
   * Pushes a single unsigned integer with 16 bits into the hash computation
   *
   * @param {number} in_value - The value to push
   */
  private pushUint16(in_value: number) {
    this.hashBuffer.dataView.setUint16(this.hashBuffer.pos, in_value);
    this.hashBuffer.pos += 2;

    if (this.hashBuffer.pos >= 16) {
      this._computeHashFor16ByteBlock();
    }
  }

  /**
   * Pushes a string into the hash computation
   *
   * @param {string} in_string - The value to push
   */
  public pushString(in_string: string) {
    // Push each character individually. We have to use uin16 here, as
    // JavaScript strings are UTF16
    for (let i = 0; i < in_string.length; i++) {
      this.pushUint16(in_string.charCodeAt(i));
    }
  }

  /**
   * @return {string} the computed Hash
   * Note: after calling this function you no longer may push more data!
   */
  public getHash() {
    if (!this.finalized) {
      this._finalizeHash();
    }

    // Convert the hash to a string
    return uint32x4ToGUID([this._h1, this._h2, this._h3, this._h4]);
  }

  /**
   * Computes the murmur3 hash for a block of 16 bytes
   * @private
   */
  private _computeHashFor16ByteBlock() {
    let k1 = this.hashBuffer.Uint32HashArray[0];
    let k2 = this.hashBuffer.Uint32HashArray[1];
    let k3 = this.hashBuffer.Uint32HashArray[2];
    let k4 = this.hashBuffer.Uint32HashArray[3];
    this.hashBuffer.shiftBuffers();

    k1 = imul(k1, c1) >>> 0; k1 = rotl32(k1, 15); k1 = imul(k1, c2) >>> 0; this._h1 = (this._h1 ^ k1) >>> 0;
    this._h1 = rotl32(this._h1, 19);
    this._h1 = (this._h1 + this._h2) >>> 0;
    this._h1 = ((imul(this._h1, 5) >>> 0) + 0x561ccd1b) >>> 0;

    k2 = imul(k2, c2) >>> 0; k2 = rotl32(k2, 16); k2 = imul(k2, c3) >>> 0; this._h2 = (this._h2 ^ k2) >>> 0;
    this._h2 = rotl32(this._h2, 17);
    this._h2 = (this._h2 + this._h3) >>> 0;
    this._h2 = ((imul(this._h2, 5) >>> 0) + 0x0bcaa747) >>> 0;

    k3 = imul(k3, c3) >>> 0; k3 = rotl32(k3, 17); k3 = imul(k3, c4) >>> 0; this._h3 = (this._h3 ^ k3) >>> 0;
    this._h3 = rotl32(this._h3, 15);
    this._h3 = (this._h3 + this._h4) >>> 0;
    this._h3 = ((imul(this._h3, 5) >>> 0) + 0x96cd1c35) >>> 0;

    k4 = imul(k4, c4) >>> 0; k4 = rotl32(k4, 18); k4 = imul(k4, c1) >>> 0; this._h4 = (this._h4 ^ k4) >>> 0;
    this._h4 = rotl32(this._h4, 13);
    this._h4 = (this._h4 + this._h1) >>> 0;
    this._h4 = ((imul(this._h4, 5) >>> 0) + 0x32ac3b17) >>> 0;

    this.length += 16;
  }

  /**
   * Finalizes the hash computation
   * @private
   */
  private _finalizeHash() {
    let k1 = 0;
    let k2 = 0;
    let k3 = 0;
    let k4 = 0;

    // Compute the hash for the remaining bytes in the buffer
    const buffer = this.hashBuffer.Uint8HashArray;
    /* eslint-disable no-multi-spaces */
    switch (this.hashBuffer.pos) {
      case 15: k4 = (k4 ^ (buffer[14] << 16)) >>> 0;
      case 14: k4 = (k4 ^ (buffer[13] << 8)) >>> 0;
      case 13: k4 = (k4 ^ (buffer[12] << 0)) >>> 0;
        k4 = imul(k4, c4) >>> 0;
        k4 = rotl32(k4, 18);
        k4 = imul(k4, c1) >>> 0;
        this._h4 = (this._h4 ^ k4) >>> 0;

      case 12: k3 = (k3 ^ (buffer[11] << 24)) >>> 0;
      case 11: k3 = (k3 ^ (buffer[10] << 16)) >>> 0;
      case 10: k3 = (k3 ^ (buffer[ 9] << 8)) >>> 0;
      case  9: k3 = (k3 ^ (buffer[ 8] << 0)) >>> 0;
        k3 = imul(k3, c3) >>> 0;
        k3 = rotl32(k3, 17);
        k3 = imul(k3, c4) >>> 0;
        this._h3 = (this._h3 ^ k3) >>> 0;

      case  8: k2 = (k2 ^ (buffer[ 7] << 24)) >>> 0;
      case  7: k2 = (k2 ^ (buffer[ 6] << 16)) >>> 0;
      case  6: k2 = (k2 ^ (buffer[ 5] << 8)) >>> 0;
      case  5: k2 = (k2 ^ (buffer[ 4] << 0)) >>> 0;
        k2 = imul(k2, c2) >>> 0;
        k2 = rotl32(k2, 16);
        k2 = imul(k2, c3) >>> 0;
        this._h2 = (this._h2 ^ k2) >>> 0;

      case  4: k1 = (k1 ^ (buffer[ 3] << 24)) >>> 0;
      case  3: k1 = (k1 ^ (buffer[ 2] << 16)) >>> 0;
      case  2: k1 = (k1 ^ (buffer[ 1] << 8)) >>> 0;
      case  1: k1 = (k1 ^ (buffer[ 0] << 0)) >>> 0;
        k1 = imul(k1, c1) >>> 0;
        k1 = rotl32(k1, 15);
        k1 = imul(k1, c2) >>> 0;
        this._h1 = (this._h1 ^ k1) >>> 0;
        break;
      case  0:
        // Bug fix for previously unhandled condition
        break;

      default:
        throw new Error("_finalizeHash: We should never get into the default case.");
    }
    /* eslint-enable no-multi-spaces */

    // Perform the finalization
    const len = this.length + this.hashBuffer.pos;
    this._h1 = (this._h1 ^ len) >>> 0;
    this._h2 = (this._h2 ^ len) >>> 0;
    this._h3 = (this._h3 ^ len) >>> 0;
    this._h4 = (this._h4 ^ len) >>> 0;

    this._h1 = (this._h1 + this._h2) >>> 0;
    this._h1 = (this._h1 + this._h3) >>> 0;
    this._h1 = (this._h1 + this._h4) >>> 0;
    this._h2 = (this._h2 + this._h1) >>> 0;
    this._h3 = (this._h3 + this._h1) >>> 0;
    this._h4 = (this._h4 + this._h1) >>> 0;

    this._h1 = fmix32(this._h1);
    this._h2 = fmix32(this._h2);
    this._h3 = fmix32(this._h3);
    this._h4 = fmix32(this._h4);

    this._h1 = (this._h1 + this._h2) >>> 0;
    this._h1 = (this._h1 + this._h3) >>> 0;
    this._h1 = (this._h1 + this._h4) >>> 0;

    this._h2 = (this._h2 + this._h1) >>> 0;
    this._h3 = (this._h3 + this._h1) >>> 0;
    this._h4 = (this._h4 + this._h1) >>> 0;

    this.finalized = true;
  }
}

const toUrlBase64 = function(base64) {
  return base64.replace(/\+/g, "-").replace(/\//g, "_").split("=")[0];
};

const uint32x4ToGUID = function(in_guidArray) {
  const intArray = new Uint32Array(in_guidArray);
  const byteArray = new Uint8Array(intArray.buffer);
  const base64guid = base64js.fromByteArray(byteArray);
  // return url-friendly base64
  return toUrlBase64(base64guid);
};
