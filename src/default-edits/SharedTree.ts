/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

import type { IFluidDataStoreRuntime } from '@fluidframework/datastore-definitions';
import { convertTreeNodes, GenericSharedTree, WriteFormat } from '../generic';
import type { ChangeNode_0_0_2, Edit, RevisionView, SharedTreeEncoder } from '../generic';
import { isDetachedSequenceId } from '../Identifiers';
import { copyPropertyIfDefined, fail } from '../Common';
import type { DetachedSequenceId } from '../Identifiers';
import { ChangeInternal, ChangeTypeInternal, ConstraintInternal, DetachInternal } from './persisted-types';
import { SharedTreeFactory } from './Factory';
import { Transaction } from './Transaction';
import { internalizeBuildNode } from './EditUtilities';
import { revert } from './HistoryEditFactory';
import { BuildTreeNode, Change, ChangeType } from './ChangeTypes';
import { tryConvertToStablePlaceInternal_0_0_2, tryConvertToStableRangeInternal_0_0_2 } from './Conversion002';
import { getSharedTreeEncoder } from './SharedTreeEncoder';

/**
 * A distributed tree.
 * @public
 * @sealed
 */
export class SharedTree extends GenericSharedTree<Change, ChangeInternal, Transaction.Failure> {
	/**
	 * Create a new SharedTree. It will contain the default value (see initialTree).
	 */
	public static create(runtime: IFluidDataStoreRuntime, id?: string): SharedTree {
		return runtime.createChannel(id, SharedTreeFactory.Type) as SharedTree;
	}

	/**
	 * Get a factory for SharedTree to register with the data store.
	 * @param summarizeHistory - Determines if the history is included in summaries.
	 * @param writeFormat - Determines the format version the SharedTree will write summaries in.
	 * This format may be updated to a newer (supported) version if a collaborating shared-tree is initialized
	 * with a newer write version.
	 * See docs/Breaking-Change-Migration for more details on this scheme.
	 * @param uploadEditChunks - Determines if edit chunks are uploaded when they are full.
	 * @returns A factory that creates `SharedTree`s and loads them from storage.
	 */
	public static getFactory(
		summarizeHistory = false,
		writeFormat = WriteFormat.v0_0_2,
		uploadEditChunks = false
	): SharedTreeFactory {
		return new SharedTreeFactory({
			summarizeHistory,
			writeFormat,
			uploadEditChunks,
		});
	}

	/**
	 * Create a new SharedTreeFactory.
	 * @param runtime - The runtime the SharedTree will be associated with
	 * @param id - Unique ID for the SharedTree
	 * @param expensiveValidation - enable expensive asserts
	 * @param summarizeHistory - Determines if the history is included in summaries.
	 * @param writeFormat - Determines the format version the SharedTree will write summaries in.
	 * @param uploadEditChunks - Determines if edit chunks are uploaded when they are full.
	 */
	public constructor(
		runtime: IFluidDataStoreRuntime,
		id: string,
		expensiveValidation = false,
		summarizeHistory = true,
		writeFormat = WriteFormat.v0_0_2,
		uploadEditChunks = false
	) {
		super(
			runtime,
			id,
			Transaction.factory,
			SharedTreeFactory.Attributes,
			expensiveValidation,
			summarizeHistory,
			writeFormat,
			uploadEditChunks
		);
	}

	/**
	 * {@inheritDoc GenericSharedTree.revertChanges}
	 * @internal
	 */
	public revertChanges(changes: readonly ChangeInternal[], before: RevisionView): ChangeInternal[] | undefined {
		return revert(changes, before, this);
	}

	/**
	 * {@inheritDoc GenericSharedTree.preprocessEdit}
	 * @internal
	 */
	protected preprocessEdit(edit: Edit<ChangeInternal>, _local: boolean): Edit<ChangeInternal> {
		// TODO:#70358: Generate IDs for remote builds
		return edit;
	}

	/**
	 * {@inheritDoc GenericSharedTree.internalizeChange}
	 * @internal
	 */
	public internalizeChange(change: Change): ChangeInternal {
		switch (change.type) {
			case ChangeType.Insert:
				return {
					source: change.source,
					destination:
						tryConvertToStablePlaceInternal_0_0_2(change.destination, this) ??
						fail('Node ID was not generated by this SharedTree'),
					type: ChangeTypeInternal.Insert,
				};
			case ChangeType.Detach: {
				const detach: DetachInternal = {
					source:
						tryConvertToStableRangeInternal_0_0_2(change.source, this) ??
						fail('Node ID was not generated by this SharedTree'),
					type: ChangeTypeInternal.Detach,
				};
				copyPropertyIfDefined(change, detach, 'destination');
				return detach;
			}
			case ChangeType.Build: {
				const source = change.source.map((buildNode) =>
					convertTreeNodes<BuildTreeNode, ChangeNode_0_0_2, DetachedSequenceId>(
						buildNode,
						(nodeData) => internalizeBuildNode(nodeData, this),
						isDetachedSequenceId
					)
				);
				return { source, destination: change.destination, type: ChangeTypeInternal.Build };
			}
			case ChangeType.SetValue:
				return {
					nodeToModify:
						this.tryConvertToStableNodeId(change.nodeToModify) ??
						fail('Node ID was not generated by this SharedTree'),
					payload: change.payload,
					type: ChangeTypeInternal.SetValue,
				};
			case ChangeType.Constraint: {
				const constraint: ConstraintInternal = {
					effect: change.effect,
					toConstrain:
						tryConvertToStableRangeInternal_0_0_2(change.toConstrain, this) ??
						fail('Node ID was not generated by this SharedTree'),
					type: ChangeTypeInternal.Constraint,
				};
				copyPropertyIfDefined(change, constraint, 'contentHash');
				copyPropertyIfDefined(change, constraint, 'identityHash');
				copyPropertyIfDefined(change, constraint, 'label');
				copyPropertyIfDefined(change, constraint, 'length');
				copyPropertyIfDefined(change, constraint, 'parentNode');
				return constraint;
			}
			default:
				fail('unexpected change type');
		}
	}

	/**
	 * {@inheritDoc GenericSharedTree.getSharedTreeEncoder}
	 */
	protected getSharedTreeEncoder(version: WriteFormat): SharedTreeEncoder<ChangeInternal> {
		return getSharedTreeEncoder(version);
	}
}
