## API Report File for "@fluidframework/driver-definitions"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ConnectionMode } from '@fluidframework/protocol-definitions';
import { IClient } from '@fluidframework/protocol-definitions';
import { IClientConfiguration } from '@fluidframework/protocol-definitions';
import { ICreateBlobResponse } from '@fluidframework/protocol-definitions';
import { IDisposable } from '@fluidframework/common-definitions';
import { IDocumentMessage } from '@fluidframework/protocol-definitions';
import { IErrorEvent } from '@fluidframework/common-definitions';
import { IEventProvider } from '@fluidframework/common-definitions';
import { IFluidCodeDetails } from '@fluidframework/core-interfaces';
import { INack } from '@fluidframework/protocol-definitions';
import { IRequest } from '@fluidframework/core-interfaces';
import { ISequencedDocumentMessage } from '@fluidframework/protocol-definitions';
import { ISignalClient } from '@fluidframework/protocol-definitions';
import { ISignalMessage } from '@fluidframework/protocol-definitions';
import { ISnapshotTree } from '@fluidframework/protocol-definitions';
import { ISummaryHandle } from '@fluidframework/protocol-definitions';
import { ISummaryTree } from '@fluidframework/protocol-definitions';
import { ITelemetryBaseLogger } from '@fluidframework/common-definitions';
import { ITokenClaims } from '@fluidframework/protocol-definitions';
import { ITree } from '@fluidframework/protocol-definitions';
import { IVersion } from '@fluidframework/protocol-definitions';

// @public (undocumented)
export type DriverError = IThrottlingWarning | IGenericNetworkError | IAuthorizationError | IDriverBasicError;

// @public
export enum DriverErrorType {
    authorizationError = "authorizationError",
    deltaStreamConnectionForbidden = "deltaStreamConnectionForbidden",
    fetchFailure = "fetchFailure",
    fileNotFoundOrAccessDeniedError = "fileNotFoundOrAccessDeniedError",
    fileOverwrittenInStorage = "fileOverwrittenInStorage",
    // @deprecated (undocumented)
    genericError = "genericError",
    genericNetworkError = "genericNetworkError",
    incorrectServerResponse = "incorrectServerResponse",
    offlineError = "offlineError",
    throttlingError = "throttlingError",
    // (undocumented)
    unsupportedClientProtocolVersion = "unsupportedClientProtocolVersion",
    writeError = "writeError"
}

// @public
export enum DriverHeader {
    // (undocumented)
    createNew = "createNew",
    // (undocumented)
    summarizingClient = "fluid-client-summarizer"
}

// @public
export interface DriverPreCheckInfo {
    codeDetailsHint?: string;
    // @deprecated (undocumented)
    containerPath: string;
    criticalBootDomains?: string[];
}

// @public (undocumented)
export interface IAuthorizationError extends IDriverErrorBase {
    // (undocumented)
    readonly claims?: string;
    // (undocumented)
    readonly errorType: DriverErrorType.authorizationError;
    // (undocumented)
    readonly tenantId?: string;
}

// @public (undocumented)
export interface IDeltasFetchResult {
    messages: ISequencedDocumentMessage[];
    partialResult: boolean;
}

// @public
export interface IDeltaStorageService {
    get(tenantId: string, id: string, from: number, // inclusive
    to: number, // exclusive
    fetchReason?: string): Promise<IDeltasFetchResult>;
}

// @public (undocumented)
export interface IDocumentDeltaConnection extends IDisposable, IEventProvider<IDocumentDeltaConnectionEvents> {
    checkpointSequenceNumber?: number;
    claims: ITokenClaims;
    clientId: string;
    existing: boolean;
    initialClients: ISignalClient[];
    initialMessages: ISequencedDocumentMessage[];
    initialSignals: ISignalMessage[];
    mode: ConnectionMode;
    relayServiceAgent?: string;
    serviceConfiguration: IClientConfiguration;
    submit(messages: IDocumentMessage[]): void;
    submitSignal(message: any): void;
    version: string;
}

// @public (undocumented)
export interface IDocumentDeltaConnectionEvents extends IErrorEvent {
    // (undocumented)
    (event: "nack", listener: (documentId: string, message: INack[]) => void): any;
    // (undocumented)
    (event: "disconnect", listener: (reason: any) => void): any;
    // (undocumented)
    (event: "op", listener: (documentId: string, messages: ISequencedDocumentMessage[]) => void): any;
    // (undocumented)
    (event: "signal", listener: (message: ISignalMessage) => void): any;
    // (undocumented)
    (event: "pong", listener: (latency: number) => void): any;
    // (undocumented)
    (event: "error", listener: (error: any) => void): any;
}

// @public
export interface IDocumentDeltaStorageService {
    fetchMessages(from: number, to: number | undefined, abortSignal?: AbortSignal, cachedOnly?: boolean, fetchReason?: string): IStream<ISequencedDocumentMessage[]>;
}

// @public (undocumented)
export interface IDocumentService {
    connectToDeltaStorage(): Promise<IDocumentDeltaStorageService>;
    connectToDeltaStream(client: IClient): Promise<IDocumentDeltaConnection>;
    connectToStorage(): Promise<IDocumentStorageService>;
    dispose(error?: any): void;
    policies?: IDocumentServicePolicies;
    // (undocumented)
    resolvedUrl: IResolvedUrl;
}

// @public (undocumented)
export interface IDocumentServiceFactory {
    createContainer(createNewSummary: ISummaryTree | undefined, createNewResolvedUrl: IResolvedUrl, logger?: ITelemetryBaseLogger): Promise<IDocumentService>;
    createDocumentService(resolvedUrl: IResolvedUrl, logger?: ITelemetryBaseLogger): Promise<IDocumentService>;
    protocolName: string;
}

// @public (undocumented)
export interface IDocumentServicePolicies {
    readonly storageOnly?: boolean;
}

// @public
export interface IDocumentStorageService extends Partial<IDisposable> {
    createBlob(file: ArrayBufferLike): Promise<ICreateBlobResponse>;
    downloadSummary(handle: ISummaryHandle): Promise<ISummaryTree>;
    getSnapshotTree(version?: IVersion): Promise<ISnapshotTree | null>;
    getVersions(versionId: string | null, count: number): Promise<IVersion[]>;
    readonly policies?: IDocumentStorageServicePolicies;
    readBlob(id: string): Promise<ArrayBufferLike>;
    // (undocumented)
    repositoryUrl: string;
    uploadSummaryWithContext(summary: ISummaryTree, context: ISummaryContext): Promise<string>;
    write(root: ITree, parents: string[], message: string, ref: string): Promise<IVersion>;
}

// @public (undocumented)
export interface IDocumentStorageServicePolicies {
    // (undocumented)
    readonly caching?: LoaderCachingPolicy;
    // (undocumented)
    readonly minBlobSize?: number;
}

// @public
export interface IDriverBasicError extends IDriverErrorBase {
    // (undocumented)
    readonly errorType: DriverErrorType.genericError | DriverErrorType.fileNotFoundOrAccessDeniedError | DriverErrorType.offlineError | DriverErrorType.unsupportedClientProtocolVersion | DriverErrorType.writeError | DriverErrorType.fetchFailure | DriverErrorType.incorrectServerResponse | DriverErrorType.fileOverwrittenInStorage;
    // (undocumented)
    readonly statusCode?: number;
}

// @public
export interface IDriverErrorBase {
    // (undocumented)
    canRetry: boolean;
    // (undocumented)
    readonly errorType: DriverErrorType;
    // (undocumented)
    readonly message: string;
    // (undocumented)
    online?: string;
}

// @public (undocumented)
export interface IDriverHeader {
    // (undocumented)
    [DriverHeader.summarizingClient]: boolean;
    // (undocumented)
    [DriverHeader.createNew]: any;
}

// @public (undocumented)
export interface IFluidResolvedUrl extends IResolvedUrlBase {
    // (undocumented)
    endpoints: {
        [name: string]: string;
    };
    id: string;
    // (undocumented)
    tokens: {
        [name: string]: string;
    };
    // (undocumented)
    type: "fluid";
    // (undocumented)
    url: string;
}

// @public (undocumented)
export interface IGenericNetworkError extends IDriverErrorBase {
    // (undocumented)
    readonly errorType: DriverErrorType.genericNetworkError;
    // (undocumented)
    readonly statusCode?: number;
}

// @public (undocumented)
export type IResolvedUrl = IWebResolvedUrl | IFluidResolvedUrl;

// @public (undocumented)
export interface IResolvedUrlBase {
    // (undocumented)
    type: string;
}

// @public
export interface IStream<T> {
    // (undocumented)
    read(): Promise<IStreamResult<T>>;
}

// @public (undocumented)
export type IStreamResult<T> = {
    done: true;
} | {
    done: false;
    value: T;
};

// @public
export interface ISummaryContext {
    readonly ackHandle: string | undefined;
    readonly proposalHandle: string | undefined;
    // (undocumented)
    readonly referenceSequenceNumber: number;
}

// @public (undocumented)
export interface IThrottlingWarning extends IDriverErrorBase {
    // (undocumented)
    readonly errorType: DriverErrorType.throttlingError;
    // (undocumented)
    readonly retryAfterSeconds: number;
}

// @public (undocumented)
export interface IUrlResolver {
    // (undocumented)
    getAbsoluteUrl(resolvedUrl: IResolvedUrl, relativeUrl: string, codeDetails?: IFluidCodeDetails): Promise<string>;
    // (undocumented)
    resolve(request: IRequest): Promise<IResolvedUrl | undefined>;
}

// @public (undocumented)
export interface IWebResolvedUrl extends IResolvedUrlBase {
    // (undocumented)
    data: string;
    // (undocumented)
    type: "web";
}

// @public (undocumented)
export enum LoaderCachingPolicy {
    NoCaching = 0,
    Prefetch = 1
}


// (No @packageDocumentation comment for this package)

```
