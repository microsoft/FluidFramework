/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "@fluidframework/common-utils-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_assert": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_assert():
    TypeOnly<typeof old.assert>;
declare function use_current_FunctionDeclaration_assert(
    use: TypeOnly<typeof current.assert>);
use_current_FunctionDeclaration_assert(
    get_old_FunctionDeclaration_assert());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_assert": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_assert():
    TypeOnly<typeof current.assert>;
declare function use_old_FunctionDeclaration_assert(
    use: TypeOnly<typeof old.assert>);
use_old_FunctionDeclaration_assert(
    get_current_FunctionDeclaration_assert());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BaseTelemetryNullLogger": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_BaseTelemetryNullLogger():
    TypeOnly<old.BaseTelemetryNullLogger>;
declare function use_current_ClassDeclaration_BaseTelemetryNullLogger(
    use: TypeOnly<current.BaseTelemetryNullLogger>);
use_current_ClassDeclaration_BaseTelemetryNullLogger(
    get_old_ClassDeclaration_BaseTelemetryNullLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BaseTelemetryNullLogger": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_BaseTelemetryNullLogger():
    TypeOnly<current.BaseTelemetryNullLogger>;
declare function use_old_ClassDeclaration_BaseTelemetryNullLogger(
    use: TypeOnly<old.BaseTelemetryNullLogger>);
use_old_ClassDeclaration_BaseTelemetryNullLogger(
    get_current_ClassDeclaration_BaseTelemetryNullLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedClassDeclaration_BatchManager": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedClassDeclaration_BatchManager": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Buffer": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Buffer():
    TypeOnly<old.Buffer>;
declare function use_current_ClassDeclaration_Buffer(
    use: TypeOnly<current.Buffer>);
use_current_ClassDeclaration_Buffer(
    get_old_ClassDeclaration_Buffer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Buffer": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Buffer():
    TypeOnly<current.Buffer>;
declare function use_old_ClassDeclaration_Buffer(
    use: TypeOnly<old.Buffer>);
use_old_ClassDeclaration_Buffer(
    get_current_ClassDeclaration_Buffer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_bufferToString": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_bufferToString():
    TypeOnly<typeof old.bufferToString>;
declare function use_current_VariableDeclaration_bufferToString(
    use: TypeOnly<typeof current.bufferToString>);
use_current_VariableDeclaration_bufferToString(
    get_old_VariableDeclaration_bufferToString());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_bufferToString": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_bufferToString():
    TypeOnly<typeof current.bufferToString>;
declare function use_old_VariableDeclaration_bufferToString(
    use: TypeOnly<typeof old.bufferToString>);
use_old_VariableDeclaration_bufferToString(
    get_current_VariableDeclaration_bufferToString());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Deferred": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Deferred():
    TypeOnly<old.Deferred<any>>;
declare function use_current_ClassDeclaration_Deferred(
    use: TypeOnly<current.Deferred<any>>);
use_current_ClassDeclaration_Deferred(
    get_old_ClassDeclaration_Deferred());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Deferred": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Deferred():
    TypeOnly<current.Deferred<any>>;
declare function use_old_ClassDeclaration_Deferred(
    use: TypeOnly<old.Deferred<any>>);
use_old_ClassDeclaration_Deferred(
    get_current_ClassDeclaration_Deferred());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_delay": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_delay():
    TypeOnly<typeof old.delay>;
declare function use_current_VariableDeclaration_delay(
    use: TypeOnly<typeof current.delay>);
use_current_VariableDeclaration_delay(
    get_old_VariableDeclaration_delay());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_delay": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_delay():
    TypeOnly<typeof current.delay>;
declare function use_old_VariableDeclaration_delay(
    use: TypeOnly<typeof old.delay>);
use_old_VariableDeclaration_delay(
    get_current_VariableDeclaration_delay());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_doIfNotDisposed": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_doIfNotDisposed():
    TypeOnly<typeof old.doIfNotDisposed>;
declare function use_current_FunctionDeclaration_doIfNotDisposed(
    use: TypeOnly<typeof current.doIfNotDisposed>);
use_current_FunctionDeclaration_doIfNotDisposed(
    get_old_FunctionDeclaration_doIfNotDisposed());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_doIfNotDisposed": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_doIfNotDisposed():
    TypeOnly<typeof current.doIfNotDisposed>;
declare function use_old_FunctionDeclaration_doIfNotDisposed(
    use: TypeOnly<typeof old.doIfNotDisposed>);
use_old_FunctionDeclaration_doIfNotDisposed(
    get_current_FunctionDeclaration_doIfNotDisposed());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_EventEmitterEventType": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_EventEmitterEventType():
    TypeOnly<old.EventEmitterEventType>;
declare function use_current_TypeAliasDeclaration_EventEmitterEventType(
    use: TypeOnly<current.EventEmitterEventType>);
use_current_TypeAliasDeclaration_EventEmitterEventType(
    get_old_TypeAliasDeclaration_EventEmitterEventType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_EventEmitterEventType": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_EventEmitterEventType():
    TypeOnly<current.EventEmitterEventType>;
declare function use_old_TypeAliasDeclaration_EventEmitterEventType(
    use: TypeOnly<old.EventEmitterEventType>);
use_old_TypeAliasDeclaration_EventEmitterEventType(
    get_current_TypeAliasDeclaration_EventEmitterEventType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EventForwarder": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_EventForwarder():
    TypeOnly<old.EventForwarder>;
declare function use_current_ClassDeclaration_EventForwarder(
    use: TypeOnly<current.EventForwarder>);
use_current_ClassDeclaration_EventForwarder(
    get_old_ClassDeclaration_EventForwarder());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EventForwarder": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_EventForwarder():
    TypeOnly<current.EventForwarder>;
declare function use_old_ClassDeclaration_EventForwarder(
    use: TypeOnly<old.EventForwarder>);
use_old_ClassDeclaration_EventForwarder(
    get_current_ClassDeclaration_EventForwarder());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_extractLogSafeErrorProperties": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_extractLogSafeErrorProperties": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_fromBase64ToUtf8": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_fromBase64ToUtf8():
    TypeOnly<typeof old.fromBase64ToUtf8>;
declare function use_current_VariableDeclaration_fromBase64ToUtf8(
    use: TypeOnly<typeof current.fromBase64ToUtf8>);
use_current_VariableDeclaration_fromBase64ToUtf8(
    get_old_VariableDeclaration_fromBase64ToUtf8());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_fromBase64ToUtf8": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_fromBase64ToUtf8():
    TypeOnly<typeof current.fromBase64ToUtf8>;
declare function use_old_VariableDeclaration_fromBase64ToUtf8(
    use: TypeOnly<typeof old.fromBase64ToUtf8>);
use_old_VariableDeclaration_fromBase64ToUtf8(
    get_current_VariableDeclaration_fromBase64ToUtf8());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_fromUtf8ToBase64": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_fromUtf8ToBase64():
    TypeOnly<typeof old.fromUtf8ToBase64>;
declare function use_current_VariableDeclaration_fromUtf8ToBase64(
    use: TypeOnly<typeof current.fromUtf8ToBase64>);
use_current_VariableDeclaration_fromUtf8ToBase64(
    get_old_VariableDeclaration_fromUtf8ToBase64());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_fromUtf8ToBase64": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_fromUtf8ToBase64():
    TypeOnly<typeof current.fromUtf8ToBase64>;
declare function use_old_VariableDeclaration_fromUtf8ToBase64(
    use: TypeOnly<typeof old.fromUtf8ToBase64>);
use_old_VariableDeclaration_fromUtf8ToBase64(
    get_current_VariableDeclaration_fromUtf8ToBase64());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_gitHashFile": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_gitHashFile():
    TypeOnly<typeof old.gitHashFile>;
declare function use_current_FunctionDeclaration_gitHashFile(
    use: TypeOnly<typeof current.gitHashFile>);
use_current_FunctionDeclaration_gitHashFile(
    get_old_FunctionDeclaration_gitHashFile());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_gitHashFile": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_gitHashFile():
    TypeOnly<typeof current.gitHashFile>;
declare function use_old_FunctionDeclaration_gitHashFile(
    use: TypeOnly<typeof old.gitHashFile>);
use_old_FunctionDeclaration_gitHashFile(
    get_current_FunctionDeclaration_gitHashFile());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_hashFile": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_hashFile():
    TypeOnly<typeof old.hashFile>;
declare function use_current_FunctionDeclaration_hashFile(
    use: TypeOnly<typeof current.hashFile>);
use_current_FunctionDeclaration_hashFile(
    get_old_FunctionDeclaration_hashFile());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_hashFile": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_hashFile():
    TypeOnly<typeof current.hashFile>;
declare function use_old_FunctionDeclaration_hashFile(
    use: TypeOnly<typeof old.hashFile>);
use_old_FunctionDeclaration_hashFile(
    get_current_FunctionDeclaration_hashFile());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Heap": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Heap():
    TypeOnly<old.Heap<any>>;
declare function use_current_ClassDeclaration_Heap(
    use: TypeOnly<current.Heap<any>>);
use_current_ClassDeclaration_Heap(
    get_old_ClassDeclaration_Heap());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Heap": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Heap():
    TypeOnly<current.Heap<any>>;
declare function use_old_ClassDeclaration_Heap(
    use: TypeOnly<old.Heap<any>>);
use_old_ClassDeclaration_Heap(
    get_current_ClassDeclaration_Heap());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IComparer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IComparer():
    TypeOnly<old.IComparer<any>>;
declare function use_current_InterfaceDeclaration_IComparer(
    use: TypeOnly<current.IComparer<any>>);
use_current_InterfaceDeclaration_IComparer(
    get_old_InterfaceDeclaration_IComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IComparer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IComparer():
    TypeOnly<current.IComparer<any>>;
declare function use_old_InterfaceDeclaration_IComparer(
    use: TypeOnly<old.IComparer<any>>);
use_old_InterfaceDeclaration_IComparer(
    get_current_InterfaceDeclaration_IComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHeapNode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IHeapNode():
    TypeOnly<old.IHeapNode<any>>;
declare function use_current_InterfaceDeclaration_IHeapNode(
    use: TypeOnly<current.IHeapNode<any>>);
use_current_InterfaceDeclaration_IHeapNode(
    get_old_InterfaceDeclaration_IHeapNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHeapNode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IHeapNode():
    TypeOnly<current.IHeapNode<any>>;
declare function use_old_InterfaceDeclaration_IHeapNode(
    use: TypeOnly<old.IHeapNode<any>>);
use_old_InterfaceDeclaration_IHeapNode(
    get_current_InterfaceDeclaration_IHeapNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPromiseTimer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPromiseTimer():
    TypeOnly<old.IPromiseTimer>;
declare function use_current_InterfaceDeclaration_IPromiseTimer(
    use: TypeOnly<current.IPromiseTimer>);
use_current_InterfaceDeclaration_IPromiseTimer(
    get_old_InterfaceDeclaration_IPromiseTimer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPromiseTimer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPromiseTimer():
    TypeOnly<current.IPromiseTimer>;
declare function use_old_InterfaceDeclaration_IPromiseTimer(
    use: TypeOnly<old.IPromiseTimer>);
use_old_InterfaceDeclaration_IPromiseTimer(
    get_current_InterfaceDeclaration_IPromiseTimer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPromiseTimerResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPromiseTimerResult():
    TypeOnly<old.IPromiseTimerResult>;
declare function use_current_InterfaceDeclaration_IPromiseTimerResult(
    use: TypeOnly<current.IPromiseTimerResult>);
use_current_InterfaceDeclaration_IPromiseTimerResult(
    get_old_InterfaceDeclaration_IPromiseTimerResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPromiseTimerResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPromiseTimerResult():
    TypeOnly<current.IPromiseTimerResult>;
declare function use_old_InterfaceDeclaration_IPromiseTimerResult(
    use: TypeOnly<old.IPromiseTimerResult>);
use_old_InterfaceDeclaration_IPromiseTimerResult(
    get_current_InterfaceDeclaration_IPromiseTimerResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRange": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRange():
    TypeOnly<old.IRange>;
declare function use_current_InterfaceDeclaration_IRange(
    use: TypeOnly<current.IRange>);
use_current_InterfaceDeclaration_IRange(
    get_old_InterfaceDeclaration_IRange());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRange": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRange():
    TypeOnly<current.IRange>;
declare function use_old_InterfaceDeclaration_IRange(
    use: TypeOnly<old.IRange>);
use_old_InterfaceDeclaration_IRange(
    get_current_InterfaceDeclaration_IRange());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRangeTrackerSnapshot": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRangeTrackerSnapshot():
    TypeOnly<old.IRangeTrackerSnapshot>;
declare function use_current_InterfaceDeclaration_IRangeTrackerSnapshot(
    use: TypeOnly<current.IRangeTrackerSnapshot>);
use_current_InterfaceDeclaration_IRangeTrackerSnapshot(
    get_old_InterfaceDeclaration_IRangeTrackerSnapshot());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRangeTrackerSnapshot": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRangeTrackerSnapshot():
    TypeOnly<current.IRangeTrackerSnapshot>;
declare function use_old_InterfaceDeclaration_IRangeTrackerSnapshot(
    use: TypeOnly<old.IRangeTrackerSnapshot>);
use_old_InterfaceDeclaration_IRangeTrackerSnapshot(
    get_current_InterfaceDeclaration_IRangeTrackerSnapshot());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IsoBuffer": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IsoBuffer():
    TypeOnly<typeof old.IsoBuffer>;
declare function use_current_VariableDeclaration_IsoBuffer(
    use: TypeOnly<typeof current.IsoBuffer>);
use_current_VariableDeclaration_IsoBuffer(
    get_old_VariableDeclaration_IsoBuffer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IsoBuffer": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IsoBuffer():
    TypeOnly<typeof current.IsoBuffer>;
declare function use_old_VariableDeclaration_IsoBuffer(
    use: TypeOnly<typeof old.IsoBuffer>);
use_old_VariableDeclaration_IsoBuffer(
    get_current_VariableDeclaration_IsoBuffer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IsoBuffer": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IsoBuffer():
    TypeOnly<old.IsoBuffer>;
declare function use_current_TypeAliasDeclaration_IsoBuffer(
    use: TypeOnly<current.IsoBuffer>);
use_current_TypeAliasDeclaration_IsoBuffer(
    get_old_TypeAliasDeclaration_IsoBuffer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IsoBuffer": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IsoBuffer():
    TypeOnly<current.IsoBuffer>;
declare function use_old_TypeAliasDeclaration_IsoBuffer(
    use: TypeOnly<old.IsoBuffer>);
use_old_TypeAliasDeclaration_IsoBuffer(
    get_current_TypeAliasDeclaration_IsoBuffer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IsomorphicPerformance": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IsomorphicPerformance():
    TypeOnly<old.IsomorphicPerformance>;
declare function use_current_TypeAliasDeclaration_IsomorphicPerformance(
    use: TypeOnly<current.IsomorphicPerformance>);
use_current_TypeAliasDeclaration_IsomorphicPerformance(
    get_old_TypeAliasDeclaration_IsomorphicPerformance());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IsomorphicPerformance": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IsomorphicPerformance():
    TypeOnly<current.IsomorphicPerformance>;
declare function use_old_TypeAliasDeclaration_IsomorphicPerformance(
    use: TypeOnly<old.IsomorphicPerformance>);
use_old_TypeAliasDeclaration_IsomorphicPerformance(
    get_current_TypeAliasDeclaration_IsomorphicPerformance());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITimer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITimer():
    TypeOnly<old.ITimer>;
declare function use_current_InterfaceDeclaration_ITimer(
    use: TypeOnly<current.ITimer>);
use_current_InterfaceDeclaration_ITimer(
    get_old_InterfaceDeclaration_ITimer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITimer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITimer():
    TypeOnly<current.ITimer>;
declare function use_old_InterfaceDeclaration_ITimer(
    use: TypeOnly<old.ITimer>);
use_old_InterfaceDeclaration_ITimer(
    get_current_InterfaceDeclaration_ITimer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITraceEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITraceEvent():
    TypeOnly<old.ITraceEvent>;
declare function use_current_InterfaceDeclaration_ITraceEvent(
    use: TypeOnly<current.ITraceEvent>);
use_current_InterfaceDeclaration_ITraceEvent(
    get_old_InterfaceDeclaration_ITraceEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITraceEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITraceEvent():
    TypeOnly<current.ITraceEvent>;
declare function use_old_InterfaceDeclaration_ITraceEvent(
    use: TypeOnly<old.ITraceEvent>);
use_old_InterfaceDeclaration_ITraceEvent(
    get_current_InterfaceDeclaration_ITraceEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Lazy": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Lazy():
    TypeOnly<old.Lazy<any>>;
declare function use_current_ClassDeclaration_Lazy(
    use: TypeOnly<current.Lazy<any>>);
use_current_ClassDeclaration_Lazy(
    get_old_ClassDeclaration_Lazy());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Lazy": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Lazy():
    TypeOnly<current.Lazy<any>>;
declare function use_old_ClassDeclaration_Lazy(
    use: TypeOnly<old.Lazy<any>>);
use_old_ClassDeclaration_Lazy(
    get_current_ClassDeclaration_Lazy());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LazyPromise": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_LazyPromise():
    TypeOnly<old.LazyPromise<any>>;
declare function use_current_ClassDeclaration_LazyPromise(
    use: TypeOnly<current.LazyPromise<any>>);
use_current_ClassDeclaration_LazyPromise(
    get_old_ClassDeclaration_LazyPromise());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LazyPromise": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_LazyPromise():
    TypeOnly<current.LazyPromise<any>>;
declare function use_old_ClassDeclaration_LazyPromise(
    use: TypeOnly<old.LazyPromise<any>>);
use_old_ClassDeclaration_LazyPromise(
    get_current_ClassDeclaration_LazyPromise());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_NumberComparer": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_NumberComparer():
    TypeOnly<typeof old.NumberComparer>;
declare function use_current_VariableDeclaration_NumberComparer(
    use: TypeOnly<typeof current.NumberComparer>);
use_current_VariableDeclaration_NumberComparer(
    get_old_VariableDeclaration_NumberComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_NumberComparer": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_NumberComparer():
    TypeOnly<typeof current.NumberComparer>;
declare function use_old_VariableDeclaration_NumberComparer(
    use: TypeOnly<typeof old.NumberComparer>);
use_old_VariableDeclaration_NumberComparer(
    get_current_VariableDeclaration_NumberComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_performance": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_performance():
    TypeOnly<typeof old.performance>;
declare function use_current_VariableDeclaration_performance(
    use: TypeOnly<typeof current.performance>);
use_current_VariableDeclaration_performance(
    get_old_VariableDeclaration_performance());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_performance": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_performance():
    TypeOnly<typeof current.performance>;
declare function use_old_VariableDeclaration_performance(
    use: TypeOnly<typeof old.performance>);
use_old_VariableDeclaration_performance(
    get_current_VariableDeclaration_performance());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PromiseCache": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_PromiseCache():
    TypeOnly<old.PromiseCache<any,any>>;
declare function use_current_ClassDeclaration_PromiseCache(
    use: TypeOnly<current.PromiseCache<any,any>>);
use_current_ClassDeclaration_PromiseCache(
    get_old_ClassDeclaration_PromiseCache());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PromiseCache": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_PromiseCache():
    TypeOnly<current.PromiseCache<any,any>>;
declare function use_old_ClassDeclaration_PromiseCache(
    use: TypeOnly<old.PromiseCache<any,any>>);
use_old_ClassDeclaration_PromiseCache(
    get_current_ClassDeclaration_PromiseCache());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_PromiseCacheExpiry": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_PromiseCacheExpiry():
    TypeOnly<old.PromiseCacheExpiry>;
declare function use_current_TypeAliasDeclaration_PromiseCacheExpiry(
    use: TypeOnly<current.PromiseCacheExpiry>);
use_current_TypeAliasDeclaration_PromiseCacheExpiry(
    get_old_TypeAliasDeclaration_PromiseCacheExpiry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_PromiseCacheExpiry": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_PromiseCacheExpiry():
    TypeOnly<current.PromiseCacheExpiry>;
declare function use_old_TypeAliasDeclaration_PromiseCacheExpiry(
    use: TypeOnly<old.PromiseCacheExpiry>);
use_old_TypeAliasDeclaration_PromiseCacheExpiry(
    get_current_TypeAliasDeclaration_PromiseCacheExpiry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_PromiseCacheOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_PromiseCacheOptions():
    TypeOnly<old.PromiseCacheOptions>;
declare function use_current_InterfaceDeclaration_PromiseCacheOptions(
    use: TypeOnly<current.PromiseCacheOptions>);
use_current_InterfaceDeclaration_PromiseCacheOptions(
    get_old_InterfaceDeclaration_PromiseCacheOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_PromiseCacheOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_PromiseCacheOptions():
    TypeOnly<current.PromiseCacheOptions>;
declare function use_old_InterfaceDeclaration_PromiseCacheOptions(
    use: TypeOnly<old.PromiseCacheOptions>);
use_old_InterfaceDeclaration_PromiseCacheOptions(
    get_current_InterfaceDeclaration_PromiseCacheOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PromiseTimer": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_PromiseTimer():
    TypeOnly<old.PromiseTimer>;
declare function use_current_ClassDeclaration_PromiseTimer(
    use: TypeOnly<current.PromiseTimer>);
use_current_ClassDeclaration_PromiseTimer(
    get_old_ClassDeclaration_PromiseTimer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PromiseTimer": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_PromiseTimer():
    TypeOnly<current.PromiseTimer>;
declare function use_old_ClassDeclaration_PromiseTimer(
    use: TypeOnly<old.PromiseTimer>);
use_old_ClassDeclaration_PromiseTimer(
    get_current_ClassDeclaration_PromiseTimer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RangeTracker": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_RangeTracker():
    TypeOnly<old.RangeTracker>;
declare function use_current_ClassDeclaration_RangeTracker(
    use: TypeOnly<current.RangeTracker>);
use_current_ClassDeclaration_RangeTracker(
    get_old_ClassDeclaration_RangeTracker());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RangeTracker": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_RangeTracker():
    TypeOnly<current.RangeTracker>;
declare function use_old_ClassDeclaration_RangeTracker(
    use: TypeOnly<old.RangeTracker>);
use_old_ClassDeclaration_RangeTracker(
    get_current_ClassDeclaration_RangeTracker());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RateLimiter": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_RateLimiter():
    TypeOnly<old.RateLimiter>;
declare function use_current_ClassDeclaration_RateLimiter(
    use: TypeOnly<current.RateLimiter>);
use_current_ClassDeclaration_RateLimiter(
    get_old_ClassDeclaration_RateLimiter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RateLimiter": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_RateLimiter():
    TypeOnly<current.RateLimiter>;
declare function use_old_ClassDeclaration_RateLimiter(
    use: TypeOnly<old.RateLimiter>);
use_old_ClassDeclaration_RateLimiter(
    get_current_ClassDeclaration_RateLimiter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_safelyParseJSON": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_safelyParseJSON():
    TypeOnly<typeof old.safelyParseJSON>;
declare function use_current_FunctionDeclaration_safelyParseJSON(
    use: TypeOnly<typeof current.safelyParseJSON>);
use_current_FunctionDeclaration_safelyParseJSON(
    get_old_FunctionDeclaration_safelyParseJSON());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_safelyParseJSON": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_safelyParseJSON():
    TypeOnly<typeof current.safelyParseJSON>;
declare function use_old_FunctionDeclaration_safelyParseJSON(
    use: TypeOnly<typeof old.safelyParseJSON>);
use_old_FunctionDeclaration_safelyParseJSON(
    get_current_FunctionDeclaration_safelyParseJSON());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_stringToBuffer": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_stringToBuffer():
    TypeOnly<typeof old.stringToBuffer>;
declare function use_current_FunctionDeclaration_stringToBuffer(
    use: TypeOnly<typeof current.stringToBuffer>);
use_current_FunctionDeclaration_stringToBuffer(
    get_old_FunctionDeclaration_stringToBuffer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_stringToBuffer": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_stringToBuffer():
    TypeOnly<typeof current.stringToBuffer>;
declare function use_old_FunctionDeclaration_stringToBuffer(
    use: TypeOnly<typeof old.stringToBuffer>);
use_old_FunctionDeclaration_stringToBuffer(
    get_current_FunctionDeclaration_stringToBuffer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TelemetryNullLogger": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TelemetryNullLogger():
    TypeOnly<old.TelemetryNullLogger>;
declare function use_current_ClassDeclaration_TelemetryNullLogger(
    use: TypeOnly<current.TelemetryNullLogger>);
use_current_ClassDeclaration_TelemetryNullLogger(
    get_old_ClassDeclaration_TelemetryNullLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TelemetryNullLogger": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TelemetryNullLogger():
    TypeOnly<current.TelemetryNullLogger>;
declare function use_old_ClassDeclaration_TelemetryNullLogger(
    use: TypeOnly<old.TelemetryNullLogger>);
use_old_ClassDeclaration_TelemetryNullLogger(
    get_current_ClassDeclaration_TelemetryNullLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Timer": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Timer():
    TypeOnly<old.Timer>;
declare function use_current_ClassDeclaration_Timer(
    use: TypeOnly<current.Timer>);
use_current_ClassDeclaration_Timer(
    get_old_ClassDeclaration_Timer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Timer": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Timer():
    TypeOnly<current.Timer>;
declare function use_old_ClassDeclaration_Timer(
    use: TypeOnly<old.Timer>);
use_old_ClassDeclaration_Timer(
    get_current_ClassDeclaration_Timer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_toUtf8": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_toUtf8():
    TypeOnly<typeof old.toUtf8>;
declare function use_current_VariableDeclaration_toUtf8(
    use: TypeOnly<typeof current.toUtf8>);
use_current_VariableDeclaration_toUtf8(
    get_old_VariableDeclaration_toUtf8());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_toUtf8": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_toUtf8():
    TypeOnly<typeof current.toUtf8>;
declare function use_old_VariableDeclaration_toUtf8(
    use: TypeOnly<typeof old.toUtf8>);
use_old_VariableDeclaration_toUtf8(
    get_current_VariableDeclaration_toUtf8());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Trace": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Trace():
    TypeOnly<old.Trace>;
declare function use_current_ClassDeclaration_Trace(
    use: TypeOnly<current.Trace>);
use_current_ClassDeclaration_Trace(
    get_old_ClassDeclaration_Trace());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Trace": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Trace():
    TypeOnly<current.Trace>;
declare function use_old_ClassDeclaration_Trace(
    use: TypeOnly<old.Trace>);
use_old_ClassDeclaration_Trace(
    get_current_ClassDeclaration_Trace());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TypedEventEmitter": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TypedEventEmitter():
    TypeOnly<old.TypedEventEmitter<any>>;
declare function use_current_ClassDeclaration_TypedEventEmitter(
    use: TypeOnly<current.TypedEventEmitter<any>>);
use_current_ClassDeclaration_TypedEventEmitter(
    get_old_ClassDeclaration_TypedEventEmitter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TypedEventEmitter": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TypedEventEmitter():
    TypeOnly<current.TypedEventEmitter<any>>;
declare function use_old_ClassDeclaration_TypedEventEmitter(
    use: TypeOnly<old.TypedEventEmitter<any>>);
use_old_ClassDeclaration_TypedEventEmitter(
    get_current_ClassDeclaration_TypedEventEmitter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TypedEventTransform": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TypedEventTransform():
    TypeOnly<old.TypedEventTransform<any,any>>;
declare function use_current_TypeAliasDeclaration_TypedEventTransform(
    use: TypeOnly<current.TypedEventTransform<any,any>>);
use_current_TypeAliasDeclaration_TypedEventTransform(
    get_old_TypeAliasDeclaration_TypedEventTransform());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TypedEventTransform": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TypedEventTransform():
    TypeOnly<current.TypedEventTransform<any,any>>;
declare function use_old_TypeAliasDeclaration_TypedEventTransform(
    use: TypeOnly<old.TypedEventTransform<any,any>>);
use_old_TypeAliasDeclaration_TypedEventTransform(
    get_current_TypeAliasDeclaration_TypedEventTransform());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_Uint8ArrayToArrayBuffer": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_Uint8ArrayToArrayBuffer():
    TypeOnly<typeof old.Uint8ArrayToArrayBuffer>;
declare function use_current_FunctionDeclaration_Uint8ArrayToArrayBuffer(
    use: TypeOnly<typeof current.Uint8ArrayToArrayBuffer>);
use_current_FunctionDeclaration_Uint8ArrayToArrayBuffer(
    get_old_FunctionDeclaration_Uint8ArrayToArrayBuffer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_Uint8ArrayToArrayBuffer": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_Uint8ArrayToArrayBuffer():
    TypeOnly<typeof current.Uint8ArrayToArrayBuffer>;
declare function use_old_FunctionDeclaration_Uint8ArrayToArrayBuffer(
    use: TypeOnly<typeof old.Uint8ArrayToArrayBuffer>);
use_old_FunctionDeclaration_Uint8ArrayToArrayBuffer(
    get_current_FunctionDeclaration_Uint8ArrayToArrayBuffer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_Uint8ArrayToString": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_Uint8ArrayToString():
    TypeOnly<typeof old.Uint8ArrayToString>;
declare function use_current_FunctionDeclaration_Uint8ArrayToString(
    use: TypeOnly<typeof current.Uint8ArrayToString>);
use_current_FunctionDeclaration_Uint8ArrayToString(
    get_old_FunctionDeclaration_Uint8ArrayToString());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_Uint8ArrayToString": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_Uint8ArrayToString():
    TypeOnly<typeof current.Uint8ArrayToString>;
declare function use_old_FunctionDeclaration_Uint8ArrayToString(
    use: TypeOnly<typeof old.Uint8ArrayToString>);
use_old_FunctionDeclaration_Uint8ArrayToString(
    get_current_FunctionDeclaration_Uint8ArrayToString());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_unreachableCase": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_unreachableCase():
    TypeOnly<typeof old.unreachableCase>;
declare function use_current_FunctionDeclaration_unreachableCase(
    use: TypeOnly<typeof current.unreachableCase>);
use_current_FunctionDeclaration_unreachableCase(
    get_old_FunctionDeclaration_unreachableCase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_unreachableCase": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_unreachableCase():
    TypeOnly<typeof current.unreachableCase>;
declare function use_old_FunctionDeclaration_unreachableCase(
    use: TypeOnly<typeof old.unreachableCase>);
use_old_FunctionDeclaration_unreachableCase(
    get_current_FunctionDeclaration_unreachableCase());
