/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type * as old from "@fluidframework/protocol-definitions-previous";

import type * as current from "../../index.js";

// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ConnectionMode": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ConnectionMode():
    TypeOnly<old.ConnectionMode>;
declare function use_current_TypeAliasDeclaration_ConnectionMode(
    use: TypeOnly<current.ConnectionMode>): void;
use_current_TypeAliasDeclaration_ConnectionMode(
    get_old_TypeAliasDeclaration_ConnectionMode());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ConnectionMode": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ConnectionMode():
    TypeOnly<current.ConnectionMode>;
declare function use_old_TypeAliasDeclaration_ConnectionMode(
    use: TypeOnly<old.ConnectionMode>): void;
use_old_TypeAliasDeclaration_ConnectionMode(
    get_current_TypeAliasDeclaration_ConnectionMode());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_FileMode": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_FileMode():
    TypeOnly<old.FileMode>;
declare function use_current_EnumDeclaration_FileMode(
    use: TypeOnly<current.FileMode>): void;
use_current_EnumDeclaration_FileMode(
    get_old_EnumDeclaration_FileMode());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_FileMode": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_FileMode():
    TypeOnly<current.FileMode>;
declare function use_old_EnumDeclaration_FileMode(
    use: TypeOnly<old.FileMode>): void;
use_old_EnumDeclaration_FileMode(
    get_current_EnumDeclaration_FileMode());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IActorClient": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IActorClient():
    TypeOnly<old.IActorClient>;
declare function use_current_InterfaceDeclaration_IActorClient(
    use: TypeOnly<current.IActorClient>): void;
use_current_InterfaceDeclaration_IActorClient(
    get_old_InterfaceDeclaration_IActorClient());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IActorClient": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IActorClient():
    TypeOnly<current.IActorClient>;
declare function use_old_InterfaceDeclaration_IActorClient(
    use: TypeOnly<old.IActorClient>): void;
use_old_InterfaceDeclaration_IActorClient(
    get_current_InterfaceDeclaration_IActorClient());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IApprovedProposal": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IApprovedProposal():
    TypeOnly<old.IApprovedProposal>;
declare function use_current_TypeAliasDeclaration_IApprovedProposal(
    use: TypeOnly<current.IApprovedProposal>): void;
use_current_TypeAliasDeclaration_IApprovedProposal(
    get_old_TypeAliasDeclaration_IApprovedProposal());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IApprovedProposal": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IApprovedProposal():
    TypeOnly<current.IApprovedProposal>;
declare function use_old_TypeAliasDeclaration_IApprovedProposal(
    use: TypeOnly<old.IApprovedProposal>): void;
use_old_TypeAliasDeclaration_IApprovedProposal(
    get_current_TypeAliasDeclaration_IApprovedProposal());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAttachment": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IAttachment():
    TypeOnly<old.IAttachment>;
declare function use_current_InterfaceDeclaration_IAttachment(
    use: TypeOnly<current.IAttachment>): void;
use_current_InterfaceDeclaration_IAttachment(
    get_old_InterfaceDeclaration_IAttachment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAttachment": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IAttachment():
    TypeOnly<current.IAttachment>;
declare function use_old_InterfaceDeclaration_IAttachment(
    use: TypeOnly<old.IAttachment>): void;
use_old_InterfaceDeclaration_IAttachment(
    get_current_InterfaceDeclaration_IAttachment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IBlob": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IBlob():
    TypeOnly<old.IBlob>;
declare function use_current_InterfaceDeclaration_IBlob(
    use: TypeOnly<current.IBlob>): void;
use_current_InterfaceDeclaration_IBlob(
    get_old_InterfaceDeclaration_IBlob());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IBlob": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IBlob():
    TypeOnly<current.IBlob>;
declare function use_old_InterfaceDeclaration_IBlob(
    use: TypeOnly<old.IBlob>): void;
use_old_InterfaceDeclaration_IBlob(
    get_current_InterfaceDeclaration_IBlob());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IBranchOrigin": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IBranchOrigin():
    TypeOnly<old.IBranchOrigin>;
declare function use_current_InterfaceDeclaration_IBranchOrigin(
    use: TypeOnly<current.IBranchOrigin>): void;
use_current_InterfaceDeclaration_IBranchOrigin(
    get_old_InterfaceDeclaration_IBranchOrigin());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IBranchOrigin": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IBranchOrigin():
    TypeOnly<current.IBranchOrigin>;
declare function use_old_InterfaceDeclaration_IBranchOrigin(
    use: TypeOnly<old.IBranchOrigin>): void;
use_old_InterfaceDeclaration_IBranchOrigin(
    get_current_InterfaceDeclaration_IBranchOrigin());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICapabilities": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ICapabilities():
    TypeOnly<old.ICapabilities>;
declare function use_current_InterfaceDeclaration_ICapabilities(
    use: TypeOnly<current.ICapabilities>): void;
use_current_InterfaceDeclaration_ICapabilities(
    get_old_InterfaceDeclaration_ICapabilities());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICapabilities": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ICapabilities():
    TypeOnly<current.ICapabilities>;
declare function use_old_InterfaceDeclaration_ICapabilities(
    use: TypeOnly<old.ICapabilities>): void;
use_old_InterfaceDeclaration_ICapabilities(
    get_current_InterfaceDeclaration_ICapabilities());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IClient": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IClient():
    TypeOnly<old.IClient>;
declare function use_current_InterfaceDeclaration_IClient(
    use: TypeOnly<current.IClient>): void;
use_current_InterfaceDeclaration_IClient(
    get_old_InterfaceDeclaration_IClient());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IClient": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IClient():
    TypeOnly<current.IClient>;
declare function use_old_InterfaceDeclaration_IClient(
    use: TypeOnly<old.IClient>): void;
use_old_InterfaceDeclaration_IClient(
    get_current_InterfaceDeclaration_IClient());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IClientConfiguration": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IClientConfiguration():
    TypeOnly<old.IClientConfiguration>;
declare function use_current_InterfaceDeclaration_IClientConfiguration(
    use: TypeOnly<current.IClientConfiguration>): void;
use_current_InterfaceDeclaration_IClientConfiguration(
    get_old_InterfaceDeclaration_IClientConfiguration());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IClientConfiguration": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IClientConfiguration():
    TypeOnly<current.IClientConfiguration>;
declare function use_old_InterfaceDeclaration_IClientConfiguration(
    use: TypeOnly<old.IClientConfiguration>): void;
use_old_InterfaceDeclaration_IClientConfiguration(
    get_current_InterfaceDeclaration_IClientConfiguration());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IClientDetails": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IClientDetails():
    TypeOnly<old.IClientDetails>;
declare function use_current_InterfaceDeclaration_IClientDetails(
    use: TypeOnly<current.IClientDetails>): void;
use_current_InterfaceDeclaration_IClientDetails(
    get_old_InterfaceDeclaration_IClientDetails());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IClientDetails": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IClientDetails():
    TypeOnly<current.IClientDetails>;
declare function use_old_InterfaceDeclaration_IClientDetails(
    use: TypeOnly<old.IClientDetails>): void;
use_old_InterfaceDeclaration_IClientDetails(
    get_current_InterfaceDeclaration_IClientDetails());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IClientJoin": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IClientJoin():
    TypeOnly<old.IClientJoin>;
declare function use_current_InterfaceDeclaration_IClientJoin(
    use: TypeOnly<current.IClientJoin>): void;
use_current_InterfaceDeclaration_IClientJoin(
    get_old_InterfaceDeclaration_IClientJoin());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IClientJoin": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IClientJoin():
    TypeOnly<current.IClientJoin>;
declare function use_old_InterfaceDeclaration_IClientJoin(
    use: TypeOnly<old.IClientJoin>): void;
use_old_InterfaceDeclaration_IClientJoin(
    get_current_InterfaceDeclaration_IClientJoin());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ICommittedProposal": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ICommittedProposal():
    TypeOnly<old.ICommittedProposal>;
declare function use_current_TypeAliasDeclaration_ICommittedProposal(
    use: TypeOnly<current.ICommittedProposal>): void;
use_current_TypeAliasDeclaration_ICommittedProposal(
    get_old_TypeAliasDeclaration_ICommittedProposal());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ICommittedProposal": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ICommittedProposal():
    TypeOnly<current.ICommittedProposal>;
declare function use_old_TypeAliasDeclaration_ICommittedProposal(
    use: TypeOnly<old.ICommittedProposal>): void;
use_old_TypeAliasDeclaration_ICommittedProposal(
    get_current_TypeAliasDeclaration_ICommittedProposal());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConnect": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IConnect():
    TypeOnly<old.IConnect>;
declare function use_current_InterfaceDeclaration_IConnect(
    use: TypeOnly<current.IConnect>): void;
use_current_InterfaceDeclaration_IConnect(
    get_old_InterfaceDeclaration_IConnect());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConnect": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IConnect():
    TypeOnly<current.IConnect>;
declare function use_old_InterfaceDeclaration_IConnect(
    use: TypeOnly<old.IConnect>): void;
use_old_InterfaceDeclaration_IConnect(
    get_current_InterfaceDeclaration_IConnect());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConnected": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IConnected():
    TypeOnly<old.IConnected>;
declare function use_current_InterfaceDeclaration_IConnected(
    use: TypeOnly<current.IConnected>): void;
use_current_InterfaceDeclaration_IConnected(
    get_old_InterfaceDeclaration_IConnected());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConnected": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IConnected():
    TypeOnly<current.IConnected>;
declare function use_old_InterfaceDeclaration_IConnected(
    use: TypeOnly<old.IConnected>): void;
use_old_InterfaceDeclaration_IConnected(
    get_current_InterfaceDeclaration_IConnected());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICreateBlobResponse": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ICreateBlobResponse():
    TypeOnly<old.ICreateBlobResponse>;
declare function use_current_InterfaceDeclaration_ICreateBlobResponse(
    use: TypeOnly<current.ICreateBlobResponse>): void;
use_current_InterfaceDeclaration_ICreateBlobResponse(
    get_old_InterfaceDeclaration_ICreateBlobResponse());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICreateBlobResponse": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ICreateBlobResponse():
    TypeOnly<current.ICreateBlobResponse>;
declare function use_old_InterfaceDeclaration_ICreateBlobResponse(
    use: TypeOnly<old.ICreateBlobResponse>): void;
use_old_InterfaceDeclaration_ICreateBlobResponse(
    get_current_InterfaceDeclaration_ICreateBlobResponse());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentAttributes": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentAttributes():
    TypeOnly<old.IDocumentAttributes>;
declare function use_current_InterfaceDeclaration_IDocumentAttributes(
    use: TypeOnly<current.IDocumentAttributes>): void;
use_current_InterfaceDeclaration_IDocumentAttributes(
    get_old_InterfaceDeclaration_IDocumentAttributes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentAttributes": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentAttributes():
    TypeOnly<current.IDocumentAttributes>;
declare function use_old_InterfaceDeclaration_IDocumentAttributes(
    use: TypeOnly<old.IDocumentAttributes>): void;
use_old_InterfaceDeclaration_IDocumentAttributes(
    get_current_InterfaceDeclaration_IDocumentAttributes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentMessage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentMessage():
    TypeOnly<old.IDocumentMessage>;
declare function use_current_InterfaceDeclaration_IDocumentMessage(
    use: TypeOnly<current.IDocumentMessage>): void;
use_current_InterfaceDeclaration_IDocumentMessage(
    get_old_InterfaceDeclaration_IDocumentMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentMessage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentMessage():
    TypeOnly<current.IDocumentMessage>;
declare function use_old_InterfaceDeclaration_IDocumentMessage(
    use: TypeOnly<old.IDocumentMessage>): void;
use_old_InterfaceDeclaration_IDocumentMessage(
    get_current_InterfaceDeclaration_IDocumentMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentSystemMessage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentSystemMessage():
    TypeOnly<old.IDocumentSystemMessage>;
declare function use_current_InterfaceDeclaration_IDocumentSystemMessage(
    use: TypeOnly<current.IDocumentSystemMessage>): void;
use_current_InterfaceDeclaration_IDocumentSystemMessage(
    get_old_InterfaceDeclaration_IDocumentSystemMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentSystemMessage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentSystemMessage():
    TypeOnly<current.IDocumentSystemMessage>;
declare function use_old_InterfaceDeclaration_IDocumentSystemMessage(
    use: TypeOnly<old.IDocumentSystemMessage>): void;
use_old_InterfaceDeclaration_IDocumentSystemMessage(
    get_current_InterfaceDeclaration_IDocumentSystemMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_INack": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_INack():
    TypeOnly<old.INack>;
declare function use_current_InterfaceDeclaration_INack(
    use: TypeOnly<current.INack>): void;
use_current_InterfaceDeclaration_INack(
    get_old_InterfaceDeclaration_INack());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_INack": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_INack():
    TypeOnly<current.INack>;
declare function use_old_InterfaceDeclaration_INack(
    use: TypeOnly<old.INack>): void;
use_old_InterfaceDeclaration_INack(
    get_current_InterfaceDeclaration_INack());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_INackContent": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_INackContent():
    TypeOnly<old.INackContent>;
declare function use_current_InterfaceDeclaration_INackContent(
    use: TypeOnly<current.INackContent>): void;
use_current_InterfaceDeclaration_INackContent(
    get_old_InterfaceDeclaration_INackContent());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_INackContent": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_INackContent():
    TypeOnly<current.INackContent>;
declare function use_old_InterfaceDeclaration_INackContent(
    use: TypeOnly<old.INackContent>): void;
use_old_InterfaceDeclaration_INackContent(
    get_current_InterfaceDeclaration_INackContent());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProcessMessageResult": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProcessMessageResult():
    TypeOnly<old.IProcessMessageResult>;
declare function use_current_InterfaceDeclaration_IProcessMessageResult(
    use: TypeOnly<current.IProcessMessageResult>): void;
use_current_InterfaceDeclaration_IProcessMessageResult(
    get_old_InterfaceDeclaration_IProcessMessageResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProcessMessageResult": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProcessMessageResult():
    TypeOnly<current.IProcessMessageResult>;
declare function use_old_InterfaceDeclaration_IProcessMessageResult(
    use: TypeOnly<old.IProcessMessageResult>): void;
use_old_InterfaceDeclaration_IProcessMessageResult(
    get_current_InterfaceDeclaration_IProcessMessageResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProposal": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProposal():
    TypeOnly<old.IProposal>;
declare function use_current_InterfaceDeclaration_IProposal(
    use: TypeOnly<current.IProposal>): void;
use_current_InterfaceDeclaration_IProposal(
    get_old_InterfaceDeclaration_IProposal());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProposal": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProposal():
    TypeOnly<current.IProposal>;
declare function use_old_InterfaceDeclaration_IProposal(
    use: TypeOnly<old.IProposal>): void;
use_old_InterfaceDeclaration_IProposal(
    get_current_InterfaceDeclaration_IProposal());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProtocolState": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProtocolState():
    TypeOnly<old.IProtocolState>;
declare function use_current_InterfaceDeclaration_IProtocolState(
    use: TypeOnly<current.IProtocolState>): void;
use_current_InterfaceDeclaration_IProtocolState(
    get_old_InterfaceDeclaration_IProtocolState());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProtocolState": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProtocolState():
    TypeOnly<current.IProtocolState>;
declare function use_old_InterfaceDeclaration_IProtocolState(
    use: TypeOnly<old.IProtocolState>): void;
use_old_InterfaceDeclaration_IProtocolState(
    get_current_InterfaceDeclaration_IProtocolState());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IQuorum": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IQuorum():
    TypeOnly<old.IQuorum>;
declare function use_current_InterfaceDeclaration_IQuorum(
    use: TypeOnly<current.IQuorum>): void;
use_current_InterfaceDeclaration_IQuorum(
    get_old_InterfaceDeclaration_IQuorum());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IQuorum": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IQuorum():
    TypeOnly<current.IQuorum>;
declare function use_old_InterfaceDeclaration_IQuorum(
    use: TypeOnly<old.IQuorum>): void;
use_old_InterfaceDeclaration_IQuorum(
    get_current_InterfaceDeclaration_IQuorum());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IQuorumClients": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IQuorumClients():
    TypeOnly<old.IQuorumClients>;
declare function use_current_InterfaceDeclaration_IQuorumClients(
    use: TypeOnly<current.IQuorumClients>): void;
use_current_InterfaceDeclaration_IQuorumClients(
    get_old_InterfaceDeclaration_IQuorumClients());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IQuorumClients": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IQuorumClients():
    TypeOnly<current.IQuorumClients>;
declare function use_old_InterfaceDeclaration_IQuorumClients(
    use: TypeOnly<old.IQuorumClients>): void;
use_old_InterfaceDeclaration_IQuorumClients(
    get_current_InterfaceDeclaration_IQuorumClients());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IQuorumClientsEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IQuorumClientsEvents():
    TypeOnly<old.IQuorumClientsEvents>;
declare function use_current_InterfaceDeclaration_IQuorumClientsEvents(
    use: TypeOnly<current.IQuorumClientsEvents>): void;
use_current_InterfaceDeclaration_IQuorumClientsEvents(
    get_old_InterfaceDeclaration_IQuorumClientsEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IQuorumClientsEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IQuorumClientsEvents():
    TypeOnly<current.IQuorumClientsEvents>;
declare function use_old_InterfaceDeclaration_IQuorumClientsEvents(
    use: TypeOnly<old.IQuorumClientsEvents>): void;
use_old_InterfaceDeclaration_IQuorumClientsEvents(
    get_current_InterfaceDeclaration_IQuorumClientsEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IQuorumEvents": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IQuorumEvents():
    TypeOnly<old.IQuorumEvents>;
declare function use_current_TypeAliasDeclaration_IQuorumEvents(
    use: TypeOnly<current.IQuorumEvents>): void;
use_current_TypeAliasDeclaration_IQuorumEvents(
    get_old_TypeAliasDeclaration_IQuorumEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IQuorumEvents": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IQuorumEvents():
    TypeOnly<current.IQuorumEvents>;
declare function use_old_TypeAliasDeclaration_IQuorumEvents(
    use: TypeOnly<old.IQuorumEvents>): void;
use_old_TypeAliasDeclaration_IQuorumEvents(
    get_current_TypeAliasDeclaration_IQuorumEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IQuorumProposals": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IQuorumProposals():
    TypeOnly<old.IQuorumProposals>;
declare function use_current_InterfaceDeclaration_IQuorumProposals(
    use: TypeOnly<current.IQuorumProposals>): void;
use_current_InterfaceDeclaration_IQuorumProposals(
    get_old_InterfaceDeclaration_IQuorumProposals());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IQuorumProposals": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IQuorumProposals():
    TypeOnly<current.IQuorumProposals>;
declare function use_old_InterfaceDeclaration_IQuorumProposals(
    use: TypeOnly<old.IQuorumProposals>): void;
use_old_InterfaceDeclaration_IQuorumProposals(
    get_current_InterfaceDeclaration_IQuorumProposals());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IQuorumProposalsEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IQuorumProposalsEvents():
    TypeOnly<old.IQuorumProposalsEvents>;
declare function use_current_InterfaceDeclaration_IQuorumProposalsEvents(
    use: TypeOnly<current.IQuorumProposalsEvents>): void;
use_current_InterfaceDeclaration_IQuorumProposalsEvents(
    get_old_InterfaceDeclaration_IQuorumProposalsEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IQuorumProposalsEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IQuorumProposalsEvents():
    TypeOnly<current.IQuorumProposalsEvents>;
declare function use_old_InterfaceDeclaration_IQuorumProposalsEvents(
    use: TypeOnly<old.IQuorumProposalsEvents>): void;
use_old_InterfaceDeclaration_IQuorumProposalsEvents(
    get_current_InterfaceDeclaration_IQuorumProposalsEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ISentSignalMessage": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ISentSignalMessage():
    TypeOnly<old.ISentSignalMessage>;
declare function use_current_TypeAliasDeclaration_ISentSignalMessage(
    use: TypeOnly<current.ISentSignalMessage>): void;
use_current_TypeAliasDeclaration_ISentSignalMessage(
    get_old_TypeAliasDeclaration_ISentSignalMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ISentSignalMessage": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ISentSignalMessage():
    TypeOnly<current.ISentSignalMessage>;
declare function use_old_TypeAliasDeclaration_ISentSignalMessage(
    use: TypeOnly<old.ISentSignalMessage>): void;
use_old_TypeAliasDeclaration_ISentSignalMessage(
    get_current_TypeAliasDeclaration_ISentSignalMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISequencedClient": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISequencedClient():
    TypeOnly<old.ISequencedClient>;
declare function use_current_InterfaceDeclaration_ISequencedClient(
    use: TypeOnly<current.ISequencedClient>): void;
use_current_InterfaceDeclaration_ISequencedClient(
    get_old_InterfaceDeclaration_ISequencedClient());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISequencedClient": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISequencedClient():
    TypeOnly<current.ISequencedClient>;
declare function use_old_InterfaceDeclaration_ISequencedClient(
    use: TypeOnly<old.ISequencedClient>): void;
use_old_InterfaceDeclaration_ISequencedClient(
    get_current_InterfaceDeclaration_ISequencedClient());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISequencedDocumentAugmentedMessage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISequencedDocumentAugmentedMessage():
    TypeOnly<old.ISequencedDocumentAugmentedMessage>;
declare function use_current_InterfaceDeclaration_ISequencedDocumentAugmentedMessage(
    use: TypeOnly<current.ISequencedDocumentAugmentedMessage>): void;
use_current_InterfaceDeclaration_ISequencedDocumentAugmentedMessage(
    get_old_InterfaceDeclaration_ISequencedDocumentAugmentedMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISequencedDocumentAugmentedMessage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISequencedDocumentAugmentedMessage():
    TypeOnly<current.ISequencedDocumentAugmentedMessage>;
declare function use_old_InterfaceDeclaration_ISequencedDocumentAugmentedMessage(
    use: TypeOnly<old.ISequencedDocumentAugmentedMessage>): void;
use_old_InterfaceDeclaration_ISequencedDocumentAugmentedMessage(
    get_current_InterfaceDeclaration_ISequencedDocumentAugmentedMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISequencedDocumentMessage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISequencedDocumentMessage():
    TypeOnly<old.ISequencedDocumentMessage>;
declare function use_current_InterfaceDeclaration_ISequencedDocumentMessage(
    use: TypeOnly<current.ISequencedDocumentMessage>): void;
use_current_InterfaceDeclaration_ISequencedDocumentMessage(
    get_old_InterfaceDeclaration_ISequencedDocumentMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISequencedDocumentMessage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISequencedDocumentMessage():
    TypeOnly<current.ISequencedDocumentMessage>;
declare function use_old_InterfaceDeclaration_ISequencedDocumentMessage(
    use: TypeOnly<old.ISequencedDocumentMessage>): void;
use_old_InterfaceDeclaration_ISequencedDocumentMessage(
    get_current_InterfaceDeclaration_ISequencedDocumentMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ISequencedDocumentMessageExperimental": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ISequencedDocumentMessageExperimental():
    TypeOnly<old.ISequencedDocumentMessageExperimental>;
declare function use_current_TypeAliasDeclaration_ISequencedDocumentMessageExperimental(
    use: TypeOnly<current.ISequencedDocumentMessageExperimental>): void;
use_current_TypeAliasDeclaration_ISequencedDocumentMessageExperimental(
    get_old_TypeAliasDeclaration_ISequencedDocumentMessageExperimental());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ISequencedDocumentMessageExperimental": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ISequencedDocumentMessageExperimental():
    TypeOnly<current.ISequencedDocumentMessageExperimental>;
declare function use_old_TypeAliasDeclaration_ISequencedDocumentMessageExperimental(
    use: TypeOnly<old.ISequencedDocumentMessageExperimental>): void;
use_old_TypeAliasDeclaration_ISequencedDocumentMessageExperimental(
    get_current_TypeAliasDeclaration_ISequencedDocumentMessageExperimental());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISequencedDocumentSystemMessage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISequencedDocumentSystemMessage():
    TypeOnly<old.ISequencedDocumentSystemMessage>;
declare function use_current_InterfaceDeclaration_ISequencedDocumentSystemMessage(
    use: TypeOnly<current.ISequencedDocumentSystemMessage>): void;
use_current_InterfaceDeclaration_ISequencedDocumentSystemMessage(
    get_old_InterfaceDeclaration_ISequencedDocumentSystemMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISequencedDocumentSystemMessage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISequencedDocumentSystemMessage():
    TypeOnly<current.ISequencedDocumentSystemMessage>;
declare function use_old_InterfaceDeclaration_ISequencedDocumentSystemMessage(
    use: TypeOnly<old.ISequencedDocumentSystemMessage>): void;
use_old_InterfaceDeclaration_ISequencedDocumentSystemMessage(
    get_current_InterfaceDeclaration_ISequencedDocumentSystemMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ISequencedProposal": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ISequencedProposal():
    TypeOnly<old.ISequencedProposal>;
declare function use_current_TypeAliasDeclaration_ISequencedProposal(
    use: TypeOnly<current.ISequencedProposal>): void;
use_current_TypeAliasDeclaration_ISequencedProposal(
    get_old_TypeAliasDeclaration_ISequencedProposal());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ISequencedProposal": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ISequencedProposal():
    TypeOnly<current.ISequencedProposal>;
declare function use_old_TypeAliasDeclaration_ISequencedProposal(
    use: TypeOnly<old.ISequencedProposal>): void;
use_old_TypeAliasDeclaration_ISequencedProposal(
    get_current_TypeAliasDeclaration_ISequencedProposal());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IServerError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IServerError():
    TypeOnly<old.IServerError>;
declare function use_current_InterfaceDeclaration_IServerError(
    use: TypeOnly<current.IServerError>): void;
use_current_InterfaceDeclaration_IServerError(
    get_old_InterfaceDeclaration_IServerError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IServerError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IServerError():
    TypeOnly<current.IServerError>;
declare function use_old_InterfaceDeclaration_IServerError(
    use: TypeOnly<old.IServerError>): void;
use_old_InterfaceDeclaration_IServerError(
    get_current_InterfaceDeclaration_IServerError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISignalClient": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISignalClient():
    TypeOnly<old.ISignalClient>;
declare function use_current_InterfaceDeclaration_ISignalClient(
    use: TypeOnly<current.ISignalClient>): void;
use_current_InterfaceDeclaration_ISignalClient(
    get_old_InterfaceDeclaration_ISignalClient());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISignalClient": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISignalClient():
    TypeOnly<current.ISignalClient>;
declare function use_old_InterfaceDeclaration_ISignalClient(
    use: TypeOnly<old.ISignalClient>): void;
use_old_InterfaceDeclaration_ISignalClient(
    get_current_InterfaceDeclaration_ISignalClient());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISignalMessage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISignalMessage():
    TypeOnly<old.ISignalMessage>;
declare function use_current_InterfaceDeclaration_ISignalMessage(
    use: TypeOnly<current.ISignalMessage>): void;
use_current_InterfaceDeclaration_ISignalMessage(
    get_old_InterfaceDeclaration_ISignalMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISignalMessage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISignalMessage():
    TypeOnly<current.ISignalMessage>;
declare function use_old_InterfaceDeclaration_ISignalMessage(
    use: TypeOnly<old.ISignalMessage>): void;
use_old_InterfaceDeclaration_ISignalMessage(
    get_current_InterfaceDeclaration_ISignalMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISignalMessageBase": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISignalMessageBase():
    TypeOnly<old.ISignalMessageBase>;
declare function use_current_InterfaceDeclaration_ISignalMessageBase(
    use: TypeOnly<current.ISignalMessageBase>): void;
use_current_InterfaceDeclaration_ISignalMessageBase(
    get_old_InterfaceDeclaration_ISignalMessageBase());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISignalMessageBase": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISignalMessageBase():
    TypeOnly<current.ISignalMessageBase>;
declare function use_old_InterfaceDeclaration_ISignalMessageBase(
    use: TypeOnly<old.ISignalMessageBase>): void;
use_old_InterfaceDeclaration_ISignalMessageBase(
    get_current_InterfaceDeclaration_ISignalMessageBase());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISnapshotTree": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISnapshotTree():
    TypeOnly<old.ISnapshotTree>;
declare function use_current_InterfaceDeclaration_ISnapshotTree(
    use: TypeOnly<current.ISnapshotTree>): void;
use_current_InterfaceDeclaration_ISnapshotTree(
    get_old_InterfaceDeclaration_ISnapshotTree());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISnapshotTree": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISnapshotTree():
    TypeOnly<current.ISnapshotTree>;
declare function use_old_InterfaceDeclaration_ISnapshotTree(
    use: TypeOnly<old.ISnapshotTree>): void;
use_old_InterfaceDeclaration_ISnapshotTree(
    get_current_InterfaceDeclaration_ISnapshotTree());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISnapshotTreeEx": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISnapshotTreeEx():
    TypeOnly<old.ISnapshotTreeEx>;
declare function use_current_InterfaceDeclaration_ISnapshotTreeEx(
    use: TypeOnly<current.ISnapshotTreeEx>): void;
use_current_InterfaceDeclaration_ISnapshotTreeEx(
    get_old_InterfaceDeclaration_ISnapshotTreeEx());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISnapshotTreeEx": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISnapshotTreeEx():
    TypeOnly<current.ISnapshotTreeEx>;
declare function use_old_InterfaceDeclaration_ISnapshotTreeEx(
    use: TypeOnly<old.ISnapshotTreeEx>): void;
use_old_InterfaceDeclaration_ISnapshotTreeEx(
    get_current_InterfaceDeclaration_ISnapshotTreeEx());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryAck": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryAck():
    TypeOnly<old.ISummaryAck>;
declare function use_current_InterfaceDeclaration_ISummaryAck(
    use: TypeOnly<current.ISummaryAck>): void;
use_current_InterfaceDeclaration_ISummaryAck(
    get_old_InterfaceDeclaration_ISummaryAck());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryAck": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryAck():
    TypeOnly<current.ISummaryAck>;
declare function use_old_InterfaceDeclaration_ISummaryAck(
    use: TypeOnly<old.ISummaryAck>): void;
use_old_InterfaceDeclaration_ISummaryAck(
    get_current_InterfaceDeclaration_ISummaryAck());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryAttachment": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryAttachment():
    TypeOnly<old.ISummaryAttachment>;
declare function use_current_InterfaceDeclaration_ISummaryAttachment(
    use: TypeOnly<current.ISummaryAttachment>): void;
use_current_InterfaceDeclaration_ISummaryAttachment(
    get_old_InterfaceDeclaration_ISummaryAttachment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryAttachment": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryAttachment():
    TypeOnly<current.ISummaryAttachment>;
declare function use_old_InterfaceDeclaration_ISummaryAttachment(
    use: TypeOnly<old.ISummaryAttachment>): void;
use_old_InterfaceDeclaration_ISummaryAttachment(
    get_current_InterfaceDeclaration_ISummaryAttachment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryBlob": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryBlob():
    TypeOnly<old.ISummaryBlob>;
declare function use_current_InterfaceDeclaration_ISummaryBlob(
    use: TypeOnly<current.ISummaryBlob>): void;
use_current_InterfaceDeclaration_ISummaryBlob(
    get_old_InterfaceDeclaration_ISummaryBlob());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryBlob": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryBlob():
    TypeOnly<current.ISummaryBlob>;
declare function use_old_InterfaceDeclaration_ISummaryBlob(
    use: TypeOnly<old.ISummaryBlob>): void;
use_old_InterfaceDeclaration_ISummaryBlob(
    get_current_InterfaceDeclaration_ISummaryBlob());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryContent": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryContent():
    TypeOnly<old.ISummaryContent>;
declare function use_current_InterfaceDeclaration_ISummaryContent(
    use: TypeOnly<current.ISummaryContent>): void;
use_current_InterfaceDeclaration_ISummaryContent(
    get_old_InterfaceDeclaration_ISummaryContent());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryContent": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryContent():
    TypeOnly<current.ISummaryContent>;
declare function use_old_InterfaceDeclaration_ISummaryContent(
    use: TypeOnly<old.ISummaryContent>): void;
use_old_InterfaceDeclaration_ISummaryContent(
    get_current_InterfaceDeclaration_ISummaryContent());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryHandle": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryHandle():
    TypeOnly<old.ISummaryHandle>;
declare function use_current_InterfaceDeclaration_ISummaryHandle(
    use: TypeOnly<current.ISummaryHandle>): void;
use_current_InterfaceDeclaration_ISummaryHandle(
    get_old_InterfaceDeclaration_ISummaryHandle());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryHandle": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryHandle():
    TypeOnly<current.ISummaryHandle>;
declare function use_old_InterfaceDeclaration_ISummaryHandle(
    use: TypeOnly<old.ISummaryHandle>): void;
use_old_InterfaceDeclaration_ISummaryHandle(
    get_current_InterfaceDeclaration_ISummaryHandle());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryNack": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryNack():
    TypeOnly<old.ISummaryNack>;
declare function use_current_InterfaceDeclaration_ISummaryNack(
    use: TypeOnly<current.ISummaryNack>): void;
use_current_InterfaceDeclaration_ISummaryNack(
    get_old_InterfaceDeclaration_ISummaryNack());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryNack": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryNack():
    TypeOnly<current.ISummaryNack>;
declare function use_old_InterfaceDeclaration_ISummaryNack(
    use: TypeOnly<old.ISummaryNack>): void;
use_old_InterfaceDeclaration_ISummaryNack(
    get_current_InterfaceDeclaration_ISummaryNack());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryProposal": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryProposal():
    TypeOnly<old.ISummaryProposal>;
declare function use_current_InterfaceDeclaration_ISummaryProposal(
    use: TypeOnly<current.ISummaryProposal>): void;
use_current_InterfaceDeclaration_ISummaryProposal(
    get_old_InterfaceDeclaration_ISummaryProposal());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryProposal": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryProposal():
    TypeOnly<current.ISummaryProposal>;
declare function use_old_InterfaceDeclaration_ISummaryProposal(
    use: TypeOnly<old.ISummaryProposal>): void;
use_old_InterfaceDeclaration_ISummaryProposal(
    get_current_InterfaceDeclaration_ISummaryProposal());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryTokenClaims": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryTokenClaims():
    TypeOnly<old.ISummaryTokenClaims>;
declare function use_current_InterfaceDeclaration_ISummaryTokenClaims(
    use: TypeOnly<current.ISummaryTokenClaims>): void;
use_current_InterfaceDeclaration_ISummaryTokenClaims(
    get_old_InterfaceDeclaration_ISummaryTokenClaims());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryTokenClaims": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryTokenClaims():
    TypeOnly<current.ISummaryTokenClaims>;
declare function use_old_InterfaceDeclaration_ISummaryTokenClaims(
    use: TypeOnly<old.ISummaryTokenClaims>): void;
use_old_InterfaceDeclaration_ISummaryTokenClaims(
    get_current_InterfaceDeclaration_ISummaryTokenClaims());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryTree": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryTree():
    TypeOnly<old.ISummaryTree>;
declare function use_current_InterfaceDeclaration_ISummaryTree(
    use: TypeOnly<current.ISummaryTree>): void;
use_current_InterfaceDeclaration_ISummaryTree(
    get_old_InterfaceDeclaration_ISummaryTree());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryTree": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryTree():
    TypeOnly<current.ISummaryTree>;
declare function use_old_InterfaceDeclaration_ISummaryTree(
    use: TypeOnly<old.ISummaryTree>): void;
use_old_InterfaceDeclaration_ISummaryTree(
    get_current_InterfaceDeclaration_ISummaryTree());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITokenClaims": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITokenClaims():
    TypeOnly<old.ITokenClaims>;
declare function use_current_InterfaceDeclaration_ITokenClaims(
    use: TypeOnly<current.ITokenClaims>): void;
use_current_InterfaceDeclaration_ITokenClaims(
    get_old_InterfaceDeclaration_ITokenClaims());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITokenClaims": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITokenClaims():
    TypeOnly<current.ITokenClaims>;
declare function use_old_InterfaceDeclaration_ITokenClaims(
    use: TypeOnly<old.ITokenClaims>): void;
use_old_InterfaceDeclaration_ITokenClaims(
    get_current_InterfaceDeclaration_ITokenClaims());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITokenProvider": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITokenProvider():
    TypeOnly<old.ITokenProvider>;
declare function use_current_InterfaceDeclaration_ITokenProvider(
    use: TypeOnly<current.ITokenProvider>): void;
use_current_InterfaceDeclaration_ITokenProvider(
    get_old_InterfaceDeclaration_ITokenProvider());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITokenProvider": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITokenProvider():
    TypeOnly<current.ITokenProvider>;
declare function use_old_InterfaceDeclaration_ITokenProvider(
    use: TypeOnly<old.ITokenProvider>): void;
use_old_InterfaceDeclaration_ITokenProvider(
    get_current_InterfaceDeclaration_ITokenProvider());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITokenService": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITokenService():
    TypeOnly<old.ITokenService>;
declare function use_current_InterfaceDeclaration_ITokenService(
    use: TypeOnly<current.ITokenService>): void;
use_current_InterfaceDeclaration_ITokenService(
    get_old_InterfaceDeclaration_ITokenService());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITokenService": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITokenService():
    TypeOnly<current.ITokenService>;
declare function use_old_InterfaceDeclaration_ITokenService(
    use: TypeOnly<old.ITokenService>): void;
use_old_InterfaceDeclaration_ITokenService(
    get_current_InterfaceDeclaration_ITokenService());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITrace": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITrace():
    TypeOnly<old.ITrace>;
declare function use_current_InterfaceDeclaration_ITrace(
    use: TypeOnly<current.ITrace>): void;
use_current_InterfaceDeclaration_ITrace(
    get_old_InterfaceDeclaration_ITrace());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITrace": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITrace():
    TypeOnly<current.ITrace>;
declare function use_old_InterfaceDeclaration_ITrace(
    use: TypeOnly<old.ITrace>): void;
use_old_InterfaceDeclaration_ITrace(
    get_current_InterfaceDeclaration_ITrace());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITree": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITree():
    TypeOnly<old.ITree>;
declare function use_current_InterfaceDeclaration_ITree(
    use: TypeOnly<current.ITree>): void;
use_current_InterfaceDeclaration_ITree(
    get_old_InterfaceDeclaration_ITree());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITree": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITree():
    TypeOnly<current.ITree>;
declare function use_old_InterfaceDeclaration_ITree(
    use: TypeOnly<old.ITree>): void;
use_old_InterfaceDeclaration_ITree(
    get_current_InterfaceDeclaration_ITree());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ITreeEntry": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ITreeEntry():
    TypeOnly<old.ITreeEntry>;
declare function use_current_TypeAliasDeclaration_ITreeEntry(
    use: TypeOnly<current.ITreeEntry>): void;
use_current_TypeAliasDeclaration_ITreeEntry(
    get_old_TypeAliasDeclaration_ITreeEntry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ITreeEntry": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ITreeEntry():
    TypeOnly<current.ITreeEntry>;
declare function use_old_TypeAliasDeclaration_ITreeEntry(
    use: TypeOnly<old.ITreeEntry>): void;
use_old_TypeAliasDeclaration_ITreeEntry(
    get_current_TypeAliasDeclaration_ITreeEntry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IUploadedSummaryDetails": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IUploadedSummaryDetails():
    TypeOnly<old.IUploadedSummaryDetails>;
declare function use_current_InterfaceDeclaration_IUploadedSummaryDetails(
    use: TypeOnly<current.IUploadedSummaryDetails>): void;
use_current_InterfaceDeclaration_IUploadedSummaryDetails(
    get_old_InterfaceDeclaration_IUploadedSummaryDetails());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IUploadedSummaryDetails": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IUploadedSummaryDetails():
    TypeOnly<current.IUploadedSummaryDetails>;
declare function use_old_InterfaceDeclaration_IUploadedSummaryDetails(
    use: TypeOnly<old.IUploadedSummaryDetails>): void;
use_old_InterfaceDeclaration_IUploadedSummaryDetails(
    get_current_InterfaceDeclaration_IUploadedSummaryDetails());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IUser": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IUser():
    TypeOnly<old.IUser>;
declare function use_current_InterfaceDeclaration_IUser(
    use: TypeOnly<current.IUser>): void;
use_current_InterfaceDeclaration_IUser(
    get_old_InterfaceDeclaration_IUser());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IUser": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IUser():
    TypeOnly<current.IUser>;
declare function use_old_InterfaceDeclaration_IUser(
    use: TypeOnly<old.IUser>): void;
use_old_InterfaceDeclaration_IUser(
    get_current_InterfaceDeclaration_IUser());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IVersion": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IVersion():
    TypeOnly<old.IVersion>;
declare function use_current_InterfaceDeclaration_IVersion(
    use: TypeOnly<current.IVersion>): void;
use_current_InterfaceDeclaration_IVersion(
    get_old_InterfaceDeclaration_IVersion());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IVersion": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IVersion():
    TypeOnly<current.IVersion>;
declare function use_old_InterfaceDeclaration_IVersion(
    use: TypeOnly<old.IVersion>): void;
use_old_InterfaceDeclaration_IVersion(
    get_current_InterfaceDeclaration_IVersion());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IsoDate": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IsoDate():
    TypeOnly<old.IsoDate>;
declare function use_current_TypeAliasDeclaration_IsoDate(
    use: TypeOnly<current.IsoDate>): void;
use_current_TypeAliasDeclaration_IsoDate(
    get_old_TypeAliasDeclaration_IsoDate());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IsoDate": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IsoDate():
    TypeOnly<current.IsoDate>;
declare function use_old_TypeAliasDeclaration_IsoDate(
    use: TypeOnly<old.IsoDate>): void;
use_old_TypeAliasDeclaration_IsoDate(
    get_current_TypeAliasDeclaration_IsoDate());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_MessageType": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_MessageType():
    TypeOnly<old.MessageType>;
declare function use_current_EnumDeclaration_MessageType(
    use: TypeOnly<current.MessageType>): void;
use_current_EnumDeclaration_MessageType(
    get_old_EnumDeclaration_MessageType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_MessageType": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_MessageType():
    TypeOnly<current.MessageType>;
declare function use_old_EnumDeclaration_MessageType(
    use: TypeOnly<old.MessageType>): void;
use_old_EnumDeclaration_MessageType(
    get_current_EnumDeclaration_MessageType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_NackErrorType": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_NackErrorType():
    TypeOnly<old.NackErrorType>;
declare function use_current_EnumDeclaration_NackErrorType(
    use: TypeOnly<current.NackErrorType>): void;
use_current_EnumDeclaration_NackErrorType(
    get_old_EnumDeclaration_NackErrorType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_NackErrorType": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_NackErrorType():
    TypeOnly<current.NackErrorType>;
declare function use_old_EnumDeclaration_NackErrorType(
    use: TypeOnly<old.NackErrorType>): void;
use_old_EnumDeclaration_NackErrorType(
    get_current_EnumDeclaration_NackErrorType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_ScopeType": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_ScopeType():
    TypeOnly<old.ScopeType>;
declare function use_current_EnumDeclaration_ScopeType(
    use: TypeOnly<current.ScopeType>): void;
use_current_EnumDeclaration_ScopeType(
    get_old_EnumDeclaration_ScopeType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_ScopeType": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_ScopeType():
    TypeOnly<current.ScopeType>;
declare function use_old_EnumDeclaration_ScopeType(
    use: TypeOnly<old.ScopeType>): void;
use_old_EnumDeclaration_ScopeType(
    get_current_EnumDeclaration_ScopeType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_SignalType": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_SignalType():
    TypeOnly<old.SignalType>;
declare function use_current_EnumDeclaration_SignalType(
    use: TypeOnly<current.SignalType>): void;
use_current_EnumDeclaration_SignalType(
    get_old_EnumDeclaration_SignalType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_SignalType": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_SignalType():
    TypeOnly<current.SignalType>;
declare function use_old_EnumDeclaration_SignalType(
    use: TypeOnly<old.SignalType>): void;
use_old_EnumDeclaration_SignalType(
    get_current_EnumDeclaration_SignalType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummaryObject": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SummaryObject():
    TypeOnly<old.SummaryObject>;
declare function use_current_TypeAliasDeclaration_SummaryObject(
    use: TypeOnly<current.SummaryObject>): void;
use_current_TypeAliasDeclaration_SummaryObject(
    get_old_TypeAliasDeclaration_SummaryObject());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummaryObject": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SummaryObject():
    TypeOnly<current.SummaryObject>;
declare function use_old_TypeAliasDeclaration_SummaryObject(
    use: TypeOnly<old.SummaryObject>): void;
use_old_TypeAliasDeclaration_SummaryObject(
    get_current_TypeAliasDeclaration_SummaryObject());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummaryTree": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SummaryTree():
    TypeOnly<old.SummaryTree>;
declare function use_current_TypeAliasDeclaration_SummaryTree(
    use: TypeOnly<current.SummaryTree>): void;
use_current_TypeAliasDeclaration_SummaryTree(
    get_old_TypeAliasDeclaration_SummaryTree());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummaryTree": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SummaryTree():
    TypeOnly<current.SummaryTree>;
declare function use_old_TypeAliasDeclaration_SummaryTree(
    use: TypeOnly<old.SummaryTree>): void;
use_old_TypeAliasDeclaration_SummaryTree(
    get_current_TypeAliasDeclaration_SummaryTree());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummaryType": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SummaryType():
    TypeOnly<old.SummaryType>;
declare function use_current_TypeAliasDeclaration_SummaryType(
    use: TypeOnly<current.SummaryType>): void;
use_current_TypeAliasDeclaration_SummaryType(
    get_old_TypeAliasDeclaration_SummaryType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummaryType": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SummaryType():
    TypeOnly<current.SummaryType>;
declare function use_old_TypeAliasDeclaration_SummaryType(
    use: TypeOnly<old.SummaryType>): void;
use_old_TypeAliasDeclaration_SummaryType(
    get_current_TypeAliasDeclaration_SummaryType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummaryTypeNoHandle": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SummaryTypeNoHandle():
    TypeOnly<old.SummaryTypeNoHandle>;
declare function use_current_TypeAliasDeclaration_SummaryTypeNoHandle(
    use: TypeOnly<current.SummaryTypeNoHandle>): void;
use_current_TypeAliasDeclaration_SummaryTypeNoHandle(
    get_old_TypeAliasDeclaration_SummaryTypeNoHandle());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummaryTypeNoHandle": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SummaryTypeNoHandle():
    TypeOnly<current.SummaryTypeNoHandle>;
declare function use_old_TypeAliasDeclaration_SummaryTypeNoHandle(
    use: TypeOnly<old.SummaryTypeNoHandle>): void;
use_old_TypeAliasDeclaration_SummaryTypeNoHandle(
    get_current_TypeAliasDeclaration_SummaryTypeNoHandle());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_TreeEntry": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_TreeEntry():
    TypeOnly<old.TreeEntry>;
declare function use_current_EnumDeclaration_TreeEntry(
    use: TypeOnly<current.TreeEntry>): void;
use_current_EnumDeclaration_TreeEntry(
    get_old_EnumDeclaration_TreeEntry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_TreeEntry": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_TreeEntry():
    TypeOnly<current.TreeEntry>;
declare function use_old_EnumDeclaration_TreeEntry(
    use: TypeOnly<old.TreeEntry>): void;
use_old_EnumDeclaration_TreeEntry(
    get_current_EnumDeclaration_TreeEntry());
