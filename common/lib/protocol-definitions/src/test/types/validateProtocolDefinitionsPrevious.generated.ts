/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/protocol-definitions-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_FileMode": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_FileMode = requireAssignableTo<TypeOnly<old.FileMode>, TypeOnly<current.FileMode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_FileMode": {"backCompat": false}
 */
declare type current_as_old_for_Enum_FileMode = requireAssignableTo<TypeOnly<current.FileMode>, TypeOnly<old.FileMode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_MessageType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_MessageType = requireAssignableTo<TypeOnly<old.MessageType>, TypeOnly<current.MessageType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_MessageType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_MessageType = requireAssignableTo<TypeOnly<current.MessageType>, TypeOnly<old.MessageType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_NackErrorType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_NackErrorType = requireAssignableTo<TypeOnly<old.NackErrorType>, TypeOnly<current.NackErrorType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_NackErrorType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_NackErrorType = requireAssignableTo<TypeOnly<current.NackErrorType>, TypeOnly<old.NackErrorType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ScopeType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_ScopeType = requireAssignableTo<TypeOnly<old.ScopeType>, TypeOnly<current.ScopeType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ScopeType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_ScopeType = requireAssignableTo<TypeOnly<current.ScopeType>, TypeOnly<old.ScopeType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_SignalType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_SignalType = requireAssignableTo<TypeOnly<old.SignalType>, TypeOnly<current.SignalType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_SignalType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_SignalType = requireAssignableTo<TypeOnly<current.SignalType>, TypeOnly<old.SignalType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_TreeEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_TreeEntry = requireAssignableTo<TypeOnly<old.TreeEntry>, TypeOnly<current.TreeEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_TreeEntry": {"backCompat": false}
 */
declare type current_as_old_for_Enum_TreeEntry = requireAssignableTo<TypeOnly<current.TreeEntry>, TypeOnly<old.TreeEntry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IActorClient": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IActorClient = requireAssignableTo<TypeOnly<old.IActorClient>, TypeOnly<current.IActorClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IActorClient": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IActorClient = requireAssignableTo<TypeOnly<current.IActorClient>, TypeOnly<old.IActorClient>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAttachment": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IAttachment = requireAssignableTo<TypeOnly<old.IAttachment>, TypeOnly<current.IAttachment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAttachment": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IAttachment = requireAssignableTo<TypeOnly<current.IAttachment>, TypeOnly<old.IAttachment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBlob": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IBlob = requireAssignableTo<TypeOnly<old.IBlob>, TypeOnly<current.IBlob>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBlob": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IBlob = requireAssignableTo<TypeOnly<current.IBlob>, TypeOnly<old.IBlob>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBranchOrigin": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IBranchOrigin = requireAssignableTo<TypeOnly<old.IBranchOrigin>, TypeOnly<current.IBranchOrigin>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBranchOrigin": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IBranchOrigin = requireAssignableTo<TypeOnly<current.IBranchOrigin>, TypeOnly<old.IBranchOrigin>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICapabilities": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICapabilities = requireAssignableTo<TypeOnly<old.ICapabilities>, TypeOnly<current.ICapabilities>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICapabilities": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICapabilities = requireAssignableTo<TypeOnly<current.ICapabilities>, TypeOnly<old.ICapabilities>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClient": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IClient = requireAssignableTo<TypeOnly<old.IClient>, TypeOnly<current.IClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClient": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IClient = requireAssignableTo<TypeOnly<current.IClient>, TypeOnly<old.IClient>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IClientConfiguration = requireAssignableTo<TypeOnly<old.IClientConfiguration>, TypeOnly<current.IClientConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IClientConfiguration = requireAssignableTo<TypeOnly<current.IClientConfiguration>, TypeOnly<old.IClientConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientDetails": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IClientDetails = requireAssignableTo<TypeOnly<old.IClientDetails>, TypeOnly<current.IClientDetails>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientDetails": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IClientDetails = requireAssignableTo<TypeOnly<current.IClientDetails>, TypeOnly<old.IClientDetails>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientJoin": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IClientJoin = requireAssignableTo<TypeOnly<old.IClientJoin>, TypeOnly<current.IClientJoin>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientJoin": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IClientJoin = requireAssignableTo<TypeOnly<current.IClientJoin>, TypeOnly<old.IClientJoin>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnect": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConnect = requireAssignableTo<TypeOnly<old.IConnect>, TypeOnly<current.IConnect>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnect": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConnect = requireAssignableTo<TypeOnly<current.IConnect>, TypeOnly<old.IConnect>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnected": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConnected = requireAssignableTo<TypeOnly<old.IConnected>, TypeOnly<current.IConnected>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnected": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConnected = requireAssignableTo<TypeOnly<current.IConnected>, TypeOnly<old.IConnected>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICreateBlobResponse": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICreateBlobResponse = requireAssignableTo<TypeOnly<old.ICreateBlobResponse>, TypeOnly<current.ICreateBlobResponse>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICreateBlobResponse": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICreateBlobResponse = requireAssignableTo<TypeOnly<current.ICreateBlobResponse>, TypeOnly<old.ICreateBlobResponse>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentAttributes": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentAttributes = requireAssignableTo<TypeOnly<old.IDocumentAttributes>, TypeOnly<current.IDocumentAttributes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentAttributes": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentAttributes = requireAssignableTo<TypeOnly<current.IDocumentAttributes>, TypeOnly<old.IDocumentAttributes>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentMessage = requireAssignableTo<TypeOnly<old.IDocumentMessage>, TypeOnly<current.IDocumentMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentMessage = requireAssignableTo<TypeOnly<current.IDocumentMessage>, TypeOnly<old.IDocumentMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentSystemMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentSystemMessage = requireAssignableTo<TypeOnly<old.IDocumentSystemMessage>, TypeOnly<current.IDocumentSystemMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentSystemMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentSystemMessage = requireAssignableTo<TypeOnly<current.IDocumentSystemMessage>, TypeOnly<old.IDocumentSystemMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INack": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_INack = requireAssignableTo<TypeOnly<old.INack>, TypeOnly<current.INack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INack": {"backCompat": false}
 */
declare type current_as_old_for_Interface_INack = requireAssignableTo<TypeOnly<current.INack>, TypeOnly<old.INack>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INackContent": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_INackContent = requireAssignableTo<TypeOnly<old.INackContent>, TypeOnly<current.INackContent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INackContent": {"backCompat": false}
 */
declare type current_as_old_for_Interface_INackContent = requireAssignableTo<TypeOnly<current.INackContent>, TypeOnly<old.INackContent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProcessMessageResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProcessMessageResult = requireAssignableTo<TypeOnly<old.IProcessMessageResult>, TypeOnly<current.IProcessMessageResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProcessMessageResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProcessMessageResult = requireAssignableTo<TypeOnly<current.IProcessMessageResult>, TypeOnly<old.IProcessMessageResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProposal": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProposal = requireAssignableTo<TypeOnly<old.IProposal>, TypeOnly<current.IProposal>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProposal": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProposal = requireAssignableTo<TypeOnly<current.IProposal>, TypeOnly<old.IProposal>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProtocolState": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProtocolState = requireAssignableTo<TypeOnly<old.IProtocolState>, TypeOnly<current.IProtocolState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProtocolState": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProtocolState = requireAssignableTo<TypeOnly<current.IProtocolState>, TypeOnly<old.IProtocolState>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IQuorum": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IQuorum = requireAssignableTo<TypeOnly<old.IQuorum>, TypeOnly<current.IQuorum>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IQuorum": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IQuorum = requireAssignableTo<TypeOnly<current.IQuorum>, TypeOnly<old.IQuorum>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IQuorumClients": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IQuorumClients = requireAssignableTo<TypeOnly<old.IQuorumClients>, TypeOnly<current.IQuorumClients>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IQuorumClients": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IQuorumClients = requireAssignableTo<TypeOnly<current.IQuorumClients>, TypeOnly<old.IQuorumClients>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IQuorumClientsEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IQuorumClientsEvents = requireAssignableTo<TypeOnly<old.IQuorumClientsEvents>, TypeOnly<current.IQuorumClientsEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IQuorumClientsEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IQuorumClientsEvents = requireAssignableTo<TypeOnly<current.IQuorumClientsEvents>, TypeOnly<old.IQuorumClientsEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IQuorumProposals": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IQuorumProposals = requireAssignableTo<TypeOnly<old.IQuorumProposals>, TypeOnly<current.IQuorumProposals>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IQuorumProposals": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IQuorumProposals = requireAssignableTo<TypeOnly<current.IQuorumProposals>, TypeOnly<old.IQuorumProposals>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IQuorumProposalsEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IQuorumProposalsEvents = requireAssignableTo<TypeOnly<old.IQuorumProposalsEvents>, TypeOnly<current.IQuorumProposalsEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IQuorumProposalsEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IQuorumProposalsEvents = requireAssignableTo<TypeOnly<current.IQuorumProposalsEvents>, TypeOnly<old.IQuorumProposalsEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequencedClient": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISequencedClient = requireAssignableTo<TypeOnly<old.ISequencedClient>, TypeOnly<current.ISequencedClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequencedClient": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISequencedClient = requireAssignableTo<TypeOnly<current.ISequencedClient>, TypeOnly<old.ISequencedClient>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequencedDocumentAugmentedMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISequencedDocumentAugmentedMessage = requireAssignableTo<TypeOnly<old.ISequencedDocumentAugmentedMessage>, TypeOnly<current.ISequencedDocumentAugmentedMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequencedDocumentAugmentedMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISequencedDocumentAugmentedMessage = requireAssignableTo<TypeOnly<current.ISequencedDocumentAugmentedMessage>, TypeOnly<old.ISequencedDocumentAugmentedMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequencedDocumentMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISequencedDocumentMessage = requireAssignableTo<TypeOnly<old.ISequencedDocumentMessage>, TypeOnly<current.ISequencedDocumentMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequencedDocumentMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISequencedDocumentMessage = requireAssignableTo<TypeOnly<current.ISequencedDocumentMessage>, TypeOnly<old.ISequencedDocumentMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequencedDocumentSystemMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISequencedDocumentSystemMessage = requireAssignableTo<TypeOnly<old.ISequencedDocumentSystemMessage>, TypeOnly<current.ISequencedDocumentSystemMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequencedDocumentSystemMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISequencedDocumentSystemMessage = requireAssignableTo<TypeOnly<current.ISequencedDocumentSystemMessage>, TypeOnly<old.ISequencedDocumentSystemMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServerError": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IServerError = requireAssignableTo<TypeOnly<old.IServerError>, TypeOnly<current.IServerError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServerError": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IServerError = requireAssignableTo<TypeOnly<current.IServerError>, TypeOnly<old.IServerError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISignalClient": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISignalClient = requireAssignableTo<TypeOnly<old.ISignalClient>, TypeOnly<current.ISignalClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISignalClient": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISignalClient = requireAssignableTo<TypeOnly<current.ISignalClient>, TypeOnly<old.ISignalClient>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISignalMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISignalMessage = requireAssignableTo<TypeOnly<old.ISignalMessage>, TypeOnly<current.ISignalMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISignalMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISignalMessage = requireAssignableTo<TypeOnly<current.ISignalMessage>, TypeOnly<old.ISignalMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISignalMessageBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISignalMessageBase = requireAssignableTo<TypeOnly<old.ISignalMessageBase>, TypeOnly<current.ISignalMessageBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISignalMessageBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISignalMessageBase = requireAssignableTo<TypeOnly<current.ISignalMessageBase>, TypeOnly<old.ISignalMessageBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISnapshotTree": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISnapshotTree = requireAssignableTo<TypeOnly<old.ISnapshotTree>, TypeOnly<current.ISnapshotTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISnapshotTree": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISnapshotTree = requireAssignableTo<TypeOnly<current.ISnapshotTree>, TypeOnly<old.ISnapshotTree>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISnapshotTreeEx": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISnapshotTreeEx = requireAssignableTo<TypeOnly<old.ISnapshotTreeEx>, TypeOnly<current.ISnapshotTreeEx>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISnapshotTreeEx": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISnapshotTreeEx = requireAssignableTo<TypeOnly<current.ISnapshotTreeEx>, TypeOnly<old.ISnapshotTreeEx>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryAck": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryAck = requireAssignableTo<TypeOnly<old.ISummaryAck>, TypeOnly<current.ISummaryAck>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryAck": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryAck = requireAssignableTo<TypeOnly<current.ISummaryAck>, TypeOnly<old.ISummaryAck>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryAttachment": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryAttachment = requireAssignableTo<TypeOnly<old.ISummaryAttachment>, TypeOnly<current.ISummaryAttachment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryAttachment": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryAttachment = requireAssignableTo<TypeOnly<current.ISummaryAttachment>, TypeOnly<old.ISummaryAttachment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryBlob": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryBlob = requireAssignableTo<TypeOnly<old.ISummaryBlob>, TypeOnly<current.ISummaryBlob>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryBlob": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryBlob = requireAssignableTo<TypeOnly<current.ISummaryBlob>, TypeOnly<old.ISummaryBlob>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryContent": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryContent = requireAssignableTo<TypeOnly<old.ISummaryContent>, TypeOnly<current.ISummaryContent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryContent": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryContent = requireAssignableTo<TypeOnly<current.ISummaryContent>, TypeOnly<old.ISummaryContent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryHandle": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryHandle = requireAssignableTo<TypeOnly<old.ISummaryHandle>, TypeOnly<current.ISummaryHandle>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryHandle": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryHandle = requireAssignableTo<TypeOnly<current.ISummaryHandle>, TypeOnly<old.ISummaryHandle>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryNack": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryNack = requireAssignableTo<TypeOnly<old.ISummaryNack>, TypeOnly<current.ISummaryNack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryNack": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryNack = requireAssignableTo<TypeOnly<current.ISummaryNack>, TypeOnly<old.ISummaryNack>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryProposal": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryProposal = requireAssignableTo<TypeOnly<old.ISummaryProposal>, TypeOnly<current.ISummaryProposal>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryProposal": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryProposal = requireAssignableTo<TypeOnly<current.ISummaryProposal>, TypeOnly<old.ISummaryProposal>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryTokenClaims": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryTokenClaims = requireAssignableTo<TypeOnly<old.ISummaryTokenClaims>, TypeOnly<current.ISummaryTokenClaims>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryTokenClaims": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryTokenClaims = requireAssignableTo<TypeOnly<current.ISummaryTokenClaims>, TypeOnly<old.ISummaryTokenClaims>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryTree": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryTree = requireAssignableTo<TypeOnly<old.ISummaryTree>, TypeOnly<current.ISummaryTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryTree": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryTree = requireAssignableTo<TypeOnly<current.ISummaryTree>, TypeOnly<old.ISummaryTree>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITokenClaims": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITokenClaims = requireAssignableTo<TypeOnly<old.ITokenClaims>, TypeOnly<current.ITokenClaims>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITokenClaims": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITokenClaims = requireAssignableTo<TypeOnly<current.ITokenClaims>, TypeOnly<old.ITokenClaims>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITokenProvider": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITokenProvider = requireAssignableTo<TypeOnly<old.ITokenProvider>, TypeOnly<current.ITokenProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITokenProvider": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITokenProvider = requireAssignableTo<TypeOnly<current.ITokenProvider>, TypeOnly<old.ITokenProvider>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITokenService": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITokenService = requireAssignableTo<TypeOnly<old.ITokenService>, TypeOnly<current.ITokenService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITokenService": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITokenService = requireAssignableTo<TypeOnly<current.ITokenService>, TypeOnly<old.ITokenService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITrace": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITrace = requireAssignableTo<TypeOnly<old.ITrace>, TypeOnly<current.ITrace>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITrace": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITrace = requireAssignableTo<TypeOnly<current.ITrace>, TypeOnly<old.ITrace>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITree": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITree = requireAssignableTo<TypeOnly<old.ITree>, TypeOnly<current.ITree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITree": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITree = requireAssignableTo<TypeOnly<current.ITree>, TypeOnly<old.ITree>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUploadedSummaryDetails": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IUploadedSummaryDetails = requireAssignableTo<TypeOnly<old.IUploadedSummaryDetails>, TypeOnly<current.IUploadedSummaryDetails>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUploadedSummaryDetails": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IUploadedSummaryDetails = requireAssignableTo<TypeOnly<current.IUploadedSummaryDetails>, TypeOnly<old.IUploadedSummaryDetails>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUser": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IUser = requireAssignableTo<TypeOnly<old.IUser>, TypeOnly<current.IUser>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUser": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IUser = requireAssignableTo<TypeOnly<current.IUser>, TypeOnly<old.IUser>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IVersion": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IVersion = requireAssignableTo<TypeOnly<old.IVersion>, TypeOnly<current.IVersion>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IVersion": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IVersion = requireAssignableTo<TypeOnly<current.IVersion>, TypeOnly<old.IVersion>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ConnectionMode": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ConnectionMode = requireAssignableTo<TypeOnly<old.ConnectionMode>, TypeOnly<current.ConnectionMode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ConnectionMode": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ConnectionMode = requireAssignableTo<TypeOnly<current.ConnectionMode>, TypeOnly<old.ConnectionMode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IApprovedProposal": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IApprovedProposal = requireAssignableTo<TypeOnly<old.IApprovedProposal>, TypeOnly<current.IApprovedProposal>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IApprovedProposal": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IApprovedProposal = requireAssignableTo<TypeOnly<current.IApprovedProposal>, TypeOnly<old.IApprovedProposal>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ICommittedProposal": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ICommittedProposal = requireAssignableTo<TypeOnly<old.ICommittedProposal>, TypeOnly<current.ICommittedProposal>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ICommittedProposal": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ICommittedProposal = requireAssignableTo<TypeOnly<current.ICommittedProposal>, TypeOnly<old.ICommittedProposal>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IQuorumEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IQuorumEvents = requireAssignableTo<TypeOnly<old.IQuorumEvents>, TypeOnly<current.IQuorumEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IQuorumEvents": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IQuorumEvents = requireAssignableTo<TypeOnly<current.IQuorumEvents>, TypeOnly<old.IQuorumEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISentSignalMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ISentSignalMessage = requireAssignableTo<TypeOnly<old.ISentSignalMessage>, TypeOnly<current.ISentSignalMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISentSignalMessage": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ISentSignalMessage = requireAssignableTo<TypeOnly<current.ISentSignalMessage>, TypeOnly<old.ISentSignalMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISequencedDocumentMessageExperimental": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ISequencedDocumentMessageExperimental = requireAssignableTo<TypeOnly<old.ISequencedDocumentMessageExperimental>, TypeOnly<current.ISequencedDocumentMessageExperimental>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISequencedDocumentMessageExperimental": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ISequencedDocumentMessageExperimental = requireAssignableTo<TypeOnly<current.ISequencedDocumentMessageExperimental>, TypeOnly<old.ISequencedDocumentMessageExperimental>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISequencedProposal": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ISequencedProposal = requireAssignableTo<TypeOnly<old.ISequencedProposal>, TypeOnly<current.ISequencedProposal>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISequencedProposal": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ISequencedProposal = requireAssignableTo<TypeOnly<current.ISequencedProposal>, TypeOnly<old.ISequencedProposal>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IsoDate": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IsoDate = requireAssignableTo<TypeOnly<old.IsoDate>, TypeOnly<current.IsoDate>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IsoDate": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IsoDate = requireAssignableTo<TypeOnly<current.IsoDate>, TypeOnly<old.IsoDate>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ITreeEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ITreeEntry = requireAssignableTo<TypeOnly<old.ITreeEntry>, TypeOnly<current.ITreeEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ITreeEntry": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ITreeEntry = requireAssignableTo<TypeOnly<current.ITreeEntry>, TypeOnly<old.ITreeEntry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryObject": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SummaryObject = requireAssignableTo<TypeOnly<old.SummaryObject>, TypeOnly<current.SummaryObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryObject": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SummaryObject = requireAssignableTo<TypeOnly<current.SummaryObject>, TypeOnly<old.SummaryObject>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryTree": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SummaryTree = requireAssignableTo<TypeOnly<old.SummaryTree>, TypeOnly<current.SummaryTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryTree": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SummaryTree = requireAssignableTo<TypeOnly<current.SummaryTree>, TypeOnly<old.SummaryTree>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SummaryType = requireAssignableTo<TypeOnly<old.SummaryType>, TypeOnly<current.SummaryType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SummaryType = requireAssignableTo<TypeOnly<current.SummaryType>, TypeOnly<old.SummaryType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryTypeNoHandle": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SummaryTypeNoHandle = requireAssignableTo<TypeOnly<old.SummaryTypeNoHandle>, TypeOnly<current.SummaryTypeNoHandle>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryTypeNoHandle": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SummaryTypeNoHandle = requireAssignableTo<TypeOnly<current.SummaryTypeNoHandle>, TypeOnly<old.SummaryTypeNoHandle>>
