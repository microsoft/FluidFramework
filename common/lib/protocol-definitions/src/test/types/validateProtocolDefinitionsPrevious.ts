/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
/* eslint-disable max-lines */
import * as old from "@fluidframework/protocol-definitions-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionMode": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConnectionMode():
    TypeOnly<old.ConnectionMode>;
declare function use_current_TypeAliasDeclaration_ConnectionMode(
    use: TypeOnly<current.ConnectionMode>);
use_current_TypeAliasDeclaration_ConnectionMode(
    get_old_TypeAliasDeclaration_ConnectionMode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionMode": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConnectionMode():
    TypeOnly<current.ConnectionMode>;
declare function use_old_TypeAliasDeclaration_ConnectionMode(
    use: TypeOnly<old.ConnectionMode>);
use_old_TypeAliasDeclaration_ConnectionMode(
    get_current_TypeAliasDeclaration_ConnectionMode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_FileMode": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_FileMode():
    TypeOnly<old.FileMode>;
declare function use_current_EnumDeclaration_FileMode(
    use: TypeOnly<current.FileMode>);
use_current_EnumDeclaration_FileMode(
    get_old_EnumDeclaration_FileMode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_FileMode": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_FileMode():
    TypeOnly<current.FileMode>;
declare function use_old_EnumDeclaration_FileMode(
    use: TypeOnly<old.FileMode>);
use_old_EnumDeclaration_FileMode(
    get_current_EnumDeclaration_FileMode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IActorClient": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IActorClient():
    TypeOnly<old.IActorClient>;
declare function use_current_InterfaceDeclaration_IActorClient(
    use: TypeOnly<current.IActorClient>);
use_current_InterfaceDeclaration_IActorClient(
    get_old_InterfaceDeclaration_IActorClient());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IActorClient": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IActorClient():
    TypeOnly<current.IActorClient>;
declare function use_old_InterfaceDeclaration_IActorClient(
    use: TypeOnly<old.IActorClient>);
use_old_InterfaceDeclaration_IActorClient(
    get_current_InterfaceDeclaration_IActorClient());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IApprovedProposal": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IApprovedProposal():
    TypeOnly<old.IApprovedProposal>;
declare function use_current_TypeAliasDeclaration_IApprovedProposal(
    use: TypeOnly<current.IApprovedProposal>);
use_current_TypeAliasDeclaration_IApprovedProposal(
    get_old_TypeAliasDeclaration_IApprovedProposal());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IApprovedProposal": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IApprovedProposal():
    TypeOnly<current.IApprovedProposal>;
declare function use_old_TypeAliasDeclaration_IApprovedProposal(
    use: TypeOnly<old.IApprovedProposal>);
use_old_TypeAliasDeclaration_IApprovedProposal(
    get_current_TypeAliasDeclaration_IApprovedProposal());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAttachment": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAttachment():
    TypeOnly<old.IAttachment>;
declare function use_current_InterfaceDeclaration_IAttachment(
    use: TypeOnly<current.IAttachment>);
use_current_InterfaceDeclaration_IAttachment(
    get_old_InterfaceDeclaration_IAttachment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAttachment": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAttachment():
    TypeOnly<current.IAttachment>;
declare function use_old_InterfaceDeclaration_IAttachment(
    use: TypeOnly<old.IAttachment>);
use_old_InterfaceDeclaration_IAttachment(
    get_current_InterfaceDeclaration_IAttachment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBlob": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IBlob():
    TypeOnly<old.IBlob>;
declare function use_current_InterfaceDeclaration_IBlob(
    use: TypeOnly<current.IBlob>);
use_current_InterfaceDeclaration_IBlob(
    get_old_InterfaceDeclaration_IBlob());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBlob": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IBlob():
    TypeOnly<current.IBlob>;
declare function use_old_InterfaceDeclaration_IBlob(
    use: TypeOnly<old.IBlob>);
use_old_InterfaceDeclaration_IBlob(
    get_current_InterfaceDeclaration_IBlob());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBranchOrigin": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IBranchOrigin():
    TypeOnly<old.IBranchOrigin>;
declare function use_current_InterfaceDeclaration_IBranchOrigin(
    use: TypeOnly<current.IBranchOrigin>);
use_current_InterfaceDeclaration_IBranchOrigin(
    get_old_InterfaceDeclaration_IBranchOrigin());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBranchOrigin": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IBranchOrigin():
    TypeOnly<current.IBranchOrigin>;
declare function use_old_InterfaceDeclaration_IBranchOrigin(
    use: TypeOnly<old.IBranchOrigin>);
use_old_InterfaceDeclaration_IBranchOrigin(
    get_current_InterfaceDeclaration_IBranchOrigin());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICapabilities": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICapabilities():
    TypeOnly<old.ICapabilities>;
declare function use_current_InterfaceDeclaration_ICapabilities(
    use: TypeOnly<current.ICapabilities>);
use_current_InterfaceDeclaration_ICapabilities(
    get_old_InterfaceDeclaration_ICapabilities());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICapabilities": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICapabilities():
    TypeOnly<current.ICapabilities>;
declare function use_old_InterfaceDeclaration_ICapabilities(
    use: TypeOnly<old.ICapabilities>);
use_old_InterfaceDeclaration_ICapabilities(
    get_current_InterfaceDeclaration_ICapabilities());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClient": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IClient():
    TypeOnly<old.IClient>;
declare function use_current_InterfaceDeclaration_IClient(
    use: TypeOnly<current.IClient>);
use_current_InterfaceDeclaration_IClient(
    get_old_InterfaceDeclaration_IClient());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClient": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IClient():
    TypeOnly<current.IClient>;
declare function use_old_InterfaceDeclaration_IClient(
    use: TypeOnly<old.IClient>);
use_old_InterfaceDeclaration_IClient(
    get_current_InterfaceDeclaration_IClient());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IClientConfiguration():
    TypeOnly<old.IClientConfiguration>;
declare function use_current_InterfaceDeclaration_IClientConfiguration(
    use: TypeOnly<current.IClientConfiguration>);
use_current_InterfaceDeclaration_IClientConfiguration(
    get_old_InterfaceDeclaration_IClientConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IClientConfiguration():
    TypeOnly<current.IClientConfiguration>;
declare function use_old_InterfaceDeclaration_IClientConfiguration(
    use: TypeOnly<old.IClientConfiguration>);
use_old_InterfaceDeclaration_IClientConfiguration(
    get_current_InterfaceDeclaration_IClientConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IClientDetails():
    TypeOnly<old.IClientDetails>;
declare function use_current_InterfaceDeclaration_IClientDetails(
    use: TypeOnly<current.IClientDetails>);
use_current_InterfaceDeclaration_IClientDetails(
    get_old_InterfaceDeclaration_IClientDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IClientDetails():
    TypeOnly<current.IClientDetails>;
declare function use_old_InterfaceDeclaration_IClientDetails(
    use: TypeOnly<old.IClientDetails>);
use_old_InterfaceDeclaration_IClientDetails(
    get_current_InterfaceDeclaration_IClientDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientJoin": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IClientJoin():
    TypeOnly<old.IClientJoin>;
declare function use_current_InterfaceDeclaration_IClientJoin(
    use: TypeOnly<current.IClientJoin>);
use_current_InterfaceDeclaration_IClientJoin(
    get_old_InterfaceDeclaration_IClientJoin());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientJoin": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IClientJoin():
    TypeOnly<current.IClientJoin>;
declare function use_old_InterfaceDeclaration_IClientJoin(
    use: TypeOnly<old.IClientJoin>);
use_old_InterfaceDeclaration_IClientJoin(
    get_current_InterfaceDeclaration_IClientJoin());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ICommittedProposal": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ICommittedProposal():
    TypeOnly<old.ICommittedProposal>;
declare function use_current_TypeAliasDeclaration_ICommittedProposal(
    use: TypeOnly<current.ICommittedProposal>);
use_current_TypeAliasDeclaration_ICommittedProposal(
    get_old_TypeAliasDeclaration_ICommittedProposal());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ICommittedProposal": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ICommittedProposal():
    TypeOnly<current.ICommittedProposal>;
declare function use_old_TypeAliasDeclaration_ICommittedProposal(
    use: TypeOnly<old.ICommittedProposal>);
use_old_TypeAliasDeclaration_ICommittedProposal(
    get_current_TypeAliasDeclaration_ICommittedProposal());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnect": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConnect():
    TypeOnly<old.IConnect>;
declare function use_current_InterfaceDeclaration_IConnect(
    use: TypeOnly<current.IConnect>);
use_current_InterfaceDeclaration_IConnect(
    get_old_InterfaceDeclaration_IConnect());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnect": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConnect():
    TypeOnly<current.IConnect>;
declare function use_old_InterfaceDeclaration_IConnect(
    use: TypeOnly<old.IConnect>);
use_old_InterfaceDeclaration_IConnect(
    get_current_InterfaceDeclaration_IConnect());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnected": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConnected():
    TypeOnly<old.IConnected>;
declare function use_current_InterfaceDeclaration_IConnected(
    use: TypeOnly<current.IConnected>);
use_current_InterfaceDeclaration_IConnected(
    get_old_InterfaceDeclaration_IConnected());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnected": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConnected():
    TypeOnly<current.IConnected>;
declare function use_old_InterfaceDeclaration_IConnected(
    use: TypeOnly<old.IConnected>);
use_old_InterfaceDeclaration_IConnected(
    get_current_InterfaceDeclaration_IConnected());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICreateBlobResponse": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICreateBlobResponse():
    TypeOnly<old.ICreateBlobResponse>;
declare function use_current_InterfaceDeclaration_ICreateBlobResponse(
    use: TypeOnly<current.ICreateBlobResponse>);
use_current_InterfaceDeclaration_ICreateBlobResponse(
    get_old_InterfaceDeclaration_ICreateBlobResponse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICreateBlobResponse": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICreateBlobResponse():
    TypeOnly<current.ICreateBlobResponse>;
declare function use_old_InterfaceDeclaration_ICreateBlobResponse(
    use: TypeOnly<old.ICreateBlobResponse>);
use_old_InterfaceDeclaration_ICreateBlobResponse(
    get_current_InterfaceDeclaration_ICreateBlobResponse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentAttributes": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDocumentAttributes():
    TypeOnly<old.IDocumentAttributes>;
declare function use_current_InterfaceDeclaration_IDocumentAttributes(
    use: TypeOnly<current.IDocumentAttributes>);
use_current_InterfaceDeclaration_IDocumentAttributes(
    get_old_InterfaceDeclaration_IDocumentAttributes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentAttributes": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDocumentAttributes():
    TypeOnly<current.IDocumentAttributes>;
declare function use_old_InterfaceDeclaration_IDocumentAttributes(
    use: TypeOnly<old.IDocumentAttributes>);
use_old_InterfaceDeclaration_IDocumentAttributes(
    get_current_InterfaceDeclaration_IDocumentAttributes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDocumentMessage():
    TypeOnly<old.IDocumentMessage>;
declare function use_current_InterfaceDeclaration_IDocumentMessage(
    use: TypeOnly<current.IDocumentMessage>);
use_current_InterfaceDeclaration_IDocumentMessage(
    get_old_InterfaceDeclaration_IDocumentMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDocumentMessage():
    TypeOnly<current.IDocumentMessage>;
declare function use_old_InterfaceDeclaration_IDocumentMessage(
    use: TypeOnly<old.IDocumentMessage>);
use_old_InterfaceDeclaration_IDocumentMessage(
    get_current_InterfaceDeclaration_IDocumentMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentSystemMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDocumentSystemMessage():
    TypeOnly<old.IDocumentSystemMessage>;
declare function use_current_InterfaceDeclaration_IDocumentSystemMessage(
    use: TypeOnly<current.IDocumentSystemMessage>);
use_current_InterfaceDeclaration_IDocumentSystemMessage(
    get_old_InterfaceDeclaration_IDocumentSystemMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentSystemMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDocumentSystemMessage():
    TypeOnly<current.IDocumentSystemMessage>;
declare function use_old_InterfaceDeclaration_IDocumentSystemMessage(
    use: TypeOnly<old.IDocumentSystemMessage>);
use_old_InterfaceDeclaration_IDocumentSystemMessage(
    get_current_InterfaceDeclaration_IDocumentSystemMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHelpMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IHelpMessage():
    TypeOnly<old.IHelpMessage>;
declare function use_current_InterfaceDeclaration_IHelpMessage(
    use: TypeOnly<current.IHelpMessage>);
use_current_InterfaceDeclaration_IHelpMessage(
    get_old_InterfaceDeclaration_IHelpMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHelpMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IHelpMessage():
    TypeOnly<current.IHelpMessage>;
declare function use_old_InterfaceDeclaration_IHelpMessage(
    use: TypeOnly<old.IHelpMessage>);
use_old_InterfaceDeclaration_IHelpMessage(
    get_current_InterfaceDeclaration_IHelpMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INack": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_INack():
    TypeOnly<old.INack>;
declare function use_current_InterfaceDeclaration_INack(
    use: TypeOnly<current.INack>);
use_current_InterfaceDeclaration_INack(
    get_old_InterfaceDeclaration_INack());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INack": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_INack():
    TypeOnly<current.INack>;
declare function use_old_InterfaceDeclaration_INack(
    use: TypeOnly<old.INack>);
use_old_InterfaceDeclaration_INack(
    get_current_InterfaceDeclaration_INack());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INackContent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_INackContent():
    TypeOnly<old.INackContent>;
declare function use_current_InterfaceDeclaration_INackContent(
    use: TypeOnly<current.INackContent>);
use_current_InterfaceDeclaration_INackContent(
    get_old_InterfaceDeclaration_INackContent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INackContent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_INackContent():
    TypeOnly<current.INackContent>;
declare function use_old_InterfaceDeclaration_INackContent(
    use: TypeOnly<old.INackContent>);
use_old_InterfaceDeclaration_INackContent(
    get_current_InterfaceDeclaration_INackContent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProcessMessageResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProcessMessageResult():
    TypeOnly<old.IProcessMessageResult>;
declare function use_current_InterfaceDeclaration_IProcessMessageResult(
    use: TypeOnly<current.IProcessMessageResult>);
use_current_InterfaceDeclaration_IProcessMessageResult(
    get_old_InterfaceDeclaration_IProcessMessageResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProcessMessageResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProcessMessageResult():
    TypeOnly<current.IProcessMessageResult>;
declare function use_old_InterfaceDeclaration_IProcessMessageResult(
    use: TypeOnly<old.IProcessMessageResult>);
use_old_InterfaceDeclaration_IProcessMessageResult(
    get_current_InterfaceDeclaration_IProcessMessageResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProposal": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProposal():
    TypeOnly<old.IProposal>;
declare function use_current_InterfaceDeclaration_IProposal(
    use: TypeOnly<current.IProposal>);
use_current_InterfaceDeclaration_IProposal(
    get_old_InterfaceDeclaration_IProposal());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProposal": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProposal():
    TypeOnly<current.IProposal>;
declare function use_old_InterfaceDeclaration_IProposal(
    use: TypeOnly<old.IProposal>);
use_old_InterfaceDeclaration_IProposal(
    get_current_InterfaceDeclaration_IProposal());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProtocolState": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProtocolState():
    TypeOnly<old.IProtocolState>;
declare function use_current_InterfaceDeclaration_IProtocolState(
    use: TypeOnly<current.IProtocolState>);
use_current_InterfaceDeclaration_IProtocolState(
    get_old_InterfaceDeclaration_IProtocolState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProtocolState": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProtocolState():
    TypeOnly<current.IProtocolState>;
declare function use_old_InterfaceDeclaration_IProtocolState(
    use: TypeOnly<old.IProtocolState>);
use_old_InterfaceDeclaration_IProtocolState(
    get_current_InterfaceDeclaration_IProtocolState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IQueueMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IQueueMessage():
    TypeOnly<old.IQueueMessage>;
declare function use_current_InterfaceDeclaration_IQueueMessage(
    use: TypeOnly<current.IQueueMessage>);
use_current_InterfaceDeclaration_IQueueMessage(
    get_old_InterfaceDeclaration_IQueueMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IQueueMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IQueueMessage():
    TypeOnly<current.IQueueMessage>;
declare function use_old_InterfaceDeclaration_IQueueMessage(
    use: TypeOnly<old.IQueueMessage>);
use_old_InterfaceDeclaration_IQueueMessage(
    get_current_InterfaceDeclaration_IQueueMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IQuorum": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IQuorum():
    TypeOnly<old.IQuorum>;
declare function use_current_InterfaceDeclaration_IQuorum(
    use: TypeOnly<current.IQuorum>);
use_current_InterfaceDeclaration_IQuorum(
    get_old_InterfaceDeclaration_IQuorum());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IQuorum": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IQuorum():
    TypeOnly<current.IQuorum>;
declare function use_old_InterfaceDeclaration_IQuorum(
    use: TypeOnly<old.IQuorum>);
use_old_InterfaceDeclaration_IQuorum(
    get_current_InterfaceDeclaration_IQuorum());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IQuorumClients": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IQuorumClients():
    TypeOnly<old.IQuorumClients>;
declare function use_current_InterfaceDeclaration_IQuorumClients(
    use: TypeOnly<current.IQuorumClients>);
use_current_InterfaceDeclaration_IQuorumClients(
    get_old_InterfaceDeclaration_IQuorumClients());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IQuorumClients": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IQuorumClients():
    TypeOnly<current.IQuorumClients>;
declare function use_old_InterfaceDeclaration_IQuorumClients(
    use: TypeOnly<old.IQuorumClients>);
use_old_InterfaceDeclaration_IQuorumClients(
    get_current_InterfaceDeclaration_IQuorumClients());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IQuorumClientsEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IQuorumClientsEvents():
    TypeOnly<old.IQuorumClientsEvents>;
declare function use_current_InterfaceDeclaration_IQuorumClientsEvents(
    use: TypeOnly<current.IQuorumClientsEvents>);
use_current_InterfaceDeclaration_IQuorumClientsEvents(
    get_old_InterfaceDeclaration_IQuorumClientsEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IQuorumClientsEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IQuorumClientsEvents():
    TypeOnly<current.IQuorumClientsEvents>;
declare function use_old_InterfaceDeclaration_IQuorumClientsEvents(
    use: TypeOnly<old.IQuorumClientsEvents>);
use_old_InterfaceDeclaration_IQuorumClientsEvents(
    get_current_InterfaceDeclaration_IQuorumClientsEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IQuorumEvents": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IQuorumEvents():
    TypeOnly<old.IQuorumEvents>;
declare function use_current_TypeAliasDeclaration_IQuorumEvents(
    use: TypeOnly<current.IQuorumEvents>);
use_current_TypeAliasDeclaration_IQuorumEvents(
    get_old_TypeAliasDeclaration_IQuorumEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IQuorumEvents": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IQuorumEvents():
    TypeOnly<current.IQuorumEvents>;
declare function use_old_TypeAliasDeclaration_IQuorumEvents(
    use: TypeOnly<old.IQuorumEvents>);
use_old_TypeAliasDeclaration_IQuorumEvents(
    get_current_TypeAliasDeclaration_IQuorumEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IQuorumProposals": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IQuorumProposals():
    TypeOnly<old.IQuorumProposals>;
declare function use_current_InterfaceDeclaration_IQuorumProposals(
    use: TypeOnly<current.IQuorumProposals>);
use_current_InterfaceDeclaration_IQuorumProposals(
    get_old_InterfaceDeclaration_IQuorumProposals());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IQuorumProposals": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IQuorumProposals():
    TypeOnly<current.IQuorumProposals>;
declare function use_old_InterfaceDeclaration_IQuorumProposals(
    use: TypeOnly<old.IQuorumProposals>);
use_old_InterfaceDeclaration_IQuorumProposals(
    get_current_InterfaceDeclaration_IQuorumProposals());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IQuorumProposalsEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IQuorumProposalsEvents():
    TypeOnly<old.IQuorumProposalsEvents>;
declare function use_current_InterfaceDeclaration_IQuorumProposalsEvents(
    use: TypeOnly<current.IQuorumProposalsEvents>);
use_current_InterfaceDeclaration_IQuorumProposalsEvents(
    get_old_InterfaceDeclaration_IQuorumProposalsEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IQuorumProposalsEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IQuorumProposalsEvents():
    TypeOnly<current.IQuorumProposalsEvents>;
declare function use_old_InterfaceDeclaration_IQuorumProposalsEvents(
    use: TypeOnly<old.IQuorumProposalsEvents>);
use_old_InterfaceDeclaration_IQuorumProposalsEvents(
    get_current_InterfaceDeclaration_IQuorumProposalsEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISequencedClient": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISequencedClient():
    TypeOnly<old.ISequencedClient>;
declare function use_current_InterfaceDeclaration_ISequencedClient(
    use: TypeOnly<current.ISequencedClient>);
use_current_InterfaceDeclaration_ISequencedClient(
    get_old_InterfaceDeclaration_ISequencedClient());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISequencedClient": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISequencedClient():
    TypeOnly<current.ISequencedClient>;
declare function use_old_InterfaceDeclaration_ISequencedClient(
    use: TypeOnly<old.ISequencedClient>);
use_old_InterfaceDeclaration_ISequencedClient(
    get_current_InterfaceDeclaration_ISequencedClient());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISequencedDocumentAugmentedMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISequencedDocumentAugmentedMessage():
    TypeOnly<old.ISequencedDocumentAugmentedMessage>;
declare function use_current_InterfaceDeclaration_ISequencedDocumentAugmentedMessage(
    use: TypeOnly<current.ISequencedDocumentAugmentedMessage>);
use_current_InterfaceDeclaration_ISequencedDocumentAugmentedMessage(
    get_old_InterfaceDeclaration_ISequencedDocumentAugmentedMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISequencedDocumentAugmentedMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISequencedDocumentAugmentedMessage():
    TypeOnly<current.ISequencedDocumentAugmentedMessage>;
declare function use_old_InterfaceDeclaration_ISequencedDocumentAugmentedMessage(
    use: TypeOnly<old.ISequencedDocumentAugmentedMessage>);
use_old_InterfaceDeclaration_ISequencedDocumentAugmentedMessage(
    get_current_InterfaceDeclaration_ISequencedDocumentAugmentedMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISequencedDocumentMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISequencedDocumentMessage():
    TypeOnly<old.ISequencedDocumentMessage>;
declare function use_current_InterfaceDeclaration_ISequencedDocumentMessage(
    use: TypeOnly<current.ISequencedDocumentMessage>);
use_current_InterfaceDeclaration_ISequencedDocumentMessage(
    get_old_InterfaceDeclaration_ISequencedDocumentMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISequencedDocumentMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISequencedDocumentMessage():
    TypeOnly<current.ISequencedDocumentMessage>;
declare function use_old_InterfaceDeclaration_ISequencedDocumentMessage(
    use: TypeOnly<old.ISequencedDocumentMessage>);
use_old_InterfaceDeclaration_ISequencedDocumentMessage(
    get_current_InterfaceDeclaration_ISequencedDocumentMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISequencedDocumentSystemMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISequencedDocumentSystemMessage():
    TypeOnly<old.ISequencedDocumentSystemMessage>;
declare function use_current_InterfaceDeclaration_ISequencedDocumentSystemMessage(
    use: TypeOnly<current.ISequencedDocumentSystemMessage>);
use_current_InterfaceDeclaration_ISequencedDocumentSystemMessage(
    get_old_InterfaceDeclaration_ISequencedDocumentSystemMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISequencedDocumentSystemMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISequencedDocumentSystemMessage():
    TypeOnly<current.ISequencedDocumentSystemMessage>;
declare function use_old_InterfaceDeclaration_ISequencedDocumentSystemMessage(
    use: TypeOnly<old.ISequencedDocumentSystemMessage>);
use_old_InterfaceDeclaration_ISequencedDocumentSystemMessage(
    get_current_InterfaceDeclaration_ISequencedDocumentSystemMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISequencedProposal": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ISequencedProposal():
    TypeOnly<old.ISequencedProposal>;
declare function use_current_TypeAliasDeclaration_ISequencedProposal(
    use: TypeOnly<current.ISequencedProposal>);
use_current_TypeAliasDeclaration_ISequencedProposal(
    get_old_TypeAliasDeclaration_ISequencedProposal());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISequencedProposal": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ISequencedProposal():
    TypeOnly<current.ISequencedProposal>;
declare function use_old_TypeAliasDeclaration_ISequencedProposal(
    use: TypeOnly<old.ISequencedProposal>);
use_old_TypeAliasDeclaration_ISequencedProposal(
    get_current_TypeAliasDeclaration_ISequencedProposal());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IServerError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IServerError():
    TypeOnly<old.IServerError>;
declare function use_current_InterfaceDeclaration_IServerError(
    use: TypeOnly<current.IServerError>);
use_current_InterfaceDeclaration_IServerError(
    get_old_InterfaceDeclaration_IServerError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IServerError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IServerError():
    TypeOnly<current.IServerError>;
declare function use_old_InterfaceDeclaration_IServerError(
    use: TypeOnly<old.IServerError>);
use_old_InterfaceDeclaration_IServerError(
    get_current_InterfaceDeclaration_IServerError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISignalClient": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISignalClient():
    TypeOnly<old.ISignalClient>;
declare function use_current_InterfaceDeclaration_ISignalClient(
    use: TypeOnly<current.ISignalClient>);
use_current_InterfaceDeclaration_ISignalClient(
    get_old_InterfaceDeclaration_ISignalClient());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISignalClient": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISignalClient():
    TypeOnly<current.ISignalClient>;
declare function use_old_InterfaceDeclaration_ISignalClient(
    use: TypeOnly<old.ISignalClient>);
use_old_InterfaceDeclaration_ISignalClient(
    get_current_InterfaceDeclaration_ISignalClient());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISignalMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISignalMessage():
    TypeOnly<old.ISignalMessage>;
declare function use_current_InterfaceDeclaration_ISignalMessage(
    use: TypeOnly<current.ISignalMessage>);
use_current_InterfaceDeclaration_ISignalMessage(
    get_old_InterfaceDeclaration_ISignalMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISignalMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISignalMessage():
    TypeOnly<current.ISignalMessage>;
declare function use_old_InterfaceDeclaration_ISignalMessage(
    use: TypeOnly<old.ISignalMessage>);
use_old_InterfaceDeclaration_ISignalMessage(
    get_current_InterfaceDeclaration_ISignalMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISnapshotTree": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISnapshotTree():
    TypeOnly<old.ISnapshotTree>;
declare function use_current_InterfaceDeclaration_ISnapshotTree(
    use: TypeOnly<current.ISnapshotTree>);
use_current_InterfaceDeclaration_ISnapshotTree(
    get_old_InterfaceDeclaration_ISnapshotTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISnapshotTree": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISnapshotTree():
    TypeOnly<current.ISnapshotTree>;
declare function use_old_InterfaceDeclaration_ISnapshotTree(
    use: TypeOnly<old.ISnapshotTree>);
use_old_InterfaceDeclaration_ISnapshotTree(
    get_current_InterfaceDeclaration_ISnapshotTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISnapshotTreeEx": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISnapshotTreeEx():
    TypeOnly<old.ISnapshotTreeEx>;
declare function use_current_InterfaceDeclaration_ISnapshotTreeEx(
    use: TypeOnly<current.ISnapshotTreeEx>);
use_current_InterfaceDeclaration_ISnapshotTreeEx(
    get_old_InterfaceDeclaration_ISnapshotTreeEx());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISnapshotTreeEx": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISnapshotTreeEx():
    TypeOnly<current.ISnapshotTreeEx>;
declare function use_old_InterfaceDeclaration_ISnapshotTreeEx(
    use: TypeOnly<old.ISnapshotTreeEx>);
use_old_InterfaceDeclaration_ISnapshotTreeEx(
    get_current_InterfaceDeclaration_ISnapshotTreeEx());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryAck": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryAck():
    TypeOnly<old.ISummaryAck>;
declare function use_current_InterfaceDeclaration_ISummaryAck(
    use: TypeOnly<current.ISummaryAck>);
use_current_InterfaceDeclaration_ISummaryAck(
    get_old_InterfaceDeclaration_ISummaryAck());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryAck": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryAck():
    TypeOnly<current.ISummaryAck>;
declare function use_old_InterfaceDeclaration_ISummaryAck(
    use: TypeOnly<old.ISummaryAck>);
use_old_InterfaceDeclaration_ISummaryAck(
    get_current_InterfaceDeclaration_ISummaryAck());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryAttachment": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryAttachment():
    TypeOnly<old.ISummaryAttachment>;
declare function use_current_InterfaceDeclaration_ISummaryAttachment(
    use: TypeOnly<current.ISummaryAttachment>);
use_current_InterfaceDeclaration_ISummaryAttachment(
    get_old_InterfaceDeclaration_ISummaryAttachment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryAttachment": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryAttachment():
    TypeOnly<current.ISummaryAttachment>;
declare function use_old_InterfaceDeclaration_ISummaryAttachment(
    use: TypeOnly<old.ISummaryAttachment>);
use_old_InterfaceDeclaration_ISummaryAttachment(
    get_current_InterfaceDeclaration_ISummaryAttachment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryAuthor": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryAuthor():
    TypeOnly<old.ISummaryAuthor>;
declare function use_current_InterfaceDeclaration_ISummaryAuthor(
    use: TypeOnly<current.ISummaryAuthor>);
use_current_InterfaceDeclaration_ISummaryAuthor(
    get_old_InterfaceDeclaration_ISummaryAuthor());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryAuthor": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryAuthor():
    TypeOnly<current.ISummaryAuthor>;
declare function use_old_InterfaceDeclaration_ISummaryAuthor(
    use: TypeOnly<old.ISummaryAuthor>);
use_old_InterfaceDeclaration_ISummaryAuthor(
    get_current_InterfaceDeclaration_ISummaryAuthor());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryBlob": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryBlob():
    TypeOnly<old.ISummaryBlob>;
declare function use_current_InterfaceDeclaration_ISummaryBlob(
    use: TypeOnly<current.ISummaryBlob>);
use_current_InterfaceDeclaration_ISummaryBlob(
    get_old_InterfaceDeclaration_ISummaryBlob());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryBlob": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryBlob():
    TypeOnly<current.ISummaryBlob>;
declare function use_old_InterfaceDeclaration_ISummaryBlob(
    use: TypeOnly<old.ISummaryBlob>);
use_old_InterfaceDeclaration_ISummaryBlob(
    get_current_InterfaceDeclaration_ISummaryBlob());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryCommitter": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryCommitter():
    TypeOnly<old.ISummaryCommitter>;
declare function use_current_InterfaceDeclaration_ISummaryCommitter(
    use: TypeOnly<current.ISummaryCommitter>);
use_current_InterfaceDeclaration_ISummaryCommitter(
    get_old_InterfaceDeclaration_ISummaryCommitter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryCommitter": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryCommitter():
    TypeOnly<current.ISummaryCommitter>;
declare function use_old_InterfaceDeclaration_ISummaryCommitter(
    use: TypeOnly<old.ISummaryCommitter>);
use_old_InterfaceDeclaration_ISummaryCommitter(
    get_current_InterfaceDeclaration_ISummaryCommitter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryConfiguration():
    TypeOnly<old.ISummaryConfiguration>;
declare function use_current_InterfaceDeclaration_ISummaryConfiguration(
    use: TypeOnly<current.ISummaryConfiguration>);
use_current_InterfaceDeclaration_ISummaryConfiguration(
    get_old_InterfaceDeclaration_ISummaryConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryConfiguration():
    TypeOnly<current.ISummaryConfiguration>;
declare function use_old_InterfaceDeclaration_ISummaryConfiguration(
    use: TypeOnly<old.ISummaryConfiguration>);
use_old_InterfaceDeclaration_ISummaryConfiguration(
    get_current_InterfaceDeclaration_ISummaryConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryContent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryContent():
    TypeOnly<old.ISummaryContent>;
declare function use_current_InterfaceDeclaration_ISummaryContent(
    use: TypeOnly<current.ISummaryContent>);
use_current_InterfaceDeclaration_ISummaryContent(
    get_old_InterfaceDeclaration_ISummaryContent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryContent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryContent():
    TypeOnly<current.ISummaryContent>;
declare function use_old_InterfaceDeclaration_ISummaryContent(
    use: TypeOnly<old.ISummaryContent>);
use_old_InterfaceDeclaration_ISummaryContent(
    get_current_InterfaceDeclaration_ISummaryContent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryHandle": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryHandle():
    TypeOnly<old.ISummaryHandle>;
declare function use_current_InterfaceDeclaration_ISummaryHandle(
    use: TypeOnly<current.ISummaryHandle>);
use_current_InterfaceDeclaration_ISummaryHandle(
    get_old_InterfaceDeclaration_ISummaryHandle());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryHandle": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryHandle():
    TypeOnly<current.ISummaryHandle>;
declare function use_old_InterfaceDeclaration_ISummaryHandle(
    use: TypeOnly<old.ISummaryHandle>);
use_old_InterfaceDeclaration_ISummaryHandle(
    get_current_InterfaceDeclaration_ISummaryHandle());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryNack": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryNack():
    TypeOnly<old.ISummaryNack>;
declare function use_current_InterfaceDeclaration_ISummaryNack(
    use: TypeOnly<current.ISummaryNack>);
use_current_InterfaceDeclaration_ISummaryNack(
    get_old_InterfaceDeclaration_ISummaryNack());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryNack": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryNack():
    TypeOnly<current.ISummaryNack>;
declare function use_old_InterfaceDeclaration_ISummaryNack(
    use: TypeOnly<old.ISummaryNack>);
use_old_InterfaceDeclaration_ISummaryNack(
    get_current_InterfaceDeclaration_ISummaryNack());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryProposal": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryProposal():
    TypeOnly<old.ISummaryProposal>;
declare function use_current_InterfaceDeclaration_ISummaryProposal(
    use: TypeOnly<current.ISummaryProposal>);
use_current_InterfaceDeclaration_ISummaryProposal(
    get_old_InterfaceDeclaration_ISummaryProposal());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryProposal": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryProposal():
    TypeOnly<current.ISummaryProposal>;
declare function use_old_InterfaceDeclaration_ISummaryProposal(
    use: TypeOnly<old.ISummaryProposal>);
use_old_InterfaceDeclaration_ISummaryProposal(
    get_current_InterfaceDeclaration_ISummaryProposal());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryTokenClaims": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryTokenClaims():
    TypeOnly<old.ISummaryTokenClaims>;
declare function use_current_InterfaceDeclaration_ISummaryTokenClaims(
    use: TypeOnly<current.ISummaryTokenClaims>);
use_current_InterfaceDeclaration_ISummaryTokenClaims(
    get_old_InterfaceDeclaration_ISummaryTokenClaims());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryTokenClaims": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryTokenClaims():
    TypeOnly<current.ISummaryTokenClaims>;
declare function use_old_InterfaceDeclaration_ISummaryTokenClaims(
    use: TypeOnly<old.ISummaryTokenClaims>);
use_old_InterfaceDeclaration_ISummaryTokenClaims(
    get_current_InterfaceDeclaration_ISummaryTokenClaims());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryTree": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryTree():
    TypeOnly<old.ISummaryTree>;
declare function use_current_InterfaceDeclaration_ISummaryTree(
    use: TypeOnly<current.ISummaryTree>);
use_current_InterfaceDeclaration_ISummaryTree(
    get_old_InterfaceDeclaration_ISummaryTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryTree": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryTree():
    TypeOnly<current.ISummaryTree>;
declare function use_old_InterfaceDeclaration_ISummaryTree(
    use: TypeOnly<old.ISummaryTree>);
use_old_InterfaceDeclaration_ISummaryTree(
    get_current_InterfaceDeclaration_ISummaryTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITokenClaims": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITokenClaims():
    TypeOnly<old.ITokenClaims>;
declare function use_current_InterfaceDeclaration_ITokenClaims(
    use: TypeOnly<current.ITokenClaims>);
use_current_InterfaceDeclaration_ITokenClaims(
    get_old_InterfaceDeclaration_ITokenClaims());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITokenClaims": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITokenClaims():
    TypeOnly<current.ITokenClaims>;
declare function use_old_InterfaceDeclaration_ITokenClaims(
    use: TypeOnly<old.ITokenClaims>);
use_old_InterfaceDeclaration_ITokenClaims(
    get_current_InterfaceDeclaration_ITokenClaims());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITokenProvider": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITokenProvider():
    TypeOnly<old.ITokenProvider>;
declare function use_current_InterfaceDeclaration_ITokenProvider(
    use: TypeOnly<current.ITokenProvider>);
use_current_InterfaceDeclaration_ITokenProvider(
    get_old_InterfaceDeclaration_ITokenProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITokenProvider": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITokenProvider():
    TypeOnly<current.ITokenProvider>;
declare function use_old_InterfaceDeclaration_ITokenProvider(
    use: TypeOnly<old.ITokenProvider>);
use_old_InterfaceDeclaration_ITokenProvider(
    get_current_InterfaceDeclaration_ITokenProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITokenService": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITokenService():
    TypeOnly<old.ITokenService>;
declare function use_current_InterfaceDeclaration_ITokenService(
    use: TypeOnly<current.ITokenService>);
use_current_InterfaceDeclaration_ITokenService(
    get_old_InterfaceDeclaration_ITokenService());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITokenService": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITokenService():
    TypeOnly<current.ITokenService>;
declare function use_old_InterfaceDeclaration_ITokenService(
    use: TypeOnly<old.ITokenService>);
use_old_InterfaceDeclaration_ITokenService(
    get_current_InterfaceDeclaration_ITokenService());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITrace": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITrace():
    TypeOnly<old.ITrace>;
declare function use_current_InterfaceDeclaration_ITrace(
    use: TypeOnly<current.ITrace>);
use_current_InterfaceDeclaration_ITrace(
    get_old_InterfaceDeclaration_ITrace());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITrace": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITrace():
    TypeOnly<current.ITrace>;
declare function use_old_InterfaceDeclaration_ITrace(
    use: TypeOnly<old.ITrace>);
use_old_InterfaceDeclaration_ITrace(
    get_current_InterfaceDeclaration_ITrace());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITree": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITree():
    TypeOnly<old.ITree>;
declare function use_current_InterfaceDeclaration_ITree(
    use: TypeOnly<current.ITree>);
use_current_InterfaceDeclaration_ITree(
    get_old_InterfaceDeclaration_ITree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITree": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITree():
    TypeOnly<current.ITree>;
declare function use_old_InterfaceDeclaration_ITree(
    use: TypeOnly<old.ITree>);
use_old_InterfaceDeclaration_ITree(
    get_current_InterfaceDeclaration_ITree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ITreeEntry": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ITreeEntry():
    TypeOnly<old.ITreeEntry>;
declare function use_current_TypeAliasDeclaration_ITreeEntry(
    use: TypeOnly<current.ITreeEntry>);
use_current_TypeAliasDeclaration_ITreeEntry(
    get_old_TypeAliasDeclaration_ITreeEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ITreeEntry": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ITreeEntry():
    TypeOnly<current.ITreeEntry>;
declare function use_old_TypeAliasDeclaration_ITreeEntry(
    use: TypeOnly<old.ITreeEntry>);
use_old_TypeAliasDeclaration_ITreeEntry(
    get_current_TypeAliasDeclaration_ITreeEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUploadedSummaryDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IUploadedSummaryDetails():
    TypeOnly<old.IUploadedSummaryDetails>;
declare function use_current_InterfaceDeclaration_IUploadedSummaryDetails(
    use: TypeOnly<current.IUploadedSummaryDetails>);
use_current_InterfaceDeclaration_IUploadedSummaryDetails(
    get_old_InterfaceDeclaration_IUploadedSummaryDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUploadedSummaryDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IUploadedSummaryDetails():
    TypeOnly<current.IUploadedSummaryDetails>;
declare function use_old_InterfaceDeclaration_IUploadedSummaryDetails(
    use: TypeOnly<old.IUploadedSummaryDetails>);
use_old_InterfaceDeclaration_IUploadedSummaryDetails(
    get_current_InterfaceDeclaration_IUploadedSummaryDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUser": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IUser():
    TypeOnly<old.IUser>;
declare function use_current_InterfaceDeclaration_IUser(
    use: TypeOnly<current.IUser>);
use_current_InterfaceDeclaration_IUser(
    get_old_InterfaceDeclaration_IUser());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUser": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IUser():
    TypeOnly<current.IUser>;
declare function use_old_InterfaceDeclaration_IUser(
    use: TypeOnly<old.IUser>);
use_old_InterfaceDeclaration_IUser(
    get_current_InterfaceDeclaration_IUser());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IVersion": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IVersion():
    TypeOnly<old.IVersion>;
declare function use_current_InterfaceDeclaration_IVersion(
    use: TypeOnly<current.IVersion>);
use_current_InterfaceDeclaration_IVersion(
    get_old_InterfaceDeclaration_IVersion());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IVersion": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IVersion():
    TypeOnly<current.IVersion>;
declare function use_old_InterfaceDeclaration_IVersion(
    use: TypeOnly<old.IVersion>);
use_old_InterfaceDeclaration_IVersion(
    get_current_InterfaceDeclaration_IVersion());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_MessageType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_MessageType():
    TypeOnly<old.MessageType>;
declare function use_current_EnumDeclaration_MessageType(
    use: TypeOnly<current.MessageType>);
use_current_EnumDeclaration_MessageType(
    get_old_EnumDeclaration_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_MessageType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_MessageType():
    TypeOnly<current.MessageType>;
declare function use_old_EnumDeclaration_MessageType(
    use: TypeOnly<old.MessageType>);
use_old_EnumDeclaration_MessageType(
    get_current_EnumDeclaration_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_NackErrorType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_NackErrorType():
    TypeOnly<old.NackErrorType>;
declare function use_current_EnumDeclaration_NackErrorType(
    use: TypeOnly<current.NackErrorType>);
use_current_EnumDeclaration_NackErrorType(
    get_old_EnumDeclaration_NackErrorType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_NackErrorType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_NackErrorType():
    TypeOnly<current.NackErrorType>;
declare function use_old_EnumDeclaration_NackErrorType(
    use: TypeOnly<old.NackErrorType>);
use_old_EnumDeclaration_NackErrorType(
    get_current_EnumDeclaration_NackErrorType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ScopeType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_ScopeType():
    TypeOnly<old.ScopeType>;
declare function use_current_EnumDeclaration_ScopeType(
    use: TypeOnly<current.ScopeType>);
use_current_EnumDeclaration_ScopeType(
    get_old_EnumDeclaration_ScopeType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ScopeType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_ScopeType():
    TypeOnly<current.ScopeType>;
declare function use_old_EnumDeclaration_ScopeType(
    use: TypeOnly<old.ScopeType>);
use_old_EnumDeclaration_ScopeType(
    get_current_EnumDeclaration_ScopeType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryObject": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummaryObject():
    TypeOnly<old.SummaryObject>;
declare function use_current_TypeAliasDeclaration_SummaryObject(
    use: TypeOnly<current.SummaryObject>);
use_current_TypeAliasDeclaration_SummaryObject(
    get_old_TypeAliasDeclaration_SummaryObject());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryObject": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummaryObject():
    TypeOnly<current.SummaryObject>;
declare function use_old_TypeAliasDeclaration_SummaryObject(
    use: TypeOnly<old.SummaryObject>);
use_old_TypeAliasDeclaration_SummaryObject(
    get_current_TypeAliasDeclaration_SummaryObject());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryTree": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummaryTree():
    TypeOnly<old.SummaryTree>;
declare function use_current_TypeAliasDeclaration_SummaryTree(
    use: TypeOnly<current.SummaryTree>);
use_current_TypeAliasDeclaration_SummaryTree(
    get_old_TypeAliasDeclaration_SummaryTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryTree": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummaryTree():
    TypeOnly<current.SummaryTree>;
declare function use_old_TypeAliasDeclaration_SummaryTree(
    use: TypeOnly<old.SummaryTree>);
use_old_TypeAliasDeclaration_SummaryTree(
    get_current_TypeAliasDeclaration_SummaryTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryType": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummaryType():
    TypeOnly<old.SummaryType>;
declare function use_current_TypeAliasDeclaration_SummaryType(
    use: TypeOnly<current.SummaryType>);
use_current_TypeAliasDeclaration_SummaryType(
    get_old_TypeAliasDeclaration_SummaryType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryType": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummaryType():
    TypeOnly<current.SummaryType>;
declare function use_old_TypeAliasDeclaration_SummaryType(
    use: TypeOnly<old.SummaryType>);
use_old_TypeAliasDeclaration_SummaryType(
    get_current_TypeAliasDeclaration_SummaryType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryType.Attachment": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummaryType_Attachment():
    TypeOnly<old.SummaryType.Attachment>;
declare function use_current_TypeAliasDeclaration_SummaryType_Attachment(
    use: TypeOnly<current.SummaryType.Attachment>);
use_current_TypeAliasDeclaration_SummaryType_Attachment(
    get_old_TypeAliasDeclaration_SummaryType_Attachment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryType.Attachment": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummaryType_Attachment():
    TypeOnly<current.SummaryType.Attachment>;
declare function use_old_TypeAliasDeclaration_SummaryType_Attachment(
    use: TypeOnly<old.SummaryType.Attachment>);
use_old_TypeAliasDeclaration_SummaryType_Attachment(
    get_current_TypeAliasDeclaration_SummaryType_Attachment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_SummaryType.Attachment": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_SummaryType_Attachment():
    TypeOnly<typeof old.SummaryType.Attachment>;
declare function use_current_VariableDeclaration_SummaryType_Attachment(
    use: TypeOnly<typeof current.SummaryType.Attachment>);
use_current_VariableDeclaration_SummaryType_Attachment(
    get_old_VariableDeclaration_SummaryType_Attachment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_SummaryType.Attachment": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_SummaryType_Attachment():
    TypeOnly<typeof current.SummaryType.Attachment>;
declare function use_old_VariableDeclaration_SummaryType_Attachment(
    use: TypeOnly<typeof old.SummaryType.Attachment>);
use_old_VariableDeclaration_SummaryType_Attachment(
    get_current_VariableDeclaration_SummaryType_Attachment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryType.Blob": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummaryType_Blob():
    TypeOnly<old.SummaryType.Blob>;
declare function use_current_TypeAliasDeclaration_SummaryType_Blob(
    use: TypeOnly<current.SummaryType.Blob>);
use_current_TypeAliasDeclaration_SummaryType_Blob(
    get_old_TypeAliasDeclaration_SummaryType_Blob());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryType.Blob": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummaryType_Blob():
    TypeOnly<current.SummaryType.Blob>;
declare function use_old_TypeAliasDeclaration_SummaryType_Blob(
    use: TypeOnly<old.SummaryType.Blob>);
use_old_TypeAliasDeclaration_SummaryType_Blob(
    get_current_TypeAliasDeclaration_SummaryType_Blob());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_SummaryType.Blob": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_SummaryType_Blob():
    TypeOnly<typeof old.SummaryType.Blob>;
declare function use_current_VariableDeclaration_SummaryType_Blob(
    use: TypeOnly<typeof current.SummaryType.Blob>);
use_current_VariableDeclaration_SummaryType_Blob(
    get_old_VariableDeclaration_SummaryType_Blob());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_SummaryType.Blob": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_SummaryType_Blob():
    TypeOnly<typeof current.SummaryType.Blob>;
declare function use_old_VariableDeclaration_SummaryType_Blob(
    use: TypeOnly<typeof old.SummaryType.Blob>);
use_old_VariableDeclaration_SummaryType_Blob(
    get_current_VariableDeclaration_SummaryType_Blob());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryType.Handle": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummaryType_Handle():
    TypeOnly<old.SummaryType.Handle>;
declare function use_current_TypeAliasDeclaration_SummaryType_Handle(
    use: TypeOnly<current.SummaryType.Handle>);
use_current_TypeAliasDeclaration_SummaryType_Handle(
    get_old_TypeAliasDeclaration_SummaryType_Handle());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryType.Handle": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummaryType_Handle():
    TypeOnly<current.SummaryType.Handle>;
declare function use_old_TypeAliasDeclaration_SummaryType_Handle(
    use: TypeOnly<old.SummaryType.Handle>);
use_old_TypeAliasDeclaration_SummaryType_Handle(
    get_current_TypeAliasDeclaration_SummaryType_Handle());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_SummaryType.Handle": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_SummaryType_Handle():
    TypeOnly<typeof old.SummaryType.Handle>;
declare function use_current_VariableDeclaration_SummaryType_Handle(
    use: TypeOnly<typeof current.SummaryType.Handle>);
use_current_VariableDeclaration_SummaryType_Handle(
    get_old_VariableDeclaration_SummaryType_Handle());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_SummaryType.Handle": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_SummaryType_Handle():
    TypeOnly<typeof current.SummaryType.Handle>;
declare function use_old_VariableDeclaration_SummaryType_Handle(
    use: TypeOnly<typeof old.SummaryType.Handle>);
use_old_VariableDeclaration_SummaryType_Handle(
    get_current_VariableDeclaration_SummaryType_Handle());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryType.Tree": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummaryType_Tree():
    TypeOnly<old.SummaryType.Tree>;
declare function use_current_TypeAliasDeclaration_SummaryType_Tree(
    use: TypeOnly<current.SummaryType.Tree>);
use_current_TypeAliasDeclaration_SummaryType_Tree(
    get_old_TypeAliasDeclaration_SummaryType_Tree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryType.Tree": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummaryType_Tree():
    TypeOnly<current.SummaryType.Tree>;
declare function use_old_TypeAliasDeclaration_SummaryType_Tree(
    use: TypeOnly<old.SummaryType.Tree>);
use_old_TypeAliasDeclaration_SummaryType_Tree(
    get_current_TypeAliasDeclaration_SummaryType_Tree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_SummaryType.Tree": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_SummaryType_Tree():
    TypeOnly<typeof old.SummaryType.Tree>;
declare function use_current_VariableDeclaration_SummaryType_Tree(
    use: TypeOnly<typeof current.SummaryType.Tree>);
use_current_VariableDeclaration_SummaryType_Tree(
    get_old_VariableDeclaration_SummaryType_Tree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_SummaryType.Tree": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_SummaryType_Tree():
    TypeOnly<typeof current.SummaryType.Tree>;
declare function use_old_VariableDeclaration_SummaryType_Tree(
    use: TypeOnly<typeof old.SummaryType.Tree>);
use_old_VariableDeclaration_SummaryType_Tree(
    get_current_VariableDeclaration_SummaryType_Tree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryTypeNoHandle": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummaryTypeNoHandle():
    TypeOnly<old.SummaryTypeNoHandle>;
declare function use_current_TypeAliasDeclaration_SummaryTypeNoHandle(
    use: TypeOnly<current.SummaryTypeNoHandle>);
use_current_TypeAliasDeclaration_SummaryTypeNoHandle(
    get_old_TypeAliasDeclaration_SummaryTypeNoHandle());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryTypeNoHandle": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummaryTypeNoHandle():
    TypeOnly<current.SummaryTypeNoHandle>;
declare function use_old_TypeAliasDeclaration_SummaryTypeNoHandle(
    use: TypeOnly<old.SummaryTypeNoHandle>);
use_old_TypeAliasDeclaration_SummaryTypeNoHandle(
    get_current_TypeAliasDeclaration_SummaryTypeNoHandle());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_TreeEntry": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_TreeEntry():
    TypeOnly<old.TreeEntry>;
declare function use_current_EnumDeclaration_TreeEntry(
    use: TypeOnly<current.TreeEntry>);
use_current_EnumDeclaration_TreeEntry(
    get_old_EnumDeclaration_TreeEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_TreeEntry": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_TreeEntry():
    TypeOnly<current.TreeEntry>;
declare function use_old_EnumDeclaration_TreeEntry(
    use: TypeOnly<old.TreeEntry>);
use_old_EnumDeclaration_TreeEntry(
    get_current_EnumDeclaration_TreeEntry());
