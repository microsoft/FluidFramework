/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import path from "node:path";
import {
	type Logger,
	type Package,
	type PackageJson,
	typeOnly,
} from "@fluidframework/build-tools";
import { mkdirSync, readJson, rmSync, writeFileSync } from "fs-extra";
import * as resolve from "resolve.exports";
import { PackageCommand } from "../../BasePackageCommand";
import { ApiLevel } from "../../library";
import {
	ensureDevDependencyExists,
	generateCompatibilityTestCases,
	getTypeTestFilePath,
	initializeProjectsAndLoadFiles,
	typeDataFromFile,
} from "../../typeTestUtils";

export default class GenerateTypetestsCommand extends PackageCommand<
	typeof GenerateTypetestsCommand
> {
	static readonly description = "Generates type tests for a package or group of packages.";

	static readonly flags = {
		...PackageCommand.flags,
	} as const;

	// public async init(): Promise<void> {
	// 	await super.init();
	// 	if (this.flags.version === undefined) {
	// 		if (this.flags.path === undefined) {
	// 			this.error("Either version or path must be specified.");
	// 		}
	// 		const pkg = new Package(path.join(this.flags.path, "package.json"), "none");
	// 		this.versionToCheck = pkg.version;
	// 	} else {
	// 		this.versionToCheck = this.flags.version;
	// 	}
	// }

	// private readonly invalidVersions: Package[] = [];
	protected async processPackage(pkg: Package): Promise<void> {
		// Do not check that file exists before opening:
		// Doing so is a time of use vs time of check issue so opening the file could fail anyway.
		// Do not catch error from opening file since the default behavior is fine (exits process with error showing useful message)

		const currentPackageJson = (await readJson("package.json")) as PackageJson;
		const currentPackageName = currentPackageJson.name;
		const previousPackageName = `${currentPackageJson.name}-previous`;
		const previousBasePath = path.join(pkg.directory, "node_modules", previousPackageName);
		const previousPackagJsonPath = path.join(previousBasePath, "package.json");

		ensureDevDependencyExists(currentPackageJson, previousPackageName);
		this.verbose(`Reading package.json at ${previousPackagJsonPath}`);
		const previousPackageJson = (await readJson(previousPackagJsonPath)) as PackageJson;

		const typeTestOutputFile = getTypeTestFilePath(currentPackageJson);
		if (currentPackageJson.typeValidation?.disabled === true) {
			this.info("skipping type test generation because they are disabled in package.json");
			rmSync(
				typeTestOutputFile,
				// force means to ignore the error if the file does not exist.
				{ force: true },
			);
			this.verbose(`Deleted file: ${typeTestOutputFile}`);
			this.exit(0);
		}

		const [currentTypeDefs, previousTypeDefs] = [
			getTypePathFromPackage(currentPackageJson, ApiLevel.internal, this),
			getTypePathFromPackage(previousPackageJson, ApiLevel.internal, this),
		];

		if (currentTypeDefs === undefined) {
			this.error(`No type definitions found for ${currentPackageName}`);
		}
		this.verbose(`Found current type definitions at: ${currentTypeDefs}`);

		if (previousTypeDefs === undefined) {
			this.error(`No type definitions found for ${previousPackageName}`);
		}
		this.verbose(`Found previous type definitions at: ${previousTypeDefs}`);

		// if (typeDefinitionFilePath === undefined) {
		// 	throw new Error("Could not determine the type definition file path from package.json");
		// }

		// const reader = new ApiLevelReader(this, /(?:)/, false /* onlyInternal */);
		// const currentExports = reader.get(currentPackageName);
		// if (currentExports === undefined) {
		// 	this.error(`No exports found for ${currentPackageName}`);
		// }

		// const previousExports = reader.get(previousPackageName);
		// if (previousExports === undefined) {
		// 	this.error(`No exports found for ${currentPackageName}`);
		// }

		const { currentFile, previousFile } = initializeProjectsAndLoadFiles(
			previousTypeDefs,
			previousBasePath,
			this.logger,
		);

		this.verbose(`Loaded source file for current version: ${currentFile.getFilePath()}`);
		this.verbose(`Loaded source file for previous version: ${previousFile.getFilePath()}`);

		const currentTypeMap = typeDataFromFile(currentFile);
		const previousData = [...typeDataFromFile(previousFile).values()];

		// eslint-disable-next-line unicorn/consistent-function-scoping
		function compareString(a: string, b: string): number {
			return a > b ? 1 : a < b ? -1 : 0;
		}
		previousData.sort((a, b) => compareString(a.name, b.name));

		const fileHeader: string[] = [
			`
/*!
	* Copyright (c) Microsoft Corporation and contributors. All rights reserved.
	* Licensed under the MIT License.
	*/

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */

import type * as old from "${previousPackageName}/internal";
import type * as current from "../../index.js";
		`.trim(),
			typeOnly,
		];

		const testCases = generateCompatibilityTestCases(
			previousData,
			currentTypeMap,
			currentPackageJson,
			fileHeader,
		);

		mkdirSync("./src/test/types", { recursive: true });

		writeFileSync(typeTestOutputFile, testCases.join("\n"));
		console.log(`generated ${path.resolve(typeTestOutputFile)}`);
	}

	public async run(): Promise<void> {
		// Calls processPackage on all packages.
		await super.run();
	}
}

// /**
//  * Checks the package.json's `exports` entries and `types` field for a type definition file path.
//  * @returns string representing type definition file path
//  */
// export async function getTypeDefinitionFilePath(
// 	packageBasePath: string,
// ): Promise<string | undefined> {
// 	const previousPackageJsonPath = tryGetPreviousPackageJsonPath(packageBasePath);
// 	const packageJson = (await readJson(previousPackageJsonPath)) as PackageJson;
// 	// Check the exports entries
// 	if (packageJson.exports !== undefined) {
// 		return getTypePathFromExport(packageJson, packageBasePath);
// 	}

// 	// Check the types field from the previous package.json as a fallback
// 	if (packageJson.types === undefined) {
// 		throw new Error(
// 			`Type definition file path could not be determined from ${previousPackageJsonPath}. No 'exports' nor 'type' fields found.`,
// 		);
// 	} else {
// 		return path.join(packageBasePath, packageJson.types);
// 	}
// }

/**
 * Attempts to extract the type definition file path from the 'exports' field of a given package.json.
 * Checks both 'import' and 'require' resolution methods to find the appropriate path.
 * If the path is found, it is returned. Otherwise, an error is thrown.
 * @param packageJson - An object representing the previous package json
 * @param packageDirectory - A string representing the path to the root directory of the "previous" package dependency.
 * @returns A type definition filepath based on the appropriate export, or undefined if it cannot be found.
 */
export function getTypePathFromPackage(
	packageJson: PackageJson,
	level: ApiLevel,
	log: Logger,
): string | undefined {
	// conditions: ["default", "types", "import", "node"]
	const exports =
		resolve.exports(packageJson, `./${level}`, { conditions: ["types"] }) ??
		resolve.exports(packageJson, `./${level}`, { conditions: ["types"], require: true });

	const typesPath =
		exports === undefined || exports.length === 0
			? packageJson.types ?? packageJson.typings
			: exports[0];

	if (typesPath === undefined) {
		throw new Error(
			`No types could be found in exports or types/typings field: ${packageJson.name}`,
		);
	}
	return typesPath;
}
