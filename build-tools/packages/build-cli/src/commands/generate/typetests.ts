/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import path from "node:path";
import {
	type Logger,
	type Package,
	type PackageJson,
	typeOnly,
} from "@fluidframework/build-tools";
import { mkdirSync, readJson, rmSync, writeFileSync } from "fs-extra";
import * as resolve from "resolve.exports";
import { PackageCommand } from "../../BasePackageCommand";
import { ApiLevel } from "../../library";
import {
	ensureDevDependencyExists,
	generateCompatibilityTestCases,
	getTypeTestFilePath,
	initializeProjectsAndLoadFiles,
	typeDataFromFile,
} from "../../typeTestUtils";
import type { ExportsRecordValue } from "./entrypoints";

export default class GenerateTypetestsCommand extends PackageCommand<
	typeof GenerateTypetestsCommand
> {
	static readonly description = "Generates type tests for a package or group of packages.";

	static readonly flags = {
		...PackageCommand.flags,
	} as const;

	// public async init(): Promise<void> {
	// 	await super.init();
	// 	if (this.flags.version === undefined) {
	// 		if (this.flags.path === undefined) {
	// 			this.error("Either version or path must be specified.");
	// 		}
	// 		const pkg = new Package(path.join(this.flags.path, "package.json"), "none");
	// 		this.versionToCheck = pkg.version;
	// 	} else {
	// 		this.versionToCheck = this.flags.version;
	// 	}
	// }

	// private readonly invalidVersions: Package[] = [];
	protected async processPackage(pkg: Package): Promise<void> {
		// Do not check that file exists before opening:
		// Doing so is a time of use vs time of check issue so opening the file could fail anyway.
		// Do not catch error from opening file since the default behavior is fine (exits process with error showing useful message)

		const currentPackageJson = (await readJson("package.json")) as PackageJson;
		const currentPackageName = currentPackageJson.name;
		const previousPackageName = `${currentPackageJson.name}-previous`;
		const previousBasePath = path.join(pkg.directory, "node_modules", previousPackageName);
		const previousPackagJsonPath = path.join(previousBasePath, "package.json");

		ensureDevDependencyExists(currentPackageJson, previousPackageName);
		this.verbose(`Reading package.json at ${previousPackagJsonPath}`);
		const previousPackageJson = (await readJson(previousPackagJsonPath)) as PackageJson;

		const typeTestOutputFile = getTypeTestFilePath(currentPackageJson);
		if (currentPackageJson.typeValidation?.disabled === true) {
			this.info("skipping type test generation because they are disabled in package.json");
			rmSync(
				typeTestOutputFile,
				// force means to ignore the error if the file does not exist.
				{ force: true },
			);
			this.verbose(`Deleted file: ${typeTestOutputFile}`);
			this.exit(0);
		}

		const [currentTypeDefs, previousTypeDefs] = [
			// First try the internal paths, but fall back to public otherwise.
			getTypesPathFromPackage(currentPackageJson, ApiLevel.internal, this) ??
				getTypesPathFromPackage(currentPackageJson, ApiLevel.public, this),
			getTypesPathFromPackage(previousPackageJson, ApiLevel.internal, this) ??
				getTypesPathFromPackage(previousPackageJson, ApiLevel.public, this),
		];

		if (currentTypeDefs === undefined) {
			this.error(`No type definitions found for ${currentPackageName}`);
		}
		this.verbose(`Found current type definitions at: ${currentTypeDefs}`);

		if (previousTypeDefs === undefined) {
			this.error(`No type definitions found for ${previousPackageName}`);
		}
		this.verbose(`Found previous type definitions at: ${previousTypeDefs}`);

		const { currentFile, previousFile } = initializeProjectsAndLoadFiles(
			previousTypeDefs,
			previousBasePath,
			this.logger,
		);

		this.verbose(`Loaded source file for current version: ${currentFile.getFilePath()}`);
		this.verbose(`Loaded source file for previous version: ${previousFile.getFilePath()}`);

		const currentTypeMap = typeDataFromFile(currentFile);
		const previousData = [...typeDataFromFile(previousFile).values()];

		// eslint-disable-next-line unicorn/consistent-function-scoping
		function compareString(a: string, b: string): number {
			return a > b ? 1 : a < b ? -1 : 0;
		}
		previousData.sort((a, b) => compareString(a.name, b.name));

		const fileHeader: string[] = [
			`
/*!
	* Copyright (c) Microsoft Corporation and contributors. All rights reserved.
	* Licensed under the MIT License.
	*/

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */

import type * as old from "${previousPackageName}/internal";
import type * as current from "../../index.js";
		`.trim(),
			"\n",
			typeOnly,
		];

		const testCases = generateCompatibilityTestCases(
			previousData,
			currentTypeMap,
			currentPackageJson,
			fileHeader,
		);

		mkdirSync("./src/test/types", { recursive: true });

		writeFileSync(typeTestOutputFile, testCases.join("\n"));
		console.log(`generated ${path.resolve(typeTestOutputFile)}`);
	}
}

/**
 * Finds the path to the types of a package using the package's export map.
 * If the path is found, it is returned. Otherwise, an error is thrown.
 *
 * This implementation uses resolve.exports to resolve the path to types for a level.
 *
 * @param packageJson - The package.json object to check for types paths.
 * @param level - An API level to get types paths for.
 * @returns A package relative path to the types.
 */
export function getTypesPathFromPackage(
	packageJson: PackageJson,
	level: ApiLevel = ApiLevel.internal,
	log: Logger,
): string {
	const exports =
		// resolve.exports sets some conditions by default, so the ones we supply supplement the defaults. For clarity the
		// applied conditions are noted in comments.

		// First try to resolve with the "import" condition, assuming the package is either ESM-only or dual-format.
		// conditions: ["default", "types", "import", "node"]
		resolve.exports(packageJson, `./${level}`, { conditions: ["types"] }) ??
		// If nothing is found when using the "import" condition, try the "require" condition. It may be possible to do this
		// in a single call to resolve.exports, but the documentation is a little unclear. This seems a safe, if inelegant
		// solution.
		// conditions: ["default", "types", "require", "node"]
		resolve.exports(packageJson, `./${level}`, { conditions: ["types"], require: true });

	const typesPath =
		exports === undefined || exports.length === 0
			? packageJson.types ?? packageJson.typings
			: exports[0];

	if (typesPath === undefined) {
		throw new Error(
			`No types could be found in exports or types/typings field: ${packageJson.name}`,
		);
	}
	return typesPath;
}

/**
 * Finds the path to the types of a package using the package's export map.
 * If the path is found, it is returned. Otherwise, an error is thrown.
 *
 * This implementation iterates through the individual exports entries recursively
 *
 * @param exports - The exports from package.json
 * @param level - An API level to get types paths for.
 * @returns A package relative path to the types.
 */
export function findTypesPathForApiLevel(
	exports: ExportsRecordValue,
	level: ApiLevel = ApiLevel.internal,
	log: Logger,
): string | undefined {
	for (const [entry, exportsValue] of Object.entries(exports)) {
		if (typeof exportsValue === "string") {
			if (entry === "types") {
				// const isTypeOnly = !(
				// 	"default" in exports ||
				// 	"import" in exports ||
				// 	"require" in exports
				// );
				return exportsValue;
			}
		} else if (exportsValue !== null) {
			if (Array.isArray(exportsValue)) {
				continue;
			}
			const deepFind = findTypesPathForApiLevel(exportsValue, level, log);
			if (deepFind !== undefined) {
				return deepFind;
			}
		}
	}

	return undefined;
}
