/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import path from "node:path";
import {
	type Logger,
	type Package,
	type PackageJson,
	typeOnly,
} from "@fluidframework/build-tools";
import { Flags } from "@oclif/core";
import { mkdirSync, readJson, rmSync, writeFileSync } from "fs-extra";
import * as resolve from "resolve.exports";
import { PackageCommand } from "../../BasePackageCommand";
import { ApiLevel, knownApiLevels } from "../../library";
import {
	ensureDevDependencyExists,
	generateCompatibilityTestCases,
	getTypeTestFilePath,
	initializeProjectsAndLoadFiles,
	typeDataFromFile,
} from "../../typeTestUtils";
import type { ExportsRecordValue } from "./entrypoints";

export default class GenerateTypetestsCommand extends PackageCommand<
	typeof GenerateTypetestsCommand
> {
	static readonly description = "Generates type tests for a package or group of packages.";

	static readonly flags = {
		level: Flags.string({
			description: "What API level to generate tests for.",
			default: ApiLevel.internal,
			options: knownApiLevels,
		}),
		publicFallback: Flags.boolean({
			description:
				"Use the public entrypoint as a fallback if the API at the requested level is not found. Pass --no-publicFallback to disable.",
			default: true,
		}),
		...PackageCommand.flags,
	} as const;

	protected async processPackage(pkg: Package): Promise<void> {
		// This cast is safe because oclif has already ensured only known ApiLevel values get to this point.
		const level = this.flags.level as ApiLevel;

		// Do not check that file exists before opening:
		// Doing so is a time of use vs time of check issue so opening the file could fail anyway.
		// Do not catch error from opening file since the default behavior is fine (exits process with error showing useful message)
		const currentPackageJson = pkg.packageJson;
		const previousPackageName = `${currentPackageJson.name}-previous`;
		const previousBasePath = path.join(pkg.directory, "node_modules", previousPackageName);
		const previousPackagJsonPath = path.join(previousBasePath, "package.json");

		ensureDevDependencyExists(currentPackageJson, previousPackageName);
		this.verbose(`Reading package.json at ${previousPackagJsonPath}`);
		const previousPackageJson = (await readJson(previousPackagJsonPath)) as PackageJson;

		const typeTestOutputFile = getTypeTestFilePath(currentPackageJson);
		if (currentPackageJson.typeValidation?.disabled === true) {
			this.info("skipping type test generation because they are disabled in package.json");
			rmSync(
				typeTestOutputFile,
				// force means to ignore the error if the file does not exist.
				{ force: true },
			);
			this.verbose(`Deleted file: ${typeTestOutputFile}`);
			this.exit(0);
		}

		const [currentTypeDefs, currentPackageLevel] = this.getTypesPathWithFallback(
			currentPackageJson,
			level,
		);
		this.verbose(`Found ${currentPackageLevel} type definitions at: ${currentTypeDefs}`);

		const [previousTypeDefs, previousPackageLevel] = this.getTypesPathWithFallback(
			previousPackageJson,
			level,
		);
		this.verbose(`Found ${previousPackageLevel} type definitions at: ${previousTypeDefs}`);

		const { currentFile, previousFile } = initializeProjectsAndLoadFiles(
			previousTypeDefs,
			previousBasePath,
			this.logger,
		);

		this.verbose(`Loaded source file for current version: ${currentFile.getFilePath()}`);
		this.verbose(`Loaded source file for previous version: ${previousFile.getFilePath()}`);

		const currentTypeMap = typeDataFromFile(currentFile);
		const previousData = [...typeDataFromFile(previousFile).values()];

		// eslint-disable-next-line unicorn/consistent-function-scoping
		function compareString(a: string, b: string): number {
			return a > b ? 1 : a < b ? -1 : 0;
		}
		previousData.sort((a, b) => compareString(a.name, b.name));

		const fileHeader: string[] = [
			`
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */

import type * as old from "${previousPackageName}${
				previousPackageLevel === ApiLevel.public ? "" : `/${previousPackageLevel}`
			}";
import type * as current from "../../index.js";
		`.trim(),
			"\n",
			typeOnly,
		];

		const testCases = generateCompatibilityTestCases(
			previousData,
			currentTypeMap,
			currentPackageJson,
			fileHeader,
		);

		mkdirSync("./src/test/types", { recursive: true });

		writeFileSync(typeTestOutputFile, testCases.join("\n"));
		console.log(`generated ${path.resolve(typeTestOutputFile)}`);
	}

	private getTypesPathWithFallback(
		packageJson: PackageJson,
		level: ApiLevel,
	): [string, ApiLevel] {
		let chosenLevel: ApiLevel = level;
		// First try the requested paths, but fall back to public otherwise if configured.
		let typeDefs: string | undefined = getTypesPathFromPackage(packageJson, level, this);

		if (typeDefs === undefined) {
			// Try the public types if configured to do so. If public types are found adjust the level accordingly.
			typeDefs = this.flags.publicFallback
				? getTypesPathFromPackage(packageJson, ApiLevel.public, this)
				: undefined;
			if (typeDefs === undefined) {
				this.error(`No type definitions found for ${packageJson.name}`, { exit: 1 });
			}
			chosenLevel = ApiLevel.public;
		}
		return [typeDefs, chosenLevel];
	}
}

/**
 * Finds the path to the types of a package using the package's export map.
 * If the path is found, it is returned. Otherwise, an error is thrown.
 *
 * This implementation uses resolve.exports to resolve the path to types for a level.
 *
 * @param packageJson - The package.json object to check for types paths.
 * @param level - An API level to get types paths for.
 * @returns A package relative path to the types.
 */
export function getTypesPathFromPackage(
	packageJson: PackageJson,
	level: ApiLevel,
	log: Logger,
): string {
	const exports =
		// resolve.exports sets some conditions by default, so the ones we supply supplement the defaults. For clarity the
		// applied conditions are noted in comments.

		// First try to resolve with the "import" condition, assuming the package is either ESM-only or dual-format.
		// conditions: ["default", "types", "import", "node"]
		resolve.exports(packageJson, `./${level}`, { conditions: ["types"] }) ??
		// If nothing is found when using the "import" condition, try the "require" condition. It may be possible to do this
		// in a single call to resolve.exports, but the documentation is a little unclear. This seems a safe, if inelegant
		// solution.
		// conditions: ["default", "types", "require", "node"]
		resolve.exports(packageJson, `./${level}`, { conditions: ["types"], require: true });

	const typesPath =
		exports === undefined || exports.length === 0
			? packageJson.types ?? packageJson.typings
			: exports[0];

	if (typesPath === undefined) {
		throw new Error(
			`No types could be found in exports or types/typings field: ${packageJson.name}`,
		);
	}
	return typesPath;
}

/**
 * Finds the path to the types of a package using the package's export map.
 * If the path is found, it is returned. Otherwise it returns undefined.
 *
 * This implementation iterates through the individual exports entries recursively
 *
 * @param exports - The exports from package.json
 * @param level - An API level to get types paths for.
 * @returns A package relative path to the types.
 */
export function findTypesPathForApiLevel(
	exports: ExportsRecordValue,
	level: ApiLevel,
	log: Logger,
): string | undefined {
	for (const [entry, exportsValue] of Object.entries(exports)) {
		if (typeof exportsValue === "string") {
			if (entry === "types") {
				return exportsValue;
			}
		} else if (exportsValue !== null) {
			if (Array.isArray(exportsValue)) {
				continue;
			}
			const deepFind = findTypesPathForApiLevel(exportsValue, level, log);
			if (deepFind !== undefined) {
				return deepFind;
			}
		}
	}

	return undefined;
}
