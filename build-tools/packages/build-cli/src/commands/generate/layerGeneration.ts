/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { existsSync } from "node:fs";
import { readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import type { Logger, Package } from "@fluidframework/build-tools";
import { Flags } from "@oclif/core";
import { diff, parse } from "semver";
import { PackageCommand } from "../../BasePackageCommand.js";
import type { PackageSelectionDefault } from "../../flags.js";

// Approximate month as 33 days to add some buffer and avoid over-counting months in longer spans.
export const daysInMonthApproximation = 33;

export default class UpdateGenerationCommand extends PackageCommand<
	typeof UpdateGenerationCommand
> {
	static readonly description =
		"Updates the generation and release date for layer compatibility.";

	static readonly flags = {
		generationDir: Flags.directory({
			description: "The directory where the generation file is located.",
			default: "./src",
		}),
		generationFileName: Flags.string({
			description: `The file name for the generation file.`,
			default: `layerGenerationState.ts`,
		}),
		minimumCompatWindowMonths: Flags.integer({
			description: `The minimum compatibility window in months that is supported across all Fluid layers.`,
			default: 3,
		}),
		...PackageCommand.flags,
	} as const;

	protected defaultSelection = "dir" as PackageSelectionDefault;

	protected async processPackage(pkg: Package): Promise<void> {
		const { generationDir, generationFileName, minimumCompatWindowMonths } = this.flags;
		const generationFile = path.join(pkg.directory, generationDir, generationFileName);

		if (!existsSync(generationFile)) {
			// Early exit; no error.
			this.info(`File ${generationFile} doesn't exist; skipping.`);
			return;
		}

		const currentPkgVersion = pkg.version;
		const generationFileContents = await readFile(generationFile, "utf8");
		const newGeneration = maybeGetNewGeneration(
			generationFileName,
			generationFileContents,
			minimumCompatWindowMonths,
			currentPkgVersion,
			this.logger,
		);
		if (newGeneration === undefined) {
			// No update needed; early exit.
			return;
		}

		const releaseDateFormatted = formatDateForLayerFile(new Date());
		await writeFile(
			generationFile,
			generateLayerFileContent(newGeneration, releaseDateFormatted, currentPkgVersion),
			{
				encoding: "utf8",
			},
		);
		this.info(`Layer generation updated to ${newGeneration}`);
	}
}

/**
 * Formats a Date object into the MM/DD/YYYY string format used in layer generation files.
 *
 * @param date - The Date object to format
 * @returns A string in MM/DD/YYYY format with zero-padded month and day values
 *
 * @example
 * ```typescript
 * const date = new Date(2025, 10, 29); // November 29, 2025
 * const formatted = formatDateForLayerFile(date);
 * console.log(formatted); // "11/29/2025"
 * ```
 */
export function formatDateForLayerFile(date: Date): string {
	const yyyy = date.getFullYear();
	const mmNumber = date.getMonth() + 1; // Months start at 0!
	const ddNumber = date.getDate();
	const dd = ddNumber < 10 ? `0${ddNumber}` : ddNumber.toString();
	const mm = mmNumber < 10 ? `0${mmNumber}` : mmNumber.toString();
	return `${mm}/${dd}/${yyyy}`;
}

/**
 * Generates the complete content for a layer generation TypeScript file.
 *
 * Creates a properly formatted TypeScript file with copyright header, autogenerated warning,
 * and exports for generation number, release date, and package version.
 *
 * @param generation - The layer compatibility generation number
 * @param releaseDate - The release date in MM/DD/YYYY format
 * @param pkgVersion - The semantic version of the package (e.g., "2.0.0")
 * @returns The complete file content as a string ready to be written to disk
 *
 * @example
 * ```typescript
 * const content = generateLayerFileContent(5, "10/29/2025", "2.1.0");
 * // Returns a complete TypeScript file with exports:
 * // export const generation = 5;
 * // export const releaseDate = "10/29/2025";
 * // export const pkgVersion = "2.1.0";
 * ```
 */
export function generateLayerFileContent(
	generation: number,
	releaseDate: string,
	pkgVersion: string,
): string {
	return `/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 */

export const generation = ${generation};
export const releaseDate = "${releaseDate}";
export const pkgVersion = "${pkgVersion}";
`;
}

/**
 * Determines if a new generation should be generated based on package version changes and time since
 * the last release.
 *
 * This function parses an existing layer generation file and decides whether to increment the generation
 * number based on:
 * 1. Whether the package version has changed since the last update
 * 2. How much time has elapsed since the previous release date
 * 3. The minimum compatibility window constraints
 *
 * The generation increment is calculated as the number of months since the previous release,
 * but capped at (minimumCompatWindowMonths - 1) to maintain compatibility requirements.
 *
 * @param generationFileName - The name of the generation file (used for error messages)
 * @param generationFileContents - The raw content of the existing generation file to parse
 * @param minimumCompatWindowMonths - The maximum number of months of compatibility to maintain across layers
 * @param currentPkgVersion - The current package version to compare against the stored version
 * @param log - Logger instance for verbose output about the calculation process
 * @returns The new generation number if an update is needed, or undefined if no update is required
 *
 * @throws Error When the generation file content doesn't match the expected format
 * @throws Error When the current date is older than the previous release date
 */
export function maybeGetNewGeneration(
	generationFileName: string,
	generationFileContents: string,
	minimumCompatWindowMonths: number,
	currentPkgVersion: string,
	log: Logger,
): number | undefined {
	const match = generationFileContents.match(
		/.*\nexport const generation = (\d+);[\n\r]*export const releaseDate = "(\d+\/\d+\/\d+)";[\n\r]*export const pkgVersion = "(\d+\.\d+\.\d+)";.*/m,
	);
	if (match === null) {
		throw new Error(`${generationFileName} content not as expected`);
	}

	const previousPkgVersion = match[3];
	const parsedCurrent = parse(currentPkgVersion);
	if (parsedCurrent === null) {
		throw new Error(`Current package version ${currentPkgVersion} is not a valid semver`);
	}

	// Only "minor" or "major" version changes trigger generation updates.
	// The extra check for patch > 0 is to handle scenarios where the generation was not updated on a minor release
	// due to time constraints, and a patch is subsequently released. In that case, we don't want to update generation
	// on the patch. For example:
	// - 1.0.0 -> 1.1.0 - No generation update due to time constraints. The previousPkgVersion is still 1.0.0.
	// - 1.1.0 -> 1.1.1 - The generation should not update even though the version changed, because it's only a patch.
	let result: string | null;
	if (
		parsedCurrent.patch > 0 ||
		(result = diff(currentPkgVersion, previousPkgVersion)) === null ||
		(result !== "minor" && result !== "major")
	) {
		log.verbose(`No minor or major release since last update; skipping generation update.`);
		return undefined;
	}

	log.verbose(
		`Previous package version: ${previousPkgVersion}, Current package version: ${currentPkgVersion}`,
	);

	const today = new Date();
	const previousReleaseDateString = match[2];
	const previousReleaseDate = new Date(previousReleaseDateString);
	const timeDiff = today.getTime() - previousReleaseDate.getTime();
	if (timeDiff < 0) {
		throw new Error("Current date is older that previous release date");
	}
	const daysBetweenReleases = Math.round(timeDiff / (1000 * 60 * 60 * 24));
	const monthsBetweenReleases = Math.floor(daysBetweenReleases / daysInMonthApproximation);
	log.verbose(`Previous release date: ${previousReleaseDate}, Today: ${today}`);
	log.verbose(
		`Time between releases: ${daysBetweenReleases} day(s) or ~${monthsBetweenReleases} month(s)`,
	);

	const previousGeneration = Number(match[1]);
	const newGeneration =
		previousGeneration + Math.min(monthsBetweenReleases, minimumCompatWindowMonths - 1);
	if (newGeneration === previousGeneration) {
		log.verbose(`Generation remains the same (${newGeneration}); skipping generation update.`);
		return undefined;
	}

	return newGeneration;
}
