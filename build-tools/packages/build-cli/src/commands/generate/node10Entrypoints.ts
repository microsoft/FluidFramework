/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import fs from "node:fs/promises";
import JSON5 from "json5";

import type { Logger } from "@fluidframework/build-tools";
import * as resolve from "resolve.exports";
import type { PackageJson, TsConfigJson } from "type-fest";
import { BaseCommand, Node10CompatExportData } from "../../library/index.js";
import type { CommandLogger } from "../../logging.js";

export default class GenerateNode10EntrypointsCommand extends BaseCommand<
	typeof GenerateNode10EntrypointsCommand
> {
	static readonly description =
		`Generates node10 type declaration entrypoints for Fluid Framework API levels (/alpha, /beta, /internal etc.) as found in package.json "exports"`;

	public async run(): Promise<void> {
		const packageJson = await readPackageJson();

		const tsconfig = await readTsConfig();

		let emitDeclarationOnly = false;
		if (tsconfig.compilerOptions?.emitDeclarationOnly !== undefined) {
			emitDeclarationOnly = true;
		}

		const mapNode10CompatExportPathToData = mapExportPathsFromPackage(
			packageJson,
			emitDeclarationOnly,
			this.logger,
		);

		if (mapNode10CompatExportPathToData.size === 0) {
			throw new Error(
				'There are no API level "exports" requiring Node10 type compatibility generation.',
			);
		}

		await generateNode10TypeEntrypoints(mapNode10CompatExportPathToData, this.logger);
	}
}

export function mapExportPathsFromPackage(
	packageJson: PackageJson,
	emitDeclarationOnly: boolean,
	logger?: Logger,
): Map<string, Node10CompatExportData> {
	const mapKeyToOutput = new Map<string, Node10CompatExportData>();

	const { exports } = packageJson;

	if (typeof exports !== "object" || exports === null) {
		throw new Error('no valid "exports" within package properties');
	}

	if (Array.isArray(exports)) {
		// eslint-disable-next-line unicorn/prefer-type-error
		throw new Error(`required entrypoints cannot be generated for "exports" array`);
	}

	// Iterate through exports looking for properties with values matching keys in map.
	for (const [exportPath, exportValue] of Object.entries(exports)) {
		if (typeof exportValue !== "object") {
			logger?.verbose(`ignoring non-object export path "${exportPath}": "${exportValue}"`);
			continue;
		}
		if (exportValue === null) {
			logger?.verbose(`ignoring null export path "${exportPath}"`);
			continue;
		}
		if (Array.isArray(exportValue)) {
			logger?.verbose(`ignoring array export path "${exportPath}"`);
			continue;
		}

		// Exclude root "." path as "types" should handle that.
		if (exportPath === ".") {
			continue;
		}

		const resolvedExport = resolve.exports(packageJson, exportPath, {
			conditions: ["types"],
		});
		if (resolvedExport === undefined || resolvedExport.length === 0) {
			throw new Error(`exports for ${exportPath} is undefined`);
		}

		const node10ExportPath = resolvedExport[0]
			.replace(/\/index(\.d\.[cm]?ts)?$/, "/internal$1")
			.replace(/^.*\//, "");

		mapKeyToOutput.set(node10ExportPath, {
			relPath: resolvedExport[0],
			isTypeOnly: emitDeclarationOnly,
		});
	}

	return mapKeyToOutput;
}

async function readPackageJson(): Promise<PackageJson> {
	const packageJson = await fs.readFile("./package.json", { encoding: "utf8" });
	return JSON.parse(packageJson) as PackageJson;
}

// Reads and parses the `tsconfig.json` file in the current directory.
export async function readTsConfig(): Promise<TsConfigJson> {
	const tsConfigContent = await fs.readFile("./tsconfig.json", { encoding: "utf8" });
	return JSON5.parse(tsConfigContent);
}

const generatedHeader: string = `/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by "flub generate node10Entrypoints" in @fluid-tools/build-cli.
 */

`;

async function generateNode10TypeEntrypoints(
	mapExportPathToData: Map<string, Node10CompatExportData>,
	log: CommandLogger,
): Promise<void> {
	/**
	 * List of out file save promises. Used to collect generated file save
	 * promises so we can await them all at once.
	 */
	const fileSavePromises: Promise<void>[] = [];

	for (const [outFile, { relPath, isTypeOnly }] of mapExportPathToData.entries()) {
		log.info(`\tGenerating ${outFile}`);
		const jsImport = relPath.replace(/\.d\.([cm]?)ts/, ".$1js");
		fileSavePromises.push(
			fs.writeFile(
				outFile,
				isTypeOnly
					? `${generatedHeader}export type * from "${relPath}";\n`
					: `${generatedHeader}export * from "${jsImport}";\n`,
				"utf8",
			),
		);
	}

	if (fileSavePromises.length === 0) {
		log.info(`\tNo Node10 compat files generated.`);
	}

	await Promise.all(fileSavePromises);
}
