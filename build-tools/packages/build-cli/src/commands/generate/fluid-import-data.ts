/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { readFileSync, writeJSON } from "fs-extra";
import globby from "globby";
import readPkgUp from "read-pkg-up";

import { Flags } from "@oclif/core";
import { BaseCommand } from "../../base";
import { ApiLevel } from "../../library";

// This type is also used in modify:fluid-imports
export interface MemberDataRaw {
	name: string;
	level: ApiLevel;
	kind?: string;
}

// This type is also used in modify:fluid-imports
export type ApiLevelDataFile = Record<string, MemberDataRaw[]>;

export class GenerateFluidImportDataFilesCommand extends BaseCommand<
	typeof GenerateFluidImportDataFilesCommand
> {
	static readonly summary =
		"Generates data files for use with the modify:fluid-imports command.";

	static readonly description =
		"API metadata is extracted from api.md files which are generated by api-extractor.";

	static readonly enableJsonFlag = true;

	static readonly flags = {
		glob: Flags.string({
			description:
				"A glob to select api-extractor report markdown files. This flag can be used multiple times; the array of glob strings will be passed to globby in the order provided. This allows you to exclude (negate) portions earlier glob paths.",
			default: ["**/*.api.md"],
			multiple: true,
			required: true,
		}),
		out: Flags.file({
			description: "A path to a file in which to output the generated data.",
			charAliases: ["o"],
		}),
		...BaseCommand.flags,
	};

	/**
	 * A regular expression that extracts API metadata from selected files
	 *
	 * The expression captures three groups:
	 *
	 * Group 1: Level (a.g. alpha)
	 * Group 2: Kind (e.g. function)
	 * Group 3: Name
	 */
	private readonly extractionRegex =
		/\s*@(alpha|beta|public|internal).*?export(?: abstract)?\s*(\w*)\s(\w*).*?[;{]/gs;

	public async run(): Promise<ApiLevelDataFile> {
		const { glob: globs, json: jsonFlag, out: outputFile } = this.flags;

		if (outputFile === undefined && jsonFlag !== true) {
			this.error(`You must provide either --out or --json.`, { exit: 1 });
		}

		this.info(`Checking globs: [${globs.join(", ")}]`);

		const files = await globby(globs, {
			absolute: true,
			gitignore: true,
			deep: 7,
		});
		this.info(`Found ${files.length} input files.`);

		const outputData: ApiLevelDataFile = {};

		for (const file of files) {
			this.verbose(`Reading ${file}.`);
			const packageName = readPkgUp.sync({ cwd: file })?.packageJson.name;
			if (packageName === undefined) {
				this.error(`Cannot find package name matching file '${file}'.`, { exit: 1 });
			}
			this.verbose(`Found package ${packageName}.`);

			if (Object.hasOwn(outputData, packageName)) {
				this.warning(
					`APIs for package ${packageName} have already been processed. Skipping file ${file}`,
				);
				continue;
			}

			const contents = readFileSync(file, { encoding: "utf8" });
			const apisExtracted = new Set<string>();
			const members: MemberDataRaw[] = [];

			for (const match of contents.matchAll(this.extractionRegex)) {
				const [level, kind, name] = match.slice(1);
				if (apisExtracted.has(name)) {
					this.warning(`Skipping duplicate API entry: ${name}`);
					continue;
				}
				apisExtracted.add(name);
				members.push({
					name,
					level: level as ApiLevel,
					kind,
				});
			}
			outputData[packageName] = members;
		}

		if (outputFile !== undefined) {
			await writeJSON(outputFile, outputData, { spaces: "\t" });
			this.info(`Output written to ${outputFile}`);
		}

		return outputData;
	}
}
