/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { strict as assert } from "node:assert";
import { writeFile } from "node:fs/promises";
import path from "node:path";
import { loadFluidBuildConfig } from "@fluidframework/build-tools";
import { Flags } from "@oclif/core";
import { StringBuilder } from "@rushstack/node-core-library";
import { format as prettier } from "prettier";

import { releaseGroupFlag } from "../../flags.js";
import {
	BaseCommand,
	DEFAULT_CHANGESET_PATH,
	UNKNOWN_SECTION,
	groupBySection,
	loadChangesets,
} from "../../library/index.js";

/**
 * Generates a summary of all changesets and outputs the results to a file. This is used to generate an UPCOMING.md file
 * that provides a single place where developers can see upcoming changes.
 */
export default class GenerateReleaseNotesCommand extends BaseCommand<
	typeof GenerateReleaseNotesCommand
> {
	static readonly summary = ``;

	// Enables the global JSON flag in oclif.
	static readonly enableJsonFlag = true;

	static readonly flags = {
		releaseGroup: releaseGroupFlag({
			required: true,
		}),
		releaseType: Flags.custom<"major" | "minor">({
			char: "t",
			description: "The type of release for which the release notes are being generated.",
			options: ["major", "minor"],
			required: true,
			parse: async (input) => {
				if (input === "major" || input === "minor") {
					return input;
				}

				throw new Error(`Invalid release type: ${input}`);
			},
		})(),
		out: Flags.file({
			description: `Output the results to this file.`,
			required: true,
			default: "RELEASE_NOTES.md",
			// exists: true
		}),
		...BaseCommand.flags,
	} as const;

	static readonly examples = [
		// {
		// 	description: `Generate UPCOMING.md for the client release group using the minor changesets.`,
		// 	command: "<%= config.bin %> <%= command.id %> -g client -t minor",
		// },
		// {
		// 	description: `You can output a different file using the --out flag.`,
		// 	command: "<%= config.bin %> <%= command.id %> -g client -t minor --out testOutput.md",
		// },
	];

	public async run(): Promise<string> {
		const context = await this.getContext();
		const { flags, logger } = this;

		const releaseGroup = context.repo.releaseGroups.get(flags.releaseGroup);
		if (releaseGroup === undefined) {
			this.errorLog(`Unknown release group: ${flags.releaseGroup}`);
			this.exit(2);
		}

		const { releaseNotes: releaseNotesConfig } = loadFluidBuildConfig(
			context.gitRepo.resolvedRoot,
		);
		if (releaseNotesConfig === undefined) {
			this.errorLog(
				`No releaseNotes config found. Make sure the 'releaseNotes' section of the build config exists.`,
			);
			this.exit(2);
		}

		const changesetDir = path.join(releaseGroup.directory, DEFAULT_CHANGESET_PATH);
		const changesets = await loadChangesets(changesetDir, logger);

		const { version } = releaseGroup;
		const header = `<!-- THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. -->`;
		const footer = `### 🛠️ Start Building Today!\n\nPlease continue to engage with us on GitHub
[Discussion](https://github.com/microsoft/FluidFramework/discussions) and
[Issue](https://github.com/microsoft/FluidFramework/issues) pages as you adopt Fluid Framework!
`;
		const intro = `# Fluid Framework v${version}`;

		this.info(`Loaded ${changesets.length} changes.`);
		assert(flags.releaseType !== undefined, `Release type must be provided.`);

		const bySection = groupBySection(changesets);

		const unknownSection = bySection.get(UNKNOWN_SECTION);
		for (const changeset of unknownSection ?? []) {
			this.warning(
				`Changeset doesn't map to known sections. Check its metadata: ${changeset.sourceFile}`,
			);
		}

		const body = new StringBuilder();
		// Only iterate through the known sections; the unknown section is omitted.
		for (const { name, heading: sectionHead } of releaseNotesConfig.sections) {
			this.verbose(`Building "${name}" section with header: ${sectionHead}`);
			const changes = bySection.get(name)?.filter(
				(change) =>
					// filter out changes that shouldn't be in the release notes
					(change.additionalMetadata?.includeInReleaseNotes ?? true) === true,
			);
			if (changes === undefined || changes.length === 0) {
				continue;
			}

			body.append(`## ${sectionHead}\n\n`);
			for (const change of changes) {
				if (change.changeTypes.includes("minor") || flags.releaseType === "major") {
					body.append(`### ${change.summary}\n\n${change.content}\n\n`);
					const affectedPackages = Object.keys(change.metadata)
						.map((pkg) => `- ${pkg}\n`)
						.join("");
					body.append(`#### Packages affected\n\n${affectedPackages}\n\n`);
				} else {
					this.info(
						`Excluding changeset: ${path.basename(change.sourceFile)} because it has no ${
							flags.releaseType
						} changes.`,
					);
				}
			}
		}

		const contents = `${header}\n\n${intro}\n\n${body.toString()}\n\n${footer}`;
		const outputPath = path.join(context.repo.resolvedRoot, flags.out);
		this.info(`Writing output file: ${outputPath}`);
		await writeFile(
			outputPath,
			await prettier(contents, { proseWrap: "never", parser: "markdown" }),
		);

		return contents;
	}
}
