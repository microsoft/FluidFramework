/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { writeFile } from "node:fs/promises";
import path from "node:path";
import { type ReleaseNotesSection, loadFluidBuildConfig } from "@fluidframework/build-tools";
import { Flags } from "@oclif/core";
import { StringBuilder } from "@rushstack/node-core-library";
import { format as prettier } from "prettier";
import { remark } from "remark";
import remarkGfm from "remark-gfm";
import remarkGithub, { defaultBuildUrl } from "remark-github";
import admonitions from "remark-github-beta-blockquote-admonitions";
import remarkToc from "remark-toc";

import { releaseGroupFlag } from "../../flags.js";
import {
	BaseCommand,
	DEFAULT_CHANGESET_PATH,
	UNKNOWN_SECTION,
	difference,
	fluidCustomChangeSetMetadataDefaults,
	groupBySection,
	loadChangesets,
} from "../../library/index.js";

/**
 * Generates release notes from individual changeset files.
 */
export default class GenerateReleaseNotesCommand extends BaseCommand<
	typeof GenerateReleaseNotesCommand
> {
	static readonly summary = `Generates release notes from individual changeset files.`;

	// Enables the global JSON flag in oclif.
	static readonly enableJsonFlag = true;

	static readonly flags = {
		releaseGroup: releaseGroupFlag({
			required: true,
		}),
		releaseType: Flags.custom<"major" | "minor">({
			char: "t",
			description: "The type of release for which the release notes are being generated.",
			options: ["major", "minor"],
			required: true,
			parse: async (input) => {
				if (input === "major" || input === "minor") {
					return input;
				}

				throw new Error(`Invalid release type: ${input}`);
			},
		})(),
		out: Flags.file({
			description: `Output the results to this file.`,
			required: true,
			default: "RELEASE_NOTES.md",
		}),
		includeUnknown: Flags.boolean({
			default: false,
			description:
				"Pass this flag to include changesets in unknown sections in the generated release notes. By default, these are excluded.",
		}),
		...BaseCommand.flags,
	} as const;

	static readonly examples = [
		{
			description: `Generate release notes for a minor release of the client release group.`,
			command: "<%= config.bin %> <%= command.id %> -g client -t minor",
		},
		{
			description: `You can output a different file using the --out flag.`,
			command:
				"<%= config.bin %> <%= command.id %> -g client -t minor --out RELEASE_NOTES/2.1.0.md",
		},
	];

	public async run(): Promise<string> {
		const context = await this.getContext();
		const { flags, logger } = this;

		const releaseGroup = context.repo.releaseGroups.get(flags.releaseGroup);
		if (releaseGroup === undefined) {
			this.error(`Unknown release group: ${flags.releaseGroup}`, { exit: 2 });
		}

		const { releaseNotes: releaseNotesConfig } = loadFluidBuildConfig(
			context.gitRepo.resolvedRoot,
		);
		if (releaseNotesConfig === undefined) {
			this.error(
				`No release notes config found. Make sure the 'releaseNotes' section of the build config exists.`,
				{ exit: 2 },
			);
		}

		const changesetDir = path.join(releaseGroup.directory, DEFAULT_CHANGESET_PATH);
		const changesets = await loadChangesets(changesetDir, logger);

		const { version } = releaseGroup;
		const header = `<!-- THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. -->`;
		const footer = `### üõ†Ô∏è Start Building Today!\n\nPlease continue to engage with us on GitHub
[Discussion](https://github.com/microsoft/FluidFramework/discussions) and
[Issue](https://github.com/microsoft/FluidFramework/issues) pages as you adopt Fluid Framework!
`;
		const intro = `# Fluid Framework v${version}\n\n## Contents`;

		this.info(`Loaded ${changesets.length} changes.`);

		const bySection = groupBySection(changesets);
		const sectionsToBuild: Map<string, ReleaseNotesSection> = new Map(
			Object.entries(releaseNotesConfig.sections),
		);

		// Create a new scope since this code section is standalone
		{
			const unknownSection = bySection.get(UNKNOWN_SECTION);
			for (const changeset of unknownSection ?? []) {
				if (changeset.additionalMetadata?.includeInReleaseNotes !== false) {
					this.warning(
						`Changeset doesn't map to known sections. Check its metadata: ${changeset.sourceFile}`,
					);
				}
			}

			const sectionsInChangesets = new Set<string>(bySection.keys());
			const configuredSections = new Set<string>(Object.keys(releaseNotesConfig.sections));
			const unknownSections = difference(sectionsInChangesets, configuredSections).add(
				UNKNOWN_SECTION,
			);

			if (flags.includeUnknown) {
				for (const sectionName of unknownSections) {
					sectionsToBuild.set(sectionName, { heading: `Unknown section: ${sectionName}` });
				}
			} else {
				for (const section of unknownSections) {
					if (section !== UNKNOWN_SECTION) {
						this.error(
							`Could not find a configuration for a section named "${section}". All sections must be configured.`,
							{ exit: 2 },
						);
					}
				}
			}
		}

		const body = new StringBuilder();
		for (const [name, { heading: sectionHead }] of sectionsToBuild.entries()) {
			this.verbose(`Building "${name}" section with header: ${sectionHead}`);
			const changes = bySection.get(name)?.filter(
				(change) =>
					// filter out changes that shouldn't be in the release notes
					(change.additionalMetadata?.includeInReleaseNotes ??
						fluidCustomChangeSetMetadataDefaults.includeInReleaseNotes) === true,
			);
			if (changes === undefined || changes.length === 0) {
				this.info(`No changes in section "${name}", so it will be omitted.`);
				continue;
			}

			body.append(`## ${sectionHead}\n\n`);
			for (const change of changes) {
				if (change.changeTypes.includes("minor") || flags.releaseType === "major") {
					const pr = change.commit?.githubPullRequest;
					const changeTitle = pr === undefined ? change.summary : `${change.summary} (#${pr})`;
					body.append(`### ${changeTitle}\n\n${change.body}\n\n`);

					body.append(`#### Change details\n\n`);
					if (change.commit?.sha !== undefined) {
						body.append(`Commit: ${change.commit.sha}\n\n`);
					}
					const affectedPackages = Object.keys(change.metadata)
						.map((pkg) => `- ${pkg}\n`)
						.join("");
					body.append(`Affected packages:\n\n${affectedPackages}`);
				} else {
					this.info(
						`Excluding changeset: ${path.basename(change.sourceFile)} because it has no ${
							flags.releaseType
						} changes.`,
					);
				}
			}
		}

		const contents = String(
			await remark()
				.use(remarkGfm)
				.use(admonitions)
				.use(remarkGithub, {
					buildUrl(values) {
						// Disable linking mentions
						return values.type === "mention" ? false : defaultBuildUrl(values);
					},
				})
				.use(remarkToc, { maxDepth: 3, skip: ".*Start Building Today.*" })
				.process(`${header}\n\n${intro}\n\n${body.toString()}\n\n${footer}`),
		);

		const outputPath = path.join(context.repo.resolvedRoot, flags.out);
		this.info(`Writing output file: ${outputPath}`);
		await writeFile(
			outputPath,
			await prettier(contents, { proseWrap: "never", parser: "markdown" }),
		);

		return contents;
	}
}
