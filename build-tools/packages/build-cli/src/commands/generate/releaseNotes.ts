/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { strict as assert } from "node:assert";
import { writeFile } from "node:fs/promises";
import path from "node:path";
import { loadFluidBuildConfig } from "@fluidframework/build-tools";
import { Flags } from "@oclif/core";
import { StringBuilder } from "@rushstack/node-core-library";
import { format as prettier } from "prettier";
import { remark } from "remark";
import remarkToc from "remark-toc";

import { releaseGroupFlag } from "../../flags.js";
import {
	BaseCommand,
	DEFAULT_CHANGESET_PATH,
	UNKNOWN_SECTION,
	groupBySection,
	loadChangesets,
} from "../../library/index.js";

/**
 * Generates a summary of all changesets and outputs the results to a file. This is used to generate an UPCOMING.md file
 * that provides a single place where developers can see upcoming changes.
 */
export default class GenerateReleaseNotesCommand extends BaseCommand<
	typeof GenerateReleaseNotesCommand
> {
	static readonly summary = ``;

	// Enables the global JSON flag in oclif.
	static readonly enableJsonFlag = true;

	static readonly flags = {
		releaseGroup: releaseGroupFlag({
			required: true,
		}),
		releaseType: Flags.custom<"major" | "minor">({
			char: "t",
			description: "The type of release for which the release notes are being generated.",
			options: ["major", "minor"],
			required: true,
			parse: async (input) => {
				if (input === "major" || input === "minor") {
					return input;
				}

				throw new Error(`Invalid release type: ${input}`);
			},
		})(),
		out: Flags.file({
			description: `Output the results to this file.`,
			required: true,
			default: "RELEASE_NOTES.md",
			// exists: true
		}),
		...BaseCommand.flags,
	} as const;

	static readonly examples = [
		{
			description: `Generate release notes for a minor release of the client release group.`,
			command: "<%= config.bin %> <%= command.id %> -g client -t minor",
		},
		{
			description: `You can output a different file using the --out flag.`,
			command:
				"<%= config.bin %> <%= command.id %> -g client -t minor --out RELEASE_NOTES/2.1.0.md",
		},
	];

	public async run(): Promise<string> {
		const context = await this.getContext();
		const { flags, logger } = this;

		const releaseGroup = context.repo.releaseGroups.get(flags.releaseGroup);
		if (releaseGroup === undefined) {
			this.errorLog(`Unknown release group: ${flags.releaseGroup}`);
			this.exit(2);
		}

		const { releaseNotes: releaseNotesConfig } = loadFluidBuildConfig(
			context.gitRepo.resolvedRoot,
		);
		if (releaseNotesConfig === undefined) {
			this.errorLog(
				`No releaseNotes config found. Make sure the 'releaseNotes' section of the build config exists.`,
			);
			this.exit(2);
		}

		const changesetDir = path.join(releaseGroup.directory, DEFAULT_CHANGESET_PATH);
		const changesets = await loadChangesets(changesetDir, logger);

		const { version } = releaseGroup;
		const header = `<!-- THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. -->`;
		const footer = `### ðŸ› ï¸ Start Building Today!\n\nPlease continue to engage with us on GitHub
[Discussion](https://github.com/microsoft/FluidFramework/discussions) and
[Issue](https://github.com/microsoft/FluidFramework/issues) pages as you adopt Fluid Framework!
`;
		const intro = `# Fluid Framework v${version}`;

		this.info(`Loaded ${changesets.length} changes.`);
		assert(flags.releaseType !== undefined, `Release type must be provided.`);

		const bySection = groupBySection(changesets);

		const unknownSection = bySection.get(UNKNOWN_SECTION);
		for (const changeset of unknownSection ?? []) {
			this.warning(
				`Changeset doesn't map to known sections. Check its metadata: ${changeset.sourceFile}`,
			);
		}

		const body = new StringBuilder();
		// Iterate through all the sections; if a section has no config a warning will be logged and it will be omitted from
		// the output.
		for (const [sectionName, sectionChangesets] of bySection) {
			const sectionConfig = releaseNotesConfig.sections.find((s) => s.name === sectionName);
			if (sectionConfig === undefined) {
				this.warning(
					`Could not find a configuration for a section named "${sectionName}". The ${sectionChangesets.length} changesets in this section will be omitted.`,
				);
				continue;
			}

			this.verbose(`Building "${sectionName}" section with header: ${sectionConfig.heading}`);
			const changes = sectionChangesets.filter(
				(change) =>
					// filter out changes that shouldn't be in the release notes
					(change.additionalMetadata?.includeInReleaseNotes ?? true) === true,
			);
			if (changes.length === 0) {
				this.verbose(`Excluding section "${sectionName}" because it has no changes.`);
				continue;
			}

			body.append(`## ${sectionConfig.heading}\n\n`);
			for (const change of changes) {
				if (change.changeTypes.includes("minor") || flags.releaseType === "major") {
					body.append(`### ${change.summary}\n\n${change.content}\n\n`);
					const affectedPackages = Object.keys(change.metadata)
						.map((pkg) => `- ${pkg}\n`)
						.join("");
					body.append(`#### Packages affected\n\n${affectedPackages}\n\n`);
				} else {
					this.info(
						`Excluding changeset: ${path.basename(change.sourceFile)} because it has no ${
							flags.releaseType
						} changes.`,
					);
				}
			}
		}

		// const contents = `${header}\n\n${intro}\n\n${body.toString()}\n\n${footer}`;
		const contents = String(
			await remark()
				.use(remarkToc)
				.process(`${header}\n\n${intro}\n\n${body.toString()}\n\n${footer}`),
		);

		const outputPath = path.join(context.repo.resolvedRoot, flags.out);
		this.info(`Writing output file: ${outputPath}`);
		await writeFile(
			outputPath,
			await prettier(contents, { proseWrap: "never", parser: "markdown" }),
		);

		return contents;
	}
}
