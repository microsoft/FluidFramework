/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { strict as assert } from "node:assert";
import type { IFluidCompatibilityMetadata } from "@fluidframework/build-tools";
import { formatISO } from "date-fns";
import { describe, it } from "mocha";

import {
	DAYS_IN_MONTH_APPROXIMATION,
	DEFAULT_MINIMUM_COMPAT_WINDOW_MONTHS,
	generateLayerFileContent,
	isCurrentPackageVersionPatch,
	maybeGetNewGeneration,
} from "../../../library/compatLayerGeneration.js";

describe("generate:compatLayerGeneration", () => {
	const minimumCompatWindowMonths = DEFAULT_MINIMUM_COMPAT_WINDOW_MONTHS;

	it("should correctly detect patch versions", () => {
		assert.strictEqual(isCurrentPackageVersionPatch("1.2.3"), true);
		assert.strictEqual(isCurrentPackageVersionPatch("1.2.0"), false);
		assert.strictEqual(isCurrentPackageVersionPatch("3.0.0"), false);
	});

	it("should generate correctly formatted output", () => {
		const result = generateLayerFileContent(42);

		// Check that it includes the copyright header
		assert(result.includes("Copyright (c) Microsoft Corporation"));
		assert(result.includes("THIS IS AN AUTOGENERATED FILE"));

		// Check the exports
		assert(result.includes("export const generation = 42;"));

		// Ensure proper formatting
		assert(/export const generation = \d+;/.test(result));
	});

	it("should not change generation when package version has not changed", () => {
		const currentVersion = "2.0.0";
		const mockMetadata: IFluidCompatibilityMetadata = {
			generation: 5,
			releaseDate: "2025-01-01",
			releasePkgVersion: currentVersion,
		};

		const result = maybeGetNewGeneration(
			currentVersion,
			mockMetadata,
			minimumCompatWindowMonths,
		);

		assert.strictEqual(result, undefined);
	});

	it("should not change generation when only patch version has changed", () => {
		const previousGeneration = 5;
		const previousVersion = "2.0.0";
		const currentVersion = "2.0.1"; // Only patch change

		// Create a date 2 months ago (should normally trigger increment)
		const oldDate = new Date();
		oldDate.setDate(oldDate.getDate() - 2 * DAYS_IN_MONTH_APPROXIMATION);
		const oldDateString = formatISO(oldDate, { representation: "date" });
		const mockMetadata: IFluidCompatibilityMetadata = {
			generation: previousGeneration,
			releaseDate: oldDateString,
			releasePkgVersion: previousVersion,
		};

		const result = maybeGetNewGeneration(
			currentVersion,
			mockMetadata,
			minimumCompatWindowMonths,
		);

		assert.strictEqual(result, undefined);
	});

	it("should update generation when time since last release is 1+ months with minor version change", () => {
		const previousGeneration = 5;
		const monthsSincePreviousRelease = 1; // More than 1 month

		// Create a date monthsSincePreviousRelease months ago
		const oldDate = new Date();
		oldDate.setDate(
			oldDate.getDate() - monthsSincePreviousRelease * DAYS_IN_MONTH_APPROXIMATION,
		);
		const oldDateString = formatISO(oldDate, { representation: "date" });
		const mockMetadata: IFluidCompatibilityMetadata = {
			generation: previousGeneration,
			releaseDate: oldDateString,
			releasePkgVersion: "1.0.0",
		};
		const result = maybeGetNewGeneration(
			"1.1.0", // Minor version change
			mockMetadata,
			minimumCompatWindowMonths,
		);

		assert.strictEqual(result, previousGeneration + monthsSincePreviousRelease);
	});

	it("should update generation when time since last release is 1+ months with major version change", () => {
		const previousGeneration = 5;
		const monthsSincePreviousRelease = 2; // 2 months

		// Create a date monthsSincePreviousRelease months ago
		const oldDate = new Date();
		oldDate.setDate(
			oldDate.getDate() - monthsSincePreviousRelease * DAYS_IN_MONTH_APPROXIMATION,
		);
		const oldDateString = formatISO(oldDate, { representation: "date" });
		const mockMetadata: IFluidCompatibilityMetadata = {
			generation: previousGeneration,
			releaseDate: oldDateString,
			releasePkgVersion: "1.0.0",
		};
		const result = maybeGetNewGeneration(
			"2.0.0", // Major version change
			mockMetadata,
			minimumCompatWindowMonths,
		);

		assert.strictEqual(result, previousGeneration + monthsSincePreviousRelease);
	});

	it("should not update generation when time since last release is < 1 month", () => {
		const previousGeneration = 5;
		const daysSincePreviousRelease = 31; // Less than approx. 1 month

		// Create a date daysSincePreviousRelease days ago
		const oldDate = new Date();
		oldDate.setDate(oldDate.getDate() - daysSincePreviousRelease);
		const oldDateString = formatISO(oldDate, { representation: "date" });
		const mockMetadata: IFluidCompatibilityMetadata = {
			generation: previousGeneration,
			releaseDate: oldDateString,
			releasePkgVersion: "1.0.0",
		};
		const result = maybeGetNewGeneration(
			"1.1.0", // Minor version change but not enough time elapsed
			mockMetadata,
			minimumCompatWindowMonths,
		);

		assert.strictEqual(result, undefined);
	});

	it("should cap generation increment to minimumCompatWindowMonths - 1", () => {
		const previousGeneration = 5;

		// Create a date 12 months ago (way beyond threshold)
		const veryOldDate = new Date();
		veryOldDate.setFullYear(veryOldDate.getFullYear() - 1);
		const oldDateString = formatISO(veryOldDate, { representation: "date" });
		const mockMetadata: IFluidCompatibilityMetadata = {
			generation: previousGeneration,
			releaseDate: oldDateString,
			releasePkgVersion: "1.0.0",
		};
		const result = maybeGetNewGeneration(
			"2.0.0", // Major version change
			mockMetadata,
			minimumCompatWindowMonths,
		);

		assert.strictEqual(result, previousGeneration + minimumCompatWindowMonths - 1);
	});

	it("should throw error for invalid date format", () => {
		// Test with invalid date format
		const invalidMetadata: IFluidCompatibilityMetadata = {
			generation: 5,
			releaseDate: "invalid-date", // Invalid date format
			releasePkgVersion: "1.0.0",
		};

		assert.throws(() => {
			maybeGetNewGeneration("2.0.0", invalidMetadata, minimumCompatWindowMonths);
		}, /not a valid date/);
	});

	it("should throw error for invalid package version format", () => {
		// Test with invalid package version format
		const invalidMetadata: IFluidCompatibilityMetadata = {
			generation: 5,
			releaseDate: "2025-11-03",
			releasePkgVersion: "invalid-version", // Invalid package version
		};

		assert.throws(() => {
			maybeGetNewGeneration("2.0.0", invalidMetadata, minimumCompatWindowMonths);
		}, /Invalid Version/);
	});

	it("should return generation 1 when fluidCompatMetadata is an empty object (opt-in)", () => {
		const emptyMetadata = {}; // Empty object indicates opt-in

		const result = maybeGetNewGeneration("2.0.0", emptyMetadata, minimumCompatWindowMonths);

		assert.strictEqual(result, 1);
	});

	it("should return generation 1 for opt-in regardless of package version", () => {
		const emptyMetadata = {}; // Empty object indicates opt-in

		// Test with patch version
		let result = maybeGetNewGeneration("1.0.1", emptyMetadata, minimumCompatWindowMonths);
		assert.strictEqual(result, 1);

		// Test with minor version
		result = maybeGetNewGeneration("1.1.0", emptyMetadata, minimumCompatWindowMonths);
		assert.strictEqual(result, 1);

		// Test with major version
		result = maybeGetNewGeneration("2.0.0", emptyMetadata, minimumCompatWindowMonths);
		assert.strictEqual(result, 1);
	});

	it("should return generation 1 for opt-in with any minimumCompatWindowMonths value", () => {
		const emptyMetadata = {}; // Empty object indicates opt-in

		// Test with different minimumCompatWindowMonths values
		let result = maybeGetNewGeneration("2.0.0", emptyMetadata, 1);
		assert.strictEqual(result, 1);

		result = maybeGetNewGeneration("2.0.0", emptyMetadata, 6);
		assert.strictEqual(result, 1);

		result = maybeGetNewGeneration("2.0.0", emptyMetadata, 12);
		assert.strictEqual(result, 1);
	});

	it("should fail when current date is older than previous release date", () => {
		// Test with a future date
		const futureDate = new Date();
		futureDate.setMonth(futureDate.getMonth() + 2);
		const futureDateString = formatISO(futureDate, { representation: "date" });
		const mockMetadata: IFluidCompatibilityMetadata = {
			generation: 5,
			releaseDate: futureDateString,
			releasePkgVersion: "1.0.0",
		};

		assert.throws(
			() =>
				maybeGetNewGeneration(
					"2.0.0", // Major version change
					mockMetadata,
					minimumCompatWindowMonths,
				),
			/Current date is older than previous release date/,
		);
	});
});
