/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import type { CoverageReport } from "./getCoverageMetrics.js";

// List of packages to be ignored from code coverage analysis
const codeCoverageComparisonIgnoreList: string[] = [
	"experimental",
	"examples",
	"packages.common.core-interfaces",
	"packages.common.core-utils",
	"packages.common.driver-definitions",
	"packages.common.container-definitions",
	"packages.common.client-utils",
];

/**
 * Type for the code coverage report generated by comparing the baseline and pr code coverage
 */
export interface CodeCoverageComparison {
	/**
	 * Name of the package
	 */
	packageName: string;
	/**
	 * Line coverage in baseline build
	 */
	lineCoverageInBaseline: number;
	/**
	 * Line coverage in pr build
	 */
	lineCoverageInPr: number;
	/**
	 * difference between line coverage in pr build and baseline build
	 */
	lineCoverageDiff: number;
	/**
	 * branch coverage in baseline build
	 */
	branchCoverageInBaseline: number;
	/**
	 * branch coverage in pr build
	 */
	branchCoverageInPr: number;
	/**
	 * difference between branch coverage in pr build and baseline build
	 */
	branchCoverageDiff: number;
	/**
	 * Flag to indicate if the package is new
	 */
	isNewPackage: boolean;
}

/**
 * Compares the code coverage for pr and baseline build and returns an array of objects with comparison results,
 * one per package.
 */
export const compareCodeCoverage = (
	baselineCoverageReport: CoverageReport[],
	prCoverageReport: CoverageReport[],
): CodeCoverageComparison[] => {
	const results: CodeCoverageComparison[] = [];

	prCoverageReport.forEach((packageInPrReport: CoverageReport) => {
		const { packageName } = packageInPrReport;
		if (packageName.length === 0) {
			return;
		}
		// Return if the package being updated in the PR is in the list of packages to be ignored
		for (const ignorePackageName of codeCoverageComparisonIgnoreList) {
			if (packageName.startsWith(ignorePackageName)) {
				return;
			}
		}

		let lineCoverageInPr = 0;
		let lineCoverageInBaseline = 0;
		let branchCoverageInPr = 0;
		let branchCoverageInBaseline = 0;

		lineCoverageInPr = packageInPrReport.lineCoverage;
		branchCoverageInPr = packageInPrReport.branchCoverage;

		// Find the package in baseline report and update metrics
		const packageInBaselineReport = baselineCoverageReport.find(
			(report) => report.packageName === packageName,
		);
		const isNewPackage = packageInBaselineReport === undefined;
		if (packageInBaselineReport) {
			lineCoverageInBaseline = packageInBaselineReport.lineCoverage;
			branchCoverageInBaseline = packageInBaselineReport.branchCoverage;
		}

		results.push({
			packageName,
			lineCoverageInBaseline,
			lineCoverageInPr,
			lineCoverageDiff: lineCoverageInPr - lineCoverageInBaseline,
			branchCoverageInBaseline,
			branchCoverageInPr,
			branchCoverageDiff: branchCoverageInPr - branchCoverageInBaseline,
			isNewPackage,
		});
	});

	return results;
};
