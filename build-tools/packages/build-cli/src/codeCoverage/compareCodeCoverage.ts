/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import type { CoverageMetric } from "./getCoverageMetrics.js";

// List of packages to be ignored from code coverage analysis. These are just prefixes. Reason is that when the package src code contains different
// folders, coverage report calculates coverage of sub folders separately. Also, for example we want to ignore all packages inside examples. So, checking
// prefix helps. If we want to ignore a specific package, we can add the package name directly. Also, the coverage report generates paths using dots as a
// separator for the path.
const codeCoverageComparisonIgnoreList: string[] = [
	"experimental",
	"examples",
	"packages.common.core-interfaces",
	"packages.common.core-utils",
	"packages.common.driver-definitions",
	"packages.common.container-definitions",
	"packages.common.client-utils",
];

/**
 * Type for the code coverage report generated by comparing the baseline and pr code coverage
 */
export interface CodeCoverageComparison {
	/**
	 * Path of the package
	 */
	packagePath: string;
	/**
	 * Line coverage in baseline build (as a percent)
	 */
	lineCoverageInBaseline: number;
	/**
	 * Line coverage in pr build (as a percent)
	 */
	lineCoverageInPr: number;
	/**
	 * difference between line coverage in pr build and baseline build (percentage points)
	 */
	lineCoverageDiff: number;
	/**
	 * branch coverage in baseline build (as a percent)
	 */
	branchCoverageInBaseline: number;
	/**
	 * branch coverage in pr build (as a percent)
	 */
	branchCoverageInPr: number;
	/**
	 * difference between branch coverage in pr build and baseline build (percentage points)
	 */
	branchCoverageDiff: number;
	/**
	 * Flag to indicate if the package is new
	 */
	isNewPackage: boolean;
}

/**
 * Compares the code coverage for pr and baseline build and returns an array of objects with comparison results,
 * one per package.
 */
export const compareCodeCoverage = (
	baselineCoverageReport: CoverageMetric[],
	prCoverageReport: CoverageMetric[],
): CodeCoverageComparison[] => {
	const results: CodeCoverageComparison[] = [];

	for (const packageInPrReport of prCoverageReport) {
		const { packagePath } = packageInPrReport;
		if (packagePath.length === 0) {
			continue;
		}
		let skip = false;
		// Return if the package being updated in the PR is in the list of packages to be ignored
		for (const ignorePackageName of codeCoverageComparisonIgnoreList) {
			if (packagePath.startsWith(ignorePackageName)) {
				skip = true;
				break;
			}
		}

		if (skip) {
			continue;
		}

		const lineCoverageInPr = packageInPrReport.lineCoverage;
		let lineCoverageInBaseline = 0;
		const branchCoverageInPr = packageInPrReport.branchCoverage;
		let branchCoverageInBaseline = 0;

		// Find the package in baseline report and update metrics
		const packageInBaselineReport = baselineCoverageReport.find(
			(report) => report.packagePath === packagePath,
		);
		const isNewPackage = packageInBaselineReport === undefined;
		if (packageInBaselineReport) {
			lineCoverageInBaseline = packageInBaselineReport.lineCoverage;
			branchCoverageInBaseline = packageInBaselineReport.branchCoverage;
		}

		results.push({
			packagePath,
			lineCoverageInBaseline,
			lineCoverageInPr,
			lineCoverageDiff: lineCoverageInPr - lineCoverageInBaseline,
			branchCoverageInBaseline,
			branchCoverageInPr,
			branchCoverageDiff: branchCoverageInPr - branchCoverageInBaseline,
			isNewPackage,
		});
	}

	return results;
};
