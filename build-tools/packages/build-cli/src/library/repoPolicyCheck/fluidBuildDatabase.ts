/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Provides {@link FluidBuildDatabase} to associate build scripts and their outputs.
 */

import path from "node:path";

import { type Package, TscUtils } from "@fluidframework/build-tools";
import type { TsConfigJson } from "type-fest";

import { getGenerateEntrypointsOutput } from "../commands/index.js";

type PackageName = string;
type Script = string;
/**
 * `${package.name}#${script}`
 */
export type PackageNameAndScript = string;
type AbsoluteFilePath = string;
type ModuleType = "CommonJS" | "ESM";
/**
 * Representation of a package.json script that generates "build" output.
 */
export interface BuildScript {
	/**
	 * Name of the package where script is located.
	 */
	packageName: PackageName;
	/**
	 * Name of the script within package.
	 */
	script: Script;
	/**
	 * The recognized module type, if any, that the script generates.
	 * An `undefined` value indicates that script is not known to be associated
	 * with a certain module type. This might happen for script that only copies
	 * files as copying files has no inherent association to one module type or
	 * the other.
	 */
	moduleType: ModuleType | undefined;
}

/**
 * Determines output generated by `flub` commands.
 *
 * @remarks Only needs to handle flub commands that are used in build. And then
 * only needs to determine enough of outputs to tie tasks together.
 */
function flubOutput(
	pkg: Package,
	commandLine: string,
): { files: AbsoluteFilePath[]; type: ModuleType | undefined } | undefined {
	if (!commandLine.startsWith("flub generate entrypoints")) {
		// ignored - not recognized as build command
		return undefined;
	}

	// Determine select output from flub generate entrypoints.
	const outputs = getGenerateEntrypointsOutput(pkg.packageJson, commandLine);
	const files: AbsoluteFilePath[] = [];
	let type: ModuleType | undefined;
	for (const output of outputs) {
		files.push(path.resolve(pkg.directory, output.relPath));
		const fileType = output.conditions.includes("import")
			? "ESM"
			: output.conditions.includes("require")
				? "CommonJS"
				: undefined;
		if (fileType !== undefined) {
			if (type === undefined) {
				type = fileType;
			} else if (type !== fileType) {
				throw new Error(`${pkg.name} "${commandLine}" produces both CommonJS and ESM output`);
			}
		}
	}
	return { files, type };
}

/**
 * Derives {@link ModuleType} from tsc "module" setting and command line
 *
 * @param pkg - Package context of command
 * @param commandLine - complete tsc or fluid-tsc command line
 * @param module - value of tsc project compilerOptions.module
 * @returns ModuleType
 */
function tscModuleType(
	pkg: Package,
	commandLine: string,
	// module is a string to allow or disparate versions of typescript across the repo and inconsistent
	// ModuleKind enums.
	module: string,
): ModuleType {
	const lcModule = module.toLowerCase();

	if (lcModule.startsWith("node")) {
		if (commandLine.startsWith("fluid-tsc")) {
			if (commandLine.startsWith("fluid-tsc commonjs")) {
				return "CommonJS";
			}
			if (commandLine.startsWith("fluid-tsc module")) {
				return "ESM";
			}
			throw new Error(`fluid-tsc package type not recognized in "${commandLine}"`);
		}

		return pkg.packageJson.type === "module" ? "ESM" : "CommonJS";
	}

	if (lcModule.startsWith("es")) {
		return "ESM";
	}
	if (lcModule === "commonjs") {
		return "CommonJS";
	}

	throw new Error(`tsc compilerOptions.module "${module}" not recognized`);
}

/**
 * Determines output generated by `tsc`/`fluid-tsc` commands.
 */
function tscOutput(
	pkg: Package,
	commandLine: string,
): { files: AbsoluteFilePath[]; type: ModuleType } | undefined {
	if (commandLine.includes("--watch")) {
		// --watch commands are special scripts not for use in general build dependencies
		return undefined;
	}

	const packageDir = pkg.directory;

	const tscUtils = TscUtils.getTscUtils(packageDir);

	const parsedCommand = tscUtils.parseCommandLine(commandLine);
	if (!parsedCommand) {
		throw new Error(`Error parsing ${pkg.name} tsc command line: ${commandLine}`);
	}
	const configFile = tscUtils.findConfigFile(packageDir, parsedCommand);
	const configJson = tscUtils.readConfigFile(configFile) as TsConfigJson;
	if (configJson === undefined) {
		throw new Error(`Failed to load config file '${configFile}'`);
	}

	// Fix up relative path from the command line based on the package directory
	const commandOptions = tscUtils.convertOptionPaths(
		parsedCommand.options,
		packageDir,
		(base: string, subpath: string) => path.resolve(base, subpath),
	);

	// Parse the config file relative to the config file directory
	const configDir = path.parse(configFile).dir;
	const ts = tscUtils.tsLib;
	const { fileNames, options } = ts.parseJsonConfigFileContent(
		configJson,
		ts.sys,
		configDir,
		commandOptions,
		configFile,
	);

	const { module } = options;
	if (module === undefined) {
		throw new Error(`${pkg.name} "${commandLine}" tsc compilerOptions.module not specified`);
	}
	const type = tscModuleType(pkg, commandLine, ts.ModuleKind[module]);

	if (options.noEmit ?? false) {
		return { files: [], type };
	}

	const rootDir = options.rootDir ?? ".";
	const outDir = options.outDir ?? ".";
	const inputRegex = /(?:\.d)?(\.[cm]?ts)$/;
	const files = fileNames.map((relSrcPath) => {
		const relOutPath = path.relative(rootDir, relSrcPath.replace(inputRegex, `.d$1`));
		return path.resolve(packageDir, outDir, relOutPath);
	});

	return { files, type };
}

const generationCommands: Partial<
	Record<
		string,
		(
			pkg: Package,
			commandLine: string,
		) =>
			| {
					files: AbsoluteFilePath[];
					type: ModuleType | undefined;
			  }
			| undefined
	>
> = {
	"flub": flubOutput,
	"fluid-tsc": tscOutput,
	"tsc": tscOutput,
};

/**
 * Maintains a database of build outputs by package script entries.
 *
 * @remarks
 * Queries made to the database provide context (package group) sufficient
 * to load packages and their dependencies, which are cached to expedite
 * further queries.
 * See {@link @fluidframework/build-tools#FluidRepo.createPackageMap | FluidRepo.createPackageMap}
 * for package group (map) creation.
 */
export class FluidBuildDatabase {
	private readonly outputSource = new Map<AbsoluteFilePath, BuildScript>();

	private readonly packageBuildScripts = new Map<
		PackageName,
		ReadonlyMap<Script, BuildScript>
	>();

	/**
	 * Find build scripts in dependencies that match given scripts module type
	 *
	 * @param packageGroup - map (cache) of packageName's related packages
	 * @param packageName - package name
	 * @param script - packages script name
	 * @param ignorePackage - optional filter function to ignore select packages
	 * @returns Array of groups of possible predecessor tasks
	 */
	public getPossiblePredecessorTasks(
		packageGroup: ReadonlyMap<PackageName, Package>,
		packageName: PackageName,
		script: Script,
		ignorePackage?: (packageInfo: {
			name: string;
			version: string;
		}) => boolean,
	): BuildScript[][] {
		const pkg = packageGroup.get(packageName);
		if (pkg === undefined) {
			throw new Error(`${packageName} is not a part of given package group`);
		}

		this.loadPackageAndDependencies(packageGroup, packageName);

		const localBuildScript = this.packageBuildScripts.get(packageName)?.get(script);
		if (localBuildScript === undefined) {
			throw new Error(`${packageName}#${script} is not a recognized build script`);
		}

		const predecessors: BuildScript[][] = [];

		for (const dep of pkg.combinedDependencies) {
			if (ignorePackage?.(dep) ?? false) {
				continue;
			}
			const depPackageName = dep.name;
			const depBuildScripts = this.packageBuildScripts.get(depPackageName);
			if (depBuildScripts !== undefined) {
				const possibleScriptPredecessors: BuildScript[] = [];
				for (const [depScript, { moduleType }] of depBuildScripts.entries()) {
					if (moduleType === undefined || moduleType === localBuildScript.moduleType) {
						possibleScriptPredecessors.push({
							packageName: depPackageName,
							script: depScript,
							moduleType,
						});
					}
				}
				if (possibleScriptPredecessors.length > 0) {
					predecessors.push(possibleScriptPredecessors);
				}
			}
		}

		return predecessors;
	}

	/**
	 * Exact set of predecessor tasks that build given inputs.
	 *
	 * @param packageGroup - map (cache) of packageName's related packages
	 * @param packageName - package name
	 * @param requiredInputs - absolute file paths required
	 * @returns Set of predecessor tasks
	 */
	public getPredecessorTasks(
		packageGroup: ReadonlyMap<PackageName, Package>,
		packageName: PackageName,
		requiredInputs: AbsoluteFilePath[],
	): Set<BuildScript> {
		this.loadPackageAndDependencies(packageGroup, packageName);

		const predecessors = new Set<BuildScript>();
		for (const input of requiredInputs) {
			const predecessor = this.outputSource.get(input);
			if (predecessor === undefined) {
				throw new Error(`no script found that produces ${input}`);
			}
			predecessors.add(predecessor);
		}
		return predecessors;
	}

	private loadPackageAndDependencies(
		packageGroup: ReadonlyMap<PackageName, Package>,
		packageName: PackageName,
	): void {
		if (this.packageBuildScripts.has(packageName)) {
			return;
		}

		const packageBuildScripts = new Map<Script, BuildScript>();
		this.packageBuildScripts.set(packageName, packageBuildScripts);

		const pkg = packageGroup.get(packageName);
		if (pkg === undefined) {
			return;
		}

		// Load local package outputs
		const scripts = pkg.packageJson.scripts ?? {};
		for (const [script, commands] of Object.entries(scripts)) {
			if (commands === undefined) {
				continue;
			}
			const source: BuildScript = { packageName, script, moduleType: undefined };
			const scriptCommandLines = commands.split("&&");
			for (const scriptCommandLine of scriptCommandLines) {
				const scriptCommand = scriptCommandLine.split(" ")[0];
				const outputs = generationCommands[scriptCommand]?.(pkg, scriptCommandLine);
				if (outputs === undefined) {
					// command not known or ignored
					continue;
				}

				packageBuildScripts.set(script, source);

				// Update source moduleType
				if (outputs.type !== undefined) {
					if (source.moduleType !== undefined && outputs.type !== source.moduleType) {
						throw new Error(
							`${packageName} ${script} cumulatively produces both CommonJS and ESM output`,
						);
					}
					source.moduleType = outputs.type;
				}

				// Accumulate output files
				for (const output of outputs.files) {
					const existingSource = this.outputSource.get(output);
					if (existingSource !== undefined) {
						throw new Error(
							`${output} generated by both ${existingSource.packageName}#${
								existingSource.script
							} and ${
								packageName === existingSource.packageName ? "" : packageName
							}#${script}`,
						);
					}
					this.outputSource.set(output, source);
				}
			}
		}

		// Load dependencies' outputs too
		for (const directDependency of pkg.combinedDependencies) {
			this.loadPackageAndDependencies(packageGroup, directDependency.name);
		}
	}
}
