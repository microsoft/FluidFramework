/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import type {
	IFluidCompatibilityMetadata,
	Logger,
	PackageJson,
} from "@fluidframework/build-tools";
import { formatISO, isDate, isValid, parseISO } from "date-fns";
import { diff, parse } from "semver";

/**
 * Approximate month as 33 days to add some buffer and avoid over-counting months in longer spans.
 */
export const DAYS_IN_MONTH_APPROXIMATION = 33;

/**
 * Default minimum compatibility window in months that is supported across all Fluid layers.
 */
export const DEFAULT_MINIMUM_COMPAT_WINDOW_MONTHS = 3;

/**
 * Default directory where the generation file is located.
 */
export const DEFAULT_GENERATION_DIR = "./src";

/**
 * Default name of the generation file.
 */
export const DEFAULT_GENERATION_FILE_NAME = "layerGenerationState.ts";

/**
 * Determines if the current package version represents a patch release.
 *
 * @param pkgVersion - The semantic version of the package (e.g., "2.0.1")
 * @returns True if the version is a patch release, false otherwise
 *
 * @throws Error When the provided version string is not a valid semantic version
 *
 * @example
 * ```typescript
 * isCurrentPackageVersionPatch("2.0.1"); // returns true
 * isCurrentPackageVersionPatch("2.1.0"); // returns false
 * isCurrentPackageVersionPatch("3.0.0"); // returns false
 * ```
 */
export function isCurrentPackageVersionPatch(pkgVersion: string): boolean {
	const parsed = parse(pkgVersion);
	if (parsed === null) {
		throw new Error(`Package version ${pkgVersion} is not a valid semver`);
	}
	return parsed.patch > 0;
}

/**
 * Generates the complete content for a layer generation TypeScript file.
 *
 * Creates a properly formatted TypeScript file with copyright header, autogenerated warning,
 * and export for generation number.
 *
 * @param generation - The layer compatibility generation number
 * @returns The complete file content as a string ready to be written to disk
 *
 * @example
 * ```typescript
 * const content = generateLayerFileContent(5);
 * // Returns a complete TypeScript file with exports:
 * // export const generation = 5;
 * ```
 */
export function generateLayerFileContent(generation: number): string {
	return `/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */

/**
 * The generation number for Fluid layer compatibility.
 * @internal
 */
export const generation = ${generation};
`;
}

/**
 * Determines if a new generation should be generated based on package version changes and time since
 * the last release.
 *
 * This function decides whether to increment the generation number based on:
 * 1. Whether the package version has changed since the last update
 * 2. How much time has elapsed since the previous release date
 * 3. The minimum compatibility window constraints
 *
 * The generation increment is calculated as the number of months since the previous release,
 * but capped at (minimumCompatWindowMonths - 1) to maintain compatibility requirements.
 *
 * @param currentPkgVersion - The current package version to compare against the stored version
 * @param fluidCompatMetadata - The existing Fluid compatibility metadata, or an empty object for newly opted-in packages
 * @param minimumCompatWindowMonths - The minimum number of months of compatibility to maintain across layers
 * @param log - Optional logger instance for verbose output about the calculation process
 * @returns The new generation number if an update is needed, or undefined if no update is required
 *
 * @throws Error When the current date is older than the previous release date
 */
export function maybeGetNewGeneration(
	currentPkgVersion: string,
	fluidCompatMetadata: IFluidCompatibilityMetadata | Record<string, never>,
	minimumCompatWindowMonths: number,
	log?: Logger,
): number | undefined {
	// If the fluidCompatMetadata is an empty object, this indicates opt-in with no prior data.
	// Return initial generation of 1.
	if (Object.keys(fluidCompatMetadata).length === 0) {
		return 1;
	}

	const metadata = fluidCompatMetadata as IFluidCompatibilityMetadata;

	log?.verbose(
		`Layer compatibility metadata from package.json: Generation: ${metadata.generation}, ` +
			`Release Date: ${metadata.releaseDate}, Package Version: ${metadata.releasePkgVersion}`,
	);

	// Only "minor" or "major" version changes trigger generation updates.
	const result = diff(currentPkgVersion, metadata.releasePkgVersion);
	if (result === null || (result !== "minor" && result !== "major")) {
		log?.verbose(`No minor or major release since last update; skipping generation update.`);
		return undefined;
	}

	log?.verbose(
		`Previous package version: ${metadata.releasePkgVersion}, Current package version: ${currentPkgVersion}`,
	);

	const previousReleaseDate = parseISO(metadata.releaseDate);
	if (!isValid(previousReleaseDate) || !isDate(previousReleaseDate)) {
		throw new Error(`Previous release date "${metadata.releaseDate}" is not a valid date.`);
	}

	const today = new Date();
	const timeDiff = today.getTime() - previousReleaseDate.getTime();
	if (timeDiff < 0) {
		throw new Error("Current date is older than previous release date");
	}
	const daysBetweenReleases = Math.round(timeDiff / (1000 * 60 * 60 * 24));
	const monthsBetweenReleases = Math.floor(daysBetweenReleases / DAYS_IN_MONTH_APPROXIMATION);
	log?.verbose(`Previous release date: ${previousReleaseDate}, Today: ${today}`);
	log?.verbose(
		`Time between releases: ${daysBetweenReleases} day(s) or ~${monthsBetweenReleases} month(s)`,
	);

	const newGeneration =
		metadata.generation + Math.min(monthsBetweenReleases, minimumCompatWindowMonths - 1);
	if (newGeneration === metadata.generation) {
		log?.verbose(
			`Generation remains the same (${newGeneration}); skipping generation update.`,
		);
		return undefined;
	}
	return newGeneration;
}

/**
 * Result of checking a package's compat layer generation status.
 */
export type LayerCompatCheckResult =
	| {
			/**
			 * Package does not need updates.
			 */
			needsUpdate: false;
			needsDeletion: false;
	  }
	| {
			/**
			 * Package needs updates to its layer generation metadata or files.
			 */
			needsUpdate: true;
			needsDeletion: false;
			/**
			 * Reason why the package needs an update.
			 */
			reason: string;
			/**
			 * The new generation number to write.
			 */
			newGeneration: number;
	  }
	| {
			/**
			 * Package is not opted in but has an orphaned generation file that should be deleted.
			 */
			needsUpdate: false;
			needsDeletion: true;
			/**
			 * Reason why the file should be deleted.
			 */
			reason: string;
			/**
			 * Path to the file that should be deleted.
			 */
			filePath: string;
	  };

/**
 * Checks if a package needs compat layer generation metadata updates.
 *
 * This is a lenient check - packages without metadata or generation files are considered
 * as not needing updates (they are skipped). This implements an opt-in model where packages
 * must have `fluidCompatMetadata` in their package.json to be checked.
 *
 * Note: This check always uses the provided parameters (or defaults). Individual packages
 * may use different parameters when running the generate command directly, which could
 * cause false positives/negatives. This is an accepted limitation for the common case.
 *
 * @param pkg - The package to check
 * @param generationDir - Directory where the generation file is located
 * @param generationFileName - Name of the generation file
 * @param minimumCompatWindowMonths - Minimum compatibility window in months
 * @param log - Optional logger for verbose output
 * @returns Result indicating if the package needs updates and why
 */
export async function checkPackageCompatLayerGeneration(
	pkg: {
		version: string;
		packageJson: { fluidCompatMetadata?: IFluidCompatibilityMetadata };
		directory: string;
	},
	generationDir: string,
	generationFileName: string,
	minimumCompatWindowMonths: number,
	log?: Logger,
): Promise<LayerCompatCheckResult> {
	const { readFile, access } = await import("node:fs/promises");
	const path = await import("node:path");

	const generationFileFullPath = path.default.join(
		pkg.directory,
		generationDir,
		generationFileName,
	);

	const currentPkgVersion = pkg.version;

	// Skip patch versions (they don't trigger generation updates)
	if (isCurrentPackageVersionPatch(currentPkgVersion)) {
		log?.verbose(`Patch version detected; skipping check.`);
		return { needsUpdate: false, needsDeletion: false };
	}

	// Check if package has the required metadata (opt-in check)
	const { fluidCompatMetadata } = pkg.packageJson;
	if (fluidCompatMetadata === undefined) {
		// Package is not opted in - check if there's an orphaned generation file to clean up
		try {
			await access(generationFileFullPath);
			// File exists but package is not opted in - needs deletion
			log?.verbose(
				`Package not opted in but generation file exists at ${generationFileFullPath}; flagging for deletion.`,
			);
			return {
				needsUpdate: false,
				needsDeletion: true,
				reason: `Generation file exists but package is not opted in (no fluidCompatMetadata)`,
				filePath: generationFileFullPath,
			};
		} catch {
			// File doesn't exist and package is not opted in - nothing to do
			log?.verbose(`No fluidCompatMetadata found in package.json; skipping.`);
			return { needsUpdate: false, needsDeletion: false };
		}
	}

	log?.verbose(
		`Checking generation metadata - Generation: ${fluidCompatMetadata.generation}, ` +
			`Release Date: ${fluidCompatMetadata.releaseDate}, Package Version: ${fluidCompatMetadata.releasePkgVersion}`,
	);

	// Check if a new generation should be created based on version/time
	const newGeneration = maybeGetNewGeneration(
		currentPkgVersion,
		fluidCompatMetadata,
		minimumCompatWindowMonths,
		log,
	);

	if (newGeneration !== undefined) {
		return {
			needsUpdate: true,
			needsDeletion: false,
			reason: `Generation should be updated from ${fluidCompatMetadata.generation} to ${newGeneration}`,
			newGeneration,
		};
	}

	// Verify the file content matches the expected generation
	let fileContent: string;
	try {
		fileContent = await readFile(generationFileFullPath, "utf8");
	} catch {
		// File doesn't exist - needs to be created
		return {
			needsUpdate: true,
			needsDeletion: false,
			reason: `Generation file not found at ${generationFileFullPath}`,
			newGeneration: fluidCompatMetadata.generation,
		};
	}

	const expectedContent = generateLayerFileContent(fluidCompatMetadata.generation);
	if (fileContent !== expectedContent) {
		return {
			needsUpdate: true,
			needsDeletion: false,
			reason: `Generation file content does not match expected content for generation ${fluidCompatMetadata.generation}`,
			newGeneration: fluidCompatMetadata.generation,
		};
	}

	log?.verbose(`Layer generation metadata is up to date.`);
	return { needsUpdate: false, needsDeletion: false };
}

/**
 * Result of checking multiple packages' layer compatibility generation status.
 */
export interface MultiPackageLayerCompatCheckResult {
	/**
	 * Packages that need updates with their reasons.
	 */
	packagesNeedingUpdate: {
		/**
		 * The package that needs an update.
		 */
		pkg: {
			name: string;
			version: string;
			packageJson: { fluidCompatMetadata?: IFluidCompatibilityMetadata };
			directory: string;
		};
		/**
		 * Reason why the package needs an update.
		 */
		reason: string;
	}[];
	/**
	 * Packages with orphaned generation files that should be deleted.
	 */
	packagesNeedingDeletion: {
		/**
		 * The package with an orphaned file.
		 */
		pkg: {
			name: string;
			directory: string;
		};
		/**
		 * Reason why the file should be deleted.
		 */
		reason: string;
		/**
		 * Path to the file that should be deleted.
		 */
		filePath: string;
	}[];
}

/**
 * Checks if multiple packages need compat layer generation metadata updates.
 *
 * This implements an opt-in model where packages must have `fluidCompatMetadata`
 * in their package.json to be checked. Packages without metadata but with orphaned
 * generation files will be flagged for deletion.
 *
 * @param packages - The packages to check
 * @param generationDir - Directory where the generation file is located
 * @param generationFileName - Name of the generation file
 * @param minimumCompatWindowMonths - Minimum compatibility window in months
 * @param log - Optional logger for verbose output
 * @returns Result containing packages that need updates or deletion
 */
export async function checkPackagesCompatLayerGeneration(
	packages: Iterable<{
		name: string;
		version: string;
		packageJson: { fluidCompatMetadata?: IFluidCompatibilityMetadata };
		directory: string;
	}>,
	generationDir: string,
	generationFileName: string,
	minimumCompatWindowMonths: number,
	log?: Logger,
): Promise<MultiPackageLayerCompatCheckResult> {
	const packagesNeedingUpdate: MultiPackageLayerCompatCheckResult["packagesNeedingUpdate"] =
		[];
	const packagesNeedingDeletion: MultiPackageLayerCompatCheckResult["packagesNeedingDeletion"] =
		[];

	for (const pkg of packages) {
		// eslint-disable-next-line no-await-in-loop -- Need to check files sequentially
		const result = await checkPackageCompatLayerGeneration(
			pkg,
			generationDir,
			generationFileName,
			minimumCompatWindowMonths,
			log,
		);

		if (result.needsUpdate) {
			packagesNeedingUpdate.push({
				pkg,
				reason: result.reason,
			});
		} else if (result.needsDeletion) {
			packagesNeedingDeletion.push({
				pkg,
				reason: result.reason,
				filePath: result.filePath,
			});
		}
	}

	return { packagesNeedingUpdate, packagesNeedingDeletion };
}

/**
 * Writes the compat layer generation update for a package.
 *
 * This function performs the actual update - writing the new metadata to package.json
 * and the generation file. Call this after `checkPackageCompatLayerGeneration` returns
 * `needsUpdate: true`.
 *
 * @param pkg - The package to update
 * @param newGeneration - The new generation number to write
 * @param generationDir - Directory where the generation file is located
 * @param generationFileName - Name of the generation file
 */
export async function writePackageCompatLayerGeneration(
	pkg: {
		version: string;
		directory: string;
	},
	newGeneration: number,
	generationDir: string,
	generationFileName: string,
): Promise<void> {
	const { writeFile } = await import("node:fs/promises");
	const path = await import("node:path");
	const { updatePackageJsonFile } = await import("@fluid-tools/build-infrastructure");

	const generationFileFullPath = path.default.join(
		pkg.directory,
		generationDir,
		generationFileName,
	);

	const currentReleaseDate = formatISO(new Date(), { representation: "date" });
	const newFluidCompatMetadata: IFluidCompatibilityMetadata = {
		generation: newGeneration,
		releaseDate: currentReleaseDate,
		releasePkgVersion: pkg.version,
	};

	updatePackageJsonFile(pkg.directory, (json: PackageJson) => {
		json.fluidCompatMetadata = newFluidCompatMetadata;
	});

	await writeFile(generationFileFullPath, generateLayerFileContent(newGeneration), {
		encoding: "utf8",
	});
}

/**
 * Deletes an orphaned compat layer generation file.
 *
 * Call this after `checkPackageCompatLayerGeneration` returns `needsDeletion: true`.
 *
 * @param filePath - Path to the file to delete
 */
export async function deleteCompatLayerGenerationFile(filePath: string): Promise<void> {
	const { unlink } = await import("node:fs/promises");
	await unlink(filePath);
}

/**
 * Formats an error message for packages that need compat layer generation updates.
 *
 * @param packagesNeedingUpdate - Array of packages that need updates with their reasons
 * @param releaseGroup - Optional release group name to include in fix command
 * @returns Object with formatted message and fix command
 */
export function formatCompatLayerGenerationError(
	packagesNeedingUpdate: { pkg: { name: string }; reason: string }[],
	releaseGroup?: string,
): { message: string; fixCommand: string } {
	const fixCommand =
		releaseGroup === undefined
			? "pnpm flub generate compatLayerGeneration"
			: `pnpm flub generate compatLayerGeneration -g ${releaseGroup}`;

	const message = `Some packages need compat layer generation updates:\n${packagesNeedingUpdate
		.map(({ pkg, reason }) => `  - ${pkg.name}: ${reason}`)
		.join("\n")}`;

	return { message, fixCommand };
}
