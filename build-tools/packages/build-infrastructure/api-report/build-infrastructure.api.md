## API Report File for "@fluid-tools/build-infrastructure"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { Opaque } from 'type-fest';
import type { PackageJson as PackageJson_2 } from 'type-fest';
import { SemVer } from 'semver';
import type { SetRequired } from 'type-fest';
import { SimpleGit } from 'simple-git';
import { Static } from '@sinclair/typebox';
import { TArray } from '@sinclair/typebox';
import { TNumber } from '@sinclair/typebox';
import { TObject } from '@sinclair/typebox';
import { TOptional } from '@sinclair/typebox';
import { TRecord } from '@sinclair/typebox';
import { TString } from '@sinclair/typebox';
import { TUnion } from '@sinclair/typebox';

// @public
export type AdditionalPackageProps = Record<string, string> | undefined;

// @public
export const BUILDPROJECT_CONFIG_VERSION = 1;

// @public
export type BuildProjectLayout = Static<typeof BuildProjectLayout>;

// @public (undocumented)
export const BuildProjectLayout: TObject<    {
version: TNumber;
repoPackages: TOptional<TRecord<TString, TUnion<[TString, TObject<    {
directory: TString;
ignoredDirs: TOptional<TArray<TString>>;
}>, TArray<TUnion<[TString, TObject<    {
directory: TString;
ignoredDirs: TOptional<TArray<TString>>;
}>]>>]>>>;
buildProject: TOptional<TObject<    {
workspaces: TRecord<TString, TObject<    {
directory: TString;
releaseGroups: TRecord<TString, TObject<    {
include: TArray<TString>;
exclude: TOptional<TArray<TString>>;
rootPackageName: TOptional<TString>;
adoPipelineUrl: TOptional<TString>;
}>>;
}>>;
}>>;
}>;

// @public
export function createPackageManager(name: PackageManagerName): IPackageManager;

// @public
export function findGitRootSync(cwd?: string): string;

// @public
export interface FluidPackageJsonFields {
    pnpm?: {
        overrides?: Record<string, string>;
    };
}

// @public
export function getAllDependencies(repo: IBuildProject, packages: IPackage[]): {
    packages: IPackage[];
    releaseGroups: IReleaseGroup[];
    workspaces: IWorkspace[];
};

// @public
export function getBuildProjectConfig(searchPath: string, noCache?: boolean): {
    config: BuildProjectLayout;
    configFilePath: string;
};

// @public
export function getChangedSinceRef<P extends IPackage>(buildProject: IBuildProject<P>, ref: string, remote?: string): Promise<{
    files: string[];
    dirs: string[];
    workspaces: IWorkspace[];
    releaseGroups: IReleaseGroup[];
    packages: P[];
}>;

// @public
export function getFiles(git: SimpleGit, directory: string): Promise<string[]>;

// @public
export function getMergeBaseRemote(git: SimpleGit, branch: string, remote?: string, localRef?: string): Promise<string>;

// @public
export function getRemote(git: SimpleGit, partialUrl: string | undefined): Promise<string | undefined>;

// @public
export interface IBuildProject<P extends IPackage = IPackage> extends Reloadable {
    configuration: BuildProjectLayout;
    getGitRepository(): Promise<Readonly<SimpleGit>>;
    getPackageReleaseGroup(pkg: Readonly<P>): Readonly<IReleaseGroup>;
    packages: Map<PackageName, P>;
    relativeToRepo(p: string): string;
    releaseGroups: Map<ReleaseGroupName, IReleaseGroup>;
    root: string;
    upstreamRemotePartialUrl?: string;
    workspaces: Map<WorkspaceName, IWorkspace>;
}

// @public @deprecated
export type IFluidBuildDir = Static<typeof IFluidBuildDir>;

// @public (undocumented)
export const IFluidBuildDir: TObject<    {
directory: TString;
ignoredDirs: TOptional<TArray<TString>>;
}>;

// @public @deprecated (undocumented)
export type IFluidBuildDirEntry = Static<typeof IFluidBuildDirEntry>;

// @public (undocumented)
export const IFluidBuildDirEntry: TUnion<[TString, TObject<    {
directory: TString;
ignoredDirs: TOptional<TArray<TString>>;
}>, TArray<TUnion<[TString, TObject<    {
directory: TString;
ignoredDirs: TOptional<TArray<TString>>;
}>]>>]>;

// @public @deprecated (undocumented)
export type IFluidBuildDirs = Static<typeof IFluidBuildDirs>;

// @public (undocumented)
export const IFluidBuildDirs: TRecord<TString, TUnion<[TString, TObject<    {
directory: TString;
ignoredDirs: TOptional<TArray<TString>>;
}>, TArray<TUnion<[TString, TObject<    {
directory: TString;
ignoredDirs: TOptional<TArray<TString>>;
}>]>>]>>;

// @public
export interface Installable {
    checkInstall(): Promise<true | string[]>;
    install(updateLockfile: boolean): Promise<boolean>;
}

// @public
export interface IPackage<J extends PackageJson = PackageJson> extends Installable, Reloadable {
    combinedDependencies: Generator<PackageDependency, void>;
    readonly directory: string;
    getScript(name: string): string | undefined;
    isReleaseGroupRoot: boolean;
    readonly isWorkspaceRoot: boolean;
    readonly name: PackageName;
    readonly nameColored: string;
    packageJson: J;
    readonly packageJsonFilePath: string;
    readonly packageManager: IPackageManager;
    readonly private: boolean;
    releaseGroup: ReleaseGroupName;
    savePackageJson(): Promise<void>;
    // (undocumented)
    toString(): string;
    readonly version: string;
    readonly workspace: IWorkspace;
}

// @public
export interface IPackageManager {
    getInstallCommandWithArgs(updateLockfile: boolean): string[];
    readonly lockfileName: string;
    readonly name: PackageManagerName;
}

// @public
export interface IReleaseGroup extends Reloadable {
    readonly adoPipelineUrl?: string;
    readonly name: ReleaseGroupName;
    readonly packages: IPackage[];
    readonly releaseGroupDependencies: IReleaseGroup[];
    readonly rootPackage?: IPackage;
    // (undocumented)
    toString(): string;
    readonly version: string;
    readonly workspace: IWorkspace;
}

// @public
export function isIPackage(pkg: any): pkg is IPackage;

// @public
export function isIReleaseGroup(toCheck: Exclude<any, string | number | ReleaseGroupName | PackageName>): toCheck is IReleaseGroup;

// @public
export interface IWorkspace extends Installable, Reloadable {
    buildProject: IBuildProject;
    directory: string;
    name: WorkspaceName;
    packages: IPackage[];
    releaseGroups: Map<ReleaseGroupName, IReleaseGroup>;
    rootPackage: IPackage;
    // (undocumented)
    toString(): string;
}

// @public
export function loadBuildProject<P extends IPackage>(searchPath: string, upstreamRemotePartialUrl?: string): IBuildProject<P>;

// @public
export class NotInGitRepository extends Error {
    constructor(
    path: string);
    readonly path: string;
}

// @public
export abstract class PackageBase<J extends PackageJson = PackageJson, TAddProps extends AdditionalPackageProps = undefined> implements IPackage<J> {
    constructor(
    packageJsonFilePath: string,
    packageManager: IPackageManager,
    workspace: IWorkspace,
    isWorkspaceRoot: boolean,
    releaseGroup: ReleaseGroupName,
    isReleaseGroupRoot: boolean, additionalProperties?: TAddProps);
    checkInstall(): Promise<true | string[]>;
    get combinedDependencies(): Generator<PackageDependency, void>;
    get directory(): string;
    getScript(name: string): string | undefined;
    install(updateLockfile: boolean): Promise<boolean>;
    isReleaseGroupRoot: boolean;
    readonly isWorkspaceRoot: boolean;
    get name(): PackageName;
    get nameColored(): string;
    get packageJson(): J;
    readonly packageJsonFilePath: string;
    readonly packageManager: IPackageManager;
    get private(): boolean;
    readonly releaseGroup: ReleaseGroupName;
    reload(): void;
    savePackageJson(): Promise<void>;
    // (undocumented)
    toString(): string;
    get version(): string;
    readonly workspace: IWorkspace;
}

// @public
export interface PackageDependency {
    depKind: "prod" | "dev" | "peer";
    name: PackageName;
    version: string;
}

// @public
export type PackageJson = SetRequired<PackageJson_2 & FluidPackageJsonFields, "name" | "scripts" | "version">;

// @public
export type PackageManagerName = "npm" | "pnpm" | "yarn";

// @public
export type PackageName = Opaque<string, "PackageName">;

// @public
export type ReleaseGroupDefinition = Static<typeof ReleaseGroupDefinition>;

// @public (undocumented)
export const ReleaseGroupDefinition: TObject<    {
include: TArray<TString>;
exclude: TOptional<TArray<TString>>;
rootPackageName: TOptional<TString>;
adoPipelineUrl: TOptional<TString>;
}>;

// @public
export type ReleaseGroupName = Opaque<string, IReleaseGroup>;

// @public
export interface Reloadable {
    reload(): void;
}

// @public
export function setVersion<J extends PackageJson>(packages: IPackage<J>[], version: SemVer): Promise<void>;

// @public
export function updatePackageJsonFile<J extends PackageJson = PackageJson>(packagePath: string, packageTransformer: (json: J) => void): void;

// @public
export function updatePackageJsonFileAsync<J extends PackageJson = PackageJson>(packagePath: string, packageTransformer: (json: J) => Promise<void>): Promise<void>;

// @public
export type WorkspaceDefinition = Static<typeof WorkspaceDefinition>;

// @public (undocumented)
export const WorkspaceDefinition: TObject<    {
directory: TString;
releaseGroups: TRecord<TString, TObject<    {
include: TArray<TString>;
exclude: TOptional<TArray<TString>>;
rootPackageName: TOptional<TString>;
adoPipelineUrl: TOptional<TString>;
}>>;
}>;

// @public
export type WorkspaceName = Opaque<string, "WorkspaceName">;

// (No @packageDocumentation comment for this package)

```
