## API Report File for "@fluid-tools/build-infrastructure"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { LoggingFunction as LoggingFunction_2 } from './logging.js';
import type { Opaque } from 'type-fest';
import type { PackageJson as PackageJson_2 } from 'type-fest';
import type { RequireExactlyOne } from 'type-fest';
import { SemVer } from 'semver';
import type { SetRequired } from 'type-fest';
import { SimpleGit } from 'simple-git';

// @public
export type AdditionalPackageProps = Record<string, string> | undefined;

// @public
export const AllPackagesSelectionCriteria: PackageSelectionCriteria;

// @public
export class BuildProject<P extends IPackage> implements IBuildProject<P> {
    constructor(searchPath: string, infer?: boolean,
    upstreamRemotePartialUrl?: string | undefined);
    readonly configuration: BuildProjectConfig;
    // (undocumented)
    readonly configurationSource: string;
    getGitRepository(): Promise<Readonly<SimpleGit>>;
    getPackageReleaseGroup(pkg: Readonly<P>): Readonly<IReleaseGroup>;
    get packages(): Map<PackageName, P>;
    relativeToRepo(p: string): string;
    get releaseGroups(): Map<ReleaseGroupName, IReleaseGroup>;
    reload(): void;
    readonly root: string;
    readonly upstreamRemotePartialUrl?: string | undefined;
    get workspaces(): Map<WorkspaceName, IWorkspace>;
}

// @public
export const BUILDPROJECT_CONFIG_MIN_VERSION = 1;

// @public (undocumented)
export type BuildProjectConfig = BuildProjectConfigV1;

// @public
export interface BuildProjectConfigBase {
    buildProject: {
        workspaces: {
            [name: string]: WorkspaceDefinition;
        };
    };
    excludeGlobs: string[];
    version: number;
}

// @public (undocumented)
export type BuildProjectConfigV1 = RequireExactlyOne<BuildProjectConfigV1Base, "buildProject" | "excludeGlobs" | "repoPackages">;

// @public (undocumented)
export interface BuildProjectConfigV1Base extends Partial<BuildProjectConfigBase> {
    // @deprecated
    repoPackages?: IFluidBuildDirs;
    version: 1;
}

// @public
export const EmptySelectionCriteria: PackageSelectionCriteria;

// @public
export type ErrorLoggingFunction = (msg: string | Error | undefined, ...args: any[]) => void;

// @public
export interface FilterablePackage {
    // (undocumented)
    name: string;
    // (undocumented)
    private?: boolean | undefined;
}

// @public
export function filterPackages<T extends FilterablePackage>(packages: T[], filters: PackageFilterOptions): Promise<T[]>;

// @public
export function findGitRootSync(cwd?: string): string;

// @public
export function generateBuildProjectConfig(searchPath: string): BuildProjectConfig;

// @public
export function getAllDependencies(repo: IBuildProject, packages: IPackage[]): {
    packages: IPackage[];
    releaseGroups: IReleaseGroup[];
    workspaces: IWorkspace[];
};

// @public
export function getBuildProjectConfig(searchPath: string, noCache?: boolean): {
    config: BuildProjectConfig;
    configFilePath: string;
};

// @public
export function getChangedSinceRef<P extends IPackage>(buildProject: IBuildProject<P>, ref: string, remote?: string): Promise<{
    files: string[];
    dirs: string[];
    workspaces: IWorkspace[];
    releaseGroups: IReleaseGroup[];
    packages: P[];
}>;

// @public
export function getFiles(git: SimpleGit, directory: string): Promise<string[]>;

// @public
export function getMergeBaseRemote(git: SimpleGit, branch: string, remote?: string, localRef?: string): Promise<string>;

// @public
export function getRemote(git: SimpleGit, partialUrl: string | undefined): Promise<string | undefined>;

// @public
export type GlobString = string;

// @public
export interface IBuildProject<P extends IPackage = IPackage> extends Reloadable {
    configuration: BuildProjectConfig;
    configurationSource: string | "INFERRED";
    getGitRepository(): Promise<Readonly<SimpleGit>>;
    getPackageReleaseGroup(pkg: Readonly<P>): Readonly<IReleaseGroup>;
    packages: Map<PackageName, P>;
    relativeToRepo(p: string): string;
    releaseGroups: Map<ReleaseGroupName, IReleaseGroup>;
    root: string;
    upstreamRemotePartialUrl?: string;
    workspaces: Map<WorkspaceName, IWorkspace>;
}

// @public @deprecated
export interface IFluidBuildDir {
    directory: string;
    // @deprecated
    ignoredDirs?: string[];
}

// @public @deprecated (undocumented)
export type IFluidBuildDirEntry = string | IFluidBuildDir | (string | IFluidBuildDir)[];

// @public @deprecated (undocumented)
export interface IFluidBuildDirs {
    // (undocumented)
    [name: string]: IFluidBuildDirEntry;
}

// @public
export interface Installable {
    checkInstall(): Promise<true | string[]>;
    install(updateLockfile: boolean): Promise<boolean>;
}

// @public
export interface IPackage<J extends PackageJson = PackageJson> extends Installable, Reloadable {
    combinedDependencies: Generator<PackageDependency, void>;
    readonly directory: string;
    getScript(name: string): string | undefined;
    isReleaseGroupRoot: boolean;
    readonly isWorkspaceRoot: boolean;
    readonly name: PackageName;
    readonly nameColored: string;
    packageJson: J;
    readonly packageJsonFilePath: string;
    readonly private: boolean;
    releaseGroup: ReleaseGroupName;
    savePackageJson(): Promise<void>;
    // (undocumented)
    toString(): string;
    readonly version: string;
    readonly workspace: IWorkspace;
}

// @public
export interface IPackageManager {
    getInstallCommandWithArgs(updateLockfile: boolean): string[];
    readonly lockfileNames: string[];
    readonly name: PackageManagerName;
}

// @public
export interface IReleaseGroup extends Reloadable {
    readonly adoPipelineUrl?: string;
    readonly name: ReleaseGroupName;
    readonly packages: IPackage[];
    readonly releaseGroupDependencies: IReleaseGroup[];
    readonly rootPackage?: IPackage;
    // (undocumented)
    toString(): string;
    readonly version: string;
    readonly workspace: IWorkspace;
}

// @public
export function isIPackage(pkg: any): pkg is IPackage;

// @public
export function isIReleaseGroup(toCheck: Exclude<any, string | number | ReleaseGroupName | PackageName>): toCheck is IReleaseGroup;

// @public
export function isV1Config(input: BuildProjectConfig): input is BuildProjectConfigV1;

// @public
export interface IWorkspace extends Installable, Reloadable {
    buildProject: IBuildProject;
    directory: string;
    name: WorkspaceName;
    packageManager: IPackageManager;
    packages: IPackage[];
    releaseGroups: Map<ReleaseGroupName, IReleaseGroup>;
    rootPackage: IPackage;
    // (undocumented)
    toString(): string;
}

// @public
export function loadBuildProject<P extends IPackage>(searchPath: string, infer?: boolean, upstreamRemotePartialUrl?: string): IBuildProject<P>;

// @public
export interface Logger {
    errorLog: ErrorLoggingFunction;
    info: ErrorLoggingFunction;
    log: LoggingFunction;
    verbose: ErrorLoggingFunction;
    warning: ErrorLoggingFunction;
}

// @public
export type LoggingFunction = (message?: string, ...args: any[]) => void;

// @public
export class NotInGitRepository extends Error {
    constructor(
    path: string);
    readonly path: string;
}

// @public
export abstract class PackageBase<J extends PackageJson = PackageJson, TAddProps extends AdditionalPackageProps = undefined> implements IPackage<J> {
    constructor(
    packageJsonFilePath: string,
    workspace: IWorkspace,
    isWorkspaceRoot: boolean,
    releaseGroup: ReleaseGroupName,
    isReleaseGroupRoot: boolean, additionalProperties?: TAddProps);
    checkInstall(): Promise<true | string[]>;
    get combinedDependencies(): Generator<PackageDependency, void>;
    get directory(): string;
    getScript(name: string): string | undefined;
    install(updateLockfile: boolean): Promise<boolean>;
    isReleaseGroupRoot: boolean;
    readonly isWorkspaceRoot: boolean;
    get name(): PackageName;
    get nameColored(): string;
    get packageJson(): J;
    readonly packageJsonFilePath: string;
    get private(): boolean;
    readonly releaseGroup: ReleaseGroupName;
    reload(): void;
    savePackageJson(): Promise<void>;
    // (undocumented)
    toString(): string;
    get version(): string;
    readonly workspace: IWorkspace;
}

// @public
export interface PackageDependency {
    depKind: "prod" | "dev" | "peer";
    name: PackageName;
    version: string;
}

// @public
export interface PackageFilterOptions {
    private: boolean | undefined;
    scope?: string[] | undefined;
    skipScope?: string[] | undefined;
}

// @public
export type PackageJson = PackageJson_2 & SetRequired<Pick<PackageJson_2, "name" | "scripts" | "version" | "dependencies" | "devDependencies" | "peerDependencies" | "private" | "type">, "name" | "scripts" | "version"> & PnpmPackageJsonFields;

// @public
export type PackageManagerName = "npm" | "pnpm" | "yarn";

// @public
export type PackageName = Opaque<string, "PackageName">;

// @public
export interface PackageSelectionCriteria {
    changedSinceBranch?: string | undefined;
    directory?: string | undefined;
    releaseGroupRoots: (GlobString | string)[];
    releaseGroups: (GlobString | string)[];
    workspaceRoots: (GlobString | string)[];
    workspaces: (GlobString | string)[];
}

// @public
export interface PnpmPackageJsonFields {
    pnpm?: {
        overrides?: Record<string, string>;
    };
}

// @public
export interface ReleaseGroupDefinition {
    adoPipelineUrl?: string;
    exclude?: string[];
    include: string[];
    rootPackageName?: string;
}

// @public
export type ReleaseGroupName = Opaque<string, "IReleaseGroup">;

// @public
export interface Reloadable {
    reload(): void;
}

// @public
export function selectAndFilterPackages<P extends IPackage>(buildProject: IBuildProject<P>, selection: PackageSelectionCriteria, filter?: PackageFilterOptions): Promise<{
    selected: P[];
    filtered: P[];
}>;

// @public
export function setVersion<J extends PackageJson>(packages: IPackage<J>[], version: SemVer): Promise<void>;

// @public
export class Stopwatch {
    constructor(enabled: boolean, logFunc?: LoggingFunction_2);
    // (undocumented)
    getTotalTime(): number;
    // (undocumented)
    log(msg?: string, print?: boolean): number;
    // (undocumented)
    protected logFunc: LoggingFunction_2;
}

// @public
export function updatePackageJsonFile<J extends PackageJson = PackageJson>(packagePath: string, packageTransformer: (json: J) => void): void;

// @public
export function updatePackageJsonFileAsync<J extends PackageJson = PackageJson>(packagePath: string, packageTransformer: (json: J) => Promise<void>): Promise<void>;

// @public
export interface WorkspaceDefinition {
    directory: string;
    releaseGroups: {
        [name: string]: ReleaseGroupDefinition;
    };
}

// @public
export type WorkspaceName = Opaque<string, "WorkspaceName">;

// (No @packageDocumentation comment for this package)

```
