## API Report File for "@fluid-tools/build-infrastructure"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { Opaque } from 'type-fest';
import type { PackageJson as PackageJson_2 } from 'type-fest';
import * as semver from 'semver';
import type { SetRequired } from 'type-fest';
import { SimpleGit } from 'simple-git';

// @public (undocumented)
export type AdditionalPackageProps = Record<string, string> | undefined;

// @public
export const AllPackagesSelectionCriteria: PackageSelectionCriteria;

// @public
export function createPackageManager(name: PackageManagerName): IPackageManager;

// @public
export const EmptySelectionCriteria: PackageSelectionCriteria;

// @public
export interface FilterablePackage {
    // (undocumented)
    name: string;
    // (undocumented)
    private?: boolean | undefined;
}

// @public
export function filterPackages<T extends FilterablePackage>(packages: T[], filters: PackageFilterOptions): Promise<T[]>;

// @public
export function findGitRootSync(cwd?: string): string;

// @public
export interface FluidPackageJsonFields {
    pnpm?: {
        overrides?: Record<string, string>;
    };
}

// @public
export const FLUIDREPO_CONFIG_VERSION = 1;

// @public (undocumented)
export class FluidRepoBase<P extends IPackage> implements IFluidRepo<P> {
    constructor(searchPath: string, upstreamRemotePartialUrl?: string | undefined);
    // (undocumented)
    readonly configFilePath: string;
    // (undocumented)
    readonly configuration: IFluidRepoLayout;
    // (undocumented)
    getGitRepository(): Promise<Readonly<SimpleGit>>;
    // (undocumented)
    getPackageReleaseGroup(pkg: Readonly<P>): Readonly<IReleaseGroup>;
    // (undocumented)
    getPackageWorkspace(pkg: Readonly<P>): Readonly<IWorkspace>;
    // (undocumented)
    get packages(): Map<PackageName, P>;
    relativeToRepo(p: string): string;
    // (undocumented)
    get releaseGroups(): Map<ReleaseGroupName, IReleaseGroup>;
    // (undocumented)
    reload(): void;
    readonly root: string;
    // (undocumented)
    readonly upstreamRemotePartialUrl?: string | undefined;
    // (undocumented)
    get workspaces(): Map<WorkspaceName, IWorkspace>;
}

// @public (undocumented)
export function getAllDependenciesInRepo(repo: IFluidRepo, packages: IPackage[]): {
    packages: IPackage[];
    releaseGroups: IReleaseGroup[];
    workspaces: IWorkspace[];
};

// @public
export function getChangedSinceRef<P extends IPackage>(fluidRepo: IFluidRepo<P>, ref: string, remote?: string): Promise<{
    files: string[];
    dirs: string[];
    workspaces: IWorkspace[];
    releaseGroups: IReleaseGroup[];
    packages: IPackage[];
}>;

// @public
export function getFiles(git: SimpleGit, directory: string): Promise<string[]>;

// @public
export function getFluidRepoLayout(searchPath: string, noCache?: boolean): {
    config: IFluidRepoLayout;
    configFilePath: string;
};

// @public
export function getMergeBaseRemote(git: SimpleGit, branch: string, remote?: string, localRef?: string): Promise<string>;

// @public
export function getRemote(git: SimpleGit, partialUrl: string | undefined): Promise<string | undefined>;

// @public
export type GlobString = string;

// @public @deprecated
export interface IFluidBuildDir {
    directory: string;
}

// @public @deprecated (undocumented)
export type IFluidBuildDirEntry = string | IFluidBuildDir | (string | IFluidBuildDir)[];

// @public @deprecated (undocumented)
export interface IFluidBuildDirs {
    // (undocumented)
    [name: string]: IFluidBuildDirEntry;
}

// @public
export interface IFluidRepo<P extends IPackage = IPackage> extends Reloadable {
    configuration: IFluidRepoLayout;
    getGitRepository(): Promise<Readonly<SimpleGit>>;
    getPackageReleaseGroup(pkg: Readonly<P>): Readonly<IReleaseGroup>;
    getPackageWorkspace(pkg: Readonly<P>): Readonly<IWorkspace>;
    packages: Map<PackageName, P>;
    relativeToRepo(p: string): string;
    releaseGroups: Map<ReleaseGroupName, IReleaseGroup>;
    root: string;
    upstreamRemotePartialUrl?: string;
    workspaces: Map<WorkspaceName, IWorkspace>;
}

// @public
export interface IFluidRepoLayout {
    repoLayout?: {
        workspaces: {
            [name: string]: WorkspaceDefinition;
        };
    };
    // @deprecated
    repoPackages?: IFluidBuildDirs;
    version: typeof FLUIDREPO_CONFIG_VERSION;
}

// @public
export interface Installable {
    checkInstall(): Promise<boolean>;
    install(updateLockfile: boolean): Promise<boolean>;
}

// @public
export interface IPackage<J extends PackageJson = PackageJson> extends Installable, Reloadable {
    combinedDependencies: Generator<PackageDependency, void>;
    readonly directory: string;
    getScript(name: string): string | undefined;
    isReleaseGroupRoot: boolean;
    readonly isWorkspaceRoot: boolean;
    readonly name: PackageName;
    readonly nameColored: string;
    packageJson: J;
    readonly packageJsonFilePath: string;
    readonly packageManager: IPackageManager;
    readonly private: boolean;
    releaseGroup: ReleaseGroupName;
    savePackageJson(): Promise<void>;
    // (undocumented)
    toString(): string;
    readonly version: string;
    readonly workspace: IWorkspace;
}

// @public
export interface IPackageManager {
    // (undocumented)
    installCommand(updateLockfile: boolean): string;
    // (undocumented)
    readonly lockfileName: string;
    // (undocumented)
    readonly name: PackageManagerName;
}

// @public
export interface IReleaseGroup extends Reloadable {
    readonly adoPipelineUrl?: string;
    readonly name: ReleaseGroupName;
    readonly packages: IPackage[];
    readonly releaseGroupDependencies: IReleaseGroup[];
    readonly rootPackage?: IPackage;
    // (undocumented)
    toString(): string;
    readonly version: string;
    readonly workspace: IWorkspace;
}

// @public
export function isIPackage(pkg: any): pkg is IPackage;

// @public
export function isIReleaseGroup(toCheck: Exclude<any, string | number | ReleaseGroupName | PackageName>): toCheck is IReleaseGroup;

// @public
export interface IWorkspace extends Installable, Reloadable {
    directory: string;
    name: WorkspaceName;
    packages: IPackage[];
    releaseGroups: Map<ReleaseGroupName, IReleaseGroup>;
    rootPackage: IPackage;
    // (undocumented)
    toString(): string;
}

// @public
export function loadFluidRepo<P extends IPackage>(searchPath: string, upstreamRemotePartialUrl?: string): IFluidRepo<P>;

// @public
export class NotInGitRepository extends Error {
    constructor(path: string);
    // (undocumented)
    readonly path: string;
}

// @public (undocumented)
export abstract class PackageBase<J extends PackageJson = PackageJson, TAddProps extends AdditionalPackageProps = undefined> implements IPackage<J> {
    constructor(packageJsonFilePath: string, packageManager: IPackageManager, workspace: IWorkspace, isWorkspaceRoot: boolean, releaseGroup: ReleaseGroupName, isReleaseGroupRoot: boolean, additionalProperties?: TAddProps);
    // (undocumented)
    checkInstall(print?: boolean): Promise<boolean>;
    // (undocumented)
    get combinedDependencies(): Generator<PackageDependency, void>;
    // (undocumented)
    get directory(): string;
    // (undocumented)
    getScript(name: string): string | undefined;
    install(updateLockfile: boolean): Promise<boolean>;
    // (undocumented)
    isReleaseGroupRoot: boolean;
    // (undocumented)
    readonly isWorkspaceRoot: boolean;
    get name(): PackageName;
    get nameColored(): string;
    // (undocumented)
    get packageJson(): J;
    // (undocumented)
    readonly packageJsonFilePath: string;
    // (undocumented)
    readonly packageManager: IPackageManager;
    // (undocumented)
    get private(): boolean;
    // (undocumented)
    readonly releaseGroup: ReleaseGroupName;
    // (undocumented)
    reload(): void;
    // (undocumented)
    savePackageJson(): Promise<void>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get version(): string;
    // (undocumented)
    readonly workspace: IWorkspace;
}

// @public
export interface PackageDependency {
    // (undocumented)
    depClass: "prod" | "dev" | "peer";
    // (undocumented)
    name: PackageName;
    // (undocumented)
    version: string;
}

// @public
export interface PackageFilterOptions {
    private: boolean | undefined;
    scope?: string[] | undefined;
    skipScope?: string[] | undefined;
}

// @public (undocumented)
export type PackageJson = SetRequired<PackageJson_2 & FluidPackageJsonFields, "name" | "scripts" | "version">;

// @public
export type PackageManagerName = "npm" | "pnpm" | "yarn";

// @public
export type PackageName = Opaque<string, "PackageName">;

// @public
export interface PackageSelectionCriteria {
    changedSinceBranch?: string | undefined;
    directory?: string | undefined;
    releaseGroupRoots: (GlobString | string)[];
    releaseGroups: (GlobString | string)[];
    workspaceRoots: (GlobString | string)[];
    workspaces: (GlobString | string)[];
}

// @public (undocumented)
export interface ReleaseGroupDefinition {
    adoPipelineUrl?: string;
    exclude?: string[];
    include: string[];
    rootPackageName?: string;
}

// @public
export type ReleaseGroupName = Opaque<string, IReleaseGroup>;

// @public
export interface Reloadable {
    // (undocumented)
    reload(): void;
}

// @public
export function selectAndFilterPackages<P extends IPackage>(fluidRepo: IFluidRepo<P>, selection: PackageSelectionCriteria, filter?: PackageFilterOptions): Promise<{
    selected: P[];
    filtered: P[];
}>;

// @public
export function setVersion<J extends PackageJson>(packages: IPackage[], version: semver.SemVer): Promise<void>;

// @public
export function updatePackageJsonFile<J extends PackageJson = PackageJson>(packagePath: string, packageTransformer: (json: J) => void): void;

// @public
export function updatePackageJsonFileAsync<J extends PackageJson = PackageJson>(packagePath: string, packageTransformer: (json: J) => Promise<void>): Promise<void>;

// @public (undocumented)
export interface WorkspaceDefinition {
    // (undocumented)
    directory: string;
    // (undocumented)
    releaseGroups: {
        [name: string]: ReleaseGroupDefinition;
    };
}

// @public
export type WorkspaceName = Opaque<string, "WorkspaceName">;

// (No @packageDocumentation comment for this package)

```
