/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import path from "node:path";
import { Project } from "ts-morph";
import { BrokenCompatTypes } from "../common/fluidRepo";
import { PackageJson } from "../common/npmPackage";
import { buildTestCase, TestCaseTypeData } from "../typeValidator/testGeneration";
import { getFullTypeName, getNodeTypeData, TypeData } from "../typeValidator/typeData";

// Do not check that file exists before opening:
// Doing so is a time of use vs time of check issue so opening the file could fail anyway.
// Do not catch error from opening file since the default behavior is fine (exits process with error showing useful message)
const packageFile = readFileSync("package.json");

const packageObject: PackageJson = JSON.parse(packageFile.toString());
const previousPackageName = `${packageObject.name}-previous`;

{
	// Information about the previous package from the package.json is not needed,
	// but error if its missing since its nice to septate errors for the dep missing here vs not installed.
	const previousDep = packageObject?.devDependencies?.[previousPackageName];
	if (typeof previousDep !== "string") {
		throw new Error(`Did not find devDependency ${previousPackageName} in package.json`);
	}
}

const broken: BrokenCompatTypes = packageObject.typeValidation?.broken ?? {};

const previousBasePath = `./node_modules/${previousPackageName}`;

const previousTsConfigPath = `${previousBasePath}/tsconfig.json`;
if (!existsSync(`${previousBasePath}/package.json`)) {
	throw new Error(
		`${previousTsConfigPath} not found. You may need to install the package via pnpm install.`,
	);
}

const currentProject = new Project({
	skipFileDependencyResolution: true,
	tsConfigFilePath: "tsconfig.json",
});

const previousProject = new Project({
	skipFileDependencyResolution: true,
	tsConfigFilePath: previousTsConfigPath,
});

function typeDataFromPackage(project: Project): TypeData[] {
	const typeData: TypeData[] = [];
	const exports = project.getSourceFileOrThrow("index.ts").getExportedDeclarations();
	for (const declarations of exports.values()) {
		for (const dec of declarations) {
			typeData.push(...getNodeTypeData(dec));
		}
	}
	return typeData;
}

const currentProjectData = typeDataFromPackage(currentProject);
const previousData = typeDataFromPackage(previousProject);

function compareString(a: string, b: string): number {
	return a > b ? 1 : a < b ? -1 : 0;
}

previousData.sort((a, b) => compareString(a.name, b.name));

const testString: string[] = [
	`/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "${previousPackageName}";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};
`,
];

const currentTypeMap = new Map<string, TypeData>(
	currentProjectData.map((v) => [getFullTypeName(v), v]),
);
for (const oldTypeData of previousData) {
	const oldType: TestCaseTypeData = {
		prefix: "old",
		...oldTypeData,
		removed: false,
	};
	const currentTypeData = currentTypeMap.get(getFullTypeName(oldTypeData));
	// if the current package is missing a type, we will use the old type data.
	// this can represent a breaking change which can be disable in the package.json.
	// this can also happen for type changes, like type to interface, which can remain
	// compatible.
	const currentType: TestCaseTypeData =
		currentTypeData === undefined
			? {
					prefix: "current",
					...oldTypeData,
					kind: `Removed${oldTypeData.kind}`,
					removed: true,
			  }
			: {
					prefix: "current",
					...currentTypeData,
					removed: false,
			  };

	// look for settings not under version, then fall back to version for back compat
	const brokenData = broken?.[getFullTypeName(currentType)];

	testString.push(`/*`);
	testString.push(`* Validate forward compat by using old type in place of current type`);
	testString.push(
		`* If breaking change required, add in package.json under typeValidation.broken:`,
	);
	testString.push(`* "${getFullTypeName(currentType)}": {"forwardCompat": false}`);
	testString.push("*/");
	testString.push(...buildTestCase(oldType, currentType, brokenData?.forwardCompat ?? true));

	testString.push("");

	testString.push(`/*`);
	testString.push(`* Validate back compat by using current type in place of old type`);
	testString.push(
		`* If breaking change required, add in package.json under typeValidation.broken:`,
	);
	testString.push(`* "${getFullTypeName(currentType)}": {"backCompat": false}`);
	testString.push("*/");
	testString.push(...buildTestCase(currentType, oldType, brokenData?.backCompat ?? true));
	testString.push("");
}

const testPath = `./src/test/types`;
mkdirSync("./src/test/types", { recursive: true });

// remove scope if it exists
const oldVersionNameForFile = path.basename(previousPackageName);

const oldVersionFileName = oldVersionNameForFile
	.split("-")
	.map((p) => p[0].toUpperCase() + p.substring(1))
	.join("");
const filePath = `${testPath}/validate${oldVersionFileName}.generated.ts`;

console.log(`generated ${path.resolve(filePath)}`);

writeFileSync(filePath, testString.join("\n"));
