<!-- THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. -->

# Fluid Framework v2.2.0

## Contents

- [‚ú® New Features](#-new-features)
  - [New `isFluidHandle` type guard to check if an object is an `IFluidHandle` (#22029)](#new-isfluidhandle-type-guard-to-check-if-an-object-is-an-ifluidhandle-22029)
- [üå≥ SharedTree DDS changes](#-sharedtree-dds-changes)
  - [‚ú® New! ArrayNodes can now be constructed from Maps, and MapNodes from arrays when unambiguous (#22036)](#-new-arraynodes-can-now-be-constructed-from-maps-and-mapnodes-from-arrays-when-unambiguous-22036)
  - [‚ú® New! `Record`-typed objects can now be used to construct MapNodes (#22042)](#-new-record-typed-objects-can-now-be-used-to-construct-mapnodes-22042)
  - [Implicit TreeNode construction improvements (#21995)](#implicit-treenode-construction-improvements-21995)
  - [Fix document-corrupting bug when rebasing over move compositions (#21993)](#fix-document-corrupting-bug-when-rebasing-over-move-compositions-21993)
  - [Enforce use of TreeViewConfiguration's constructor (#22055)](#enforce-use-of-treeviewconfigurations-constructor-22055)
  - [Add `ITreeConfigurationOptions.preventAmbiguity` (#22048)](#add-itreeconfigurationoptionspreventambiguity-22048)
- [‚ö†Ô∏è Deprecations](#Ô∏è-deprecations)
  - [container-loader: summarizeProtocolTree and its corresponding duplicate ILoaderOptions definition is deprecated (#21999)](#container-loader-summarizeprotocoltree-and-its-corresponding-duplicate-iloaderoptions-definition-is-deprecated-21999)
  - [gcThrowOnTombstoneUsage and gcTombstoneEnforcementAllowed are deprecated (#21992)](#gcthrowontombstoneusage-and-gctombstoneenforcementallowed-are-deprecated-21992)
  - [InactiveResponseHeaderKey header is deprecated (#22107)](#inactiveresponseheaderkey-header-is-deprecated-22107)
- [Other Changes](#other-changes)
  - [Remove PropertyDDS/SharedTree Schema Converter (#22111)](#remove-propertyddssharedtree-schema-converter-22111)

## ‚ú® New Features

### New `isFluidHandle` type guard to check if an object is an `IFluidHandle` ([#22029](https://github.com/microsoft/FluidFramework/issues/22029))

The `isFluidHandle` type guard function is now exported and can be used to detect which objects are `IFluidHandle`s. Since `IFluidHandle` often needs special handling (for example when serializing since it's not JSON compatible), having a dedicated detection function for it is useful. Doing this detection was possible previously using the `tree` package's schema system via `Tree.is(value, new SchemaFactory("").handle)`, but can now be done with just `isFluidHandle(value)`.

#### Change details

Commit: [`7827d10`](https://github.com/microsoft/FluidFramework/commit/7827d1040a9ebc0bd11388dc31f15370ea9f68d3)

Affected packages:

- fluid-framework
- @fluidframework/runtime-utils

## üå≥ SharedTree DDS changes

### ‚ú® New! ArrayNodes can now be constructed from Maps, and MapNodes from arrays when unambiguous ([#22036](https://github.com/microsoft/FluidFramework/issues/22036))

Since the types for ArrayNodes and MapNodes indicate they can be constructed from iterables, it should work, even if those iterables are themselves arrays or maps. To avoid this being a breaking change, a priority system was introduced. ArrayNodes will only be implicitly constructable from JavaScript Map objects in contexts where no MapNodes are allowed. Similarly MapNodes will only be implicitly constructable from JavaScript Array objects in contexts where no ArrayNodes are allowed.

In practice, the main case in which this is likely to matter is when implicitly constructing a map node. If you provide an array of key value pairs, this now works instead of erroring, as long as no ArrayNode is valid at that location in the tree.

```typescript
class MyMapNode extends schemaFactory.map("x", schemaFactory.number) {}
class Root extends schemaFactory.object("root", { data: MyMapNode }) {}
// This now works (before it compiled, but error at runtime):
const fromArray = new Root({ data: [["x", 5]] });
```

Prior versions used to have to do:

```typescript
new Root({ data: new MyMapNode([["x", 5]]) });
```

or:

```typescript
new Root({ data: new Map([["x", 5]]) });
```

Both of these options still work: strictly more cases are allowed with this change.

#### Change details

Commit: [`25e74f9`](https://github.com/microsoft/FluidFramework/commit/25e74f9f3bed6e6ff041c088813c4cc1ea276b9c)

Affected packages:

- @fluidframework/tree
- fluid-framework

### ‚ú® New! `Record`-typed objects can now be used to construct MapNodes ([#22042](https://github.com/microsoft/FluidFramework/issues/22042))

You can now construct MapNodes from `Record` typed objects, similar to how maps are expressed in JSON.

Before this change, an `Iterable<string, Child>` was required, but now an object like `{key1: Child1, key2: Child2}` is allowed.

Full example using this new API:

```typescript
class Schema extends schemaFactory.map("ExampleMap", schemaFactory.number) {}
const fromRecord = new Schema({ x: 5 });
```

This new feature makes it possible for schemas to construct a tree entirely from JSON-compatible objects using their constructors, as long as they do not require unhydrated nodes to differentiate ambiguous unions, or IFluidHandles (which themselves are not JSON compatible).

Due to limitations of TypeScript and recursive types, recursive maps do not advertise support for this feature in their typing, but it works at runtime.

#### Change details

Commit: [`25deff3`](https://github.com/microsoft/FluidFramework/commit/25deff344b447380486c1efb64ed69177c32ddc5)

Affected packages:

- fluid-framework
- @fluidframework/tree

### Implicit TreeNode construction improvements ([#21995](https://github.com/microsoft/FluidFramework/issues/21995))

ArrayNodes and MapNodes could always be explicitly constructed (using `new`) from iterables. The types also allowed using of iterables to implicitly construct array nodes and map nodes, but this did not work at runtime. This has been fixed for all cases except implicitly constructing an ArrayNode form an `Iterable` that is actually a `Map`, and implicitly constructing a MapNode from an `Iterable` that is actually an `Array`. These cases may be fixed in the future, but require additional work to ensure unions of array nodes and map nodes work correctly.

Additionally MapNodes can now be constructed from `Iterator<readonly [string, content]>` where previously the inner arrays had to be mutable.

#### Change details

Commit: [`977f96c`](https://github.com/microsoft/FluidFramework/commit/977f96c1a0dd1d5eb0dbcd087d07cb7510d533ea)

Affected packages:

- fluid-framework
- @fluidframework/tree

### Fix document-corrupting bug when rebasing over move compositions ([#21993](https://github.com/microsoft/FluidFramework/issues/21993))

Before this fix, if multiple users concurrently performed moves (possibly by reverting prior moves), there was a chance that the document would become corrupted.

#### Change details

Commit: [`f3af9d1`](https://github.com/microsoft/FluidFramework/commit/f3af9d1cd3f7ee1ea3660ae934ddca8473fbdb9b)

Affected packages:

- @fluidframework/tree

### Enforce use of TreeViewConfiguration's constructor ([#22055](https://github.com/microsoft/FluidFramework/issues/22055))

`TreeViewConfiguration` is `@sealed`, meaning creating custom implementations of it such as assigning object literals to a `TreeViewConfiguration` or sub-classing it are not supported. This reserved the ability for the Fluid Framework to add members to this class over time, informing users that they must use it in such a way where such changes are non-breaking. However, there was no compiler-based enforcement of this expectation. It was only indicated via documentation and an implicit assumption that when an API takes in a typed defined as a class, that an instance of that class must be used rather than an arbitrary object of a similar shape.

With this change, the TypeScript compiler will now inform users when they invalidly provide an object literal as a `TreeViewConfiguration`.

More specifically this causes code like this to produce a compile error:

```typescript
// Don't do this!
const view = tree.viewWith({ schema: TestNode, enableSchemaValidation: false });
```

The above was never intended to work, and is not a supported use of the `viewWith` since it requires a `TreeViewConfiguration` which is sealed. Any code using the above pattern will break in Fluid Framework 2.2 and above. Such code will need to be updated to the pattern shown below. Any code broken by this change is technically unsupported and only worked due to a gap in the type checking. This is not considered a breaking change. The correct way to get a `TreeViewConfiguration` is by using its constructor:

```typescript
// This pattern correctly initializes default values and validates input.
const view = tree.viewWith(new TreeViewConfiguration({ schema: TestNode }));
```

Skipping the constructor causes the following problems:

1. `TreeViewConfiguration` does validation in its constructor, so skipping it also skips the validation which leads to much less friendly error messages for invalid schema.
2. Skipping the constructor also discards any default values for options like `enableSchemaValidation`. This means that code written in that style would break if more options were added. Since such changes are planned, it is not practical to support this pattern.

#### Change details

Commit: [`e895557`](https://github.com/microsoft/FluidFramework/commit/e8955579f6d52a6c7e300642088c60d6ed12d7db)

Affected packages:

- fluid-framework
- @fluidframework/tree

### Add `ITreeConfigurationOptions.preventAmbiguity` ([#22048](https://github.com/microsoft/FluidFramework/issues/22048))

The new `ITreeConfigurationOptions.preventAmbiguity` flag can be set to true to enable checking of some additional rules when constructing the `TreeViewConfiguration`.

This example shows an ambiguous schema:

```typescript
const schemaFactory = new SchemaFactory("com.example");
class Feet extends schemaFactory.object("Feet", {
  length: schemaFactory.number,
}) {}
class Meters extends schemaFactory.object("Meters", {
  length: schemaFactory.number,
}) {}
const config = new TreeViewConfiguration({
  // This combination of schema can lead to ambiguous cases, and will error since preventAmbiguity is true.
  schema: [Feet, Meters],
  preventAmbiguity: true,
});
const view = tree.viewWith(config);
// This is invalid since it is ambiguous which type of node is being constructed.
// The error thrown above when constructing the TreeViewConfiguration is because of this ambiguous case:
view.initialize({ length: 5 });
```

See the documentation on `ITreeConfigurationOptions.preventAmbiguity` for a more complete example and more details.

#### Change details

Commit: [`966906a`](https://github.com/microsoft/FluidFramework/commit/966906a03490daa5a914030b37342abb8267c12d)

Affected packages:

- fluid-framework
- @fluidframework/tree

## ‚ö†Ô∏è Deprecations

### container-loader: summarizeProtocolTree and its corresponding duplicate ILoaderOptions definition is deprecated ([#21999](https://github.com/microsoft/FluidFramework/issues/21999))

The `summarizeProtocolTree` property in ILoaderOptions was added to test single-commit summaries during the initial implementation phase. The flag is no longer required and should no longer be used, and is now marked deprecated. If a driver needs to enable or disable single-commit summaries, it can do so via `IDocumentServicePolicies`.

#### Change details

Commit: [`11ccda1`](https://github.com/microsoft/FluidFramework/commit/11ccda15970a10de00facfebfc060bece4a459ba)

Affected packages:

- @fluidframework/container-loader

### gcThrowOnTombstoneUsage and gcTombstoneEnforcementAllowed are deprecated ([#21992](https://github.com/microsoft/FluidFramework/issues/21992))

These properties `gcThrowOnTombstoneUsage` and `gcTombstoneEnforcementAllowed` have been deprecated in `IFluidParentContext` and `ContainerRuntime`. These were included in certain garbage collection (GC) telemetry to identify whether the corresponding features have been enabled. These features are now enabled by default and this information is added to the "GarbageCollectorLoaded" telemetry.

Also, the following Garbage collection runtime options and configs have been removed. They were added during GC feature development to roll out and control functionalities. The corresponding features are on by default and can no longer be disabled or controlled:

GC runtime options removed:

- `gcDisableThrowOnTombstoneLoad`
- `disableDataStoreSweep`

GC configs removed:

- `"Fluid.GarbageCollection.DisableTombstone"`
- `"Fluid.GarbageCollection.ThrowOnTombstoneUsage"`
- `"Fluid.GarbageCollection.DisableDataStoreSweep"`

#### Change details

Commit: [`b2bfed3`](https://github.com/microsoft/FluidFramework/commit/b2bfed3a624d590d776c64a3317c60400b4b3e81)

Affected packages:

- @fluidframework/container-runtime
- @fluidframework/runtime-definitions

### InactiveResponseHeaderKey header is deprecated ([#22107](https://github.com/microsoft/FluidFramework/issues/22107))

The header `InactiveResponseHeaderKey` is deprecated and will be removed in the future. It was part of an experimental feature where loading an inactive data store would result in returning a 404 with this header set to true. This feature is no longer supported.

#### Change details

Commit: [`2e4e9b2`](https://github.com/microsoft/FluidFramework/commit/2e4e9b2cfcdd7f5d2aa460ab9dedabd6dc2b20ba)

Affected packages:

- @fluidframework/container-runtime

## Other Changes

### Remove PropertyDDS/SharedTree Schema Converter ([#22111](https://github.com/microsoft/FluidFramework/issues/22111))

This schema converter had several known issues and has been removed. Read the [schema converter section](https://github.com/microsoft/FluidFramework/blob/main/experimental/PropertyDDS/packages/property-shared-tree-interop/README.md#schema-converter-runtime) of the package readme for more details.

#### Change details

Commit: [`54e4b5e`](https://github.com/microsoft/FluidFramework/commit/54e4b5e5ec125b59ebc1c05c93bf55db9cf2921a)

Affected packages:

- @fluid-experimental/property-shared-tree-interop

### üõ†Ô∏è Start Building Today!

Please continue to engage with us on GitHub [Discussion](https://github.com/microsoft/FluidFramework/discussions) and [Issue](https://github.com/microsoft/FluidFramework/issues) pages as you adopt Fluid Framework!
