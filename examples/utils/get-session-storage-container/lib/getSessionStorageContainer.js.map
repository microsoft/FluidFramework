{"version":3,"file":"getSessionStorageContainer.js","sourceRoot":"","sources":["../src/getSessionStorageContainer.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAKH,OAAO,EAAa,MAAM,EAAE,MAAM,kCAAkC,CAAC;AACrE,OAAO,EAAE,0BAA0B,EAA+B,MAAM,qCAAqC,CAAC;AAC9G,OAAO,EAAE,aAAa,EAAE,2BAA2B,EAAE,4BAA4B,EAAE,MAAM,8BAA8B,CAAC;AAExH,iGAAiG;AACjG,MAAM,kBAAkB,GAAG,IAAI,GAAG,EAAuC,CAAC;AAE1E,MAAM,WAAW,GAAG,IAAI,aAAa,EAAE,CAAC;AAExC;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,0BAA0B,CAC5C,UAAkB,EAClB,uBAAwC,EACxC,SAAkB;IAElB,IAAI,eAAe,GAAG,kBAAkB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IACzD,IAAI,eAAe,KAAK,SAAS,EAAE;QAC/B,eAAe,GAAG,0BAA0B,CAAC,MAAM,CAAC,IAAI,4BAA4B,CAAC,UAAU,CAAC,CAAC,CAAC;QAClG,kBAAkB,CAAC,GAAG,CAAC,UAAU,EAAE,eAAe,CAAC,CAAC;KACvD;IAED,MAAM,sBAAsB,GAAG,IAAI,2BAA2B,CAAC,eAAe,CAAC,CAAC;IAChF,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,IAAI,UAAU,EAAE,CAAC;IAEtD,mHAAmH;IACnH,8EAA8E;IAC9E,MAAM,MAAM,GAAG,EAAE,WAAW,EAAE,uBAAuB,EAAE,CAAC;IACxD,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE,KAAK,IAAI,EAAE,CAAC,MAAM,EAAE,CAAC;IAEhD,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC;QACtB,WAAW;QACX,sBAAsB;QACtB,UAAU;KACb,CAAC,CAAC;IAEH,IAAI,SAAoB,CAAC;IAEzB,IAAI,SAAS,EAAE;QACX,6GAA6G;QAC7G,4GAA4G;QAC5G,YAAY;QACZ,SAAS,GAAG,MAAM,MAAM,CAAC,uBAAuB,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC,CAAC;QAC9E,MAAM,SAAS,CAAC,MAAM,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC;KACnC;SAAM;QACH,SAAS,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC;QAC1C,4GAA4G;QAC5G,gFAAgF;QAChF,yEAAyE;QACzE,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE;YACrB,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;SACjE;KACJ;IAED,OAAO,SAAS,CAAC;AACrB,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    IRuntimeFactory,\n} from \"@fluidframework/container-definitions\";\nimport { Container, Loader } from \"@fluidframework/container-loader\";\nimport { LocalDeltaConnectionServer, ILocalDeltaConnectionServer } from \"@fluidframework/server-local-server\";\nimport { LocalResolver, LocalDocumentServiceFactory, LocalSessionStorageDbFactory } from \"@fluidframework/local-driver\";\n\n// The deltaConnection needs to be shared across the Loader instances for collaboration to happen\nconst deltaConnectionMap = new Map<string, ILocalDeltaConnectionServer>();\n\nconst urlResolver = new LocalResolver();\n\n/**\n * Connect to the local SessionStorage Fluid service and retrieve a Container with the given ID running the given code.\n * @param documentId - The document id to retrieve or create\n * @param containerRuntimeFactory - The container factory to be loaded in the container\n */\nexport async function getSessionStorageContainer(\n    documentId: string,\n    containerRuntimeFactory: IRuntimeFactory,\n    createNew: boolean,\n): Promise<Container> {\n    let deltaConnection = deltaConnectionMap.get(documentId);\n    if (deltaConnection === undefined) {\n        deltaConnection = LocalDeltaConnectionServer.create(new LocalSessionStorageDbFactory(documentId));\n        deltaConnectionMap.set(documentId, deltaConnection);\n    }\n\n    const documentServiceFactory = new LocalDocumentServiceFactory(deltaConnection);\n    const url = `${window.location.origin}/${documentId}`;\n\n    // To bypass proposal-based loading, we need a codeLoader that will return our already-in-memory container factory.\n    // The expected format of that response is an IFluidModule with a fluidExport.\n    const module = { fluidExport: containerRuntimeFactory };\n    const codeLoader = { load: async () => module };\n\n    const loader = new Loader({\n        urlResolver,\n        documentServiceFactory,\n        codeLoader,\n    });\n\n    let container: Container;\n\n    if (createNew) {\n        // We're not actually using the code proposal (our code loader always loads the same module regardless of the\n        // proposal), but the Container will only give us a NullRuntime if there's no proposal.  So we'll use a fake\n        // proposal.\n        container = await loader.createDetachedContainer({ package: \"\", config: {} });\n        await container.attach({ url });\n    } else {\n        container = await loader.resolve({ url });\n        // If we didn't create the container properly, then it won't function correctly.  So we'll throw if we got a\n        // new container here, where we expect this to be loading an existing container.\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (!container.existing) {\n            throw new Error(\"Attempted to load a non-existing container\");\n        }\n    }\n\n    return container;\n}\n"]}