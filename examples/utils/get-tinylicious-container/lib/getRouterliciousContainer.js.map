{"version":3,"file":"getRouterliciousContainer.js","sourceRoot":"","sources":["../src/getRouterliciousContainer.ts"],"names":[],"mappings":"AAOA,OAAO,EAAE,mCAAmC,EAAE,MAAM,sCAAsC,CAAC;AAC3F,OAAO,EAAE,qBAAqB,EAAE,MAAM,oCAAoC,CAAC;AAE3E,OAAO,GAAG,MAAM,cAAc,CAAC;AAC/B,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAS9C,MAAM,iBAAiB;IAGnB,YACa,WAAmB,EACX,MAA4B,EACpC,IAAW;QAFX,gBAAW,GAAX,WAAW,CAAQ;QACX,WAAM,GAAN,MAAM,CAAsB;QACpC,SAAI,GAAJ,IAAI,CAAO;QAEpB,IAAI,CAAC,KAAK,GAAG,GAAG,CAAC,IAAI,CACjB;YACI,IAAI;YACJ,UAAU,EAAE,WAAW;YACvB,QAAQ,EAAE,MAAM,CAAC,QAAQ;YACzB,MAAM,EAAE,CAAC,UAAU,EAAE,WAAW,EAAE,eAAe,CAAC;SACrD,EACD,MAAM,CAAC,GAAG,CAAC,CAAC;IACpB,CAAC;IAEM,KAAK,CAAC,OAAO,CAAC,OAAiB;QAClC,MAAM,WAAW,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,IAAI,OAAO,CAAC,GAAG,EAAE,CAAC;QACpF,OAAO,OAAO,CAAC,OAAO,CAAC;YACnB,SAAS,EAAE;gBACP,eAAe,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,WAAW,IAAI,CAAC,MAAM,CAAC,QAAQ,IAAI,OAAO,CAAC,GAAG,EAAE;gBACvF,UAAU,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;gBACpC,UAAU,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,UAAU,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;aACrE;YACD,MAAM,EAAE,EAAE,GAAG,EAAE,IAAI,CAAC,KAAK,EAAE;YAC3B,IAAI,EAAE,OAAO;YACb,GAAG,EAAE,WAAW;SACnB,CAAC,CAAC;IACP,CAAC;IACM,KAAK,CAAC,cAAc,CAAC,WAAyB,EAAE,WAAmB;QACtE,IAAI,WAAW,CAAC,IAAI,KAAK,OAAO,EAAE;YAC9B,MAAM,KAAK,CAAC,sBAAsB,CAAC,CAAC;SACvC;QACD,OAAO,GAAG,WAAW,CAAC,GAAG,IAAI,WAAW,EAAE,CAAC;IAC/C,CAAC;CACJ;AAED;;;;;;;;GAQG;AACH,MAAM,CAAC,KAAK,UAAU,yBAAyB,CAC3C,WAAmB,EACnB,uBAAwC,EACxC,SAAkB,EAClB,MAA4B;IAE5B,MAAM,IAAI,GAAG;QACT,EAAE,EAAE,WAAW;QACf,IAAI,EAAE,aAAa;KACtB,CAAC;IAEF,MAAM,aAAa,GAAG,IAAI,qBAAqB,CAAC,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;IAClE,MAAM,sBAAsB,GAAG,IAAI,mCAAmC,CAAC,aAAa,CAAC,CAAC;IAEtF,MAAM,WAAW,GAAG,IAAI,iBAAiB,CAAC,WAAW,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;IAErE,OAAO,YAAY,CACf,WAAW,EACX,SAAS,EACT,EAAE,GAAG,EAAE,WAAW,EAAE,EACpB,WAAW,EACX,sBAAsB,EACtB,uBAAuB,CAC1B,CAAC;AACN,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { IRuntimeFactory } from \"@fluidframework/container-definitions\";\nimport { IRequest } from \"@fluidframework/core-interfaces\";\nimport { IFluidResolvedUrl, IResolvedUrl, IUrlResolver } from \"@fluidframework/driver-definitions\";\nimport { RouterliciousDocumentServiceFactory } from \"@fluidframework/routerlicious-driver\";\nimport { InsecureTokenProvider } from \"@fluidframework/test-runtime-utils\";\nimport { IUser } from \"@fluidframework/protocol-definitions\";\nimport jwt from \"jsonwebtoken\";\nimport { getContainer } from \"./getContainer\";\n\nexport interface IRouterliciousConfig {\n    orderer: string,\n    storage: string,\n    tenantId: string,\n    key: string,\n}\n\nclass SimpleUrlResolver implements IUrlResolver {\n    private readonly token: string;\n\n    constructor(\n        readonly containerId: string,\n        private readonly config: IRouterliciousConfig,\n        readonly user: IUser,\n    ) {\n        this.token = jwt.sign(\n            {\n                user,\n                documentId: containerId,\n                tenantId: config.tenantId,\n                scopes: [\"doc:read\", \"doc:write\", \"summary:write\"],\n            },\n            config.key);\n    }\n\n    public async resolve(request: IRequest): Promise<IFluidResolvedUrl> {\n        const documentUrl = `${this.config.orderer}/${this.config.tenantId}/${request.url}`;\n        return Promise.resolve({\n            endpoints: {\n                deltaStorageUrl: `${this.config.orderer}/deltas/${this.config.tenantId}/${request.url}`,\n                ordererUrl: `${this.config.orderer}`,\n                storageUrl: `${this.config.storage}/repos/${this.config.tenantId}`,\n            },\n            tokens: { jwt: this.token },\n            type: \"fluid\",\n            url: documentUrl,\n        });\n    }\n    public async getAbsoluteUrl(resolvedUrl: IResolvedUrl, relativeUrl: string): Promise<string> {\n        if (resolvedUrl.type !== \"fluid\") {\n            throw Error(\"Invalid Resolved Url\");\n        }\n        return `${resolvedUrl.url}/${relativeUrl}`;\n    }\n}\n\n/**\n * Connect to an implementation of the Routerlicious service and retrieve a Container with\n * the given ID running the given code.\n *\n * @param containerId - The document id to retrieve or create\n * @param containerRuntimeFactory - The container factory to be loaded in the container\n * @param createNew - Is this a new container\n * @param config\n */\nexport async function getRouterliciousContainer(\n    containerId: string,\n    containerRuntimeFactory: IRuntimeFactory,\n    createNew: boolean,\n    config: IRouterliciousConfig,\n) {\n    const user = {\n        id: \"unique-id\",\n        name: \"Unique Idee\",\n    };\n\n    const tokenProvider = new InsecureTokenProvider(config.key, user);\n    const documentServiceFactory = new RouterliciousDocumentServiceFactory(tokenProvider);\n\n    const urlResolver = new SimpleUrlResolver(containerId, config, user);\n\n    return getContainer(\n        containerId,\n        createNew,\n        { url: containerId },\n        urlResolver,\n        documentServiceFactory,\n        containerRuntimeFactory,\n    );\n}\n"]}