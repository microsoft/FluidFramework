{"version":3,"file":"fluidSudoku.js","sourceRoot":"","sources":["../src/fluidSudoku.tsx"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { DataObject, DataObjectFactory } from \"@fluidframework/aqueduct\";\nimport { IFluidHandle } from \"@fluidframework/core-interfaces\";\nimport { ISharedMap, SharedMap } from \"@fluidframework/map\";\nimport { IFluidHTMLView } from \"@fluidframework/view-interfaces\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { loadPuzzle } from \"./helpers/puzzles\";\nimport { SudokuView } from \"./react/sudokuView\";\n\n// eslint-disable-next-line import/no-unassigned-import\nimport \"./helpers/styles.css\";\n\n/**\n * A collaborative Sudoku component built on the Fluid Framework.\n */\nexport class FluidSudoku extends DataObject implements IFluidHTMLView {\n    public get IFluidHTMLView() {\n        return this;\n    }\n\n    public static ObjectIdentifier: string = \"FluidSudoku\";\n\n    /**\n     * This is where you define all which Distributed Data Structures your component will use\n     */\n    private static readonly factory = new DataObjectFactory(\n        FluidSudoku.ObjectIdentifier,\n        FluidSudoku,\n        [SharedMap.getFactory()],\n        {}\n    );\n\n    public static getFactory() {\n        return FluidSudoku.factory;\n    }\n\n    private domElement: HTMLElement | undefined;\n    private readonly sudokuMapKey = \"sudoku-map\";\n    private puzzle: ISharedMap | undefined;\n    private readonly presenceMapKey = \"clientPresence\";\n    private clientPresence: ISharedMap | undefined;\n\n    /**\n     * ComponentInitializingFirstTime is where you do setup for your component. This is only called once the first time\n     * your component is created. Anything that happens in initializingFirstTime will happen before any other\n     * user will see the component.\n     */\n    protected async initializingFirstTime() {\n        // Create a new map for our Sudoku data\n        const map = SharedMap.create(this.runtime);\n\n        // Populate it with some puzzle data\n        loadPuzzle(0, map);\n\n        // Store the new map under the sudokuMapKey key in the root SharedDirectory\n        this.root.set(this.sudokuMapKey, map.handle);\n\n        // Create a SharedMap to store presence data\n        const clientPresence = SharedMap.create(this.runtime);\n        this.root.set(this.presenceMapKey, clientPresence.handle);\n    }\n\n    /**\n     * This method will be called whenever the component has initialized, be it the first time or subsequent times.\n     */\n    protected async hasInitialized() {\n        // Shared objects that are stored within other Shared objects (e.g. a SharedMap within the root, which is a\n        // SharedDirectory) must be retrieved asynchronously. We do that here, in this async function, then store a\n        // local reference to the object so we can easily use it in synchronous code.\n        //\n        // Our \"puzzle\" SharedMap is stored as a handle on the \"root\" SharedDirectory. To get it we must make a\n        // synchronous call to get the IFluidHandle, then an asynchronous call to get the ISharedMap from the\n        // handle.\n        this.puzzle = await this.root.get<IFluidHandle<ISharedMap>>(this.sudokuMapKey).get();\n\n        // Since we're using a Fluid distributed data structure to store our Sudoku data, we need to render whenever a\n        // value in our map changes. Recall that distributed data structures can be changed by both local and remote\n        // clients, so if we don't call render here, then our UI will not update when remote clients change data.\n        this.puzzle.on(\"valueChanged\", (changed, local, op) => {\n            this.render();\n        });\n\n        this.clientPresence = await this.root\n            .get<IFluidHandle<ISharedMap>>(this.presenceMapKey)\n            .get();\n\n        this.clientPresence.on(\"valueChanged\", (changed, local, op) => {\n            this.render();\n        });\n    }\n\n    public render(element?: HTMLElement): void {\n        if (element) {\n            this.domElement = element;\n        }\n        if (this.domElement) {\n            let view: JSX.Element;\n            if (this.puzzle) {\n                view = (\n                    <SudokuView\n                        puzzle={this.puzzle}\n                        clientPresence={this.clientPresence}\n                        clientId={this.runtime.clientId ?? \"not connected\"}\n                        setPresence={this.presenceSetter}\n                    />\n                );\n            } else {\n                view = <div />;\n            }\n            ReactDOM.render(view, this.domElement);\n        }\n    }\n\n    /**\n     * A function that can be used to update presence data.\n     *\n     * @param cellCoordinate - The coordinate of the cell to set.\n     * @param reset - If true, presence for the cell will be cleared.\n     */\n    private readonly presenceSetter = (cellCoordinate: string, reset: boolean): void => {\n        if (this.clientPresence) {\n            if (reset) {\n                // Retrieve the current clientId in the cell, if there is one\n                const prev = this.clientPresence.get<string>(cellCoordinate);\n                const isCurrentClient = this.runtime.clientId === prev;\n                if (!isCurrentClient) {\n                    return;\n                }\n                this.clientPresence.delete(cellCoordinate);\n            } else {\n                this.clientPresence.set(cellCoordinate, this.runtime.clientId);\n            }\n        }\n    };\n}\n"]}