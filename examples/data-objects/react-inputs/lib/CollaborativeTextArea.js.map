{"version":3,"file":"CollaborativeTextArea.js","sourceRoot":"","sources":["../src/CollaborativeTextArea.tsx"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { SharedString } from \"@fluidframework/sequence\";\nimport React from \"react\";\n\nexport interface ICollaborativeTextAreaProps {\n    /**\n     * The SharedString that will store the text from the textarea.\n     */\n    sharedString: SharedString;\n    /**\n     * Whether spellCheck should be enabled.  Defaults to false.\n     */\n    spellCheck?: boolean;\n    className?: string;\n    style?: React.CSSProperties;\n}\n\nexport interface ICollaborativeTextAreaState {\n    selectionEnd: number;\n    selectionStart: number;\n    text: string;\n}\n\n/**\n * Given a SharedString will produce a collaborative textarea.\n */\nexport class CollaborativeTextArea\n    extends React.Component<ICollaborativeTextAreaProps, ICollaborativeTextAreaState> {\n    private readonly ref: React.RefObject<HTMLTextAreaElement>;\n\n    constructor(props: ICollaborativeTextAreaProps) {\n        super(props);\n\n        this.ref = React.createRef<HTMLTextAreaElement>();\n\n        this.state = {\n            selectionEnd: 0,\n            selectionStart: 0,\n            text: this.props.sharedString.getText(),\n        };\n\n        this.handleChange = this.handleChange.bind(this);\n        this.updateSelection = this.updateSelection.bind(this);\n    }\n\n    public componentDidMount() {\n        // Sets an event listener so we can update our state as the value changes\n\n        this.props.sharedString.on(\"sequenceDelta\", (event) => {\n            const newText = this.props.sharedString.getText();\n            // We only need to insert if the text changed.\n            if (newText === this.state.text) {\n                return;\n            }\n\n            // If the event is our own then just insert the text\n            if (event.isLocal) {\n                this.setState({ text: newText });\n                return;\n            }\n\n            // Because we did not make the change we need to manage the remote\n            // character insertion.\n            const remoteCaretStart = event.first.position;\n            const remoteCaretEnd = event.last.position + event.last.segment.cachedLength;\n            const charactersModifiedCount = newText.length - this.state.text.length;\n\n            this.updateSelection();\n            const currentCaretStart = this.state.selectionStart;\n            const currentCaretEnd = this.state.selectionEnd;\n\n            let newCaretStart = 0;\n            let newCaretEnd = 0;\n\n            // Remote text inserted/removed after our cp range\n            if (currentCaretEnd <= remoteCaretStart) {\n                // cp stays where it was before.\n                newCaretStart = currentCaretStart;\n                newCaretEnd = currentCaretEnd;\n            } else if (currentCaretStart > (remoteCaretEnd - 1)) {\n                // Remote text inserted/removed before our cp range\n                // We need to move our cp the number of characters inserted/removed\n                // to ensure we are in the same position\n                newCaretStart = currentCaretStart + charactersModifiedCount;\n                newCaretEnd = currentCaretEnd + charactersModifiedCount;\n            } else {\n                // Remote text is overlapping cp\n\n                // The remote changes occurred inside current selection\n                if (remoteCaretEnd <= currentCaretEnd && remoteCaretStart > currentCaretStart) {\n                    // Our selection needs to include remote changes\n                    newCaretStart = currentCaretStart;\n                    newCaretEnd = currentCaretEnd + charactersModifiedCount;\n                } else if (remoteCaretEnd >= currentCaretEnd && remoteCaretStart <= currentCaretStart) {\n                    // The remote changes encompass our location\n\n                    // Our selection has been removed\n                    // Move our cp to the beginning of the new text insertion\n                    newCaretStart = remoteCaretStart;\n                    newCaretEnd = remoteCaretStart;\n                } else {\n                    // We have partial overlapping selection with the changes.\n                    // This makes things a lot harder to manage so for now we will just remove the current selection\n                    // and place it to the remote caret start.\n                    // TODO: implement this the correct way\n                    newCaretStart = remoteCaretStart;\n                    newCaretEnd = remoteCaretStart;\n                }\n            }\n\n            this.setState({ text: newText });\n            this.setCaretPosition(newCaretStart, newCaretEnd);\n        });\n    }\n\n    private setCaretPosition(newStart: number, newEnd: number) {\n        if (this.ref.current) {\n            this.ref.current.selectionStart = newStart;\n            this.ref.current.selectionEnd = newEnd;\n        }\n    }\n\n    // componentDidUpdate(){\n    //     this.setCaretPosition(this.state.selectionStart, this.state.selectionEnd);\n    // }\n\n    public render() {\n        return (\n            // There are a lot of different ways content can be inserted into a textarea\n            // and not all of them trigger a onBeforeInput event. To ensure we are grabbing\n            // the correct selection before we modify the shared string we need to make sure\n            // this.updateSelection is being called for multiple cases.\n            <textarea\n                rows={20}\n                cols={50}\n                ref={this.ref}\n                className={this.props.className}\n                style={this.props.style}\n                spellCheck={this.props.spellCheck ? this.props.spellCheck : false}\n                onBeforeInput={this.updateSelection}\n                onKeyDown={this.updateSelection}\n                onClick={this.updateSelection}\n                onContextMenu={this.updateSelection}\n                // onChange is recommended over onInput for React controls\n                // https://medium.com/capital-one-tech/how-to-work-with-forms-inputs-and-events-in-react-c337171b923b\n                onChange={this.handleChange}\n                value={this.state.text} />\n        );\n    }\n\n    private handleChange(ev: React.FormEvent<HTMLTextAreaElement>) {\n        // We need to set the value here to keep the input responsive to the user\n        const newText = ev.currentTarget.value;\n        const charactersModifiedCount = this.state.text.length - newText.length;\n        this.setState({ text: newText });\n\n        // Get the new caret position and use that to get the text that was inserted\n        const newPosition = ev.currentTarget.selectionStart ? ev.currentTarget.selectionStart : 0;\n        const isTextInserted = newPosition - this.state.selectionStart > 0;\n        if (isTextInserted) {\n            const insertedText = newText.substring(this.state.selectionStart, newPosition);\n            const changeRangeLength = this.state.selectionEnd - this.state.selectionStart;\n            if (changeRangeLength === 0) {\n                this.props.sharedString.insertText(this.state.selectionStart, insertedText);\n            } else {\n                this.props.sharedString.replaceText(this.state.selectionStart, this.state.selectionEnd, insertedText);\n            }\n        } else {\n            // Text was removed\n            this.props.sharedString.removeText(newPosition, newPosition + charactersModifiedCount);\n        }\n    }\n\n    /**\n     * Update the current caret selection.\n     * We need to do this before we do any handleChange action or we will have lost our\n     * cursor position and not be able to accurately update the shared string.\n     */\n    private updateSelection() {\n        if (!this.ref.current) {\n            return;\n        }\n\n        const selectionEnd = this.ref.current.selectionEnd ? this.ref.current.selectionEnd : 0;\n        const selectionStart = this.ref.current.selectionStart ? this.ref.current.selectionStart : 0;\n        this.setState({ selectionEnd, selectionStart });\n    }\n}\n"]}