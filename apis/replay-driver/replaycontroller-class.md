{
  "title": "ReplayController Class",
  "summary": "Replay controller object It controls where we start (snapshot, local file, no snapshots) As well as dispatch of ops",
  "kind": "Class",
  "members": {
    "Method": {
      "fetchTo": "/docs/apis/replay-driver\\replaycontroller-class#fetchto-method",
      "getStartingOpSequence": "/docs/apis/replay-driver\\replaycontroller-class#getstartingopsequence-method",
      "initStorage": "/docs/apis/replay-driver\\replaycontroller-class#initstorage-method",
      "isDoneFetch": "/docs/apis/replay-driver\\replaycontroller-class#isdonefetch-method",
      "replay": "/docs/apis/replay-driver\\replaycontroller-class#replay-method"
    }
  },
  "package": "@fluidframework/replay-driver",
  "unscopedPackageName": "replay-driver"
}

[//]: # (Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter.)

[Packages](/docs/apis/) &gt; [@fluidframework/replay-driver](/docs/apis/replay-driver) &gt; [ReplayController](/docs/apis/replay-driver\replaycontroller-class)

Replay controller object It controls where we start (snapshot, local file, no snapshots) As well as dispatch of ops

## Signature {#replaycontroller-signature}

```typescript
export declare abstract class ReplayController extends ReadDocumentStorageServiceBase 
```
<b>Extends:</b> [ReadDocumentStorageServiceBase](/docs/apis/replay-driver\readdocumentstorageservicebase-class)

## Methods

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Method
      </th>
      <th scope="col">
        Return Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/replay-driver\replaycontroller-class#fetchto-method'>fetchTo</a>
      </td>
      <td>
        number | undefined
      </td>
      <td>
        Returns last op number to fetch from current op Note: this API is called while replay() is in progress - next batch of ops is downloaded in parallel
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/replay-driver\replaycontroller-class#getstartingopsequence-method'>getStartingOpSequence</a>
      </td>
      <td>
        Promise<number>
      </td>
      <td>
        Returns sequence number to start processing ops Should be zero if not using snapshot, and snapshot seq# otherwise
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/replay-driver\replaycontroller-class#initstorage-method'>initStorage</a>
      </td>
      <td>
        Promise<boolean>
      </td>
      <td>
        Initialize reply controller
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/replay-driver\replaycontroller-class#isdonefetch-method'>isDoneFetch</a>
      </td>
      <td>
        boolean
      </td>
      <td>
        Returns true if no more ops should be processed (or downloaded for future processing). It's called at end of each batch with latest op timestamp. Also it's called when there are no more ops available (lastTimeStamp === undefined). If false is returned and there are no more ops, request for more ops is made every 2 seconds. Note: this API is called while replay() is in progress - next batch of ops is downloaded in parallel
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/replay-driver\replaycontroller-class#replay-method'>replay</a>
      </td>
      <td>
        Promise<void>
      </td>
      <td>
        Replay batch of ops NOTE: new batch of ops is fetched (fetchTo() & isDoneFetch() APIs are called) while this call is in flights
      </td>
    </tr>
  </tbody>
</table>

## Method Details

### fetchTo {#fetchto-method}

Returns last op number to fetch from current op Note: this API is called while replay() is in progress - next batch of ops is downloaded in parallel

#### Signature {#fetchto-signature}

```typescript
abstract fetchTo(currentOp: number): number | undefined;
```

#### Parameters {#fetchto-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        currentOp
      </td>
      <td>
        number
      </td>
      <td>
        current op
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#fetchto-returns}

<b>Return type:</b> number \| undefined

### getStartingOpSequence {#getstartingopsequence-method}

Returns sequence number to start processing ops Should be zero if not using snapshot, and snapshot seq\# otherwise

#### Signature {#getstartingopsequence-signature}

```typescript
abstract getStartingOpSequence(): Promise<number>;
```

#### Returns {#getstartingopsequence-returns}

<b>Return type:</b> Promise&lt;number&gt;

### initStorage {#initstorage-method}

Initialize reply controller

#### Signature {#initstorage-signature}

```typescript
abstract initStorage(documentService: IDocumentService): Promise<boolean>;
```

#### Parameters {#initstorage-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        documentService
      </td>
      <td>
        <a href='/docs/apis/driver-definitions\idocumentservice-interface'>IDocumentService</a>
      </td>
      <td>
        the real document service
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#initstorage-returns}

- Boolean, indicating if controller should be used. If false is returned, caller should fallback to original storage.

<b>Return type:</b> Promise&lt;boolean&gt;

### isDoneFetch {#isdonefetch-method}

Returns true if no more ops should be processed (or downloaded for future processing). It's called at end of each batch with latest op timestamp. Also it's called when there are no more ops available (lastTimeStamp === undefined). If false is returned and there are no more ops, request for more ops is made every 2 seconds. Note: this API is called while replay() is in progress - next batch of ops is downloaded in parallel

#### Signature {#isdonefetch-signature}

```typescript
abstract isDoneFetch(currentOp: number, lastTimeStamp?: number): boolean;
```

#### Parameters {#isdonefetch-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Modifiers
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        currentOp
      </td>
      <td>
      </td>
      <td>
        number
      </td>
      <td>
        current op
      </td>
    </tr>
    <tr>
      <td>
        lastTimeStamp
      </td>
      <td>
        optional
      </td>
      <td>
        number
      </td>
      <td>
        timestamp of last op (if more ops are available). Undefined otherwise.
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#isdonefetch-returns}

<b>Return type:</b> boolean

### replay {#replay-method}

Replay batch of ops NOTE: new batch of ops is fetched (fetchTo() &amp; isDoneFetch() APIs are called) while this call is in flights

#### Signature {#replay-signature}

```typescript
abstract replay(emitter: (op: api.ISequencedDocumentMessage[]) => void, fetchedOps: api.ISequencedDocumentMessage[]): Promise<void>;
```

#### Parameters {#replay-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        emitter
      </td>
      <td>
        (op: api.<a href='/docs/apis/protocol-definitions\isequenceddocumentmessage-interface'>ISequencedDocumentMessage</a>[]) => void
      </td>
      <td>
        callback to emit ops
      </td>
    </tr>
    <tr>
      <td>
        fetchedOps
      </td>
      <td>
        api.<a href='/docs/apis/protocol-definitions\isequenceddocumentmessage-interface'>ISequencedDocumentMessage</a>[]
      </td>
      <td>
        ops to process
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#replay-returns}

<b>Return type:</b> Promise&lt;void&gt;