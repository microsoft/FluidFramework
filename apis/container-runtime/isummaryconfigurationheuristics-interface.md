{
  "title": "ISummaryConfigurationHeuristics Interface",
  "kind": "Interface",
  "members": {
    "PropertySignature": {
      "maxIdleTime": "/docs/apis/container-runtime\\isummaryconfigurationheuristics-interface#maxidletime-propertysignature",
      "maxOps": "/docs/apis/container-runtime\\isummaryconfigurationheuristics-interface#maxops-propertysignature",
      "maxTime": "/docs/apis/container-runtime\\isummaryconfigurationheuristics-interface#maxtime-propertysignature",
      "minIdleTime": "/docs/apis/container-runtime\\isummaryconfigurationheuristics-interface#minidletime-propertysignature",
      "minOpsForLastSummaryAttempt": "/docs/apis/container-runtime\\isummaryconfigurationheuristics-interface#minopsforlastsummaryattempt-propertysignature",
      "nonRuntimeHeuristicThreshold": "/docs/apis/container-runtime\\isummaryconfigurationheuristics-interface#nonruntimeheuristicthreshold-propertysignature",
      "nonRuntimeOpWeight": "/docs/apis/container-runtime\\isummaryconfigurationheuristics-interface#nonruntimeopweight-propertysignature",
      "runtimeOpWeight": "/docs/apis/container-runtime\\isummaryconfigurationheuristics-interface#runtimeopweight-propertysignature",
      "state": "/docs/apis/container-runtime\\isummaryconfigurationheuristics-interface#state-propertysignature"
    }
  },
  "package": "@fluidframework/container-runtime",
  "unscopedPackageName": "container-runtime"
}

[//]: # (Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter.)

[Packages](/docs/apis/) &gt; [@fluidframework/container-runtime](/docs/apis/container-runtime) &gt; [ISummaryConfigurationHeuristics](/docs/apis/container-runtime\isummaryconfigurationheuristics-interface)

## Signature {#isummaryconfigurationheuristics-signature}

```typescript
export interface ISummaryConfigurationHeuristics extends ISummaryBaseConfiguration 
```
<b>Extends:</b> [ISummaryBaseConfiguration](/docs/apis/container-runtime\isummarybaseconfiguration-interface)

## Properties

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Property
      </th>
      <th scope="col">
        Modifiers
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/container-runtime\isummaryconfigurationheuristics-interface#maxidletime-propertysignature'>maxIdleTime</a>
      </td>
      <td>
      </td>
      <td>
        number
      </td>
      <td>
        Defines the upper boundary for the allowed time in between summarizations. Pairs with minIdleTime to form a range. For example, if we only receive 1 op, we don't want to have the same idle time as say 100 ops. Based on the boundaries we set in minIdleTime and maxIdleTime, the idle time will change linearly depending on the number of ops we receive.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/container-runtime\isummaryconfigurationheuristics-interface#maxops-propertysignature'>maxOps</a>
      </td>
      <td>
      </td>
      <td>
        number
      </td>
      <td>
        Defines the maximum number of Ops, since the last received Ack, that can be allowed before running the summary with reason maxOps.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/container-runtime\isummaryconfigurationheuristics-interface#maxtime-propertysignature'>maxTime</a>
      </td>
      <td>
      </td>
      <td>
        number
      </td>
      <td>
        Defines the maximum allowed time, since the last received Ack, before running the summary with reason maxTime. For example, say we receive ops one by one just before the idle time is triggered. In this case, we still want to run a summary since it's been a while since the last summary.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/container-runtime\isummaryconfigurationheuristics-interface#minidletime-propertysignature'>minIdleTime</a>
      </td>
      <td>
      </td>
      <td>
        number
      </td>
      <td>
        Defines the lower boundary for the allowed time in between summarizations. Pairs with maxIdleTime to form a range. For example, if we only receive 1 op, we don't want to have the same idle time as say 100 ops. Based on the boundaries we set in minIdleTime and maxIdleTime, the idle time will change linearly depending on the number of ops we receive.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/container-runtime\isummaryconfigurationheuristics-interface#minopsforlastsummaryattempt-propertysignature'>minOpsForLastSummaryAttempt</a>
      </td>
      <td>
      </td>
      <td>
        number
      </td>
      <td>
        Defines the minimum number of Ops, since the last received Ack, that can be allowed before running the last summary.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/container-runtime\isummaryconfigurationheuristics-interface#nonruntimeheuristicthreshold-propertysignature'>nonRuntimeHeuristicThreshold</a>
      </td>
      <td>
        <code>optional</code>
      </td>
      <td>
        number
      </td>
      <td>
        <p>Number of ops since last summary needed before a non-runtime op can trigger running summary heuristics.</p><p>Note: Any runtime ops sent before the threshold is reached will trigger heuristics normally. This threshold ONLY applies to non-runtime ops triggering summaries.</p><p>For example: Say the threshold is 20. Sending 19 non-runtime ops will not trigger any heuristic checks. Sending the 20th non-runtime op will trigger the heuristic checks for summarizing.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/container-runtime\isummaryconfigurationheuristics-interface#nonruntimeopweight-propertysignature'>nonRuntimeOpWeight</a>
      </td>
      <td>
      </td>
      <td>
        number
      </td>
      <td>
        Non-runtime op weight to use in heuristic summarizing This number is a multiplier on the number of non-runtime ops we process when running summarize heuristics. For example: (multiplier) * (number of non-runtime ops) = weighted number of non-runtime ops
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/container-runtime\isummaryconfigurationheuristics-interface#runtimeopweight-propertysignature'>runtimeOpWeight</a>
      </td>
      <td>
      </td>
      <td>
        number
      </td>
      <td>
        Runtime op weight to use in heuristic summarizing. This number is a multiplier on the number of runtime ops we process when running summarize heuristics. For example: (multiplier) * (number of runtime ops) = weighted number of runtime ops
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/container-runtime\isummaryconfigurationheuristics-interface#state-propertysignature'>state</a>
      </td>
      <td>
      </td>
      <td>
        "enabled"
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Property Details

### maxIdleTime {#maxidletime-propertysignature}

Defines the upper boundary for the allowed time in between summarizations. Pairs with minIdleTime to form a range. For example, if we only receive 1 op, we don't want to have the same idle time as say 100 ops. Based on the boundaries we set in minIdleTime and maxIdleTime, the idle time will change linearly depending on the number of ops we receive.

#### Signature {#maxidletime-signature}

```typescript
maxIdleTime: number;
```

### maxOps {#maxops-propertysignature}

Defines the maximum number of Ops, since the last received Ack, that can be allowed before running the summary with reason maxOps.

#### Signature {#maxops-signature}

```typescript
maxOps: number;
```

### maxTime {#maxtime-propertysignature}

Defines the maximum allowed time, since the last received Ack, before running the summary with reason maxTime. For example, say we receive ops one by one just before the idle time is triggered. In this case, we still want to run a summary since it's been a while since the last summary.

#### Signature {#maxtime-signature}

```typescript
maxTime: number;
```

### minIdleTime {#minidletime-propertysignature}

Defines the lower boundary for the allowed time in between summarizations. Pairs with maxIdleTime to form a range. For example, if we only receive 1 op, we don't want to have the same idle time as say 100 ops. Based on the boundaries we set in minIdleTime and maxIdleTime, the idle time will change linearly depending on the number of ops we receive.

#### Signature {#minidletime-signature}

```typescript
minIdleTime: number;
```

### minOpsForLastSummaryAttempt {#minopsforlastsummaryattempt-propertysignature}

Defines the minimum number of Ops, since the last received Ack, that can be allowed before running the last summary.

#### Signature {#minopsforlastsummaryattempt-signature}

```typescript
minOpsForLastSummaryAttempt: number;
```

### nonRuntimeHeuristicThreshold {#nonruntimeheuristicthreshold-propertysignature}

Number of ops since last summary needed before a non-runtime op can trigger running summary heuristics.

Note: Any runtime ops sent before the threshold is reached will trigger heuristics normally. This threshold ONLY applies to non-runtime ops triggering summaries.

For example: Say the threshold is 20. Sending 19 non-runtime ops will not trigger any heuristic checks. Sending the 20th non-runtime op will trigger the heuristic checks for summarizing.

#### Signature {#nonruntimeheuristicthreshold-signature}

```typescript
nonRuntimeHeuristicThreshold?: number;
```

### nonRuntimeOpWeight {#nonruntimeopweight-propertysignature}

Non-runtime op weight to use in heuristic summarizing This number is a multiplier on the number of non-runtime ops we process when running summarize heuristics. For example: (multiplier) \* (number of non-runtime ops) = weighted number of non-runtime ops

#### Signature {#nonruntimeopweight-signature}

```typescript
nonRuntimeOpWeight: number;
```

### runtimeOpWeight {#runtimeopweight-propertysignature}

Runtime op weight to use in heuristic summarizing. This number is a multiplier on the number of runtime ops we process when running summarize heuristics. For example: (multiplier) \* (number of runtime ops) = weighted number of runtime ops

#### Signature {#runtimeopweight-signature}

```typescript
runtimeOpWeight: number;
```

### state {#state-propertysignature}

#### Signature {#state-signature}

```typescript
state: "enabled";
```