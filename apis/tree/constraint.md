{"kind":"Interface","title":"Constraint Interface","summary":"A set of constraints on the validity of an Edit. A Constraint is used to detect when an Edit, due to other concurrent edits, may have unintended effects or merge in non-semantic ways. It is processed in order like any other Change in an Edit. It can cause an edit to fail if the various constraints are not met at the time of evaluation (ex: the parentNode has changed due to concurrent editing). Does not modify the document.","members":{"PropertySignature":{"contentHash":"/docs/apis/tree/constraint#contenthash-PropertySignature","effect":"/docs/apis/tree/constraint#effect-PropertySignature","identityHash":"/docs/apis/tree/constraint#identityhash-PropertySignature","label":"/docs/apis/tree/constraint#label-PropertySignature","length":"/docs/apis/tree/constraint#length-PropertySignature","parentNode":"/docs/apis/tree/constraint#parentnode-PropertySignature","toConstrain":"/docs/apis/tree/constraint#toconstrain-PropertySignature","type":"/docs/apis/tree/constraint#type-PropertySignature"}},"package":"@fluid-experimental/tree","unscopedPackageName":"tree"}

[//]: # (Do not edit this file. It is automatically generated by API Documenter.)

[Packages](/docs/apis/) &gt; [@fluid-experimental/tree](/docs/apis/tree) &gt; [Constraint](/docs/apis/tree/constraint)

A set of constraints on the validity of an Edit. A Constraint is used to detect when an Edit, due to other concurrent edits, may have unintended effects or merge in non-semantic ways. It is processed in order like any other Change in an Edit. It can cause an edit to fail if the various constraints are not met at the time of evaluation (ex: the parentNode has changed due to concurrent editing). Does not modify the document.

<b>Signature:</b>

```typescript
export interface Constraint 
```

## Properties

<table class="table table-striped table-hover property-list">
<caption>List of properties on this interface</caption>
  <thead>
    <tr>
     <th scope="col">Property</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href='/docs/apis/tree/constraint#contenthash-PropertySignature'>contentHash</a></td>
      <td><a href='/docs/apis/tree#uuidstring-TypeAlias'>UuidString</a></td>
      <td>Require that the contents of all of the nodes in toConstrain hash to this value. Hash is an order dependant deep hash, which includes all subtree content recursively. TODO: implement and specify exact hash function.<!-- -->This is an efficient (O(1) space) way to constrain a sequence of nodes have exact values (transitively).</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/tree/constraint#effect-PropertySignature'>effect</a></td>
      <td><a href='/docs/apis/tree#constrainteffect-Enum'>ConstraintEffect</a></td>
      <td>What to do if a constraint is not met.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/tree/constraint#identityhash-PropertySignature'>identityHash</a></td>
      <td><a href='/docs/apis/tree#uuidstring-TypeAlias'>UuidString</a></td>
      <td>Require that the identities of all the nodes in toConstrain hash to this value. Hash is order dependent. TODO: implement and specify exact hash function.<!-- -->This is an efficient (O(1) space) way to constrain a sequence of nodes to have specific identities.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/tree/constraint#label-PropertySignature'>label</a></td>
      <td><a href='/docs/apis/tree#traitlabel-TypeAlias'>TraitLabel</a></td>
      <td>Require that the trait under which toConstrain is located has this label.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/tree/constraint#length-PropertySignature'>length</a></td>
      <td>number</td>
      <td>Require that the number of nodes in toConstrain is this value.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/tree/constraint#parentnode-PropertySignature'>parentNode</a></td>
      <td><a href='/docs/apis/tree#nodeid-TypeAlias'>NodeId</a></td>
      <td>Require that parent under which toConstrain is located has this identifier.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/tree/constraint#toconstrain-PropertySignature'>toConstrain</a></td>
      <td><a href='/docs/apis/tree/stablerange'>StableRange</a></td>
      <td>Selects a sequence of nodes which will be checked against the constraints specified by the optional fields. If <code>toConstrain</code> is invalid, it will be treated like a constraint being unmet. Depending on <code>effect</code> this may or may not make the Edit invalid.<!-- -->When a constraint is not met, the effects is specified by <code>effect</code>.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/tree/constraint#type-PropertySignature'>type</a></td>
      <td>typeof <a href='/docs/apis/tree#changetype-Enum'>ChangeType.Constraint</a></td>
      <td>Marker for which kind of Change this is.</td>
    </tr>
  </tbody>
</table>

<hr><div id=interface-details>

## Property Details {#properties-details}

### contentHash {#contenthash-PropertySignature}

Require that the contents of all of the nodes in toConstrain hash to this value. Hash is an order dependant deep hash, which includes all subtree content recursively. TODO: implement and specify exact hash function.

This is an efficient (O(1) space) way to constrain a sequence of nodes have exact values (transitively).

<b>Signature:</b>

```typescript
readonly contentHash?: UuidString;
```

### effect {#effect-PropertySignature}

What to do if a constraint is not met.

<b>Signature:</b>

```typescript
readonly effect: ConstraintEffect;
```

### identityHash {#identityhash-PropertySignature}

Require that the identities of all the nodes in toConstrain hash to this value. Hash is order dependent. TODO: implement and specify exact hash function.

This is an efficient (O(1) space) way to constrain a sequence of nodes to have specific identities.

<b>Signature:</b>

```typescript
readonly identityHash?: UuidString;
```

### label {#label-PropertySignature}

Require that the trait under which toConstrain is located has this label.

<b>Signature:</b>

```typescript
readonly label?: TraitLabel;
```

### length {#length-PropertySignature}

Require that the number of nodes in toConstrain is this value.

<b>Signature:</b>

```typescript
readonly length?: number;
```

### parentNode {#parentnode-PropertySignature}

Require that parent under which toConstrain is located has this identifier.

<b>Signature:</b>

```typescript
readonly parentNode?: NodeId;
```

### toConstrain {#toconstrain-PropertySignature}

Selects a sequence of nodes which will be checked against the constraints specified by the optional fields. If `toConstrain` is invalid, it will be treated like a constraint being unmet. Depending on `effect` this may or may not make the Edit invalid.

When a constraint is not met, the effects is specified by `effect`<!-- -->.

<b>Signature:</b>

```typescript
readonly toConstrain: StableRange;
```

### type {#type-PropertySignature}

Marker for which kind of Change this is.

<b>Signature:</b>

```typescript
readonly type: typeof ChangeType.Constraint;
```

</div>
