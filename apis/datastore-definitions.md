{"kind":"Package","title":"@fluidframework/datastore-definitions Package","summary":"This package defines the interfaces required to implement and/or communicate with a data store.","members":{"Interface":{"IChannel":"/docs/apis/datastore-definitions/ichannel","IChannelAttributes":"/docs/apis/datastore-definitions/ichannelattributes","IChannelFactory":"/docs/apis/datastore-definitions/ichannelfactory","IChannelServices":"/docs/apis/datastore-definitions/ichannelservices","IChannelStorageService":"/docs/apis/datastore-definitions/ichannelstorageservice","IDeltaConnection":"/docs/apis/datastore-definitions/ideltaconnection","IDeltaHandler":"/docs/apis/datastore-definitions/ideltahandler","IFluidDataStoreRuntime":"/docs/apis/datastore-definitions/ifluiddatastoreruntime","IFluidDataStoreRuntimeEvents":"/docs/apis/datastore-definitions/ifluiddatastoreruntimeevents"},"TypeAlias":{"Jsonable":"/docs/apis/datastore-definitions#jsonable-TypeAlias","Serializable":"/docs/apis/datastore-definitions#serializable-TypeAlias"}},"package":"@fluidframework/datastore-definitions","unscopedPackageName":"datastore-definitions"}

[//]: # (Do not edit this file. It is automatically generated by API Documenter.)

[Packages](/docs/apis/) &gt; [@fluidframework/datastore-definitions](/docs/apis/datastore-definitions)

This package defines the interfaces required to implement and/or communicate with a data store.

## Interfaces

<table class="table table-striped table-hover interface-list">
<caption>List of interfaces contained in this package</caption>
  <thead>
    <tr>
     <th scope="col">Interface</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href='/docs/apis/datastore-definitions/ichannel'>IChannel</a></td>
      <td></td>
    </tr>
    <tr>
      <td><a href='/docs/apis/datastore-definitions/ichannelattributes'>IChannelAttributes</a></td>
      <td>Represents the attributes of a channel/DDS.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/datastore-definitions/ichannelfactory'>IChannelFactory</a></td>
      <td>Definitions of a channel factory.<!-- -->The runtime must be able to produce "channels" of the correct in-memory object type for the collaborative session. Here "channels" are typically distributed data structures (DDSs).<!-- -->The runtime will consult with a registry of such factories during <a href='https://fluidframework.com/docs/build/containers/'>Container</a> load and when receiving "attach" operations (ops), which indicate a new instance of a channel being introduced to the collaboration session, to produce the appropriate in-memory object.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/datastore-definitions/ichannelservices'>IChannelServices</a></td>
      <td>Storage services to read the objects at a given path using the given delta connection.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/datastore-definitions/ichannelstorageservice'>IChannelStorageService</a></td>
      <td>Storage services to read the objects at a given path.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/datastore-definitions/ideltaconnection'>IDeltaConnection</a></td>
      <td>Interface to represent a connection to a delta notification stream.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/datastore-definitions/ideltahandler'>IDeltaHandler</a></td>
      <td>Handler provided by shared data structure to process requests from the runtime.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/datastore-definitions/ifluiddatastoreruntime'>IFluidDataStoreRuntime</a></td>
      <td>Represents the runtime for the data store. Contains helper functions/state of the data store.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/datastore-definitions/ifluiddatastoreruntimeevents'>IFluidDataStoreRuntimeEvents</a></td>
      <td></td>
    </tr>
  </tbody>
</table>

## Type Aliases

<table class="table table-striped table-hover alias-list">
<caption>List of type aliases contained in this package</caption>
  <thead>
    <tr>
     <th scope="col">Type Alias</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href='/docs/apis/datastore-definitions#jsonable-TypeAlias'>Jsonable</a></td>
      <td>Used to constrain a type <code>T</code> to types that are serializable as JSON. Produces a compile-time error if <code>T</code> contains non-Jsonable members.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/datastore-definitions#serializable-TypeAlias'>Serializable</a></td>
      <td>Used to constrain a type 'T' to types that Fluid can intrinsically serialize. Produces a compile-time error if <code>T</code> contains non-serializable members.</td>
    </tr>
  </tbody>
</table>

<hr><div id=package-details>

## Type Alias Details {#type-aliases-details}

### Jsonable {#jsonable-TypeAlias}

Used to constrain a type `T` to types that are serializable as JSON. Produces a compile-time error if `T` contains non-Jsonable members.

<b>Signature:</b>

```typescript
export declare type Jsonable<T = any, TReplaced = void> = T extends undefined | null | boolean | number | string | TReplaced ? T : Extract<T, Function> extends never ? {
    [K in keyof T]: Extract<K, symbol> extends never ? Jsonable<T[K], TReplaced> : never;
} : never;
```

#### Remarks {#jsonable-TypeAlias-remarks}

Note that this does NOT prevent using of values with non-json compatible data, it only prevents using values with types that include non-json compatible data. This means that one can, for example, pass an a value typed with json compatible interface into this function, that could actually be a class with lots on non-json compatible fields and methods.

Important: `T extends Jsonable<T>` is incorrect (does not even compile). `T extends Jsonable` is also incorrect since `Jsonable` is just `any` and thus applies no constraint at all.

The optional 'TReplaced' parameter may be used to permit additional leaf types to support situations where a `replacer` is used to handle special values (e.g., `Jsonable<{ x: IFluidHandle }, IFluidHandle>`<!-- -->).

Note that `Jsonable<T>` does not protect against the following pitfalls when serializing with JSON.stringify():

- `undefined` properties on objects are omitted (i.e., properties become undefined instead of equal to undefined). - When `undefined` appears as the root object or as an array element it is coerced to `null`<!-- -->. - Non-finite numbers (`NaN`<!-- -->, `+/-Infinity`<!-- -->) are also coerced to `null`<!-- -->. - prototypes and non-enumerable properties are lost.

Also, `Jsonable<T>` does not prevent the construction of circular references.

Using `Jsonable` (with no type parameters) or `Jsonable<any>` is just a type alias for `any` and should not be used if type safety is desired.

#### Example {#jsonable-TypeAlias-example}

Typical usage:

```ts
     function foo<T>(value: Jsonable<T>) { ... }
```

### Serializable {#serializable-TypeAlias}

Used to constrain a type 'T' to types that Fluid can intrinsically serialize. Produces a compile-time error if `T` contains non-serializable members.

<b>Signature:</b>

```typescript
export declare type Serializable<T = any> = Jsonable<T, IFluidHandle>;
```

#### Remarks {#serializable-TypeAlias-remarks}

See Jsonable for caveats regarding serialization of `undefined`<!-- -->, non-finite numbers, and circular references.

Important: `T extends Serializable<T>` is generally incorrect. (Any value of `T` extends the serializable subset of itself.)

#### Example {#serializable-TypeAlias-example}

Typical usage:

```typescript
     function serialize<T>(value: Serializable<T>) { ... }
```


</div>
