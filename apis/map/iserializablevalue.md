{"kind":"Interface","title":"ISerializableValue Interface","summary":"The \\_ready-for-serialization\\_ format of values contained in DDS contents. This allows us to use [ISerializableValue.type](/docs/apis/map/iserializablevalue#type-PropertySignature) to understand whether they're storing a Plain JavaScript object, a [SharedObject](/docs/apis/shared-object-base/sharedobject)<!-- -->, or a value type.","members":{"PropertySignature":{"type":"/docs/apis/map/iserializablevalue#type-PropertySignature","value":"/docs/apis/map/iserializablevalue#value-PropertySignature"}},"package":"@fluidframework/map","unscopedPackageName":"map"}

[//]: # (Do not edit this file. It is automatically generated by API Documenter.)

[Packages](/docs/apis/) &gt; [@fluidframework/map](/docs/apis/map) &gt; [ISerializableValue](/docs/apis/map/iserializablevalue)

{{% callout warning Deprecated %}}
This type is legacy and deprecated.

{{% /callout %}}

The \_ready-for-serialization\_ format of values contained in DDS contents. This allows us to use [ISerializableValue.type](/docs/apis/map/iserializablevalue#type-PropertySignature) to understand whether they're storing a Plain JavaScript object, a [SharedObject](/docs/apis/shared-object-base/sharedobject)<!-- -->, or a value type.

<b>Signature:</b>

```typescript
export interface ISerializableValue 
```

## Remarks

Note that the in-memory equivalent of ISerializableValue is ILocalValue (similarly holding a type, but with the \_in-memory representation\_ of the value instead). An ISerializableValue is what gets passed to JSON.stringify and comes out of JSON.parse. This format is used both for snapshots (loadCore/populate) and ops (set).

If type is Plain, it must be a plain JS object that can survive a JSON.stringify/parse. E.g. a URL object will just get stringified to a URL string and not rehydrate as a URL object on the other side. It may contain members that are ISerializedHandle (the serialized form of a handle).

If type is a value type then it must be amongst the types registered via registerValueType or we won't know how to serialize/deserialize it (we rely on its factory via .load() and .store()). Its value will be type-dependent. If type is Shared, then the in-memory value will just be a reference to the SharedObject. Its value will be a channel ID.

## Properties

<table class="table table-striped table-hover property-list">
<caption>List of properties on this interface</caption>
  <thead>
    <tr>
     <th scope="col">Property</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href='/docs/apis/map/iserializablevalue#type-PropertySignature'>type</a></td>
      <td>string</td>
      <td>A type annotation to help indicate how the value serializes.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/map/iserializablevalue#value-PropertySignature'>value</a></td>
      <td>any</td>
      <td>The JSONable representation of the value.</td>
    </tr>
  </tbody>
</table>

<hr><div id=interface-details>

## Property Details {#properties-details}

### type {#type-PropertySignature}

A type annotation to help indicate how the value serializes.

<b>Signature:</b>

```typescript
type: string;
```

### value {#value-PropertySignature}

The JSONable representation of the value.

<b>Signature:</b>

```typescript
value: any;
```

</div>
