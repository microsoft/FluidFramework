{"kind":"Class","title":"DataProcessingError Class","summary":"DataProcessingError indicates we hit a fatal error while processing incoming data from the Fluid Service. The error will often originate in the dataStore or DDS implementation that is responding to incoming changes. This differs from DataCorruptionError in that this may be a transient error that will not repro in another client or session.","members":{"Property":{"canRetry":"/docs/apis/container-utils/dataprocessingerror#canretry-Property","errorType":"/docs/apis/container-utils/dataprocessingerror#errortype-Property"},"Method":{"create":"/docs/apis/container-utils/dataprocessingerror#create-Method","wrapIfUnrecognized":"/docs/apis/container-utils/dataprocessingerror#wrapifunrecognized-Method"}},"package":"@fluidframework/container-utils","unscopedPackageName":"container-utils"}

[//]: # (Do not edit this file. It is automatically generated by API Documenter.)

[Packages](/docs/apis/) &gt; [@fluidframework/container-utils](/docs/apis/container-utils) &gt; [DataProcessingError](/docs/apis/container-utils/dataprocessingerror)

DataProcessingError indicates we hit a fatal error while processing incoming data from the Fluid Service. The error will often originate in the dataStore or DDS implementation that is responding to incoming changes. This differs from DataCorruptionError in that this may be a transient error that will not repro in another client or session.

<b>Signature:</b>

```typescript
export declare class DataProcessingError extends LoggingError implements IErrorBase, IFluidErrorBase 
```
<b>Extends:</b> [LoggingError](/docs/apis/telemetry-utils/loggingerror)

<b>Implements:</b> IErrorBase, [IFluidErrorBase](/docs/apis/telemetry-utils/ifluiderrorbase)

<b>Implements:</b> IErrorBase, [IFluidErrorBase](/docs/apis/telemetry-utils/ifluiderrorbase)

## Properties

<table class="table table-striped table-hover property-list">
<caption>List of properties on this class</caption>
  <thead>
    <tr>
     <th scope="col">Property</th>
 <th scope="col">Modifiers</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href='/docs/apis/container-utils/dataprocessingerror#canretry-Property'>canRetry</a></td>
      <td></td>
      <td>(not declared)</td>
      <td></td>
    </tr>
    <tr>
      <td><a href='/docs/apis/container-utils/dataprocessingerror#errortype-Property'>errorType</a></td>
      <td></td>
      <td>(not declared)</td>
      <td></td>
    </tr>
  </tbody>
</table>

## Methods

<table class="table table-striped table-hover method-list">
<caption>List of methods on this class</caption>
  <thead>
    <tr>
     <th scope="col">Method</th>
 <th scope="col">Modifiers</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href='/docs/apis/container-utils/dataprocessingerror#create-Method'>create(errorMessage, dataProcessingCodepath, sequencedMessage, props)</a></td>
      <td><code>static</code></td>
      <td>Create a new DataProcessingError detected and raised with the FF code</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/container-utils/dataprocessingerror#wrapifunrecognized-Method'>wrapIfUnrecognized(originalError, dataProcessingCodepath, sequencedMessage)</a></td>
      <td><code>static</code></td>
      <td>Wrap the given error in a DataProcessingError, unless the error is already of a known type. In either case, the error will have some relevant properties added for telemetry We wrap conditionally since known error types represent well-understood failure modes, and ideally one day we will move away from throwing these errors but rather we'll return them. But an unrecognized error needs to be classified as DataProcessingError.</td>
    </tr>
  </tbody>
</table>

<hr><div id=class-details>

## Property Details {#properties-details}

### canRetry {#canretry-Property}

<b>Signature:</b>

```typescript
readonly canRetry = false;
```

### errorType {#errortype-Property}

<b>Signature:</b>

```typescript
readonly errorType = ContainerErrorType.dataProcessingError;
```

## Method Details {#methods-details}

### create {#create-Method}

Create a new DataProcessingError detected and raised with the FF code

<b>Signature:</b>

```typescript
static create(errorMessage: string, dataProcessingCodepath: string, sequencedMessage?: ISequencedDocumentMessage, props?: ITelemetryProperties): IFluidErrorBase;
```

#### Parameters {#create-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>errorMessage</td>
      <td>string</td>
      <td></td>
    </tr>
    <tr>
      <td>dataProcessingCodepath</td>
      <td>string</td>
      <td></td>
    </tr>
    <tr>
      <td>sequencedMessage</td>
      <td><a href='/docs/apis/protocol-definitions/isequenceddocumentmessage'>ISequencedDocumentMessage</a></td>
      <td></td>
    </tr>
    <tr>
      <td>props</td>
      <td><a href='/docs/apis/common-definitions/itelemetryproperties'>ITelemetryProperties</a></td>
      <td></td>
    </tr>
  </tbody>
</table>

### wrapIfUnrecognized {#wrapifunrecognized-Method}

Wrap the given error in a DataProcessingError, unless the error is already of a known type. In either case, the error will have some relevant properties added for telemetry We wrap conditionally since known error types represent well-understood failure modes, and ideally one day we will move away from throwing these errors but rather we'll return them. But an unrecognized error needs to be classified as DataProcessingError.

<b>Signature:</b>

```typescript
static wrapIfUnrecognized(originalError: any, dataProcessingCodepath: string, sequencedMessage?: ISequencedDocumentMessage): IFluidErrorBase;
```

#### Parameters {#wrapifunrecognized-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>originalError</td>
      <td>any</td>
      <td>error to be converted</td>
    </tr>
    <tr>
      <td>dataProcessingCodepath</td>
      <td>string</td>
      <td>which codepath failed while processing data</td>
    </tr>
    <tr>
      <td>sequencedMessage</td>
      <td><a href='/docs/apis/protocol-definitions/isequenceddocumentmessage'>ISequencedDocumentMessage</a></td>
      <td>Sequenced message to include info about via telemetry props</td>
    </tr>
  </tbody>
</table>

#### Returns {#wrapifunrecognized-Method-returns}


Either a new DataProcessingError, or (if wrapping is deemed unnecessary) the given error

<b>Return type(s):</b> [IFluidErrorBase](/docs/apis/telemetry-utils/ifluiderrorbase)


</div>
