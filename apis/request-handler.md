{"kind":"Package","title":"@fluidframework/request-handler Package","members":{"Function":{"buildRuntimeRequestHandler":"/docs/apis/request-handler#buildruntimerequesthandler-Function","handleFromLegacyUri":"/docs/apis/request-handler#handlefromlegacyuri-Function"},"Variable":{"createFluidObjectResponse":"/docs/apis/request-handler#createfluidobjectresponse-Variable","rootDataStoreRequestHandler":"/docs/apis/request-handler#rootdatastorerequesthandler-Variable"},"TypeAlias":{"RuntimeRequestHandler":"/docs/apis/request-handler#runtimerequesthandler-TypeAlias"},"Class":{"RuntimeRequestHandlerBuilder":"/docs/apis/request-handler/runtimerequesthandlerbuilder"}},"package":"@fluidframework/request-handler","unscopedPackageName":"request-handler"}

[//]: # (Do not edit this file. It is automatically generated by API Documenter.)

[Packages](/docs/apis/) &gt; [@fluidframework/request-handler](/docs/apis/request-handler)

## Classes

<table class="table table-striped table-hover class-list">
<caption>List of classes contained in this package</caption>
  <thead>
    <tr>
     <th scope="col">Class</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href='/docs/apis/request-handler/runtimerequesthandlerbuilder'>RuntimeRequestHandlerBuilder</a></td>
      <td>The RuntimeRequestHandlerBuilder creates a runtime request handler based on request handlers. The provided handlers sequentially applied until one is able to satisfy the request.</td>
    </tr>
  </tbody>
</table>

## Functions

<table class="table table-striped table-hover function-list">
<caption>List of functions contained in this package</caption>
  <thead>
    <tr>
     <th scope="col">Function</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href='/docs/apis/request-handler#buildruntimerequesthandler-Function'>buildRuntimeRequestHandler(handlers)</a></td>
      <td></td>
    </tr>
    <tr>
      <td><a href='/docs/apis/request-handler#handlefromlegacyuri-Function'>handleFromLegacyUri(uri, runtime)</a></td>
      <td></td>
    </tr>
  </tbody>
</table>

## Variables

<table class="table table-striped table-hover variable-list">
<caption>List of variables contained in this package</caption>
  <thead>
    <tr>
     <th scope="col">Variable</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href='/docs/apis/request-handler#createfluidobjectresponse-Variable'>createFluidObjectResponse</a></td>
      <td></td>
    </tr>
    <tr>
      <td><a href='/docs/apis/request-handler#rootdatastorerequesthandler-Variable'>rootDataStoreRequestHandler</a></td>
      <td>A request handler to expose access to all root data stores in the container by id.</td>
    </tr>
  </tbody>
</table>

## Type Aliases

<table class="table table-striped table-hover alias-list">
<caption>List of type aliases contained in this package</caption>
  <thead>
    <tr>
     <th scope="col">Type Alias</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href='/docs/apis/request-handler#runtimerequesthandler-TypeAlias'>RuntimeRequestHandler</a></td>
      <td>A request handler for the container runtime. Each handler should handle a specific request, and return undefined if it does not apply. These handlers are called in series, so there may be other handlers before or after. A handler should only return error if the request is for a route the handler owns, and there is a problem with the route, or fulling the specific request.</td>
    </tr>
  </tbody>
</table>

<hr><div id=package-details>

## Function Details {#functions-details}

### buildRuntimeRequestHandler {#buildruntimerequesthandler-Function}

<b>Signature:</b>

```typescript
export declare function buildRuntimeRequestHandler(...handlers: RuntimeRequestHandler[]): (request: IRequest, runtime: IContainerRuntime) => Promise<IResponse>;
```

#### Parameters {#buildruntimerequesthandler-Function-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>handlers</td>
      <td><a href='/docs/apis/request-handler#runtimerequesthandler-TypeAlias'>RuntimeRequestHandler</a>[]</td>
      <td></td>
    </tr>
  </tbody>
</table>

### handleFromLegacyUri {#handlefromlegacyuri-Function}

<b>Signature:</b>

```typescript
export declare function handleFromLegacyUri<T = FluidObject & IFluidLoadable>(uri: string, runtime: IContainerRuntimeBase): IFluidHandle<T>;
```

#### Parameters {#handlefromlegacyuri-Function-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>uri</td>
      <td>string</td>
      <td></td>
    </tr>
    <tr>
      <td>runtime</td>
      <td><a href='/docs/apis/runtime-definitions/icontainerruntimebase'>IContainerRuntimeBase</a></td>
      <td></td>
    </tr>
  </tbody>
</table>


## Variable Details {#variables-details}

### createFluidObjectResponse {#createfluidobjectresponse-Variable}

<b>Signature:</b>

```typescript
createFluidObjectResponse: (fluidObject: FluidObject) => {
    status: 200;
    mimeType: "fluid/object";
    value: FluidObject;
}
```

### rootDataStoreRequestHandler {#rootdatastorerequesthandler-Variable}

A request handler to expose access to all root data stores in the container by id.

<b>Signature:</b>

```typescript
rootDataStoreRequestHandler: (request: IRequest, runtime: IContainerRuntime) => Promise<IResponse | undefined>
```

## Type Alias Details {#type-aliases-details}

### RuntimeRequestHandler {#runtimerequesthandler-TypeAlias}

A request handler for the container runtime. Each handler should handle a specific request, and return undefined if it does not apply. These handlers are called in series, so there may be other handlers before or after. A handler should only return error if the request is for a route the handler owns, and there is a problem with the route, or fulling the specific request.

<b>Signature:</b>

```typescript
export declare type RuntimeRequestHandler = (request: RequestParser, runtime: IContainerRuntime) => Promise<IResponse | undefined>;
```

</div>
