{"kind":"Class","title":"SharedObjectCore Class","summary":"Base class from which all shared objects derive","members":{"Constructor":{"(constructor)":"/docs/apis/shared-object-base/sharedobjectcore#_constructor_-Constructor"},"Method":{"applyStashedOp":"/docs/apis/shared-object-base/sharedobjectcore#applystashedop-Method","bindToContext":"/docs/apis/shared-object-base/sharedobjectcore#bindtocontext-Method","connect":"/docs/apis/shared-object-base/sharedobjectcore#connect-Method","didAttach":"/docs/apis/shared-object-base/sharedobjectcore#didattach-Method","dirty":"/docs/apis/shared-object-base/sharedobjectcore#dirty-Method","getAttachSummary":"/docs/apis/shared-object-base/sharedobjectcore#getattachsummary-Method","getGCData":"/docs/apis/shared-object-base/sharedobjectcore#getgcdata-Method","handleDecoded":"/docs/apis/shared-object-base/sharedobjectcore#handledecoded-Method","initializeLocal":"/docs/apis/shared-object-base/sharedobjectcore#initializelocal-Method","initializeLocalCore":"/docs/apis/shared-object-base/sharedobjectcore#initializelocalcore-Method","isAttached":"/docs/apis/shared-object-base/sharedobjectcore#isattached-Method","load":"/docs/apis/shared-object-base/sharedobjectcore#load-Method","loadCore":"/docs/apis/shared-object-base/sharedobjectcore#loadcore-Method","newAckBasedPromise":"/docs/apis/shared-object-base/sharedobjectcore#newackbasedpromise-Method","onConnect":"/docs/apis/shared-object-base/sharedobjectcore#onconnect-Method","onDisconnect":"/docs/apis/shared-object-base/sharedobjectcore#ondisconnect-Method","processCore":"/docs/apis/shared-object-base/sharedobjectcore#processcore-Method","reSubmitCore":"/docs/apis/shared-object-base/sharedobjectcore#resubmitcore-Method","rollback":"/docs/apis/shared-object-base/sharedobjectcore#rollback-Method","submitLocalMessage":"/docs/apis/shared-object-base/sharedobjectcore#submitlocalmessage-Method","summarize":"/docs/apis/shared-object-base/sharedobjectcore#summarize-Method"},"Property":{"attributes":"/docs/apis/shared-object-base/sharedobjectcore#attributes-Property","connected":"/docs/apis/shared-object-base/sharedobjectcore#connected-Property","handle":"/docs/apis/shared-object-base/sharedobjectcore#handle-Property","id":"/docs/apis/shared-object-base/sharedobjectcore#id-Property","IFluidLoadable":"/docs/apis/shared-object-base/sharedobjectcore#ifluidloadable-Property","logger":"/docs/apis/shared-object-base/sharedobjectcore#logger-Property","runtime":"/docs/apis/shared-object-base/sharedobjectcore#runtime-Property"}},"package":"@fluidframework/shared-object-base","unscopedPackageName":"shared-object-base"}

[//]: # (Do not edit this file. It is automatically generated by API Documenter.)

[Packages](/docs/apis/) &gt; [@fluidframework/shared-object-base](/docs/apis/shared-object-base) &gt; [SharedObjectCore](/docs/apis/shared-object-base/sharedobjectcore)

Base class from which all shared objects derive

<b>Signature:</b>

```typescript
export declare abstract class SharedObjectCore<TEvent extends ISharedObjectEvents = ISharedObjectEvents> extends EventEmitterWithErrorHandling<TEvent> implements ISharedObject<TEvent> 
```
<b>Extends:</b> [EventEmitterWithErrorHandling](/docs/apis/telemetry-utils/eventemitterwitherrorhandling)

<b>Implements:</b> [ISharedObject](/docs/apis/shared-object-base/isharedobject)

<b>Type parameters:</b> 

<b>TEvent</b> --

## Constructors

<table class="table table-striped table-hover constructor-list">
<caption>List of constructors for this class</caption>
  <thead>
    <tr>
     <th scope="col">Constructor</th>
 <th scope="col">Modifiers</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#_constructor_-Constructor'>(constructor)(id, runtime, attributes)</a></td>
      <td></td>
      <td>Constructs a new instance of the <code>SharedObjectCore</code> class</td>
    </tr>
  </tbody>
</table>

## Properties

<table class="table table-striped table-hover property-list">
<caption>List of properties on this class</caption>
  <thead>
    <tr>
     <th scope="col">Property</th>
 <th scope="col">Modifiers</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#attributes-Property'>attributes</a></td>
      <td></td>
      <td><a href='/docs/apis/datastore-definitions/ichannelattributes'>IChannelAttributes</a></td>
      <td></td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#connected-Property'>connected</a></td>
      <td></td>
      <td>boolean</td>
      <td>Gets the connection state</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#handle-Property'>handle</a></td>
      <td></td>
      <td><a href='/docs/apis/core-interfaces/ifluidhandle'>IFluidHandle</a></td>
      <td>The handle referring to this SharedObject</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#id-Property'>id</a></td>
      <td></td>
      <td>string</td>
      <td></td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#ifluidloadable-Property'>IFluidLoadable</a></td>
      <td></td>
      <td>this</td>
      <td></td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#logger-Property'>logger</a></td>
      <td></td>
      <td><a href='/docs/apis/common-definitions/itelemetrylogger'>ITelemetryLogger</a></td>
      <td>Telemetry logger for the shared object</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#runtime-Property'>runtime</a></td>
      <td></td>
      <td><a href='/docs/apis/datastore-definitions/ifluiddatastoreruntime'>IFluidDataStoreRuntime</a></td>
      <td></td>
    </tr>
  </tbody>
</table>

## Methods

<table class="table table-striped table-hover method-list">
<caption>List of methods on this class</caption>
  <thead>
    <tr>
     <th scope="col">Method</th>
 <th scope="col">Modifiers</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#applystashedop-Method'>applyStashedOp(content)</a></td>
      <td></td>
      <td>Apply changes from an op. Used when rehydrating an attached container with pending changes. This prepares the SharedObject for seeing an ACK for the op or resubmitting the op upon reconnection.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#bindtocontext-Method'>bindToContext()</a></td>
      <td></td>
      <td>Binds the given shared object to its containing data store runtime, causing it to attach once the runtime attaches.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#connect-Method'>connect(services)</a></td>
      <td></td>
      <td>Enables the channel to send and receive ops.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#didattach-Method'>didAttach()</a></td>
      <td></td>
      <td>Allows the distributive data type the ability to perform custom processing once an attach has happened. Also called after non-local data type get loaded.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#dirty-Method'>dirty()</a></td>
      <td></td>
      <td>Marks this object as dirty so that it is part of the next summary. It is called by a SharedSummaryBlock that want to be part of summary but does not generate ops.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#getattachsummary-Method'>getAttachSummary(fullTree, trackState, telemetryContext)</a></td>
      <td></td>
      <td>Generates summary of the channel synchronously. It is called when an <code>attach message</code> for a local channel is generated. In other words, when the channel is being attached to make it visible to other clients. Note: Since Attach Summary is generated for local channels when making them visible to remote clients, they don't have any previous summaries to compare against. For this reason, The attach summary cannot contain summary handles (paths to sub-trees or blobs). It can, however, contain ISummaryAttachment (handles to blobs uploaded async via the blob manager).</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#getgcdata-Method'>getGCData(fullGC)</a></td>
      <td></td>
      <td>Returns the GC data for this shared object. It contains a list of GC nodes that contains references to other GC nodes.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#handledecoded-Method'>handleDecoded(decodedHandle)</a></td>
      <td></td>
      <td>Called when a handle is decoded by this object. A handle in the object's data represents an outbound reference to another object in the container.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#initializelocal-Method'>initializeLocal()</a></td>
      <td></td>
      <td>Initializes the object as a local, non-shared object. This object can become shared after it is attached to the document.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#initializelocalcore-Method'>initializeLocalCore()</a></td>
      <td></td>
      <td>Allows the distributed data type to perform custom local loading.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#isattached-Method'>isAttached()</a></td>
      <td></td>
      <td>Checks if the channel is attached to storage.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#load-Method'>load(services)</a></td>
      <td></td>
      <td>A shared object, after construction, can either be loaded in the case that it is already part of a shared document. Or later attached if it is being newly added.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#loadcore-Method'>loadCore(services)</a></td>
      <td></td>
      <td>Allows the distributed data type to perform custom loading</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#newackbasedpromise-Method'>newAckBasedPromise(executor)</a></td>
      <td></td>
      <td>Promises that are waiting for an ack from the server before resolving should use this instead of new Promise. It ensures that if something changes that will interrupt that ack (e.g. the FluidDataStoreRuntime disposes), the Promise will reject. If runtime is disposed when this call is made, executor is not run and promise is rejected right away.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#onconnect-Method'>onConnect()</a></td>
      <td></td>
      <td>Called when the object has fully connected to the delta stream Default implementation for DDS, override if different behavior is required.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#ondisconnect-Method'>onDisconnect()</a></td>
      <td></td>
      <td>Called when the object has disconnected from the delta stream.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#processcore-Method'>processCore(message, local, localOpMetadata)</a></td>
      <td></td>
      <td>Derived classes must override this to do custom processing on a remote message.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#resubmitcore-Method'>reSubmitCore(content, localOpMetadata)</a></td>
      <td></td>
      <td>Called when a message has to be resubmitted. This typically happens after a reconnection for unacked messages. The default implementation here is to resubmit the same message. The client can override if different behavior is required. It can choose to resubmit the same message, submit different / multiple messages or not submit anything at all.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#rollback-Method'>rollback(content, localOpMetadata)</a></td>
      <td></td>
      <td>Revert an op</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#submitlocalmessage-Method'>submitLocalMessage(content, localOpMetadata)</a></td>
      <td></td>
      <td>Submits a message by the local client to the runtime.</td>
    </tr>
    <tr>
      <td><a href='/docs/apis/shared-object-base/sharedobjectcore#summarize-Method'>summarize(fullTree, trackState, telemetryContext)</a></td>
      <td></td>
      <td>Generates summary of the channel asynchronously. This should not be called where the channel can be modified while summarization is in progress.</td>
    </tr>
  </tbody>
</table>

<hr><div id=class-details>

## Constructor Details {#constructors-details}

### SharedObjectCore.(constructor) {#_constructor_-Constructor}

Constructs a new instance of the `SharedObjectCore` class

<b>Signature:</b>

```typescript
constructor(id: string, runtime: IFluidDataStoreRuntime, attributes: IChannelAttributes);
```

#### Parameters {#_constructor_-Constructor-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>string</td>
      <td>The id of the shared object</td>
    </tr>
    <tr>
      <td>runtime</td>
      <td><a href='/docs/apis/datastore-definitions/ifluiddatastoreruntime'>IFluidDataStoreRuntime</a></td>
      <td>The IFluidDataStoreRuntime which contains the shared object</td>
    </tr>
    <tr>
      <td>attributes</td>
      <td><a href='/docs/apis/datastore-definitions/ichannelattributes'>IChannelAttributes</a></td>
      <td>Attributes of the shared object</td>
    </tr>
  </tbody>
</table>


## Property Details {#properties-details}

### attributes {#attributes-Property}

<b>Signature:</b>

```typescript
readonly attributes: IChannelAttributes;
```

### connected {#connected-Property}

Gets the connection state

<b>Signature:</b>

```typescript
get connected(): boolean;
```

### handle {#handle-Property}

The handle referring to this SharedObject

<b>Signature:</b>

```typescript
readonly handle: IFluidHandle;
```

### id {#id-Property}

<b>Signature:</b>

```typescript
id: string;
```

### IFluidLoadable {#ifluidloadable-Property}

<b>Signature:</b>

```typescript
get IFluidLoadable(): this;
```

### logger {#logger-Property}

Telemetry logger for the shared object

<b>Signature:</b>

```typescript
protected readonly logger: ITelemetryLogger;
```

### runtime {#runtime-Property}

<b>Signature:</b>

```typescript
protected runtime: IFluidDataStoreRuntime;
```

## Method Details {#methods-details}

### applyStashedOp {#applystashedop-Method}

Apply changes from an op. Used when rehydrating an attached container with pending changes. This prepares the SharedObject for seeing an ACK for the op or resubmitting the op upon reconnection.

<b>Signature:</b>

```typescript
protected abstract applyStashedOp(content: any): unknown;
```

#### Parameters {#applystashedop-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>content</td>
      <td>any</td>
      <td>Contents of a stashed op.</td>
    </tr>
  </tbody>
</table>

#### Returns {#applystashedop-Method-returns}


localMetadata of the op, to be passed to process() or resubmit() when the op is ACKed or resubmitted, respectively

<b>Return type(s):</b> unknown

### bindToContext {#bindtocontext-Method}

Binds the given shared object to its containing data store runtime, causing it to attach once the runtime attaches.

<b>Signature:</b>

```typescript
bindToContext(): void;
```

### connect {#connect-Method}

Enables the channel to send and receive ops.

<b>Signature:</b>

```typescript
connect(services: IChannelServices): void;
```

#### Parameters {#connect-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>services</td>
      <td><a href='/docs/apis/datastore-definitions/ichannelservices'>IChannelServices</a></td>
      <td>Services to connect to</td>
    </tr>
  </tbody>
</table>

### didAttach {#didattach-Method}

Allows the distributive data type the ability to perform custom processing once an attach has happened. Also called after non-local data type get loaded.

<b>Signature:</b>

```typescript
protected didAttach(): void;
```

### dirty {#dirty-Method}

Marks this object as dirty so that it is part of the next summary. It is called by a SharedSummaryBlock that want to be part of summary but does not generate ops.

<b>Signature:</b>

```typescript
protected dirty(): void;
```

### getAttachSummary {#getattachsummary-Method}

Generates summary of the channel synchronously. It is called when an `attach message` for a local channel is generated. In other words, when the channel is being attached to make it visible to other clients. Note: Since Attach Summary is generated for local channels when making them visible to remote clients, they don't have any previous summaries to compare against. For this reason, The attach summary cannot contain summary handles (paths to sub-trees or blobs). It can, however, contain ISummaryAttachment (handles to blobs uploaded async via the blob manager).

<b>Signature:</b>

```typescript
abstract getAttachSummary(fullTree?: boolean, trackState?: boolean, telemetryContext?: ITelemetryContext): ISummaryTreeWithStats;
```

#### Parameters {#getattachsummary-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>fullTree</td>
      <td>boolean</td>
      <td>flag indicating whether the attempt should generate a full summary tree without any handles for unchanged subtrees.</td>
    </tr>
    <tr>
      <td>trackState</td>
      <td>boolean</td>
      <td>optimization for tracking state of objects across summaries. If the state of an object did not change since last successful summary, an ISummaryHandle can be used instead of re-summarizing it. If this is false, the expectation is that you should never send an ISummaryHandle since you are not expected to track state. Note: The goal is to remove the trackState and automatically decided whether the handles will be used or not: https://github.com/microsoft/FluidFramework/issues/10455</td>
    </tr>
    <tr>
      <td>telemetryContext</td>
      <td><a href='/docs/apis/runtime-definitions/itelemetrycontext'>ITelemetryContext</a></td>
      <td></td>
    </tr>
  </tbody>
</table>

#### Returns {#getattachsummary-Method-returns}


A summary capturing the current state of the channel.

<b>Return type(s):</b> [ISummaryTreeWithStats](/docs/apis/runtime-definitions/isummarytreewithstats)

### getGCData {#getgcdata-Method}

Returns the GC data for this shared object. It contains a list of GC nodes that contains references to other GC nodes.

<b>Signature:</b>

```typescript
abstract getGCData(fullGC?: boolean): IGarbageCollectionData;
```

#### Parameters {#getgcdata-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>fullGC</td>
      <td>boolean</td>
      <td>true to bypass optimizations and force full generation of GC data.</td>
    </tr>
  </tbody>
</table>

### handleDecoded {#handledecoded-Method}

Called when a handle is decoded by this object. A handle in the object's data represents an outbound reference to another object in the container.

<b>Signature:</b>

```typescript
protected handleDecoded(decodedHandle: IFluidHandle): void;
```

#### Parameters {#handledecoded-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>decodedHandle</td>
      <td><a href='/docs/apis/core-interfaces/ifluidhandle'>IFluidHandle</a></td>
      <td>The handle of the Fluid object that is decoded.</td>
    </tr>
  </tbody>
</table>

### initializeLocal {#initializelocal-Method}

Initializes the object as a local, non-shared object. This object can become shared after it is attached to the document.

<b>Signature:</b>

```typescript
initializeLocal(): void;
```

### initializeLocalCore {#initializelocalcore-Method}

Allows the distributed data type to perform custom local loading.

<b>Signature:</b>

```typescript
protected initializeLocalCore(): void;
```

### isAttached {#isattached-Method}

Checks if the channel is attached to storage.

<b>Signature:</b>

```typescript
isAttached(): boolean;
```

#### Returns {#isattached-Method-returns}


True iff the channel is attached.

<b>Return type(s):</b> boolean

### load {#load-Method}

A shared object, after construction, can either be loaded in the case that it is already part of a shared document. Or later attached if it is being newly added.

<b>Signature:</b>

```typescript
load(services: IChannelServices): Promise<void>;
```

#### Parameters {#load-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>services</td>
      <td><a href='/docs/apis/datastore-definitions/ichannelservices'>IChannelServices</a></td>
      <td>Services used by the shared object</td>
    </tr>
  </tbody>
</table>

### loadCore {#loadcore-Method}

Allows the distributed data type to perform custom loading

<b>Signature:</b>

```typescript
protected abstract loadCore(services: IChannelStorageService): Promise<void>;
```

#### Parameters {#loadcore-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>services</td>
      <td><a href='/docs/apis/datastore-definitions/ichannelstorageservice'>IChannelStorageService</a></td>
      <td>Storage used by the shared object</td>
    </tr>
  </tbody>
</table>

### newAckBasedPromise {#newackbasedpromise-Method}

Promises that are waiting for an ack from the server before resolving should use this instead of new Promise. It ensures that if something changes that will interrupt that ack (e.g. the FluidDataStoreRuntime disposes), the Promise will reject. If runtime is disposed when this call is made, executor is not run and promise is rejected right away.

<b>Signature:</b>

```typescript
protected newAckBasedPromise<T>(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;
```

#### Parameters {#newackbasedpromise-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>executor</td>
      <td>(resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void</td>
      <td></td>
    </tr>
  </tbody>
</table>

### onConnect {#onconnect-Method}

Called when the object has fully connected to the delta stream Default implementation for DDS, override if different behavior is required.

<b>Signature:</b>

```typescript
protected onConnect(): void;
```

### onDisconnect {#ondisconnect-Method}

Called when the object has disconnected from the delta stream.

<b>Signature:</b>

```typescript
protected abstract onDisconnect(): any;
```

### processCore {#processcore-Method}

Derived classes must override this to do custom processing on a remote message.

<b>Signature:</b>

```typescript
protected abstract processCore(message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown): any;
```

#### Parameters {#processcore-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>message</td>
      <td><a href='/docs/apis/protocol-definitions/isequenceddocumentmessage'>ISequencedDocumentMessage</a></td>
      <td>The message to process</td>
    </tr>
    <tr>
      <td>local</td>
      <td>boolean</td>
      <td>True if the shared object is local</td>
    </tr>
    <tr>
      <td>localOpMetadata</td>
      <td>unknown</td>
      <td>For local client messages, this is the metadata that was submitted with the message. For messages from a remote client, this will be undefined.</td>
    </tr>
  </tbody>
</table>

### reSubmitCore {#resubmitcore-Method}

Called when a message has to be resubmitted. This typically happens after a reconnection for unacked messages. The default implementation here is to resubmit the same message. The client can override if different behavior is required. It can choose to resubmit the same message, submit different / multiple messages or not submit anything at all.

<b>Signature:</b>

```typescript
protected reSubmitCore(content: any, localOpMetadata: unknown): void;
```

#### Parameters {#resubmitcore-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>content</td>
      <td>any</td>
      <td>The content of the original message.</td>
    </tr>
    <tr>
      <td>localOpMetadata</td>
      <td>unknown</td>
      <td>The local metadata associated with the original message.</td>
    </tr>
  </tbody>
</table>

### rollback {#rollback-Method}

Revert an op

<b>Signature:</b>

```typescript
protected rollback(content: any, localOpMetadata: unknown): void;
```

#### Parameters {#rollback-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>content</td>
      <td>any</td>
      <td></td>
    </tr>
    <tr>
      <td>localOpMetadata</td>
      <td>unknown</td>
      <td></td>
    </tr>
  </tbody>
</table>

### submitLocalMessage {#submitlocalmessage-Method}

Submits a message by the local client to the runtime.

<b>Signature:</b>

```typescript
protected submitLocalMessage(content: any, localOpMetadata?: unknown): void;
```

#### Parameters {#submitlocalmessage-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>content</td>
      <td>any</td>
      <td>Content of the message</td>
    </tr>
    <tr>
      <td>localOpMetadata</td>
      <td>unknown</td>
      <td>The local metadata associated with the message. This is kept locally by the runtime and not sent to the server. This will be sent back when this message is received back from the server. This is also sent if we are asked to resubmit the message.</td>
    </tr>
  </tbody>
</table>

### summarize {#summarize-Method}

Generates summary of the channel asynchronously. This should not be called where the channel can be modified while summarization is in progress.

<b>Signature:</b>

```typescript
abstract summarize(fullTree?: boolean, trackState?: boolean, telemetryContext?: ITelemetryContext): Promise<ISummaryTreeWithStats>;
```

#### Parameters {#summarize-Method-parameters}


<table class="table table-striped table-hover param-list">
<caption>List of parameters</caption>
  <thead>
    <tr>
     <th scope="col">Parameter</th>
 <th scope="col">Type</th>
 <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>fullTree</td>
      <td>boolean</td>
      <td>flag indicating whether the attempt should generate a full summary tree without any handles for unchanged subtrees. It is only set to true when generating a summary from the entire container.</td>
    </tr>
    <tr>
      <td>trackState</td>
      <td>boolean</td>
      <td>This tells whether we should track state from this summary.</td>
    </tr>
    <tr>
      <td>telemetryContext</td>
      <td><a href='/docs/apis/runtime-definitions/itelemetrycontext'>ITelemetryContext</a></td>
      <td></td>
    </tr>
  </tbody>
</table>

#### Returns {#summarize-Method-returns}


A summary capturing the current state of the channel.

<b>Return type(s):</b> Promise&lt;[ISummaryTreeWithStats](/docs/apis/runtime-definitions/isummarytreewithstats)<!-- -->&gt;


</div>
