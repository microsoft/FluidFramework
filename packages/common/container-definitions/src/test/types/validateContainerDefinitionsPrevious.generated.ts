/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */
import type * as old from "@fluidframework/container-definitions-previous";
import type * as current from "../../index";


// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_AttachState": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_AttachState():
    TypeOnly<old.AttachState>;
declare function use_current_EnumDeclaration_AttachState(
    use: TypeOnly<current.AttachState>): void;
use_current_EnumDeclaration_AttachState(
    get_old_EnumDeclaration_AttachState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_AttachState": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_AttachState():
    TypeOnly<current.AttachState>;
declare function use_old_EnumDeclaration_AttachState(
    use: TypeOnly<old.AttachState>): void;
use_old_EnumDeclaration_AttachState(
    get_current_EnumDeclaration_AttachState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConnectionState():
    TypeOnly<old.ConnectionState>;
declare function use_current_TypeAliasDeclaration_ConnectionState(
    use: TypeOnly<current.ConnectionState>): void;
use_current_TypeAliasDeclaration_ConnectionState(
    get_old_TypeAliasDeclaration_ConnectionState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConnectionState():
    TypeOnly<current.ConnectionState>;
declare function use_old_TypeAliasDeclaration_ConnectionState(
    use: TypeOnly<old.ConnectionState>): void;
use_old_TypeAliasDeclaration_ConnectionState(
    get_current_TypeAliasDeclaration_ConnectionState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.CatchingUp": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConnectionState_CatchingUp():
    TypeOnly<old.ConnectionState.CatchingUp>;
declare function use_current_TypeAliasDeclaration_ConnectionState_CatchingUp(
    use: TypeOnly<current.ConnectionState.CatchingUp>): void;
use_current_TypeAliasDeclaration_ConnectionState_CatchingUp(
    get_old_TypeAliasDeclaration_ConnectionState_CatchingUp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.CatchingUp": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConnectionState_CatchingUp():
    TypeOnly<current.ConnectionState.CatchingUp>;
declare function use_old_TypeAliasDeclaration_ConnectionState_CatchingUp(
    use: TypeOnly<old.ConnectionState.CatchingUp>): void;
use_old_TypeAliasDeclaration_ConnectionState_CatchingUp(
    get_current_TypeAliasDeclaration_ConnectionState_CatchingUp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.Connected": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConnectionState_Connected():
    TypeOnly<old.ConnectionState.Connected>;
declare function use_current_TypeAliasDeclaration_ConnectionState_Connected(
    use: TypeOnly<current.ConnectionState.Connected>): void;
use_current_TypeAliasDeclaration_ConnectionState_Connected(
    get_old_TypeAliasDeclaration_ConnectionState_Connected());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.Connected": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConnectionState_Connected():
    TypeOnly<current.ConnectionState.Connected>;
declare function use_old_TypeAliasDeclaration_ConnectionState_Connected(
    use: TypeOnly<old.ConnectionState.Connected>): void;
use_old_TypeAliasDeclaration_ConnectionState_Connected(
    get_current_TypeAliasDeclaration_ConnectionState_Connected());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.Disconnected": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConnectionState_Disconnected():
    TypeOnly<old.ConnectionState.Disconnected>;
declare function use_current_TypeAliasDeclaration_ConnectionState_Disconnected(
    use: TypeOnly<current.ConnectionState.Disconnected>): void;
use_current_TypeAliasDeclaration_ConnectionState_Disconnected(
    get_old_TypeAliasDeclaration_ConnectionState_Disconnected());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.Disconnected": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConnectionState_Disconnected():
    TypeOnly<current.ConnectionState.Disconnected>;
declare function use_old_TypeAliasDeclaration_ConnectionState_Disconnected(
    use: TypeOnly<old.ConnectionState.Disconnected>): void;
use_old_TypeAliasDeclaration_ConnectionState_Disconnected(
    get_current_TypeAliasDeclaration_ConnectionState_Disconnected());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.EstablishingConnection": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConnectionState_EstablishingConnection():
    TypeOnly<old.ConnectionState.EstablishingConnection>;
declare function use_current_TypeAliasDeclaration_ConnectionState_EstablishingConnection(
    use: TypeOnly<current.ConnectionState.EstablishingConnection>): void;
use_current_TypeAliasDeclaration_ConnectionState_EstablishingConnection(
    get_old_TypeAliasDeclaration_ConnectionState_EstablishingConnection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.EstablishingConnection": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConnectionState_EstablishingConnection():
    TypeOnly<current.ConnectionState.EstablishingConnection>;
declare function use_old_TypeAliasDeclaration_ConnectionState_EstablishingConnection(
    use: TypeOnly<old.ConnectionState.EstablishingConnection>): void;
use_old_TypeAliasDeclaration_ConnectionState_EstablishingConnection(
    get_current_TypeAliasDeclaration_ConnectionState_EstablishingConnection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ContainerErrorType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_ContainerErrorType():
    TypeOnly<old.ContainerErrorType>;
declare function use_current_EnumDeclaration_ContainerErrorType(
    use: TypeOnly<current.ContainerErrorType>): void;
use_current_EnumDeclaration_ContainerErrorType(
    get_old_EnumDeclaration_ContainerErrorType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ContainerErrorType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_ContainerErrorType():
    TypeOnly<current.ContainerErrorType>;
declare function use_old_EnumDeclaration_ContainerErrorType(
    use: TypeOnly<old.ContainerErrorType>): void;
use_old_EnumDeclaration_ContainerErrorType(
    get_current_EnumDeclaration_ContainerErrorType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ContainerErrorTypes": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_ContainerErrorTypes():
    TypeOnly<typeof old.ContainerErrorTypes>;
declare function use_current_VariableDeclaration_ContainerErrorTypes(
    use: TypeOnly<typeof current.ContainerErrorTypes>): void;
use_current_VariableDeclaration_ContainerErrorTypes(
    get_old_VariableDeclaration_ContainerErrorTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ContainerErrorTypes": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_ContainerErrorTypes():
    TypeOnly<typeof current.ContainerErrorTypes>;
declare function use_old_VariableDeclaration_ContainerErrorTypes(
    use: TypeOnly<typeof old.ContainerErrorTypes>): void;
use_old_VariableDeclaration_ContainerErrorTypes(
    get_current_VariableDeclaration_ContainerErrorTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ContainerErrorTypes": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ContainerErrorTypes():
    TypeOnly<old.ContainerErrorTypes>;
declare function use_current_TypeAliasDeclaration_ContainerErrorTypes(
    use: TypeOnly<current.ContainerErrorTypes>): void;
use_current_TypeAliasDeclaration_ContainerErrorTypes(
    get_old_TypeAliasDeclaration_ContainerErrorTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ContainerErrorTypes": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ContainerErrorTypes():
    TypeOnly<current.ContainerErrorTypes>;
declare function use_old_TypeAliasDeclaration_ContainerErrorTypes(
    use: TypeOnly<old.ContainerErrorTypes>): void;
use_old_TypeAliasDeclaration_ContainerErrorTypes(
    get_current_TypeAliasDeclaration_ContainerErrorTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerWarning": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerWarning():
    TypeOnly<old.ContainerWarning>;
declare function use_current_InterfaceDeclaration_ContainerWarning(
    use: TypeOnly<current.ContainerWarning>): void;
use_current_InterfaceDeclaration_ContainerWarning(
    get_old_InterfaceDeclaration_ContainerWarning());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerWarning": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerWarning():
    TypeOnly<current.ContainerWarning>;
declare function use_old_InterfaceDeclaration_ContainerWarning(
    use: TypeOnly<old.ContainerWarning>): void;
use_old_InterfaceDeclaration_ContainerWarning(
    get_current_InterfaceDeclaration_ContainerWarning());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAudience": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAudience():
    TypeOnly<old.IAudience>;
declare function use_current_InterfaceDeclaration_IAudience(
    use: TypeOnly<current.IAudience>): void;
use_current_InterfaceDeclaration_IAudience(
    get_old_InterfaceDeclaration_IAudience());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAudience": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAudience():
    TypeOnly<current.IAudience>;
declare function use_old_InterfaceDeclaration_IAudience(
    use: TypeOnly<old.IAudience>): void;
use_old_InterfaceDeclaration_IAudience(
    get_current_InterfaceDeclaration_IAudience());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAudienceOwner": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAudienceOwner():
    TypeOnly<old.IAudienceOwner>;
declare function use_current_InterfaceDeclaration_IAudienceOwner(
    use: TypeOnly<current.IAudienceOwner>): void;
use_current_InterfaceDeclaration_IAudienceOwner(
    get_old_InterfaceDeclaration_IAudienceOwner());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAudienceOwner": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAudienceOwner():
    TypeOnly<current.IAudienceOwner>;
declare function use_old_InterfaceDeclaration_IAudienceOwner(
    use: TypeOnly<old.IAudienceOwner>): void;
use_old_InterfaceDeclaration_IAudienceOwner(
    get_current_InterfaceDeclaration_IAudienceOwner());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBatchMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IBatchMessage():
    TypeOnly<old.IBatchMessage>;
declare function use_current_InterfaceDeclaration_IBatchMessage(
    use: TypeOnly<current.IBatchMessage>): void;
use_current_InterfaceDeclaration_IBatchMessage(
    get_old_InterfaceDeclaration_IBatchMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBatchMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IBatchMessage():
    TypeOnly<current.IBatchMessage>;
declare function use_old_InterfaceDeclaration_IBatchMessage(
    use: TypeOnly<old.IBatchMessage>): void;
use_old_InterfaceDeclaration_IBatchMessage(
    get_current_InterfaceDeclaration_IBatchMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICodeDetailsLoader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICodeDetailsLoader():
    TypeOnly<old.ICodeDetailsLoader>;
declare function use_current_InterfaceDeclaration_ICodeDetailsLoader(
    use: TypeOnly<current.ICodeDetailsLoader>): void;
use_current_InterfaceDeclaration_ICodeDetailsLoader(
    get_old_InterfaceDeclaration_ICodeDetailsLoader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICodeDetailsLoader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICodeDetailsLoader():
    TypeOnly<current.ICodeDetailsLoader>;
declare function use_old_InterfaceDeclaration_ICodeDetailsLoader(
    use: TypeOnly<old.ICodeDetailsLoader>): void;
use_old_InterfaceDeclaration_ICodeDetailsLoader(
    get_current_InterfaceDeclaration_ICodeDetailsLoader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnectionDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConnectionDetails():
    TypeOnly<old.IConnectionDetails>;
declare function use_current_InterfaceDeclaration_IConnectionDetails(
    use: TypeOnly<current.IConnectionDetails>): void;
use_current_InterfaceDeclaration_IConnectionDetails(
    get_old_InterfaceDeclaration_IConnectionDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnectionDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConnectionDetails():
    TypeOnly<current.IConnectionDetails>;
declare function use_old_InterfaceDeclaration_IConnectionDetails(
    use: TypeOnly<old.IConnectionDetails>): void;
use_old_InterfaceDeclaration_IConnectionDetails(
    get_current_InterfaceDeclaration_IConnectionDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainer():
    TypeOnly<old.IContainer>;
declare function use_current_InterfaceDeclaration_IContainer(
    use: TypeOnly<current.IContainer>): void;
use_current_InterfaceDeclaration_IContainer(
    get_old_InterfaceDeclaration_IContainer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainer():
    TypeOnly<current.IContainer>;
declare function use_old_InterfaceDeclaration_IContainer(
    use: TypeOnly<old.IContainer>): void;
use_old_InterfaceDeclaration_IContainer(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IContainer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerContext():
    TypeOnly<old.IContainerContext>;
declare function use_current_InterfaceDeclaration_IContainerContext(
    use: TypeOnly<current.IContainerContext>): void;
use_current_InterfaceDeclaration_IContainerContext(
    get_old_InterfaceDeclaration_IContainerContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerContext():
    TypeOnly<current.IContainerContext>;
declare function use_old_InterfaceDeclaration_IContainerContext(
    use: TypeOnly<old.IContainerContext>): void;
use_old_InterfaceDeclaration_IContainerContext(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IContainerContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerEvents():
    TypeOnly<old.IContainerEvents>;
declare function use_current_InterfaceDeclaration_IContainerEvents(
    use: TypeOnly<current.IContainerEvents>): void;
use_current_InterfaceDeclaration_IContainerEvents(
    get_old_InterfaceDeclaration_IContainerEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerEvents():
    TypeOnly<current.IContainerEvents>;
declare function use_old_InterfaceDeclaration_IContainerEvents(
    use: TypeOnly<old.IContainerEvents>): void;
use_old_InterfaceDeclaration_IContainerEvents(
    get_current_InterfaceDeclaration_IContainerEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerLoadMode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerLoadMode():
    TypeOnly<old.IContainerLoadMode>;
declare function use_current_InterfaceDeclaration_IContainerLoadMode(
    use: TypeOnly<current.IContainerLoadMode>): void;
use_current_InterfaceDeclaration_IContainerLoadMode(
    get_old_InterfaceDeclaration_IContainerLoadMode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerLoadMode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerLoadMode():
    TypeOnly<current.IContainerLoadMode>;
declare function use_old_InterfaceDeclaration_IContainerLoadMode(
    use: TypeOnly<old.IContainerLoadMode>): void;
use_old_InterfaceDeclaration_IContainerLoadMode(
    get_current_InterfaceDeclaration_IContainerLoadMode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ICriticalContainerError": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ICriticalContainerError():
    TypeOnly<old.ICriticalContainerError>;
declare function use_current_TypeAliasDeclaration_ICriticalContainerError(
    use: TypeOnly<current.ICriticalContainerError>): void;
use_current_TypeAliasDeclaration_ICriticalContainerError(
    get_old_TypeAliasDeclaration_ICriticalContainerError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ICriticalContainerError": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ICriticalContainerError():
    TypeOnly<current.ICriticalContainerError>;
declare function use_old_TypeAliasDeclaration_ICriticalContainerError(
    use: TypeOnly<old.ICriticalContainerError>): void;
use_old_TypeAliasDeclaration_ICriticalContainerError(
    get_current_TypeAliasDeclaration_ICriticalContainerError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeltaManager():
    TypeOnly<old.IDeltaManager<any,any>>;
declare function use_current_InterfaceDeclaration_IDeltaManager(
    use: TypeOnly<current.IDeltaManager<any,any>>): void;
use_current_InterfaceDeclaration_IDeltaManager(
    get_old_InterfaceDeclaration_IDeltaManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeltaManager():
    TypeOnly<current.IDeltaManager<any,any>>;
declare function use_old_InterfaceDeclaration_IDeltaManager(
    use: TypeOnly<old.IDeltaManager<any,any>>): void;
use_old_InterfaceDeclaration_IDeltaManager(
    get_current_InterfaceDeclaration_IDeltaManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaManagerEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeltaManagerEvents():
    TypeOnly<old.IDeltaManagerEvents>;
declare function use_current_InterfaceDeclaration_IDeltaManagerEvents(
    use: TypeOnly<current.IDeltaManagerEvents>): void;
use_current_InterfaceDeclaration_IDeltaManagerEvents(
    get_old_InterfaceDeclaration_IDeltaManagerEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaManagerEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeltaManagerEvents():
    TypeOnly<current.IDeltaManagerEvents>;
declare function use_old_InterfaceDeclaration_IDeltaManagerEvents(
    use: TypeOnly<old.IDeltaManagerEvents>): void;
use_old_InterfaceDeclaration_IDeltaManagerEvents(
    get_current_InterfaceDeclaration_IDeltaManagerEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaQueue": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeltaQueue():
    TypeOnly<old.IDeltaQueue<any>>;
declare function use_current_InterfaceDeclaration_IDeltaQueue(
    use: TypeOnly<current.IDeltaQueue<any>>): void;
use_current_InterfaceDeclaration_IDeltaQueue(
    get_old_InterfaceDeclaration_IDeltaQueue());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaQueue": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeltaQueue():
    TypeOnly<current.IDeltaQueue<any>>;
declare function use_old_InterfaceDeclaration_IDeltaQueue(
    use: TypeOnly<old.IDeltaQueue<any>>): void;
use_old_InterfaceDeclaration_IDeltaQueue(
    get_current_InterfaceDeclaration_IDeltaQueue());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaQueueEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeltaQueueEvents():
    TypeOnly<old.IDeltaQueueEvents<any>>;
declare function use_current_InterfaceDeclaration_IDeltaQueueEvents(
    use: TypeOnly<current.IDeltaQueueEvents<any>>): void;
use_current_InterfaceDeclaration_IDeltaQueueEvents(
    get_old_InterfaceDeclaration_IDeltaQueueEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaQueueEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeltaQueueEvents():
    TypeOnly<current.IDeltaQueueEvents<any>>;
declare function use_old_InterfaceDeclaration_IDeltaQueueEvents(
    use: TypeOnly<old.IDeltaQueueEvents<any>>): void;
use_old_InterfaceDeclaration_IDeltaQueueEvents(
    get_current_InterfaceDeclaration_IDeltaQueueEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaSender": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeltaSender():
    TypeOnly<old.IDeltaSender>;
declare function use_current_InterfaceDeclaration_IDeltaSender(
    use: TypeOnly<current.IDeltaSender>): void;
use_current_InterfaceDeclaration_IDeltaSender(
    get_old_InterfaceDeclaration_IDeltaSender());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaSender": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeltaSender():
    TypeOnly<current.IDeltaSender>;
declare function use_old_InterfaceDeclaration_IDeltaSender(
    use: TypeOnly<old.IDeltaSender>): void;
use_old_InterfaceDeclaration_IDeltaSender(
    get_current_InterfaceDeclaration_IDeltaSender());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IErrorBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IErrorBase():
    TypeOnly<old.IErrorBase>;
declare function use_current_InterfaceDeclaration_IErrorBase(
    use: TypeOnly<current.IErrorBase>): void;
use_current_InterfaceDeclaration_IErrorBase(
    get_old_InterfaceDeclaration_IErrorBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IErrorBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IErrorBase():
    TypeOnly<current.IErrorBase>;
declare function use_old_InterfaceDeclaration_IErrorBase(
    use: TypeOnly<old.IErrorBase>): void;
use_old_InterfaceDeclaration_IErrorBase(
    get_current_InterfaceDeclaration_IErrorBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidBrowserPackage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidBrowserPackage():
    TypeOnly<old.IFluidBrowserPackage>;
declare function use_current_InterfaceDeclaration_IFluidBrowserPackage(
    use: TypeOnly<current.IFluidBrowserPackage>): void;
use_current_InterfaceDeclaration_IFluidBrowserPackage(
    get_old_InterfaceDeclaration_IFluidBrowserPackage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidBrowserPackage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidBrowserPackage():
    TypeOnly<current.IFluidBrowserPackage>;
declare function use_old_InterfaceDeclaration_IFluidBrowserPackage(
    use: TypeOnly<old.IFluidBrowserPackage>): void;
use_old_InterfaceDeclaration_IFluidBrowserPackage(
    get_current_InterfaceDeclaration_IFluidBrowserPackage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidBrowserPackageEnvironment": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidBrowserPackageEnvironment():
    TypeOnly<old.IFluidBrowserPackageEnvironment>;
declare function use_current_InterfaceDeclaration_IFluidBrowserPackageEnvironment(
    use: TypeOnly<current.IFluidBrowserPackageEnvironment>): void;
use_current_InterfaceDeclaration_IFluidBrowserPackageEnvironment(
    get_old_InterfaceDeclaration_IFluidBrowserPackageEnvironment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidBrowserPackageEnvironment": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidBrowserPackageEnvironment():
    TypeOnly<current.IFluidBrowserPackageEnvironment>;
declare function use_old_InterfaceDeclaration_IFluidBrowserPackageEnvironment(
    use: TypeOnly<old.IFluidBrowserPackageEnvironment>): void;
use_old_InterfaceDeclaration_IFluidBrowserPackageEnvironment(
    get_current_InterfaceDeclaration_IFluidBrowserPackageEnvironment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidCodeDetails():
    TypeOnly<old.IFluidCodeDetails>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetails(
    use: TypeOnly<current.IFluidCodeDetails>): void;
use_current_InterfaceDeclaration_IFluidCodeDetails(
    get_old_InterfaceDeclaration_IFluidCodeDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidCodeDetails():
    TypeOnly<current.IFluidCodeDetails>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetails(
    use: TypeOnly<old.IFluidCodeDetails>): void;
use_old_InterfaceDeclaration_IFluidCodeDetails(
    get_current_InterfaceDeclaration_IFluidCodeDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidCodeDetailsComparer": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<typeof old.IFluidCodeDetailsComparer>;
declare function use_current_VariableDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<typeof current.IFluidCodeDetailsComparer>): void;
use_current_VariableDeclaration_IFluidCodeDetailsComparer(
    get_old_VariableDeclaration_IFluidCodeDetailsComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidCodeDetailsComparer": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<typeof current.IFluidCodeDetailsComparer>;
declare function use_old_VariableDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<typeof old.IFluidCodeDetailsComparer>): void;
use_old_VariableDeclaration_IFluidCodeDetailsComparer(
    get_current_VariableDeclaration_IFluidCodeDetailsComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsComparer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<old.IFluidCodeDetailsComparer>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<current.IFluidCodeDetailsComparer>): void;
use_current_InterfaceDeclaration_IFluidCodeDetailsComparer(
    get_old_InterfaceDeclaration_IFluidCodeDetailsComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsComparer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<current.IFluidCodeDetailsComparer>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<old.IFluidCodeDetailsComparer>): void;
use_old_InterfaceDeclaration_IFluidCodeDetailsComparer(
    get_current_InterfaceDeclaration_IFluidCodeDetailsComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidCodeDetailsConfig():
    TypeOnly<old.IFluidCodeDetailsConfig>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetailsConfig(
    use: TypeOnly<current.IFluidCodeDetailsConfig>): void;
use_current_InterfaceDeclaration_IFluidCodeDetailsConfig(
    get_old_InterfaceDeclaration_IFluidCodeDetailsConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidCodeDetailsConfig():
    TypeOnly<current.IFluidCodeDetailsConfig>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetailsConfig(
    use: TypeOnly<old.IFluidCodeDetailsConfig>): void;
use_old_InterfaceDeclaration_IFluidCodeDetailsConfig(
    get_current_InterfaceDeclaration_IFluidCodeDetailsConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeResolver": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidCodeResolver():
    TypeOnly<old.IFluidCodeResolver>;
declare function use_current_InterfaceDeclaration_IFluidCodeResolver(
    use: TypeOnly<current.IFluidCodeResolver>): void;
use_current_InterfaceDeclaration_IFluidCodeResolver(
    get_old_InterfaceDeclaration_IFluidCodeResolver());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeResolver": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidCodeResolver():
    TypeOnly<current.IFluidCodeResolver>;
declare function use_old_InterfaceDeclaration_IFluidCodeResolver(
    use: TypeOnly<old.IFluidCodeResolver>): void;
use_old_InterfaceDeclaration_IFluidCodeResolver(
    get_current_InterfaceDeclaration_IFluidCodeResolver());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidModule": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidModule():
    TypeOnly<old.IFluidModule>;
declare function use_current_InterfaceDeclaration_IFluidModule(
    use: TypeOnly<current.IFluidModule>): void;
use_current_InterfaceDeclaration_IFluidModule(
    get_old_InterfaceDeclaration_IFluidModule());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidModule": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidModule():
    TypeOnly<current.IFluidModule>;
declare function use_old_InterfaceDeclaration_IFluidModule(
    use: TypeOnly<old.IFluidModule>): void;
use_old_InterfaceDeclaration_IFluidModule(
    get_current_InterfaceDeclaration_IFluidModule());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidModuleWithDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidModuleWithDetails():
    TypeOnly<old.IFluidModuleWithDetails>;
declare function use_current_InterfaceDeclaration_IFluidModuleWithDetails(
    use: TypeOnly<current.IFluidModuleWithDetails>): void;
use_current_InterfaceDeclaration_IFluidModuleWithDetails(
    get_old_InterfaceDeclaration_IFluidModuleWithDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidModuleWithDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidModuleWithDetails():
    TypeOnly<current.IFluidModuleWithDetails>;
declare function use_old_InterfaceDeclaration_IFluidModuleWithDetails(
    use: TypeOnly<old.IFluidModuleWithDetails>): void;
use_old_InterfaceDeclaration_IFluidModuleWithDetails(
    get_current_InterfaceDeclaration_IFluidModuleWithDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidPackage():
    TypeOnly<old.IFluidPackage>;
declare function use_current_InterfaceDeclaration_IFluidPackage(
    use: TypeOnly<current.IFluidPackage>): void;
use_current_InterfaceDeclaration_IFluidPackage(
    get_old_InterfaceDeclaration_IFluidPackage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidPackage():
    TypeOnly<current.IFluidPackage>;
declare function use_old_InterfaceDeclaration_IFluidPackage(
    use: TypeOnly<old.IFluidPackage>): void;
use_old_InterfaceDeclaration_IFluidPackage(
    get_current_InterfaceDeclaration_IFluidPackage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackageEnvironment": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidPackageEnvironment():
    TypeOnly<old.IFluidPackageEnvironment>;
declare function use_current_InterfaceDeclaration_IFluidPackageEnvironment(
    use: TypeOnly<current.IFluidPackageEnvironment>): void;
use_current_InterfaceDeclaration_IFluidPackageEnvironment(
    get_old_InterfaceDeclaration_IFluidPackageEnvironment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackageEnvironment": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidPackageEnvironment():
    TypeOnly<current.IFluidPackageEnvironment>;
declare function use_old_InterfaceDeclaration_IFluidPackageEnvironment(
    use: TypeOnly<old.IFluidPackageEnvironment>): void;
use_old_InterfaceDeclaration_IFluidPackageEnvironment(
    get_current_InterfaceDeclaration_IFluidPackageEnvironment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGenericError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGenericError():
    TypeOnly<old.IGenericError>;
declare function use_current_InterfaceDeclaration_IGenericError(
    use: TypeOnly<current.IGenericError>): void;
use_current_InterfaceDeclaration_IGenericError(
    get_old_InterfaceDeclaration_IGenericError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGenericError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGenericError():
    TypeOnly<current.IGenericError>;
declare function use_old_InterfaceDeclaration_IGenericError(
    use: TypeOnly<old.IGenericError>): void;
use_old_InterfaceDeclaration_IGenericError(
    get_current_InterfaceDeclaration_IGenericError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGetPendingLocalStateProps": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGetPendingLocalStateProps():
    TypeOnly<old.IGetPendingLocalStateProps>;
declare function use_current_InterfaceDeclaration_IGetPendingLocalStateProps(
    use: TypeOnly<current.IGetPendingLocalStateProps>): void;
use_current_InterfaceDeclaration_IGetPendingLocalStateProps(
    get_old_InterfaceDeclaration_IGetPendingLocalStateProps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGetPendingLocalStateProps": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGetPendingLocalStateProps():
    TypeOnly<current.IGetPendingLocalStateProps>;
declare function use_old_InterfaceDeclaration_IGetPendingLocalStateProps(
    use: TypeOnly<old.IGetPendingLocalStateProps>): void;
use_old_InterfaceDeclaration_IGetPendingLocalStateProps(
    get_current_InterfaceDeclaration_IGetPendingLocalStateProps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHostLoader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IHostLoader():
    TypeOnly<old.IHostLoader>;
declare function use_current_InterfaceDeclaration_IHostLoader(
    use: TypeOnly<current.IHostLoader>): void;
use_current_InterfaceDeclaration_IHostLoader(
    get_old_InterfaceDeclaration_IHostLoader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHostLoader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IHostLoader():
    TypeOnly<current.IHostLoader>;
declare function use_old_InterfaceDeclaration_IHostLoader(
    use: TypeOnly<old.IHostLoader>): void;
use_old_InterfaceDeclaration_IHostLoader(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IHostLoader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILoader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ILoader():
    TypeOnly<old.ILoader>;
declare function use_current_InterfaceDeclaration_ILoader(
    use: TypeOnly<current.ILoader>): void;
use_current_InterfaceDeclaration_ILoader(
    get_old_InterfaceDeclaration_ILoader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILoader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ILoader():
    TypeOnly<current.ILoader>;
declare function use_old_InterfaceDeclaration_ILoader(
    use: TypeOnly<old.ILoader>): void;
use_old_InterfaceDeclaration_ILoader(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_ILoader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILoaderHeader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ILoaderHeader():
    TypeOnly<old.ILoaderHeader>;
declare function use_current_InterfaceDeclaration_ILoaderHeader(
    use: TypeOnly<current.ILoaderHeader>): void;
use_current_InterfaceDeclaration_ILoaderHeader(
    get_old_InterfaceDeclaration_ILoaderHeader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILoaderHeader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ILoaderHeader():
    TypeOnly<current.ILoaderHeader>;
declare function use_old_InterfaceDeclaration_ILoaderHeader(
    use: TypeOnly<old.ILoaderHeader>): void;
use_old_InterfaceDeclaration_ILoaderHeader(
    get_current_InterfaceDeclaration_ILoaderHeader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ILoaderOptions": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ILoaderOptions():
    TypeOnly<old.ILoaderOptions>;
declare function use_current_TypeAliasDeclaration_ILoaderOptions(
    use: TypeOnly<current.ILoaderOptions>): void;
use_current_TypeAliasDeclaration_ILoaderOptions(
    get_old_TypeAliasDeclaration_ILoaderOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ILoaderOptions": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ILoaderOptions():
    TypeOnly<current.ILoaderOptions>;
declare function use_old_TypeAliasDeclaration_ILoaderOptions(
    use: TypeOnly<old.ILoaderOptions>): void;
use_old_TypeAliasDeclaration_ILoaderOptions(
    get_current_TypeAliasDeclaration_ILoaderOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedInterfaceDeclaration_IPendingLocalState": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedInterfaceDeclaration_IPendingLocalState": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidCodeDetailsComparer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer():
    TypeOnly<old.IProvideFluidCodeDetailsComparer>;
declare function use_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    use: TypeOnly<current.IProvideFluidCodeDetailsComparer>): void;
use_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    get_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidCodeDetailsComparer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer():
    TypeOnly<current.IProvideFluidCodeDetailsComparer>;
declare function use_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    use: TypeOnly<old.IProvideFluidCodeDetailsComparer>): void;
use_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    get_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideLoader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideLoader():
    TypeOnly<old.IProvideLoader>;
declare function use_current_InterfaceDeclaration_IProvideLoader(
    use: TypeOnly<current.IProvideLoader>): void;
use_current_InterfaceDeclaration_IProvideLoader(
    get_old_InterfaceDeclaration_IProvideLoader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideLoader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideLoader():
    TypeOnly<current.IProvideLoader>;
declare function use_old_InterfaceDeclaration_IProvideLoader(
    use: TypeOnly<old.IProvideLoader>): void;
use_old_InterfaceDeclaration_IProvideLoader(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IProvideLoader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideRuntimeFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideRuntimeFactory():
    TypeOnly<old.IProvideRuntimeFactory>;
declare function use_current_InterfaceDeclaration_IProvideRuntimeFactory(
    use: TypeOnly<current.IProvideRuntimeFactory>): void;
use_current_InterfaceDeclaration_IProvideRuntimeFactory(
    get_old_InterfaceDeclaration_IProvideRuntimeFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideRuntimeFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideRuntimeFactory():
    TypeOnly<current.IProvideRuntimeFactory>;
declare function use_old_InterfaceDeclaration_IProvideRuntimeFactory(
    use: TypeOnly<old.IProvideRuntimeFactory>): void;
use_old_InterfaceDeclaration_IProvideRuntimeFactory(
    get_current_InterfaceDeclaration_IProvideRuntimeFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IResolvedFluidCodeDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IResolvedFluidCodeDetails():
    TypeOnly<old.IResolvedFluidCodeDetails>;
declare function use_current_InterfaceDeclaration_IResolvedFluidCodeDetails(
    use: TypeOnly<current.IResolvedFluidCodeDetails>): void;
use_current_InterfaceDeclaration_IResolvedFluidCodeDetails(
    get_old_InterfaceDeclaration_IResolvedFluidCodeDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IResolvedFluidCodeDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IResolvedFluidCodeDetails():
    TypeOnly<current.IResolvedFluidCodeDetails>;
declare function use_old_InterfaceDeclaration_IResolvedFluidCodeDetails(
    use: TypeOnly<old.IResolvedFluidCodeDetails>): void;
use_old_InterfaceDeclaration_IResolvedFluidCodeDetails(
    get_current_InterfaceDeclaration_IResolvedFluidCodeDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRuntime": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRuntime():
    TypeOnly<old.IRuntime>;
declare function use_current_InterfaceDeclaration_IRuntime(
    use: TypeOnly<current.IRuntime>): void;
use_current_InterfaceDeclaration_IRuntime(
    get_old_InterfaceDeclaration_IRuntime());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRuntime": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRuntime():
    TypeOnly<current.IRuntime>;
declare function use_old_InterfaceDeclaration_IRuntime(
    use: TypeOnly<old.IRuntime>): void;
use_old_InterfaceDeclaration_IRuntime(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IRuntime());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IRuntimeFactory": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IRuntimeFactory():
    TypeOnly<typeof old.IRuntimeFactory>;
declare function use_current_VariableDeclaration_IRuntimeFactory(
    use: TypeOnly<typeof current.IRuntimeFactory>): void;
use_current_VariableDeclaration_IRuntimeFactory(
    get_old_VariableDeclaration_IRuntimeFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IRuntimeFactory": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IRuntimeFactory():
    TypeOnly<typeof current.IRuntimeFactory>;
declare function use_old_VariableDeclaration_IRuntimeFactory(
    use: TypeOnly<typeof old.IRuntimeFactory>): void;
use_old_VariableDeclaration_IRuntimeFactory(
    get_current_VariableDeclaration_IRuntimeFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRuntimeFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRuntimeFactory():
    TypeOnly<old.IRuntimeFactory>;
declare function use_current_InterfaceDeclaration_IRuntimeFactory(
    use: TypeOnly<current.IRuntimeFactory>): void;
use_current_InterfaceDeclaration_IRuntimeFactory(
    get_old_InterfaceDeclaration_IRuntimeFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRuntimeFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRuntimeFactory():
    TypeOnly<current.IRuntimeFactory>;
declare function use_old_InterfaceDeclaration_IRuntimeFactory(
    use: TypeOnly<old.IRuntimeFactory>): void;
use_old_InterfaceDeclaration_IRuntimeFactory(
    get_current_InterfaceDeclaration_IRuntimeFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISnapshotTreeWithBlobContents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISnapshotTreeWithBlobContents():
    TypeOnly<old.ISnapshotTreeWithBlobContents>;
declare function use_current_InterfaceDeclaration_ISnapshotTreeWithBlobContents(
    use: TypeOnly<current.ISnapshotTreeWithBlobContents>): void;
use_current_InterfaceDeclaration_ISnapshotTreeWithBlobContents(
    get_old_InterfaceDeclaration_ISnapshotTreeWithBlobContents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISnapshotTreeWithBlobContents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISnapshotTreeWithBlobContents():
    TypeOnly<current.ISnapshotTreeWithBlobContents>;
declare function use_old_InterfaceDeclaration_ISnapshotTreeWithBlobContents(
    use: TypeOnly<old.ISnapshotTreeWithBlobContents>): void;
use_old_InterfaceDeclaration_ISnapshotTreeWithBlobContents(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_ISnapshotTreeWithBlobContents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottlingWarning": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IThrottlingWarning():
    TypeOnly<old.IThrottlingWarning>;
declare function use_current_InterfaceDeclaration_IThrottlingWarning(
    use: TypeOnly<current.IThrottlingWarning>): void;
use_current_InterfaceDeclaration_IThrottlingWarning(
    get_old_InterfaceDeclaration_IThrottlingWarning());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottlingWarning": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IThrottlingWarning():
    TypeOnly<current.IThrottlingWarning>;
declare function use_old_InterfaceDeclaration_IThrottlingWarning(
    use: TypeOnly<old.IThrottlingWarning>): void;
use_old_InterfaceDeclaration_IThrottlingWarning(
    get_current_InterfaceDeclaration_IThrottlingWarning());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUsageError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IUsageError():
    TypeOnly<old.IUsageError>;
declare function use_current_InterfaceDeclaration_IUsageError(
    use: TypeOnly<current.IUsageError>): void;
use_current_InterfaceDeclaration_IUsageError(
    get_old_InterfaceDeclaration_IUsageError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUsageError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IUsageError():
    TypeOnly<current.IUsageError>;
declare function use_old_InterfaceDeclaration_IUsageError(
    use: TypeOnly<old.IUsageError>): void;
use_old_InterfaceDeclaration_IUsageError(
    get_current_InterfaceDeclaration_IUsageError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_LoaderHeader": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_LoaderHeader():
    TypeOnly<old.LoaderHeader>;
declare function use_current_EnumDeclaration_LoaderHeader(
    use: TypeOnly<current.LoaderHeader>): void;
use_current_EnumDeclaration_LoaderHeader(
    get_old_EnumDeclaration_LoaderHeader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_LoaderHeader": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_LoaderHeader():
    TypeOnly<current.LoaderHeader>;
declare function use_old_EnumDeclaration_LoaderHeader(
    use: TypeOnly<old.LoaderHeader>): void;
use_old_EnumDeclaration_LoaderHeader(
    get_current_EnumDeclaration_LoaderHeader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ReadOnlyInfo": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ReadOnlyInfo():
    TypeOnly<old.ReadOnlyInfo>;
declare function use_current_TypeAliasDeclaration_ReadOnlyInfo(
    use: TypeOnly<current.ReadOnlyInfo>): void;
use_current_TypeAliasDeclaration_ReadOnlyInfo(
    get_old_TypeAliasDeclaration_ReadOnlyInfo());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ReadOnlyInfo": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ReadOnlyInfo():
    TypeOnly<current.ReadOnlyInfo>;
declare function use_old_TypeAliasDeclaration_ReadOnlyInfo(
    use: TypeOnly<old.ReadOnlyInfo>): void;
use_old_TypeAliasDeclaration_ReadOnlyInfo(
    get_current_TypeAliasDeclaration_ReadOnlyInfo());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidBrowserPackage": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isFluidBrowserPackage():
    TypeOnly<typeof old.isFluidBrowserPackage>;
declare function use_current_VariableDeclaration_isFluidBrowserPackage(
    use: TypeOnly<typeof current.isFluidBrowserPackage>): void;
use_current_VariableDeclaration_isFluidBrowserPackage(
    get_old_VariableDeclaration_isFluidBrowserPackage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidBrowserPackage": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isFluidBrowserPackage():
    TypeOnly<typeof current.isFluidBrowserPackage>;
declare function use_old_VariableDeclaration_isFluidBrowserPackage(
    use: TypeOnly<typeof old.isFluidBrowserPackage>): void;
use_old_VariableDeclaration_isFluidBrowserPackage(
    get_current_VariableDeclaration_isFluidBrowserPackage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidCodeDetails": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isFluidCodeDetails():
    TypeOnly<typeof old.isFluidCodeDetails>;
declare function use_current_VariableDeclaration_isFluidCodeDetails(
    use: TypeOnly<typeof current.isFluidCodeDetails>): void;
use_current_VariableDeclaration_isFluidCodeDetails(
    get_old_VariableDeclaration_isFluidCodeDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidCodeDetails": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isFluidCodeDetails():
    TypeOnly<typeof current.isFluidCodeDetails>;
declare function use_old_VariableDeclaration_isFluidCodeDetails(
    use: TypeOnly<typeof old.isFluidCodeDetails>): void;
use_old_VariableDeclaration_isFluidCodeDetails(
    get_current_VariableDeclaration_isFluidCodeDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidPackage": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isFluidPackage():
    TypeOnly<typeof old.isFluidPackage>;
declare function use_current_VariableDeclaration_isFluidPackage(
    use: TypeOnly<typeof current.isFluidPackage>): void;
use_current_VariableDeclaration_isFluidPackage(
    get_old_VariableDeclaration_isFluidPackage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidPackage": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isFluidPackage():
    TypeOnly<typeof current.isFluidPackage>;
declare function use_old_VariableDeclaration_isFluidPackage(
    use: TypeOnly<typeof old.isFluidPackage>): void;
use_old_VariableDeclaration_isFluidPackage(
    get_current_VariableDeclaration_isFluidPackage());
