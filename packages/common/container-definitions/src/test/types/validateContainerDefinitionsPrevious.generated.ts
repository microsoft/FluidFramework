/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type * as old from "@fluidframework/container-definitions-previous/internal";

import type * as current from "../../index.js";

type ValueOf<T> = T[keyof T];
type OnlySymbols<T> = T extends symbol ? T : never;
type WellKnownSymbols = OnlySymbols<ValueOf<typeof Symbol>>;
/**
 * Omit (replace with never) a key if it is a custom symbol,
 * not just symbol or a well known symbol from the global Symbol.
 */
type SkipUniqueSymbols<Key> = symbol extends Key
	? Key // Key is symbol or a generalization of symbol, so leave it as is.
	: Key extends symbol
		? Key extends WellKnownSymbols
			? Key // Key is a well known symbol from the global Symbol object. These are shared between packages, so they are fine and kept as is.
			: never // Key is most likely some specialized symbol, typically a unique symbol. These break type comparisons so are removed by replacing them with never.
		: Key; // Key is not a symbol (for example its a string or number), so leave it as is.
/**
 * Remove details of T which are incompatible with type testing while keeping as much as is practical.
 *
 * See 'build-tools/packages/build-tools/src/typeValidator/compatibility.ts' for more information.
 */
type TypeOnly<T> = T extends number
	? number
	: T extends boolean | bigint | string
		? T
		: T extends symbol
			? SkipUniqueSymbols<T>
			: {
					[P in keyof T as SkipUniqueSymbols<P>]: TypeOnly<T[P]>;
				};

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_AttachState": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_AttachState():
    TypeOnly<old.AttachState>;
declare function use_current_EnumDeclaration_AttachState(
    use: TypeOnly<current.AttachState>): void;
use_current_EnumDeclaration_AttachState(
    get_old_EnumDeclaration_AttachState());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_AttachState": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_AttachState():
    TypeOnly<current.AttachState>;
declare function use_old_EnumDeclaration_AttachState(
    use: TypeOnly<old.AttachState>): void;
use_old_EnumDeclaration_AttachState(
    get_current_EnumDeclaration_AttachState());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ConnectionState": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ConnectionState():
    TypeOnly<old.ConnectionState>;
declare function use_current_TypeAliasDeclaration_ConnectionState(
    use: TypeOnly<current.ConnectionState>): void;
use_current_TypeAliasDeclaration_ConnectionState(
    get_old_TypeAliasDeclaration_ConnectionState());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ConnectionState": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ConnectionState():
    TypeOnly<current.ConnectionState>;
declare function use_old_TypeAliasDeclaration_ConnectionState(
    use: TypeOnly<old.ConnectionState>): void;
use_old_TypeAliasDeclaration_ConnectionState(
    get_current_TypeAliasDeclaration_ConnectionState());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_ContainerErrorTypes": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_ContainerErrorTypes():
    TypeOnly<typeof old.ContainerErrorTypes>;
declare function use_current_VariableDeclaration_ContainerErrorTypes(
    use: TypeOnly<typeof current.ContainerErrorTypes>): void;
use_current_VariableDeclaration_ContainerErrorTypes(
    get_old_VariableDeclaration_ContainerErrorTypes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_ContainerErrorTypes": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_ContainerErrorTypes():
    TypeOnly<typeof current.ContainerErrorTypes>;
declare function use_old_VariableDeclaration_ContainerErrorTypes(
    use: TypeOnly<typeof old.ContainerErrorTypes>): void;
use_old_VariableDeclaration_ContainerErrorTypes(
    get_current_VariableDeclaration_ContainerErrorTypes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ContainerErrorTypes": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ContainerErrorTypes():
    TypeOnly<old.ContainerErrorTypes>;
declare function use_current_TypeAliasDeclaration_ContainerErrorTypes(
    use: TypeOnly<current.ContainerErrorTypes>): void;
use_current_TypeAliasDeclaration_ContainerErrorTypes(
    get_old_TypeAliasDeclaration_ContainerErrorTypes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ContainerErrorTypes": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ContainerErrorTypes():
    TypeOnly<current.ContainerErrorTypes>;
declare function use_old_TypeAliasDeclaration_ContainerErrorTypes(
    use: TypeOnly<old.ContainerErrorTypes>): void;
use_old_TypeAliasDeclaration_ContainerErrorTypes(
    get_current_TypeAliasDeclaration_ContainerErrorTypes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ContainerWarning": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ContainerWarning():
    TypeOnly<old.ContainerWarning>;
declare function use_current_InterfaceDeclaration_ContainerWarning(
    use: TypeOnly<current.ContainerWarning>): void;
use_current_InterfaceDeclaration_ContainerWarning(
    get_old_InterfaceDeclaration_ContainerWarning());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ContainerWarning": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ContainerWarning():
    TypeOnly<current.ContainerWarning>;
declare function use_old_InterfaceDeclaration_ContainerWarning(
    use: TypeOnly<old.ContainerWarning>): void;
use_old_InterfaceDeclaration_ContainerWarning(
    get_current_InterfaceDeclaration_ContainerWarning());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAudience": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IAudience():
    TypeOnly<old.IAudience>;
declare function use_current_InterfaceDeclaration_IAudience(
    use: TypeOnly<current.IAudience>): void;
use_current_InterfaceDeclaration_IAudience(
    get_old_InterfaceDeclaration_IAudience());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAudience": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IAudience():
    TypeOnly<current.IAudience>;
declare function use_old_InterfaceDeclaration_IAudience(
    use: TypeOnly<old.IAudience>): void;
use_old_InterfaceDeclaration_IAudience(
    get_current_InterfaceDeclaration_IAudience());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAudienceEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IAudienceEvents():
    TypeOnly<old.IAudienceEvents>;
declare function use_current_InterfaceDeclaration_IAudienceEvents(
    use: TypeOnly<current.IAudienceEvents>): void;
use_current_InterfaceDeclaration_IAudienceEvents(
    get_old_InterfaceDeclaration_IAudienceEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAudienceEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IAudienceEvents():
    TypeOnly<current.IAudienceEvents>;
declare function use_old_InterfaceDeclaration_IAudienceEvents(
    use: TypeOnly<old.IAudienceEvents>): void;
use_old_InterfaceDeclaration_IAudienceEvents(
    get_current_InterfaceDeclaration_IAudienceEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAudienceOwner": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IAudienceOwner():
    TypeOnly<old.IAudienceOwner>;
declare function use_current_InterfaceDeclaration_IAudienceOwner(
    use: TypeOnly<current.IAudienceOwner>): void;
use_current_InterfaceDeclaration_IAudienceOwner(
    get_old_InterfaceDeclaration_IAudienceOwner());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAudienceOwner": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IAudienceOwner():
    TypeOnly<current.IAudienceOwner>;
declare function use_old_InterfaceDeclaration_IAudienceOwner(
    use: TypeOnly<old.IAudienceOwner>): void;
use_old_InterfaceDeclaration_IAudienceOwner(
    get_current_InterfaceDeclaration_IAudienceOwner());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IBatchMessage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IBatchMessage():
    TypeOnly<old.IBatchMessage>;
declare function use_current_InterfaceDeclaration_IBatchMessage(
    use: TypeOnly<current.IBatchMessage>): void;
use_current_InterfaceDeclaration_IBatchMessage(
    get_old_InterfaceDeclaration_IBatchMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IBatchMessage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IBatchMessage():
    TypeOnly<current.IBatchMessage>;
declare function use_old_InterfaceDeclaration_IBatchMessage(
    use: TypeOnly<old.IBatchMessage>): void;
use_old_InterfaceDeclaration_IBatchMessage(
    get_current_InterfaceDeclaration_IBatchMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICodeDetailsLoader": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ICodeDetailsLoader():
    TypeOnly<old.ICodeDetailsLoader>;
declare function use_current_InterfaceDeclaration_ICodeDetailsLoader(
    use: TypeOnly<current.ICodeDetailsLoader>): void;
use_current_InterfaceDeclaration_ICodeDetailsLoader(
    get_old_InterfaceDeclaration_ICodeDetailsLoader());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICodeDetailsLoader": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ICodeDetailsLoader():
    TypeOnly<current.ICodeDetailsLoader>;
declare function use_old_InterfaceDeclaration_ICodeDetailsLoader(
    use: TypeOnly<old.ICodeDetailsLoader>): void;
use_old_InterfaceDeclaration_ICodeDetailsLoader(
    get_current_InterfaceDeclaration_ICodeDetailsLoader());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConnectionDetails": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IConnectionDetails():
    TypeOnly<old.IConnectionDetails>;
declare function use_current_InterfaceDeclaration_IConnectionDetails(
    use: TypeOnly<current.IConnectionDetails>): void;
use_current_InterfaceDeclaration_IConnectionDetails(
    get_old_InterfaceDeclaration_IConnectionDetails());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConnectionDetails": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IConnectionDetails():
    TypeOnly<current.IConnectionDetails>;
declare function use_old_InterfaceDeclaration_IConnectionDetails(
    use: TypeOnly<old.IConnectionDetails>): void;
use_old_InterfaceDeclaration_IConnectionDetails(
    get_current_InterfaceDeclaration_IConnectionDetails());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainer": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IContainer():
    TypeOnly<old.IContainer>;
declare function use_current_InterfaceDeclaration_IContainer(
    use: TypeOnly<current.IContainer>): void;
use_current_InterfaceDeclaration_IContainer(
    get_old_InterfaceDeclaration_IContainer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainer": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IContainer():
    TypeOnly<current.IContainer>;
declare function use_old_InterfaceDeclaration_IContainer(
    use: TypeOnly<old.IContainer>): void;
use_old_InterfaceDeclaration_IContainer(
    get_current_InterfaceDeclaration_IContainer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerContext": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IContainerContext():
    TypeOnly<old.IContainerContext>;
declare function use_current_InterfaceDeclaration_IContainerContext(
    use: TypeOnly<current.IContainerContext>): void;
use_current_InterfaceDeclaration_IContainerContext(
    get_old_InterfaceDeclaration_IContainerContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerContext": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IContainerContext():
    TypeOnly<current.IContainerContext>;
declare function use_old_InterfaceDeclaration_IContainerContext(
    use: TypeOnly<old.IContainerContext>): void;
use_old_InterfaceDeclaration_IContainerContext(
    get_current_InterfaceDeclaration_IContainerContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IContainerEvents():
    TypeOnly<old.IContainerEvents>;
declare function use_current_InterfaceDeclaration_IContainerEvents(
    use: TypeOnly<current.IContainerEvents>): void;
use_current_InterfaceDeclaration_IContainerEvents(
    get_old_InterfaceDeclaration_IContainerEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IContainerEvents():
    TypeOnly<current.IContainerEvents>;
declare function use_old_InterfaceDeclaration_IContainerEvents(
    use: TypeOnly<old.IContainerEvents>): void;
use_old_InterfaceDeclaration_IContainerEvents(
    get_current_InterfaceDeclaration_IContainerEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerLoadMode": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IContainerLoadMode():
    TypeOnly<old.IContainerLoadMode>;
declare function use_current_InterfaceDeclaration_IContainerLoadMode(
    use: TypeOnly<current.IContainerLoadMode>): void;
use_current_InterfaceDeclaration_IContainerLoadMode(
    get_old_InterfaceDeclaration_IContainerLoadMode());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerLoadMode": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IContainerLoadMode():
    TypeOnly<current.IContainerLoadMode>;
declare function use_old_InterfaceDeclaration_IContainerLoadMode(
    use: TypeOnly<old.IContainerLoadMode>): void;
use_old_InterfaceDeclaration_IContainerLoadMode(
    get_current_InterfaceDeclaration_IContainerLoadMode());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ICriticalContainerError": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ICriticalContainerError():
    TypeOnly<old.ICriticalContainerError>;
declare function use_current_TypeAliasDeclaration_ICriticalContainerError(
    use: TypeOnly<current.ICriticalContainerError>): void;
use_current_TypeAliasDeclaration_ICriticalContainerError(
    get_old_TypeAliasDeclaration_ICriticalContainerError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ICriticalContainerError": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ICriticalContainerError():
    TypeOnly<current.ICriticalContainerError>;
declare function use_old_TypeAliasDeclaration_ICriticalContainerError(
    use: TypeOnly<old.ICriticalContainerError>): void;
use_old_TypeAliasDeclaration_ICriticalContainerError(
    get_current_TypeAliasDeclaration_ICriticalContainerError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDeltaManager": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDeltaManager():
    TypeOnly<old.IDeltaManager<any,any>>;
declare function use_current_InterfaceDeclaration_IDeltaManager(
    use: TypeOnly<current.IDeltaManager<any,any>>): void;
use_current_InterfaceDeclaration_IDeltaManager(
    get_old_InterfaceDeclaration_IDeltaManager());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDeltaManager": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDeltaManager():
    TypeOnly<current.IDeltaManager<any,any>>;
declare function use_old_InterfaceDeclaration_IDeltaManager(
    use: TypeOnly<old.IDeltaManager<any,any>>): void;
use_old_InterfaceDeclaration_IDeltaManager(
    get_current_InterfaceDeclaration_IDeltaManager());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDeltaManagerEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDeltaManagerEvents():
    TypeOnly<old.IDeltaManagerEvents>;
declare function use_current_InterfaceDeclaration_IDeltaManagerEvents(
    use: TypeOnly<current.IDeltaManagerEvents>): void;
use_current_InterfaceDeclaration_IDeltaManagerEvents(
    get_old_InterfaceDeclaration_IDeltaManagerEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDeltaManagerEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDeltaManagerEvents():
    TypeOnly<current.IDeltaManagerEvents>;
declare function use_old_InterfaceDeclaration_IDeltaManagerEvents(
    use: TypeOnly<old.IDeltaManagerEvents>): void;
use_old_InterfaceDeclaration_IDeltaManagerEvents(
    get_current_InterfaceDeclaration_IDeltaManagerEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDeltaQueue": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDeltaQueue():
    TypeOnly<old.IDeltaQueue<any>>;
declare function use_current_InterfaceDeclaration_IDeltaQueue(
    use: TypeOnly<current.IDeltaQueue<any>>): void;
use_current_InterfaceDeclaration_IDeltaQueue(
    get_old_InterfaceDeclaration_IDeltaQueue());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDeltaQueue": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDeltaQueue():
    TypeOnly<current.IDeltaQueue<any>>;
declare function use_old_InterfaceDeclaration_IDeltaQueue(
    use: TypeOnly<old.IDeltaQueue<any>>): void;
use_old_InterfaceDeclaration_IDeltaQueue(
    get_current_InterfaceDeclaration_IDeltaQueue());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDeltaQueueEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDeltaQueueEvents():
    TypeOnly<old.IDeltaQueueEvents<any>>;
declare function use_current_InterfaceDeclaration_IDeltaQueueEvents(
    use: TypeOnly<current.IDeltaQueueEvents<any>>): void;
use_current_InterfaceDeclaration_IDeltaQueueEvents(
    get_old_InterfaceDeclaration_IDeltaQueueEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDeltaQueueEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDeltaQueueEvents():
    TypeOnly<current.IDeltaQueueEvents<any>>;
declare function use_old_InterfaceDeclaration_IDeltaQueueEvents(
    use: TypeOnly<old.IDeltaQueueEvents<any>>): void;
use_old_InterfaceDeclaration_IDeltaQueueEvents(
    get_current_InterfaceDeclaration_IDeltaQueueEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDeltaSender": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDeltaSender():
    TypeOnly<old.IDeltaSender>;
declare function use_current_InterfaceDeclaration_IDeltaSender(
    use: TypeOnly<current.IDeltaSender>): void;
use_current_InterfaceDeclaration_IDeltaSender(
    get_old_InterfaceDeclaration_IDeltaSender());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDeltaSender": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDeltaSender():
    TypeOnly<current.IDeltaSender>;
declare function use_old_InterfaceDeclaration_IDeltaSender(
    use: TypeOnly<old.IDeltaSender>): void;
use_old_InterfaceDeclaration_IDeltaSender(
    get_current_InterfaceDeclaration_IDeltaSender());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IErrorBase": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IErrorBase():
    TypeOnly<old.IErrorBase>;
declare function use_current_InterfaceDeclaration_IErrorBase(
    use: TypeOnly<current.IErrorBase>): void;
use_current_InterfaceDeclaration_IErrorBase(
    get_old_InterfaceDeclaration_IErrorBase());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IErrorBase": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IErrorBase():
    TypeOnly<current.IErrorBase>;
declare function use_old_InterfaceDeclaration_IErrorBase(
    use: TypeOnly<old.IErrorBase>): void;
use_old_InterfaceDeclaration_IErrorBase(
    get_current_InterfaceDeclaration_IErrorBase());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidBrowserPackage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidBrowserPackage():
    TypeOnly<old.IFluidBrowserPackage>;
declare function use_current_InterfaceDeclaration_IFluidBrowserPackage(
    use: TypeOnly<current.IFluidBrowserPackage>): void;
use_current_InterfaceDeclaration_IFluidBrowserPackage(
    get_old_InterfaceDeclaration_IFluidBrowserPackage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidBrowserPackage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidBrowserPackage():
    TypeOnly<current.IFluidBrowserPackage>;
declare function use_old_InterfaceDeclaration_IFluidBrowserPackage(
    use: TypeOnly<old.IFluidBrowserPackage>): void;
use_old_InterfaceDeclaration_IFluidBrowserPackage(
    get_current_InterfaceDeclaration_IFluidBrowserPackage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidBrowserPackageEnvironment": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidBrowserPackageEnvironment():
    TypeOnly<old.IFluidBrowserPackageEnvironment>;
declare function use_current_InterfaceDeclaration_IFluidBrowserPackageEnvironment(
    use: TypeOnly<current.IFluidBrowserPackageEnvironment>): void;
use_current_InterfaceDeclaration_IFluidBrowserPackageEnvironment(
    get_old_InterfaceDeclaration_IFluidBrowserPackageEnvironment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidBrowserPackageEnvironment": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidBrowserPackageEnvironment():
    TypeOnly<current.IFluidBrowserPackageEnvironment>;
declare function use_old_InterfaceDeclaration_IFluidBrowserPackageEnvironment(
    use: TypeOnly<old.IFluidBrowserPackageEnvironment>): void;
use_old_InterfaceDeclaration_IFluidBrowserPackageEnvironment(
    get_current_InterfaceDeclaration_IFluidBrowserPackageEnvironment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidCodeDetails": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidCodeDetails():
    TypeOnly<old.IFluidCodeDetails>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetails(
    use: TypeOnly<current.IFluidCodeDetails>): void;
use_current_InterfaceDeclaration_IFluidCodeDetails(
    get_old_InterfaceDeclaration_IFluidCodeDetails());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidCodeDetails": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidCodeDetails():
    TypeOnly<current.IFluidCodeDetails>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetails(
    use: TypeOnly<old.IFluidCodeDetails>): void;
use_old_InterfaceDeclaration_IFluidCodeDetails(
    get_current_InterfaceDeclaration_IFluidCodeDetails());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IFluidCodeDetailsComparer": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<typeof old.IFluidCodeDetailsComparer>;
declare function use_current_VariableDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<typeof current.IFluidCodeDetailsComparer>): void;
use_current_VariableDeclaration_IFluidCodeDetailsComparer(
    get_old_VariableDeclaration_IFluidCodeDetailsComparer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IFluidCodeDetailsComparer": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<typeof current.IFluidCodeDetailsComparer>;
declare function use_old_VariableDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<typeof old.IFluidCodeDetailsComparer>): void;
use_old_VariableDeclaration_IFluidCodeDetailsComparer(
    get_current_VariableDeclaration_IFluidCodeDetailsComparer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidCodeDetailsComparer": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<old.IFluidCodeDetailsComparer>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<current.IFluidCodeDetailsComparer>): void;
use_current_InterfaceDeclaration_IFluidCodeDetailsComparer(
    get_old_InterfaceDeclaration_IFluidCodeDetailsComparer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidCodeDetailsComparer": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<current.IFluidCodeDetailsComparer>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<old.IFluidCodeDetailsComparer>): void;
use_old_InterfaceDeclaration_IFluidCodeDetailsComparer(
    get_current_InterfaceDeclaration_IFluidCodeDetailsComparer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidCodeDetailsConfig": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidCodeDetailsConfig():
    TypeOnly<old.IFluidCodeDetailsConfig>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetailsConfig(
    use: TypeOnly<current.IFluidCodeDetailsConfig>): void;
use_current_InterfaceDeclaration_IFluidCodeDetailsConfig(
    get_old_InterfaceDeclaration_IFluidCodeDetailsConfig());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidCodeDetailsConfig": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidCodeDetailsConfig():
    TypeOnly<current.IFluidCodeDetailsConfig>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetailsConfig(
    use: TypeOnly<old.IFluidCodeDetailsConfig>): void;
use_old_InterfaceDeclaration_IFluidCodeDetailsConfig(
    get_current_InterfaceDeclaration_IFluidCodeDetailsConfig());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidCodeResolver": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidCodeResolver():
    TypeOnly<old.IFluidCodeResolver>;
declare function use_current_InterfaceDeclaration_IFluidCodeResolver(
    use: TypeOnly<current.IFluidCodeResolver>): void;
use_current_InterfaceDeclaration_IFluidCodeResolver(
    get_old_InterfaceDeclaration_IFluidCodeResolver());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidCodeResolver": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidCodeResolver():
    TypeOnly<current.IFluidCodeResolver>;
declare function use_old_InterfaceDeclaration_IFluidCodeResolver(
    use: TypeOnly<old.IFluidCodeResolver>): void;
use_old_InterfaceDeclaration_IFluidCodeResolver(
    get_current_InterfaceDeclaration_IFluidCodeResolver());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidModule": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidModule():
    TypeOnly<old.IFluidModule>;
declare function use_current_InterfaceDeclaration_IFluidModule(
    use: TypeOnly<current.IFluidModule>): void;
use_current_InterfaceDeclaration_IFluidModule(
    get_old_InterfaceDeclaration_IFluidModule());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidModule": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidModule():
    TypeOnly<current.IFluidModule>;
declare function use_old_InterfaceDeclaration_IFluidModule(
    use: TypeOnly<old.IFluidModule>): void;
use_old_InterfaceDeclaration_IFluidModule(
    get_current_InterfaceDeclaration_IFluidModule());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidModuleWithDetails": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidModuleWithDetails():
    TypeOnly<old.IFluidModuleWithDetails>;
declare function use_current_InterfaceDeclaration_IFluidModuleWithDetails(
    use: TypeOnly<current.IFluidModuleWithDetails>): void;
use_current_InterfaceDeclaration_IFluidModuleWithDetails(
    get_old_InterfaceDeclaration_IFluidModuleWithDetails());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidModuleWithDetails": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidModuleWithDetails():
    TypeOnly<current.IFluidModuleWithDetails>;
declare function use_old_InterfaceDeclaration_IFluidModuleWithDetails(
    use: TypeOnly<old.IFluidModuleWithDetails>): void;
use_old_InterfaceDeclaration_IFluidModuleWithDetails(
    get_current_InterfaceDeclaration_IFluidModuleWithDetails());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidPackage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidPackage():
    TypeOnly<old.IFluidPackage>;
declare function use_current_InterfaceDeclaration_IFluidPackage(
    use: TypeOnly<current.IFluidPackage>): void;
use_current_InterfaceDeclaration_IFluidPackage(
    get_old_InterfaceDeclaration_IFluidPackage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidPackage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidPackage():
    TypeOnly<current.IFluidPackage>;
declare function use_old_InterfaceDeclaration_IFluidPackage(
    use: TypeOnly<old.IFluidPackage>): void;
use_old_InterfaceDeclaration_IFluidPackage(
    get_current_InterfaceDeclaration_IFluidPackage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidPackageEnvironment": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidPackageEnvironment():
    TypeOnly<old.IFluidPackageEnvironment>;
declare function use_current_InterfaceDeclaration_IFluidPackageEnvironment(
    use: TypeOnly<current.IFluidPackageEnvironment>): void;
use_current_InterfaceDeclaration_IFluidPackageEnvironment(
    get_old_InterfaceDeclaration_IFluidPackageEnvironment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidPackageEnvironment": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidPackageEnvironment():
    TypeOnly<current.IFluidPackageEnvironment>;
declare function use_old_InterfaceDeclaration_IFluidPackageEnvironment(
    use: TypeOnly<old.IFluidPackageEnvironment>): void;
use_old_InterfaceDeclaration_IFluidPackageEnvironment(
    get_current_InterfaceDeclaration_IFluidPackageEnvironment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGenericError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IGenericError():
    TypeOnly<old.IGenericError>;
declare function use_current_InterfaceDeclaration_IGenericError(
    use: TypeOnly<current.IGenericError>): void;
use_current_InterfaceDeclaration_IGenericError(
    get_old_InterfaceDeclaration_IGenericError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGenericError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IGenericError():
    TypeOnly<current.IGenericError>;
declare function use_old_InterfaceDeclaration_IGenericError(
    use: TypeOnly<old.IGenericError>): void;
use_old_InterfaceDeclaration_IGenericError(
    get_current_InterfaceDeclaration_IGenericError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGetPendingLocalStateProps": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IGetPendingLocalStateProps():
    TypeOnly<old.IGetPendingLocalStateProps>;
declare function use_current_InterfaceDeclaration_IGetPendingLocalStateProps(
    use: TypeOnly<current.IGetPendingLocalStateProps>): void;
use_current_InterfaceDeclaration_IGetPendingLocalStateProps(
    get_old_InterfaceDeclaration_IGetPendingLocalStateProps());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGetPendingLocalStateProps": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IGetPendingLocalStateProps():
    TypeOnly<current.IGetPendingLocalStateProps>;
declare function use_old_InterfaceDeclaration_IGetPendingLocalStateProps(
    use: TypeOnly<old.IGetPendingLocalStateProps>): void;
use_old_InterfaceDeclaration_IGetPendingLocalStateProps(
    get_current_InterfaceDeclaration_IGetPendingLocalStateProps());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IHostLoader": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IHostLoader():
    TypeOnly<old.IHostLoader>;
declare function use_current_InterfaceDeclaration_IHostLoader(
    use: TypeOnly<current.IHostLoader>): void;
use_current_InterfaceDeclaration_IHostLoader(
    get_old_InterfaceDeclaration_IHostLoader());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IHostLoader": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IHostLoader():
    TypeOnly<current.IHostLoader>;
declare function use_old_InterfaceDeclaration_IHostLoader(
    use: TypeOnly<old.IHostLoader>): void;
use_old_InterfaceDeclaration_IHostLoader(
    get_current_InterfaceDeclaration_IHostLoader());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ILoader": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ILoader():
    TypeOnly<old.ILoader>;
declare function use_current_InterfaceDeclaration_ILoader(
    use: TypeOnly<current.ILoader>): void;
use_current_InterfaceDeclaration_ILoader(
    get_old_InterfaceDeclaration_ILoader());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ILoader": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ILoader():
    TypeOnly<current.ILoader>;
declare function use_old_InterfaceDeclaration_ILoader(
    use: TypeOnly<old.ILoader>): void;
use_old_InterfaceDeclaration_ILoader(
    get_current_InterfaceDeclaration_ILoader());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ILoaderHeader": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ILoaderHeader():
    TypeOnly<old.ILoaderHeader>;
declare function use_current_InterfaceDeclaration_ILoaderHeader(
    use: TypeOnly<current.ILoaderHeader>): void;
use_current_InterfaceDeclaration_ILoaderHeader(
    get_old_InterfaceDeclaration_ILoaderHeader());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ILoaderHeader": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ILoaderHeader():
    TypeOnly<current.ILoaderHeader>;
declare function use_old_InterfaceDeclaration_ILoaderHeader(
    use: TypeOnly<old.ILoaderHeader>): void;
use_old_InterfaceDeclaration_ILoaderHeader(
    get_current_InterfaceDeclaration_ILoaderHeader());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ILoaderOptions": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ILoaderOptions():
    TypeOnly<old.ILoaderOptions>;
declare function use_current_TypeAliasDeclaration_ILoaderOptions(
    use: TypeOnly<current.ILoaderOptions>): void;
use_current_TypeAliasDeclaration_ILoaderOptions(
    get_old_TypeAliasDeclaration_ILoaderOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ILoaderOptions": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ILoaderOptions():
    TypeOnly<current.ILoaderOptions>;
declare function use_old_TypeAliasDeclaration_ILoaderOptions(
    use: TypeOnly<old.ILoaderOptions>): void;
use_old_TypeAliasDeclaration_ILoaderOptions(
    get_current_TypeAliasDeclaration_ILoaderOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideFluidCodeDetailsComparer": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer():
    TypeOnly<old.IProvideFluidCodeDetailsComparer>;
declare function use_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    use: TypeOnly<current.IProvideFluidCodeDetailsComparer>): void;
use_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    get_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideFluidCodeDetailsComparer": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer():
    TypeOnly<current.IProvideFluidCodeDetailsComparer>;
declare function use_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    use: TypeOnly<old.IProvideFluidCodeDetailsComparer>): void;
use_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    get_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideLoader": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProvideLoader():
    TypeOnly<old.IProvideLoader>;
declare function use_current_InterfaceDeclaration_IProvideLoader(
    use: TypeOnly<current.IProvideLoader>): void;
use_current_InterfaceDeclaration_IProvideLoader(
    get_old_InterfaceDeclaration_IProvideLoader());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideLoader": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProvideLoader():
    TypeOnly<current.IProvideLoader>;
declare function use_old_InterfaceDeclaration_IProvideLoader(
    use: TypeOnly<old.IProvideLoader>): void;
use_old_InterfaceDeclaration_IProvideLoader(
    get_current_InterfaceDeclaration_IProvideLoader());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideRuntimeFactory": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProvideRuntimeFactory():
    TypeOnly<old.IProvideRuntimeFactory>;
declare function use_current_InterfaceDeclaration_IProvideRuntimeFactory(
    use: TypeOnly<current.IProvideRuntimeFactory>): void;
use_current_InterfaceDeclaration_IProvideRuntimeFactory(
    get_old_InterfaceDeclaration_IProvideRuntimeFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideRuntimeFactory": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProvideRuntimeFactory():
    TypeOnly<current.IProvideRuntimeFactory>;
declare function use_old_InterfaceDeclaration_IProvideRuntimeFactory(
    use: TypeOnly<old.IProvideRuntimeFactory>): void;
use_old_InterfaceDeclaration_IProvideRuntimeFactory(
    get_current_InterfaceDeclaration_IProvideRuntimeFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IResolvedFluidCodeDetails": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IResolvedFluidCodeDetails():
    TypeOnly<old.IResolvedFluidCodeDetails>;
declare function use_current_InterfaceDeclaration_IResolvedFluidCodeDetails(
    use: TypeOnly<current.IResolvedFluidCodeDetails>): void;
use_current_InterfaceDeclaration_IResolvedFluidCodeDetails(
    get_old_InterfaceDeclaration_IResolvedFluidCodeDetails());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IResolvedFluidCodeDetails": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IResolvedFluidCodeDetails():
    TypeOnly<current.IResolvedFluidCodeDetails>;
declare function use_old_InterfaceDeclaration_IResolvedFluidCodeDetails(
    use: TypeOnly<old.IResolvedFluidCodeDetails>): void;
use_old_InterfaceDeclaration_IResolvedFluidCodeDetails(
    get_current_InterfaceDeclaration_IResolvedFluidCodeDetails());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRuntime": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IRuntime():
    TypeOnly<old.IRuntime>;
declare function use_current_InterfaceDeclaration_IRuntime(
    use: TypeOnly<current.IRuntime>): void;
use_current_InterfaceDeclaration_IRuntime(
    get_old_InterfaceDeclaration_IRuntime());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRuntime": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IRuntime():
    TypeOnly<current.IRuntime>;
declare function use_old_InterfaceDeclaration_IRuntime(
    use: TypeOnly<old.IRuntime>): void;
use_old_InterfaceDeclaration_IRuntime(
    get_current_InterfaceDeclaration_IRuntime());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IRuntimeFactory": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_IRuntimeFactory():
    TypeOnly<typeof old.IRuntimeFactory>;
declare function use_current_VariableDeclaration_IRuntimeFactory(
    use: TypeOnly<typeof current.IRuntimeFactory>): void;
use_current_VariableDeclaration_IRuntimeFactory(
    get_old_VariableDeclaration_IRuntimeFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IRuntimeFactory": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_IRuntimeFactory():
    TypeOnly<typeof current.IRuntimeFactory>;
declare function use_old_VariableDeclaration_IRuntimeFactory(
    use: TypeOnly<typeof old.IRuntimeFactory>): void;
use_old_VariableDeclaration_IRuntimeFactory(
    get_current_VariableDeclaration_IRuntimeFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRuntimeFactory": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IRuntimeFactory():
    TypeOnly<old.IRuntimeFactory>;
declare function use_current_InterfaceDeclaration_IRuntimeFactory(
    use: TypeOnly<current.IRuntimeFactory>): void;
use_current_InterfaceDeclaration_IRuntimeFactory(
    get_old_InterfaceDeclaration_IRuntimeFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRuntimeFactory": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IRuntimeFactory():
    TypeOnly<current.IRuntimeFactory>;
declare function use_old_InterfaceDeclaration_IRuntimeFactory(
    use: TypeOnly<old.IRuntimeFactory>): void;
use_old_InterfaceDeclaration_IRuntimeFactory(
    get_current_InterfaceDeclaration_IRuntimeFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISelf": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISelf():
    TypeOnly<old.ISelf>;
declare function use_current_InterfaceDeclaration_ISelf(
    use: TypeOnly<current.ISelf>): void;
use_current_InterfaceDeclaration_ISelf(
    get_old_InterfaceDeclaration_ISelf());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISelf": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISelf():
    TypeOnly<current.ISelf>;
declare function use_old_InterfaceDeclaration_ISelf(
    use: TypeOnly<old.ISelf>): void;
use_old_InterfaceDeclaration_ISelf(
    get_current_InterfaceDeclaration_ISelf());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISnapshotTreeWithBlobContents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISnapshotTreeWithBlobContents():
    TypeOnly<old.ISnapshotTreeWithBlobContents>;
declare function use_current_InterfaceDeclaration_ISnapshotTreeWithBlobContents(
    use: TypeOnly<current.ISnapshotTreeWithBlobContents>): void;
use_current_InterfaceDeclaration_ISnapshotTreeWithBlobContents(
    get_old_InterfaceDeclaration_ISnapshotTreeWithBlobContents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISnapshotTreeWithBlobContents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISnapshotTreeWithBlobContents():
    TypeOnly<current.ISnapshotTreeWithBlobContents>;
declare function use_old_InterfaceDeclaration_ISnapshotTreeWithBlobContents(
    use: TypeOnly<old.ISnapshotTreeWithBlobContents>): void;
use_old_InterfaceDeclaration_ISnapshotTreeWithBlobContents(
    get_current_InterfaceDeclaration_ISnapshotTreeWithBlobContents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IThrottlingWarning": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IThrottlingWarning():
    TypeOnly<old.IThrottlingWarning>;
declare function use_current_InterfaceDeclaration_IThrottlingWarning(
    use: TypeOnly<current.IThrottlingWarning>): void;
use_current_InterfaceDeclaration_IThrottlingWarning(
    get_old_InterfaceDeclaration_IThrottlingWarning());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IThrottlingWarning": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IThrottlingWarning():
    TypeOnly<current.IThrottlingWarning>;
declare function use_old_InterfaceDeclaration_IThrottlingWarning(
    use: TypeOnly<old.IThrottlingWarning>): void;
use_old_InterfaceDeclaration_IThrottlingWarning(
    get_current_InterfaceDeclaration_IThrottlingWarning());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IUsageError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IUsageError():
    TypeOnly<old.IUsageError>;
declare function use_current_InterfaceDeclaration_IUsageError(
    use: TypeOnly<current.IUsageError>): void;
use_current_InterfaceDeclaration_IUsageError(
    get_old_InterfaceDeclaration_IUsageError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IUsageError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IUsageError():
    TypeOnly<current.IUsageError>;
declare function use_old_InterfaceDeclaration_IUsageError(
    use: TypeOnly<old.IUsageError>): void;
use_old_InterfaceDeclaration_IUsageError(
    get_current_InterfaceDeclaration_IUsageError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_LoaderHeader": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_LoaderHeader():
    TypeOnly<old.LoaderHeader>;
declare function use_current_EnumDeclaration_LoaderHeader(
    use: TypeOnly<current.LoaderHeader>): void;
use_current_EnumDeclaration_LoaderHeader(
    get_old_EnumDeclaration_LoaderHeader());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_LoaderHeader": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_LoaderHeader():
    TypeOnly<current.LoaderHeader>;
declare function use_old_EnumDeclaration_LoaderHeader(
    use: TypeOnly<old.LoaderHeader>): void;
use_old_EnumDeclaration_LoaderHeader(
    get_current_EnumDeclaration_LoaderHeader());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ReadOnlyInfo": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ReadOnlyInfo():
    TypeOnly<old.ReadOnlyInfo>;
declare function use_current_TypeAliasDeclaration_ReadOnlyInfo(
    use: TypeOnly<current.ReadOnlyInfo>): void;
use_current_TypeAliasDeclaration_ReadOnlyInfo(
    get_old_TypeAliasDeclaration_ReadOnlyInfo());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ReadOnlyInfo": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ReadOnlyInfo():
    TypeOnly<current.ReadOnlyInfo>;
declare function use_old_TypeAliasDeclaration_ReadOnlyInfo(
    use: TypeOnly<old.ReadOnlyInfo>): void;
use_old_TypeAliasDeclaration_ReadOnlyInfo(
    get_current_TypeAliasDeclaration_ReadOnlyInfo());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isFluidBrowserPackage": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_isFluidBrowserPackage():
    TypeOnly<typeof old.isFluidBrowserPackage>;
declare function use_current_VariableDeclaration_isFluidBrowserPackage(
    use: TypeOnly<typeof current.isFluidBrowserPackage>): void;
use_current_VariableDeclaration_isFluidBrowserPackage(
    get_old_VariableDeclaration_isFluidBrowserPackage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isFluidBrowserPackage": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_isFluidBrowserPackage():
    TypeOnly<typeof current.isFluidBrowserPackage>;
declare function use_old_VariableDeclaration_isFluidBrowserPackage(
    use: TypeOnly<typeof old.isFluidBrowserPackage>): void;
use_old_VariableDeclaration_isFluidBrowserPackage(
    get_current_VariableDeclaration_isFluidBrowserPackage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isFluidCodeDetails": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_isFluidCodeDetails():
    TypeOnly<typeof old.isFluidCodeDetails>;
declare function use_current_VariableDeclaration_isFluidCodeDetails(
    use: TypeOnly<typeof current.isFluidCodeDetails>): void;
use_current_VariableDeclaration_isFluidCodeDetails(
    get_old_VariableDeclaration_isFluidCodeDetails());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isFluidCodeDetails": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_isFluidCodeDetails():
    TypeOnly<typeof current.isFluidCodeDetails>;
declare function use_old_VariableDeclaration_isFluidCodeDetails(
    use: TypeOnly<typeof old.isFluidCodeDetails>): void;
use_old_VariableDeclaration_isFluidCodeDetails(
    get_current_VariableDeclaration_isFluidCodeDetails());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isFluidPackage": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_isFluidPackage():
    TypeOnly<typeof old.isFluidPackage>;
declare function use_current_VariableDeclaration_isFluidPackage(
    use: TypeOnly<typeof current.isFluidPackage>): void;
use_current_VariableDeclaration_isFluidPackage(
    get_old_VariableDeclaration_isFluidPackage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isFluidPackage": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_isFluidPackage():
    TypeOnly<typeof current.isFluidPackage>;
declare function use_old_VariableDeclaration_isFluidPackage(
    use: TypeOnly<typeof old.isFluidPackage>): void;
use_old_VariableDeclaration_isFluidPackage(
    get_current_VariableDeclaration_isFluidPackage());
