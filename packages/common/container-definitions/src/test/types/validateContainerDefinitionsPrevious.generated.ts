/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "@fluidframework/container-definitions-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_AttachState": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_AttachState():
    TypeOnly<old.AttachState>;
declare function use_current_EnumDeclaration_AttachState(
    use: TypeOnly<current.AttachState>);
use_current_EnumDeclaration_AttachState(
    get_old_EnumDeclaration_AttachState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_AttachState": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_AttachState():
    TypeOnly<current.AttachState>;
declare function use_old_EnumDeclaration_AttachState(
    use: TypeOnly<old.AttachState>);
use_old_EnumDeclaration_AttachState(
    get_current_EnumDeclaration_AttachState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConnectionState():
    TypeOnly<old.ConnectionState>;
declare function use_current_TypeAliasDeclaration_ConnectionState(
    use: TypeOnly<current.ConnectionState>);
use_current_TypeAliasDeclaration_ConnectionState(
    get_old_TypeAliasDeclaration_ConnectionState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConnectionState():
    TypeOnly<current.ConnectionState>;
declare function use_old_TypeAliasDeclaration_ConnectionState(
    use: TypeOnly<old.ConnectionState>);
use_old_TypeAliasDeclaration_ConnectionState(
    get_current_TypeAliasDeclaration_ConnectionState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.CatchingUp": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConnectionState_CatchingUp():
    TypeOnly<old.ConnectionState.CatchingUp>;
declare function use_current_TypeAliasDeclaration_ConnectionState_CatchingUp(
    use: TypeOnly<current.ConnectionState.CatchingUp>);
use_current_TypeAliasDeclaration_ConnectionState_CatchingUp(
    get_old_TypeAliasDeclaration_ConnectionState_CatchingUp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.CatchingUp": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConnectionState_CatchingUp():
    TypeOnly<current.ConnectionState.CatchingUp>;
declare function use_old_TypeAliasDeclaration_ConnectionState_CatchingUp(
    use: TypeOnly<old.ConnectionState.CatchingUp>);
use_old_TypeAliasDeclaration_ConnectionState_CatchingUp(
    get_current_TypeAliasDeclaration_ConnectionState_CatchingUp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.Connected": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConnectionState_Connected():
    TypeOnly<old.ConnectionState.Connected>;
declare function use_current_TypeAliasDeclaration_ConnectionState_Connected(
    use: TypeOnly<current.ConnectionState.Connected>);
use_current_TypeAliasDeclaration_ConnectionState_Connected(
    get_old_TypeAliasDeclaration_ConnectionState_Connected());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.Connected": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConnectionState_Connected():
    TypeOnly<current.ConnectionState.Connected>;
declare function use_old_TypeAliasDeclaration_ConnectionState_Connected(
    use: TypeOnly<old.ConnectionState.Connected>);
use_old_TypeAliasDeclaration_ConnectionState_Connected(
    get_current_TypeAliasDeclaration_ConnectionState_Connected());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.Disconnected": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConnectionState_Disconnected():
    TypeOnly<old.ConnectionState.Disconnected>;
declare function use_current_TypeAliasDeclaration_ConnectionState_Disconnected(
    use: TypeOnly<current.ConnectionState.Disconnected>);
use_current_TypeAliasDeclaration_ConnectionState_Disconnected(
    get_old_TypeAliasDeclaration_ConnectionState_Disconnected());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.Disconnected": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConnectionState_Disconnected():
    TypeOnly<current.ConnectionState.Disconnected>;
declare function use_old_TypeAliasDeclaration_ConnectionState_Disconnected(
    use: TypeOnly<old.ConnectionState.Disconnected>);
use_old_TypeAliasDeclaration_ConnectionState_Disconnected(
    get_current_TypeAliasDeclaration_ConnectionState_Disconnected());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.EstablishingConnection": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConnectionState_EstablishingConnection():
    TypeOnly<old.ConnectionState.EstablishingConnection>;
declare function use_current_TypeAliasDeclaration_ConnectionState_EstablishingConnection(
    use: TypeOnly<current.ConnectionState.EstablishingConnection>);
use_current_TypeAliasDeclaration_ConnectionState_EstablishingConnection(
    get_old_TypeAliasDeclaration_ConnectionState_EstablishingConnection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectionState.EstablishingConnection": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConnectionState_EstablishingConnection():
    TypeOnly<current.ConnectionState.EstablishingConnection>;
declare function use_old_TypeAliasDeclaration_ConnectionState_EstablishingConnection(
    use: TypeOnly<old.ConnectionState.EstablishingConnection>);
use_old_TypeAliasDeclaration_ConnectionState_EstablishingConnection(
    get_current_TypeAliasDeclaration_ConnectionState_EstablishingConnection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ContainerErrorType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_ContainerErrorType():
    TypeOnly<old.ContainerErrorType>;
declare function use_current_EnumDeclaration_ContainerErrorType(
    use: TypeOnly<current.ContainerErrorType>);
use_current_EnumDeclaration_ContainerErrorType(
    get_old_EnumDeclaration_ContainerErrorType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ContainerErrorType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_ContainerErrorType():
    TypeOnly<current.ContainerErrorType>;
declare function use_old_EnumDeclaration_ContainerErrorType(
    use: TypeOnly<old.ContainerErrorType>);
use_old_EnumDeclaration_ContainerErrorType(
    get_current_EnumDeclaration_ContainerErrorType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerWarning": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerWarning():
    TypeOnly<old.ContainerWarning>;
declare function use_current_InterfaceDeclaration_ContainerWarning(
    use: TypeOnly<current.ContainerWarning>);
use_current_InterfaceDeclaration_ContainerWarning(
    get_old_InterfaceDeclaration_ContainerWarning());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerWarning": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerWarning():
    TypeOnly<current.ContainerWarning>;
declare function use_old_InterfaceDeclaration_ContainerWarning(
    use: TypeOnly<old.ContainerWarning>);
use_old_InterfaceDeclaration_ContainerWarning(
    get_current_InterfaceDeclaration_ContainerWarning());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAudience": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAudience():
    TypeOnly<old.IAudience>;
declare function use_current_InterfaceDeclaration_IAudience(
    use: TypeOnly<current.IAudience>);
use_current_InterfaceDeclaration_IAudience(
    get_old_InterfaceDeclaration_IAudience());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAudience": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAudience():
    TypeOnly<current.IAudience>;
declare function use_old_InterfaceDeclaration_IAudience(
    use: TypeOnly<old.IAudience>);
use_old_InterfaceDeclaration_IAudience(
    get_current_InterfaceDeclaration_IAudience());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAudienceOwner": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAudienceOwner():
    TypeOnly<old.IAudienceOwner>;
declare function use_current_InterfaceDeclaration_IAudienceOwner(
    use: TypeOnly<current.IAudienceOwner>);
use_current_InterfaceDeclaration_IAudienceOwner(
    get_old_InterfaceDeclaration_IAudienceOwner());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAudienceOwner": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAudienceOwner():
    TypeOnly<current.IAudienceOwner>;
declare function use_old_InterfaceDeclaration_IAudienceOwner(
    use: TypeOnly<old.IAudienceOwner>);
use_old_InterfaceDeclaration_IAudienceOwner(
    get_current_InterfaceDeclaration_IAudienceOwner());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBatchMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IBatchMessage():
    TypeOnly<old.IBatchMessage>;
declare function use_current_InterfaceDeclaration_IBatchMessage(
    use: TypeOnly<current.IBatchMessage>);
use_current_InterfaceDeclaration_IBatchMessage(
    get_old_InterfaceDeclaration_IBatchMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBatchMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IBatchMessage():
    TypeOnly<current.IBatchMessage>;
declare function use_old_InterfaceDeclaration_IBatchMessage(
    use: TypeOnly<old.IBatchMessage>);
use_old_InterfaceDeclaration_IBatchMessage(
    get_current_InterfaceDeclaration_IBatchMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICodeAllowList": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICodeAllowList():
    TypeOnly<old.ICodeAllowList>;
declare function use_current_InterfaceDeclaration_ICodeAllowList(
    use: TypeOnly<current.ICodeAllowList>);
use_current_InterfaceDeclaration_ICodeAllowList(
    get_old_InterfaceDeclaration_ICodeAllowList());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICodeAllowList": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICodeAllowList():
    TypeOnly<current.ICodeAllowList>;
declare function use_old_InterfaceDeclaration_ICodeAllowList(
    use: TypeOnly<old.ICodeAllowList>);
use_old_InterfaceDeclaration_ICodeAllowList(
    get_current_InterfaceDeclaration_ICodeAllowList());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICodeDetailsLoader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICodeDetailsLoader():
    TypeOnly<old.ICodeDetailsLoader>;
declare function use_current_InterfaceDeclaration_ICodeDetailsLoader(
    use: TypeOnly<current.ICodeDetailsLoader>);
use_current_InterfaceDeclaration_ICodeDetailsLoader(
    get_old_InterfaceDeclaration_ICodeDetailsLoader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICodeDetailsLoader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICodeDetailsLoader():
    TypeOnly<current.ICodeDetailsLoader>;
declare function use_old_InterfaceDeclaration_ICodeDetailsLoader(
    use: TypeOnly<old.ICodeDetailsLoader>);
use_old_InterfaceDeclaration_ICodeDetailsLoader(
    get_current_InterfaceDeclaration_ICodeDetailsLoader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnectionDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConnectionDetails():
    TypeOnly<old.IConnectionDetails>;
declare function use_current_InterfaceDeclaration_IConnectionDetails(
    use: TypeOnly<current.IConnectionDetails>);
use_current_InterfaceDeclaration_IConnectionDetails(
    get_old_InterfaceDeclaration_IConnectionDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnectionDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConnectionDetails():
    TypeOnly<current.IConnectionDetails>;
declare function use_old_InterfaceDeclaration_IConnectionDetails(
    use: TypeOnly<old.IConnectionDetails>);
use_old_InterfaceDeclaration_IConnectionDetails(
    get_current_InterfaceDeclaration_IConnectionDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainer():
    TypeOnly<old.IContainer>;
declare function use_current_InterfaceDeclaration_IContainer(
    use: TypeOnly<current.IContainer>);
use_current_InterfaceDeclaration_IContainer(
    get_old_InterfaceDeclaration_IContainer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainer():
    TypeOnly<current.IContainer>;
declare function use_old_InterfaceDeclaration_IContainer(
    use: TypeOnly<old.IContainer>);
use_old_InterfaceDeclaration_IContainer(
    get_current_InterfaceDeclaration_IContainer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerContext():
    TypeOnly<old.IContainerContext>;
declare function use_current_InterfaceDeclaration_IContainerContext(
    use: TypeOnly<current.IContainerContext>);
use_current_InterfaceDeclaration_IContainerContext(
    get_old_InterfaceDeclaration_IContainerContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerContext():
    TypeOnly<current.IContainerContext>;
declare function use_old_InterfaceDeclaration_IContainerContext(
    use: TypeOnly<old.IContainerContext>);
use_old_InterfaceDeclaration_IContainerContext(
    get_current_InterfaceDeclaration_IContainerContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerEvents():
    TypeOnly<old.IContainerEvents>;
declare function use_current_InterfaceDeclaration_IContainerEvents(
    use: TypeOnly<current.IContainerEvents>);
use_current_InterfaceDeclaration_IContainerEvents(
    get_old_InterfaceDeclaration_IContainerEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerEvents():
    TypeOnly<current.IContainerEvents>;
declare function use_old_InterfaceDeclaration_IContainerEvents(
    use: TypeOnly<old.IContainerEvents>);
use_old_InterfaceDeclaration_IContainerEvents(
    get_current_InterfaceDeclaration_IContainerEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerLoadMode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerLoadMode():
    TypeOnly<old.IContainerLoadMode>;
declare function use_current_InterfaceDeclaration_IContainerLoadMode(
    use: TypeOnly<current.IContainerLoadMode>);
use_current_InterfaceDeclaration_IContainerLoadMode(
    get_old_InterfaceDeclaration_IContainerLoadMode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerLoadMode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerLoadMode():
    TypeOnly<current.IContainerLoadMode>;
declare function use_old_InterfaceDeclaration_IContainerLoadMode(
    use: TypeOnly<old.IContainerLoadMode>);
use_old_InterfaceDeclaration_IContainerLoadMode(
    get_current_InterfaceDeclaration_IContainerLoadMode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ICriticalContainerError": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ICriticalContainerError():
    TypeOnly<old.ICriticalContainerError>;
declare function use_current_TypeAliasDeclaration_ICriticalContainerError(
    use: TypeOnly<current.ICriticalContainerError>);
use_current_TypeAliasDeclaration_ICriticalContainerError(
    get_old_TypeAliasDeclaration_ICriticalContainerError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ICriticalContainerError": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ICriticalContainerError():
    TypeOnly<current.ICriticalContainerError>;
declare function use_old_TypeAliasDeclaration_ICriticalContainerError(
    use: TypeOnly<old.ICriticalContainerError>);
use_old_TypeAliasDeclaration_ICriticalContainerError(
    get_current_TypeAliasDeclaration_ICriticalContainerError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaHandlerStrategy": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeltaHandlerStrategy():
    TypeOnly<old.IDeltaHandlerStrategy>;
declare function use_current_InterfaceDeclaration_IDeltaHandlerStrategy(
    use: TypeOnly<current.IDeltaHandlerStrategy>);
use_current_InterfaceDeclaration_IDeltaHandlerStrategy(
    get_old_InterfaceDeclaration_IDeltaHandlerStrategy());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaHandlerStrategy": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeltaHandlerStrategy():
    TypeOnly<current.IDeltaHandlerStrategy>;
declare function use_old_InterfaceDeclaration_IDeltaHandlerStrategy(
    use: TypeOnly<old.IDeltaHandlerStrategy>);
use_old_InterfaceDeclaration_IDeltaHandlerStrategy(
    get_current_InterfaceDeclaration_IDeltaHandlerStrategy());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeltaManager():
    TypeOnly<old.IDeltaManager<any,any>>;
declare function use_current_InterfaceDeclaration_IDeltaManager(
    use: TypeOnly<current.IDeltaManager<any,any>>);
use_current_InterfaceDeclaration_IDeltaManager(
    get_old_InterfaceDeclaration_IDeltaManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeltaManager():
    TypeOnly<current.IDeltaManager<any,any>>;
declare function use_old_InterfaceDeclaration_IDeltaManager(
    use: TypeOnly<old.IDeltaManager<any,any>>);
use_old_InterfaceDeclaration_IDeltaManager(
    get_current_InterfaceDeclaration_IDeltaManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaManagerEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeltaManagerEvents():
    TypeOnly<old.IDeltaManagerEvents>;
declare function use_current_InterfaceDeclaration_IDeltaManagerEvents(
    use: TypeOnly<current.IDeltaManagerEvents>);
use_current_InterfaceDeclaration_IDeltaManagerEvents(
    get_old_InterfaceDeclaration_IDeltaManagerEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaManagerEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeltaManagerEvents():
    TypeOnly<current.IDeltaManagerEvents>;
declare function use_old_InterfaceDeclaration_IDeltaManagerEvents(
    use: TypeOnly<old.IDeltaManagerEvents>);
use_old_InterfaceDeclaration_IDeltaManagerEvents(
    get_current_InterfaceDeclaration_IDeltaManagerEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaQueue": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeltaQueue():
    TypeOnly<old.IDeltaQueue<any>>;
declare function use_current_InterfaceDeclaration_IDeltaQueue(
    use: TypeOnly<current.IDeltaQueue<any>>);
use_current_InterfaceDeclaration_IDeltaQueue(
    get_old_InterfaceDeclaration_IDeltaQueue());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaQueue": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeltaQueue():
    TypeOnly<current.IDeltaQueue<any>>;
declare function use_old_InterfaceDeclaration_IDeltaQueue(
    use: TypeOnly<old.IDeltaQueue<any>>);
use_old_InterfaceDeclaration_IDeltaQueue(
    get_current_InterfaceDeclaration_IDeltaQueue());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaQueueEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeltaQueueEvents():
    TypeOnly<old.IDeltaQueueEvents<any>>;
declare function use_current_InterfaceDeclaration_IDeltaQueueEvents(
    use: TypeOnly<current.IDeltaQueueEvents<any>>);
use_current_InterfaceDeclaration_IDeltaQueueEvents(
    get_old_InterfaceDeclaration_IDeltaQueueEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaQueueEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeltaQueueEvents():
    TypeOnly<current.IDeltaQueueEvents<any>>;
declare function use_old_InterfaceDeclaration_IDeltaQueueEvents(
    use: TypeOnly<old.IDeltaQueueEvents<any>>);
use_old_InterfaceDeclaration_IDeltaQueueEvents(
    get_current_InterfaceDeclaration_IDeltaQueueEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaSender": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeltaSender():
    TypeOnly<old.IDeltaSender>;
declare function use_current_InterfaceDeclaration_IDeltaSender(
    use: TypeOnly<current.IDeltaSender>);
use_current_InterfaceDeclaration_IDeltaSender(
    get_old_InterfaceDeclaration_IDeltaSender());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaSender": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeltaSender():
    TypeOnly<current.IDeltaSender>;
declare function use_old_InterfaceDeclaration_IDeltaSender(
    use: TypeOnly<old.IDeltaSender>);
use_old_InterfaceDeclaration_IDeltaSender(
    get_current_InterfaceDeclaration_IDeltaSender());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IErrorBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IErrorBase():
    TypeOnly<old.IErrorBase>;
declare function use_current_InterfaceDeclaration_IErrorBase(
    use: TypeOnly<current.IErrorBase>);
use_current_InterfaceDeclaration_IErrorBase(
    get_old_InterfaceDeclaration_IErrorBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IErrorBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IErrorBase():
    TypeOnly<current.IErrorBase>;
declare function use_old_InterfaceDeclaration_IErrorBase(
    use: TypeOnly<old.IErrorBase>);
use_old_InterfaceDeclaration_IErrorBase(
    get_current_InterfaceDeclaration_IErrorBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidBrowserPackage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidBrowserPackage():
    TypeOnly<old.IFluidBrowserPackage>;
declare function use_current_InterfaceDeclaration_IFluidBrowserPackage(
    use: TypeOnly<current.IFluidBrowserPackage>);
use_current_InterfaceDeclaration_IFluidBrowserPackage(
    get_old_InterfaceDeclaration_IFluidBrowserPackage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidBrowserPackage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidBrowserPackage():
    TypeOnly<current.IFluidBrowserPackage>;
declare function use_old_InterfaceDeclaration_IFluidBrowserPackage(
    use: TypeOnly<old.IFluidBrowserPackage>);
use_old_InterfaceDeclaration_IFluidBrowserPackage(
    get_current_InterfaceDeclaration_IFluidBrowserPackage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidBrowserPackageEnvironment": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidBrowserPackageEnvironment():
    TypeOnly<old.IFluidBrowserPackageEnvironment>;
declare function use_current_InterfaceDeclaration_IFluidBrowserPackageEnvironment(
    use: TypeOnly<current.IFluidBrowserPackageEnvironment>);
use_current_InterfaceDeclaration_IFluidBrowserPackageEnvironment(
    get_old_InterfaceDeclaration_IFluidBrowserPackageEnvironment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidBrowserPackageEnvironment": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidBrowserPackageEnvironment():
    TypeOnly<current.IFluidBrowserPackageEnvironment>;
declare function use_old_InterfaceDeclaration_IFluidBrowserPackageEnvironment(
    use: TypeOnly<old.IFluidBrowserPackageEnvironment>);
use_old_InterfaceDeclaration_IFluidBrowserPackageEnvironment(
    get_current_InterfaceDeclaration_IFluidBrowserPackageEnvironment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidCodeDetails():
    TypeOnly<old.IFluidCodeDetails>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetails(
    use: TypeOnly<current.IFluidCodeDetails>);
use_current_InterfaceDeclaration_IFluidCodeDetails(
    get_old_InterfaceDeclaration_IFluidCodeDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidCodeDetails():
    TypeOnly<current.IFluidCodeDetails>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetails(
    use: TypeOnly<old.IFluidCodeDetails>);
use_old_InterfaceDeclaration_IFluidCodeDetails(
    get_current_InterfaceDeclaration_IFluidCodeDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidCodeDetailsComparer": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<typeof old.IFluidCodeDetailsComparer>;
declare function use_current_VariableDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<typeof current.IFluidCodeDetailsComparer>);
use_current_VariableDeclaration_IFluidCodeDetailsComparer(
    get_old_VariableDeclaration_IFluidCodeDetailsComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidCodeDetailsComparer": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<typeof current.IFluidCodeDetailsComparer>;
declare function use_old_VariableDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<typeof old.IFluidCodeDetailsComparer>);
use_old_VariableDeclaration_IFluidCodeDetailsComparer(
    get_current_VariableDeclaration_IFluidCodeDetailsComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsComparer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<old.IFluidCodeDetailsComparer>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<current.IFluidCodeDetailsComparer>);
use_current_InterfaceDeclaration_IFluidCodeDetailsComparer(
    get_old_InterfaceDeclaration_IFluidCodeDetailsComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsComparer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<current.IFluidCodeDetailsComparer>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<old.IFluidCodeDetailsComparer>);
use_old_InterfaceDeclaration_IFluidCodeDetailsComparer(
    get_current_InterfaceDeclaration_IFluidCodeDetailsComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidCodeDetailsConfig():
    TypeOnly<old.IFluidCodeDetailsConfig>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetailsConfig(
    use: TypeOnly<current.IFluidCodeDetailsConfig>);
use_current_InterfaceDeclaration_IFluidCodeDetailsConfig(
    get_old_InterfaceDeclaration_IFluidCodeDetailsConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidCodeDetailsConfig():
    TypeOnly<current.IFluidCodeDetailsConfig>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetailsConfig(
    use: TypeOnly<old.IFluidCodeDetailsConfig>);
use_old_InterfaceDeclaration_IFluidCodeDetailsConfig(
    get_current_InterfaceDeclaration_IFluidCodeDetailsConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeResolver": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidCodeResolver():
    TypeOnly<old.IFluidCodeResolver>;
declare function use_current_InterfaceDeclaration_IFluidCodeResolver(
    use: TypeOnly<current.IFluidCodeResolver>);
use_current_InterfaceDeclaration_IFluidCodeResolver(
    get_old_InterfaceDeclaration_IFluidCodeResolver());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeResolver": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidCodeResolver():
    TypeOnly<current.IFluidCodeResolver>;
declare function use_old_InterfaceDeclaration_IFluidCodeResolver(
    use: TypeOnly<old.IFluidCodeResolver>);
use_old_InterfaceDeclaration_IFluidCodeResolver(
    get_current_InterfaceDeclaration_IFluidCodeResolver());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidModule": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidModule():
    TypeOnly<old.IFluidModule>;
declare function use_current_InterfaceDeclaration_IFluidModule(
    use: TypeOnly<current.IFluidModule>);
use_current_InterfaceDeclaration_IFluidModule(
    get_old_InterfaceDeclaration_IFluidModule());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidModule": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidModule():
    TypeOnly<current.IFluidModule>;
declare function use_old_InterfaceDeclaration_IFluidModule(
    use: TypeOnly<old.IFluidModule>);
use_old_InterfaceDeclaration_IFluidModule(
    get_current_InterfaceDeclaration_IFluidModule());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidModuleWithDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidModuleWithDetails():
    TypeOnly<old.IFluidModuleWithDetails>;
declare function use_current_InterfaceDeclaration_IFluidModuleWithDetails(
    use: TypeOnly<current.IFluidModuleWithDetails>);
use_current_InterfaceDeclaration_IFluidModuleWithDetails(
    get_old_InterfaceDeclaration_IFluidModuleWithDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidModuleWithDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidModuleWithDetails():
    TypeOnly<current.IFluidModuleWithDetails>;
declare function use_old_InterfaceDeclaration_IFluidModuleWithDetails(
    use: TypeOnly<old.IFluidModuleWithDetails>);
use_old_InterfaceDeclaration_IFluidModuleWithDetails(
    get_current_InterfaceDeclaration_IFluidModuleWithDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidPackage():
    TypeOnly<old.IFluidPackage>;
declare function use_current_InterfaceDeclaration_IFluidPackage(
    use: TypeOnly<current.IFluidPackage>);
use_current_InterfaceDeclaration_IFluidPackage(
    get_old_InterfaceDeclaration_IFluidPackage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidPackage():
    TypeOnly<current.IFluidPackage>;
declare function use_old_InterfaceDeclaration_IFluidPackage(
    use: TypeOnly<old.IFluidPackage>);
use_old_InterfaceDeclaration_IFluidPackage(
    get_current_InterfaceDeclaration_IFluidPackage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackageEnvironment": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidPackageEnvironment():
    TypeOnly<old.IFluidPackageEnvironment>;
declare function use_current_InterfaceDeclaration_IFluidPackageEnvironment(
    use: TypeOnly<current.IFluidPackageEnvironment>);
use_current_InterfaceDeclaration_IFluidPackageEnvironment(
    get_old_InterfaceDeclaration_IFluidPackageEnvironment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackageEnvironment": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidPackageEnvironment():
    TypeOnly<current.IFluidPackageEnvironment>;
declare function use_old_InterfaceDeclaration_IFluidPackageEnvironment(
    use: TypeOnly<old.IFluidPackageEnvironment>);
use_old_InterfaceDeclaration_IFluidPackageEnvironment(
    get_current_InterfaceDeclaration_IFluidPackageEnvironment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidTokenProvider": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidTokenProvider():
    TypeOnly<typeof old.IFluidTokenProvider>;
declare function use_current_VariableDeclaration_IFluidTokenProvider(
    use: TypeOnly<typeof current.IFluidTokenProvider>);
use_current_VariableDeclaration_IFluidTokenProvider(
    get_old_VariableDeclaration_IFluidTokenProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidTokenProvider": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidTokenProvider():
    TypeOnly<typeof current.IFluidTokenProvider>;
declare function use_old_VariableDeclaration_IFluidTokenProvider(
    use: TypeOnly<typeof old.IFluidTokenProvider>);
use_old_VariableDeclaration_IFluidTokenProvider(
    get_current_VariableDeclaration_IFluidTokenProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidTokenProvider": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidTokenProvider():
    TypeOnly<old.IFluidTokenProvider>;
declare function use_current_InterfaceDeclaration_IFluidTokenProvider(
    use: TypeOnly<current.IFluidTokenProvider>);
use_current_InterfaceDeclaration_IFluidTokenProvider(
    get_old_InterfaceDeclaration_IFluidTokenProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidTokenProvider": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidTokenProvider():
    TypeOnly<current.IFluidTokenProvider>;
declare function use_old_InterfaceDeclaration_IFluidTokenProvider(
    use: TypeOnly<old.IFluidTokenProvider>);
use_old_InterfaceDeclaration_IFluidTokenProvider(
    get_current_InterfaceDeclaration_IFluidTokenProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGenericError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGenericError():
    TypeOnly<old.IGenericError>;
declare function use_current_InterfaceDeclaration_IGenericError(
    use: TypeOnly<current.IGenericError>);
use_current_InterfaceDeclaration_IGenericError(
    get_old_InterfaceDeclaration_IGenericError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGenericError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGenericError():
    TypeOnly<current.IGenericError>;
declare function use_old_InterfaceDeclaration_IGenericError(
    use: TypeOnly<old.IGenericError>);
use_old_InterfaceDeclaration_IGenericError(
    get_current_InterfaceDeclaration_IGenericError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHostLoader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IHostLoader():
    TypeOnly<old.IHostLoader>;
declare function use_current_InterfaceDeclaration_IHostLoader(
    use: TypeOnly<current.IHostLoader>);
use_current_InterfaceDeclaration_IHostLoader(
    get_old_InterfaceDeclaration_IHostLoader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHostLoader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IHostLoader():
    TypeOnly<current.IHostLoader>;
declare function use_old_InterfaceDeclaration_IHostLoader(
    use: TypeOnly<old.IHostLoader>);
use_old_InterfaceDeclaration_IHostLoader(
    get_current_InterfaceDeclaration_IHostLoader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILoader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ILoader():
    TypeOnly<old.ILoader>;
declare function use_current_InterfaceDeclaration_ILoader(
    use: TypeOnly<current.ILoader>);
use_current_InterfaceDeclaration_ILoader(
    get_old_InterfaceDeclaration_ILoader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILoader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ILoader():
    TypeOnly<current.ILoader>;
declare function use_old_InterfaceDeclaration_ILoader(
    use: TypeOnly<old.ILoader>);
use_old_InterfaceDeclaration_ILoader(
    get_current_InterfaceDeclaration_ILoader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILoaderHeader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ILoaderHeader():
    TypeOnly<old.ILoaderHeader>;
declare function use_current_InterfaceDeclaration_ILoaderHeader(
    use: TypeOnly<current.ILoaderHeader>);
use_current_InterfaceDeclaration_ILoaderHeader(
    get_old_InterfaceDeclaration_ILoaderHeader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILoaderHeader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ILoaderHeader():
    TypeOnly<current.ILoaderHeader>;
declare function use_old_InterfaceDeclaration_ILoaderHeader(
    use: TypeOnly<old.ILoaderHeader>);
use_old_InterfaceDeclaration_ILoaderHeader(
    get_current_InterfaceDeclaration_ILoaderHeader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ILoaderOptions": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ILoaderOptions():
    TypeOnly<old.ILoaderOptions>;
declare function use_current_TypeAliasDeclaration_ILoaderOptions(
    use: TypeOnly<current.ILoaderOptions>);
use_current_TypeAliasDeclaration_ILoaderOptions(
    get_old_TypeAliasDeclaration_ILoaderOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ILoaderOptions": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ILoaderOptions():
    TypeOnly<current.ILoaderOptions>;
declare function use_old_TypeAliasDeclaration_ILoaderOptions(
    use: TypeOnly<old.ILoaderOptions>);
use_old_TypeAliasDeclaration_ILoaderOptions(
    get_current_TypeAliasDeclaration_ILoaderOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingLocalState": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPendingLocalState():
    TypeOnly<old.IPendingLocalState>;
declare function use_current_InterfaceDeclaration_IPendingLocalState(
    use: TypeOnly<current.IPendingLocalState>);
use_current_InterfaceDeclaration_IPendingLocalState(
    get_old_InterfaceDeclaration_IPendingLocalState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingLocalState": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPendingLocalState():
    TypeOnly<current.IPendingLocalState>;
declare function use_old_InterfaceDeclaration_IPendingLocalState(
    use: TypeOnly<old.IPendingLocalState>);
use_old_InterfaceDeclaration_IPendingLocalState(
    get_current_InterfaceDeclaration_IPendingLocalState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidCodeDetailsComparer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer():
    TypeOnly<old.IProvideFluidCodeDetailsComparer>;
declare function use_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    use: TypeOnly<current.IProvideFluidCodeDetailsComparer>);
use_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    get_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidCodeDetailsComparer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer():
    TypeOnly<current.IProvideFluidCodeDetailsComparer>;
declare function use_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    use: TypeOnly<old.IProvideFluidCodeDetailsComparer>);
use_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    get_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidTokenProvider": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidTokenProvider():
    TypeOnly<old.IProvideFluidTokenProvider>;
declare function use_current_InterfaceDeclaration_IProvideFluidTokenProvider(
    use: TypeOnly<current.IProvideFluidTokenProvider>);
use_current_InterfaceDeclaration_IProvideFluidTokenProvider(
    get_old_InterfaceDeclaration_IProvideFluidTokenProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidTokenProvider": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidTokenProvider():
    TypeOnly<current.IProvideFluidTokenProvider>;
declare function use_old_InterfaceDeclaration_IProvideFluidTokenProvider(
    use: TypeOnly<old.IProvideFluidTokenProvider>);
use_old_InterfaceDeclaration_IProvideFluidTokenProvider(
    get_current_InterfaceDeclaration_IProvideFluidTokenProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideLoader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideLoader():
    TypeOnly<old.IProvideLoader>;
declare function use_current_InterfaceDeclaration_IProvideLoader(
    use: TypeOnly<current.IProvideLoader>);
use_current_InterfaceDeclaration_IProvideLoader(
    get_old_InterfaceDeclaration_IProvideLoader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideLoader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideLoader():
    TypeOnly<current.IProvideLoader>;
declare function use_old_InterfaceDeclaration_IProvideLoader(
    use: TypeOnly<old.IProvideLoader>);
use_old_InterfaceDeclaration_IProvideLoader(
    get_current_InterfaceDeclaration_IProvideLoader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideRuntimeFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideRuntimeFactory():
    TypeOnly<old.IProvideRuntimeFactory>;
declare function use_current_InterfaceDeclaration_IProvideRuntimeFactory(
    use: TypeOnly<current.IProvideRuntimeFactory>);
use_current_InterfaceDeclaration_IProvideRuntimeFactory(
    get_old_InterfaceDeclaration_IProvideRuntimeFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideRuntimeFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideRuntimeFactory():
    TypeOnly<current.IProvideRuntimeFactory>;
declare function use_old_InterfaceDeclaration_IProvideRuntimeFactory(
    use: TypeOnly<old.IProvideRuntimeFactory>);
use_old_InterfaceDeclaration_IProvideRuntimeFactory(
    get_current_InterfaceDeclaration_IProvideRuntimeFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IResolvedFluidCodeDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IResolvedFluidCodeDetails():
    TypeOnly<old.IResolvedFluidCodeDetails>;
declare function use_current_InterfaceDeclaration_IResolvedFluidCodeDetails(
    use: TypeOnly<current.IResolvedFluidCodeDetails>);
use_current_InterfaceDeclaration_IResolvedFluidCodeDetails(
    get_old_InterfaceDeclaration_IResolvedFluidCodeDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IResolvedFluidCodeDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IResolvedFluidCodeDetails():
    TypeOnly<current.IResolvedFluidCodeDetails>;
declare function use_old_InterfaceDeclaration_IResolvedFluidCodeDetails(
    use: TypeOnly<old.IResolvedFluidCodeDetails>);
use_old_InterfaceDeclaration_IResolvedFluidCodeDetails(
    get_current_InterfaceDeclaration_IResolvedFluidCodeDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRuntime": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRuntime():
    TypeOnly<old.IRuntime>;
declare function use_current_InterfaceDeclaration_IRuntime(
    use: TypeOnly<current.IRuntime>);
use_current_InterfaceDeclaration_IRuntime(
    get_old_InterfaceDeclaration_IRuntime());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRuntime": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRuntime():
    TypeOnly<current.IRuntime>;
declare function use_old_InterfaceDeclaration_IRuntime(
    use: TypeOnly<old.IRuntime>);
use_old_InterfaceDeclaration_IRuntime(
    get_current_InterfaceDeclaration_IRuntime());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IRuntimeFactory": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IRuntimeFactory():
    TypeOnly<typeof old.IRuntimeFactory>;
declare function use_current_VariableDeclaration_IRuntimeFactory(
    use: TypeOnly<typeof current.IRuntimeFactory>);
use_current_VariableDeclaration_IRuntimeFactory(
    get_old_VariableDeclaration_IRuntimeFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IRuntimeFactory": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IRuntimeFactory():
    TypeOnly<typeof current.IRuntimeFactory>;
declare function use_old_VariableDeclaration_IRuntimeFactory(
    use: TypeOnly<typeof old.IRuntimeFactory>);
use_old_VariableDeclaration_IRuntimeFactory(
    get_current_VariableDeclaration_IRuntimeFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRuntimeFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRuntimeFactory():
    TypeOnly<old.IRuntimeFactory>;
declare function use_current_InterfaceDeclaration_IRuntimeFactory(
    use: TypeOnly<current.IRuntimeFactory>);
use_current_InterfaceDeclaration_IRuntimeFactory(
    get_old_InterfaceDeclaration_IRuntimeFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRuntimeFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRuntimeFactory():
    TypeOnly<current.IRuntimeFactory>;
declare function use_old_InterfaceDeclaration_IRuntimeFactory(
    use: TypeOnly<old.IRuntimeFactory>);
use_old_InterfaceDeclaration_IRuntimeFactory(
    get_current_InterfaceDeclaration_IRuntimeFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidBrowserPackage": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isFluidBrowserPackage():
    TypeOnly<typeof old.isFluidBrowserPackage>;
declare function use_current_VariableDeclaration_isFluidBrowserPackage(
    use: TypeOnly<typeof current.isFluidBrowserPackage>);
use_current_VariableDeclaration_isFluidBrowserPackage(
    get_old_VariableDeclaration_isFluidBrowserPackage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidBrowserPackage": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isFluidBrowserPackage():
    TypeOnly<typeof current.isFluidBrowserPackage>;
declare function use_old_VariableDeclaration_isFluidBrowserPackage(
    use: TypeOnly<typeof old.isFluidBrowserPackage>);
use_old_VariableDeclaration_isFluidBrowserPackage(
    get_current_VariableDeclaration_isFluidBrowserPackage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidCodeDetails": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isFluidCodeDetails():
    TypeOnly<typeof old.isFluidCodeDetails>;
declare function use_current_VariableDeclaration_isFluidCodeDetails(
    use: TypeOnly<typeof current.isFluidCodeDetails>);
use_current_VariableDeclaration_isFluidCodeDetails(
    get_old_VariableDeclaration_isFluidCodeDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidCodeDetails": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isFluidCodeDetails():
    TypeOnly<typeof current.isFluidCodeDetails>;
declare function use_old_VariableDeclaration_isFluidCodeDetails(
    use: TypeOnly<typeof old.isFluidCodeDetails>);
use_old_VariableDeclaration_isFluidCodeDetails(
    get_current_VariableDeclaration_isFluidCodeDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidPackage": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isFluidPackage():
    TypeOnly<typeof old.isFluidPackage>;
declare function use_current_VariableDeclaration_isFluidPackage(
    use: TypeOnly<typeof current.isFluidPackage>);
use_current_VariableDeclaration_isFluidPackage(
    get_old_VariableDeclaration_isFluidPackage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidPackage": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isFluidPackage():
    TypeOnly<typeof current.isFluidPackage>;
declare function use_old_VariableDeclaration_isFluidPackage(
    use: TypeOnly<typeof old.isFluidPackage>);
use_old_VariableDeclaration_isFluidPackage(
    get_current_VariableDeclaration_isFluidPackage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISnapshotTreeWithBlobContents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISnapshotTreeWithBlobContents():
    TypeOnly<old.ISnapshotTreeWithBlobContents>;
declare function use_current_InterfaceDeclaration_ISnapshotTreeWithBlobContents(
    use: TypeOnly<current.ISnapshotTreeWithBlobContents>);
use_current_InterfaceDeclaration_ISnapshotTreeWithBlobContents(
    get_old_InterfaceDeclaration_ISnapshotTreeWithBlobContents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISnapshotTreeWithBlobContents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISnapshotTreeWithBlobContents():
    TypeOnly<current.ISnapshotTreeWithBlobContents>;
declare function use_old_InterfaceDeclaration_ISnapshotTreeWithBlobContents(
    use: TypeOnly<old.ISnapshotTreeWithBlobContents>);
use_old_InterfaceDeclaration_ISnapshotTreeWithBlobContents(
    get_current_InterfaceDeclaration_ISnapshotTreeWithBlobContents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottlingWarning": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IThrottlingWarning():
    TypeOnly<old.IThrottlingWarning>;
declare function use_current_InterfaceDeclaration_IThrottlingWarning(
    use: TypeOnly<current.IThrottlingWarning>);
use_current_InterfaceDeclaration_IThrottlingWarning(
    get_old_InterfaceDeclaration_IThrottlingWarning());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottlingWarning": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IThrottlingWarning():
    TypeOnly<current.IThrottlingWarning>;
declare function use_old_InterfaceDeclaration_IThrottlingWarning(
    use: TypeOnly<old.IThrottlingWarning>);
use_old_InterfaceDeclaration_IThrottlingWarning(
    get_current_InterfaceDeclaration_IThrottlingWarning());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUsageError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IUsageError():
    TypeOnly<old.IUsageError>;
declare function use_current_InterfaceDeclaration_IUsageError(
    use: TypeOnly<current.IUsageError>);
use_current_InterfaceDeclaration_IUsageError(
    get_old_InterfaceDeclaration_IUsageError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUsageError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IUsageError():
    TypeOnly<current.IUsageError>;
declare function use_old_InterfaceDeclaration_IUsageError(
    use: TypeOnly<old.IUsageError>);
use_old_InterfaceDeclaration_IUsageError(
    get_current_InterfaceDeclaration_IUsageError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_LoaderHeader": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_LoaderHeader():
    TypeOnly<old.LoaderHeader>;
declare function use_current_EnumDeclaration_LoaderHeader(
    use: TypeOnly<current.LoaderHeader>);
use_current_EnumDeclaration_LoaderHeader(
    get_old_EnumDeclaration_LoaderHeader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_LoaderHeader": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_LoaderHeader():
    TypeOnly<current.LoaderHeader>;
declare function use_old_EnumDeclaration_LoaderHeader(
    use: TypeOnly<old.LoaderHeader>);
use_old_EnumDeclaration_LoaderHeader(
    get_current_EnumDeclaration_LoaderHeader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ReadOnlyInfo": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ReadOnlyInfo():
    TypeOnly<old.ReadOnlyInfo>;
declare function use_current_TypeAliasDeclaration_ReadOnlyInfo(
    use: TypeOnly<current.ReadOnlyInfo>);
use_current_TypeAliasDeclaration_ReadOnlyInfo(
    get_old_TypeAliasDeclaration_ReadOnlyInfo());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ReadOnlyInfo": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ReadOnlyInfo():
    TypeOnly<current.ReadOnlyInfo>;
declare function use_old_TypeAliasDeclaration_ReadOnlyInfo(
    use: TypeOnly<old.ReadOnlyInfo>);
use_old_TypeAliasDeclaration_ReadOnlyInfo(
    get_current_TypeAliasDeclaration_ReadOnlyInfo());
