/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/core-interfaces-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidCodeDetails": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidCodeDetails = requireAssignableTo<TypeOnly<old.IFluidCodeDetails>, TypeOnly<current.IFluidCodeDetails>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidCodeDetails": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidCodeDetails = requireAssignableTo<TypeOnly<current.IFluidCodeDetails>, TypeOnly<old.IFluidCodeDetails>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidCodeDetailsComparer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidCodeDetailsComparer = requireAssignableTo<TypeOnly<old.IFluidCodeDetailsComparer>, TypeOnly<current.IFluidCodeDetailsComparer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidCodeDetailsComparer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidCodeDetailsComparer = requireAssignableTo<TypeOnly<current.IFluidCodeDetailsComparer>, TypeOnly<old.IFluidCodeDetailsComparer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidCodeDetailsConfig": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidCodeDetailsConfig = requireAssignableTo<TypeOnly<old.IFluidCodeDetailsConfig>, TypeOnly<current.IFluidCodeDetailsConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidCodeDetailsConfig": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidCodeDetailsConfig = requireAssignableTo<TypeOnly<current.IFluidCodeDetailsConfig>, TypeOnly<old.IFluidCodeDetailsConfig>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidHandle": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidHandle = requireAssignableTo<TypeOnly<old.IFluidHandle>, TypeOnly<current.IFluidHandle>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidHandle": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidHandle = requireAssignableTo<TypeOnly<current.IFluidHandle>, TypeOnly<old.IFluidHandle>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidHandleContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidHandleContext = requireAssignableTo<TypeOnly<old.IFluidHandleContext>, TypeOnly<current.IFluidHandleContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidHandleContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidHandleContext = requireAssignableTo<TypeOnly<current.IFluidHandleContext>, TypeOnly<old.IFluidHandleContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidLoadable": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidLoadable = requireAssignableTo<TypeOnly<old.IFluidLoadable>, TypeOnly<current.IFluidLoadable>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidLoadable": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidLoadable = requireAssignableTo<TypeOnly<current.IFluidLoadable>, TypeOnly<old.IFluidLoadable>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidObject": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidObject = requireAssignableTo<TypeOnly<old.IFluidObject>, TypeOnly<current.IFluidObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidObject": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidObject = requireAssignableTo<TypeOnly<current.IFluidObject>, TypeOnly<old.IFluidObject>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidPackage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidPackage = requireAssignableTo<TypeOnly<old.IFluidPackage>, TypeOnly<current.IFluidPackage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidPackage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidPackage = requireAssignableTo<TypeOnly<current.IFluidPackage>, TypeOnly<old.IFluidPackage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidPackageEnvironment": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidPackageEnvironment = requireAssignableTo<TypeOnly<old.IFluidPackageEnvironment>, TypeOnly<current.IFluidPackageEnvironment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidPackageEnvironment": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidPackageEnvironment = requireAssignableTo<TypeOnly<current.IFluidPackageEnvironment>, TypeOnly<old.IFluidPackageEnvironment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidRouter": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidRouter = requireAssignableTo<TypeOnly<old.IFluidRouter>, TypeOnly<current.IFluidRouter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidRouter": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidRouter = requireAssignableTo<TypeOnly<current.IFluidRouter>, TypeOnly<old.IFluidRouter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidRunnable": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidRunnable = requireAssignableTo<TypeOnly<old.IFluidRunnable>, TypeOnly<current.IFluidRunnable>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidRunnable": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidRunnable = requireAssignableTo<TypeOnly<current.IFluidRunnable>, TypeOnly<old.IFluidRunnable>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidCodeDetailsComparer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProvideFluidCodeDetailsComparer = requireAssignableTo<TypeOnly<old.IProvideFluidCodeDetailsComparer>, TypeOnly<current.IProvideFluidCodeDetailsComparer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidCodeDetailsComparer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProvideFluidCodeDetailsComparer = requireAssignableTo<TypeOnly<current.IProvideFluidCodeDetailsComparer>, TypeOnly<old.IProvideFluidCodeDetailsComparer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidHandle": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProvideFluidHandle = requireAssignableTo<TypeOnly<old.IProvideFluidHandle>, TypeOnly<current.IProvideFluidHandle>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidHandle": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProvideFluidHandle = requireAssignableTo<TypeOnly<current.IProvideFluidHandle>, TypeOnly<old.IProvideFluidHandle>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidHandleContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProvideFluidHandleContext = requireAssignableTo<TypeOnly<old.IProvideFluidHandleContext>, TypeOnly<current.IProvideFluidHandleContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidHandleContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProvideFluidHandleContext = requireAssignableTo<TypeOnly<current.IProvideFluidHandleContext>, TypeOnly<old.IProvideFluidHandleContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidLoadable": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProvideFluidLoadable = requireAssignableTo<TypeOnly<old.IProvideFluidLoadable>, TypeOnly<current.IProvideFluidLoadable>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidLoadable": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProvideFluidLoadable = requireAssignableTo<TypeOnly<current.IProvideFluidLoadable>, TypeOnly<old.IProvideFluidLoadable>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidRouter": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProvideFluidRouter = requireAssignableTo<TypeOnly<old.IProvideFluidRouter>, TypeOnly<current.IProvideFluidRouter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidRouter": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProvideFluidRouter = requireAssignableTo<TypeOnly<current.IProvideFluidRouter>, TypeOnly<old.IProvideFluidRouter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidRunnable": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProvideFluidRunnable = requireAssignableTo<TypeOnly<old.IProvideFluidRunnable>, TypeOnly<current.IProvideFluidRunnable>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidRunnable": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProvideFluidRunnable = requireAssignableTo<TypeOnly<current.IProvideFluidRunnable>, TypeOnly<old.IProvideFluidRunnable>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRequest": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRequest = requireAssignableTo<TypeOnly<old.IRequest>, TypeOnly<current.IRequest>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRequest": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRequest = requireAssignableTo<TypeOnly<current.IRequest>, TypeOnly<old.IRequest>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRequestHeader": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRequestHeader = requireAssignableTo<TypeOnly<old.IRequestHeader>, TypeOnly<current.IRequestHeader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRequestHeader": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRequestHeader = requireAssignableTo<TypeOnly<current.IRequestHeader>, TypeOnly<old.IRequestHeader>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IResponse": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IResponse = requireAssignableTo<TypeOnly<old.IResponse>, TypeOnly<current.IResponse>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IResponse": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IResponse = requireAssignableTo<TypeOnly<current.IResponse>, TypeOnly<old.IResponse>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObject": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_FluidObject = requireAssignableTo<TypeOnly<old.FluidObject>, TypeOnly<current.FluidObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObject": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_FluidObject = requireAssignableTo<TypeOnly<current.FluidObject>, TypeOnly<old.FluidObject>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObjectKeys": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_FluidObjectKeys = requireAssignableTo<TypeOnly<old.FluidObjectKeys<never>>, TypeOnly<current.FluidObjectKeys<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObjectKeys": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_FluidObjectKeys = requireAssignableTo<TypeOnly<current.FluidObjectKeys<never>>, TypeOnly<old.FluidObjectKeys<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObjectProviderKeys": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_FluidObjectProviderKeys = requireAssignableTo<TypeOnly<old.FluidObjectProviderKeys<never>>, TypeOnly<current.FluidObjectProviderKeys<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObjectProviderKeys": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_FluidObjectProviderKeys = requireAssignableTo<TypeOnly<current.FluidObjectProviderKeys<never>>, TypeOnly<old.FluidObjectProviderKeys<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IFluidCodeDetailsComparer": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IFluidCodeDetailsComparer = requireAssignableTo<TypeOnly<typeof current.IFluidCodeDetailsComparer>, TypeOnly<typeof old.IFluidCodeDetailsComparer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IFluidHandle": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IFluidHandle = requireAssignableTo<TypeOnly<typeof current.IFluidHandle>, TypeOnly<typeof old.IFluidHandle>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IFluidHandleContext": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IFluidHandleContext = requireAssignableTo<TypeOnly<typeof current.IFluidHandleContext>, TypeOnly<typeof old.IFluidHandleContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IFluidLoadable": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IFluidLoadable = requireAssignableTo<TypeOnly<typeof current.IFluidLoadable>, TypeOnly<typeof old.IFluidLoadable>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IFluidRouter": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IFluidRouter = requireAssignableTo<TypeOnly<typeof current.IFluidRouter>, TypeOnly<typeof old.IFluidRouter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IFluidRunnable": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IFluidRunnable = requireAssignableTo<TypeOnly<typeof current.IFluidRunnable>, TypeOnly<typeof old.IFluidRunnable>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_isFluidCodeDetails": {"backCompat": false}
 */
declare type current_as_old_for_Variable_isFluidCodeDetails = requireAssignableTo<TypeOnly<typeof current.isFluidCodeDetails>, TypeOnly<typeof old.isFluidCodeDetails>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_isFluidPackage": {"backCompat": false}
 */
declare type current_as_old_for_Variable_isFluidPackage = requireAssignableTo<TypeOnly<typeof current.isFluidPackage>, TypeOnly<typeof old.isFluidPackage>>
