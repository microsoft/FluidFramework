/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/core-interfaces-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ErasedType": {"backCompat": false}
 */
declare type current_as_old_for_Class_ErasedType = requireAssignableTo<TypeOnly<current.ErasedType>, TypeOnly<old.ErasedType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ErasedType": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ErasedType = requireAssignableTo<TypeOnly<typeof current.ErasedType>, TypeOnly<typeof old.ErasedType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConfigProviderBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConfigProviderBase = requireAssignableTo<TypeOnly<old.IConfigProviderBase>, TypeOnly<current.IConfigProviderBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConfigProviderBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConfigProviderBase = requireAssignableTo<TypeOnly<current.IConfigProviderBase>, TypeOnly<old.IConfigProviderBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDisposable": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDisposable = requireAssignableTo<TypeOnly<current.IDisposable>, TypeOnly<old.IDisposable>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IErrorBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IErrorBase = requireAssignableTo<TypeOnly<old.IErrorBase>, TypeOnly<current.IErrorBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IErrorBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IErrorBase = requireAssignableTo<TypeOnly<current.IErrorBase>, TypeOnly<old.IErrorBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IErrorEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IErrorEvent = requireAssignableTo<TypeOnly<old.IErrorEvent>, TypeOnly<current.IErrorEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IErrorEvent": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IErrorEvent = requireAssignableTo<TypeOnly<current.IErrorEvent>, TypeOnly<old.IErrorEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IEvent = requireAssignableTo<TypeOnly<old.IEvent>, TypeOnly<current.IEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEvent": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IEvent = requireAssignableTo<TypeOnly<current.IEvent>, TypeOnly<old.IEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEventProvider": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IEventProvider = requireAssignableTo<TypeOnly<current.IEventProvider<never>>, TypeOnly<old.IEventProvider<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidHandle": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidHandle = requireAssignableTo<TypeOnly<current.IFluidHandle>, TypeOnly<old.IFluidHandle>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidHandleContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidHandleContext = requireAssignableTo<TypeOnly<old.IFluidHandleContext>, TypeOnly<current.IFluidHandleContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidHandleContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidHandleContext = requireAssignableTo<TypeOnly<current.IFluidHandleContext>, TypeOnly<old.IFluidHandleContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidHandleErased": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidHandleErased = requireAssignableTo<TypeOnly<current.IFluidHandleErased<never>>, TypeOnly<old.IFluidHandleErased<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidHandleInternal": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidHandleInternal = requireAssignableTo<TypeOnly<old.IFluidHandleInternal>, TypeOnly<current.IFluidHandleInternal>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidHandleInternal": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidHandleInternal = requireAssignableTo<TypeOnly<current.IFluidHandleInternal>, TypeOnly<old.IFluidHandleInternal>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidLoadable": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidLoadable = requireAssignableTo<TypeOnly<current.IFluidLoadable>, TypeOnly<old.IFluidLoadable>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILoggingError": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ILoggingError = requireAssignableTo<TypeOnly<old.ILoggingError>, TypeOnly<current.ILoggingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILoggingError": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ILoggingError = requireAssignableTo<TypeOnly<current.ILoggingError>, TypeOnly<old.ILoggingError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidHandle": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProvideFluidHandle = requireAssignableTo<TypeOnly<old.IProvideFluidHandle>, TypeOnly<current.IProvideFluidHandle>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidHandle": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProvideFluidHandle = requireAssignableTo<TypeOnly<current.IProvideFluidHandle>, TypeOnly<old.IProvideFluidHandle>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidHandleContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProvideFluidHandleContext = requireAssignableTo<TypeOnly<old.IProvideFluidHandleContext>, TypeOnly<current.IProvideFluidHandleContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidHandleContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProvideFluidHandleContext = requireAssignableTo<TypeOnly<current.IProvideFluidHandleContext>, TypeOnly<old.IProvideFluidHandleContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidLoadable": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProvideFluidLoadable = requireAssignableTo<TypeOnly<old.IProvideFluidLoadable>, TypeOnly<current.IProvideFluidLoadable>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidLoadable": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProvideFluidLoadable = requireAssignableTo<TypeOnly<current.IProvideFluidLoadable>, TypeOnly<old.IProvideFluidLoadable>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRequest": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRequest = requireAssignableTo<TypeOnly<old.IRequest>, TypeOnly<current.IRequest>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRequest": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRequest = requireAssignableTo<TypeOnly<current.IRequest>, TypeOnly<old.IRequest>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRequestHeader": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRequestHeader = requireAssignableTo<TypeOnly<old.IRequestHeader>, TypeOnly<current.IRequestHeader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRequestHeader": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRequestHeader = requireAssignableTo<TypeOnly<current.IRequestHeader>, TypeOnly<old.IRequestHeader>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IResponse": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IResponse = requireAssignableTo<TypeOnly<old.IResponse>, TypeOnly<current.IResponse>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IResponse": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IResponse = requireAssignableTo<TypeOnly<current.IResponse>, TypeOnly<old.IResponse>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryBaseEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITelemetryBaseEvent = requireAssignableTo<TypeOnly<old.ITelemetryBaseEvent>, TypeOnly<current.ITelemetryBaseEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryBaseEvent": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryBaseEvent = requireAssignableTo<TypeOnly<current.ITelemetryBaseEvent>, TypeOnly<old.ITelemetryBaseEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryBaseLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITelemetryBaseLogger = requireAssignableTo<TypeOnly<old.ITelemetryBaseLogger>, TypeOnly<current.ITelemetryBaseLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryBaseLogger": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryBaseLogger = requireAssignableTo<TypeOnly<current.ITelemetryBaseLogger>, TypeOnly<old.ITelemetryBaseLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryBaseProperties": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITelemetryBaseProperties = requireAssignableTo<TypeOnly<old.ITelemetryBaseProperties>, TypeOnly<current.ITelemetryBaseProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryBaseProperties": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryBaseProperties = requireAssignableTo<TypeOnly<current.ITelemetryBaseProperties>, TypeOnly<old.ITelemetryBaseProperties>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottlingWarning": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IThrottlingWarning = requireAssignableTo<TypeOnly<old.IThrottlingWarning>, TypeOnly<current.IThrottlingWarning>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottlingWarning": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IThrottlingWarning = requireAssignableTo<TypeOnly<current.IThrottlingWarning>, TypeOnly<old.IThrottlingWarning>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_Listenable": {"backCompat": false}
 */
declare type current_as_old_for_Interface_Listenable = requireAssignableTo<TypeOnly<current.Listenable<never>>, TypeOnly<old.Listenable<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_Tagged": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_Tagged = requireAssignableTo<TypeOnly<old.Tagged<never>>, TypeOnly<current.Tagged<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_Tagged": {"backCompat": false}
 */
declare type current_as_old_for_Interface_Tagged = requireAssignableTo<TypeOnly<current.Tagged<never>>, TypeOnly<old.Tagged<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ConfigTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ConfigTypes = requireAssignableTo<TypeOnly<old.ConfigTypes>, TypeOnly<current.ConfigTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ConfigTypes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ConfigTypes = requireAssignableTo<TypeOnly<current.ConfigTypes>, TypeOnly<old.ConfigTypes>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ExtendEventProvider": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ExtendEventProvider = requireAssignableTo<TypeOnly<old.ExtendEventProvider<never,never,never>>, TypeOnly<current.ExtendEventProvider<never,never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ExtendEventProvider": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ExtendEventProvider = requireAssignableTo<TypeOnly<current.ExtendEventProvider<never,never,never>>, TypeOnly<old.ExtendEventProvider<never,never,never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidErrorTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_FluidErrorTypes = requireAssignableTo<TypeOnly<old.FluidErrorTypes>, TypeOnly<current.FluidErrorTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidErrorTypes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_FluidErrorTypes = requireAssignableTo<TypeOnly<current.FluidErrorTypes>, TypeOnly<old.FluidErrorTypes>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObject": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_FluidObject = requireAssignableTo<TypeOnly<old.FluidObject>, TypeOnly<current.FluidObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObject": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_FluidObject = requireAssignableTo<TypeOnly<current.FluidObject>, TypeOnly<old.FluidObject>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObjectKeys": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_FluidObjectKeys = requireAssignableTo<TypeOnly<old.FluidObjectKeys<never>>, TypeOnly<current.FluidObjectKeys<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObjectKeys": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_FluidObjectKeys = requireAssignableTo<TypeOnly<current.FluidObjectKeys<never>>, TypeOnly<old.FluidObjectKeys<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObjectProviderKeys": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_FluidObjectProviderKeys = requireAssignableTo<TypeOnly<old.FluidObjectProviderKeys<never>>, TypeOnly<current.FluidObjectProviderKeys<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObjectProviderKeys": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_FluidObjectProviderKeys = requireAssignableTo<TypeOnly<current.FluidObjectProviderKeys<never>>, TypeOnly<old.FluidObjectProviderKeys<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IEventThisPlaceHolder": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IEventThisPlaceHolder = requireAssignableTo<TypeOnly<old.IEventThisPlaceHolder>, TypeOnly<current.IEventThisPlaceHolder>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IEventThisPlaceHolder": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IEventThisPlaceHolder = requireAssignableTo<TypeOnly<current.IEventThisPlaceHolder>, TypeOnly<old.IEventThisPlaceHolder>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IEventTransformer": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IEventTransformer = requireAssignableTo<TypeOnly<old.IEventTransformer<never,never>>, TypeOnly<current.IEventTransformer<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IEventTransformer": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IEventTransformer = requireAssignableTo<TypeOnly<current.IEventTransformer<never,never>>, TypeOnly<old.IEventTransformer<never,never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IsListener": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IsListener = requireAssignableTo<TypeOnly<old.IsListener<never>>, TypeOnly<current.IsListener<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IsListener": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IsListener = requireAssignableTo<TypeOnly<current.IsListener<never>>, TypeOnly<old.IsListener<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Listeners": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_Listeners = requireAssignableTo<TypeOnly<old.Listeners<never>>, TypeOnly<current.Listeners<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Listeners": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_Listeners = requireAssignableTo<TypeOnly<current.Listeners<never>>, TypeOnly<old.Listeners<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LogLevel": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_LogLevel = requireAssignableTo<TypeOnly<old.LogLevel>, TypeOnly<current.LogLevel>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LogLevel": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_LogLevel = requireAssignableTo<TypeOnly<current.LogLevel>, TypeOnly<old.LogLevel>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Off": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_Off = requireAssignableTo<TypeOnly<old.Off>, TypeOnly<current.Off>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Off": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_Off = requireAssignableTo<TypeOnly<current.Off>, TypeOnly<old.Off>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ReplaceIEventThisPlaceHolder": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ReplaceIEventThisPlaceHolder = requireAssignableTo<TypeOnly<old.ReplaceIEventThisPlaceHolder<never,never>>, TypeOnly<current.ReplaceIEventThisPlaceHolder<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ReplaceIEventThisPlaceHolder": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ReplaceIEventThisPlaceHolder = requireAssignableTo<TypeOnly<current.ReplaceIEventThisPlaceHolder<never,never>>, TypeOnly<old.ReplaceIEventThisPlaceHolder<never,never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TelemetryBaseEventPropertyType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TelemetryBaseEventPropertyType = requireAssignableTo<TypeOnly<old.TelemetryBaseEventPropertyType>, TypeOnly<current.TelemetryBaseEventPropertyType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TelemetryBaseEventPropertyType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TelemetryBaseEventPropertyType = requireAssignableTo<TypeOnly<current.TelemetryBaseEventPropertyType>, TypeOnly<old.TelemetryBaseEventPropertyType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TransformedEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TransformedEvent = requireAssignableTo<TypeOnly<old.TransformedEvent<never,never,never>>, TypeOnly<current.TransformedEvent<never,never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TransformedEvent": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TransformedEvent = requireAssignableTo<TypeOnly<current.TransformedEvent<never,never,never>>, TypeOnly<old.TransformedEvent<never,never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_FluidErrorTypes": {"backCompat": false}
 */
declare type current_as_old_for_Variable_FluidErrorTypes = requireAssignableTo<TypeOnly<typeof current.FluidErrorTypes>, TypeOnly<typeof old.FluidErrorTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_fluidHandleSymbol": {"backCompat": false}
 */
declare type current_as_old_for_Variable_fluidHandleSymbol = requireAssignableTo<TypeOnly<typeof current.fluidHandleSymbol>, TypeOnly<typeof old.fluidHandleSymbol>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IFluidHandle": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IFluidHandle = requireAssignableTo<TypeOnly<typeof current.IFluidHandle>, TypeOnly<typeof old.IFluidHandle>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IFluidHandleContext": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IFluidHandleContext = requireAssignableTo<TypeOnly<typeof current.IFluidHandleContext>, TypeOnly<typeof old.IFluidHandleContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IFluidLoadable": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IFluidLoadable = requireAssignableTo<TypeOnly<typeof current.IFluidLoadable>, TypeOnly<typeof old.IFluidLoadable>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_LogLevel": {"backCompat": false}
 */
declare type current_as_old_for_Variable_LogLevel = requireAssignableTo<TypeOnly<typeof current.LogLevel>, TypeOnly<typeof old.LogLevel>>
