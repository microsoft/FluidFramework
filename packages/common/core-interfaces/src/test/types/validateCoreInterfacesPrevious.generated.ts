/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */
import * as old from "@fluidframework/core-interfaces-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ExtendEventProvider": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ExtendEventProvider():
    TypeOnly<old.ExtendEventProvider<any,any,any>>;
declare function use_current_TypeAliasDeclaration_ExtendEventProvider(
    use: TypeOnly<current.ExtendEventProvider<any,any,any>>);
use_current_TypeAliasDeclaration_ExtendEventProvider(
    get_old_TypeAliasDeclaration_ExtendEventProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ExtendEventProvider": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ExtendEventProvider():
    TypeOnly<current.ExtendEventProvider<any,any,any>>;
declare function use_old_TypeAliasDeclaration_ExtendEventProvider(
    use: TypeOnly<old.ExtendEventProvider<any,any,any>>);
use_old_TypeAliasDeclaration_ExtendEventProvider(
    get_current_TypeAliasDeclaration_ExtendEventProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_FluidErrorTypes": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_FluidErrorTypes():
    TypeOnly<typeof old.FluidErrorTypes>;
declare function use_current_VariableDeclaration_FluidErrorTypes(
    use: TypeOnly<typeof current.FluidErrorTypes>);
use_current_VariableDeclaration_FluidErrorTypes(
    get_old_VariableDeclaration_FluidErrorTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_FluidErrorTypes": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_FluidErrorTypes():
    TypeOnly<typeof current.FluidErrorTypes>;
declare function use_old_VariableDeclaration_FluidErrorTypes(
    use: TypeOnly<typeof old.FluidErrorTypes>);
use_old_VariableDeclaration_FluidErrorTypes(
    get_current_VariableDeclaration_FluidErrorTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidErrorTypes": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_FluidErrorTypes():
    TypeOnly<old.FluidErrorTypes>;
declare function use_current_TypeAliasDeclaration_FluidErrorTypes(
    use: TypeOnly<current.FluidErrorTypes>);
use_current_TypeAliasDeclaration_FluidErrorTypes(
    get_old_TypeAliasDeclaration_FluidErrorTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidErrorTypes": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_FluidErrorTypes():
    TypeOnly<current.FluidErrorTypes>;
declare function use_old_TypeAliasDeclaration_FluidErrorTypes(
    use: TypeOnly<old.FluidErrorTypes>);
use_old_TypeAliasDeclaration_FluidErrorTypes(
    get_current_TypeAliasDeclaration_FluidErrorTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObject": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_FluidObject():
    TypeOnly<old.FluidObject>;
declare function use_current_TypeAliasDeclaration_FluidObject(
    use: TypeOnly<current.FluidObject>);
use_current_TypeAliasDeclaration_FluidObject(
    get_old_TypeAliasDeclaration_FluidObject());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObject": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_FluidObject():
    TypeOnly<current.FluidObject>;
declare function use_old_TypeAliasDeclaration_FluidObject(
    use: TypeOnly<old.FluidObject>);
use_old_TypeAliasDeclaration_FluidObject(
    get_current_TypeAliasDeclaration_FluidObject());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObjectKeys": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_FluidObjectKeys():
    TypeOnly<old.FluidObjectKeys<any>>;
declare function use_current_TypeAliasDeclaration_FluidObjectKeys(
    use: TypeOnly<current.FluidObjectKeys<any>>);
use_current_TypeAliasDeclaration_FluidObjectKeys(
    get_old_TypeAliasDeclaration_FluidObjectKeys());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObjectKeys": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_FluidObjectKeys():
    TypeOnly<current.FluidObjectKeys<any>>;
declare function use_old_TypeAliasDeclaration_FluidObjectKeys(
    use: TypeOnly<old.FluidObjectKeys<any>>);
use_old_TypeAliasDeclaration_FluidObjectKeys(
    get_current_TypeAliasDeclaration_FluidObjectKeys());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObjectProviderKeys": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_FluidObjectProviderKeys():
    TypeOnly<old.FluidObjectProviderKeys<any,any>>;
declare function use_current_TypeAliasDeclaration_FluidObjectProviderKeys(
    use: TypeOnly<current.FluidObjectProviderKeys<any,any>>);
use_current_TypeAliasDeclaration_FluidObjectProviderKeys(
    get_old_TypeAliasDeclaration_FluidObjectProviderKeys());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObjectProviderKeys": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_FluidObjectProviderKeys():
    TypeOnly<current.FluidObjectProviderKeys<any,any>>;
declare function use_old_TypeAliasDeclaration_FluidObjectProviderKeys(
    use: TypeOnly<old.FluidObjectProviderKeys<any,any>>);
use_old_TypeAliasDeclaration_FluidObjectProviderKeys(
    get_current_TypeAliasDeclaration_FluidObjectProviderKeys());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDisposable": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDisposable():
    TypeOnly<old.IDisposable>;
declare function use_current_InterfaceDeclaration_IDisposable(
    use: TypeOnly<current.IDisposable>);
use_current_InterfaceDeclaration_IDisposable(
    get_old_InterfaceDeclaration_IDisposable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDisposable": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDisposable():
    TypeOnly<current.IDisposable>;
declare function use_old_InterfaceDeclaration_IDisposable(
    use: TypeOnly<old.IDisposable>);
use_old_InterfaceDeclaration_IDisposable(
    get_current_InterfaceDeclaration_IDisposable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IErrorBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IErrorBase():
    TypeOnly<old.IErrorBase>;
declare function use_current_InterfaceDeclaration_IErrorBase(
    use: TypeOnly<current.IErrorBase>);
use_current_InterfaceDeclaration_IErrorBase(
    get_old_InterfaceDeclaration_IErrorBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IErrorBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IErrorBase():
    TypeOnly<current.IErrorBase>;
declare function use_old_InterfaceDeclaration_IErrorBase(
    use: TypeOnly<old.IErrorBase>);
use_old_InterfaceDeclaration_IErrorBase(
    get_current_InterfaceDeclaration_IErrorBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IErrorEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IErrorEvent():
    TypeOnly<old.IErrorEvent>;
declare function use_current_InterfaceDeclaration_IErrorEvent(
    use: TypeOnly<current.IErrorEvent>);
use_current_InterfaceDeclaration_IErrorEvent(
    get_old_InterfaceDeclaration_IErrorEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IErrorEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IErrorEvent():
    TypeOnly<current.IErrorEvent>;
declare function use_old_InterfaceDeclaration_IErrorEvent(
    use: TypeOnly<old.IErrorEvent>);
use_old_InterfaceDeclaration_IErrorEvent(
    get_current_InterfaceDeclaration_IErrorEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IEvent():
    TypeOnly<old.IEvent>;
declare function use_current_InterfaceDeclaration_IEvent(
    use: TypeOnly<current.IEvent>);
use_current_InterfaceDeclaration_IEvent(
    get_old_InterfaceDeclaration_IEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IEvent():
    TypeOnly<current.IEvent>;
declare function use_old_InterfaceDeclaration_IEvent(
    use: TypeOnly<old.IEvent>);
use_old_InterfaceDeclaration_IEvent(
    get_current_InterfaceDeclaration_IEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEventProvider": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IEventProvider():
    TypeOnly<old.IEventProvider<any>>;
declare function use_current_InterfaceDeclaration_IEventProvider(
    use: TypeOnly<current.IEventProvider<any>>);
use_current_InterfaceDeclaration_IEventProvider(
    get_old_InterfaceDeclaration_IEventProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEventProvider": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IEventProvider():
    TypeOnly<current.IEventProvider<any>>;
declare function use_old_InterfaceDeclaration_IEventProvider(
    use: TypeOnly<old.IEventProvider<any>>);
use_old_InterfaceDeclaration_IEventProvider(
    get_current_InterfaceDeclaration_IEventProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IEventThisPlaceHolder": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IEventThisPlaceHolder():
    TypeOnly<old.IEventThisPlaceHolder>;
declare function use_current_TypeAliasDeclaration_IEventThisPlaceHolder(
    use: TypeOnly<current.IEventThisPlaceHolder>);
use_current_TypeAliasDeclaration_IEventThisPlaceHolder(
    get_old_TypeAliasDeclaration_IEventThisPlaceHolder());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IEventThisPlaceHolder": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IEventThisPlaceHolder():
    TypeOnly<current.IEventThisPlaceHolder>;
declare function use_old_TypeAliasDeclaration_IEventThisPlaceHolder(
    use: TypeOnly<old.IEventThisPlaceHolder>);
use_old_TypeAliasDeclaration_IEventThisPlaceHolder(
    get_current_TypeAliasDeclaration_IEventThisPlaceHolder());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IEventTransformer": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IEventTransformer():
    TypeOnly<old.IEventTransformer<any,any>>;
declare function use_current_TypeAliasDeclaration_IEventTransformer(
    use: TypeOnly<current.IEventTransformer<any,any>>);
use_current_TypeAliasDeclaration_IEventTransformer(
    get_old_TypeAliasDeclaration_IEventTransformer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IEventTransformer": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IEventTransformer():
    TypeOnly<current.IEventTransformer<any,any>>;
declare function use_old_TypeAliasDeclaration_IEventTransformer(
    use: TypeOnly<old.IEventTransformer<any,any>>);
use_old_TypeAliasDeclaration_IEventTransformer(
    get_current_TypeAliasDeclaration_IEventTransformer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidCodeDetails():
    TypeOnly<old.IFluidCodeDetails>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetails(
    use: TypeOnly<current.IFluidCodeDetails>);
use_current_InterfaceDeclaration_IFluidCodeDetails(
    get_old_InterfaceDeclaration_IFluidCodeDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidCodeDetails():
    TypeOnly<current.IFluidCodeDetails>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetails(
    use: TypeOnly<old.IFluidCodeDetails>);
use_old_InterfaceDeclaration_IFluidCodeDetails(
    get_current_InterfaceDeclaration_IFluidCodeDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidCodeDetailsComparer": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<typeof old.IFluidCodeDetailsComparer>;
declare function use_current_VariableDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<typeof current.IFluidCodeDetailsComparer>);
use_current_VariableDeclaration_IFluidCodeDetailsComparer(
    get_old_VariableDeclaration_IFluidCodeDetailsComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidCodeDetailsComparer": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<typeof current.IFluidCodeDetailsComparer>;
declare function use_old_VariableDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<typeof old.IFluidCodeDetailsComparer>);
use_old_VariableDeclaration_IFluidCodeDetailsComparer(
    get_current_VariableDeclaration_IFluidCodeDetailsComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsComparer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<old.IFluidCodeDetailsComparer>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<current.IFluidCodeDetailsComparer>);
use_current_InterfaceDeclaration_IFluidCodeDetailsComparer(
    get_old_InterfaceDeclaration_IFluidCodeDetailsComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsComparer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<current.IFluidCodeDetailsComparer>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<old.IFluidCodeDetailsComparer>);
use_old_InterfaceDeclaration_IFluidCodeDetailsComparer(
    get_current_InterfaceDeclaration_IFluidCodeDetailsComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidCodeDetailsConfig():
    TypeOnly<old.IFluidCodeDetailsConfig>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetailsConfig(
    use: TypeOnly<current.IFluidCodeDetailsConfig>);
use_current_InterfaceDeclaration_IFluidCodeDetailsConfig(
    get_old_InterfaceDeclaration_IFluidCodeDetailsConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidCodeDetailsConfig():
    TypeOnly<current.IFluidCodeDetailsConfig>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetailsConfig(
    use: TypeOnly<old.IFluidCodeDetailsConfig>);
use_old_InterfaceDeclaration_IFluidCodeDetailsConfig(
    get_current_InterfaceDeclaration_IFluidCodeDetailsConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidHandle": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidHandle():
    TypeOnly<typeof old.IFluidHandle>;
declare function use_current_VariableDeclaration_IFluidHandle(
    use: TypeOnly<typeof current.IFluidHandle>);
use_current_VariableDeclaration_IFluidHandle(
    get_old_VariableDeclaration_IFluidHandle());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidHandle": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidHandle():
    TypeOnly<typeof current.IFluidHandle>;
declare function use_old_VariableDeclaration_IFluidHandle(
    use: TypeOnly<typeof old.IFluidHandle>);
use_old_VariableDeclaration_IFluidHandle(
    get_current_VariableDeclaration_IFluidHandle());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidHandle": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidHandle():
    TypeOnly<old.IFluidHandle>;
declare function use_current_InterfaceDeclaration_IFluidHandle(
    use: TypeOnly<current.IFluidHandle>);
use_current_InterfaceDeclaration_IFluidHandle(
    get_old_InterfaceDeclaration_IFluidHandle());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidHandle": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidHandle():
    TypeOnly<current.IFluidHandle>;
declare function use_old_InterfaceDeclaration_IFluidHandle(
    use: TypeOnly<old.IFluidHandle>);
use_old_InterfaceDeclaration_IFluidHandle(
    get_current_InterfaceDeclaration_IFluidHandle());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidHandleContext": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidHandleContext():
    TypeOnly<typeof old.IFluidHandleContext>;
declare function use_current_VariableDeclaration_IFluidHandleContext(
    use: TypeOnly<typeof current.IFluidHandleContext>);
use_current_VariableDeclaration_IFluidHandleContext(
    get_old_VariableDeclaration_IFluidHandleContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidHandleContext": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidHandleContext():
    TypeOnly<typeof current.IFluidHandleContext>;
declare function use_old_VariableDeclaration_IFluidHandleContext(
    use: TypeOnly<typeof old.IFluidHandleContext>);
use_old_VariableDeclaration_IFluidHandleContext(
    get_current_VariableDeclaration_IFluidHandleContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidHandleContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidHandleContext():
    TypeOnly<old.IFluidHandleContext>;
declare function use_current_InterfaceDeclaration_IFluidHandleContext(
    use: TypeOnly<current.IFluidHandleContext>);
use_current_InterfaceDeclaration_IFluidHandleContext(
    get_old_InterfaceDeclaration_IFluidHandleContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidHandleContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidHandleContext():
    TypeOnly<current.IFluidHandleContext>;
declare function use_old_InterfaceDeclaration_IFluidHandleContext(
    use: TypeOnly<old.IFluidHandleContext>);
use_old_InterfaceDeclaration_IFluidHandleContext(
    get_current_InterfaceDeclaration_IFluidHandleContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidLoadable": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidLoadable():
    TypeOnly<typeof old.IFluidLoadable>;
declare function use_current_VariableDeclaration_IFluidLoadable(
    use: TypeOnly<typeof current.IFluidLoadable>);
use_current_VariableDeclaration_IFluidLoadable(
    get_old_VariableDeclaration_IFluidLoadable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidLoadable": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidLoadable():
    TypeOnly<typeof current.IFluidLoadable>;
declare function use_old_VariableDeclaration_IFluidLoadable(
    use: TypeOnly<typeof old.IFluidLoadable>);
use_old_VariableDeclaration_IFluidLoadable(
    get_current_VariableDeclaration_IFluidLoadable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidLoadable": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidLoadable():
    TypeOnly<old.IFluidLoadable>;
declare function use_current_InterfaceDeclaration_IFluidLoadable(
    use: TypeOnly<current.IFluidLoadable>);
use_current_InterfaceDeclaration_IFluidLoadable(
    get_old_InterfaceDeclaration_IFluidLoadable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidLoadable": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidLoadable():
    TypeOnly<current.IFluidLoadable>;
declare function use_old_InterfaceDeclaration_IFluidLoadable(
    use: TypeOnly<old.IFluidLoadable>);
use_old_InterfaceDeclaration_IFluidLoadable(
    get_current_InterfaceDeclaration_IFluidLoadable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidPackage():
    TypeOnly<old.IFluidPackage>;
declare function use_current_InterfaceDeclaration_IFluidPackage(
    use: TypeOnly<current.IFluidPackage>);
use_current_InterfaceDeclaration_IFluidPackage(
    get_old_InterfaceDeclaration_IFluidPackage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidPackage():
    TypeOnly<current.IFluidPackage>;
declare function use_old_InterfaceDeclaration_IFluidPackage(
    use: TypeOnly<old.IFluidPackage>);
use_old_InterfaceDeclaration_IFluidPackage(
    get_current_InterfaceDeclaration_IFluidPackage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackageEnvironment": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidPackageEnvironment():
    TypeOnly<old.IFluidPackageEnvironment>;
declare function use_current_InterfaceDeclaration_IFluidPackageEnvironment(
    use: TypeOnly<current.IFluidPackageEnvironment>);
use_current_InterfaceDeclaration_IFluidPackageEnvironment(
    get_old_InterfaceDeclaration_IFluidPackageEnvironment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackageEnvironment": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidPackageEnvironment():
    TypeOnly<current.IFluidPackageEnvironment>;
declare function use_old_InterfaceDeclaration_IFluidPackageEnvironment(
    use: TypeOnly<old.IFluidPackageEnvironment>);
use_old_InterfaceDeclaration_IFluidPackageEnvironment(
    get_current_InterfaceDeclaration_IFluidPackageEnvironment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidRouter": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidRouter():
    TypeOnly<typeof old.IFluidRouter>;
declare function use_current_VariableDeclaration_IFluidRouter(
    use: TypeOnly<typeof current.IFluidRouter>);
use_current_VariableDeclaration_IFluidRouter(
    get_old_VariableDeclaration_IFluidRouter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidRouter": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidRouter():
    TypeOnly<typeof current.IFluidRouter>;
declare function use_old_VariableDeclaration_IFluidRouter(
    use: TypeOnly<typeof old.IFluidRouter>);
use_old_VariableDeclaration_IFluidRouter(
    get_current_VariableDeclaration_IFluidRouter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidRouter": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidRouter():
    TypeOnly<old.IFluidRouter>;
declare function use_current_InterfaceDeclaration_IFluidRouter(
    use: TypeOnly<current.IFluidRouter>);
use_current_InterfaceDeclaration_IFluidRouter(
    get_old_InterfaceDeclaration_IFluidRouter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidRouter": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidRouter():
    TypeOnly<current.IFluidRouter>;
declare function use_old_InterfaceDeclaration_IFluidRouter(
    use: TypeOnly<old.IFluidRouter>);
use_old_InterfaceDeclaration_IFluidRouter(
    get_current_InterfaceDeclaration_IFluidRouter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidRunnable": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidRunnable():
    TypeOnly<typeof old.IFluidRunnable>;
declare function use_current_VariableDeclaration_IFluidRunnable(
    use: TypeOnly<typeof current.IFluidRunnable>);
use_current_VariableDeclaration_IFluidRunnable(
    get_old_VariableDeclaration_IFluidRunnable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidRunnable": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidRunnable():
    TypeOnly<typeof current.IFluidRunnable>;
declare function use_old_VariableDeclaration_IFluidRunnable(
    use: TypeOnly<typeof old.IFluidRunnable>);
use_old_VariableDeclaration_IFluidRunnable(
    get_current_VariableDeclaration_IFluidRunnable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidRunnable": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidRunnable():
    TypeOnly<old.IFluidRunnable>;
declare function use_current_InterfaceDeclaration_IFluidRunnable(
    use: TypeOnly<current.IFluidRunnable>);
use_current_InterfaceDeclaration_IFluidRunnable(
    get_old_InterfaceDeclaration_IFluidRunnable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidRunnable": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidRunnable():
    TypeOnly<current.IFluidRunnable>;
declare function use_old_InterfaceDeclaration_IFluidRunnable(
    use: TypeOnly<old.IFluidRunnable>);
use_old_InterfaceDeclaration_IFluidRunnable(
    get_current_InterfaceDeclaration_IFluidRunnable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGenericError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGenericError():
    TypeOnly<old.IGenericError>;
declare function use_current_InterfaceDeclaration_IGenericError(
    use: TypeOnly<current.IGenericError>);
use_current_InterfaceDeclaration_IGenericError(
    get_old_InterfaceDeclaration_IGenericError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGenericError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGenericError():
    TypeOnly<current.IGenericError>;
declare function use_old_InterfaceDeclaration_IGenericError(
    use: TypeOnly<old.IGenericError>);
use_old_InterfaceDeclaration_IGenericError(
    get_current_InterfaceDeclaration_IGenericError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILoggingError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ILoggingError():
    TypeOnly<old.ILoggingError>;
declare function use_current_InterfaceDeclaration_ILoggingError(
    use: TypeOnly<current.ILoggingError>);
use_current_InterfaceDeclaration_ILoggingError(
    get_old_InterfaceDeclaration_ILoggingError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILoggingError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ILoggingError():
    TypeOnly<current.ILoggingError>;
declare function use_old_InterfaceDeclaration_ILoggingError(
    use: TypeOnly<old.ILoggingError>);
use_old_InterfaceDeclaration_ILoggingError(
    get_current_InterfaceDeclaration_ILoggingError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidCodeDetailsComparer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer():
    TypeOnly<old.IProvideFluidCodeDetailsComparer>;
declare function use_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    use: TypeOnly<current.IProvideFluidCodeDetailsComparer>);
use_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    get_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidCodeDetailsComparer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer():
    TypeOnly<current.IProvideFluidCodeDetailsComparer>;
declare function use_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    use: TypeOnly<old.IProvideFluidCodeDetailsComparer>);
use_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    get_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidHandle": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidHandle():
    TypeOnly<old.IProvideFluidHandle>;
declare function use_current_InterfaceDeclaration_IProvideFluidHandle(
    use: TypeOnly<current.IProvideFluidHandle>);
use_current_InterfaceDeclaration_IProvideFluidHandle(
    get_old_InterfaceDeclaration_IProvideFluidHandle());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidHandle": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidHandle():
    TypeOnly<current.IProvideFluidHandle>;
declare function use_old_InterfaceDeclaration_IProvideFluidHandle(
    use: TypeOnly<old.IProvideFluidHandle>);
use_old_InterfaceDeclaration_IProvideFluidHandle(
    get_current_InterfaceDeclaration_IProvideFluidHandle());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidHandleContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidHandleContext():
    TypeOnly<old.IProvideFluidHandleContext>;
declare function use_current_InterfaceDeclaration_IProvideFluidHandleContext(
    use: TypeOnly<current.IProvideFluidHandleContext>);
use_current_InterfaceDeclaration_IProvideFluidHandleContext(
    get_old_InterfaceDeclaration_IProvideFluidHandleContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidHandleContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidHandleContext():
    TypeOnly<current.IProvideFluidHandleContext>;
declare function use_old_InterfaceDeclaration_IProvideFluidHandleContext(
    use: TypeOnly<old.IProvideFluidHandleContext>);
use_old_InterfaceDeclaration_IProvideFluidHandleContext(
    get_current_InterfaceDeclaration_IProvideFluidHandleContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidLoadable": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidLoadable():
    TypeOnly<old.IProvideFluidLoadable>;
declare function use_current_InterfaceDeclaration_IProvideFluidLoadable(
    use: TypeOnly<current.IProvideFluidLoadable>);
use_current_InterfaceDeclaration_IProvideFluidLoadable(
    get_old_InterfaceDeclaration_IProvideFluidLoadable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidLoadable": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidLoadable():
    TypeOnly<current.IProvideFluidLoadable>;
declare function use_old_InterfaceDeclaration_IProvideFluidLoadable(
    use: TypeOnly<old.IProvideFluidLoadable>);
use_old_InterfaceDeclaration_IProvideFluidLoadable(
    get_current_InterfaceDeclaration_IProvideFluidLoadable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidRouter": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidRouter():
    TypeOnly<old.IProvideFluidRouter>;
declare function use_current_InterfaceDeclaration_IProvideFluidRouter(
    use: TypeOnly<current.IProvideFluidRouter>);
use_current_InterfaceDeclaration_IProvideFluidRouter(
    get_old_InterfaceDeclaration_IProvideFluidRouter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidRouter": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidRouter():
    TypeOnly<current.IProvideFluidRouter>;
declare function use_old_InterfaceDeclaration_IProvideFluidRouter(
    use: TypeOnly<old.IProvideFluidRouter>);
use_old_InterfaceDeclaration_IProvideFluidRouter(
    get_current_InterfaceDeclaration_IProvideFluidRouter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidRunnable": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidRunnable():
    TypeOnly<old.IProvideFluidRunnable>;
declare function use_current_InterfaceDeclaration_IProvideFluidRunnable(
    use: TypeOnly<current.IProvideFluidRunnable>);
use_current_InterfaceDeclaration_IProvideFluidRunnable(
    get_old_InterfaceDeclaration_IProvideFluidRunnable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidRunnable": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidRunnable():
    TypeOnly<current.IProvideFluidRunnable>;
declare function use_old_InterfaceDeclaration_IProvideFluidRunnable(
    use: TypeOnly<old.IProvideFluidRunnable>);
use_old_InterfaceDeclaration_IProvideFluidRunnable(
    get_current_InterfaceDeclaration_IProvideFluidRunnable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRequest": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRequest():
    TypeOnly<old.IRequest>;
declare function use_current_InterfaceDeclaration_IRequest(
    use: TypeOnly<current.IRequest>);
use_current_InterfaceDeclaration_IRequest(
    get_old_InterfaceDeclaration_IRequest());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRequest": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRequest():
    TypeOnly<current.IRequest>;
declare function use_old_InterfaceDeclaration_IRequest(
    use: TypeOnly<old.IRequest>);
use_old_InterfaceDeclaration_IRequest(
    get_current_InterfaceDeclaration_IRequest());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRequestHeader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRequestHeader():
    TypeOnly<old.IRequestHeader>;
declare function use_current_InterfaceDeclaration_IRequestHeader(
    use: TypeOnly<current.IRequestHeader>);
use_current_InterfaceDeclaration_IRequestHeader(
    get_old_InterfaceDeclaration_IRequestHeader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRequestHeader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRequestHeader():
    TypeOnly<current.IRequestHeader>;
declare function use_old_InterfaceDeclaration_IRequestHeader(
    use: TypeOnly<old.IRequestHeader>);
use_old_InterfaceDeclaration_IRequestHeader(
    get_current_InterfaceDeclaration_IRequestHeader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IResponse": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IResponse():
    TypeOnly<old.IResponse>;
declare function use_current_InterfaceDeclaration_IResponse(
    use: TypeOnly<current.IResponse>);
use_current_InterfaceDeclaration_IResponse(
    get_old_InterfaceDeclaration_IResponse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IResponse": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IResponse():
    TypeOnly<current.IResponse>;
declare function use_old_InterfaceDeclaration_IResponse(
    use: TypeOnly<old.IResponse>);
use_old_InterfaceDeclaration_IResponse(
    get_current_InterfaceDeclaration_IResponse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITaggedTelemetryPropertyType": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITaggedTelemetryPropertyType():
    TypeOnly<old.ITaggedTelemetryPropertyType>;
declare function use_current_InterfaceDeclaration_ITaggedTelemetryPropertyType(
    use: TypeOnly<current.ITaggedTelemetryPropertyType>);
use_current_InterfaceDeclaration_ITaggedTelemetryPropertyType(
    get_old_InterfaceDeclaration_ITaggedTelemetryPropertyType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITaggedTelemetryPropertyType": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITaggedTelemetryPropertyType():
    TypeOnly<current.ITaggedTelemetryPropertyType>;
declare function use_old_InterfaceDeclaration_ITaggedTelemetryPropertyType(
    use: TypeOnly<old.ITaggedTelemetryPropertyType>);
use_old_InterfaceDeclaration_ITaggedTelemetryPropertyType(
    get_current_InterfaceDeclaration_ITaggedTelemetryPropertyType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryBaseEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryBaseEvent():
    TypeOnly<old.ITelemetryBaseEvent>;
declare function use_current_InterfaceDeclaration_ITelemetryBaseEvent(
    use: TypeOnly<current.ITelemetryBaseEvent>);
use_current_InterfaceDeclaration_ITelemetryBaseEvent(
    get_old_InterfaceDeclaration_ITelemetryBaseEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryBaseEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryBaseEvent():
    TypeOnly<current.ITelemetryBaseEvent>;
declare function use_old_InterfaceDeclaration_ITelemetryBaseEvent(
    use: TypeOnly<old.ITelemetryBaseEvent>);
use_old_InterfaceDeclaration_ITelemetryBaseEvent(
    get_current_InterfaceDeclaration_ITelemetryBaseEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryBaseLogger": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryBaseLogger():
    TypeOnly<old.ITelemetryBaseLogger>;
declare function use_current_InterfaceDeclaration_ITelemetryBaseLogger(
    use: TypeOnly<current.ITelemetryBaseLogger>);
use_current_InterfaceDeclaration_ITelemetryBaseLogger(
    get_old_InterfaceDeclaration_ITelemetryBaseLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryBaseLogger": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryBaseLogger():
    TypeOnly<current.ITelemetryBaseLogger>;
declare function use_old_InterfaceDeclaration_ITelemetryBaseLogger(
    use: TypeOnly<old.ITelemetryBaseLogger>);
use_old_InterfaceDeclaration_ITelemetryBaseLogger(
    get_current_InterfaceDeclaration_ITelemetryBaseLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ITelemetryBaseProperties": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ITelemetryBaseProperties():
    TypeOnly<old.ITelemetryBaseProperties>;
declare function use_current_TypeAliasDeclaration_ITelemetryBaseProperties(
    use: TypeOnly<current.ITelemetryBaseProperties>);
use_current_TypeAliasDeclaration_ITelemetryBaseProperties(
    get_old_TypeAliasDeclaration_ITelemetryBaseProperties());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ITelemetryBaseProperties": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ITelemetryBaseProperties():
    TypeOnly<current.ITelemetryBaseProperties>;
declare function use_old_TypeAliasDeclaration_ITelemetryBaseProperties(
    use: TypeOnly<old.ITelemetryBaseProperties>);
use_old_TypeAliasDeclaration_ITelemetryBaseProperties(
    get_current_TypeAliasDeclaration_ITelemetryBaseProperties());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryErrorEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryErrorEvent():
    TypeOnly<old.ITelemetryErrorEvent>;
declare function use_current_InterfaceDeclaration_ITelemetryErrorEvent(
    use: TypeOnly<current.ITelemetryErrorEvent>);
use_current_InterfaceDeclaration_ITelemetryErrorEvent(
    get_old_InterfaceDeclaration_ITelemetryErrorEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryErrorEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryErrorEvent():
    TypeOnly<current.ITelemetryErrorEvent>;
declare function use_old_InterfaceDeclaration_ITelemetryErrorEvent(
    use: TypeOnly<old.ITelemetryErrorEvent>);
use_old_InterfaceDeclaration_ITelemetryErrorEvent(
    get_current_InterfaceDeclaration_ITelemetryErrorEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryGenericEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryGenericEvent():
    TypeOnly<old.ITelemetryGenericEvent>;
declare function use_current_InterfaceDeclaration_ITelemetryGenericEvent(
    use: TypeOnly<current.ITelemetryGenericEvent>);
use_current_InterfaceDeclaration_ITelemetryGenericEvent(
    get_old_InterfaceDeclaration_ITelemetryGenericEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryGenericEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryGenericEvent():
    TypeOnly<current.ITelemetryGenericEvent>;
declare function use_old_InterfaceDeclaration_ITelemetryGenericEvent(
    use: TypeOnly<old.ITelemetryGenericEvent>);
use_old_InterfaceDeclaration_ITelemetryGenericEvent(
    get_current_InterfaceDeclaration_ITelemetryGenericEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryLogger": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryLogger():
    TypeOnly<old.ITelemetryLogger>;
declare function use_current_InterfaceDeclaration_ITelemetryLogger(
    use: TypeOnly<current.ITelemetryLogger>);
use_current_InterfaceDeclaration_ITelemetryLogger(
    get_old_InterfaceDeclaration_ITelemetryLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryLogger": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryLogger():
    TypeOnly<current.ITelemetryLogger>;
declare function use_old_InterfaceDeclaration_ITelemetryLogger(
    use: TypeOnly<old.ITelemetryLogger>);
use_old_InterfaceDeclaration_ITelemetryLogger(
    get_current_InterfaceDeclaration_ITelemetryLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryPerformanceEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryPerformanceEvent():
    TypeOnly<old.ITelemetryPerformanceEvent>;
declare function use_current_InterfaceDeclaration_ITelemetryPerformanceEvent(
    use: TypeOnly<current.ITelemetryPerformanceEvent>);
use_current_InterfaceDeclaration_ITelemetryPerformanceEvent(
    get_old_InterfaceDeclaration_ITelemetryPerformanceEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryPerformanceEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryPerformanceEvent():
    TypeOnly<current.ITelemetryPerformanceEvent>;
declare function use_old_InterfaceDeclaration_ITelemetryPerformanceEvent(
    use: TypeOnly<old.ITelemetryPerformanceEvent>);
use_old_InterfaceDeclaration_ITelemetryPerformanceEvent(
    get_current_InterfaceDeclaration_ITelemetryPerformanceEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryProperties": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryProperties():
    TypeOnly<old.ITelemetryProperties>;
declare function use_current_InterfaceDeclaration_ITelemetryProperties(
    use: TypeOnly<current.ITelemetryProperties>);
use_current_InterfaceDeclaration_ITelemetryProperties(
    get_old_InterfaceDeclaration_ITelemetryProperties());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryProperties": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryProperties():
    TypeOnly<current.ITelemetryProperties>;
declare function use_old_InterfaceDeclaration_ITelemetryProperties(
    use: TypeOnly<old.ITelemetryProperties>);
use_old_InterfaceDeclaration_ITelemetryProperties(
    get_current_InterfaceDeclaration_ITelemetryProperties());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottlingWarning": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IThrottlingWarning():
    TypeOnly<old.IThrottlingWarning>;
declare function use_current_InterfaceDeclaration_IThrottlingWarning(
    use: TypeOnly<current.IThrottlingWarning>);
use_current_InterfaceDeclaration_IThrottlingWarning(
    get_old_InterfaceDeclaration_IThrottlingWarning());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottlingWarning": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IThrottlingWarning():
    TypeOnly<current.IThrottlingWarning>;
declare function use_old_InterfaceDeclaration_IThrottlingWarning(
    use: TypeOnly<old.IThrottlingWarning>);
use_old_InterfaceDeclaration_IThrottlingWarning(
    get_current_InterfaceDeclaration_IThrottlingWarning());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUsageError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IUsageError():
    TypeOnly<old.IUsageError>;
declare function use_current_InterfaceDeclaration_IUsageError(
    use: TypeOnly<current.IUsageError>);
use_current_InterfaceDeclaration_IUsageError(
    get_old_InterfaceDeclaration_IUsageError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUsageError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IUsageError():
    TypeOnly<current.IUsageError>;
declare function use_old_InterfaceDeclaration_IUsageError(
    use: TypeOnly<old.IUsageError>);
use_old_InterfaceDeclaration_IUsageError(
    get_current_InterfaceDeclaration_IUsageError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_LogLevel": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_LogLevel():
    TypeOnly<typeof old.LogLevel>;
declare function use_current_VariableDeclaration_LogLevel(
    use: TypeOnly<typeof current.LogLevel>);
use_current_VariableDeclaration_LogLevel(
    get_old_VariableDeclaration_LogLevel());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_LogLevel": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_LogLevel():
    TypeOnly<typeof current.LogLevel>;
declare function use_old_VariableDeclaration_LogLevel(
    use: TypeOnly<typeof old.LogLevel>);
use_old_VariableDeclaration_LogLevel(
    get_current_VariableDeclaration_LogLevel());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_LogLevel": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_LogLevel():
    TypeOnly<old.LogLevel>;
declare function use_current_TypeAliasDeclaration_LogLevel(
    use: TypeOnly<current.LogLevel>);
use_current_TypeAliasDeclaration_LogLevel(
    get_old_TypeAliasDeclaration_LogLevel());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_LogLevel": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_LogLevel():
    TypeOnly<current.LogLevel>;
declare function use_old_TypeAliasDeclaration_LogLevel(
    use: TypeOnly<old.LogLevel>);
use_old_TypeAliasDeclaration_LogLevel(
    get_current_TypeAliasDeclaration_LogLevel());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ReplaceIEventThisPlaceHolder": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder():
    TypeOnly<old.ReplaceIEventThisPlaceHolder<any,any>>;
declare function use_current_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder(
    use: TypeOnly<current.ReplaceIEventThisPlaceHolder<any,any>>);
use_current_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder(
    get_old_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ReplaceIEventThisPlaceHolder": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder():
    TypeOnly<current.ReplaceIEventThisPlaceHolder<any,any>>;
declare function use_old_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder(
    use: TypeOnly<old.ReplaceIEventThisPlaceHolder<any,any>>);
use_old_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder(
    get_current_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_Tagged": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_Tagged():
    TypeOnly<old.Tagged<any,any>>;
declare function use_current_InterfaceDeclaration_Tagged(
    use: TypeOnly<current.Tagged<any,any>>);
use_current_InterfaceDeclaration_Tagged(
    get_old_InterfaceDeclaration_Tagged());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_Tagged": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_Tagged():
    TypeOnly<current.Tagged<any,any>>;
declare function use_old_InterfaceDeclaration_Tagged(
    use: TypeOnly<old.Tagged<any,any>>);
use_old_InterfaceDeclaration_Tagged(
    get_current_InterfaceDeclaration_Tagged());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryBaseEventPropertyType": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TelemetryBaseEventPropertyType():
    TypeOnly<old.TelemetryBaseEventPropertyType>;
declare function use_current_TypeAliasDeclaration_TelemetryBaseEventPropertyType(
    use: TypeOnly<current.TelemetryBaseEventPropertyType>);
use_current_TypeAliasDeclaration_TelemetryBaseEventPropertyType(
    get_old_TypeAliasDeclaration_TelemetryBaseEventPropertyType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryBaseEventPropertyType": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TelemetryBaseEventPropertyType():
    TypeOnly<current.TelemetryBaseEventPropertyType>;
declare function use_old_TypeAliasDeclaration_TelemetryBaseEventPropertyType(
    use: TypeOnly<old.TelemetryBaseEventPropertyType>);
use_old_TypeAliasDeclaration_TelemetryBaseEventPropertyType(
    get_current_TypeAliasDeclaration_TelemetryBaseEventPropertyType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventCategory": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TelemetryEventCategory():
    TypeOnly<old.TelemetryEventCategory>;
declare function use_current_TypeAliasDeclaration_TelemetryEventCategory(
    use: TypeOnly<current.TelemetryEventCategory>);
use_current_TypeAliasDeclaration_TelemetryEventCategory(
    get_old_TypeAliasDeclaration_TelemetryEventCategory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventCategory": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TelemetryEventCategory():
    TypeOnly<current.TelemetryEventCategory>;
declare function use_old_TypeAliasDeclaration_TelemetryEventCategory(
    use: TypeOnly<old.TelemetryEventCategory>);
use_old_TypeAliasDeclaration_TelemetryEventCategory(
    get_current_TypeAliasDeclaration_TelemetryEventCategory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventPropertyType": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TelemetryEventPropertyType():
    TypeOnly<old.TelemetryEventPropertyType>;
declare function use_current_TypeAliasDeclaration_TelemetryEventPropertyType(
    use: TypeOnly<current.TelemetryEventPropertyType>);
use_current_TypeAliasDeclaration_TelemetryEventPropertyType(
    get_old_TypeAliasDeclaration_TelemetryEventPropertyType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventPropertyType": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TelemetryEventPropertyType():
    TypeOnly<current.TelemetryEventPropertyType>;
declare function use_old_TypeAliasDeclaration_TelemetryEventPropertyType(
    use: TypeOnly<old.TelemetryEventPropertyType>);
use_old_TypeAliasDeclaration_TelemetryEventPropertyType(
    get_current_TypeAliasDeclaration_TelemetryEventPropertyType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TransformedEvent": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TransformedEvent():
    TypeOnly<old.TransformedEvent<any,any,any>>;
declare function use_current_TypeAliasDeclaration_TransformedEvent(
    use: TypeOnly<current.TransformedEvent<any,any,any>>);
use_current_TypeAliasDeclaration_TransformedEvent(
    get_old_TypeAliasDeclaration_TransformedEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TransformedEvent": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TransformedEvent():
    TypeOnly<current.TransformedEvent<any,any,any>>;
declare function use_old_TypeAliasDeclaration_TransformedEvent(
    use: TypeOnly<old.TransformedEvent<any,any,any>>);
use_old_TypeAliasDeclaration_TransformedEvent(
    get_current_TypeAliasDeclaration_TransformedEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidCodeDetails": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isFluidCodeDetails():
    TypeOnly<typeof old.isFluidCodeDetails>;
declare function use_current_VariableDeclaration_isFluidCodeDetails(
    use: TypeOnly<typeof current.isFluidCodeDetails>);
use_current_VariableDeclaration_isFluidCodeDetails(
    get_old_VariableDeclaration_isFluidCodeDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidCodeDetails": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isFluidCodeDetails():
    TypeOnly<typeof current.isFluidCodeDetails>;
declare function use_old_VariableDeclaration_isFluidCodeDetails(
    use: TypeOnly<typeof old.isFluidCodeDetails>);
use_old_VariableDeclaration_isFluidCodeDetails(
    get_current_VariableDeclaration_isFluidCodeDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidPackage": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isFluidPackage():
    TypeOnly<typeof old.isFluidPackage>;
declare function use_current_VariableDeclaration_isFluidPackage(
    use: TypeOnly<typeof current.isFluidPackage>);
use_current_VariableDeclaration_isFluidPackage(
    get_old_VariableDeclaration_isFluidPackage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidPackage": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isFluidPackage():
    TypeOnly<typeof current.isFluidPackage>;
declare function use_old_VariableDeclaration_isFluidPackage(
    use: TypeOnly<typeof old.isFluidPackage>);
use_old_VariableDeclaration_isFluidPackage(
    get_current_VariableDeclaration_isFluidPackage());
