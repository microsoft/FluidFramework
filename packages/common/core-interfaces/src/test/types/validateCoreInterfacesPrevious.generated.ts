/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type * as old from "@fluidframework/core-interfaces-previous/internal";

import type * as current from "../../index.js";

type ValueOf<T> = T[keyof T];
type OnlySymbols<T> = T extends symbol ? T : never;
type WellKnownSymbols = OnlySymbols<ValueOf<typeof Symbol>>;
/**
 * Omit (replace with never) a key if it is a custom symbol,
 * not just symbol or a well known symbol from the global Symbol.
 */
type SkipUniqueSymbols<Key> = symbol extends Key
	? Key // Key is symbol or a generalization of symbol, so leave it as is.
	: Key extends symbol
		? Key extends WellKnownSymbols
			? Key // Key is a well known symbol from the global Symbol object. These are shared between packages, so they are fine and kept as is.
			: never // Key is most likely some specialized symbol, typically a unique symbol. These break type comparisons so are removed by replacing them with never.
		: Key; // Key is not a symbol (for example its a string or number), so leave it as is.
/**
 * Remove details of T which are incompatible with type testing while keeping as much as is practical.
 *
 * See 'build-tools/packages/build-tools/src/typeValidator/compatibility.ts' for more information.
 */
type TypeOnly<T> = T extends number
	? number
	: T extends boolean | bigint | string
		? T
		: T extends symbol
			? SkipUniqueSymbols<T>
			: {
					[P in keyof T as SkipUniqueSymbols<P>]: TypeOnly<T[P]>;
				};

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ConfigTypes": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ConfigTypes():
    TypeOnly<old.ConfigTypes>;
declare function use_current_TypeAliasDeclaration_ConfigTypes(
    use: TypeOnly<current.ConfigTypes>): void;
use_current_TypeAliasDeclaration_ConfigTypes(
    get_old_TypeAliasDeclaration_ConfigTypes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ConfigTypes": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ConfigTypes():
    TypeOnly<current.ConfigTypes>;
declare function use_old_TypeAliasDeclaration_ConfigTypes(
    use: TypeOnly<old.ConfigTypes>): void;
use_old_TypeAliasDeclaration_ConfigTypes(
    get_current_TypeAliasDeclaration_ConfigTypes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ErasedType": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_ErasedType():
    TypeOnly<old.ErasedType>;
declare function use_current_ClassDeclaration_ErasedType(
    use: TypeOnly<current.ErasedType>): void;
use_current_ClassDeclaration_ErasedType(
    get_old_ClassDeclaration_ErasedType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ErasedType": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_ErasedType():
    TypeOnly<current.ErasedType>;
declare function use_old_ClassDeclaration_ErasedType(
    use: TypeOnly<old.ErasedType>): void;
use_old_ClassDeclaration_ErasedType(
    get_current_ClassDeclaration_ErasedType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ExtendEventProvider": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ExtendEventProvider():
    TypeOnly<old.ExtendEventProvider<any,any,any>>;
declare function use_current_TypeAliasDeclaration_ExtendEventProvider(
    use: TypeOnly<current.ExtendEventProvider<any,any,any>>): void;
use_current_TypeAliasDeclaration_ExtendEventProvider(
    get_old_TypeAliasDeclaration_ExtendEventProvider());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ExtendEventProvider": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ExtendEventProvider():
    TypeOnly<current.ExtendEventProvider<any,any,any>>;
declare function use_old_TypeAliasDeclaration_ExtendEventProvider(
    use: TypeOnly<old.ExtendEventProvider<any,any,any>>): void;
use_old_TypeAliasDeclaration_ExtendEventProvider(
    get_current_TypeAliasDeclaration_ExtendEventProvider());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_FluidErrorTypes": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_FluidErrorTypes():
    TypeOnly<typeof old.FluidErrorTypes>;
declare function use_current_VariableDeclaration_FluidErrorTypes(
    use: TypeOnly<typeof current.FluidErrorTypes>): void;
use_current_VariableDeclaration_FluidErrorTypes(
    get_old_VariableDeclaration_FluidErrorTypes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_FluidErrorTypes": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_FluidErrorTypes():
    TypeOnly<typeof current.FluidErrorTypes>;
declare function use_old_VariableDeclaration_FluidErrorTypes(
    use: TypeOnly<typeof old.FluidErrorTypes>): void;
use_old_VariableDeclaration_FluidErrorTypes(
    get_current_VariableDeclaration_FluidErrorTypes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_FluidErrorTypes": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_FluidErrorTypes():
    TypeOnly<old.FluidErrorTypes>;
declare function use_current_TypeAliasDeclaration_FluidErrorTypes(
    use: TypeOnly<current.FluidErrorTypes>): void;
use_current_TypeAliasDeclaration_FluidErrorTypes(
    get_old_TypeAliasDeclaration_FluidErrorTypes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_FluidErrorTypes": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_FluidErrorTypes():
    TypeOnly<current.FluidErrorTypes>;
declare function use_old_TypeAliasDeclaration_FluidErrorTypes(
    use: TypeOnly<old.FluidErrorTypes>): void;
use_old_TypeAliasDeclaration_FluidErrorTypes(
    get_current_TypeAliasDeclaration_FluidErrorTypes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_FluidObject": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_FluidObject():
    TypeOnly<old.FluidObject>;
declare function use_current_TypeAliasDeclaration_FluidObject(
    use: TypeOnly<current.FluidObject>): void;
use_current_TypeAliasDeclaration_FluidObject(
    get_old_TypeAliasDeclaration_FluidObject());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_FluidObject": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_FluidObject():
    TypeOnly<current.FluidObject>;
declare function use_old_TypeAliasDeclaration_FluidObject(
    use: TypeOnly<old.FluidObject>): void;
use_old_TypeAliasDeclaration_FluidObject(
    get_current_TypeAliasDeclaration_FluidObject());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_FluidObjectKeys": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_FluidObjectKeys():
    TypeOnly<old.FluidObjectKeys<any>>;
declare function use_current_TypeAliasDeclaration_FluidObjectKeys(
    use: TypeOnly<current.FluidObjectKeys<any>>): void;
use_current_TypeAliasDeclaration_FluidObjectKeys(
    get_old_TypeAliasDeclaration_FluidObjectKeys());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_FluidObjectKeys": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_FluidObjectKeys():
    TypeOnly<current.FluidObjectKeys<any>>;
declare function use_old_TypeAliasDeclaration_FluidObjectKeys(
    use: TypeOnly<old.FluidObjectKeys<any>>): void;
use_old_TypeAliasDeclaration_FluidObjectKeys(
    get_current_TypeAliasDeclaration_FluidObjectKeys());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_FluidObjectProviderKeys": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_FluidObjectProviderKeys():
    TypeOnly<old.FluidObjectProviderKeys<any>>;
declare function use_current_TypeAliasDeclaration_FluidObjectProviderKeys(
    use: TypeOnly<current.FluidObjectProviderKeys<any>>): void;
use_current_TypeAliasDeclaration_FluidObjectProviderKeys(
    get_old_TypeAliasDeclaration_FluidObjectProviderKeys());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_FluidObjectProviderKeys": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_FluidObjectProviderKeys():
    TypeOnly<current.FluidObjectProviderKeys<any>>;
declare function use_old_TypeAliasDeclaration_FluidObjectProviderKeys(
    use: TypeOnly<old.FluidObjectProviderKeys<any>>): void;
use_old_TypeAliasDeclaration_FluidObjectProviderKeys(
    get_current_TypeAliasDeclaration_FluidObjectProviderKeys());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConfigProviderBase": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IConfigProviderBase():
    TypeOnly<old.IConfigProviderBase>;
declare function use_current_InterfaceDeclaration_IConfigProviderBase(
    use: TypeOnly<current.IConfigProviderBase>): void;
use_current_InterfaceDeclaration_IConfigProviderBase(
    get_old_InterfaceDeclaration_IConfigProviderBase());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConfigProviderBase": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IConfigProviderBase():
    TypeOnly<current.IConfigProviderBase>;
declare function use_old_InterfaceDeclaration_IConfigProviderBase(
    use: TypeOnly<old.IConfigProviderBase>): void;
use_old_InterfaceDeclaration_IConfigProviderBase(
    get_current_InterfaceDeclaration_IConfigProviderBase());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDisposable": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDisposable():
    TypeOnly<old.IDisposable>;
declare function use_current_InterfaceDeclaration_IDisposable(
    use: TypeOnly<current.IDisposable>): void;
use_current_InterfaceDeclaration_IDisposable(
    get_old_InterfaceDeclaration_IDisposable());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDisposable": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDisposable():
    TypeOnly<current.IDisposable>;
declare function use_old_InterfaceDeclaration_IDisposable(
    use: TypeOnly<old.IDisposable>): void;
use_old_InterfaceDeclaration_IDisposable(
    get_current_InterfaceDeclaration_IDisposable());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IErrorBase": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IErrorBase():
    TypeOnly<old.IErrorBase>;
declare function use_current_InterfaceDeclaration_IErrorBase(
    use: TypeOnly<current.IErrorBase>): void;
use_current_InterfaceDeclaration_IErrorBase(
    get_old_InterfaceDeclaration_IErrorBase());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IErrorBase": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IErrorBase():
    TypeOnly<current.IErrorBase>;
declare function use_old_InterfaceDeclaration_IErrorBase(
    use: TypeOnly<old.IErrorBase>): void;
use_old_InterfaceDeclaration_IErrorBase(
    get_current_InterfaceDeclaration_IErrorBase());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IErrorEvent": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IErrorEvent():
    TypeOnly<old.IErrorEvent>;
declare function use_current_InterfaceDeclaration_IErrorEvent(
    use: TypeOnly<current.IErrorEvent>): void;
use_current_InterfaceDeclaration_IErrorEvent(
    get_old_InterfaceDeclaration_IErrorEvent());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IErrorEvent": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IErrorEvent():
    TypeOnly<current.IErrorEvent>;
declare function use_old_InterfaceDeclaration_IErrorEvent(
    use: TypeOnly<old.IErrorEvent>): void;
use_old_InterfaceDeclaration_IErrorEvent(
    get_current_InterfaceDeclaration_IErrorEvent());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEvent": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IEvent():
    TypeOnly<old.IEvent>;
declare function use_current_InterfaceDeclaration_IEvent(
    use: TypeOnly<current.IEvent>): void;
use_current_InterfaceDeclaration_IEvent(
    get_old_InterfaceDeclaration_IEvent());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEvent": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IEvent():
    TypeOnly<current.IEvent>;
declare function use_old_InterfaceDeclaration_IEvent(
    use: TypeOnly<old.IEvent>): void;
use_old_InterfaceDeclaration_IEvent(
    get_current_InterfaceDeclaration_IEvent());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEventProvider": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IEventProvider():
    TypeOnly<old.IEventProvider<any>>;
declare function use_current_InterfaceDeclaration_IEventProvider(
    use: TypeOnly<current.IEventProvider<any>>): void;
use_current_InterfaceDeclaration_IEventProvider(
    get_old_InterfaceDeclaration_IEventProvider());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEventProvider": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IEventProvider():
    TypeOnly<current.IEventProvider<any>>;
declare function use_old_InterfaceDeclaration_IEventProvider(
    use: TypeOnly<old.IEventProvider<any>>): void;
use_old_InterfaceDeclaration_IEventProvider(
    get_current_InterfaceDeclaration_IEventProvider());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IEventThisPlaceHolder": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IEventThisPlaceHolder():
    TypeOnly<old.IEventThisPlaceHolder>;
declare function use_current_TypeAliasDeclaration_IEventThisPlaceHolder(
    use: TypeOnly<current.IEventThisPlaceHolder>): void;
use_current_TypeAliasDeclaration_IEventThisPlaceHolder(
    get_old_TypeAliasDeclaration_IEventThisPlaceHolder());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IEventThisPlaceHolder": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IEventThisPlaceHolder():
    TypeOnly<current.IEventThisPlaceHolder>;
declare function use_old_TypeAliasDeclaration_IEventThisPlaceHolder(
    use: TypeOnly<old.IEventThisPlaceHolder>): void;
use_old_TypeAliasDeclaration_IEventThisPlaceHolder(
    get_current_TypeAliasDeclaration_IEventThisPlaceHolder());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IEventTransformer": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IEventTransformer():
    TypeOnly<old.IEventTransformer<any,any>>;
declare function use_current_TypeAliasDeclaration_IEventTransformer(
    use: TypeOnly<current.IEventTransformer<any,any>>): void;
use_current_TypeAliasDeclaration_IEventTransformer(
    get_old_TypeAliasDeclaration_IEventTransformer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IEventTransformer": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IEventTransformer():
    TypeOnly<current.IEventTransformer<any,any>>;
declare function use_old_TypeAliasDeclaration_IEventTransformer(
    use: TypeOnly<old.IEventTransformer<any,any>>): void;
use_old_TypeAliasDeclaration_IEventTransformer(
    get_current_TypeAliasDeclaration_IEventTransformer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IFluidHandle": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_IFluidHandle():
    TypeOnly<typeof old.IFluidHandle>;
declare function use_current_VariableDeclaration_IFluidHandle(
    use: TypeOnly<typeof current.IFluidHandle>): void;
use_current_VariableDeclaration_IFluidHandle(
    get_old_VariableDeclaration_IFluidHandle());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IFluidHandle": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_IFluidHandle():
    TypeOnly<typeof current.IFluidHandle>;
declare function use_old_VariableDeclaration_IFluidHandle(
    use: TypeOnly<typeof old.IFluidHandle>): void;
use_old_VariableDeclaration_IFluidHandle(
    get_current_VariableDeclaration_IFluidHandle());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidHandle": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidHandle():
    TypeOnly<old.IFluidHandle>;
declare function use_current_InterfaceDeclaration_IFluidHandle(
    use: TypeOnly<current.IFluidHandle>): void;
use_current_InterfaceDeclaration_IFluidHandle(
    get_old_InterfaceDeclaration_IFluidHandle());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidHandle": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidHandle():
    TypeOnly<current.IFluidHandle>;
declare function use_old_InterfaceDeclaration_IFluidHandle(
    use: TypeOnly<old.IFluidHandle>): void;
use_old_InterfaceDeclaration_IFluidHandle(
    get_current_InterfaceDeclaration_IFluidHandle());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IFluidHandleContext": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_IFluidHandleContext():
    TypeOnly<typeof old.IFluidHandleContext>;
declare function use_current_VariableDeclaration_IFluidHandleContext(
    use: TypeOnly<typeof current.IFluidHandleContext>): void;
use_current_VariableDeclaration_IFluidHandleContext(
    get_old_VariableDeclaration_IFluidHandleContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IFluidHandleContext": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_IFluidHandleContext():
    TypeOnly<typeof current.IFluidHandleContext>;
declare function use_old_VariableDeclaration_IFluidHandleContext(
    use: TypeOnly<typeof old.IFluidHandleContext>): void;
use_old_VariableDeclaration_IFluidHandleContext(
    get_current_VariableDeclaration_IFluidHandleContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidHandleContext": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidHandleContext():
    TypeOnly<old.IFluidHandleContext>;
declare function use_current_InterfaceDeclaration_IFluidHandleContext(
    use: TypeOnly<current.IFluidHandleContext>): void;
use_current_InterfaceDeclaration_IFluidHandleContext(
    get_old_InterfaceDeclaration_IFluidHandleContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidHandleContext": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidHandleContext():
    TypeOnly<current.IFluidHandleContext>;
declare function use_old_InterfaceDeclaration_IFluidHandleContext(
    use: TypeOnly<old.IFluidHandleContext>): void;
use_old_InterfaceDeclaration_IFluidHandleContext(
    get_current_InterfaceDeclaration_IFluidHandleContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidHandleErased": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidHandleErased():
    TypeOnly<old.IFluidHandleErased<any>>;
declare function use_current_InterfaceDeclaration_IFluidHandleErased(
    use: TypeOnly<current.IFluidHandleErased<any>>): void;
use_current_InterfaceDeclaration_IFluidHandleErased(
    get_old_InterfaceDeclaration_IFluidHandleErased());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidHandleErased": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidHandleErased():
    TypeOnly<current.IFluidHandleErased<any>>;
declare function use_old_InterfaceDeclaration_IFluidHandleErased(
    use: TypeOnly<old.IFluidHandleErased<any>>): void;
use_old_InterfaceDeclaration_IFluidHandleErased(
    get_current_InterfaceDeclaration_IFluidHandleErased());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidHandleInternal": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidHandleInternal():
    TypeOnly<old.IFluidHandleInternal>;
declare function use_current_InterfaceDeclaration_IFluidHandleInternal(
    use: TypeOnly<current.IFluidHandleInternal>): void;
use_current_InterfaceDeclaration_IFluidHandleInternal(
    get_old_InterfaceDeclaration_IFluidHandleInternal());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidHandleInternal": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidHandleInternal():
    TypeOnly<current.IFluidHandleInternal>;
declare function use_old_InterfaceDeclaration_IFluidHandleInternal(
    use: TypeOnly<old.IFluidHandleInternal>): void;
use_old_InterfaceDeclaration_IFluidHandleInternal(
    get_current_InterfaceDeclaration_IFluidHandleInternal());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IFluidLoadable": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_IFluidLoadable():
    TypeOnly<typeof old.IFluidLoadable>;
declare function use_current_VariableDeclaration_IFluidLoadable(
    use: TypeOnly<typeof current.IFluidLoadable>): void;
use_current_VariableDeclaration_IFluidLoadable(
    get_old_VariableDeclaration_IFluidLoadable());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IFluidLoadable": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_IFluidLoadable():
    TypeOnly<typeof current.IFluidLoadable>;
declare function use_old_VariableDeclaration_IFluidLoadable(
    use: TypeOnly<typeof old.IFluidLoadable>): void;
use_old_VariableDeclaration_IFluidLoadable(
    get_current_VariableDeclaration_IFluidLoadable());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidLoadable": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidLoadable():
    TypeOnly<old.IFluidLoadable>;
declare function use_current_InterfaceDeclaration_IFluidLoadable(
    use: TypeOnly<current.IFluidLoadable>): void;
use_current_InterfaceDeclaration_IFluidLoadable(
    get_old_InterfaceDeclaration_IFluidLoadable());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidLoadable": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidLoadable():
    TypeOnly<current.IFluidLoadable>;
declare function use_old_InterfaceDeclaration_IFluidLoadable(
    use: TypeOnly<old.IFluidLoadable>): void;
use_old_InterfaceDeclaration_IFluidLoadable(
    get_current_InterfaceDeclaration_IFluidLoadable());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IFluidRunnable": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_IFluidRunnable():
    TypeOnly<typeof old.IFluidRunnable>;
declare function use_current_VariableDeclaration_IFluidRunnable(
    use: TypeOnly<typeof current.IFluidRunnable>): void;
use_current_VariableDeclaration_IFluidRunnable(
    get_old_VariableDeclaration_IFluidRunnable());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IFluidRunnable": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_IFluidRunnable():
    TypeOnly<typeof current.IFluidRunnable>;
declare function use_old_VariableDeclaration_IFluidRunnable(
    use: TypeOnly<typeof old.IFluidRunnable>): void;
use_old_VariableDeclaration_IFluidRunnable(
    get_current_VariableDeclaration_IFluidRunnable());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidRunnable": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidRunnable():
    TypeOnly<old.IFluidRunnable>;
declare function use_current_InterfaceDeclaration_IFluidRunnable(
    use: TypeOnly<current.IFluidRunnable>): void;
use_current_InterfaceDeclaration_IFluidRunnable(
    get_old_InterfaceDeclaration_IFluidRunnable());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidRunnable": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidRunnable():
    TypeOnly<current.IFluidRunnable>;
declare function use_old_InterfaceDeclaration_IFluidRunnable(
    use: TypeOnly<old.IFluidRunnable>): void;
use_old_InterfaceDeclaration_IFluidRunnable(
    get_current_InterfaceDeclaration_IFluidRunnable());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGenericError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IGenericError():
    TypeOnly<old.IGenericError>;
declare function use_current_InterfaceDeclaration_IGenericError(
    use: TypeOnly<current.IGenericError>): void;
use_current_InterfaceDeclaration_IGenericError(
    get_old_InterfaceDeclaration_IGenericError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGenericError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IGenericError():
    TypeOnly<current.IGenericError>;
declare function use_old_InterfaceDeclaration_IGenericError(
    use: TypeOnly<old.IGenericError>): void;
use_old_InterfaceDeclaration_IGenericError(
    get_current_InterfaceDeclaration_IGenericError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ILoggingError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ILoggingError():
    TypeOnly<old.ILoggingError>;
declare function use_current_InterfaceDeclaration_ILoggingError(
    use: TypeOnly<current.ILoggingError>): void;
use_current_InterfaceDeclaration_ILoggingError(
    get_old_InterfaceDeclaration_ILoggingError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ILoggingError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ILoggingError():
    TypeOnly<current.ILoggingError>;
declare function use_old_InterfaceDeclaration_ILoggingError(
    use: TypeOnly<old.ILoggingError>): void;
use_old_InterfaceDeclaration_ILoggingError(
    get_current_InterfaceDeclaration_ILoggingError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideFluidHandle": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProvideFluidHandle():
    TypeOnly<old.IProvideFluidHandle>;
declare function use_current_InterfaceDeclaration_IProvideFluidHandle(
    use: TypeOnly<current.IProvideFluidHandle>): void;
use_current_InterfaceDeclaration_IProvideFluidHandle(
    get_old_InterfaceDeclaration_IProvideFluidHandle());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideFluidHandle": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProvideFluidHandle():
    TypeOnly<current.IProvideFluidHandle>;
declare function use_old_InterfaceDeclaration_IProvideFluidHandle(
    use: TypeOnly<old.IProvideFluidHandle>): void;
use_old_InterfaceDeclaration_IProvideFluidHandle(
    get_current_InterfaceDeclaration_IProvideFluidHandle());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideFluidHandleContext": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProvideFluidHandleContext():
    TypeOnly<old.IProvideFluidHandleContext>;
declare function use_current_InterfaceDeclaration_IProvideFluidHandleContext(
    use: TypeOnly<current.IProvideFluidHandleContext>): void;
use_current_InterfaceDeclaration_IProvideFluidHandleContext(
    get_old_InterfaceDeclaration_IProvideFluidHandleContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideFluidHandleContext": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProvideFluidHandleContext():
    TypeOnly<current.IProvideFluidHandleContext>;
declare function use_old_InterfaceDeclaration_IProvideFluidHandleContext(
    use: TypeOnly<old.IProvideFluidHandleContext>): void;
use_old_InterfaceDeclaration_IProvideFluidHandleContext(
    get_current_InterfaceDeclaration_IProvideFluidHandleContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideFluidLoadable": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProvideFluidLoadable():
    TypeOnly<old.IProvideFluidLoadable>;
declare function use_current_InterfaceDeclaration_IProvideFluidLoadable(
    use: TypeOnly<current.IProvideFluidLoadable>): void;
use_current_InterfaceDeclaration_IProvideFluidLoadable(
    get_old_InterfaceDeclaration_IProvideFluidLoadable());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideFluidLoadable": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProvideFluidLoadable():
    TypeOnly<current.IProvideFluidLoadable>;
declare function use_old_InterfaceDeclaration_IProvideFluidLoadable(
    use: TypeOnly<old.IProvideFluidLoadable>): void;
use_old_InterfaceDeclaration_IProvideFluidLoadable(
    get_current_InterfaceDeclaration_IProvideFluidLoadable());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideFluidRunnable": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProvideFluidRunnable():
    TypeOnly<old.IProvideFluidRunnable>;
declare function use_current_InterfaceDeclaration_IProvideFluidRunnable(
    use: TypeOnly<current.IProvideFluidRunnable>): void;
use_current_InterfaceDeclaration_IProvideFluidRunnable(
    get_old_InterfaceDeclaration_IProvideFluidRunnable());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideFluidRunnable": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProvideFluidRunnable():
    TypeOnly<current.IProvideFluidRunnable>;
declare function use_old_InterfaceDeclaration_IProvideFluidRunnable(
    use: TypeOnly<old.IProvideFluidRunnable>): void;
use_old_InterfaceDeclaration_IProvideFluidRunnable(
    get_current_InterfaceDeclaration_IProvideFluidRunnable());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRequest": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IRequest():
    TypeOnly<old.IRequest>;
declare function use_current_InterfaceDeclaration_IRequest(
    use: TypeOnly<current.IRequest>): void;
use_current_InterfaceDeclaration_IRequest(
    get_old_InterfaceDeclaration_IRequest());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRequest": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IRequest():
    TypeOnly<current.IRequest>;
declare function use_old_InterfaceDeclaration_IRequest(
    use: TypeOnly<old.IRequest>): void;
use_old_InterfaceDeclaration_IRequest(
    get_current_InterfaceDeclaration_IRequest());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRequestHeader": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IRequestHeader():
    TypeOnly<old.IRequestHeader>;
declare function use_current_InterfaceDeclaration_IRequestHeader(
    use: TypeOnly<current.IRequestHeader>): void;
use_current_InterfaceDeclaration_IRequestHeader(
    get_old_InterfaceDeclaration_IRequestHeader());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRequestHeader": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IRequestHeader():
    TypeOnly<current.IRequestHeader>;
declare function use_old_InterfaceDeclaration_IRequestHeader(
    use: TypeOnly<old.IRequestHeader>): void;
use_old_InterfaceDeclaration_IRequestHeader(
    get_current_InterfaceDeclaration_IRequestHeader());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IResponse": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IResponse():
    TypeOnly<old.IResponse>;
declare function use_current_InterfaceDeclaration_IResponse(
    use: TypeOnly<current.IResponse>): void;
use_current_InterfaceDeclaration_IResponse(
    get_old_InterfaceDeclaration_IResponse());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IResponse": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IResponse():
    TypeOnly<current.IResponse>;
declare function use_old_InterfaceDeclaration_IResponse(
    use: TypeOnly<old.IResponse>): void;
use_old_InterfaceDeclaration_IResponse(
    get_current_InterfaceDeclaration_IResponse());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISignalEnvelope": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISignalEnvelope():
    TypeOnly<old.ISignalEnvelope>;
declare function use_current_InterfaceDeclaration_ISignalEnvelope(
    use: TypeOnly<current.ISignalEnvelope>): void;
use_current_InterfaceDeclaration_ISignalEnvelope(
    get_old_InterfaceDeclaration_ISignalEnvelope());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISignalEnvelope": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISignalEnvelope():
    TypeOnly<current.ISignalEnvelope>;
declare function use_old_InterfaceDeclaration_ISignalEnvelope(
    use: TypeOnly<old.ISignalEnvelope>): void;
use_old_InterfaceDeclaration_ISignalEnvelope(
    get_current_InterfaceDeclaration_ISignalEnvelope());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryBaseEvent": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITelemetryBaseEvent():
    TypeOnly<old.ITelemetryBaseEvent>;
declare function use_current_InterfaceDeclaration_ITelemetryBaseEvent(
    use: TypeOnly<current.ITelemetryBaseEvent>): void;
use_current_InterfaceDeclaration_ITelemetryBaseEvent(
    get_old_InterfaceDeclaration_ITelemetryBaseEvent());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryBaseEvent": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITelemetryBaseEvent():
    TypeOnly<current.ITelemetryBaseEvent>;
declare function use_old_InterfaceDeclaration_ITelemetryBaseEvent(
    use: TypeOnly<old.ITelemetryBaseEvent>): void;
use_old_InterfaceDeclaration_ITelemetryBaseEvent(
    get_current_InterfaceDeclaration_ITelemetryBaseEvent());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryBaseLogger": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITelemetryBaseLogger():
    TypeOnly<old.ITelemetryBaseLogger>;
declare function use_current_InterfaceDeclaration_ITelemetryBaseLogger(
    use: TypeOnly<current.ITelemetryBaseLogger>): void;
use_current_InterfaceDeclaration_ITelemetryBaseLogger(
    get_old_InterfaceDeclaration_ITelemetryBaseLogger());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryBaseLogger": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITelemetryBaseLogger():
    TypeOnly<current.ITelemetryBaseLogger>;
declare function use_old_InterfaceDeclaration_ITelemetryBaseLogger(
    use: TypeOnly<old.ITelemetryBaseLogger>): void;
use_old_InterfaceDeclaration_ITelemetryBaseLogger(
    get_current_InterfaceDeclaration_ITelemetryBaseLogger());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryBaseProperties": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITelemetryBaseProperties():
    TypeOnly<old.ITelemetryBaseProperties>;
declare function use_current_InterfaceDeclaration_ITelemetryBaseProperties(
    use: TypeOnly<current.ITelemetryBaseProperties>): void;
use_current_InterfaceDeclaration_ITelemetryBaseProperties(
    get_old_InterfaceDeclaration_ITelemetryBaseProperties());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryBaseProperties": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITelemetryBaseProperties():
    TypeOnly<current.ITelemetryBaseProperties>;
declare function use_old_InterfaceDeclaration_ITelemetryBaseProperties(
    use: TypeOnly<old.ITelemetryBaseProperties>): void;
use_old_InterfaceDeclaration_ITelemetryBaseProperties(
    get_current_InterfaceDeclaration_ITelemetryBaseProperties());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IThrottlingWarning": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IThrottlingWarning():
    TypeOnly<old.IThrottlingWarning>;
declare function use_current_InterfaceDeclaration_IThrottlingWarning(
    use: TypeOnly<current.IThrottlingWarning>): void;
use_current_InterfaceDeclaration_IThrottlingWarning(
    get_old_InterfaceDeclaration_IThrottlingWarning());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IThrottlingWarning": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IThrottlingWarning():
    TypeOnly<current.IThrottlingWarning>;
declare function use_old_InterfaceDeclaration_IThrottlingWarning(
    use: TypeOnly<old.IThrottlingWarning>): void;
use_old_InterfaceDeclaration_IThrottlingWarning(
    get_current_InterfaceDeclaration_IThrottlingWarning());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IUsageError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IUsageError():
    TypeOnly<old.IUsageError>;
declare function use_current_InterfaceDeclaration_IUsageError(
    use: TypeOnly<current.IUsageError>): void;
use_current_InterfaceDeclaration_IUsageError(
    get_old_InterfaceDeclaration_IUsageError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IUsageError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IUsageError():
    TypeOnly<current.IUsageError>;
declare function use_old_InterfaceDeclaration_IUsageError(
    use: TypeOnly<old.IUsageError>): void;
use_old_InterfaceDeclaration_IUsageError(
    get_current_InterfaceDeclaration_IUsageError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_LogLevel": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_LogLevel():
    TypeOnly<typeof old.LogLevel>;
declare function use_current_VariableDeclaration_LogLevel(
    use: TypeOnly<typeof current.LogLevel>): void;
use_current_VariableDeclaration_LogLevel(
    get_old_VariableDeclaration_LogLevel());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_LogLevel": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_LogLevel():
    TypeOnly<typeof current.LogLevel>;
declare function use_old_VariableDeclaration_LogLevel(
    use: TypeOnly<typeof old.LogLevel>): void;
use_old_VariableDeclaration_LogLevel(
    get_current_VariableDeclaration_LogLevel());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_LogLevel": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_LogLevel():
    TypeOnly<old.LogLevel>;
declare function use_current_TypeAliasDeclaration_LogLevel(
    use: TypeOnly<current.LogLevel>): void;
use_current_TypeAliasDeclaration_LogLevel(
    get_old_TypeAliasDeclaration_LogLevel());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_LogLevel": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_LogLevel():
    TypeOnly<current.LogLevel>;
declare function use_old_TypeAliasDeclaration_LogLevel(
    use: TypeOnly<old.LogLevel>): void;
use_old_TypeAliasDeclaration_LogLevel(
    get_current_TypeAliasDeclaration_LogLevel());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ReplaceIEventThisPlaceHolder": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder():
    TypeOnly<old.ReplaceIEventThisPlaceHolder<any,any>>;
declare function use_current_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder(
    use: TypeOnly<current.ReplaceIEventThisPlaceHolder<any,any>>): void;
use_current_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder(
    get_old_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ReplaceIEventThisPlaceHolder": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder():
    TypeOnly<current.ReplaceIEventThisPlaceHolder<any,any>>;
declare function use_old_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder(
    use: TypeOnly<old.ReplaceIEventThisPlaceHolder<any,any>>): void;
use_old_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder(
    get_current_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_Tagged": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_Tagged():
    TypeOnly<old.Tagged<any>>;
declare function use_current_InterfaceDeclaration_Tagged(
    use: TypeOnly<current.Tagged<any>>): void;
use_current_InterfaceDeclaration_Tagged(
    get_old_InterfaceDeclaration_Tagged());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_Tagged": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_Tagged():
    TypeOnly<current.Tagged<any>>;
declare function use_old_InterfaceDeclaration_Tagged(
    use: TypeOnly<old.Tagged<any>>): void;
use_old_InterfaceDeclaration_Tagged(
    get_current_InterfaceDeclaration_Tagged());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TelemetryBaseEventPropertyType": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_TelemetryBaseEventPropertyType():
    TypeOnly<old.TelemetryBaseEventPropertyType>;
declare function use_current_TypeAliasDeclaration_TelemetryBaseEventPropertyType(
    use: TypeOnly<current.TelemetryBaseEventPropertyType>): void;
use_current_TypeAliasDeclaration_TelemetryBaseEventPropertyType(
    get_old_TypeAliasDeclaration_TelemetryBaseEventPropertyType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TelemetryBaseEventPropertyType": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_TelemetryBaseEventPropertyType():
    TypeOnly<current.TelemetryBaseEventPropertyType>;
declare function use_old_TypeAliasDeclaration_TelemetryBaseEventPropertyType(
    use: TypeOnly<old.TelemetryBaseEventPropertyType>): void;
use_old_TypeAliasDeclaration_TelemetryBaseEventPropertyType(
    get_current_TypeAliasDeclaration_TelemetryBaseEventPropertyType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TransformedEvent": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_TransformedEvent():
    TypeOnly<old.TransformedEvent<any,any,any>>;
declare function use_current_TypeAliasDeclaration_TransformedEvent(
    use: TypeOnly<current.TransformedEvent<any,any,any>>): void;
use_current_TypeAliasDeclaration_TransformedEvent(
    get_old_TypeAliasDeclaration_TransformedEvent());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TransformedEvent": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_TransformedEvent():
    TypeOnly<current.TransformedEvent<any,any,any>>;
declare function use_old_TypeAliasDeclaration_TransformedEvent(
    use: TypeOnly<old.TransformedEvent<any,any,any>>): void;
use_old_TypeAliasDeclaration_TransformedEvent(
    get_current_TypeAliasDeclaration_TransformedEvent());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_fluidHandleSymbol": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_fluidHandleSymbol():
    TypeOnly<typeof old.fluidHandleSymbol>;
declare function use_current_VariableDeclaration_fluidHandleSymbol(
    use: TypeOnly<typeof current.fluidHandleSymbol>): void;
use_current_VariableDeclaration_fluidHandleSymbol(
    get_old_VariableDeclaration_fluidHandleSymbol());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_fluidHandleSymbol": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_fluidHandleSymbol():
    TypeOnly<typeof current.fluidHandleSymbol>;
declare function use_old_VariableDeclaration_fluidHandleSymbol(
    use: TypeOnly<typeof old.fluidHandleSymbol>): void;
use_old_VariableDeclaration_fluidHandleSymbol(
    get_current_VariableDeclaration_fluidHandleSymbol());
