/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */
import type * as old from "@fluidframework/core-interfaces-previous";
import type * as current from "../../index";


// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConfigTypes": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConfigTypes():
    TypeOnly<old.ConfigTypes>;
declare function use_current_TypeAliasDeclaration_ConfigTypes(
    use: TypeOnly<current.ConfigTypes>): void;
use_current_TypeAliasDeclaration_ConfigTypes(
    get_old_TypeAliasDeclaration_ConfigTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConfigTypes": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConfigTypes():
    TypeOnly<current.ConfigTypes>;
declare function use_old_TypeAliasDeclaration_ConfigTypes(
    use: TypeOnly<old.ConfigTypes>): void;
use_old_TypeAliasDeclaration_ConfigTypes(
    get_current_TypeAliasDeclaration_ConfigTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ExtendEventProvider": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ExtendEventProvider():
    TypeOnly<old.ExtendEventProvider<any,any,any>>;
declare function use_current_TypeAliasDeclaration_ExtendEventProvider(
    use: TypeOnly<current.ExtendEventProvider<any,any,any>>): void;
use_current_TypeAliasDeclaration_ExtendEventProvider(
    get_old_TypeAliasDeclaration_ExtendEventProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ExtendEventProvider": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ExtendEventProvider():
    TypeOnly<current.ExtendEventProvider<any,any,any>>;
declare function use_old_TypeAliasDeclaration_ExtendEventProvider(
    use: TypeOnly<old.ExtendEventProvider<any,any,any>>): void;
use_old_TypeAliasDeclaration_ExtendEventProvider(
    get_current_TypeAliasDeclaration_ExtendEventProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_FluidErrorTypes": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_FluidErrorTypes():
    TypeOnly<typeof old.FluidErrorTypes>;
declare function use_current_VariableDeclaration_FluidErrorTypes(
    use: TypeOnly<typeof current.FluidErrorTypes>): void;
use_current_VariableDeclaration_FluidErrorTypes(
    get_old_VariableDeclaration_FluidErrorTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_FluidErrorTypes": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_FluidErrorTypes():
    TypeOnly<typeof current.FluidErrorTypes>;
declare function use_old_VariableDeclaration_FluidErrorTypes(
    use: TypeOnly<typeof old.FluidErrorTypes>): void;
use_old_VariableDeclaration_FluidErrorTypes(
    get_current_VariableDeclaration_FluidErrorTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidErrorTypes": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_FluidErrorTypes():
    TypeOnly<old.FluidErrorTypes>;
declare function use_current_TypeAliasDeclaration_FluidErrorTypes(
    use: TypeOnly<current.FluidErrorTypes>): void;
use_current_TypeAliasDeclaration_FluidErrorTypes(
    get_old_TypeAliasDeclaration_FluidErrorTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidErrorTypes": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_FluidErrorTypes():
    TypeOnly<current.FluidErrorTypes>;
declare function use_old_TypeAliasDeclaration_FluidErrorTypes(
    use: TypeOnly<old.FluidErrorTypes>): void;
use_old_TypeAliasDeclaration_FluidErrorTypes(
    get_current_TypeAliasDeclaration_FluidErrorTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObject": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_FluidObject():
    TypeOnly<old.FluidObject>;
declare function use_current_TypeAliasDeclaration_FluidObject(
    use: TypeOnly<current.FluidObject>): void;
use_current_TypeAliasDeclaration_FluidObject(
    get_old_TypeAliasDeclaration_FluidObject());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObject": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_FluidObject():
    TypeOnly<current.FluidObject>;
declare function use_old_TypeAliasDeclaration_FluidObject(
    use: TypeOnly<old.FluidObject>): void;
use_old_TypeAliasDeclaration_FluidObject(
    get_current_TypeAliasDeclaration_FluidObject());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObjectKeys": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_FluidObjectKeys():
    TypeOnly<old.FluidObjectKeys<any>>;
declare function use_current_TypeAliasDeclaration_FluidObjectKeys(
    use: TypeOnly<current.FluidObjectKeys<any>>): void;
use_current_TypeAliasDeclaration_FluidObjectKeys(
    get_old_TypeAliasDeclaration_FluidObjectKeys());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObjectKeys": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_FluidObjectKeys():
    TypeOnly<current.FluidObjectKeys<any>>;
declare function use_old_TypeAliasDeclaration_FluidObjectKeys(
    use: TypeOnly<old.FluidObjectKeys<any>>): void;
use_old_TypeAliasDeclaration_FluidObjectKeys(
    get_current_TypeAliasDeclaration_FluidObjectKeys());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObjectProviderKeys": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_FluidObjectProviderKeys():
    TypeOnly<old.FluidObjectProviderKeys<any>>;
declare function use_current_TypeAliasDeclaration_FluidObjectProviderKeys(
    use: TypeOnly<current.FluidObjectProviderKeys<any>>): void;
use_current_TypeAliasDeclaration_FluidObjectProviderKeys(
    get_old_TypeAliasDeclaration_FluidObjectProviderKeys());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObjectProviderKeys": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_FluidObjectProviderKeys():
    TypeOnly<current.FluidObjectProviderKeys<any>>;
declare function use_old_TypeAliasDeclaration_FluidObjectProviderKeys(
    use: TypeOnly<old.FluidObjectProviderKeys<any>>): void;
use_old_TypeAliasDeclaration_FluidObjectProviderKeys(
    get_current_TypeAliasDeclaration_FluidObjectProviderKeys());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConfigProviderBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConfigProviderBase():
    TypeOnly<old.IConfigProviderBase>;
declare function use_current_InterfaceDeclaration_IConfigProviderBase(
    use: TypeOnly<current.IConfigProviderBase>): void;
use_current_InterfaceDeclaration_IConfigProviderBase(
    get_old_InterfaceDeclaration_IConfigProviderBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConfigProviderBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConfigProviderBase():
    TypeOnly<current.IConfigProviderBase>;
declare function use_old_InterfaceDeclaration_IConfigProviderBase(
    use: TypeOnly<old.IConfigProviderBase>): void;
use_old_InterfaceDeclaration_IConfigProviderBase(
    get_current_InterfaceDeclaration_IConfigProviderBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDisposable": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDisposable():
    TypeOnly<old.IDisposable>;
declare function use_current_InterfaceDeclaration_IDisposable(
    use: TypeOnly<current.IDisposable>): void;
use_current_InterfaceDeclaration_IDisposable(
    get_old_InterfaceDeclaration_IDisposable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDisposable": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDisposable():
    TypeOnly<current.IDisposable>;
declare function use_old_InterfaceDeclaration_IDisposable(
    use: TypeOnly<old.IDisposable>): void;
use_old_InterfaceDeclaration_IDisposable(
    get_current_InterfaceDeclaration_IDisposable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IErrorBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IErrorBase():
    TypeOnly<old.IErrorBase>;
declare function use_current_InterfaceDeclaration_IErrorBase(
    use: TypeOnly<current.IErrorBase>): void;
use_current_InterfaceDeclaration_IErrorBase(
    get_old_InterfaceDeclaration_IErrorBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IErrorBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IErrorBase():
    TypeOnly<current.IErrorBase>;
declare function use_old_InterfaceDeclaration_IErrorBase(
    use: TypeOnly<old.IErrorBase>): void;
use_old_InterfaceDeclaration_IErrorBase(
    get_current_InterfaceDeclaration_IErrorBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IErrorEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IErrorEvent():
    TypeOnly<old.IErrorEvent>;
declare function use_current_InterfaceDeclaration_IErrorEvent(
    use: TypeOnly<current.IErrorEvent>): void;
use_current_InterfaceDeclaration_IErrorEvent(
    get_old_InterfaceDeclaration_IErrorEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IErrorEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IErrorEvent():
    TypeOnly<current.IErrorEvent>;
declare function use_old_InterfaceDeclaration_IErrorEvent(
    use: TypeOnly<old.IErrorEvent>): void;
use_old_InterfaceDeclaration_IErrorEvent(
    get_current_InterfaceDeclaration_IErrorEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IEvent():
    TypeOnly<old.IEvent>;
declare function use_current_InterfaceDeclaration_IEvent(
    use: TypeOnly<current.IEvent>): void;
use_current_InterfaceDeclaration_IEvent(
    get_old_InterfaceDeclaration_IEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IEvent():
    TypeOnly<current.IEvent>;
declare function use_old_InterfaceDeclaration_IEvent(
    use: TypeOnly<old.IEvent>): void;
use_old_InterfaceDeclaration_IEvent(
    get_current_InterfaceDeclaration_IEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEventProvider": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IEventProvider():
    TypeOnly<old.IEventProvider<any>>;
declare function use_current_InterfaceDeclaration_IEventProvider(
    use: TypeOnly<current.IEventProvider<any>>): void;
use_current_InterfaceDeclaration_IEventProvider(
    get_old_InterfaceDeclaration_IEventProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEventProvider": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IEventProvider():
    TypeOnly<current.IEventProvider<any>>;
declare function use_old_InterfaceDeclaration_IEventProvider(
    use: TypeOnly<old.IEventProvider<any>>): void;
use_old_InterfaceDeclaration_IEventProvider(
    get_current_InterfaceDeclaration_IEventProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IEventThisPlaceHolder": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IEventThisPlaceHolder():
    TypeOnly<old.IEventThisPlaceHolder>;
declare function use_current_TypeAliasDeclaration_IEventThisPlaceHolder(
    use: TypeOnly<current.IEventThisPlaceHolder>): void;
use_current_TypeAliasDeclaration_IEventThisPlaceHolder(
    get_old_TypeAliasDeclaration_IEventThisPlaceHolder());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IEventThisPlaceHolder": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IEventThisPlaceHolder():
    TypeOnly<current.IEventThisPlaceHolder>;
declare function use_old_TypeAliasDeclaration_IEventThisPlaceHolder(
    use: TypeOnly<old.IEventThisPlaceHolder>): void;
use_old_TypeAliasDeclaration_IEventThisPlaceHolder(
    get_current_TypeAliasDeclaration_IEventThisPlaceHolder());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IEventTransformer": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IEventTransformer():
    TypeOnly<old.IEventTransformer<any,any>>;
declare function use_current_TypeAliasDeclaration_IEventTransformer(
    use: TypeOnly<current.IEventTransformer<any,any>>): void;
use_current_TypeAliasDeclaration_IEventTransformer(
    get_old_TypeAliasDeclaration_IEventTransformer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IEventTransformer": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IEventTransformer():
    TypeOnly<current.IEventTransformer<any,any>>;
declare function use_old_TypeAliasDeclaration_IEventTransformer(
    use: TypeOnly<old.IEventTransformer<any,any>>): void;
use_old_TypeAliasDeclaration_IEventTransformer(
    get_current_TypeAliasDeclaration_IEventTransformer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidCodeDetails():
    TypeOnly<old.IFluidCodeDetails>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetails(
    use: TypeOnly<current.IFluidCodeDetails>): void;
use_current_InterfaceDeclaration_IFluidCodeDetails(
    get_old_InterfaceDeclaration_IFluidCodeDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidCodeDetails():
    TypeOnly<current.IFluidCodeDetails>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetails(
    use: TypeOnly<old.IFluidCodeDetails>): void;
use_old_InterfaceDeclaration_IFluidCodeDetails(
    get_current_InterfaceDeclaration_IFluidCodeDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidCodeDetailsComparer": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<typeof old.IFluidCodeDetailsComparer>;
declare function use_current_VariableDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<typeof current.IFluidCodeDetailsComparer>): void;
use_current_VariableDeclaration_IFluidCodeDetailsComparer(
    get_old_VariableDeclaration_IFluidCodeDetailsComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidCodeDetailsComparer": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<typeof current.IFluidCodeDetailsComparer>;
declare function use_old_VariableDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<typeof old.IFluidCodeDetailsComparer>): void;
use_old_VariableDeclaration_IFluidCodeDetailsComparer(
    get_current_VariableDeclaration_IFluidCodeDetailsComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsComparer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<old.IFluidCodeDetailsComparer>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<current.IFluidCodeDetailsComparer>): void;
use_current_InterfaceDeclaration_IFluidCodeDetailsComparer(
    get_old_InterfaceDeclaration_IFluidCodeDetailsComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsComparer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidCodeDetailsComparer():
    TypeOnly<current.IFluidCodeDetailsComparer>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetailsComparer(
    use: TypeOnly<old.IFluidCodeDetailsComparer>): void;
use_old_InterfaceDeclaration_IFluidCodeDetailsComparer(
    get_current_InterfaceDeclaration_IFluidCodeDetailsComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidCodeDetailsConfig():
    TypeOnly<old.IFluidCodeDetailsConfig>;
declare function use_current_InterfaceDeclaration_IFluidCodeDetailsConfig(
    use: TypeOnly<current.IFluidCodeDetailsConfig>): void;
use_current_InterfaceDeclaration_IFluidCodeDetailsConfig(
    get_old_InterfaceDeclaration_IFluidCodeDetailsConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidCodeDetailsConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidCodeDetailsConfig():
    TypeOnly<current.IFluidCodeDetailsConfig>;
declare function use_old_InterfaceDeclaration_IFluidCodeDetailsConfig(
    use: TypeOnly<old.IFluidCodeDetailsConfig>): void;
use_old_InterfaceDeclaration_IFluidCodeDetailsConfig(
    get_current_InterfaceDeclaration_IFluidCodeDetailsConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidHandle": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidHandle():
    TypeOnly<typeof old.IFluidHandle>;
declare function use_current_VariableDeclaration_IFluidHandle(
    use: TypeOnly<typeof current.IFluidHandle>): void;
use_current_VariableDeclaration_IFluidHandle(
    get_old_VariableDeclaration_IFluidHandle());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidHandle": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidHandle():
    TypeOnly<typeof current.IFluidHandle>;
declare function use_old_VariableDeclaration_IFluidHandle(
    use: TypeOnly<typeof old.IFluidHandle>): void;
use_old_VariableDeclaration_IFluidHandle(
    get_current_VariableDeclaration_IFluidHandle());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidHandle": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidHandle():
    TypeOnly<old.IFluidHandle>;
declare function use_current_InterfaceDeclaration_IFluidHandle(
    use: TypeOnly<current.IFluidHandle>): void;
use_current_InterfaceDeclaration_IFluidHandle(
    get_old_InterfaceDeclaration_IFluidHandle());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidHandle": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidHandle():
    TypeOnly<current.IFluidHandle>;
declare function use_old_InterfaceDeclaration_IFluidHandle(
    use: TypeOnly<old.IFluidHandle>): void;
use_old_InterfaceDeclaration_IFluidHandle(
    get_current_InterfaceDeclaration_IFluidHandle());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidHandleContext": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidHandleContext():
    TypeOnly<typeof old.IFluidHandleContext>;
declare function use_current_VariableDeclaration_IFluidHandleContext(
    use: TypeOnly<typeof current.IFluidHandleContext>): void;
use_current_VariableDeclaration_IFluidHandleContext(
    get_old_VariableDeclaration_IFluidHandleContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidHandleContext": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidHandleContext():
    TypeOnly<typeof current.IFluidHandleContext>;
declare function use_old_VariableDeclaration_IFluidHandleContext(
    use: TypeOnly<typeof old.IFluidHandleContext>): void;
use_old_VariableDeclaration_IFluidHandleContext(
    get_current_VariableDeclaration_IFluidHandleContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidHandleContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidHandleContext():
    TypeOnly<old.IFluidHandleContext>;
declare function use_current_InterfaceDeclaration_IFluidHandleContext(
    use: TypeOnly<current.IFluidHandleContext>): void;
use_current_InterfaceDeclaration_IFluidHandleContext(
    get_old_InterfaceDeclaration_IFluidHandleContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidHandleContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidHandleContext():
    TypeOnly<current.IFluidHandleContext>;
declare function use_old_InterfaceDeclaration_IFluidHandleContext(
    use: TypeOnly<old.IFluidHandleContext>): void;
use_old_InterfaceDeclaration_IFluidHandleContext(
    get_current_InterfaceDeclaration_IFluidHandleContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidLoadable": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidLoadable():
    TypeOnly<typeof old.IFluidLoadable>;
declare function use_current_VariableDeclaration_IFluidLoadable(
    use: TypeOnly<typeof current.IFluidLoadable>): void;
use_current_VariableDeclaration_IFluidLoadable(
    get_old_VariableDeclaration_IFluidLoadable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidLoadable": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidLoadable():
    TypeOnly<typeof current.IFluidLoadable>;
declare function use_old_VariableDeclaration_IFluidLoadable(
    use: TypeOnly<typeof old.IFluidLoadable>): void;
use_old_VariableDeclaration_IFluidLoadable(
    get_current_VariableDeclaration_IFluidLoadable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidLoadable": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidLoadable():
    TypeOnly<old.IFluidLoadable>;
declare function use_current_InterfaceDeclaration_IFluidLoadable(
    use: TypeOnly<current.IFluidLoadable>): void;
use_current_InterfaceDeclaration_IFluidLoadable(
    get_old_InterfaceDeclaration_IFluidLoadable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidLoadable": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidLoadable():
    TypeOnly<current.IFluidLoadable>;
declare function use_old_InterfaceDeclaration_IFluidLoadable(
    use: TypeOnly<old.IFluidLoadable>): void;
use_old_InterfaceDeclaration_IFluidLoadable(
    get_current_InterfaceDeclaration_IFluidLoadable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidPackage():
    TypeOnly<old.IFluidPackage>;
declare function use_current_InterfaceDeclaration_IFluidPackage(
    use: TypeOnly<current.IFluidPackage>): void;
use_current_InterfaceDeclaration_IFluidPackage(
    get_old_InterfaceDeclaration_IFluidPackage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidPackage():
    TypeOnly<current.IFluidPackage>;
declare function use_old_InterfaceDeclaration_IFluidPackage(
    use: TypeOnly<old.IFluidPackage>): void;
use_old_InterfaceDeclaration_IFluidPackage(
    get_current_InterfaceDeclaration_IFluidPackage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackageEnvironment": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidPackageEnvironment():
    TypeOnly<old.IFluidPackageEnvironment>;
declare function use_current_InterfaceDeclaration_IFluidPackageEnvironment(
    use: TypeOnly<current.IFluidPackageEnvironment>): void;
use_current_InterfaceDeclaration_IFluidPackageEnvironment(
    get_old_InterfaceDeclaration_IFluidPackageEnvironment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidPackageEnvironment": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidPackageEnvironment():
    TypeOnly<current.IFluidPackageEnvironment>;
declare function use_old_InterfaceDeclaration_IFluidPackageEnvironment(
    use: TypeOnly<old.IFluidPackageEnvironment>): void;
use_old_InterfaceDeclaration_IFluidPackageEnvironment(
    get_current_InterfaceDeclaration_IFluidPackageEnvironment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidRunnable": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidRunnable():
    TypeOnly<typeof old.IFluidRunnable>;
declare function use_current_VariableDeclaration_IFluidRunnable(
    use: TypeOnly<typeof current.IFluidRunnable>): void;
use_current_VariableDeclaration_IFluidRunnable(
    get_old_VariableDeclaration_IFluidRunnable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidRunnable": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidRunnable():
    TypeOnly<typeof current.IFluidRunnable>;
declare function use_old_VariableDeclaration_IFluidRunnable(
    use: TypeOnly<typeof old.IFluidRunnable>): void;
use_old_VariableDeclaration_IFluidRunnable(
    get_current_VariableDeclaration_IFluidRunnable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidRunnable": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidRunnable():
    TypeOnly<old.IFluidRunnable>;
declare function use_current_InterfaceDeclaration_IFluidRunnable(
    use: TypeOnly<current.IFluidRunnable>): void;
use_current_InterfaceDeclaration_IFluidRunnable(
    get_old_InterfaceDeclaration_IFluidRunnable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidRunnable": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidRunnable():
    TypeOnly<current.IFluidRunnable>;
declare function use_old_InterfaceDeclaration_IFluidRunnable(
    use: TypeOnly<old.IFluidRunnable>): void;
use_old_InterfaceDeclaration_IFluidRunnable(
    get_current_InterfaceDeclaration_IFluidRunnable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGenericError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGenericError():
    TypeOnly<old.IGenericError>;
declare function use_current_InterfaceDeclaration_IGenericError(
    use: TypeOnly<current.IGenericError>): void;
use_current_InterfaceDeclaration_IGenericError(
    get_old_InterfaceDeclaration_IGenericError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGenericError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGenericError():
    TypeOnly<current.IGenericError>;
declare function use_old_InterfaceDeclaration_IGenericError(
    use: TypeOnly<old.IGenericError>): void;
use_old_InterfaceDeclaration_IGenericError(
    get_current_InterfaceDeclaration_IGenericError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILoggingError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ILoggingError():
    TypeOnly<old.ILoggingError>;
declare function use_current_InterfaceDeclaration_ILoggingError(
    use: TypeOnly<current.ILoggingError>): void;
use_current_InterfaceDeclaration_ILoggingError(
    get_old_InterfaceDeclaration_ILoggingError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILoggingError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ILoggingError():
    TypeOnly<current.ILoggingError>;
declare function use_old_InterfaceDeclaration_ILoggingError(
    use: TypeOnly<old.ILoggingError>): void;
use_old_InterfaceDeclaration_ILoggingError(
    get_current_InterfaceDeclaration_ILoggingError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidCodeDetailsComparer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer():
    TypeOnly<old.IProvideFluidCodeDetailsComparer>;
declare function use_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    use: TypeOnly<current.IProvideFluidCodeDetailsComparer>): void;
use_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    get_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidCodeDetailsComparer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer():
    TypeOnly<current.IProvideFluidCodeDetailsComparer>;
declare function use_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    use: TypeOnly<old.IProvideFluidCodeDetailsComparer>): void;
use_old_InterfaceDeclaration_IProvideFluidCodeDetailsComparer(
    get_current_InterfaceDeclaration_IProvideFluidCodeDetailsComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidHandle": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidHandle():
    TypeOnly<old.IProvideFluidHandle>;
declare function use_current_InterfaceDeclaration_IProvideFluidHandle(
    use: TypeOnly<current.IProvideFluidHandle>): void;
use_current_InterfaceDeclaration_IProvideFluidHandle(
    get_old_InterfaceDeclaration_IProvideFluidHandle());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidHandle": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidHandle():
    TypeOnly<current.IProvideFluidHandle>;
declare function use_old_InterfaceDeclaration_IProvideFluidHandle(
    use: TypeOnly<old.IProvideFluidHandle>): void;
use_old_InterfaceDeclaration_IProvideFluidHandle(
    get_current_InterfaceDeclaration_IProvideFluidHandle());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidHandleContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidHandleContext():
    TypeOnly<old.IProvideFluidHandleContext>;
declare function use_current_InterfaceDeclaration_IProvideFluidHandleContext(
    use: TypeOnly<current.IProvideFluidHandleContext>): void;
use_current_InterfaceDeclaration_IProvideFluidHandleContext(
    get_old_InterfaceDeclaration_IProvideFluidHandleContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidHandleContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidHandleContext():
    TypeOnly<current.IProvideFluidHandleContext>;
declare function use_old_InterfaceDeclaration_IProvideFluidHandleContext(
    use: TypeOnly<old.IProvideFluidHandleContext>): void;
use_old_InterfaceDeclaration_IProvideFluidHandleContext(
    get_current_InterfaceDeclaration_IProvideFluidHandleContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidLoadable": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidLoadable():
    TypeOnly<old.IProvideFluidLoadable>;
declare function use_current_InterfaceDeclaration_IProvideFluidLoadable(
    use: TypeOnly<current.IProvideFluidLoadable>): void;
use_current_InterfaceDeclaration_IProvideFluidLoadable(
    get_old_InterfaceDeclaration_IProvideFluidLoadable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidLoadable": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidLoadable():
    TypeOnly<current.IProvideFluidLoadable>;
declare function use_old_InterfaceDeclaration_IProvideFluidLoadable(
    use: TypeOnly<old.IProvideFluidLoadable>): void;
use_old_InterfaceDeclaration_IProvideFluidLoadable(
    get_current_InterfaceDeclaration_IProvideFluidLoadable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidRunnable": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidRunnable():
    TypeOnly<old.IProvideFluidRunnable>;
declare function use_current_InterfaceDeclaration_IProvideFluidRunnable(
    use: TypeOnly<current.IProvideFluidRunnable>): void;
use_current_InterfaceDeclaration_IProvideFluidRunnable(
    get_old_InterfaceDeclaration_IProvideFluidRunnable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidRunnable": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidRunnable():
    TypeOnly<current.IProvideFluidRunnable>;
declare function use_old_InterfaceDeclaration_IProvideFluidRunnable(
    use: TypeOnly<old.IProvideFluidRunnable>): void;
use_old_InterfaceDeclaration_IProvideFluidRunnable(
    get_current_InterfaceDeclaration_IProvideFluidRunnable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRequest": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRequest():
    TypeOnly<old.IRequest>;
declare function use_current_InterfaceDeclaration_IRequest(
    use: TypeOnly<current.IRequest>): void;
use_current_InterfaceDeclaration_IRequest(
    get_old_InterfaceDeclaration_IRequest());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRequest": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRequest():
    TypeOnly<current.IRequest>;
declare function use_old_InterfaceDeclaration_IRequest(
    use: TypeOnly<old.IRequest>): void;
use_old_InterfaceDeclaration_IRequest(
    get_current_InterfaceDeclaration_IRequest());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRequestHeader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRequestHeader():
    TypeOnly<old.IRequestHeader>;
declare function use_current_InterfaceDeclaration_IRequestHeader(
    use: TypeOnly<current.IRequestHeader>): void;
use_current_InterfaceDeclaration_IRequestHeader(
    get_old_InterfaceDeclaration_IRequestHeader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRequestHeader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRequestHeader():
    TypeOnly<current.IRequestHeader>;
declare function use_old_InterfaceDeclaration_IRequestHeader(
    use: TypeOnly<old.IRequestHeader>): void;
use_old_InterfaceDeclaration_IRequestHeader(
    get_current_InterfaceDeclaration_IRequestHeader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IResponse": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IResponse():
    TypeOnly<old.IResponse>;
declare function use_current_InterfaceDeclaration_IResponse(
    use: TypeOnly<current.IResponse>): void;
use_current_InterfaceDeclaration_IResponse(
    get_old_InterfaceDeclaration_IResponse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IResponse": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IResponse():
    TypeOnly<current.IResponse>;
declare function use_old_InterfaceDeclaration_IResponse(
    use: TypeOnly<old.IResponse>): void;
use_old_InterfaceDeclaration_IResponse(
    get_current_InterfaceDeclaration_IResponse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITaggedTelemetryPropertyType": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITaggedTelemetryPropertyType():
    TypeOnly<old.ITaggedTelemetryPropertyType>;
declare function use_current_InterfaceDeclaration_ITaggedTelemetryPropertyType(
    use: TypeOnly<current.ITaggedTelemetryPropertyType>): void;
use_current_InterfaceDeclaration_ITaggedTelemetryPropertyType(
    get_old_InterfaceDeclaration_ITaggedTelemetryPropertyType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITaggedTelemetryPropertyType": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITaggedTelemetryPropertyType():
    TypeOnly<current.ITaggedTelemetryPropertyType>;
declare function use_old_InterfaceDeclaration_ITaggedTelemetryPropertyType(
    use: TypeOnly<old.ITaggedTelemetryPropertyType>): void;
use_old_InterfaceDeclaration_ITaggedTelemetryPropertyType(
    get_current_InterfaceDeclaration_ITaggedTelemetryPropertyType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryBaseEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryBaseEvent():
    TypeOnly<old.ITelemetryBaseEvent>;
declare function use_current_InterfaceDeclaration_ITelemetryBaseEvent(
    use: TypeOnly<current.ITelemetryBaseEvent>): void;
use_current_InterfaceDeclaration_ITelemetryBaseEvent(
    get_old_InterfaceDeclaration_ITelemetryBaseEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryBaseEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryBaseEvent():
    TypeOnly<current.ITelemetryBaseEvent>;
declare function use_old_InterfaceDeclaration_ITelemetryBaseEvent(
    use: TypeOnly<old.ITelemetryBaseEvent>): void;
use_old_InterfaceDeclaration_ITelemetryBaseEvent(
    get_current_InterfaceDeclaration_ITelemetryBaseEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryBaseLogger": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryBaseLogger():
    TypeOnly<old.ITelemetryBaseLogger>;
declare function use_current_InterfaceDeclaration_ITelemetryBaseLogger(
    use: TypeOnly<current.ITelemetryBaseLogger>): void;
use_current_InterfaceDeclaration_ITelemetryBaseLogger(
    get_old_InterfaceDeclaration_ITelemetryBaseLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryBaseLogger": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryBaseLogger():
    TypeOnly<current.ITelemetryBaseLogger>;
declare function use_old_InterfaceDeclaration_ITelemetryBaseLogger(
    use: TypeOnly<old.ITelemetryBaseLogger>): void;
use_old_InterfaceDeclaration_ITelemetryBaseLogger(
    get_current_InterfaceDeclaration_ITelemetryBaseLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ITelemetryBaseProperties": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ITelemetryBaseProperties():
    TypeOnly<old.ITelemetryBaseProperties>;
declare function use_current_TypeAliasDeclaration_ITelemetryBaseProperties(
    use: TypeOnly<current.ITelemetryBaseProperties>): void;
use_current_TypeAliasDeclaration_ITelemetryBaseProperties(
    get_old_TypeAliasDeclaration_ITelemetryBaseProperties());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ITelemetryBaseProperties": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ITelemetryBaseProperties():
    TypeOnly<current.ITelemetryBaseProperties>;
declare function use_old_TypeAliasDeclaration_ITelemetryBaseProperties(
    use: TypeOnly<old.ITelemetryBaseProperties>): void;
use_old_TypeAliasDeclaration_ITelemetryBaseProperties(
    get_current_TypeAliasDeclaration_ITelemetryBaseProperties());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryErrorEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryErrorEvent():
    TypeOnly<old.ITelemetryErrorEvent>;
declare function use_current_InterfaceDeclaration_ITelemetryErrorEvent(
    use: TypeOnly<current.ITelemetryErrorEvent>): void;
use_current_InterfaceDeclaration_ITelemetryErrorEvent(
    get_old_InterfaceDeclaration_ITelemetryErrorEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryErrorEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryErrorEvent():
    TypeOnly<current.ITelemetryErrorEvent>;
declare function use_old_InterfaceDeclaration_ITelemetryErrorEvent(
    use: TypeOnly<old.ITelemetryErrorEvent>): void;
use_old_InterfaceDeclaration_ITelemetryErrorEvent(
    get_current_InterfaceDeclaration_ITelemetryErrorEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryGenericEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryGenericEvent():
    TypeOnly<old.ITelemetryGenericEvent>;
declare function use_current_InterfaceDeclaration_ITelemetryGenericEvent(
    use: TypeOnly<current.ITelemetryGenericEvent>): void;
use_current_InterfaceDeclaration_ITelemetryGenericEvent(
    get_old_InterfaceDeclaration_ITelemetryGenericEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryGenericEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryGenericEvent():
    TypeOnly<current.ITelemetryGenericEvent>;
declare function use_old_InterfaceDeclaration_ITelemetryGenericEvent(
    use: TypeOnly<old.ITelemetryGenericEvent>): void;
use_old_InterfaceDeclaration_ITelemetryGenericEvent(
    get_current_InterfaceDeclaration_ITelemetryGenericEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryLogger": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryLogger():
    TypeOnly<old.ITelemetryLogger>;
declare function use_current_InterfaceDeclaration_ITelemetryLogger(
    use: TypeOnly<current.ITelemetryLogger>): void;
use_current_InterfaceDeclaration_ITelemetryLogger(
    get_old_InterfaceDeclaration_ITelemetryLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryLogger": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryLogger():
    TypeOnly<current.ITelemetryLogger>;
declare function use_old_InterfaceDeclaration_ITelemetryLogger(
    use: TypeOnly<old.ITelemetryLogger>): void;
use_old_InterfaceDeclaration_ITelemetryLogger(
    get_current_InterfaceDeclaration_ITelemetryLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryPerformanceEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryPerformanceEvent():
    TypeOnly<old.ITelemetryPerformanceEvent>;
declare function use_current_InterfaceDeclaration_ITelemetryPerformanceEvent(
    use: TypeOnly<current.ITelemetryPerformanceEvent>): void;
use_current_InterfaceDeclaration_ITelemetryPerformanceEvent(
    get_old_InterfaceDeclaration_ITelemetryPerformanceEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryPerformanceEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryPerformanceEvent():
    TypeOnly<current.ITelemetryPerformanceEvent>;
declare function use_old_InterfaceDeclaration_ITelemetryPerformanceEvent(
    use: TypeOnly<old.ITelemetryPerformanceEvent>): void;
use_old_InterfaceDeclaration_ITelemetryPerformanceEvent(
    get_current_InterfaceDeclaration_ITelemetryPerformanceEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryProperties": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryProperties():
    TypeOnly<old.ITelemetryProperties>;
declare function use_current_InterfaceDeclaration_ITelemetryProperties(
    use: TypeOnly<current.ITelemetryProperties>): void;
use_current_InterfaceDeclaration_ITelemetryProperties(
    get_old_InterfaceDeclaration_ITelemetryProperties());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryProperties": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryProperties():
    TypeOnly<current.ITelemetryProperties>;
declare function use_old_InterfaceDeclaration_ITelemetryProperties(
    use: TypeOnly<old.ITelemetryProperties>): void;
use_old_InterfaceDeclaration_ITelemetryProperties(
    get_current_InterfaceDeclaration_ITelemetryProperties());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottlingWarning": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IThrottlingWarning():
    TypeOnly<old.IThrottlingWarning>;
declare function use_current_InterfaceDeclaration_IThrottlingWarning(
    use: TypeOnly<current.IThrottlingWarning>): void;
use_current_InterfaceDeclaration_IThrottlingWarning(
    get_old_InterfaceDeclaration_IThrottlingWarning());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottlingWarning": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IThrottlingWarning():
    TypeOnly<current.IThrottlingWarning>;
declare function use_old_InterfaceDeclaration_IThrottlingWarning(
    use: TypeOnly<old.IThrottlingWarning>): void;
use_old_InterfaceDeclaration_IThrottlingWarning(
    get_current_InterfaceDeclaration_IThrottlingWarning());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUsageError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IUsageError():
    TypeOnly<old.IUsageError>;
declare function use_current_InterfaceDeclaration_IUsageError(
    use: TypeOnly<current.IUsageError>): void;
use_current_InterfaceDeclaration_IUsageError(
    get_old_InterfaceDeclaration_IUsageError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUsageError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IUsageError():
    TypeOnly<current.IUsageError>;
declare function use_old_InterfaceDeclaration_IUsageError(
    use: TypeOnly<old.IUsageError>): void;
use_old_InterfaceDeclaration_IUsageError(
    get_current_InterfaceDeclaration_IUsageError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_LogLevel": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_LogLevel():
    TypeOnly<typeof old.LogLevel>;
declare function use_current_VariableDeclaration_LogLevel(
    use: TypeOnly<typeof current.LogLevel>): void;
use_current_VariableDeclaration_LogLevel(
    get_old_VariableDeclaration_LogLevel());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_LogLevel": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_LogLevel():
    TypeOnly<typeof current.LogLevel>;
declare function use_old_VariableDeclaration_LogLevel(
    use: TypeOnly<typeof old.LogLevel>): void;
use_old_VariableDeclaration_LogLevel(
    get_current_VariableDeclaration_LogLevel());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_LogLevel": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_LogLevel():
    TypeOnly<old.LogLevel>;
declare function use_current_TypeAliasDeclaration_LogLevel(
    use: TypeOnly<current.LogLevel>): void;
use_current_TypeAliasDeclaration_LogLevel(
    get_old_TypeAliasDeclaration_LogLevel());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_LogLevel": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_LogLevel():
    TypeOnly<current.LogLevel>;
declare function use_old_TypeAliasDeclaration_LogLevel(
    use: TypeOnly<old.LogLevel>): void;
use_old_TypeAliasDeclaration_LogLevel(
    get_current_TypeAliasDeclaration_LogLevel());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ReplaceIEventThisPlaceHolder": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder():
    TypeOnly<old.ReplaceIEventThisPlaceHolder<any,any>>;
declare function use_current_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder(
    use: TypeOnly<current.ReplaceIEventThisPlaceHolder<any,any>>): void;
use_current_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder(
    get_old_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ReplaceIEventThisPlaceHolder": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder():
    TypeOnly<current.ReplaceIEventThisPlaceHolder<any,any>>;
declare function use_old_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder(
    use: TypeOnly<old.ReplaceIEventThisPlaceHolder<any,any>>): void;
use_old_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder(
    get_current_TypeAliasDeclaration_ReplaceIEventThisPlaceHolder());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_Tagged": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_Tagged():
    TypeOnly<old.Tagged<any>>;
declare function use_current_InterfaceDeclaration_Tagged(
    use: TypeOnly<current.Tagged<any>>): void;
use_current_InterfaceDeclaration_Tagged(
    get_old_InterfaceDeclaration_Tagged());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_Tagged": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_Tagged():
    TypeOnly<current.Tagged<any>>;
declare function use_old_InterfaceDeclaration_Tagged(
    use: TypeOnly<old.Tagged<any>>): void;
use_old_InterfaceDeclaration_Tagged(
    get_current_InterfaceDeclaration_Tagged());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryBaseEventPropertyType": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TelemetryBaseEventPropertyType():
    TypeOnly<old.TelemetryBaseEventPropertyType>;
declare function use_current_TypeAliasDeclaration_TelemetryBaseEventPropertyType(
    use: TypeOnly<current.TelemetryBaseEventPropertyType>): void;
use_current_TypeAliasDeclaration_TelemetryBaseEventPropertyType(
    get_old_TypeAliasDeclaration_TelemetryBaseEventPropertyType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryBaseEventPropertyType": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TelemetryBaseEventPropertyType():
    TypeOnly<current.TelemetryBaseEventPropertyType>;
declare function use_old_TypeAliasDeclaration_TelemetryBaseEventPropertyType(
    use: TypeOnly<old.TelemetryBaseEventPropertyType>): void;
use_old_TypeAliasDeclaration_TelemetryBaseEventPropertyType(
    get_current_TypeAliasDeclaration_TelemetryBaseEventPropertyType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventCategory": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TelemetryEventCategory():
    TypeOnly<old.TelemetryEventCategory>;
declare function use_current_TypeAliasDeclaration_TelemetryEventCategory(
    use: TypeOnly<current.TelemetryEventCategory>): void;
use_current_TypeAliasDeclaration_TelemetryEventCategory(
    get_old_TypeAliasDeclaration_TelemetryEventCategory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventCategory": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TelemetryEventCategory():
    TypeOnly<current.TelemetryEventCategory>;
declare function use_old_TypeAliasDeclaration_TelemetryEventCategory(
    use: TypeOnly<old.TelemetryEventCategory>): void;
use_old_TypeAliasDeclaration_TelemetryEventCategory(
    get_current_TypeAliasDeclaration_TelemetryEventCategory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventPropertyType": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TelemetryEventPropertyType():
    TypeOnly<old.TelemetryEventPropertyType>;
declare function use_current_TypeAliasDeclaration_TelemetryEventPropertyType(
    use: TypeOnly<current.TelemetryEventPropertyType>): void;
use_current_TypeAliasDeclaration_TelemetryEventPropertyType(
    get_old_TypeAliasDeclaration_TelemetryEventPropertyType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventPropertyType": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TelemetryEventPropertyType():
    TypeOnly<current.TelemetryEventPropertyType>;
declare function use_old_TypeAliasDeclaration_TelemetryEventPropertyType(
    use: TypeOnly<old.TelemetryEventPropertyType>): void;
use_old_TypeAliasDeclaration_TelemetryEventPropertyType(
    get_current_TypeAliasDeclaration_TelemetryEventPropertyType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TransformedEvent": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TransformedEvent():
    TypeOnly<old.TransformedEvent<any,any,any>>;
declare function use_current_TypeAliasDeclaration_TransformedEvent(
    use: TypeOnly<current.TransformedEvent<any,any,any>>): void;
use_current_TypeAliasDeclaration_TransformedEvent(
    get_old_TypeAliasDeclaration_TransformedEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TransformedEvent": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TransformedEvent():
    TypeOnly<current.TransformedEvent<any,any,any>>;
declare function use_old_TypeAliasDeclaration_TransformedEvent(
    use: TypeOnly<old.TransformedEvent<any,any,any>>): void;
use_old_TypeAliasDeclaration_TransformedEvent(
    get_current_TypeAliasDeclaration_TransformedEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidCodeDetails": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isFluidCodeDetails():
    TypeOnly<typeof old.isFluidCodeDetails>;
declare function use_current_VariableDeclaration_isFluidCodeDetails(
    use: TypeOnly<typeof current.isFluidCodeDetails>): void;
use_current_VariableDeclaration_isFluidCodeDetails(
    get_old_VariableDeclaration_isFluidCodeDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidCodeDetails": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isFluidCodeDetails():
    TypeOnly<typeof current.isFluidCodeDetails>;
declare function use_old_VariableDeclaration_isFluidCodeDetails(
    use: TypeOnly<typeof old.isFluidCodeDetails>): void;
use_old_VariableDeclaration_isFluidCodeDetails(
    get_current_VariableDeclaration_isFluidCodeDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidPackage": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isFluidPackage():
    TypeOnly<typeof old.isFluidPackage>;
declare function use_current_VariableDeclaration_isFluidPackage(
    use: TypeOnly<typeof current.isFluidPackage>): void;
use_current_VariableDeclaration_isFluidPackage(
    get_old_VariableDeclaration_isFluidPackage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidPackage": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isFluidPackage():
    TypeOnly<typeof current.isFluidPackage>;
declare function use_old_VariableDeclaration_isFluidPackage(
    use: TypeOnly<typeof old.isFluidPackage>): void;
use_old_VariableDeclaration_isFluidPackage(
    get_current_VariableDeclaration_isFluidPackage());
