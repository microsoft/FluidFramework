/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/core-utils-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Deferred": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_Deferred():
    TypeOnly<old.Deferred<any>>;
declare function use_current_ClassDeclaration_Deferred(
    use: TypeOnly<current.Deferred<any>>): void;
use_current_ClassDeclaration_Deferred(
    get_old_ClassDeclaration_Deferred());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Deferred": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_Deferred():
    TypeOnly<current.Deferred<any>>;
declare function use_old_ClassDeclaration_Deferred(
    use: TypeOnly<old.Deferred<any>>): void;
use_old_ClassDeclaration_Deferred(
    get_current_ClassDeclaration_Deferred());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Heap": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_Heap():
    TypeOnly<old.Heap<any>>;
declare function use_current_ClassDeclaration_Heap(
    use: TypeOnly<current.Heap<any>>): void;
use_current_ClassDeclaration_Heap(
    get_old_ClassDeclaration_Heap());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Heap": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_Heap():
    TypeOnly<current.Heap<any>>;
declare function use_old_ClassDeclaration_Heap(
    use: TypeOnly<old.Heap<any>>): void;
use_old_ClassDeclaration_Heap(
    get_current_ClassDeclaration_Heap());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IComparer": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IComparer():
    TypeOnly<old.IComparer<any>>;
declare function use_current_InterfaceDeclaration_IComparer(
    use: TypeOnly<current.IComparer<any>>): void;
use_current_InterfaceDeclaration_IComparer(
    get_old_InterfaceDeclaration_IComparer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IComparer": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IComparer():
    TypeOnly<current.IComparer<any>>;
declare function use_old_InterfaceDeclaration_IComparer(
    use: TypeOnly<old.IComparer<any>>): void;
use_old_InterfaceDeclaration_IComparer(
    get_current_InterfaceDeclaration_IComparer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IHeapNode": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IHeapNode():
    TypeOnly<old.IHeapNode<any>>;
declare function use_current_InterfaceDeclaration_IHeapNode(
    use: TypeOnly<current.IHeapNode<any>>): void;
use_current_InterfaceDeclaration_IHeapNode(
    get_old_InterfaceDeclaration_IHeapNode());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IHeapNode": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IHeapNode():
    TypeOnly<current.IHeapNode<any>>;
declare function use_old_InterfaceDeclaration_IHeapNode(
    use: TypeOnly<old.IHeapNode<any>>): void;
use_old_InterfaceDeclaration_IHeapNode(
    get_current_InterfaceDeclaration_IHeapNode());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IPromiseTimer": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IPromiseTimer():
    TypeOnly<old.IPromiseTimer>;
declare function use_current_InterfaceDeclaration_IPromiseTimer(
    use: TypeOnly<current.IPromiseTimer>): void;
use_current_InterfaceDeclaration_IPromiseTimer(
    get_old_InterfaceDeclaration_IPromiseTimer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IPromiseTimer": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IPromiseTimer():
    TypeOnly<current.IPromiseTimer>;
declare function use_old_InterfaceDeclaration_IPromiseTimer(
    use: TypeOnly<old.IPromiseTimer>): void;
use_old_InterfaceDeclaration_IPromiseTimer(
    get_current_InterfaceDeclaration_IPromiseTimer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IPromiseTimerResult": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IPromiseTimerResult():
    TypeOnly<old.IPromiseTimerResult>;
declare function use_current_InterfaceDeclaration_IPromiseTimerResult(
    use: TypeOnly<current.IPromiseTimerResult>): void;
use_current_InterfaceDeclaration_IPromiseTimerResult(
    get_old_InterfaceDeclaration_IPromiseTimerResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IPromiseTimerResult": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IPromiseTimerResult():
    TypeOnly<current.IPromiseTimerResult>;
declare function use_old_InterfaceDeclaration_IPromiseTimerResult(
    use: TypeOnly<old.IPromiseTimerResult>): void;
use_old_InterfaceDeclaration_IPromiseTimerResult(
    get_current_InterfaceDeclaration_IPromiseTimerResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITimer": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITimer():
    TypeOnly<old.ITimer>;
declare function use_current_InterfaceDeclaration_ITimer(
    use: TypeOnly<current.ITimer>): void;
use_current_InterfaceDeclaration_ITimer(
    get_old_InterfaceDeclaration_ITimer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITimer": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITimer():
    TypeOnly<current.ITimer>;
declare function use_old_InterfaceDeclaration_ITimer(
    use: TypeOnly<old.ITimer>): void;
use_old_InterfaceDeclaration_ITimer(
    get_current_InterfaceDeclaration_ITimer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Lazy": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_Lazy():
    TypeOnly<old.Lazy<any>>;
declare function use_current_ClassDeclaration_Lazy(
    use: TypeOnly<current.Lazy<any>>): void;
use_current_ClassDeclaration_Lazy(
    get_old_ClassDeclaration_Lazy());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Lazy": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_Lazy():
    TypeOnly<current.Lazy<any>>;
declare function use_old_ClassDeclaration_Lazy(
    use: TypeOnly<old.Lazy<any>>): void;
use_old_ClassDeclaration_Lazy(
    get_current_ClassDeclaration_Lazy());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LazyPromise": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_LazyPromise():
    TypeOnly<old.LazyPromise<any>>;
declare function use_current_ClassDeclaration_LazyPromise(
    use: TypeOnly<current.LazyPromise<any>>): void;
use_current_ClassDeclaration_LazyPromise(
    get_old_ClassDeclaration_LazyPromise());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LazyPromise": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_LazyPromise():
    TypeOnly<current.LazyPromise<any>>;
declare function use_old_ClassDeclaration_LazyPromise(
    use: TypeOnly<old.LazyPromise<any>>): void;
use_old_ClassDeclaration_LazyPromise(
    get_current_ClassDeclaration_LazyPromise());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_NumberComparer": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_NumberComparer():
    TypeOnly<typeof old.NumberComparer>;
declare function use_current_VariableDeclaration_NumberComparer(
    use: TypeOnly<typeof current.NumberComparer>): void;
use_current_VariableDeclaration_NumberComparer(
    get_old_VariableDeclaration_NumberComparer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_NumberComparer": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_NumberComparer():
    TypeOnly<typeof current.NumberComparer>;
declare function use_old_VariableDeclaration_NumberComparer(
    use: TypeOnly<typeof old.NumberComparer>): void;
use_old_VariableDeclaration_NumberComparer(
    get_current_VariableDeclaration_NumberComparer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_PromiseCache": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_PromiseCache():
    TypeOnly<old.PromiseCache<any,any>>;
declare function use_current_ClassDeclaration_PromiseCache(
    use: TypeOnly<current.PromiseCache<any,any>>): void;
use_current_ClassDeclaration_PromiseCache(
    get_old_ClassDeclaration_PromiseCache());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_PromiseCache": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_PromiseCache():
    TypeOnly<current.PromiseCache<any,any>>;
declare function use_old_ClassDeclaration_PromiseCache(
    use: TypeOnly<old.PromiseCache<any,any>>): void;
use_old_ClassDeclaration_PromiseCache(
    get_current_ClassDeclaration_PromiseCache());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_PromiseCacheExpiry": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_PromiseCacheExpiry():
    TypeOnly<old.PromiseCacheExpiry>;
declare function use_current_TypeAliasDeclaration_PromiseCacheExpiry(
    use: TypeOnly<current.PromiseCacheExpiry>): void;
use_current_TypeAliasDeclaration_PromiseCacheExpiry(
    get_old_TypeAliasDeclaration_PromiseCacheExpiry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_PromiseCacheExpiry": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_PromiseCacheExpiry():
    TypeOnly<current.PromiseCacheExpiry>;
declare function use_old_TypeAliasDeclaration_PromiseCacheExpiry(
    use: TypeOnly<old.PromiseCacheExpiry>): void;
use_old_TypeAliasDeclaration_PromiseCacheExpiry(
    get_current_TypeAliasDeclaration_PromiseCacheExpiry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_PromiseCacheOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_PromiseCacheOptions():
    TypeOnly<old.PromiseCacheOptions>;
declare function use_current_InterfaceDeclaration_PromiseCacheOptions(
    use: TypeOnly<current.PromiseCacheOptions>): void;
use_current_InterfaceDeclaration_PromiseCacheOptions(
    get_old_InterfaceDeclaration_PromiseCacheOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_PromiseCacheOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_PromiseCacheOptions():
    TypeOnly<current.PromiseCacheOptions>;
declare function use_old_InterfaceDeclaration_PromiseCacheOptions(
    use: TypeOnly<old.PromiseCacheOptions>): void;
use_old_InterfaceDeclaration_PromiseCacheOptions(
    get_current_InterfaceDeclaration_PromiseCacheOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_PromiseTimer": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_PromiseTimer():
    TypeOnly<old.PromiseTimer>;
declare function use_current_ClassDeclaration_PromiseTimer(
    use: TypeOnly<current.PromiseTimer>): void;
use_current_ClassDeclaration_PromiseTimer(
    get_old_ClassDeclaration_PromiseTimer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_PromiseTimer": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_PromiseTimer():
    TypeOnly<current.PromiseTimer>;
declare function use_old_ClassDeclaration_PromiseTimer(
    use: TypeOnly<old.PromiseTimer>): void;
use_old_ClassDeclaration_PromiseTimer(
    get_current_ClassDeclaration_PromiseTimer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Timer": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_Timer():
    TypeOnly<old.Timer>;
declare function use_current_ClassDeclaration_Timer(
    use: TypeOnly<current.Timer>): void;
use_current_ClassDeclaration_Timer(
    get_old_ClassDeclaration_Timer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Timer": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_Timer():
    TypeOnly<current.Timer>;
declare function use_old_ClassDeclaration_Timer(
    use: TypeOnly<old.Timer>): void;
use_old_ClassDeclaration_Timer(
    get_current_ClassDeclaration_Timer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_assert": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_assert():
    TypeOnly<typeof old.assert>;
declare function use_current_FunctionDeclaration_assert(
    use: TypeOnly<typeof current.assert>): void;
use_current_FunctionDeclaration_assert(
    get_old_FunctionDeclaration_assert());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_assert": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_assert():
    TypeOnly<typeof current.assert>;
declare function use_old_FunctionDeclaration_assert(
    use: TypeOnly<typeof old.assert>): void;
use_old_FunctionDeclaration_assert(
    get_current_FunctionDeclaration_assert());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_compareArrays": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_compareArrays():
    TypeOnly<typeof old.compareArrays>;
declare function use_current_VariableDeclaration_compareArrays(
    use: TypeOnly<typeof current.compareArrays>): void;
use_current_VariableDeclaration_compareArrays(
    get_old_VariableDeclaration_compareArrays());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_compareArrays": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_compareArrays():
    TypeOnly<typeof current.compareArrays>;
declare function use_old_VariableDeclaration_compareArrays(
    use: TypeOnly<typeof old.compareArrays>): void;
use_old_VariableDeclaration_compareArrays(
    get_current_VariableDeclaration_compareArrays());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_delay": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_delay():
    TypeOnly<typeof old.delay>;
declare function use_current_VariableDeclaration_delay(
    use: TypeOnly<typeof current.delay>): void;
use_current_VariableDeclaration_delay(
    get_old_VariableDeclaration_delay());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_delay": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_delay():
    TypeOnly<typeof current.delay>;
declare function use_old_VariableDeclaration_delay(
    use: TypeOnly<typeof old.delay>): void;
use_old_VariableDeclaration_delay(
    get_current_VariableDeclaration_delay());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isObject": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_isObject():
    TypeOnly<typeof old.isObject>;
declare function use_current_VariableDeclaration_isObject(
    use: TypeOnly<typeof current.isObject>): void;
use_current_VariableDeclaration_isObject(
    get_old_VariableDeclaration_isObject());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isObject": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_isObject():
    TypeOnly<typeof current.isObject>;
declare function use_old_VariableDeclaration_isObject(
    use: TypeOnly<typeof old.isObject>): void;
use_old_VariableDeclaration_isObject(
    get_current_VariableDeclaration_isObject());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isPromiseLike": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_isPromiseLike():
    TypeOnly<typeof old.isPromiseLike>;
declare function use_current_VariableDeclaration_isPromiseLike(
    use: TypeOnly<typeof current.isPromiseLike>): void;
use_current_VariableDeclaration_isPromiseLike(
    get_old_VariableDeclaration_isPromiseLike());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isPromiseLike": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_isPromiseLike():
    TypeOnly<typeof current.isPromiseLike>;
declare function use_old_VariableDeclaration_isPromiseLike(
    use: TypeOnly<typeof old.isPromiseLike>): void;
use_old_VariableDeclaration_isPromiseLike(
    get_current_VariableDeclaration_isPromiseLike());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_setLongTimeout": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_setLongTimeout():
    TypeOnly<typeof old.setLongTimeout>;
declare function use_current_FunctionDeclaration_setLongTimeout(
    use: TypeOnly<typeof current.setLongTimeout>): void;
use_current_FunctionDeclaration_setLongTimeout(
    get_old_FunctionDeclaration_setLongTimeout());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_setLongTimeout": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_setLongTimeout():
    TypeOnly<typeof current.setLongTimeout>;
declare function use_old_FunctionDeclaration_setLongTimeout(
    use: TypeOnly<typeof old.setLongTimeout>): void;
use_old_FunctionDeclaration_setLongTimeout(
    get_current_FunctionDeclaration_setLongTimeout());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_unreachableCase": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_unreachableCase():
    TypeOnly<typeof old.unreachableCase>;
declare function use_current_FunctionDeclaration_unreachableCase(
    use: TypeOnly<typeof current.unreachableCase>): void;
use_current_FunctionDeclaration_unreachableCase(
    get_old_FunctionDeclaration_unreachableCase());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_unreachableCase": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_unreachableCase():
    TypeOnly<typeof current.unreachableCase>;
declare function use_old_FunctionDeclaration_unreachableCase(
    use: TypeOnly<typeof old.unreachableCase>): void;
use_old_FunctionDeclaration_unreachableCase(
    get_current_FunctionDeclaration_unreachableCase());
