## Alpha API Report File for "@fluidframework/core-utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @alpha
export function assert(condition: boolean, message: string | number): asserts condition;

// @alpha
export const compareArrays: <T>(left: readonly T[], right: readonly T[], comparator?: (leftItem: T, rightItem: T, index: number) => boolean) => boolean;

// @alpha
export class Deferred<T> {
    constructor();
    get isCompleted(): boolean;
    get promise(): Promise<T>;
    reject(error: any): void;
    resolve(value: T | PromiseLike<T>): void;
}

// @public
export function getOrAddInMap<Key, Value>(map: MapGetSet<Key, Value>, key: Key, value: Value): Value;

// @public
export function getOrCreate<K, V>(map: MapGetSet<K, V>, key: K, defaultValue: (key: K) => V): V;

// @public
export type IsListener<TListener> = TListener extends (...args: any[]) => void ? true : false;

// @alpha
export class LazyPromise<T> implements Promise<T> {
    // (undocumented)
    get [Symbol.toStringTag](): string;
    constructor(execute: () => Promise<T>);
    // (undocumented)
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined): Promise<T | TResult>;
    // (undocumented)
    finally(onfinally?: (() => void) | null | undefined): Promise<T>;
    // (undocumented)
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2>;
}

// @public @sealed
export interface Listenable<TListeners extends object> {
    off<K extends keyof Listeners<TListeners>>(eventName: K, listener: TListeners[K]): void;
    on<K extends keyof Listeners<TListeners>>(eventName: K, listener: TListeners[K]): Off;
}

// @public
export type Listeners<T extends object> = {
    [P in (string | symbol) & keyof T as IsListener<T[P]> extends true ? P : never]: T[P];
};

// @public
export interface MapGetSet<K, V> {
    // (undocumented)
    get(key: K): V | undefined;
    // (undocumented)
    set(key: K, value: V): void;
}

// @public
export type NestedMap<Key1, Key2, Value> = Map<Key1, Map<Key2, Value>>;

// @public
export type Off = () => void;

// @alpha
export class PromiseCache<TKey, TResult> {
    constructor({ expiry, removeOnError, }?: PromiseCacheOptions);
    add(key: TKey, asyncFn: () => Promise<TResult>): boolean;
    addOrGet(key: TKey, asyncFn: () => Promise<TResult>): Promise<TResult>;
    addValue(key: TKey, value: TResult): boolean;
    addValueOrGet(key: TKey, value: TResult): Promise<TResult>;
    get(key: TKey): Promise<TResult> | undefined;
    has(key: TKey): boolean;
    remove(key: TKey): boolean;
}

// @alpha
export type PromiseCacheExpiry = {
    policy: "indefinite";
} | {
    policy: "absolute" | "sliding";
    durationMs: number;
};

// @alpha
export interface PromiseCacheOptions {
    expiry?: PromiseCacheExpiry;
    removeOnError?: (error: any) => boolean;
}

// @public
export function setInNestedMap<Key1, Key2, Value>(map: NestedMap<Key1, Key2, Value>, key1: Key1, key2: Key2, value: Value): void;

// @public
export type UnionToIntersection<T> = (T extends T ? (k: T) => unknown : never) extends (k: infer U) => unknown ? U : never;

// (No @packageDocumentation comment for this package)

```
