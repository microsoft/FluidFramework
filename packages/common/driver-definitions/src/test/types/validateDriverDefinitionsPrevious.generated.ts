/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type * as old from "@fluidframework/driver-definitions-previous/internal";

import type * as current from "../../index.js";

// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_DriverError": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_DriverError():
    TypeOnly<old.DriverError>;
declare function use_current_TypeAliasDeclaration_DriverError(
    use: TypeOnly<current.DriverError>): void;
use_current_TypeAliasDeclaration_DriverError(
    get_old_TypeAliasDeclaration_DriverError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_DriverError": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_DriverError():
    TypeOnly<current.DriverError>;
declare function use_old_TypeAliasDeclaration_DriverError(
    use: TypeOnly<old.DriverError>): void;
use_old_TypeAliasDeclaration_DriverError(
    get_current_TypeAliasDeclaration_DriverError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_DriverErrorTypes": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_DriverErrorTypes():
    TypeOnly<typeof old.DriverErrorTypes>;
declare function use_current_VariableDeclaration_DriverErrorTypes(
    use: TypeOnly<typeof current.DriverErrorTypes>): void;
use_current_VariableDeclaration_DriverErrorTypes(
    get_old_VariableDeclaration_DriverErrorTypes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_DriverErrorTypes": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_DriverErrorTypes():
    TypeOnly<typeof current.DriverErrorTypes>;
declare function use_old_VariableDeclaration_DriverErrorTypes(
    use: TypeOnly<typeof old.DriverErrorTypes>): void;
use_old_VariableDeclaration_DriverErrorTypes(
    get_current_VariableDeclaration_DriverErrorTypes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_DriverErrorTypes": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_DriverErrorTypes():
    TypeOnly<old.DriverErrorTypes>;
declare function use_current_TypeAliasDeclaration_DriverErrorTypes(
    use: TypeOnly<current.DriverErrorTypes>): void;
use_current_TypeAliasDeclaration_DriverErrorTypes(
    get_old_TypeAliasDeclaration_DriverErrorTypes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_DriverErrorTypes": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_DriverErrorTypes():
    TypeOnly<current.DriverErrorTypes>;
declare function use_old_TypeAliasDeclaration_DriverErrorTypes(
    use: TypeOnly<old.DriverErrorTypes>): void;
use_old_TypeAliasDeclaration_DriverErrorTypes(
    get_current_TypeAliasDeclaration_DriverErrorTypes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_DriverHeader": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_DriverHeader():
    TypeOnly<old.DriverHeader>;
declare function use_current_EnumDeclaration_DriverHeader(
    use: TypeOnly<current.DriverHeader>): void;
use_current_EnumDeclaration_DriverHeader(
    get_old_EnumDeclaration_DriverHeader());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_DriverHeader": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_DriverHeader():
    TypeOnly<current.DriverHeader>;
declare function use_old_EnumDeclaration_DriverHeader(
    use: TypeOnly<old.DriverHeader>): void;
use_old_EnumDeclaration_DriverHeader(
    get_current_EnumDeclaration_DriverHeader());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_DriverPreCheckInfo": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_DriverPreCheckInfo():
    TypeOnly<old.DriverPreCheckInfo>;
declare function use_current_InterfaceDeclaration_DriverPreCheckInfo(
    use: TypeOnly<current.DriverPreCheckInfo>): void;
use_current_InterfaceDeclaration_DriverPreCheckInfo(
    get_old_InterfaceDeclaration_DriverPreCheckInfo());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_DriverPreCheckInfo": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_DriverPreCheckInfo():
    TypeOnly<current.DriverPreCheckInfo>;
declare function use_old_InterfaceDeclaration_DriverPreCheckInfo(
    use: TypeOnly<old.DriverPreCheckInfo>): void;
use_old_InterfaceDeclaration_DriverPreCheckInfo(
    get_current_InterfaceDeclaration_DriverPreCheckInfo());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_FetchSource": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_FetchSource():
    TypeOnly<old.FetchSource>;
declare function use_current_EnumDeclaration_FetchSource(
    use: TypeOnly<current.FetchSource>): void;
use_current_EnumDeclaration_FetchSource(
    get_old_EnumDeclaration_FetchSource());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_FetchSource": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_FetchSource():
    TypeOnly<current.FetchSource>;
declare function use_old_EnumDeclaration_FetchSource(
    use: TypeOnly<old.FetchSource>): void;
use_old_EnumDeclaration_FetchSource(
    get_current_EnumDeclaration_FetchSource());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_FiveDaysMs": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_FiveDaysMs():
    TypeOnly<old.FiveDaysMs>;
declare function use_current_TypeAliasDeclaration_FiveDaysMs(
    use: TypeOnly<current.FiveDaysMs>): void;
use_current_TypeAliasDeclaration_FiveDaysMs(
    get_old_TypeAliasDeclaration_FiveDaysMs());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_FiveDaysMs": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_FiveDaysMs():
    TypeOnly<current.FiveDaysMs>;
declare function use_old_TypeAliasDeclaration_FiveDaysMs(
    use: TypeOnly<old.FiveDaysMs>): void;
use_old_TypeAliasDeclaration_FiveDaysMs(
    get_current_TypeAliasDeclaration_FiveDaysMs());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAnyDriverError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IAnyDriverError():
    TypeOnly<old.IAnyDriverError>;
declare function use_current_InterfaceDeclaration_IAnyDriverError(
    use: TypeOnly<current.IAnyDriverError>): void;
use_current_InterfaceDeclaration_IAnyDriverError(
    get_old_InterfaceDeclaration_IAnyDriverError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAnyDriverError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IAnyDriverError():
    TypeOnly<current.IAnyDriverError>;
declare function use_old_InterfaceDeclaration_IAnyDriverError(
    use: TypeOnly<old.IAnyDriverError>): void;
use_old_InterfaceDeclaration_IAnyDriverError(
    get_current_InterfaceDeclaration_IAnyDriverError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAuthorizationError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IAuthorizationError():
    TypeOnly<old.IAuthorizationError>;
declare function use_current_InterfaceDeclaration_IAuthorizationError(
    use: TypeOnly<current.IAuthorizationError>): void;
use_current_InterfaceDeclaration_IAuthorizationError(
    get_old_InterfaceDeclaration_IAuthorizationError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAuthorizationError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IAuthorizationError():
    TypeOnly<current.IAuthorizationError>;
declare function use_old_InterfaceDeclaration_IAuthorizationError(
    use: TypeOnly<old.IAuthorizationError>): void;
use_old_InterfaceDeclaration_IAuthorizationError(
    get_current_InterfaceDeclaration_IAuthorizationError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerPackageInfo": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IContainerPackageInfo():
    TypeOnly<old.IContainerPackageInfo>;
declare function use_current_InterfaceDeclaration_IContainerPackageInfo(
    use: TypeOnly<current.IContainerPackageInfo>): void;
use_current_InterfaceDeclaration_IContainerPackageInfo(
    get_old_InterfaceDeclaration_IContainerPackageInfo());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerPackageInfo": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IContainerPackageInfo():
    TypeOnly<current.IContainerPackageInfo>;
declare function use_old_InterfaceDeclaration_IContainerPackageInfo(
    use: TypeOnly<old.IContainerPackageInfo>): void;
use_old_InterfaceDeclaration_IContainerPackageInfo(
    get_current_InterfaceDeclaration_IContainerPackageInfo());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDeltaStorageService": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDeltaStorageService():
    TypeOnly<old.IDeltaStorageService>;
declare function use_current_InterfaceDeclaration_IDeltaStorageService(
    use: TypeOnly<current.IDeltaStorageService>): void;
use_current_InterfaceDeclaration_IDeltaStorageService(
    get_old_InterfaceDeclaration_IDeltaStorageService());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDeltaStorageService": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDeltaStorageService():
    TypeOnly<current.IDeltaStorageService>;
declare function use_old_InterfaceDeclaration_IDeltaStorageService(
    use: TypeOnly<old.IDeltaStorageService>): void;
use_old_InterfaceDeclaration_IDeltaStorageService(
    get_current_InterfaceDeclaration_IDeltaStorageService());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDeltasFetchResult": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDeltasFetchResult():
    TypeOnly<old.IDeltasFetchResult>;
declare function use_current_InterfaceDeclaration_IDeltasFetchResult(
    use: TypeOnly<current.IDeltasFetchResult>): void;
use_current_InterfaceDeclaration_IDeltasFetchResult(
    get_old_InterfaceDeclaration_IDeltasFetchResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDeltasFetchResult": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDeltasFetchResult():
    TypeOnly<current.IDeltasFetchResult>;
declare function use_old_InterfaceDeclaration_IDeltasFetchResult(
    use: TypeOnly<old.IDeltasFetchResult>): void;
use_old_InterfaceDeclaration_IDeltasFetchResult(
    get_current_InterfaceDeclaration_IDeltasFetchResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentDeltaConnection": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentDeltaConnection():
    TypeOnly<old.IDocumentDeltaConnection>;
declare function use_current_InterfaceDeclaration_IDocumentDeltaConnection(
    use: TypeOnly<current.IDocumentDeltaConnection>): void;
use_current_InterfaceDeclaration_IDocumentDeltaConnection(
    get_old_InterfaceDeclaration_IDocumentDeltaConnection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentDeltaConnection": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentDeltaConnection():
    TypeOnly<current.IDocumentDeltaConnection>;
declare function use_old_InterfaceDeclaration_IDocumentDeltaConnection(
    use: TypeOnly<old.IDocumentDeltaConnection>): void;
use_old_InterfaceDeclaration_IDocumentDeltaConnection(
    get_current_InterfaceDeclaration_IDocumentDeltaConnection());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentDeltaConnectionEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentDeltaConnectionEvents():
    TypeOnly<old.IDocumentDeltaConnectionEvents>;
declare function use_current_InterfaceDeclaration_IDocumentDeltaConnectionEvents(
    use: TypeOnly<current.IDocumentDeltaConnectionEvents>): void;
use_current_InterfaceDeclaration_IDocumentDeltaConnectionEvents(
    get_old_InterfaceDeclaration_IDocumentDeltaConnectionEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentDeltaConnectionEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentDeltaConnectionEvents():
    TypeOnly<current.IDocumentDeltaConnectionEvents>;
declare function use_old_InterfaceDeclaration_IDocumentDeltaConnectionEvents(
    use: TypeOnly<old.IDocumentDeltaConnectionEvents>): void;
use_old_InterfaceDeclaration_IDocumentDeltaConnectionEvents(
    get_current_InterfaceDeclaration_IDocumentDeltaConnectionEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentDeltaStorageService": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentDeltaStorageService():
    TypeOnly<old.IDocumentDeltaStorageService>;
declare function use_current_InterfaceDeclaration_IDocumentDeltaStorageService(
    use: TypeOnly<current.IDocumentDeltaStorageService>): void;
use_current_InterfaceDeclaration_IDocumentDeltaStorageService(
    get_old_InterfaceDeclaration_IDocumentDeltaStorageService());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentDeltaStorageService": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentDeltaStorageService():
    TypeOnly<current.IDocumentDeltaStorageService>;
declare function use_old_InterfaceDeclaration_IDocumentDeltaStorageService(
    use: TypeOnly<old.IDocumentDeltaStorageService>): void;
use_old_InterfaceDeclaration_IDocumentDeltaStorageService(
    get_current_InterfaceDeclaration_IDocumentDeltaStorageService());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentService": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentService():
    TypeOnly<old.IDocumentService>;
declare function use_current_InterfaceDeclaration_IDocumentService(
    use: TypeOnly<current.IDocumentService>): void;
use_current_InterfaceDeclaration_IDocumentService(
    get_old_InterfaceDeclaration_IDocumentService());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentService": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentService():
    TypeOnly<current.IDocumentService>;
declare function use_old_InterfaceDeclaration_IDocumentService(
    use: TypeOnly<old.IDocumentService>): void;
use_old_InterfaceDeclaration_IDocumentService(
    get_current_InterfaceDeclaration_IDocumentService());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentServiceEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentServiceEvents():
    TypeOnly<old.IDocumentServiceEvents>;
declare function use_current_InterfaceDeclaration_IDocumentServiceEvents(
    use: TypeOnly<current.IDocumentServiceEvents>): void;
use_current_InterfaceDeclaration_IDocumentServiceEvents(
    get_old_InterfaceDeclaration_IDocumentServiceEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentServiceEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentServiceEvents():
    TypeOnly<current.IDocumentServiceEvents>;
declare function use_old_InterfaceDeclaration_IDocumentServiceEvents(
    use: TypeOnly<old.IDocumentServiceEvents>): void;
use_old_InterfaceDeclaration_IDocumentServiceEvents(
    get_current_InterfaceDeclaration_IDocumentServiceEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentServiceFactory": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentServiceFactory():
    TypeOnly<old.IDocumentServiceFactory>;
declare function use_current_InterfaceDeclaration_IDocumentServiceFactory(
    use: TypeOnly<current.IDocumentServiceFactory>): void;
use_current_InterfaceDeclaration_IDocumentServiceFactory(
    get_old_InterfaceDeclaration_IDocumentServiceFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentServiceFactory": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentServiceFactory():
    TypeOnly<current.IDocumentServiceFactory>;
declare function use_old_InterfaceDeclaration_IDocumentServiceFactory(
    use: TypeOnly<old.IDocumentServiceFactory>): void;
use_old_InterfaceDeclaration_IDocumentServiceFactory(
    get_current_InterfaceDeclaration_IDocumentServiceFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentServicePolicies": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentServicePolicies():
    TypeOnly<old.IDocumentServicePolicies>;
declare function use_current_InterfaceDeclaration_IDocumentServicePolicies(
    use: TypeOnly<current.IDocumentServicePolicies>): void;
use_current_InterfaceDeclaration_IDocumentServicePolicies(
    get_old_InterfaceDeclaration_IDocumentServicePolicies());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentServicePolicies": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentServicePolicies():
    TypeOnly<current.IDocumentServicePolicies>;
declare function use_old_InterfaceDeclaration_IDocumentServicePolicies(
    use: TypeOnly<old.IDocumentServicePolicies>): void;
use_old_InterfaceDeclaration_IDocumentServicePolicies(
    get_current_InterfaceDeclaration_IDocumentServicePolicies());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentStorageService": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentStorageService():
    TypeOnly<old.IDocumentStorageService>;
declare function use_current_InterfaceDeclaration_IDocumentStorageService(
    use: TypeOnly<current.IDocumentStorageService>): void;
use_current_InterfaceDeclaration_IDocumentStorageService(
    get_old_InterfaceDeclaration_IDocumentStorageService());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentStorageService": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentStorageService():
    TypeOnly<current.IDocumentStorageService>;
declare function use_old_InterfaceDeclaration_IDocumentStorageService(
    use: TypeOnly<old.IDocumentStorageService>): void;
use_old_InterfaceDeclaration_IDocumentStorageService(
    get_current_InterfaceDeclaration_IDocumentStorageService());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentStorageServicePolicies": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentStorageServicePolicies():
    TypeOnly<old.IDocumentStorageServicePolicies>;
declare function use_current_InterfaceDeclaration_IDocumentStorageServicePolicies(
    use: TypeOnly<current.IDocumentStorageServicePolicies>): void;
use_current_InterfaceDeclaration_IDocumentStorageServicePolicies(
    get_old_InterfaceDeclaration_IDocumentStorageServicePolicies());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentStorageServicePolicies": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentStorageServicePolicies():
    TypeOnly<current.IDocumentStorageServicePolicies>;
declare function use_old_InterfaceDeclaration_IDocumentStorageServicePolicies(
    use: TypeOnly<old.IDocumentStorageServicePolicies>): void;
use_old_InterfaceDeclaration_IDocumentStorageServicePolicies(
    get_current_InterfaceDeclaration_IDocumentStorageServicePolicies());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDriverBasicError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDriverBasicError():
    TypeOnly<old.IDriverBasicError>;
declare function use_current_InterfaceDeclaration_IDriverBasicError(
    use: TypeOnly<current.IDriverBasicError>): void;
use_current_InterfaceDeclaration_IDriverBasicError(
    get_old_InterfaceDeclaration_IDriverBasicError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDriverBasicError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDriverBasicError():
    TypeOnly<current.IDriverBasicError>;
declare function use_old_InterfaceDeclaration_IDriverBasicError(
    use: TypeOnly<old.IDriverBasicError>): void;
use_old_InterfaceDeclaration_IDriverBasicError(
    get_current_InterfaceDeclaration_IDriverBasicError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDriverErrorBase": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDriverErrorBase():
    TypeOnly<old.IDriverErrorBase>;
declare function use_current_InterfaceDeclaration_IDriverErrorBase(
    use: TypeOnly<current.IDriverErrorBase>): void;
use_current_InterfaceDeclaration_IDriverErrorBase(
    get_old_InterfaceDeclaration_IDriverErrorBase());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDriverErrorBase": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDriverErrorBase():
    TypeOnly<current.IDriverErrorBase>;
declare function use_old_InterfaceDeclaration_IDriverErrorBase(
    use: TypeOnly<old.IDriverErrorBase>): void;
use_old_InterfaceDeclaration_IDriverErrorBase(
    get_current_InterfaceDeclaration_IDriverErrorBase());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDriverHeader": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDriverHeader():
    TypeOnly<old.IDriverHeader>;
declare function use_current_InterfaceDeclaration_IDriverHeader(
    use: TypeOnly<current.IDriverHeader>): void;
use_current_InterfaceDeclaration_IDriverHeader(
    get_old_InterfaceDeclaration_IDriverHeader());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDriverHeader": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDriverHeader():
    TypeOnly<current.IDriverHeader>;
declare function use_old_InterfaceDeclaration_IDriverHeader(
    use: TypeOnly<old.IDriverHeader>): void;
use_old_InterfaceDeclaration_IDriverHeader(
    get_current_InterfaceDeclaration_IDriverHeader());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGenericNetworkError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IGenericNetworkError():
    TypeOnly<old.IGenericNetworkError>;
declare function use_current_InterfaceDeclaration_IGenericNetworkError(
    use: TypeOnly<current.IGenericNetworkError>): void;
use_current_InterfaceDeclaration_IGenericNetworkError(
    get_old_InterfaceDeclaration_IGenericNetworkError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGenericNetworkError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IGenericNetworkError():
    TypeOnly<current.IGenericNetworkError>;
declare function use_old_InterfaceDeclaration_IGenericNetworkError(
    use: TypeOnly<old.IGenericNetworkError>): void;
use_old_InterfaceDeclaration_IGenericNetworkError(
    get_current_InterfaceDeclaration_IGenericNetworkError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ILocationRedirectionError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ILocationRedirectionError():
    TypeOnly<old.ILocationRedirectionError>;
declare function use_current_InterfaceDeclaration_ILocationRedirectionError(
    use: TypeOnly<current.ILocationRedirectionError>): void;
use_current_InterfaceDeclaration_ILocationRedirectionError(
    get_old_InterfaceDeclaration_ILocationRedirectionError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ILocationRedirectionError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ILocationRedirectionError():
    TypeOnly<current.ILocationRedirectionError>;
declare function use_old_InterfaceDeclaration_ILocationRedirectionError(
    use: TypeOnly<old.ILocationRedirectionError>): void;
use_old_InterfaceDeclaration_ILocationRedirectionError(
    get_current_InterfaceDeclaration_ILocationRedirectionError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IResolvedUrl": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IResolvedUrl():
    TypeOnly<old.IResolvedUrl>;
declare function use_current_InterfaceDeclaration_IResolvedUrl(
    use: TypeOnly<current.IResolvedUrl>): void;
use_current_InterfaceDeclaration_IResolvedUrl(
    get_old_InterfaceDeclaration_IResolvedUrl());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IResolvedUrl": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IResolvedUrl():
    TypeOnly<current.IResolvedUrl>;
declare function use_old_InterfaceDeclaration_IResolvedUrl(
    use: TypeOnly<old.IResolvedUrl>): void;
use_old_InterfaceDeclaration_IResolvedUrl(
    get_current_InterfaceDeclaration_IResolvedUrl());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISnapshot": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISnapshot():
    TypeOnly<old.ISnapshot>;
declare function use_current_InterfaceDeclaration_ISnapshot(
    use: TypeOnly<current.ISnapshot>): void;
use_current_InterfaceDeclaration_ISnapshot(
    get_old_InterfaceDeclaration_ISnapshot());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISnapshot": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISnapshot():
    TypeOnly<current.ISnapshot>;
declare function use_old_InterfaceDeclaration_ISnapshot(
    use: TypeOnly<old.ISnapshot>): void;
use_old_InterfaceDeclaration_ISnapshot(
    get_current_InterfaceDeclaration_ISnapshot());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISnapshotFetchOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISnapshotFetchOptions():
    TypeOnly<old.ISnapshotFetchOptions>;
declare function use_current_InterfaceDeclaration_ISnapshotFetchOptions(
    use: TypeOnly<current.ISnapshotFetchOptions>): void;
use_current_InterfaceDeclaration_ISnapshotFetchOptions(
    get_old_InterfaceDeclaration_ISnapshotFetchOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISnapshotFetchOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISnapshotFetchOptions():
    TypeOnly<current.ISnapshotFetchOptions>;
declare function use_old_InterfaceDeclaration_ISnapshotFetchOptions(
    use: TypeOnly<old.ISnapshotFetchOptions>): void;
use_old_InterfaceDeclaration_ISnapshotFetchOptions(
    get_current_InterfaceDeclaration_ISnapshotFetchOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IStream": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IStream():
    TypeOnly<old.IStream<any>>;
declare function use_current_InterfaceDeclaration_IStream(
    use: TypeOnly<current.IStream<any>>): void;
use_current_InterfaceDeclaration_IStream(
    get_old_InterfaceDeclaration_IStream());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IStream": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IStream():
    TypeOnly<current.IStream<any>>;
declare function use_old_InterfaceDeclaration_IStream(
    use: TypeOnly<old.IStream<any>>): void;
use_old_InterfaceDeclaration_IStream(
    get_current_InterfaceDeclaration_IStream());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IStreamResult": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IStreamResult():
    TypeOnly<old.IStreamResult<any>>;
declare function use_current_TypeAliasDeclaration_IStreamResult(
    use: TypeOnly<current.IStreamResult<any>>): void;
use_current_TypeAliasDeclaration_IStreamResult(
    get_old_TypeAliasDeclaration_IStreamResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IStreamResult": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IStreamResult():
    TypeOnly<current.IStreamResult<any>>;
declare function use_old_TypeAliasDeclaration_IStreamResult(
    use: TypeOnly<old.IStreamResult<any>>): void;
use_old_TypeAliasDeclaration_IStreamResult(
    get_current_TypeAliasDeclaration_IStreamResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryContext": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryContext():
    TypeOnly<old.ISummaryContext>;
declare function use_current_InterfaceDeclaration_ISummaryContext(
    use: TypeOnly<current.ISummaryContext>): void;
use_current_InterfaceDeclaration_ISummaryContext(
    get_old_InterfaceDeclaration_ISummaryContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryContext": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryContext():
    TypeOnly<current.ISummaryContext>;
declare function use_old_InterfaceDeclaration_ISummaryContext(
    use: TypeOnly<old.ISummaryContext>): void;
use_old_InterfaceDeclaration_ISummaryContext(
    get_current_InterfaceDeclaration_ISummaryContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IThrottlingWarning": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IThrottlingWarning():
    TypeOnly<old.IThrottlingWarning>;
declare function use_current_InterfaceDeclaration_IThrottlingWarning(
    use: TypeOnly<current.IThrottlingWarning>): void;
use_current_InterfaceDeclaration_IThrottlingWarning(
    get_old_InterfaceDeclaration_IThrottlingWarning());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IThrottlingWarning": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IThrottlingWarning():
    TypeOnly<current.IThrottlingWarning>;
declare function use_old_InterfaceDeclaration_IThrottlingWarning(
    use: TypeOnly<old.IThrottlingWarning>): void;
use_old_InterfaceDeclaration_IThrottlingWarning(
    get_current_InterfaceDeclaration_IThrottlingWarning());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IUrlResolver": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IUrlResolver():
    TypeOnly<old.IUrlResolver>;
declare function use_current_InterfaceDeclaration_IUrlResolver(
    use: TypeOnly<current.IUrlResolver>): void;
use_current_InterfaceDeclaration_IUrlResolver(
    get_old_InterfaceDeclaration_IUrlResolver());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IUrlResolver": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IUrlResolver():
    TypeOnly<current.IUrlResolver>;
declare function use_old_InterfaceDeclaration_IUrlResolver(
    use: TypeOnly<old.IUrlResolver>): void;
use_old_InterfaceDeclaration_IUrlResolver(
    get_current_InterfaceDeclaration_IUrlResolver());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_LoaderCachingPolicy": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_LoaderCachingPolicy():
    TypeOnly<old.LoaderCachingPolicy>;
declare function use_current_EnumDeclaration_LoaderCachingPolicy(
    use: TypeOnly<current.LoaderCachingPolicy>): void;
use_current_EnumDeclaration_LoaderCachingPolicy(
    get_old_EnumDeclaration_LoaderCachingPolicy());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_LoaderCachingPolicy": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_LoaderCachingPolicy():
    TypeOnly<current.LoaderCachingPolicy>;
declare function use_old_EnumDeclaration_LoaderCachingPolicy(
    use: TypeOnly<old.LoaderCachingPolicy>): void;
use_old_EnumDeclaration_LoaderCachingPolicy(
    get_current_EnumDeclaration_LoaderCachingPolicy());
