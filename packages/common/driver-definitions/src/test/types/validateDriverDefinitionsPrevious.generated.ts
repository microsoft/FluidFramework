/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/driver-definitions-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_DriverErrorType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_DriverErrorType = requireAssignableTo<TypeOnly<old.DriverErrorType>, TypeOnly<current.DriverErrorType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_DriverErrorType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_DriverErrorType = requireAssignableTo<TypeOnly<current.DriverErrorType>, TypeOnly<old.DriverErrorType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_DriverHeader": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_DriverHeader = requireAssignableTo<TypeOnly<old.DriverHeader>, TypeOnly<current.DriverHeader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_DriverHeader": {"backCompat": false}
 */
declare type current_as_old_for_Enum_DriverHeader = requireAssignableTo<TypeOnly<current.DriverHeader>, TypeOnly<old.DriverHeader>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_LoaderCachingPolicy": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_LoaderCachingPolicy = requireAssignableTo<TypeOnly<old.LoaderCachingPolicy>, TypeOnly<current.LoaderCachingPolicy>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_LoaderCachingPolicy": {"backCompat": false}
 */
declare type current_as_old_for_Enum_LoaderCachingPolicy = requireAssignableTo<TypeOnly<current.LoaderCachingPolicy>, TypeOnly<old.LoaderCachingPolicy>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_DriverPreCheckInfo": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_DriverPreCheckInfo = requireAssignableTo<TypeOnly<old.DriverPreCheckInfo>, TypeOnly<current.DriverPreCheckInfo>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_DriverPreCheckInfo": {"backCompat": false}
 */
declare type current_as_old_for_Interface_DriverPreCheckInfo = requireAssignableTo<TypeOnly<current.DriverPreCheckInfo>, TypeOnly<old.DriverPreCheckInfo>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAuthorizationError": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IAuthorizationError = requireAssignableTo<TypeOnly<old.IAuthorizationError>, TypeOnly<current.IAuthorizationError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAuthorizationError": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IAuthorizationError = requireAssignableTo<TypeOnly<current.IAuthorizationError>, TypeOnly<old.IAuthorizationError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContainerPackageInfo": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IContainerPackageInfo = requireAssignableTo<TypeOnly<old.IContainerPackageInfo>, TypeOnly<current.IContainerPackageInfo>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContainerPackageInfo": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IContainerPackageInfo = requireAssignableTo<TypeOnly<current.IContainerPackageInfo>, TypeOnly<old.IContainerPackageInfo>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeltasFetchResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDeltasFetchResult = requireAssignableTo<TypeOnly<old.IDeltasFetchResult>, TypeOnly<current.IDeltasFetchResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeltasFetchResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDeltasFetchResult = requireAssignableTo<TypeOnly<current.IDeltasFetchResult>, TypeOnly<old.IDeltasFetchResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeltaStorageService": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDeltaStorageService = requireAssignableTo<TypeOnly<old.IDeltaStorageService>, TypeOnly<current.IDeltaStorageService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeltaStorageService": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDeltaStorageService = requireAssignableTo<TypeOnly<current.IDeltaStorageService>, TypeOnly<old.IDeltaStorageService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentDeltaConnection": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentDeltaConnection = requireAssignableTo<TypeOnly<old.IDocumentDeltaConnection>, TypeOnly<current.IDocumentDeltaConnection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentDeltaConnection": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentDeltaConnection = requireAssignableTo<TypeOnly<current.IDocumentDeltaConnection>, TypeOnly<old.IDocumentDeltaConnection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentDeltaConnectionEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentDeltaConnectionEvents = requireAssignableTo<TypeOnly<old.IDocumentDeltaConnectionEvents>, TypeOnly<current.IDocumentDeltaConnectionEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentDeltaConnectionEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentDeltaConnectionEvents = requireAssignableTo<TypeOnly<current.IDocumentDeltaConnectionEvents>, TypeOnly<old.IDocumentDeltaConnectionEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentDeltaStorageService": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentDeltaStorageService = requireAssignableTo<TypeOnly<old.IDocumentDeltaStorageService>, TypeOnly<current.IDocumentDeltaStorageService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentDeltaStorageService": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentDeltaStorageService = requireAssignableTo<TypeOnly<current.IDocumentDeltaStorageService>, TypeOnly<old.IDocumentDeltaStorageService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentService": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentService = requireAssignableTo<TypeOnly<old.IDocumentService>, TypeOnly<current.IDocumentService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentService": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentService = requireAssignableTo<TypeOnly<current.IDocumentService>, TypeOnly<old.IDocumentService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentServiceFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentServiceFactory = requireAssignableTo<TypeOnly<old.IDocumentServiceFactory>, TypeOnly<current.IDocumentServiceFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentServiceFactory": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentServiceFactory = requireAssignableTo<TypeOnly<current.IDocumentServiceFactory>, TypeOnly<old.IDocumentServiceFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentServicePolicies": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentServicePolicies = requireAssignableTo<TypeOnly<old.IDocumentServicePolicies>, TypeOnly<current.IDocumentServicePolicies>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentServicePolicies": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentServicePolicies = requireAssignableTo<TypeOnly<current.IDocumentServicePolicies>, TypeOnly<old.IDocumentServicePolicies>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentStorageService": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentStorageService = requireAssignableTo<TypeOnly<old.IDocumentStorageService>, TypeOnly<current.IDocumentStorageService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentStorageService": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentStorageService = requireAssignableTo<TypeOnly<current.IDocumentStorageService>, TypeOnly<old.IDocumentStorageService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentStorageServicePolicies": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentStorageServicePolicies = requireAssignableTo<TypeOnly<old.IDocumentStorageServicePolicies>, TypeOnly<current.IDocumentStorageServicePolicies>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentStorageServicePolicies": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentStorageServicePolicies = requireAssignableTo<TypeOnly<current.IDocumentStorageServicePolicies>, TypeOnly<old.IDocumentStorageServicePolicies>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDriverBasicError": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDriverBasicError = requireAssignableTo<TypeOnly<old.IDriverBasicError>, TypeOnly<current.IDriverBasicError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDriverBasicError": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDriverBasicError = requireAssignableTo<TypeOnly<current.IDriverBasicError>, TypeOnly<old.IDriverBasicError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDriverErrorBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDriverErrorBase = requireAssignableTo<TypeOnly<old.IDriverErrorBase>, TypeOnly<current.IDriverErrorBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDriverErrorBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDriverErrorBase = requireAssignableTo<TypeOnly<current.IDriverErrorBase>, TypeOnly<old.IDriverErrorBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDriverHeader": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDriverHeader = requireAssignableTo<TypeOnly<old.IDriverHeader>, TypeOnly<current.IDriverHeader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDriverHeader": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDriverHeader = requireAssignableTo<TypeOnly<current.IDriverHeader>, TypeOnly<old.IDriverHeader>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidResolvedUrl": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidResolvedUrl = requireAssignableTo<TypeOnly<old.IFluidResolvedUrl>, TypeOnly<current.IFluidResolvedUrl>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidResolvedUrl": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidResolvedUrl = requireAssignableTo<TypeOnly<current.IFluidResolvedUrl>, TypeOnly<old.IFluidResolvedUrl>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGenericNetworkError": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGenericNetworkError = requireAssignableTo<TypeOnly<old.IGenericNetworkError>, TypeOnly<current.IGenericNetworkError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGenericNetworkError": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGenericNetworkError = requireAssignableTo<TypeOnly<current.IGenericNetworkError>, TypeOnly<old.IGenericNetworkError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILocationRedirectionError": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ILocationRedirectionError = requireAssignableTo<TypeOnly<old.ILocationRedirectionError>, TypeOnly<current.ILocationRedirectionError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILocationRedirectionError": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ILocationRedirectionError = requireAssignableTo<TypeOnly<current.ILocationRedirectionError>, TypeOnly<old.ILocationRedirectionError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IResolvedUrlBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IResolvedUrlBase = requireAssignableTo<TypeOnly<old.IResolvedUrlBase>, TypeOnly<current.IResolvedUrlBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IResolvedUrlBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IResolvedUrlBase = requireAssignableTo<TypeOnly<current.IResolvedUrlBase>, TypeOnly<old.IResolvedUrlBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IStream": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IStream = requireAssignableTo<TypeOnly<old.IStream<never>>, TypeOnly<current.IStream<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IStream": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IStream = requireAssignableTo<TypeOnly<current.IStream<never>>, TypeOnly<old.IStream<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryContext = requireAssignableTo<TypeOnly<old.ISummaryContext>, TypeOnly<current.ISummaryContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryContext = requireAssignableTo<TypeOnly<current.ISummaryContext>, TypeOnly<old.ISummaryContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottlingWarning": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IThrottlingWarning = requireAssignableTo<TypeOnly<old.IThrottlingWarning>, TypeOnly<current.IThrottlingWarning>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottlingWarning": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IThrottlingWarning = requireAssignableTo<TypeOnly<current.IThrottlingWarning>, TypeOnly<old.IThrottlingWarning>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUrlResolver": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IUrlResolver = requireAssignableTo<TypeOnly<old.IUrlResolver>, TypeOnly<current.IUrlResolver>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUrlResolver": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IUrlResolver = requireAssignableTo<TypeOnly<current.IUrlResolver>, TypeOnly<old.IUrlResolver>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWebResolvedUrl": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWebResolvedUrl = requireAssignableTo<TypeOnly<old.IWebResolvedUrl>, TypeOnly<current.IWebResolvedUrl>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWebResolvedUrl": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWebResolvedUrl = requireAssignableTo<TypeOnly<current.IWebResolvedUrl>, TypeOnly<old.IWebResolvedUrl>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_DriverError": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_DriverError = requireAssignableTo<TypeOnly<old.DriverError>, TypeOnly<current.DriverError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_DriverError": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_DriverError = requireAssignableTo<TypeOnly<current.DriverError>, TypeOnly<old.DriverError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IResolvedUrl": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IResolvedUrl = requireAssignableTo<TypeOnly<old.IResolvedUrl>, TypeOnly<current.IResolvedUrl>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IResolvedUrl": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IResolvedUrl = requireAssignableTo<TypeOnly<current.IResolvedUrl>, TypeOnly<old.IResolvedUrl>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IStreamResult": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IStreamResult = requireAssignableTo<TypeOnly<old.IStreamResult<never>>, TypeOnly<current.IStreamResult<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IStreamResult": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IStreamResult = requireAssignableTo<TypeOnly<current.IStreamResult<never>>, TypeOnly<old.IStreamResult<never>>>
