/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/driver-definitions-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICapabilities": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICapabilities = requireAssignableTo<TypeOnly<old.ICapabilities>, TypeOnly<current.ICapabilities>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICapabilities": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICapabilities = requireAssignableTo<TypeOnly<current.ICapabilities>, TypeOnly<old.ICapabilities>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClient": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IClient = requireAssignableTo<TypeOnly<old.IClient>, TypeOnly<current.IClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClient": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IClient = requireAssignableTo<TypeOnly<current.IClient>, TypeOnly<old.IClient>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientDetails": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IClientDetails = requireAssignableTo<TypeOnly<old.IClientDetails>, TypeOnly<current.IClientDetails>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientDetails": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IClientDetails = requireAssignableTo<TypeOnly<current.IClientDetails>, TypeOnly<old.IClientDetails>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IQuorumClients": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IQuorumClients = requireAssignableTo<TypeOnly<old.IQuorumClients>, TypeOnly<current.IQuorumClients>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IQuorumClients": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IQuorumClients = requireAssignableTo<TypeOnly<current.IQuorumClients>, TypeOnly<old.IQuorumClients>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequencedClient": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISequencedClient = requireAssignableTo<TypeOnly<old.ISequencedClient>, TypeOnly<current.ISequencedClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequencedClient": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISequencedClient = requireAssignableTo<TypeOnly<current.ISequencedClient>, TypeOnly<old.ISequencedClient>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryAttachment": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryAttachment = requireAssignableTo<TypeOnly<old.ISummaryAttachment>, TypeOnly<current.ISummaryAttachment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryAttachment": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryAttachment = requireAssignableTo<TypeOnly<current.ISummaryAttachment>, TypeOnly<old.ISummaryAttachment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryBlob": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryBlob = requireAssignableTo<TypeOnly<old.ISummaryBlob>, TypeOnly<current.ISummaryBlob>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryBlob": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryBlob = requireAssignableTo<TypeOnly<current.ISummaryBlob>, TypeOnly<old.ISummaryBlob>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryHandle": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryHandle = requireAssignableTo<TypeOnly<old.ISummaryHandle>, TypeOnly<current.ISummaryHandle>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryHandle": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryHandle = requireAssignableTo<TypeOnly<current.ISummaryHandle>, TypeOnly<old.ISummaryHandle>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryTree": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryTree = requireAssignableTo<TypeOnly<old.ISummaryTree>, TypeOnly<current.ISummaryTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryTree": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryTree = requireAssignableTo<TypeOnly<current.ISummaryTree>, TypeOnly<old.ISummaryTree>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUser": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IUser = requireAssignableTo<TypeOnly<old.IUser>, TypeOnly<current.IUser>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUser": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IUser = requireAssignableTo<TypeOnly<current.IUser>, TypeOnly<old.IUser>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ConnectionMode": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ConnectionMode = requireAssignableTo<TypeOnly<old.ConnectionMode>, TypeOnly<current.ConnectionMode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ConnectionMode": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ConnectionMode = requireAssignableTo<TypeOnly<current.ConnectionMode>, TypeOnly<old.ConnectionMode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryObject": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SummaryObject = requireAssignableTo<TypeOnly<old.SummaryObject>, TypeOnly<current.SummaryObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryObject": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SummaryObject = requireAssignableTo<TypeOnly<current.SummaryObject>, TypeOnly<old.SummaryObject>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SummaryType = requireAssignableTo<TypeOnly<old.SummaryType>, TypeOnly<current.SummaryType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SummaryType = requireAssignableTo<TypeOnly<current.SummaryType>, TypeOnly<old.SummaryType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryTypeNoHandle": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SummaryTypeNoHandle = requireAssignableTo<TypeOnly<old.SummaryTypeNoHandle>, TypeOnly<current.SummaryTypeNoHandle>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryTypeNoHandle": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SummaryTypeNoHandle = requireAssignableTo<TypeOnly<current.SummaryTypeNoHandle>, TypeOnly<old.SummaryTypeNoHandle>>
