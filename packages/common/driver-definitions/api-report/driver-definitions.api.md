## API Report File for "@fluidframework/driver-definitions"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { IDisposable } from '@fluidframework/core-interfaces';
import type { IErrorEvent } from '@fluidframework/core-interfaces';
import type { IEvent } from '@fluidframework/core-interfaces';
import type { IEventProvider } from '@fluidframework/core-interfaces';
import type { IRequest } from '@fluidframework/core-interfaces';
import type { ITelemetryBaseLogger } from '@fluidframework/core-interfaces';

// @public
export type ConnectionMode = "write" | "read";

// @alpha (undocumented)
export type DriverError = IThrottlingWarning | IGenericNetworkError | IAuthorizationError | ILocationRedirectionError | IDriverBasicError;

// @alpha
export const DriverErrorTypes: {
    readonly genericNetworkError: "genericNetworkError";
    readonly authorizationError: "authorizationError";
    readonly fileNotFoundOrAccessDeniedError: "fileNotFoundOrAccessDeniedError";
    readonly offlineError: "offlineError";
    readonly unsupportedClientProtocolVersion: "unsupportedClientProtocolVersion";
    readonly writeError: "writeError";
    readonly fetchFailure: "fetchFailure";
    readonly fetchTokenError: "fetchTokenError";
    readonly incorrectServerResponse: "incorrectServerResponse";
    readonly fileOverwrittenInStorage: "fileOverwrittenInStorage";
    readonly deltaStreamConnectionForbidden: "deltaStreamConnectionForbidden";
    readonly locationRedirection: "locationRedirection";
    readonly fluidInvalidSchema: "fluidInvalidSchema";
    readonly fileIsLocked: "fileIsLocked";
    readonly outOfStorageError: "outOfStorageError";
    readonly genericError: "genericError";
    readonly throttlingError: "throttlingError";
    readonly usageError: "usageError";
};

// @alpha
export type DriverErrorTypes = (typeof DriverErrorTypes)[keyof typeof DriverErrorTypes];

// @alpha
export enum DriverHeader {
    // (undocumented)
    createNew = "createNew",
    // (undocumented)
    summarizingClient = "fluid-client-summarizer"
}

// @alpha
export interface DriverPreCheckInfo {
    codeDetailsHint?: string;
    criticalBootDomains?: string[];
}

// @alpha (undocumented)
export enum FetchSource {
    // (undocumented)
    default = "default",
    // (undocumented)
    noCache = "noCache"
}

// @alpha (undocumented)
export enum FileMode {
    // (undocumented)
    Directory = "040000",
    // (undocumented)
    Executable = "100755",
    // (undocumented)
    File = "100644",
    // (undocumented)
    Symlink = "120000"
}

// @alpha (undocumented)
export type FiveDaysMs = 432000000;

// @internal @deprecated (undocumented)
export interface IActorClient {
    // (undocumented)
    sub: string;
}

// @alpha
export interface IAnyDriverError extends Omit<IDriverErrorBase, "errorType"> {
    // (undocumented)
    readonly errorType: string;
    scenarioName?: string;
}

// @alpha
export type IApprovedProposal = {
    approvalSequenceNumber: number;
} & ISequencedProposal;

// @alpha (undocumented)
export interface IAttachment {
    // (undocumented)
    id: string;
}

// @alpha (undocumented)
export interface IAuthorizationError extends IDriverErrorBase {
    // (undocumented)
    readonly claims?: string;
    // (undocumented)
    readonly errorType: typeof DriverErrorTypes.authorizationError;
    // (undocumented)
    readonly tenantId?: string;
}

// @alpha
export interface IBlob {
    contents: string;
    encoding: "utf-8" | "base64";
}

// @public
export interface IBranchOrigin {
    id: string;
    minimumSequenceNumber: number;
    sequenceNumber: number;
}

// @public
export interface ICapabilities {
    interactive: boolean;
}

// @public
export interface IClient {
    details: IClientDetails;
    mode: ConnectionMode;
    // (undocumented)
    permission: string[];
    scopes: string[];
    timestamp?: number;
    user: IUser;
}

// @alpha
export interface IClientConfiguration {
    blockSize: number;
    maxMessageSize: number;
    noopCountFrequency?: number;
    noopTimeFrequency?: number;
}

// @public
export interface IClientDetails {
    capabilities: ICapabilities;
    // (undocumented)
    device?: string;
    // (undocumented)
    environment?: string;
    type?: string;
}

// @internal
export interface IClientJoin {
    clientId: string;
    detail: IClient;
}

// @alpha
export type ICommittedProposal = {
    commitSequenceNumber: number;
} & IApprovedProposal;

// @alpha
export interface IConnect {
    client: IClient;
    driverVersion?: string;
    epoch?: string;
    id: string;
    mode: ConnectionMode;
    nonce?: string;
    relayUserAgent?: string;
    supportedFeatures?: Record<string, unknown>;
    tenantId: string;
    token: string | null;
    versions: string[];
}

// @alpha
export interface IConnected {
    checkpointSequenceNumber?: number;
    claims: ITokenClaims;
    clientId: string;
    epoch?: string;
    existing: boolean;
    initialClients: ISignalClient[];
    initialMessages: ISequencedDocumentMessage[];
    initialSignals: ISignalMessage[];
    maxMessageSize: number;
    mode: ConnectionMode;
    nonce?: string;
    relayServiceAgent?: string;
    serviceConfiguration: IClientConfiguration;
    supportedFeatures?: Record<string, unknown>;
    supportedVersions: string[];
    timestamp?: number;
    version: string;
}

// @alpha
export interface IContainerPackageInfo {
    name: string;
}

// @alpha (undocumented)
export interface ICreateBlobResponse {
    // (undocumented)
    id: string;
}

// @internal (undocumented)
export interface IDeltasFetchResult {
    messages: ISequencedDocumentMessage[];
    partialResult: boolean;
}

// @internal
export interface IDeltaStorageService {
    get(tenantId: string, id: string, from: number, // inclusive
    to: number, // exclusive
    fetchReason?: string): Promise<IDeltasFetchResult>;
}

// @alpha (undocumented)
export interface IDocumentAttributes {
    minimumSequenceNumber: number;
    sequenceNumber: number;
}

// @alpha (undocumented)
export interface IDocumentDeltaConnection extends IDisposable, IEventProvider<IDocumentDeltaConnectionEvents> {
    checkpointSequenceNumber?: number;
    claims: ITokenClaims;
    clientId: string;
    existing: boolean;
    initialClients: ISignalClient[];
    initialMessages: ISequencedDocumentMessage[];
    initialSignals: ISignalMessage[];
    mode: ConnectionMode;
    relayServiceAgent?: string;
    serviceConfiguration: IClientConfiguration;
    submit(messages: IDocumentMessage[]): void;
    submitSignal: (content: string, targetClientId?: string) => void;
    version: string;
}

// @alpha (undocumented)
export interface IDocumentDeltaConnectionEvents extends IErrorEvent {
    // (undocumented)
    (event: "nack", listener: (documentId: string, message: INack[]) => void): any;
    // (undocumented)
    (event: "disconnect", listener: (reason: IAnyDriverError) => void): any;
    // (undocumented)
    (event: "op", listener: (documentId: string, messages: ISequencedDocumentMessage[]) => void): any;
    // (undocumented)
    (event: "signal", listener: (message: ISignalMessage | ISignalMessage[]) => void): any;
    // (undocumented)
    (event: "pong", listener: (latency: number) => void): any;
    // (undocumented)
    (event: "error", listener: (error: any) => void): any;
}

// @alpha
export interface IDocumentDeltaStorageService {
    fetchMessages(from: number, to: number | undefined, abortSignal?: AbortSignal, cachedOnly?: boolean, fetchReason?: string): IStream<ISequencedDocumentMessage[]>;
}

// @alpha
export interface IDocumentMessage {
    clientSequenceNumber: number;
    compression?: string;
    contents: unknown;
    metadata?: unknown;
    referenceSequenceNumber: number;
    serverMetadata?: unknown;
    traces?: ITrace[];
    type: string;
}

// @alpha (undocumented)
export interface IDocumentService extends IEventProvider<IDocumentServiceEvents> {
    connectToDeltaStorage(): Promise<IDocumentDeltaStorageService>;
    connectToDeltaStream(client: IClient): Promise<IDocumentDeltaConnection>;
    connectToStorage(): Promise<IDocumentStorageService>;
    dispose(error?: any): void;
    policies?: IDocumentServicePolicies;
    // (undocumented)
    resolvedUrl: IResolvedUrl;
}

// @alpha
export interface IDocumentServiceEvents extends IEvent {
    (event: "metadataUpdate", listener: (metadata: Record<string, string>) => void): any;
}

// @alpha (undocumented)
export interface IDocumentServiceFactory {
    createContainer(createNewSummary: ISummaryTree | undefined, createNewResolvedUrl: IResolvedUrl, logger?: ITelemetryBaseLogger, clientIsSummarizer?: boolean): Promise<IDocumentService>;
    createDocumentService(resolvedUrl: IResolvedUrl, logger?: ITelemetryBaseLogger, clientIsSummarizer?: boolean): Promise<IDocumentService>;
}

// @alpha (undocumented)
export interface IDocumentServicePolicies {
    readonly storageOnly?: boolean;
    readonly summarizeProtocolTree?: boolean;
    readonly supportGetSnapshotApi?: boolean;
}

// @alpha
export interface IDocumentStorageService extends Partial<IDisposable> {
    createBlob(file: ArrayBufferLike): Promise<ICreateBlobResponse>;
    downloadSummary(handle: ISummaryHandle): Promise<ISummaryTree>;
    getSnapshot?(snapshotFetchOptions?: ISnapshotFetchOptions): Promise<ISnapshot>;
    getSnapshotTree(version?: IVersion, scenarioName?: string): Promise<ISnapshotTree | null>;
    getVersions(versionId: string | null, count: number, scenarioName?: string, fetchSource?: FetchSource): Promise<IVersion[]>;
    readonly policies?: IDocumentStorageServicePolicies;
    readBlob(id: string): Promise<ArrayBufferLike>;
    uploadSummaryWithContext(summary: ISummaryTree, context: ISummaryContext): Promise<string>;
}

// @alpha
export interface IDocumentStorageServicePolicies {
    readonly caching?: LoaderCachingPolicy;
    readonly maximumCacheDurationMs?: FiveDaysMs;
}

// @internal
export interface IDocumentSystemMessage extends IDocumentMessage {
    // (undocumented)
    data: string;
}

// @alpha
export interface IDriverBasicError extends IDriverErrorBase {
    // (undocumented)
    readonly errorType: typeof DriverErrorTypes.genericError | typeof DriverErrorTypes.fileNotFoundOrAccessDeniedError | typeof DriverErrorTypes.offlineError | typeof DriverErrorTypes.unsupportedClientProtocolVersion | typeof DriverErrorTypes.writeError | typeof DriverErrorTypes.fetchFailure | typeof DriverErrorTypes.fetchTokenError | typeof DriverErrorTypes.incorrectServerResponse | typeof DriverErrorTypes.fileOverwrittenInStorage | typeof DriverErrorTypes.fluidInvalidSchema | typeof DriverErrorTypes.usageError | typeof DriverErrorTypes.fileIsLocked | typeof DriverErrorTypes.outOfStorageError;
    // (undocumented)
    readonly statusCode?: number;
}

// @alpha
export interface IDriverErrorBase {
    canRetry: boolean;
    endpointReached?: boolean;
    readonly errorType: DriverErrorTypes;
    readonly message: string;
    online?: string;
}

// @internal (undocumented)
export interface IDriverHeader {
    // (undocumented)
    [DriverHeader.summarizingClient]: boolean;
    // (undocumented)
    [DriverHeader.createNew]: any;
}

// @alpha (undocumented)
export interface IGenericNetworkError extends IDriverErrorBase {
    // (undocumented)
    readonly errorType: typeof DriverErrorTypes.genericNetworkError;
    // (undocumented)
    readonly statusCode?: number;
}

// @alpha (undocumented)
export interface ILocationRedirectionError extends IDriverErrorBase {
    // (undocumented)
    readonly errorType: typeof DriverErrorTypes.locationRedirection;
    // (undocumented)
    readonly redirectUrl: IResolvedUrl;
}

// @alpha (undocumented)
export interface INack {
    content: INackContent;
    operation: IDocumentMessage | undefined;
    sequenceNumber: number;
}

// @alpha
export interface INackContent {
    code: number;
    message: string;
    retryAfter?: number;
    type: NackErrorType;
}

// @alpha (undocumented)
export interface IProcessMessageResult {
    // (undocumented)
    immediateNoOp?: boolean;
}

// @alpha
export interface IProposal {
    key: string;
    value: unknown;
}

// @internal (undocumented)
export interface IProtocolState {
    // (undocumented)
    members: [string, ISequencedClient][];
    // (undocumented)
    minimumSequenceNumber: number;
    // (undocumented)
    proposals: [number, ISequencedProposal, string[]][];
    // (undocumented)
    sequenceNumber: number;
    // (undocumented)
    values: [string, ICommittedProposal][];
}

// @alpha
export interface IQuorum extends Omit<IQuorumClients, "on" | "once" | "off">, Omit<IQuorumProposals, "on" | "once" | "off"> {
    // (undocumented)
    off: IQuorum["on"];
    // (undocumented)
    on: IQuorumClients["on"] & IQuorumProposals["on"];
    // (undocumented)
    once: IQuorum["on"];
}

// @public
export interface IQuorumClients {
    // (undocumented)
    getMember(clientId: string): ISequencedClient | undefined;
    // (undocumented)
    getMembers(): Map<string, ISequencedClient>;
    // (undocumented)
    off: IQuorumClients["on"];
    // (undocumented)
    on(event: "addMember", listener: (clientId: string, details: ISequencedClient) => void): any;
    // (undocumented)
    on(event: "removeMember", listener: (clientId: string) => void): any;
    // (undocumented)
    on(event: "error", listener: (message: any) => void): any;
    // (undocumented)
    once: IQuorumClients["on"];
}

// @internal @deprecated (undocumented)
export interface IQuorumClientsEvents {
    // (undocumented)
    (event: "addMember", listener: (clientId: string, details: ISequencedClient) => void): any;
    // (undocumented)
    (event: "removeMember", listener: (clientId: string) => void): any;
    // (undocumented)
    (event: "error", listener: (message: any) => void): any;
}

// @internal @deprecated
export type IQuorumEvents = IQuorumClientsEvents & IQuorumProposalsEvents;

// @alpha
export interface IQuorumProposals {
    // (undocumented)
    get(key: string): unknown;
    // (undocumented)
    has(key: string): boolean;
    // (undocumented)
    off: IQuorumProposals["on"];
    // (undocumented)
    on(event: "addProposal", listener: (proposal: ISequencedProposal) => void): any;
    // (undocumented)
    on(event: "approveProposal", listener: (sequenceNumber: number, key: string, value: unknown, approvalSequenceNumber: number) => void): any;
    // (undocumented)
    on(event: "error", listener: (message: any) => void): void;
    // (undocumented)
    once: IQuorumProposals["on"];
    // (undocumented)
    propose(key: string, value: unknown): Promise<void>;
}

// @internal @deprecated
export interface IQuorumProposalsEvents {
    // (undocumented)
    (event: "addProposal", listener: (proposal: ISequencedProposal) => void): any;
    // (undocumented)
    (event: "approveProposal", listener: (sequenceNumber: number, key: string, value: unknown, approvalSequenceNumber: number) => void): any;
    // (undocumented)
    (event: "error", listener: (message: any) => void): void;
}

// @alpha (undocumented)
export interface IResolvedUrl {
    // (undocumented)
    endpoints: {
        [name: string]: string;
    };
    id: string;
    // (undocumented)
    tokens: {
        [name: string]: string;
    };
    // (undocumented)
    type: "fluid";
    // (undocumented)
    url: string;
}

// @internal
export type ISentSignalMessage = ISignalMessageBase;

// @public
export interface ISequencedClient {
    client: IClient;
    sequenceNumber: number;
}

// @internal (undocumented)
export interface ISequencedDocumentAugmentedMessage extends ISequencedDocumentMessage {
    // (undocumented)
    additionalContent: string;
}

// @public
export interface ISequencedDocumentMessage {
    clientId: string | null;
    clientSequenceNumber: number;
    // @deprecated
    compression?: string;
    contents: unknown;
    data?: string;
    // @deprecated
    expHash1?: string;
    metadata?: unknown;
    minimumSequenceNumber: number;
    origin?: IBranchOrigin;
    referenceSequenceNumber: number;
    sequenceNumber: number;
    serverMetadata?: unknown;
    timestamp: number;
    traces?: ITrace[];
    type: string;
}

// @internal
export type ISequencedDocumentMessageExperimental = Omit<ISequencedDocumentMessage, "expHash1" | "compression"> & {
    expHash1?: string;
    compression?: string;
};

// @internal (undocumented)
export interface ISequencedDocumentSystemMessage extends ISequencedDocumentMessage {
    // (undocumented)
    data: string;
}

// @alpha
export type ISequencedProposal = {
    sequenceNumber: number;
} & IProposal;

// @internal
export interface IServerError {
    errorMessage: string;
}

// @alpha (undocumented)
export interface ISignalClient {
    client: IClient;
    clientConnectionNumber?: number;
    clientId: string;
    referenceSequenceNumber?: number;
}

// @public
export interface ISignalMessage extends ISignalMessageBase {
    clientId: string | null;
}

// @public
export interface ISignalMessageBase {
    clientConnectionNumber?: number;
    content: unknown;
    referenceSequenceNumber?: number;
    targetClientId?: string;
    type?: string;
}

// @alpha
export interface ISnapshot {
    // (undocumented)
    blobContents: Map<string, ArrayBuffer>;
    latestSequenceNumber: number | undefined;
    // (undocumented)
    ops: ISequencedDocumentMessage[];
    sequenceNumber: number | undefined;
    // (undocumented)
    snapshotFormatV: 1;
    // (undocumented)
    snapshotTree: ISnapshotTree;
}

// @alpha
export interface ISnapshotFetchOptions {
    cacheSnapshot?: boolean;
    fetchSource?: FetchSource;
    loadingGroupIds?: string[];
    scenarioName?: string;
    versionId?: string;
}

// @alpha (undocumented)
export interface ISnapshotTree {
    // (undocumented)
    blobs: {
        [path: string]: string;
    };
    groupId?: string;
    // (undocumented)
    id?: string;
    // (undocumented)
    trees: {
        [path: string]: ISnapshotTree;
    };
    unreferenced?: true;
}

// @internal (undocumented)
export interface ISnapshotTreeEx extends ISnapshotTree {
    // (undocumented)
    id: string;
    // (undocumented)
    trees: {
        [path: string]: ISnapshotTreeEx;
    };
}

// @alpha
export type IsoDate = string;

// @alpha
export interface IStream<T> {
    // (undocumented)
    read(): Promise<IStreamResult<T>>;
}

// @alpha (undocumented)
export type IStreamResult<T> = {
    done: true;
} | {
    done: false;
    value: T;
};

// @alpha
export interface ISummaryAck {
    handle: string;
    summaryProposal: ISummaryProposal;
}

// @public
export interface ISummaryAttachment {
    // (undocumented)
    id: string;
    // (undocumented)
    type: SummaryType.Attachment;
}

// @public
export interface ISummaryBlob {
    // (undocumented)
    content: string | Uint8Array;
    // (undocumented)
    type: SummaryType.Blob;
}

// @alpha (undocumented)
export interface ISummaryContent {
    details?: IUploadedSummaryDetails;
    handle: string;
    head: string;
    message: string;
    parents: string[];
}

// @alpha
export interface ISummaryContext {
    readonly ackHandle: string | undefined;
    readonly proposalHandle: string | undefined;
    // (undocumented)
    readonly referenceSequenceNumber: number;
}

// @public
export interface ISummaryHandle {
    handle: string;
    handleType: SummaryTypeNoHandle;
    // (undocumented)
    type: SummaryType.Handle;
}

// @alpha
export interface ISummaryNack {
    code?: number;
    message?: string;
    retryAfter?: number;
    summaryProposal: ISummaryProposal;
}

// @alpha
export interface ISummaryProposal {
    summarySequenceNumber: number;
}

// @internal @deprecated (undocumented)
export interface ISummaryTokenClaims {
    // (undocumented)
    act: IActorClient;
    // (undocumented)
    claims: ITokenClaims;
    // (undocumented)
    sub: string;
}

// @public
export interface ISummaryTree {
    groupId?: string;
    // (undocumented)
    tree: {
        [path: string]: SummaryObject;
    };
    // (undocumented)
    type: SummaryType.Tree;
    unreferenced?: true;
}

// @alpha (undocumented)
export interface IThrottlingWarning extends IDriverErrorBase {
    // (undocumented)
    readonly errorType: typeof DriverErrorTypes.throttlingError;
    // (undocumented)
    readonly retryAfterSeconds: number;
}

// @alpha
export interface ITokenClaims {
    documentId: string;
    exp: number;
    iat: number;
    jti?: string;
    scopes: string[];
    tenantId: string;
    user: IUser;
    ver: string;
}

// @internal @deprecated (undocumented)
export interface ITokenProvider {
    isValid(): boolean;
}

// @internal @deprecated (undocumented)
export interface ITokenService {
    // (undocumented)
    extractClaims(token: string): ITokenClaims;
}

// @public
export interface ITrace {
    action: string;
    service: string;
    timestamp: number;
}

// @alpha (undocumented)
export interface ITree {
    // (undocumented)
    entries: ITreeEntry[];
    groupId?: string;
    id?: string;
    unreferenced?: true;
}

// @alpha
export type ITreeEntry = {
    path: string;
    mode: FileMode;
} & ({
    type: TreeEntry.Blob;
    value: IBlob;
} | {
    type: TreeEntry.Tree;
    value: ITree;
} | {
    type: TreeEntry.Attachment;
    value: IAttachment;
});

// @alpha (undocumented)
export interface IUploadedSummaryDetails {
    includesProtocolTree?: boolean;
}

// @alpha (undocumented)
export interface IUrlResolver {
    getAbsoluteUrl(resolvedUrl: IResolvedUrl, relativeUrl: string, packageInfoSource?: IContainerPackageInfo): Promise<string>;
    // (undocumented)
    resolve(request: IRequest): Promise<IResolvedUrl | undefined>;
}

// @public
export interface IUser {
    id: string;
}

// @alpha
export interface IVersion {
    date?: IsoDate;
    id: string;
    treeId: string;
}

// @alpha (undocumented)
export enum LoaderCachingPolicy {
    NoCaching = 0,
    Prefetch = 1
}

// @alpha (undocumented)
export enum MessageType {
    Accept = "accept",
    ClientJoin = "join",
    ClientLeave = "leave",
    Control = "control",
    NoClient = "noClient",
    NoOp = "noop",
    Operation = "op",
    Propose = "propose",
    Reject = "reject",
    RoundTrip = "tripComplete",
    Summarize = "summarize",
    SummaryAck = "summaryAck",
    SummaryNack = "summaryNack"
}

// @alpha
export enum NackErrorType {
    BadRequestError = "BadRequestError",
    InvalidScopeError = "InvalidScopeError",
    LimitExceededError = "LimitExceededError",
    ThrottlingError = "ThrottlingError"
}

// @alpha
export enum ScopeType {
    DocRead = "doc:read",
    DocWrite = "doc:write",
    SummaryWrite = "summary:write"
}

// @internal (undocumented)
export enum SignalType {
    ClientJoin = "join",
    ClientLeave = "leave"
}

// @public
export type SummaryObject = ISummaryTree | ISummaryBlob | ISummaryHandle | ISummaryAttachment;

// @alpha
export type SummaryTree = ISummaryTree | ISummaryHandle;

// @public
export namespace SummaryType {
    // @internal (undocumented)
    export type Attachment = 4;
    // @internal (undocumented)
    export type Blob = 2;
    // @internal (undocumented)
    export type Handle = 3;
    // @internal (undocumented)
    export type Tree = 1;
    const Tree: Tree;
    const Blob: Blob;
    const Handle: Handle;
    const Attachment: Attachment;
}

// @public
export type SummaryType = SummaryType.Attachment | SummaryType.Blob | SummaryType.Handle | SummaryType.Tree;

// @public
export type SummaryTypeNoHandle = SummaryType.Tree | SummaryType.Blob | SummaryType.Attachment;

// @alpha
export enum TreeEntry {
    // (undocumented)
    Attachment = "Attachment",
    // (undocumented)
    Blob = "Blob",
    // (undocumented)
    Tree = "Tree"
}

// (No @packageDocumentation comment for this package)

```
