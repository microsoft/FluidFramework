## API Report File for "@fluidframework/driver-definitions"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ConnectionMode } from '@fluidframework/protocol-definitions';
import { IClient } from '@fluidframework/protocol-definitions';
import { IClientConfiguration } from '@fluidframework/protocol-definitions';
import { ICreateBlobResponse } from '@fluidframework/protocol-definitions';
import { IDisposable } from '@fluidframework/core-interfaces';
import { IDocumentMessage } from '@fluidframework/protocol-definitions';
import { IErrorEvent } from '@fluidframework/core-interfaces';
import { IEvent } from '@fluidframework/core-interfaces';
import { IEventProvider } from '@fluidframework/core-interfaces';
import { INack } from '@fluidframework/protocol-definitions';
import { IRequest } from '@fluidframework/core-interfaces';
import { ISequencedDocumentMessage } from '@fluidframework/protocol-definitions';
import { ISignalClient } from '@fluidframework/protocol-definitions';
import { ISignalMessage } from '@fluidframework/protocol-definitions';
import { ISnapshotTree } from '@fluidframework/protocol-definitions';
import { ISummaryHandle } from '@fluidframework/protocol-definitions';
import { ISummaryTree } from '@fluidframework/protocol-definitions';
import { ITelemetryBaseLogger } from '@fluidframework/core-interfaces';
import { ITokenClaims } from '@fluidframework/protocol-definitions';
import { IVersion } from '@fluidframework/protocol-definitions';

// @alpha (undocumented)
export type DriverError = IThrottlingWarning | IGenericNetworkError | IAuthorizationError | ILocationRedirectionError | IDriverBasicError;

// @public
export const DriverErrorTypes: {
    readonly genericNetworkError: "genericNetworkError";
    readonly authorizationError: "authorizationError";
    readonly fileNotFoundOrAccessDeniedError: "fileNotFoundOrAccessDeniedError";
    readonly offlineError: "offlineError";
    readonly unsupportedClientProtocolVersion: "unsupportedClientProtocolVersion";
    readonly writeError: "writeError";
    readonly fetchFailure: "fetchFailure";
    readonly fetchTokenError: "fetchTokenError";
    readonly incorrectServerResponse: "incorrectServerResponse";
    readonly fileOverwrittenInStorage: "fileOverwrittenInStorage";
    readonly deltaStreamConnectionForbidden: "deltaStreamConnectionForbidden";
    readonly locationRedirection: "locationRedirection";
    readonly fluidInvalidSchema: "fluidInvalidSchema";
    readonly fileIsLocked: "fileIsLocked";
    readonly outOfStorageError: "outOfStorageError";
    readonly genericError: "genericError";
    readonly throttlingError: "throttlingError";
    readonly usageError: "usageError";
};

// @public (undocumented)
export type DriverErrorTypes = (typeof DriverErrorTypes)[keyof typeof DriverErrorTypes];

// @alpha
export enum DriverHeader {
    // (undocumented)
    createNew = "createNew",
    // (undocumented)
    summarizingClient = "fluid-client-summarizer"
}

// @alpha
export interface DriverPreCheckInfo {
    codeDetailsHint?: string;
    criticalBootDomains?: string[];
}

// @alpha (undocumented)
export enum FetchSource {
    // (undocumented)
    default = "default",
    // (undocumented)
    noCache = "noCache"
}

// @alpha (undocumented)
export type FiveDaysMs = 432000000;

// @public
export interface IAnyDriverError extends Omit<IDriverErrorBase, "errorType"> {
    // (undocumented)
    readonly errorType: string;
}

// @alpha (undocumented)
export interface IAuthorizationError extends IDriverErrorBase {
    // (undocumented)
    readonly claims?: string;
    // (undocumented)
    readonly errorType: typeof DriverErrorTypes.authorizationError;
    // (undocumented)
    readonly tenantId?: string;
}

// @alpha
export interface IContainerPackageInfo {
    name: string;
}

// @internal (undocumented)
export interface IDeltasFetchResult {
    messages: ISequencedDocumentMessage[];
    partialResult: boolean;
}

// @internal
export interface IDeltaStorageService {
    get(tenantId: string, id: string, from: number, // inclusive
    to: number, // exclusive
    fetchReason?: string): Promise<IDeltasFetchResult>;
}

// @alpha (undocumented)
export interface IDocumentDeltaConnection extends IDisposable, IEventProvider<IDocumentDeltaConnectionEvents> {
    checkpointSequenceNumber?: number;
    claims: ITokenClaims;
    clientId: string;
    existing: boolean;
    initialClients: ISignalClient[];
    initialMessages: ISequencedDocumentMessage[];
    initialSignals: ISignalMessage[];
    mode: ConnectionMode;
    relayServiceAgent?: string;
    serviceConfiguration: IClientConfiguration;
    submit(messages: IDocumentMessage[]): void;
    submitSignal(content: any, targetClientId?: string): void;
    version: string;
}

// @alpha (undocumented)
export interface IDocumentDeltaConnectionEvents extends IErrorEvent {
    // (undocumented)
    (event: "nack", listener: (documentId: string, message: INack[]) => void): any;
    // (undocumented)
    (event: "disconnect", listener: (reason: IAnyDriverError) => void): any;
    // (undocumented)
    (event: "op", listener: (documentId: string, messages: ISequencedDocumentMessage[]) => void): any;
    // (undocumented)
    (event: "signal", listener: (message: ISignalMessage | ISignalMessage[]) => void): any;
    // (undocumented)
    (event: "pong", listener: (latency: number) => void): any;
    // (undocumented)
    (event: "error", listener: (error: any) => void): any;
}

// @alpha
export interface IDocumentDeltaStorageService {
    fetchMessages(from: number, to: number | undefined, abortSignal?: AbortSignal, cachedOnly?: boolean, fetchReason?: string): IStream<ISequencedDocumentMessage[]>;
}

// @alpha (undocumented)
export interface IDocumentService extends IEventProvider<IDocumentServiceEvents> {
    connectToDeltaStorage(): Promise<IDocumentDeltaStorageService>;
    connectToDeltaStream(client: IClient): Promise<IDocumentDeltaConnection>;
    connectToStorage(): Promise<IDocumentStorageService>;
    dispose(error?: any): void;
    policies?: IDocumentServicePolicies;
    // (undocumented)
    resolvedUrl: IResolvedUrl;
}

// @alpha
export interface IDocumentServiceEvents extends IEvent {
    (event: "metadataUpdate", listener: (metadata: Record<string, string>) => void): any;
}

// @alpha (undocumented)
export interface IDocumentServiceFactory {
    createContainer(createNewSummary: ISummaryTree | undefined, createNewResolvedUrl: IResolvedUrl, logger?: ITelemetryBaseLogger, clientIsSummarizer?: boolean): Promise<IDocumentService>;
    createDocumentService(resolvedUrl: IResolvedUrl, logger?: ITelemetryBaseLogger, clientIsSummarizer?: boolean): Promise<IDocumentService>;
}

// @alpha (undocumented)
export interface IDocumentServicePolicies {
    readonly storageOnly?: boolean;
    readonly summarizeProtocolTree?: boolean;
    readonly supportGetSnapshotApi?: boolean;
}

// @alpha
export interface IDocumentStorageService extends Partial<IDisposable> {
    createBlob(file: ArrayBufferLike): Promise<ICreateBlobResponse>;
    downloadSummary(handle: ISummaryHandle): Promise<ISummaryTree>;
    getSnapshot?(snapshotFetchOptions?: ISnapshotFetchOptions): Promise<ISnapshot>;
    getSnapshotTree(version?: IVersion, scenarioName?: string): Promise<ISnapshotTree | null>;
    getVersions(versionId: string | null, count: number, scenarioName?: string, fetchSource?: FetchSource): Promise<IVersion[]>;
    readonly policies?: IDocumentStorageServicePolicies;
    readBlob(id: string): Promise<ArrayBufferLike>;
    // (undocumented)
    repositoryUrl: string;
    uploadSummaryWithContext(summary: ISummaryTree, context: ISummaryContext): Promise<string>;
}

// @alpha
export interface IDocumentStorageServicePolicies {
    readonly caching?: LoaderCachingPolicy;
    readonly maximumCacheDurationMs?: FiveDaysMs;
}

// @alpha
export interface IDriverBasicError extends IDriverErrorBase {
    // (undocumented)
    readonly errorType: typeof DriverErrorTypes.genericError | typeof DriverErrorTypes.fileNotFoundOrAccessDeniedError | typeof DriverErrorTypes.offlineError | typeof DriverErrorTypes.unsupportedClientProtocolVersion | typeof DriverErrorTypes.writeError | typeof DriverErrorTypes.fetchFailure | typeof DriverErrorTypes.fetchTokenError | typeof DriverErrorTypes.incorrectServerResponse | typeof DriverErrorTypes.fileOverwrittenInStorage | typeof DriverErrorTypes.fluidInvalidSchema | typeof DriverErrorTypes.usageError | typeof DriverErrorTypes.fileIsLocked | typeof DriverErrorTypes.outOfStorageError;
    // (undocumented)
    readonly statusCode?: number;
}

// @public
export interface IDriverErrorBase {
    canRetry: boolean;
    endpointReached?: boolean;
    readonly errorType: DriverErrorTypes;
    readonly message: string;
    online?: string;
}

// @internal (undocumented)
export interface IDriverHeader {
    // (undocumented)
    [DriverHeader.summarizingClient]: boolean;
    // (undocumented)
    [DriverHeader.createNew]: any;
}

// @alpha (undocumented)
export interface IGenericNetworkError extends IDriverErrorBase {
    // (undocumented)
    readonly errorType: typeof DriverErrorTypes.genericNetworkError;
    // (undocumented)
    readonly statusCode?: number;
}

// @alpha (undocumented)
export interface ILocationRedirectionError extends IDriverErrorBase {
    // (undocumented)
    readonly errorType: typeof DriverErrorTypes.locationRedirection;
    // (undocumented)
    readonly redirectUrl: IResolvedUrl;
}

// @alpha (undocumented)
export interface IResolvedUrl {
    // (undocumented)
    endpoints: {
        [name: string]: string;
    };
    id: string;
    // (undocumented)
    tokens: {
        [name: string]: string;
    };
    // (undocumented)
    type: "fluid";
    // (undocumented)
    url: string;
}

// @alpha (undocumented)
export interface ISnapshot {
    // (undocumented)
    blobContents: Map<string, ArrayBuffer>;
    latestSequenceNumber: number | undefined;
    // (undocumented)
    ops: ISequencedDocumentMessage[];
    sequenceNumber: number | undefined;
    // (undocumented)
    snapshotFormatV: 1;
    // (undocumented)
    snapshotTree: ISnapshotTree;
}

// @alpha
export interface ISnapshotFetchOptions {
    cacheSnapshot?: boolean;
    scenarioName?: string;
    versionId?: string;
}

// @alpha
export interface IStream<T> {
    // (undocumented)
    read(): Promise<IStreamResult<T>>;
}

// @alpha (undocumented)
export type IStreamResult<T> = {
    done: true;
} | {
    done: false;
    value: T;
};

// @alpha
export interface ISummaryContext {
    readonly ackHandle: string | undefined;
    readonly proposalHandle: string | undefined;
    // (undocumented)
    readonly referenceSequenceNumber: number;
}

// @alpha (undocumented)
export interface IThrottlingWarning extends IDriverErrorBase {
    // (undocumented)
    readonly errorType: typeof DriverErrorTypes.throttlingError;
    // (undocumented)
    readonly retryAfterSeconds: number;
}

// @alpha (undocumented)
export interface IUrlResolver {
    getAbsoluteUrl(resolvedUrl: IResolvedUrl, relativeUrl: string, packageInfoSource?: IContainerPackageInfo): Promise<string>;
    // (undocumented)
    resolve(request: IRequest): Promise<IResolvedUrl | undefined>;
}

// @alpha (undocumented)
export enum LoaderCachingPolicy {
    NoCaching = 0,
    Prefetch = 1
}

// (No @packageDocumentation comment for this package)

```
