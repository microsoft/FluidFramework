/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */
import type * as old from "@fluidframework/odsp-driver-definitions-previous";
import type * as current from "../../index.js";


// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CacheContentType": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_CacheContentType():
    TypeOnly<old.CacheContentType>;
declare function use_current_TypeAliasDeclaration_CacheContentType(
    use: TypeOnly<current.CacheContentType>): void;
use_current_TypeAliasDeclaration_CacheContentType(
    get_old_TypeAliasDeclaration_CacheContentType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CacheContentType": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_CacheContentType():
    TypeOnly<current.CacheContentType>;
declare function use_old_TypeAliasDeclaration_CacheContentType(
    use: TypeOnly<old.CacheContentType>): void;
use_old_TypeAliasDeclaration_CacheContentType(
    get_current_TypeAliasDeclaration_CacheContentType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_HostStoragePolicy": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_HostStoragePolicy():
    TypeOnly<old.HostStoragePolicy>;
declare function use_current_InterfaceDeclaration_HostStoragePolicy(
    use: TypeOnly<current.HostStoragePolicy>): void;
use_current_InterfaceDeclaration_HostStoragePolicy(
    get_old_InterfaceDeclaration_HostStoragePolicy());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_HostStoragePolicy": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_HostStoragePolicy():
    TypeOnly<current.HostStoragePolicy>;
declare function use_old_InterfaceDeclaration_HostStoragePolicy(
    use: TypeOnly<old.HostStoragePolicy>): void;
use_old_InterfaceDeclaration_HostStoragePolicy(
    get_current_InterfaceDeclaration_HostStoragePolicy());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICacheEntry": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICacheEntry():
    TypeOnly<old.ICacheEntry>;
declare function use_current_InterfaceDeclaration_ICacheEntry(
    use: TypeOnly<current.ICacheEntry>): void;
use_current_InterfaceDeclaration_ICacheEntry(
    get_old_InterfaceDeclaration_ICacheEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICacheEntry": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICacheEntry():
    TypeOnly<current.ICacheEntry>;
declare function use_old_InterfaceDeclaration_ICacheEntry(
    use: TypeOnly<old.ICacheEntry>): void;
use_old_InterfaceDeclaration_ICacheEntry(
    get_current_InterfaceDeclaration_ICacheEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICollabSessionOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICollabSessionOptions():
    TypeOnly<old.ICollabSessionOptions>;
declare function use_current_InterfaceDeclaration_ICollabSessionOptions(
    use: TypeOnly<current.ICollabSessionOptions>): void;
use_current_InterfaceDeclaration_ICollabSessionOptions(
    get_old_InterfaceDeclaration_ICollabSessionOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICollabSessionOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICollabSessionOptions():
    TypeOnly<current.ICollabSessionOptions>;
declare function use_old_InterfaceDeclaration_ICollabSessionOptions(
    use: TypeOnly<old.ICollabSessionOptions>): void;
use_old_InterfaceDeclaration_ICollabSessionOptions(
    get_current_InterfaceDeclaration_ICollabSessionOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEntry": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IEntry():
    TypeOnly<old.IEntry>;
declare function use_current_InterfaceDeclaration_IEntry(
    use: TypeOnly<current.IEntry>): void;
use_current_InterfaceDeclaration_IEntry(
    get_old_InterfaceDeclaration_IEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEntry": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IEntry():
    TypeOnly<current.IEntry>;
declare function use_old_InterfaceDeclaration_IEntry(
    use: TypeOnly<old.IEntry>): void;
use_old_InterfaceDeclaration_IEntry(
    get_current_InterfaceDeclaration_IEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFileEntry": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFileEntry():
    TypeOnly<old.IFileEntry>;
declare function use_current_InterfaceDeclaration_IFileEntry(
    use: TypeOnly<current.IFileEntry>): void;
use_current_InterfaceDeclaration_IFileEntry(
    get_old_InterfaceDeclaration_IFileEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFileEntry": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFileEntry():
    TypeOnly<current.IFileEntry>;
declare function use_old_InterfaceDeclaration_IFileEntry(
    use: TypeOnly<old.IFileEntry>): void;
use_old_InterfaceDeclaration_IFileEntry(
    get_current_InterfaceDeclaration_IFileEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOdspError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOdspError():
    TypeOnly<old.IOdspError>;
declare function use_current_InterfaceDeclaration_IOdspError(
    use: TypeOnly<current.IOdspError>): void;
use_current_InterfaceDeclaration_IOdspError(
    get_old_InterfaceDeclaration_IOdspError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOdspError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOdspError():
    TypeOnly<current.IOdspError>;
declare function use_old_InterfaceDeclaration_IOdspError(
    use: TypeOnly<old.IOdspError>): void;
use_old_InterfaceDeclaration_IOdspError(
    get_current_InterfaceDeclaration_IOdspError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOdspErrorAugmentations": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOdspErrorAugmentations():
    TypeOnly<old.IOdspErrorAugmentations>;
declare function use_current_InterfaceDeclaration_IOdspErrorAugmentations(
    use: TypeOnly<current.IOdspErrorAugmentations>): void;
use_current_InterfaceDeclaration_IOdspErrorAugmentations(
    get_old_InterfaceDeclaration_IOdspErrorAugmentations());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOdspErrorAugmentations": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOdspErrorAugmentations():
    TypeOnly<current.IOdspErrorAugmentations>;
declare function use_old_InterfaceDeclaration_IOdspErrorAugmentations(
    use: TypeOnly<old.IOdspErrorAugmentations>): void;
use_old_InterfaceDeclaration_IOdspErrorAugmentations(
    get_current_InterfaceDeclaration_IOdspErrorAugmentations());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOdspResolvedUrl": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOdspResolvedUrl():
    TypeOnly<old.IOdspResolvedUrl>;
declare function use_current_InterfaceDeclaration_IOdspResolvedUrl(
    use: TypeOnly<current.IOdspResolvedUrl>): void;
use_current_InterfaceDeclaration_IOdspResolvedUrl(
    get_old_InterfaceDeclaration_IOdspResolvedUrl());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOdspResolvedUrl": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOdspResolvedUrl():
    TypeOnly<current.IOdspResolvedUrl>;
declare function use_old_InterfaceDeclaration_IOdspResolvedUrl(
    use: TypeOnly<old.IOdspResolvedUrl>): void;
use_old_InterfaceDeclaration_IOdspResolvedUrl(
    get_current_InterfaceDeclaration_IOdspResolvedUrl());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOdspUrlParts": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOdspUrlParts():
    TypeOnly<old.IOdspUrlParts>;
declare function use_current_InterfaceDeclaration_IOdspUrlParts(
    use: TypeOnly<current.IOdspUrlParts>): void;
use_current_InterfaceDeclaration_IOdspUrlParts(
    get_old_InterfaceDeclaration_IOdspUrlParts());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOdspUrlParts": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOdspUrlParts():
    TypeOnly<current.IOdspUrlParts>;
declare function use_old_InterfaceDeclaration_IOdspUrlParts(
    use: TypeOnly<old.IOdspUrlParts>): void;
use_old_InterfaceDeclaration_IOdspUrlParts(
    get_current_InterfaceDeclaration_IOdspUrlParts());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOpsCachingPolicy": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOpsCachingPolicy():
    TypeOnly<old.IOpsCachingPolicy>;
declare function use_current_InterfaceDeclaration_IOpsCachingPolicy(
    use: TypeOnly<current.IOpsCachingPolicy>): void;
use_current_InterfaceDeclaration_IOpsCachingPolicy(
    get_old_InterfaceDeclaration_IOpsCachingPolicy());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOpsCachingPolicy": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOpsCachingPolicy():
    TypeOnly<current.IOpsCachingPolicy>;
declare function use_old_InterfaceDeclaration_IOpsCachingPolicy(
    use: TypeOnly<old.IOpsCachingPolicy>): void;
use_old_InterfaceDeclaration_IOpsCachingPolicy(
    get_current_InterfaceDeclaration_IOpsCachingPolicy());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPersistedCache": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPersistedCache():
    TypeOnly<old.IPersistedCache>;
declare function use_current_InterfaceDeclaration_IPersistedCache(
    use: TypeOnly<current.IPersistedCache>): void;
use_current_InterfaceDeclaration_IPersistedCache(
    get_old_InterfaceDeclaration_IPersistedCache());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPersistedCache": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPersistedCache():
    TypeOnly<current.IPersistedCache>;
declare function use_old_InterfaceDeclaration_IPersistedCache(
    use: TypeOnly<old.IPersistedCache>): void;
use_old_InterfaceDeclaration_IPersistedCache(
    get_current_InterfaceDeclaration_IPersistedCache());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideSessionAwareDriverFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideSessionAwareDriverFactory():
    TypeOnly<old.IProvideSessionAwareDriverFactory>;
declare function use_current_InterfaceDeclaration_IProvideSessionAwareDriverFactory(
    use: TypeOnly<current.IProvideSessionAwareDriverFactory>): void;
use_current_InterfaceDeclaration_IProvideSessionAwareDriverFactory(
    get_old_InterfaceDeclaration_IProvideSessionAwareDriverFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideSessionAwareDriverFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideSessionAwareDriverFactory():
    TypeOnly<current.IProvideSessionAwareDriverFactory>;
declare function use_old_InterfaceDeclaration_IProvideSessionAwareDriverFactory(
    use: TypeOnly<old.IProvideSessionAwareDriverFactory>): void;
use_old_InterfaceDeclaration_IProvideSessionAwareDriverFactory(
    get_current_InterfaceDeclaration_IProvideSessionAwareDriverFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRelaySessionAwareDriverFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRelaySessionAwareDriverFactory():
    TypeOnly<old.IRelaySessionAwareDriverFactory>;
declare function use_current_InterfaceDeclaration_IRelaySessionAwareDriverFactory(
    use: TypeOnly<current.IRelaySessionAwareDriverFactory>): void;
use_current_InterfaceDeclaration_IRelaySessionAwareDriverFactory(
    get_old_InterfaceDeclaration_IRelaySessionAwareDriverFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRelaySessionAwareDriverFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRelaySessionAwareDriverFactory():
    TypeOnly<current.IRelaySessionAwareDriverFactory>;
declare function use_old_InterfaceDeclaration_IRelaySessionAwareDriverFactory(
    use: TypeOnly<old.IRelaySessionAwareDriverFactory>): void;
use_old_InterfaceDeclaration_IRelaySessionAwareDriverFactory(
    get_current_InterfaceDeclaration_IRelaySessionAwareDriverFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharingLink": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISharingLink():
    TypeOnly<old.ISharingLink>;
declare function use_current_InterfaceDeclaration_ISharingLink(
    use: TypeOnly<current.ISharingLink>): void;
use_current_InterfaceDeclaration_ISharingLink(
    get_old_InterfaceDeclaration_ISharingLink());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharingLink": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISharingLink():
    TypeOnly<current.ISharingLink>;
declare function use_old_InterfaceDeclaration_ISharingLink(
    use: TypeOnly<old.ISharingLink>): void;
use_old_InterfaceDeclaration_ISharingLink(
    get_current_InterfaceDeclaration_ISharingLink());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharingLinkKind": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISharingLinkKind():
    TypeOnly<old.ISharingLinkKind>;
declare function use_current_InterfaceDeclaration_ISharingLinkKind(
    use: TypeOnly<current.ISharingLinkKind>): void;
use_current_InterfaceDeclaration_ISharingLinkKind(
    get_old_InterfaceDeclaration_ISharingLinkKind());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharingLinkKind": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISharingLinkKind():
    TypeOnly<current.ISharingLinkKind>;
declare function use_old_InterfaceDeclaration_ISharingLinkKind(
    use: TypeOnly<old.ISharingLinkKind>): void;
use_old_InterfaceDeclaration_ISharingLinkKind(
    get_current_InterfaceDeclaration_ISharingLinkKind());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISnapshotOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISnapshotOptions():
    TypeOnly<old.ISnapshotOptions>;
declare function use_current_InterfaceDeclaration_ISnapshotOptions(
    use: TypeOnly<current.ISnapshotOptions>): void;
use_current_InterfaceDeclaration_ISnapshotOptions(
    get_old_InterfaceDeclaration_ISnapshotOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISnapshotOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISnapshotOptions():
    TypeOnly<current.ISnapshotOptions>;
declare function use_old_InterfaceDeclaration_ISnapshotOptions(
    use: TypeOnly<old.ISnapshotOptions>): void;
use_old_InterfaceDeclaration_ISnapshotOptions(
    get_current_InterfaceDeclaration_ISnapshotOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISocketStorageDiscovery": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISocketStorageDiscovery():
    TypeOnly<old.ISocketStorageDiscovery>;
declare function use_current_InterfaceDeclaration_ISocketStorageDiscovery(
    use: TypeOnly<current.ISocketStorageDiscovery>): void;
use_current_InterfaceDeclaration_ISocketStorageDiscovery(
    get_old_InterfaceDeclaration_ISocketStorageDiscovery());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISocketStorageDiscovery": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISocketStorageDiscovery():
    TypeOnly<current.ISocketStorageDiscovery>;
declare function use_old_InterfaceDeclaration_ISocketStorageDiscovery(
    use: TypeOnly<old.ISocketStorageDiscovery>): void;
use_old_InterfaceDeclaration_ISocketStorageDiscovery(
    get_current_InterfaceDeclaration_ISocketStorageDiscovery());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IdentityType": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IdentityType():
    TypeOnly<old.IdentityType>;
declare function use_current_TypeAliasDeclaration_IdentityType(
    use: TypeOnly<current.IdentityType>): void;
use_current_TypeAliasDeclaration_IdentityType(
    get_old_TypeAliasDeclaration_IdentityType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IdentityType": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IdentityType():
    TypeOnly<current.IdentityType>;
declare function use_old_TypeAliasDeclaration_IdentityType(
    use: TypeOnly<old.IdentityType>): void;
use_old_TypeAliasDeclaration_IdentityType(
    get_current_TypeAliasDeclaration_IdentityType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_InstrumentedStorageTokenFetcher": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_InstrumentedStorageTokenFetcher():
    TypeOnly<old.InstrumentedStorageTokenFetcher>;
declare function use_current_TypeAliasDeclaration_InstrumentedStorageTokenFetcher(
    use: TypeOnly<current.InstrumentedStorageTokenFetcher>): void;
use_current_TypeAliasDeclaration_InstrumentedStorageTokenFetcher(
    get_old_TypeAliasDeclaration_InstrumentedStorageTokenFetcher());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_InstrumentedStorageTokenFetcher": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_InstrumentedStorageTokenFetcher():
    TypeOnly<current.InstrumentedStorageTokenFetcher>;
declare function use_old_TypeAliasDeclaration_InstrumentedStorageTokenFetcher(
    use: TypeOnly<old.InstrumentedStorageTokenFetcher>): void;
use_old_TypeAliasDeclaration_InstrumentedStorageTokenFetcher(
    get_current_TypeAliasDeclaration_InstrumentedStorageTokenFetcher());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OdspError": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_OdspError():
    TypeOnly<old.OdspError>;
declare function use_current_TypeAliasDeclaration_OdspError(
    use: TypeOnly<current.OdspError>): void;
use_current_TypeAliasDeclaration_OdspError(
    get_old_TypeAliasDeclaration_OdspError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OdspError": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_OdspError():
    TypeOnly<current.OdspError>;
declare function use_old_TypeAliasDeclaration_OdspError(
    use: TypeOnly<old.OdspError>): void;
use_old_TypeAliasDeclaration_OdspError(
    get_current_TypeAliasDeclaration_OdspError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedEnumDeclaration_OdspErrorType": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedEnumDeclaration_OdspErrorType": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_OdspErrorTypes": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_OdspErrorTypes():
    TypeOnly<typeof old.OdspErrorTypes>;
declare function use_current_VariableDeclaration_OdspErrorTypes(
    use: TypeOnly<typeof current.OdspErrorTypes>): void;
use_current_VariableDeclaration_OdspErrorTypes(
    get_old_VariableDeclaration_OdspErrorTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_OdspErrorTypes": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_OdspErrorTypes():
    TypeOnly<typeof current.OdspErrorTypes>;
declare function use_old_VariableDeclaration_OdspErrorTypes(
    use: TypeOnly<typeof old.OdspErrorTypes>): void;
use_old_VariableDeclaration_OdspErrorTypes(
    get_current_VariableDeclaration_OdspErrorTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OdspErrorTypes": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_OdspErrorTypes():
    TypeOnly<old.OdspErrorTypes>;
declare function use_current_TypeAliasDeclaration_OdspErrorTypes(
    use: TypeOnly<current.OdspErrorTypes>): void;
use_current_TypeAliasDeclaration_OdspErrorTypes(
    get_old_TypeAliasDeclaration_OdspErrorTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OdspErrorTypes": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_OdspErrorTypes():
    TypeOnly<current.OdspErrorTypes>;
declare function use_old_TypeAliasDeclaration_OdspErrorTypes(
    use: TypeOnly<old.OdspErrorTypes>): void;
use_old_TypeAliasDeclaration_OdspErrorTypes(
    get_current_TypeAliasDeclaration_OdspErrorTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_OdspResourceTokenFetchOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_OdspResourceTokenFetchOptions():
    TypeOnly<old.OdspResourceTokenFetchOptions>;
declare function use_current_InterfaceDeclaration_OdspResourceTokenFetchOptions(
    use: TypeOnly<current.OdspResourceTokenFetchOptions>): void;
use_current_InterfaceDeclaration_OdspResourceTokenFetchOptions(
    get_old_InterfaceDeclaration_OdspResourceTokenFetchOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_OdspResourceTokenFetchOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_OdspResourceTokenFetchOptions():
    TypeOnly<current.OdspResourceTokenFetchOptions>;
declare function use_old_InterfaceDeclaration_OdspResourceTokenFetchOptions(
    use: TypeOnly<old.OdspResourceTokenFetchOptions>): void;
use_old_InterfaceDeclaration_OdspResourceTokenFetchOptions(
    get_current_InterfaceDeclaration_OdspResourceTokenFetchOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ShareLinkInfoType": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ShareLinkInfoType():
    TypeOnly<old.ShareLinkInfoType>;
declare function use_current_InterfaceDeclaration_ShareLinkInfoType(
    use: TypeOnly<current.ShareLinkInfoType>): void;
use_current_InterfaceDeclaration_ShareLinkInfoType(
    get_old_InterfaceDeclaration_ShareLinkInfoType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ShareLinkInfoType": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ShareLinkInfoType():
    TypeOnly<current.ShareLinkInfoType>;
declare function use_old_InterfaceDeclaration_ShareLinkInfoType(
    use: TypeOnly<old.ShareLinkInfoType>): void;
use_old_InterfaceDeclaration_ShareLinkInfoType(
    get_current_InterfaceDeclaration_ShareLinkInfoType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedEnumDeclaration_ShareLinkTypes": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedEnumDeclaration_ShareLinkTypes": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_SharingLinkRole": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_SharingLinkRole():
    TypeOnly<old.SharingLinkRole>;
declare function use_current_EnumDeclaration_SharingLinkRole(
    use: TypeOnly<current.SharingLinkRole>): void;
use_current_EnumDeclaration_SharingLinkRole(
    get_old_EnumDeclaration_SharingLinkRole());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_SharingLinkRole": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_SharingLinkRole():
    TypeOnly<current.SharingLinkRole>;
declare function use_old_EnumDeclaration_SharingLinkRole(
    use: TypeOnly<old.SharingLinkRole>): void;
use_old_EnumDeclaration_SharingLinkRole(
    get_current_EnumDeclaration_SharingLinkRole());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_SharingLinkScope": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_SharingLinkScope():
    TypeOnly<old.SharingLinkScope>;
declare function use_current_EnumDeclaration_SharingLinkScope(
    use: TypeOnly<current.SharingLinkScope>): void;
use_current_EnumDeclaration_SharingLinkScope(
    get_old_EnumDeclaration_SharingLinkScope());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_SharingLinkScope": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_SharingLinkScope():
    TypeOnly<current.SharingLinkScope>;
declare function use_old_EnumDeclaration_SharingLinkScope(
    use: TypeOnly<old.SharingLinkScope>): void;
use_old_EnumDeclaration_SharingLinkScope(
    get_current_EnumDeclaration_SharingLinkScope());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TokenFetchOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_TokenFetchOptions():
    TypeOnly<old.TokenFetchOptions>;
declare function use_current_InterfaceDeclaration_TokenFetchOptions(
    use: TypeOnly<current.TokenFetchOptions>): void;
use_current_InterfaceDeclaration_TokenFetchOptions(
    get_old_InterfaceDeclaration_TokenFetchOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TokenFetchOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_TokenFetchOptions():
    TypeOnly<current.TokenFetchOptions>;
declare function use_old_InterfaceDeclaration_TokenFetchOptions(
    use: TypeOnly<old.TokenFetchOptions>): void;
use_old_InterfaceDeclaration_TokenFetchOptions(
    get_current_InterfaceDeclaration_TokenFetchOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TokenFetcher": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TokenFetcher():
    TypeOnly<old.TokenFetcher<any>>;
declare function use_current_TypeAliasDeclaration_TokenFetcher(
    use: TypeOnly<current.TokenFetcher<any>>): void;
use_current_TypeAliasDeclaration_TokenFetcher(
    get_old_TypeAliasDeclaration_TokenFetcher());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TokenFetcher": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TokenFetcher():
    TypeOnly<current.TokenFetcher<any>>;
declare function use_old_TypeAliasDeclaration_TokenFetcher(
    use: TypeOnly<old.TokenFetcher<any>>): void;
use_old_TypeAliasDeclaration_TokenFetcher(
    get_current_TypeAliasDeclaration_TokenFetcher());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TokenResponse": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_TokenResponse():
    TypeOnly<old.TokenResponse>;
declare function use_current_InterfaceDeclaration_TokenResponse(
    use: TypeOnly<current.TokenResponse>): void;
use_current_InterfaceDeclaration_TokenResponse(
    get_old_InterfaceDeclaration_TokenResponse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TokenResponse": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_TokenResponse():
    TypeOnly<current.TokenResponse>;
declare function use_old_InterfaceDeclaration_TokenResponse(
    use: TypeOnly<old.TokenResponse>): void;
use_old_InterfaceDeclaration_TokenResponse(
    get_current_InterfaceDeclaration_TokenResponse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getKeyForCacheEntry": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getKeyForCacheEntry():
    TypeOnly<typeof old.getKeyForCacheEntry>;
declare function use_current_FunctionDeclaration_getKeyForCacheEntry(
    use: TypeOnly<typeof current.getKeyForCacheEntry>): void;
use_current_FunctionDeclaration_getKeyForCacheEntry(
    get_old_FunctionDeclaration_getKeyForCacheEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getKeyForCacheEntry": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getKeyForCacheEntry():
    TypeOnly<typeof current.getKeyForCacheEntry>;
declare function use_old_FunctionDeclaration_getKeyForCacheEntry(
    use: TypeOnly<typeof old.getKeyForCacheEntry>): void;
use_old_FunctionDeclaration_getKeyForCacheEntry(
    get_current_FunctionDeclaration_getKeyForCacheEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isTokenFromCache": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isTokenFromCache():
    TypeOnly<typeof old.isTokenFromCache>;
declare function use_current_VariableDeclaration_isTokenFromCache(
    use: TypeOnly<typeof current.isTokenFromCache>): void;
use_current_VariableDeclaration_isTokenFromCache(
    get_old_VariableDeclaration_isTokenFromCache());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isTokenFromCache": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isTokenFromCache():
    TypeOnly<typeof current.isTokenFromCache>;
declare function use_old_VariableDeclaration_isTokenFromCache(
    use: TypeOnly<typeof old.isTokenFromCache>): void;
use_old_VariableDeclaration_isTokenFromCache(
    get_current_VariableDeclaration_isTokenFromCache());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_snapshotKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_snapshotKey():
    TypeOnly<typeof old.snapshotKey>;
declare function use_current_VariableDeclaration_snapshotKey(
    use: TypeOnly<typeof current.snapshotKey>): void;
use_current_VariableDeclaration_snapshotKey(
    get_old_VariableDeclaration_snapshotKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_snapshotKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_snapshotKey():
    TypeOnly<typeof current.snapshotKey>;
declare function use_old_VariableDeclaration_snapshotKey(
    use: TypeOnly<typeof old.snapshotKey>): void;
use_old_VariableDeclaration_snapshotKey(
    get_current_VariableDeclaration_snapshotKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_tokenFromResponse": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_tokenFromResponse():
    TypeOnly<typeof old.tokenFromResponse>;
declare function use_current_VariableDeclaration_tokenFromResponse(
    use: TypeOnly<typeof current.tokenFromResponse>): void;
use_current_VariableDeclaration_tokenFromResponse(
    get_old_VariableDeclaration_tokenFromResponse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_tokenFromResponse": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_tokenFromResponse():
    TypeOnly<typeof current.tokenFromResponse>;
declare function use_old_VariableDeclaration_tokenFromResponse(
    use: TypeOnly<typeof old.tokenFromResponse>): void;
use_old_VariableDeclaration_tokenFromResponse(
    get_current_VariableDeclaration_tokenFromResponse());
