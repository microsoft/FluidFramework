/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/odsp-driver-definitions-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_CacheContentType": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_CacheContentType():
    TypeOnly<old.CacheContentType>;
declare function use_current_TypeAliasDeclaration_CacheContentType(
    use: TypeOnly<current.CacheContentType>): void;
use_current_TypeAliasDeclaration_CacheContentType(
    get_old_TypeAliasDeclaration_CacheContentType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_CacheContentType": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_CacheContentType():
    TypeOnly<current.CacheContentType>;
declare function use_old_TypeAliasDeclaration_CacheContentType(
    use: TypeOnly<old.CacheContentType>): void;
use_old_TypeAliasDeclaration_CacheContentType(
    get_current_TypeAliasDeclaration_CacheContentType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_HostStoragePolicy": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_HostStoragePolicy():
    TypeOnly<old.HostStoragePolicy>;
declare function use_current_InterfaceDeclaration_HostStoragePolicy(
    use: TypeOnly<current.HostStoragePolicy>): void;
use_current_InterfaceDeclaration_HostStoragePolicy(
    get_old_InterfaceDeclaration_HostStoragePolicy());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_HostStoragePolicy": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_HostStoragePolicy():
    TypeOnly<current.HostStoragePolicy>;
declare function use_old_InterfaceDeclaration_HostStoragePolicy(
    use: TypeOnly<old.HostStoragePolicy>): void;
use_old_InterfaceDeclaration_HostStoragePolicy(
    get_current_InterfaceDeclaration_HostStoragePolicy());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICacheEntry": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ICacheEntry():
    TypeOnly<old.ICacheEntry>;
declare function use_current_InterfaceDeclaration_ICacheEntry(
    use: TypeOnly<current.ICacheEntry>): void;
use_current_InterfaceDeclaration_ICacheEntry(
    get_old_InterfaceDeclaration_ICacheEntry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICacheEntry": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ICacheEntry():
    TypeOnly<current.ICacheEntry>;
declare function use_old_InterfaceDeclaration_ICacheEntry(
    use: TypeOnly<old.ICacheEntry>): void;
use_old_InterfaceDeclaration_ICacheEntry(
    get_current_InterfaceDeclaration_ICacheEntry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICollabSessionOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ICollabSessionOptions():
    TypeOnly<old.ICollabSessionOptions>;
declare function use_current_InterfaceDeclaration_ICollabSessionOptions(
    use: TypeOnly<current.ICollabSessionOptions>): void;
use_current_InterfaceDeclaration_ICollabSessionOptions(
    get_old_InterfaceDeclaration_ICollabSessionOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICollabSessionOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ICollabSessionOptions():
    TypeOnly<current.ICollabSessionOptions>;
declare function use_old_InterfaceDeclaration_ICollabSessionOptions(
    use: TypeOnly<old.ICollabSessionOptions>): void;
use_old_InterfaceDeclaration_ICollabSessionOptions(
    get_current_InterfaceDeclaration_ICollabSessionOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEntry": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IEntry():
    TypeOnly<old.IEntry>;
declare function use_current_InterfaceDeclaration_IEntry(
    use: TypeOnly<current.IEntry>): void;
use_current_InterfaceDeclaration_IEntry(
    get_old_InterfaceDeclaration_IEntry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEntry": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IEntry():
    TypeOnly<current.IEntry>;
declare function use_old_InterfaceDeclaration_IEntry(
    use: TypeOnly<old.IEntry>): void;
use_old_InterfaceDeclaration_IEntry(
    get_current_InterfaceDeclaration_IEntry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFileEntry": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFileEntry():
    TypeOnly<old.IFileEntry>;
declare function use_current_InterfaceDeclaration_IFileEntry(
    use: TypeOnly<current.IFileEntry>): void;
use_current_InterfaceDeclaration_IFileEntry(
    get_old_InterfaceDeclaration_IFileEntry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFileEntry": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFileEntry():
    TypeOnly<current.IFileEntry>;
declare function use_old_InterfaceDeclaration_IFileEntry(
    use: TypeOnly<old.IFileEntry>): void;
use_old_InterfaceDeclaration_IFileEntry(
    get_current_InterfaceDeclaration_IFileEntry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOdspError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IOdspError():
    TypeOnly<old.IOdspError>;
declare function use_current_InterfaceDeclaration_IOdspError(
    use: TypeOnly<current.IOdspError>): void;
use_current_InterfaceDeclaration_IOdspError(
    get_old_InterfaceDeclaration_IOdspError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOdspError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IOdspError():
    TypeOnly<current.IOdspError>;
declare function use_old_InterfaceDeclaration_IOdspError(
    use: TypeOnly<old.IOdspError>): void;
use_old_InterfaceDeclaration_IOdspError(
    get_current_InterfaceDeclaration_IOdspError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOdspErrorAugmentations": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IOdspErrorAugmentations():
    TypeOnly<old.IOdspErrorAugmentations>;
declare function use_current_InterfaceDeclaration_IOdspErrorAugmentations(
    use: TypeOnly<current.IOdspErrorAugmentations>): void;
use_current_InterfaceDeclaration_IOdspErrorAugmentations(
    get_old_InterfaceDeclaration_IOdspErrorAugmentations());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOdspErrorAugmentations": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IOdspErrorAugmentations():
    TypeOnly<current.IOdspErrorAugmentations>;
declare function use_old_InterfaceDeclaration_IOdspErrorAugmentations(
    use: TypeOnly<old.IOdspErrorAugmentations>): void;
use_old_InterfaceDeclaration_IOdspErrorAugmentations(
    get_current_InterfaceDeclaration_IOdspErrorAugmentations());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOdspResolvedUrl": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IOdspResolvedUrl():
    TypeOnly<old.IOdspResolvedUrl>;
declare function use_current_InterfaceDeclaration_IOdspResolvedUrl(
    use: TypeOnly<current.IOdspResolvedUrl>): void;
use_current_InterfaceDeclaration_IOdspResolvedUrl(
    get_old_InterfaceDeclaration_IOdspResolvedUrl());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOdspResolvedUrl": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IOdspResolvedUrl():
    TypeOnly<current.IOdspResolvedUrl>;
declare function use_old_InterfaceDeclaration_IOdspResolvedUrl(
    use: TypeOnly<old.IOdspResolvedUrl>): void;
use_old_InterfaceDeclaration_IOdspResolvedUrl(
    get_current_InterfaceDeclaration_IOdspResolvedUrl());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOdspUrlParts": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IOdspUrlParts():
    TypeOnly<old.IOdspUrlParts>;
declare function use_current_InterfaceDeclaration_IOdspUrlParts(
    use: TypeOnly<current.IOdspUrlParts>): void;
use_current_InterfaceDeclaration_IOdspUrlParts(
    get_old_InterfaceDeclaration_IOdspUrlParts());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOdspUrlParts": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IOdspUrlParts():
    TypeOnly<current.IOdspUrlParts>;
declare function use_old_InterfaceDeclaration_IOdspUrlParts(
    use: TypeOnly<old.IOdspUrlParts>): void;
use_old_InterfaceDeclaration_IOdspUrlParts(
    get_current_InterfaceDeclaration_IOdspUrlParts());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOpsCachingPolicy": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IOpsCachingPolicy():
    TypeOnly<old.IOpsCachingPolicy>;
declare function use_current_InterfaceDeclaration_IOpsCachingPolicy(
    use: TypeOnly<current.IOpsCachingPolicy>): void;
use_current_InterfaceDeclaration_IOpsCachingPolicy(
    get_old_InterfaceDeclaration_IOpsCachingPolicy());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOpsCachingPolicy": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IOpsCachingPolicy():
    TypeOnly<current.IOpsCachingPolicy>;
declare function use_old_InterfaceDeclaration_IOpsCachingPolicy(
    use: TypeOnly<old.IOpsCachingPolicy>): void;
use_old_InterfaceDeclaration_IOpsCachingPolicy(
    get_current_InterfaceDeclaration_IOpsCachingPolicy());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IPersistedCache": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IPersistedCache():
    TypeOnly<old.IPersistedCache>;
declare function use_current_InterfaceDeclaration_IPersistedCache(
    use: TypeOnly<current.IPersistedCache>): void;
use_current_InterfaceDeclaration_IPersistedCache(
    get_old_InterfaceDeclaration_IPersistedCache());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IPersistedCache": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IPersistedCache():
    TypeOnly<current.IPersistedCache>;
declare function use_old_InterfaceDeclaration_IPersistedCache(
    use: TypeOnly<old.IPersistedCache>): void;
use_old_InterfaceDeclaration_IPersistedCache(
    get_current_InterfaceDeclaration_IPersistedCache());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideSessionAwareDriverFactory": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProvideSessionAwareDriverFactory():
    TypeOnly<old.IProvideSessionAwareDriverFactory>;
declare function use_current_InterfaceDeclaration_IProvideSessionAwareDriverFactory(
    use: TypeOnly<current.IProvideSessionAwareDriverFactory>): void;
use_current_InterfaceDeclaration_IProvideSessionAwareDriverFactory(
    get_old_InterfaceDeclaration_IProvideSessionAwareDriverFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideSessionAwareDriverFactory": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProvideSessionAwareDriverFactory():
    TypeOnly<current.IProvideSessionAwareDriverFactory>;
declare function use_old_InterfaceDeclaration_IProvideSessionAwareDriverFactory(
    use: TypeOnly<old.IProvideSessionAwareDriverFactory>): void;
use_old_InterfaceDeclaration_IProvideSessionAwareDriverFactory(
    get_current_InterfaceDeclaration_IProvideSessionAwareDriverFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRelaySessionAwareDriverFactory": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IRelaySessionAwareDriverFactory():
    TypeOnly<old.IRelaySessionAwareDriverFactory>;
declare function use_current_InterfaceDeclaration_IRelaySessionAwareDriverFactory(
    use: TypeOnly<current.IRelaySessionAwareDriverFactory>): void;
use_current_InterfaceDeclaration_IRelaySessionAwareDriverFactory(
    get_old_InterfaceDeclaration_IRelaySessionAwareDriverFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRelaySessionAwareDriverFactory": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IRelaySessionAwareDriverFactory():
    TypeOnly<current.IRelaySessionAwareDriverFactory>;
declare function use_old_InterfaceDeclaration_IRelaySessionAwareDriverFactory(
    use: TypeOnly<old.IRelaySessionAwareDriverFactory>): void;
use_old_InterfaceDeclaration_IRelaySessionAwareDriverFactory(
    get_current_InterfaceDeclaration_IRelaySessionAwareDriverFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharingLink": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISharingLink():
    TypeOnly<old.ISharingLink>;
declare function use_current_InterfaceDeclaration_ISharingLink(
    use: TypeOnly<current.ISharingLink>): void;
use_current_InterfaceDeclaration_ISharingLink(
    get_old_InterfaceDeclaration_ISharingLink());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharingLink": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISharingLink():
    TypeOnly<current.ISharingLink>;
declare function use_old_InterfaceDeclaration_ISharingLink(
    use: TypeOnly<old.ISharingLink>): void;
use_old_InterfaceDeclaration_ISharingLink(
    get_current_InterfaceDeclaration_ISharingLink());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharingLinkKind": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISharingLinkKind():
    TypeOnly<old.ISharingLinkKind>;
declare function use_current_InterfaceDeclaration_ISharingLinkKind(
    use: TypeOnly<current.ISharingLinkKind>): void;
use_current_InterfaceDeclaration_ISharingLinkKind(
    get_old_InterfaceDeclaration_ISharingLinkKind());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharingLinkKind": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISharingLinkKind():
    TypeOnly<current.ISharingLinkKind>;
declare function use_old_InterfaceDeclaration_ISharingLinkKind(
    use: TypeOnly<old.ISharingLinkKind>): void;
use_old_InterfaceDeclaration_ISharingLinkKind(
    get_current_InterfaceDeclaration_ISharingLinkKind());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISnapshotOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISnapshotOptions():
    TypeOnly<old.ISnapshotOptions>;
declare function use_current_InterfaceDeclaration_ISnapshotOptions(
    use: TypeOnly<current.ISnapshotOptions>): void;
use_current_InterfaceDeclaration_ISnapshotOptions(
    get_old_InterfaceDeclaration_ISnapshotOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISnapshotOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISnapshotOptions():
    TypeOnly<current.ISnapshotOptions>;
declare function use_old_InterfaceDeclaration_ISnapshotOptions(
    use: TypeOnly<old.ISnapshotOptions>): void;
use_old_InterfaceDeclaration_ISnapshotOptions(
    get_current_InterfaceDeclaration_ISnapshotOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISocketStorageDiscovery": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISocketStorageDiscovery():
    TypeOnly<old.ISocketStorageDiscovery>;
declare function use_current_InterfaceDeclaration_ISocketStorageDiscovery(
    use: TypeOnly<current.ISocketStorageDiscovery>): void;
use_current_InterfaceDeclaration_ISocketStorageDiscovery(
    get_old_InterfaceDeclaration_ISocketStorageDiscovery());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISocketStorageDiscovery": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISocketStorageDiscovery():
    TypeOnly<current.ISocketStorageDiscovery>;
declare function use_old_InterfaceDeclaration_ISocketStorageDiscovery(
    use: TypeOnly<old.ISocketStorageDiscovery>): void;
use_old_InterfaceDeclaration_ISocketStorageDiscovery(
    get_current_InterfaceDeclaration_ISocketStorageDiscovery());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IdentityType": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IdentityType():
    TypeOnly<old.IdentityType>;
declare function use_current_TypeAliasDeclaration_IdentityType(
    use: TypeOnly<current.IdentityType>): void;
use_current_TypeAliasDeclaration_IdentityType(
    get_old_TypeAliasDeclaration_IdentityType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IdentityType": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IdentityType():
    TypeOnly<current.IdentityType>;
declare function use_old_TypeAliasDeclaration_IdentityType(
    use: TypeOnly<old.IdentityType>): void;
use_old_TypeAliasDeclaration_IdentityType(
    get_current_TypeAliasDeclaration_IdentityType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_InstrumentedStorageTokenFetcher": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_InstrumentedStorageTokenFetcher():
    TypeOnly<old.InstrumentedStorageTokenFetcher>;
declare function use_current_TypeAliasDeclaration_InstrumentedStorageTokenFetcher(
    use: TypeOnly<current.InstrumentedStorageTokenFetcher>): void;
use_current_TypeAliasDeclaration_InstrumentedStorageTokenFetcher(
    get_old_TypeAliasDeclaration_InstrumentedStorageTokenFetcher());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_InstrumentedStorageTokenFetcher": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_InstrumentedStorageTokenFetcher():
    TypeOnly<current.InstrumentedStorageTokenFetcher>;
declare function use_old_TypeAliasDeclaration_InstrumentedStorageTokenFetcher(
    use: TypeOnly<old.InstrumentedStorageTokenFetcher>): void;
use_old_TypeAliasDeclaration_InstrumentedStorageTokenFetcher(
    get_current_TypeAliasDeclaration_InstrumentedStorageTokenFetcher());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_InstrumentedTokenFetcher": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_InstrumentedTokenFetcher():
    TypeOnly<old.InstrumentedTokenFetcher>;
declare function use_current_TypeAliasDeclaration_InstrumentedTokenFetcher(
    use: TypeOnly<current.InstrumentedTokenFetcher>): void;
use_current_TypeAliasDeclaration_InstrumentedTokenFetcher(
    get_old_TypeAliasDeclaration_InstrumentedTokenFetcher());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_InstrumentedTokenFetcher": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_InstrumentedTokenFetcher():
    TypeOnly<current.InstrumentedTokenFetcher>;
declare function use_old_TypeAliasDeclaration_InstrumentedTokenFetcher(
    use: TypeOnly<old.InstrumentedTokenFetcher>): void;
use_old_TypeAliasDeclaration_InstrumentedTokenFetcher(
    get_current_TypeAliasDeclaration_InstrumentedTokenFetcher());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_OdspError": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_OdspError():
    TypeOnly<old.OdspError>;
declare function use_current_TypeAliasDeclaration_OdspError(
    use: TypeOnly<current.OdspError>): void;
use_current_TypeAliasDeclaration_OdspError(
    get_old_TypeAliasDeclaration_OdspError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_OdspError": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_OdspError():
    TypeOnly<current.OdspError>;
declare function use_old_TypeAliasDeclaration_OdspError(
    use: TypeOnly<old.OdspError>): void;
use_old_TypeAliasDeclaration_OdspError(
    get_current_TypeAliasDeclaration_OdspError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_OdspErrorTypes": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_OdspErrorTypes():
    TypeOnly<typeof old.OdspErrorTypes>;
declare function use_current_VariableDeclaration_OdspErrorTypes(
    use: TypeOnly<typeof current.OdspErrorTypes>): void;
use_current_VariableDeclaration_OdspErrorTypes(
    get_old_VariableDeclaration_OdspErrorTypes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_OdspErrorTypes": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_OdspErrorTypes():
    TypeOnly<typeof current.OdspErrorTypes>;
declare function use_old_VariableDeclaration_OdspErrorTypes(
    use: TypeOnly<typeof old.OdspErrorTypes>): void;
use_old_VariableDeclaration_OdspErrorTypes(
    get_current_VariableDeclaration_OdspErrorTypes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_OdspErrorTypes": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_OdspErrorTypes():
    TypeOnly<old.OdspErrorTypes>;
declare function use_current_TypeAliasDeclaration_OdspErrorTypes(
    use: TypeOnly<current.OdspErrorTypes>): void;
use_current_TypeAliasDeclaration_OdspErrorTypes(
    get_old_TypeAliasDeclaration_OdspErrorTypes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_OdspErrorTypes": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_OdspErrorTypes():
    TypeOnly<current.OdspErrorTypes>;
declare function use_old_TypeAliasDeclaration_OdspErrorTypes(
    use: TypeOnly<old.OdspErrorTypes>): void;
use_old_TypeAliasDeclaration_OdspErrorTypes(
    get_current_TypeAliasDeclaration_OdspErrorTypes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_OdspResourceTokenFetchOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_OdspResourceTokenFetchOptions():
    TypeOnly<old.OdspResourceTokenFetchOptions>;
declare function use_current_InterfaceDeclaration_OdspResourceTokenFetchOptions(
    use: TypeOnly<current.OdspResourceTokenFetchOptions>): void;
use_current_InterfaceDeclaration_OdspResourceTokenFetchOptions(
    get_old_InterfaceDeclaration_OdspResourceTokenFetchOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_OdspResourceTokenFetchOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_OdspResourceTokenFetchOptions():
    TypeOnly<current.OdspResourceTokenFetchOptions>;
declare function use_old_InterfaceDeclaration_OdspResourceTokenFetchOptions(
    use: TypeOnly<old.OdspResourceTokenFetchOptions>): void;
use_old_InterfaceDeclaration_OdspResourceTokenFetchOptions(
    get_current_InterfaceDeclaration_OdspResourceTokenFetchOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ShareLinkInfoType": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ShareLinkInfoType():
    TypeOnly<old.ShareLinkInfoType>;
declare function use_current_InterfaceDeclaration_ShareLinkInfoType(
    use: TypeOnly<current.ShareLinkInfoType>): void;
use_current_InterfaceDeclaration_ShareLinkInfoType(
    get_old_InterfaceDeclaration_ShareLinkInfoType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ShareLinkInfoType": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ShareLinkInfoType():
    TypeOnly<current.ShareLinkInfoType>;
declare function use_old_InterfaceDeclaration_ShareLinkInfoType(
    use: TypeOnly<old.ShareLinkInfoType>): void;
use_old_InterfaceDeclaration_ShareLinkInfoType(
    get_current_InterfaceDeclaration_ShareLinkInfoType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_SharingLinkRole": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_SharingLinkRole():
    TypeOnly<old.SharingLinkRole>;
declare function use_current_EnumDeclaration_SharingLinkRole(
    use: TypeOnly<current.SharingLinkRole>): void;
use_current_EnumDeclaration_SharingLinkRole(
    get_old_EnumDeclaration_SharingLinkRole());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_SharingLinkRole": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_SharingLinkRole():
    TypeOnly<current.SharingLinkRole>;
declare function use_old_EnumDeclaration_SharingLinkRole(
    use: TypeOnly<old.SharingLinkRole>): void;
use_old_EnumDeclaration_SharingLinkRole(
    get_current_EnumDeclaration_SharingLinkRole());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_SharingLinkScope": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_SharingLinkScope():
    TypeOnly<old.SharingLinkScope>;
declare function use_current_EnumDeclaration_SharingLinkScope(
    use: TypeOnly<current.SharingLinkScope>): void;
use_current_EnumDeclaration_SharingLinkScope(
    get_old_EnumDeclaration_SharingLinkScope());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_SharingLinkScope": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_SharingLinkScope():
    TypeOnly<current.SharingLinkScope>;
declare function use_old_EnumDeclaration_SharingLinkScope(
    use: TypeOnly<old.SharingLinkScope>): void;
use_old_EnumDeclaration_SharingLinkScope(
    get_current_EnumDeclaration_SharingLinkScope());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_TokenFetchOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TokenFetchOptions():
    TypeOnly<old.TokenFetchOptions>;
declare function use_current_InterfaceDeclaration_TokenFetchOptions(
    use: TypeOnly<current.TokenFetchOptions>): void;
use_current_InterfaceDeclaration_TokenFetchOptions(
    get_old_InterfaceDeclaration_TokenFetchOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_TokenFetchOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TokenFetchOptions():
    TypeOnly<current.TokenFetchOptions>;
declare function use_old_InterfaceDeclaration_TokenFetchOptions(
    use: TypeOnly<old.TokenFetchOptions>): void;
use_old_InterfaceDeclaration_TokenFetchOptions(
    get_current_InterfaceDeclaration_TokenFetchOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TokenFetcher": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_TokenFetcher():
    TypeOnly<old.TokenFetcher<any>>;
declare function use_current_TypeAliasDeclaration_TokenFetcher(
    use: TypeOnly<current.TokenFetcher<any>>): void;
use_current_TypeAliasDeclaration_TokenFetcher(
    get_old_TypeAliasDeclaration_TokenFetcher());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TokenFetcher": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_TokenFetcher():
    TypeOnly<current.TokenFetcher<any>>;
declare function use_old_TypeAliasDeclaration_TokenFetcher(
    use: TypeOnly<old.TokenFetcher<any>>): void;
use_old_TypeAliasDeclaration_TokenFetcher(
    get_current_TypeAliasDeclaration_TokenFetcher());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_TokenResponse": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TokenResponse():
    TypeOnly<old.TokenResponse>;
declare function use_current_InterfaceDeclaration_TokenResponse(
    use: TypeOnly<current.TokenResponse>): void;
use_current_InterfaceDeclaration_TokenResponse(
    get_old_InterfaceDeclaration_TokenResponse());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_TokenResponse": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TokenResponse():
    TypeOnly<current.TokenResponse>;
declare function use_old_InterfaceDeclaration_TokenResponse(
    use: TypeOnly<old.TokenResponse>): void;
use_old_InterfaceDeclaration_TokenResponse(
    get_current_InterfaceDeclaration_TokenResponse());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getKeyForCacheEntry": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getKeyForCacheEntry():
    TypeOnly<typeof old.getKeyForCacheEntry>;
declare function use_current_FunctionDeclaration_getKeyForCacheEntry(
    use: TypeOnly<typeof current.getKeyForCacheEntry>): void;
use_current_FunctionDeclaration_getKeyForCacheEntry(
    get_old_FunctionDeclaration_getKeyForCacheEntry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getKeyForCacheEntry": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getKeyForCacheEntry():
    TypeOnly<typeof current.getKeyForCacheEntry>;
declare function use_old_FunctionDeclaration_getKeyForCacheEntry(
    use: TypeOnly<typeof old.getKeyForCacheEntry>): void;
use_old_FunctionDeclaration_getKeyForCacheEntry(
    get_current_FunctionDeclaration_getKeyForCacheEntry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isTokenFromCache": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_isTokenFromCache():
    TypeOnly<typeof old.isTokenFromCache>;
declare function use_current_VariableDeclaration_isTokenFromCache(
    use: TypeOnly<typeof current.isTokenFromCache>): void;
use_current_VariableDeclaration_isTokenFromCache(
    get_old_VariableDeclaration_isTokenFromCache());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isTokenFromCache": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_isTokenFromCache():
    TypeOnly<typeof current.isTokenFromCache>;
declare function use_old_VariableDeclaration_isTokenFromCache(
    use: TypeOnly<typeof old.isTokenFromCache>): void;
use_old_VariableDeclaration_isTokenFromCache(
    get_current_VariableDeclaration_isTokenFromCache());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_maximumCacheDurationMs": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_maximumCacheDurationMs():
    TypeOnly<typeof old.maximumCacheDurationMs>;
declare function use_current_VariableDeclaration_maximumCacheDurationMs(
    use: TypeOnly<typeof current.maximumCacheDurationMs>): void;
use_current_VariableDeclaration_maximumCacheDurationMs(
    get_old_VariableDeclaration_maximumCacheDurationMs());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_maximumCacheDurationMs": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_maximumCacheDurationMs():
    TypeOnly<typeof current.maximumCacheDurationMs>;
declare function use_old_VariableDeclaration_maximumCacheDurationMs(
    use: TypeOnly<typeof old.maximumCacheDurationMs>): void;
use_old_VariableDeclaration_maximumCacheDurationMs(
    get_current_VariableDeclaration_maximumCacheDurationMs());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_snapshotKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_snapshotKey():
    TypeOnly<typeof old.snapshotKey>;
declare function use_current_VariableDeclaration_snapshotKey(
    use: TypeOnly<typeof current.snapshotKey>): void;
use_current_VariableDeclaration_snapshotKey(
    get_old_VariableDeclaration_snapshotKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_snapshotKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_snapshotKey():
    TypeOnly<typeof current.snapshotKey>;
declare function use_old_VariableDeclaration_snapshotKey(
    use: TypeOnly<typeof old.snapshotKey>): void;
use_old_VariableDeclaration_snapshotKey(
    get_current_VariableDeclaration_snapshotKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_tokenFromResponse": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_tokenFromResponse():
    TypeOnly<typeof old.tokenFromResponse>;
declare function use_current_VariableDeclaration_tokenFromResponse(
    use: TypeOnly<typeof current.tokenFromResponse>): void;
use_current_VariableDeclaration_tokenFromResponse(
    get_old_VariableDeclaration_tokenFromResponse());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_tokenFromResponse": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_tokenFromResponse():
    TypeOnly<typeof current.tokenFromResponse>;
declare function use_old_VariableDeclaration_tokenFromResponse(
    use: TypeOnly<typeof old.tokenFromResponse>): void;
use_old_VariableDeclaration_tokenFromResponse(
    get_current_VariableDeclaration_tokenFromResponse());
