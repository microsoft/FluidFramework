/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
import {
	Dropdown,
	IDropdownOption,
	IDropdownStyles,
	IStackTokens,
	Stack,
	StackItem,
} from "@fluentui/react";
import {
	tokens,
	ToggleButton,
	DataGridBody,
	DataGridRow,
	DataGrid,
	DataGridHeader,
	DataGridHeaderCell,
	DataGridCell,
	TableColumnDefinition,
	createTableColumn,
} from "@fluentui/react-components";
import { Info24Regular, Info24Filled } from "@fluentui/react-icons";
import React, { useState } from "react";

import {
	GetTelemetryHistory,
	handleIncomingMessage,
	InboundHandlers,
	ISourcedDevtoolsMessage,
	ITimestampedTelemetryEvent,
	TelemetryHistory,
	TelemetryEvent,
} from "@fluid-tools/client-debugger";
import { useMessageRelay } from "../MessageRelayContext";
import { Waiting } from "./Waiting";

function mapEventCategoryToBackgroundColor(eventCategory: string): string {
	switch (eventCategory) {
		case "generic":
			return tokens.colorPaletteGreenForeground1;
		case "performance":
			return tokens.colorPaletteBlueForeground2;
		case "error":
			return tokens.colorPaletteRedBackground3;
		default:
			return tokens.colorNeutralBackground1;
	}
}

/**
 * Set the default displayed size to 100.
 */
const DEFAULT_PAGE_SIZE = 100;

/**
 * Displays telemetry events generated by FluidFramework in the application.
 */
export function TelemetryView(): React.ReactElement {
	const messageRelay = useMessageRelay();
	const [telemetryEvents, setTelemetryEvents] = React.useState<
		ITimestampedTelemetryEvent[] | undefined
	>();
	const [maxEventsToDisplay, setMaxEventsToDisplay] = React.useState<number>(DEFAULT_PAGE_SIZE);
	React.useEffect(() => {
		/**
		 * Handlers for inbound messages related to telemetry.
		 */
		const inboundMessageHandlers: InboundHandlers = {
			[TelemetryEvent.MessageType]: (untypedMessage) => {
				const message = untypedMessage as TelemetryEvent.Message;
				setTelemetryEvents((currentEvents) => [
					message.data.event,
					...(currentEvents ?? []),
				]);
				return true;
			},
			[TelemetryHistory.MessageType]: (untypedMessage) => {
				const message = untypedMessage as TelemetryHistory.Message;
				setTelemetryEvents(message.data.contents);
				return true;
			},
		};

		// Event handler for messages coming from the Message Relay
		function messageHandler(message: Partial<ISourcedDevtoolsMessage>): void {
			handleIncomingMessage(message, inboundMessageHandlers);
		}

		messageRelay.on("message", messageHandler);

		// Request all log history
		messageRelay.postMessage(GetTelemetryHistory.createMessage());

		return (): void => {
			messageRelay.off("message", messageHandler);
		};
	}, [messageRelay, setTelemetryEvents]);

	/**
	 * Interface for each item in the telemetry table.
	 */
	interface Item {
		category: string;
		eventName: string;
		information: string;
	}

	const items: Item[] =
		telemetryEvents !== undefined
			? telemetryEvents?.map((message) => {
					return {
						category: message.logContent.category,
						eventName: message.logContent.eventName,
						information: JSON.stringify(message.logContent, undefined, 2),
					};
			  }, [])
			: [];

	const columns: TableColumnDefinition<Item>[] = [
		createTableColumn<Item>({
			columnId: "category",
			renderHeaderCell: () => {
				return <b>Category</b>;
			},
			renderCell: (message) => {
				return (
					<div
						style={{
							color: mapEventCategoryToBackgroundColor(message.category),
							fontWeight: 700,
						}}
					>
						{message.category}
					</div>
				);
			},
		}),
		createTableColumn<Item>({
			columnId: "eventName",
			renderHeaderCell: () => {
				return <b>Event Name</b>;
			},
			renderCell: (message) => {
				return (
					<div style={{ maxWidth: 160, whiteSpace: "normal", wordWrap: "break-word" }}>
						{/* Since all events start with "fluid:telemetry:", we trim the start of the name */}
						{message.eventName.slice("fluid:telemetry:".length)}
					</div>
				);
			},
		}),
		createTableColumn<Item>({
			columnId: "information",
			renderHeaderCell: () => {
				return <b>Information</b>;
			},
			renderCell: (message) => {
				// eslint-disable-next-line react-hooks/rules-of-hooks
				const [expanded, setExpanded] = useState(false);
				const toggleExpanded = (): void => {
					setExpanded(!expanded);
				};
				return (
					<div>
						<ToggleButton
							checked={expanded}
							icon={expanded ? <Info24Filled /> : <Info24Regular />}
							size="small"
							onClick={toggleExpanded}
						>
							{expanded ? "Hide" : "Show"} Info
						</ToggleButton>
						{expanded && <pre>{message.information}</pre>}
					</div>
				);
			},
		}),
	];

	const log_view =
		telemetryEvents !== undefined ? (
			<>
				<h3>Telemetry events (newest first):</h3>
				<DataGrid
					items={items}
					columns={columns}
					resizableColumns
					columnSizingOptions={{
						category: {
							minWidth: 65,
							idealWidth: 80,
						},
						eventType: {
							minWidth: 60,
							idealWidth: 150,
						},
						information: {
							minWidth: 60,
							idealWidth: 250,
						},
					}}
				>
					<DataGridHeader>
						<DataGridRow style={{ whiteSpace: "normal" }}>
							{({ renderHeaderCell }): JSX.Element => (
								<DataGridHeaderCell>{renderHeaderCell()}</DataGridHeaderCell>
							)}
						</DataGridRow>
					</DataGridHeader>
					<DataGridBody<Item>>
						{({ item, rowId }): JSX.Element => (
							<DataGridRow<Item> key={rowId}>
								{({ renderCell }): JSX.Element => (
									<DataGridCell>{renderCell(item)}</DataGridCell>
								)}
							</DataGridRow>
						)}
					</DataGridBody>
				</DataGrid>
			</>
		) : (
			<Waiting label={"Waiting for Telemetry events"} />
		);

	return (
		<Stack>
			<StackItem>
				<_ListLengthSelection
					currentLimit={maxEventsToDisplay}
					onChangeSelection={(key): void => setMaxEventsToDisplay(key)}
				/>
			</StackItem>
			<StackItem>{log_view}</StackItem>
		</Stack>
	);
}

/**
 * {@link _ListLengthSelectionProps} input props.
 */
interface _ListLengthSelectionProps {
	/**
	 * The current limit (max number of telemetry events to show).
	 * @defaultValue {@link DEFAULT_PAGE_SIZE}
	 */
	currentLimit: number;

	/**
	 * Called when the selection changes.
	 */
	onChangeSelection(newLimit: number): void;
}

/**
 * A dropdown menu for selecting how many logs to display on the page.
 */
function _ListLengthSelection(props: _ListLengthSelectionProps): React.ReactElement {
	const { currentLimit, onChangeSelection } = props;
	const dropdownStyles: Partial<IDropdownStyles> = {
		dropdown: { width: "300px", zIndex: "1" },
	};

	const stackTokens: IStackTokens = { childrenGap: 20 };

	// Options formatted for the Fluent Dropdown component
	const dropdownOptions: IDropdownOption[] = [
		{ key: 50, text: "50" },
		{ key: 100, text: "100" },
		{ key: 500, text: "500" },
		{ key: 1000, text: "1000" },
	];

	return (
		<Stack tokens={stackTokens}>
			<div className="list-size-options">
				<h3>Max number of telemetry events to display: </h3>
				<Dropdown
					placeholder="Select an option"
					selectedKey={currentLimit}
					options={dropdownOptions}
					styles={dropdownStyles}
					// change the number of logs displayed on the page
					onChange={(event, option): void => onChangeSelection(option?.key as number)}
				/>
			</div>
		</Stack>
	);
}
