/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import React from "react";

import {
	handleIncomingMessage,
	ISourcedDebuggerMessage,
	InboundHandlers,
	TelemetryHistoryMessage,
	TelemetryEventMessage,
} from "@fluid-tools/client-debugger";
import { ITelemetryBaseEvent } from "@fluidframework/common-definitions";
import { useMessageRelay } from "../MessageRelayContext";
import { Waiting } from "./Waiting";

function mapEventCategoryToBackgroundColor(eventCategory: string): string {
	switch (eventCategory) {
		case "generic":
			return "#b8ebf2";
		case "performance":
			return "#4cf5a3";
		case "error":
			return "#f54c4f";
		default:
			return "#d2d3d4";
	}
}

/**
 * Function to transform the results when JSON-serializing telemetry events for display.
 * We already extract some of their properties to a different place in the UI, so it seems best to remove them from the
 * rendered JSON payload for a bit less bloat there.
 * @param key - The name of the property that's being serialized.
 * @param value - The value of the property that's being serialized.
 * @returns An updated value for the given key, or 'undefined' to remove the key from the serialized output.
 */
function jsonSerializationTransformer(key, value): unknown {
	// Filter out properties we display somewhere else in the UI
	if (key === "eventName" || key === "category") {
		return undefined;
	}
	return value;
}

/**
 * Displays telemetry events generated by FluidFramework in the application.
 */
export function TelemetryView(): React.ReactElement {
	const messageRelay = useMessageRelay();

	const [telemetryEvents, setTelemetryEvents] = React.useState<
		ITelemetryBaseEvent[] | undefined
	>();

	React.useEffect(() => {
		/**
		 * Handlers for inbound messages related to telemetry.
		 */
		const inboundMessageHandlers: InboundHandlers = {
			["TELEMETRY_EVENT"]: (untypedMessage) => {
				const message: TelemetryEventMessage = untypedMessage as TelemetryEventMessage;
				setTelemetryEvents((currentEvents) => [
					...message.data.contents,
					...(currentEvents ?? []),
				]);
				return true;
			},
			["TELEMETRY_HISTORY"]: (untypedMessage) => {
				const message: TelemetryHistoryMessage = untypedMessage as TelemetryHistoryMessage;
				setTelemetryEvents(message.data.contents);
				return true;
			},
		};

		// Event handler for messages coming from the Message Relay
		function messageHandler(message: Partial<ISourcedDebuggerMessage>): void {
			handleIncomingMessage(message, inboundMessageHandlers);
		}

		messageRelay.on("message", messageHandler);

		// Request all log history
		messageRelay.postMessage({
			type: "GET_TELEMETRY_HISTORY",
			data: undefined,
		});

		return (): void => {
			messageRelay.off("message", messageHandler);
		};
	}, [messageRelay, setTelemetryEvents]);

	return telemetryEvents !== undefined ? (
		<>
			<h3>Telemetry events (newest first):</h3>
			<ul>
				{telemetryEvents.map((message, index) => (
					<div
						key={index}
						style={{
							border: "1px solid black",
							backgroundColor: mapEventCategoryToBackgroundColor(message.category),
							padding: "5px",
						}}
					>
						<h4 style={{ margin: "0px" }}>
							EventName: {message.eventName}
							<br />
							Category: {message.category}
							<br />
							ContainerId: {message.containerId} ({message.clientType})
							<br />
							DocumentId: {message.docId}
						</h4>
						<p>{JSON.stringify(message, jsonSerializationTransformer, "  ")}</p>
					</div>
				))}
			</ul>
		</>
	) : (
		<Waiting label={"Waiting for Telemetry events"} />
	);
}
