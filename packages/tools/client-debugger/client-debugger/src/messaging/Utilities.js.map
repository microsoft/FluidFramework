{"version":3,"file":"Utilities.js","sourceRoot":"","sources":["Utilities.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAIH;;;;;;GAMG;AACH,MAAM,UAAU,mBAAmB,CAClC,OAAiB,EACjB,cAAsC;;IAEtC,MAAM,eAAe,GACpB,CAAA,cAAc,aAAd,cAAc,uBAAd,cAAc,CAAE,OAAO,MAAK,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,cAAc,CAAC,OAAO,IAAI,CAAC;IAC5E,OAAO,CAAC,GAAG,CAAC,GAAG,eAAe,gCAAgC,EAAE,OAAO,CAAC,CAAC,CAAC,sBAAsB;IAChG,MAAA,UAAU,CAAC,WAAW,+CADoD,sBAAsB;IAChG,UAAU,EAAe,OAAO,EAAE,GAAG,CAAC,CAAC,CAAC,8BAA8B;AACvE,CAAC;AA8BD;;;;;;;;;GASG;AACH,MAAM,UAAU,2BAA2B,CAC1C,KAA8C,EAC9C,QAAyB,EACzB,cAAsC;IAEtC,OAAO,qBAAqB,CAAC,KAAK,CAAC,IAAI,EAAE,QAAQ,EAAE,cAAc,CAAC,CAAC;AACpE,CAAC;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,qBAAqB,CACpC,OAAkC,EAClC,QAAyB,EACzB,cAAsC;IAEtC,IAAI,OAAO,KAAK,SAAS,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,EAAE;QACzD,OAAO;KACP;IAED,IAAI,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,SAAS,EAAE;QACzC,4CAA4C;QAC5C,OAAO;KACP;IAED,MAAM,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC;IAEhD,iEAAiE;IACjE,IAAI,OAAO,EAAE;QACZ,MAAM,eAAe,GACpB,CAAA,cAAc,aAAd,cAAc,uBAAd,cAAc,CAAE,OAAO,MAAK,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,cAAc,CAAC,OAAO,IAAI,CAAC;QAC5E,OAAO,CAAC,GAAG,CAAC,GAAG,eAAe,mBAAmB,EAAE,OAAO,CAAC,CAAC,CAAC,sBAAsB;KACnF;AACF,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,iBAAiB,CAAC,KAAgC;IACjE,OAAO,OAAO,KAAK,CAAC,MAAM,KAAK,QAAQ,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,CAAC;AACrE,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IDebuggerMessage } from \"./Messages\";\n\n/**\n * Posts the provided message to the window (globalThis).\n *\n * @remarks Thin wrapper to provide some message-wise type-safety.\n *\n * @internal\n */\nexport function postMessageToWindow<TMessage extends IDebuggerMessage>(\n\tmessage: TMessage,\n\tloggingOptions?: MessageLoggingOptions,\n): void {\n\tconst loggingPreamble =\n\t\tloggingOptions?.context === undefined ? \"\" : `${loggingOptions.context}: `;\n\tconsole.log(`${loggingPreamble}Posting message to the window:`, message); // TODO: console.debug\n\tglobalThis.postMessage?.(message, \"*\"); // TODO: verify target is okay\n}\n\n/**\n * Handlers for incoming {@link IDebuggerMessage}s.\n *\n * @internal\n */\nexport interface InboundHandlers {\n\t/**\n\t * Mapping from {@link IDebuggerMessage.\"type\"}s to a handler callback for that message type.\n\t * @returns Whether or not the message was actually handled.\n\t */\n\t[type: string]: (message: IDebuggerMessage) => boolean;\n}\n\n/**\n * Console logging options for {@link handleIncomingWindowMessage}.\n *\n * @privateRemarks TODO: Introduce better diagnostic logging infra for the entire library\n *\n * @internal\n */\nexport interface MessageLoggingOptions {\n\t/**\n\t * Context to associate with the log text.\n\t * Messages will be logged in the form: `(<context>): <text>`.\n\t */\n\tcontext?: string;\n}\n\n/**\n * Utility function for handling incoming events.\n *\n * @param event - The window event containing the message to handle.\n * @param handlers - List of handlers for particular event types.\n * If the incoming event's message type has a corresponding handler callback, that callback will be invoked.\n * Otherwise, this function will no-op.\n *\n * @internal\n */\nexport function handleIncomingWindowMessage(\n\tevent: MessageEvent<Partial<IDebuggerMessage>>,\n\thandlers: InboundHandlers,\n\tloggingOptions?: MessageLoggingOptions,\n): void {\n\treturn handleIncomingMessage(event.data, handlers, loggingOptions);\n}\n\n/**\n * Utility function for handling incoming events.\n *\n * @param message - The window event containing the message to handle.\n * @param handlers - List of handlers for particular event types.\n * If the incoming event's message type has a corresponding handler callback, that callback will be invoked.\n * Otherwise, this function will no-op.\n *\n * @internal\n */\nexport function handleIncomingMessage(\n\tmessage: Partial<IDebuggerMessage>,\n\thandlers: InboundHandlers,\n\tloggingOptions?: MessageLoggingOptions,\n): void {\n\tif (message === undefined || !isDebuggerMessage(message)) {\n\t\treturn;\n\t}\n\n\tif (handlers[message.type] === undefined) {\n\t\t// No handler for this type provided. No-op.\n\t\treturn;\n\t}\n\n\tconst handled = handlers[message.type](message);\n\n\t// Only log if the message was actually handled by the recipient.\n\tif (handled) {\n\t\tconst loggingPreamble =\n\t\t\tloggingOptions?.context === undefined ? \"\" : `${loggingOptions.context}: `;\n\t\tconsole.log(`${loggingPreamble} message handled:`, message); // TODO: console.debug\n\t}\n}\n\n/**\n * Determines whether the provided event message data is an {@link IDebuggerMessage}.\n *\n * @internal\n */\nexport function isDebuggerMessage(value: Partial<IDebuggerMessage>): value is IDebuggerMessage {\n\treturn typeof value.source === \"string\" && value.type !== undefined;\n}\n"]}