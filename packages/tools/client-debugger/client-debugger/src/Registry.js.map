{"version":3,"file":"Registry.js","sourceRoot":"","sources":["Registry.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { IEvent } from \"@fluidframework/common-definitions\";\nimport { IContainer } from \"@fluidframework/container-definitions\";\nimport { IFluidLoadable } from \"@fluidframework/core-interfaces\";\n\nimport { FluidClientDebugger } from \"./FluidClientDebugger\";\nimport { IFluidClientDebugger } from \"./IFluidClientDebugger\";\nimport {\n\tdebuggerMessageSource,\n\thandleIncomingWindowMessage,\n\tIDebuggerMessage,\n\tInboundHandlers,\n\tMessageLoggingOptions,\n\tpostMessageToWindow,\n\tRegistryChangeMessage,\n} from \"./messaging\";\n\n// TODOs:\n// - Clear registry on `window.beforeunload`, to ensure we do not hold onto stale resources.\n\n/**\n * Message logging options used by the registry.\n */\nconst registryMessageLoggingOptions: MessageLoggingOptions = {\n\tcontext: \"DEBUGGER REGISTRY\",\n};\n\n/**\n * Properties for configuring a {@link IFluidClientDebugger}.\n *\n * @public\n */\nexport interface FluidClientDebuggerProps {\n\t/**\n\t * The Container with which the debugger will be associated.\n\t */\n\tcontainer: IContainer;\n\n\t/**\n\t * The ID of {@link FluidClientDebuggerProps.container | the Container}.\n\t */\n\tcontainerId: string;\n\n\t/**\n\t * Optional: Data belonging to {@link FluidClientDebuggerProps.container | the Container}.\n\t *\n\t * @remarks The debugger will not mutate this data.\n\t */\n\tcontainerData?: IFluidLoadable | Record<string, IFluidLoadable>;\n\n\t/**\n\t * Optional: Nickname for {@link FluidClientDebuggerProps.container | the Container} / debugger instance.\n\t *\n\t * @remarks\n\t *\n\t * Associated tooling may take advantage of this to differentiate between debugger instances using\n\t * semantically meaningful information.\n\t *\n\t * If not provided, the {@link FluidClientDebuggerProps.containerId} will be used for the purpose of distinguising\n\t * debugger instances.\n\t */\n\tcontainerNickname?: string;\n}\n\n/**\n * Event to montor client debugger list change.\n * @internal\n */\nexport interface DebuggerRegistryEvents extends IEvent {\n\t/**\n\t * Emitted when a {@link IFluidClientDebugger} is registered.\n\t *\n\t * @eventProperty\n\t */\n\t(event: \"debuggerRegistered\", listener: (containerId: string) => void): void;\n\n\t/**\n\t * Emitted when a {@link IFluidClientDebugger} is closed.\n\t *\n\t * @eventProperty\n\t */\n\t(event: \"debuggerClosed\", listener: (containerId: string) => void): void;\n}\n\n/**\n * Contract for maintaining a global client debugger registry to store all registered client debugger.\n *\n * @remarks\n *\n * This class listens to incoming messages from the window (globalThis), and posts messages to it upon relevant\n * state changes and when requested.\n *\n * **Messages it listens for:**\n *\n * - {@link GetContainerListMessage}: When received, the registry will post {@link RegistryChangeMessage}.\n *\n * TODO: Document others as they are added.\n *\n * **Messages it posts:**\n *\n * - {@link RegistryChangeMessage}: The registry will post this whenever the list of registered\n * debuggers changes, or when requested (via {@link GetContainerListMessage}).\n *\n * TODO: Document others as they are added.\n *\n * @internal\n */\nexport class DebuggerRegistry extends TypedEventEmitter<DebuggerRegistryEvents> {\n\tprivate readonly registeredDebuggers: Map<string, FluidClientDebugger> = new Map();\n\n\t// #region Event handlers\n\n\t/**\n\t * Handlers for inbound messages related to the registry.\n\t */\n\tprivate readonly inboundMessageHandlers: InboundHandlers = {\n\t\t[\"GET_CONTAINER_LIST\"]: () => {\n\t\t\tthis.postRegistryChange();\n\t\t\treturn true;\n\t\t},\n\t};\n\n\t/**\n\t * Event handler for messages coming from the window (globalThis).\n\t */\n\tprivate readonly windowMessageHandler = (\n\t\tevent: MessageEvent<Partial<IDebuggerMessage>>,\n\t): void => {\n\t\thandleIncomingWindowMessage(\n\t\t\tevent,\n\t\t\tthis.inboundMessageHandlers,\n\t\t\tregistryMessageLoggingOptions,\n\t\t);\n\t};\n\n\t/**\n\t * Posts a {@link RegistryChangeMessage} to the window (globalThis).\n\t */\n\tprivate readonly postRegistryChange = (): void => {\n\t\tpostMessageToWindow<RegistryChangeMessage>(\n\t\t\t{\n\t\t\t\tsource: debuggerMessageSource,\n\t\t\t\ttype: \"REGISTRY_CHANGE\",\n\t\t\t\tdata: {\n\t\t\t\t\tcontainers: [...this.registeredDebuggers.values()].map((clientDebugger) => ({\n\t\t\t\t\t\tid: clientDebugger.containerId,\n\t\t\t\t\t\tnickname: clientDebugger.containerNickname,\n\t\t\t\t\t})),\n\t\t\t\t},\n\t\t\t},\n\t\t\tregistryMessageLoggingOptions,\n\t\t);\n\t};\n\n\t// #endregion\n\n\tpublic constructor() {\n\t\tsuper();\n\n\t\t// Register listener for inbound messages from the window (globalThis)\n\t\tglobalThis.addEventListener?.(\"message\", this.windowMessageHandler);\n\n\t\t// Initiate message posting of registry updates.\n\t\t// TODO: Only do this after some external request?\n\t\tthis.on(\"debuggerRegistered\", this.postRegistryChange);\n\t\tthis.on(\"debuggerClosed\", this.postRegistryChange);\n\t}\n\n\t/**\n\t * Initializes a {@link IFluidClientDebugger} from the provided properties and binds it to the global context.\n\t */\n\tpublic initializeDebugger(props: FluidClientDebuggerProps): void {\n\t\tconst { containerId } = props;\n\t\tconst existingDebugger = this.registeredDebuggers.get(containerId);\n\t\tif (existingDebugger !== undefined) {\n\t\t\tconsole.warn(\n\t\t\t\t`Active debugger registry already contains an entry for container ID \"${containerId}\". Override existing entry.`,\n\t\t\t);\n\t\t\texistingDebugger.dispose();\n\t\t}\n\n\t\tconst clientDebugger = new FluidClientDebugger(props);\n\t\tconsole.log(`Add new debugger${clientDebugger.containerId}`);\n\t\tthis.registeredDebuggers.set(containerId, clientDebugger);\n\t\tthis.emit(\"debuggerRegistered\", containerId, clientDebugger);\n\t}\n\n\t/**\n\t * Closes ({@link IFluidClientDebugger.dispose | disposes}) a registered client debugger associated with the\n\t * provided Container ID.\n\t */\n\tpublic closeDebugger(containerId: string): void {\n\t\tif (this.registeredDebuggers.has(containerId)) {\n\t\t\tconst clientDebugger = this.registeredDebuggers.get(containerId);\n\t\t\tif (clientDebugger === undefined) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`No active client debugger associated with container ID \"${containerId}\" was found.`,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tclientDebugger.dispose();\n\t\t\t\tthis.registeredDebuggers.delete(containerId);\n\t\t\t\tthis.emit(\"debuggerClosed\", containerId);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn(`Fluid Client debugger never been registered.`);\n\t\t}\n\t}\n\n\t/**\n\t * Gets the registered client debugger associated with the provided Container ID if one is registered.\n\t * @returns the client debugger or undefined if not found.\n\t */\n\tpublic getRegisteredDebuggers(): Map<string, IFluidClientDebugger> {\n\t\treturn this.registeredDebuggers;\n\t}\n}\n\n/**\n * Initializes a {@link IFluidClientDebugger} from the provided properties, binding it to the global context.\n *\n * @remarks\n *\n * If there is an existing debugger session associated with the provided {@link FluidClientDebuggerProps.containerId},\n * the existing debugger session will be closed, and a new one will be generated from the provided props.\n *\n * @public\n */\nexport function initializeFluidClientDebugger(props: FluidClientDebuggerProps): void {\n\tgetDebuggerRegistry().initializeDebugger(props);\n}\n\n/**\n * Closes ({@link IFluidClientDebugger.dispose | disposes}) a registered client debugger associated with the\n * provided Container ID.\n *\n * @public\n */\nexport function closeFluidClientDebugger(containerId: string): void {\n\tgetDebuggerRegistry().closeDebugger(containerId);\n}\n\n/**\n * Gets the registered client debugger associated with the provided Container ID if one is registered.\n *\n * @remarks Will return `undefined` if no such debugger is registered.\n *\n * @internal\n */\nexport function getFluidClientDebugger(containerId: string): IFluidClientDebugger | undefined {\n\tconst debuggerRegistry = getDebuggerRegistry().getRegisteredDebuggers();\n\treturn debuggerRegistry.get(containerId);\n}\n\n/**\n * Gets all registered client debuggers from the registry.\n *\n * @internal\n */\nexport function getFluidClientDebuggers(): IFluidClientDebugger[] {\n\tconst debuggerRegistry = getDebuggerRegistry();\n\n\tconst clientDebuggers: IFluidClientDebugger[] = [];\n\tfor (const [, clientDebugger] of debuggerRegistry.getRegisteredDebuggers()) {\n\t\tclientDebuggers.push(clientDebugger);\n\t}\n\n\treturn clientDebuggers;\n}\n\n/**\n * Gets the debugger registry from the window. Initializes it if one does not yet exist.\n *\n * @throws Throws an error if initialization / binding to the window object fails.\n *\n * @internal\n */\nexport function getDebuggerRegistry(): DebuggerRegistry {\n\tif (globalThis.fluidClientDebuggersRegistry === undefined) {\n\t\t// If no client debuggers have been bound, initialize list\n\t\tglobalThis.fluidClientDebuggersRegistry = new DebuggerRegistry();\n\t}\n\n\tconst debuggerRegistry = globalThis.fluidClientDebuggersRegistry as DebuggerRegistry;\n\n\tif (debuggerRegistry === undefined) {\n\t\tthrow new Error(\"Fluid Client debugger registry initialization failed.\");\n\t}\n\n\treturn debuggerRegistry;\n}\n\n/**\n * Clears the debugger registry, disposing of any remaining debugger objects.\n *\n * @internal\n */\nexport function clearDebuggerRegistry(): void {\n\tconst debuggerRegistry = globalThis.fluidClientDebuggers as Map<string, IFluidClientDebugger>;\n\tif (debuggerRegistry !== undefined) {\n\t\tfor (const [, clientDebugger] of debuggerRegistry) {\n\t\t\tif (clientDebugger.disposed) {\n\t\t\t\tconsole.warn(`Fluid Client debugger has already been disposed.`);\n\t\t\t} else {\n\t\t\t\tclientDebugger.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tglobalThis.fluidClientDebuggers = undefined;\n}\n"]}