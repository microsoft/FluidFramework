## API Report File for "@fluid-tools/client-debugger"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AttachState } from '@fluidframework/container-definitions';
import { ConnectionState } from '@fluidframework/container-loader';
import { IAudience } from '@fluidframework/container-definitions';
import { IClient } from '@fluidframework/protocol-definitions';
import { IContainer } from '@fluidframework/container-definitions';
import { IDisposable } from '@fluidframework/common-definitions';
import { IEvent } from '@fluidframework/common-definitions';
import { IEventProvider } from '@fluidframework/common-definitions';
import { IFluidLoadable } from '@fluidframework/core-interfaces';
import { TypedEventEmitter } from '@fluidframework/common-utils';

// @internal
export interface AudienceChangeLogEntry extends LogEntry {
    changeKind: "added" | "removed";
    client: IClient;
    clientId: string;
}

// @internal
export function clearDebuggerRegistry(): void;

// @public
export function closeFluidClientDebugger(containerId: string): void;

// @internal
export interface ConnectionStateChangeLogEntry extends StateChangeLogEntry<ContainerStateChangeKind> {
    clientId: string | undefined;
}

// @public
export interface ContainerMetadata {
    id: string;
    nickname?: string;
}

// @internal
export enum ContainerStateChangeKind {
    Attached = "attached",
    Closed = "closed",
    Connected = "connected",
    Disconnected = "disconnected",
    Disposed = "disposed"
}

// @public
export interface ContainerStateChangeMessage extends IDebuggerMessage<ContainerStateChangeMessageData> {
    // (undocumented)
    type: "CONTAINER_STATE_CHANGE";
}

// @public
export interface ContainerStateChangeMessageData extends HasContainerId {
    containerState: ContainerStateMetadata;
}

// @public
export interface ContainerStateMetadata extends ContainerMetadata {
    // (undocumented)
    attachState: AttachState;
    audienceId?: string;
    // (undocumented)
    clientId?: string;
    closed: boolean;
    // (undocumented)
    connectionState: ConnectionState;
}

// @public
export const debuggerMessageSource: string;

// @internal
export class DebuggerRegistry extends TypedEventEmitter<DebuggerRegistryEvents> {
    constructor();
    closeDebugger(containerId: string): void;
    getRegisteredDebuggers(): Map<string, IFluidClientDebugger>;
    initializeDebugger(props: FluidClientDebuggerProps): void;
}

// @internal
export interface DebuggerRegistryEvents extends IEvent {
    // @eventProperty
    (event: "debuggerRegistered", listener: (containerId: string) => void): void;
    // @eventProperty
    (event: "debuggerClosed", listener: (containerId: string) => void): void;
}

// @public
export interface FluidClientDebuggerProps {
    container: IContainer;
    containerData?: IFluidLoadable | Record<string, IFluidLoadable>;
    containerId: string;
    containerNickname?: string;
}

// @public
export interface GetContainerListMessage extends IDebuggerMessage<undefined> {
    // (undocumented)
    type: "GET_CONTAINER_LIST";
}

// @public
export interface GetContainerStateMessage extends IDebuggerMessage<HasContainerId> {
    // (undocumented)
    type: "GET_CONTAINER_STATE";
}

// @public
export type GetContainerStateMessageData = HasContainerId;

// @internal
export function getDebuggerRegistry(): DebuggerRegistry;

// @internal
export function getFluidClientDebugger(containerId: string): IFluidClientDebugger | undefined;

// @internal
export function getFluidClientDebuggers(): IFluidClientDebugger[];

// @internal
export function handleIncomingMessage(message: Partial<IDebuggerMessage>, handlers: InboundHandlers, loggingOptions?: MessageLoggingOptions): void;

// @internal
export function handleIncomingWindowMessage(event: MessageEvent<Partial<IDebuggerMessage>>, handlers: InboundHandlers, loggingOptions?: MessageLoggingOptions): void;

// @public
export interface HasContainerId {
    containerId: string;
}

// @public
export interface IDebuggerMessage<TData = unknown> {
    data: TData;
    source: string;
    type: string;
}

// @internal
export interface IFluidClientDebugger extends IEventProvider<IFluidClientDebuggerEvents>, IDisposable {
    readonly audience: IAudience;
    readonly container: IContainer;
    readonly containerData?: IFluidLoadable | Record<string, IFluidLoadable>;
    readonly containerId: string;
    readonly containerNickname?: string;
    dispose(): void;
    getAudienceHistory(): readonly AudienceChangeLogEntry[];
    getContainerConnectionLog(): readonly ConnectionStateChangeLogEntry[];
}

// @internal
export interface IFluidClientDebuggerEvents extends IEvent {
    (event: "disposed", listener: () => void): any;
}

// @internal
export interface InboundHandlers {
    [type: string]: (message: IDebuggerMessage) => boolean;
}

// @public
export function initializeFluidClientDebugger(props: FluidClientDebuggerProps): void;

// @internal
export function isDebuggerMessage(value: Partial<IDebuggerMessage>): value is IDebuggerMessage;

// @internal
export interface LogEntry {
    timestamp: number;
}

// @internal
export enum MemberChangeKind {
    Added = "Added",
    Removed = "Removed"
}

// @internal
export interface MessageLoggingOptions {
    context?: string;
}

// @internal
export function postMessageToWindow<TMessage extends IDebuggerMessage>(message: TMessage, loggingOptions?: MessageLoggingOptions): void;

// @public
export interface RegistryChangeMessage extends IDebuggerMessage<RegistryChangeMessageData> {
    // (undocumented)
    type: "REGISTRY_CHANGE";
}

// @public
export interface RegistryChangeMessageData {
    containers: ContainerMetadata[];
}

// @internal
export interface StateChangeLogEntry<TState> extends LogEntry {
    newState: TState;
}

```
