## API Report File for "@fluid-tools/client-debugger"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AttachState } from '@fluidframework/container-definitions';
import { ConnectionState } from '@fluidframework/container-loader';
import { IAudience } from '@fluidframework/container-definitions';
import { IClient } from '@fluidframework/protocol-definitions';
import { IContainer } from '@fluidframework/container-definitions';
import { IDisposable } from '@fluidframework/common-definitions';
import { IEvent } from '@fluidframework/common-definitions';
import { IEventProvider } from '@fluidframework/common-definitions';
import { IFluidLoadable } from '@fluidframework/core-interfaces';
import { ISharedObject } from '@fluidframework/shared-object-base';
import { ITelemetryBaseEvent } from '@fluidframework/common-definitions';
import { ITelemetryBaseLogger } from '@fluidframework/common-definitions';
import { ITelemetryLoggerPropertyBags } from '@fluidframework/telemetry-utils';
import { TelemetryLogger } from '@fluidframework/telemetry-utils';
import { TypedEventEmitter } from '@fluidframework/common-utils';

// @public
export interface AudienceChangeLogEntry extends LogEntry {
    changeKind: "added" | "removed";
    client: IClient;
    clientId: string;
}

// @public
export interface AudienceClientMetadata {
    client: IClient;
    clientId: string;
}

// @public
export interface AudienceSummaryMessage extends IDebuggerMessage<AudienceSummaryMessageData> {
    type: typeof AudienceSummaryMessageType;
}

// @public
export interface AudienceSummaryMessageData extends HasContainerId {
    audienceHistory: readonly AudienceChangeLogEntry[];
    audienceState: AudienceClientMetadata[];
    clientId: string | undefined;
}

// @public
export const AudienceSummaryMessageType = "AUDIENCE_EVENT";

// @public
export namespace CloseContainer {
    const MessageType = "CLOSE_CONTAINER";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDebuggerMessage<MessageData> {
        type: typeof MessageType;
    }
    export type MessageData = HasContainerId;
}

// @public
export namespace ConnectContainer {
    const MessageType = "CONNECT_CONTAINER";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDebuggerMessage<MessageData> {
        type: typeof MessageType;
    }
    export type MessageData = HasContainerId;
}

// @public
export interface ConnectionStateChangeLogEntry extends StateChangeLogEntry<ContainerStateChangeKind> {
    clientId: string | undefined;
}

// @internal @sealed
export class ContainerDevtools extends TypedEventEmitter<ContainerDevtoolsEvents> implements IContainerDevtools {
    constructor(props: ContainerDevtoolsProps);
    get audience(): IAudience;
    readonly container: IContainer;
    readonly containerData?: Record<string, IFluidLoadable>;
    readonly containerId: string;
    readonly containerNickname?: string;
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    getAudienceHistory(): readonly AudienceChangeLogEntry[];
    getContainerConnectionLog(): readonly ConnectionStateChangeLogEntry[];
}

// @public
export interface ContainerDevtoolsEvents extends IEvent {
    (event: "disposed", listener: () => void): any;
}

// @public
export interface ContainerDevtoolsProps {
    container: IContainer;
    containerData?: Record<string, IFluidLoadable>;
    containerId: string;
    containerNickname?: string;
    dataVisualizers?: Record<string, VisualizeSharedObject>;
}

// @public
export interface ContainerListMessage extends IDebuggerMessage<ContainerListMessageData> {
    type: typeof ContainerListMessageType;
}

// @public
export interface ContainerListMessageData {
    containers: ContainerMetadata[];
}

// @public
export const ContainerListMessageType = "CONTAINER_LIST";

// @public
export interface ContainerMetadata {
    id: string;
    nickname?: string;
}

// @public
export namespace ContainerStateChange {
    const MessageType = "CONTAINER_STATE_CHANGE";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDebuggerMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData extends HasContainerId {
        containerState: ContainerStateMetadata;
    }
}

// @public
export enum ContainerStateChangeKind {
    Attached = "attached",
    Closed = "closed",
    Connected = "connected",
    Disconnected = "disconnected",
    Disposed = "disposed"
}

// @public
export namespace ContainerStateHistory {
    const MessageType = "CONTAINER_STATE_HISTORY";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDebuggerMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData extends HasContainerId {
        history: ConnectionStateChangeLogEntry[];
    }
}

// @public
export interface ContainerStateMetadata extends ContainerMetadata {
    // (undocumented)
    attachState: AttachState;
    audienceId?: string;
    // (undocumented)
    clientId?: string;
    closed: boolean;
    // (undocumented)
    connectionState: ConnectionState;
}

// @public
export namespace DataVisualization {
    const MessageType = "DATA_VISUALIZATION";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDebuggerMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData extends HasContainerId, HasFluidObjectId {
        visualization: FluidObjectNode | undefined;
    }
}

// @public
export const devtoolsMessageSource: string;

// @public
export namespace DisconnectContainer {
    const MessageType = "DISCONNECT_CONTAINER";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDebuggerMessage<MessageData> {
        type: typeof MessageType;
    }
    export type MessageData = HasContainerId;
}

// @internal @sealed
export class FluidDebuggerLogger extends TelemetryLogger {
    static create(namespace?: string, properties?: ITelemetryLoggerPropertyBags): TelemetryLogger;
    static mixinLogger(namespace?: string, baseLogger?: ITelemetryBaseLogger, properties?: ITelemetryLoggerPropertyBags): TelemetryLogger;
    send(event: ITelemetryBaseEvent): void;
}

// @internal
export class FluidDevtools extends TypedEventEmitter<FluidDevtoolsEvents> implements IFluidDevtools {
    constructor(props?: FluidDevtoolsProps);
    closeContainerDevtools(containerId: string): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    getAllContainerDevtools(): readonly IContainerDevtools[];
    getContainerDevtools(containerId: string): IContainerDevtools | undefined;
    registerContainerDevtools(props: ContainerDevtoolsProps): void;
}

// @public
export interface FluidDevtoolsEvents extends IEvent {
    // @eventProperty
    (event: "containerDevtoolsRegistered", listener: (containerId: string) => void): void;
    // @eventProperty
    (event: "containerDevtoolsClosed", listener: (containerId: string) => void): void;
    // @eventProperty
    (event: "devtoolsDisposed", listener: () => void): void;
}

// @public
export interface FluidDevtoolsProps {
    initialContainers?: ContainerDevtoolsProps[];
}

// @public
export interface FluidHandleNode extends VisualNodeBase {
    fluidObjectId: string;
    nodeKind: VisualNodeKind.FluidHandleNode;
}

// @public
export type FluidObjectId = string;

// @public
export type FluidObjectNode = FluidObjectTreeNode | FluidObjectValueNode | FluidUnknownObjectNode;

// @public
export interface FluidObjectNodeBase extends VisualNodeBase {
    fluidObjectId: FluidObjectId;
}

// @public
export interface FluidObjectTreeNode extends TreeNodeBase, FluidObjectNodeBase {
    nodeKind: VisualNodeKind.FluidTreeNode;
}

// @public
export interface FluidObjectValueNode extends ValueNodeBase, FluidObjectNodeBase {
    nodeKind: VisualNodeKind.FluidValueNode;
}

// @public
export interface FluidUnknownObjectNode extends FluidObjectNodeBase {
    nodeKind: VisualNodeKind.FluidUnknownObjectNode;
}

// @public
export interface GetAudienceMessage extends IDebuggerMessage<HasContainerId> {
    type: typeof GetAudienceMessageType;
}

// @public
export const GetAudienceMessageType = "GET_AUDIENCE";

// @public
export interface GetContainerListMessage extends IDebuggerMessage<undefined> {
    type: typeof GetContainerListMessageType;
}

// @public
export const GetContainerListMessageType = "GET_CONTAINER_LIST";

// @public
export namespace GetContainerState {
    const MessageType = "GET_CONTAINER_STATE";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDebuggerMessage<HasContainerId> {
        type: typeof MessageType;
    }
    export type MessageData = HasContainerId;
}

// @public
export namespace GetDataVisualization {
    const MessageType = "GET_DATA_VISUALIZATION";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDebuggerMessage<MessageData> {
        type: typeof MessageType;
    }
    export type MessageData = HasContainerId & HasFluidObjectId;
}

// @public
export namespace GetRootDataVisualizations {
    const MessageType = "GET_ROOT_DATA_VISUALIZATIONS";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDebuggerMessage<MessageData> {
        type: typeof MessageType;
    }
    export type MessageData = HasContainerId;
}

// @public
export interface GetTelemetryHistoryMessage extends IDebuggerMessage {
    type: typeof GetTelemetryHistoryMessageType;
}

// @public
export const GetTelemetryHistoryMessageType = "GET_TELEMETRY_HISTORY";

// @internal
export function handleIncomingMessage(message: Partial<ISourcedDebuggerMessage>, handlers: InboundHandlers, loggingOptions?: MessageLoggingOptions): void;

// @internal
export function handleIncomingWindowMessage(event: MessageEvent<Partial<ISourcedDebuggerMessage>>, handlers: InboundHandlers, loggingOptions?: MessageLoggingOptions): void;

// @public
export interface HasContainerId {
    containerId: string;
}

// @public
export interface HasFluidObjectId {
    fluidObjectId: FluidObjectId;
}

// @public
export interface IContainerDevtools extends IEventProvider<ContainerDevtoolsEvents>, IDisposable {
    readonly audience: IAudience;
    readonly container: IContainer;
    readonly containerData?: IFluidLoadable | Record<string, IFluidLoadable>;
    readonly containerId: string;
    readonly containerNickname?: string;
    dispose(): void;
    getAudienceHistory(): readonly AudienceChangeLogEntry[];
    getContainerConnectionLog(): readonly ConnectionStateChangeLogEntry[];
}

// @public
export interface IDebuggerMessage<TData = unknown> {
    data: TData;
    type: string;
}

// @public
export interface IFluidDevtools extends IEventProvider<FluidDevtoolsEvents>, IDisposable {
    closeContainerDevtools(containerId: string): void;
    getAllContainerDevtools(): readonly IContainerDevtools[];
    getContainerDevtools(containerId: string): IContainerDevtools | undefined;
    registerContainerDevtools(props: ContainerDevtoolsProps): void;
}

// @internal
export interface IMessageRelay<TSend extends IDebuggerMessage = IDebuggerMessage, TReceive extends ISourcedDebuggerMessage = ISourcedDebuggerMessage> extends IEventProvider<IMessageRelayEvents<TReceive>> {
    postMessage: (message: TSend) => void;
}

// @internal
export interface IMessageRelayEvents<TMessage extends ISourcedDebuggerMessage = ISourcedDebuggerMessage> extends IEvent {
    (event: "message", listener: (message: TMessage) => void): any;
}

// @internal
export interface InboundHandlers {
    [type: string]: (message: ISourcedDebuggerMessage) => boolean;
}

// @public
export function initializeFluidDevtools(props?: FluidDevtoolsProps): IFluidDevtools;

// @internal
export function isDebuggerMessage(value: Partial<ISourcedDebuggerMessage>): value is ISourcedDebuggerMessage;

// @public
export interface ISourcedDebuggerMessage<TData = unknown> extends IDebuggerMessage<TData> {
    source: string;
}

// @public
export interface ITimestampedTelemetryEvent {
    logContent: ITelemetryBaseEvent;
    timestamp: number;
}

// @public
export interface LogEntry {
    timestamp: number;
}

// @internal
export enum MemberChangeKind {
    Added = "Added",
    Removed = "Removed"
}

// @internal
export interface MessageLoggingOptions {
    context?: string;
}

// @internal
export function postMessagesToWindow<TMessage extends IDebuggerMessage>(loggingOptions?: MessageLoggingOptions, ...messages: TMessage[]): void;

// @public
export type Primitive = bigint | number | boolean | null | string | symbol | undefined;

// @public
export namespace RootDataVisualizations {
    const MessageType = "ROOT_DATA_VISUALIZATIONS";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDebuggerMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData extends HasContainerId {
        visualizations: Record<string, RootHandleNode> | undefined;
    }
}

// @public
export type RootHandleNode = FluidHandleNode | UnknownObjectNode;

// @public
export interface StateChangeLogEntry<TState> extends LogEntry {
    newState: TState;
}

// @public
export interface TelemetryEventMessage extends IDebuggerMessage<TelemetryEventMessageData> {
    type: typeof TelemetryEventMessageType;
}

// @public
export interface TelemetryEventMessageData {
    contents: ITimestampedTelemetryEvent[];
}

// @public
export const TelemetryEventMessageType = "TELEMETRY_EVENT";

// @public
export interface TelemetryHistoryMessage extends IDebuggerMessage<TelemetryEventMessageData> {
    type: typeof TelemetryHistoryMessageType;
}

// @public
export const TelemetryHistoryMessageType = "TELEMETRY_HISTORY";

// @public
export interface TreeNodeBase extends VisualNodeBase {
    children: Record<string, VisualChildNode>;
}

// @public
export interface UnknownObjectNode extends VisualNodeBase {
    nodeKind: VisualNodeKind.UnknownObjectNode;
}

// @public
export interface ValueNodeBase extends VisualNodeBase {
    value: Primitive;
}

// @public
export type VisualChildNode = VisualTreeNode | VisualValueNode | FluidHandleNode | UnknownObjectNode;

// @public
export type VisualizeChildData = (data: unknown) => Promise<VisualChildNode>;

// @public
export type VisualizeSharedObject = (sharedObject: ISharedObject, visualizeChildData: VisualizeChildData) => Promise<FluidObjectNode>;

// @public
export type VisualNode = VisualTreeNode | VisualValueNode | FluidHandleNode | FluidObjectTreeNode | FluidObjectValueNode | FluidUnknownObjectNode | UnknownObjectNode;

// @public
export interface VisualNodeBase {
    metadata?: Record<string, Primitive>;
    nodeKind: VisualNodeKind | string;
    typeMetadata?: string;
}

// @public
export enum VisualNodeKind {
    // (undocumented)
    FluidHandleNode = "FluidHandleNode",
    // (undocumented)
    FluidTreeNode = "FluidTreeNode",
    // (undocumented)
    FluidUnknownObjectNode = "FluidUnknownObjectNode",
    // (undocumented)
    FluidValueNode = "FluidValueNode",
    // (undocumented)
    TreeNode = "TreeNode",
    // (undocumented)
    UnknownObjectNode = "UnknownObjectNode",
    // (undocumented)
    ValueNode = "ValueNode"
}

// @public
export interface VisualTreeNode extends TreeNodeBase {
    nodeKind: VisualNodeKind.TreeNode;
}

// @public
export interface VisualValueNode extends ValueNodeBase {
    nodeKind: VisualNodeKind.ValueNode;
}

```
