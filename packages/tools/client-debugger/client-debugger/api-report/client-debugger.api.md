## API Report File for "@fluid-tools/client-debugger"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AttachState } from '@fluidframework/container-definitions';
import { ConnectionState } from '@fluidframework/container-loader';
import { IAudience } from '@fluidframework/container-definitions';
import { IClient } from '@fluidframework/protocol-definitions';
import { IContainer } from '@fluidframework/container-definitions';
import { IDisposable } from '@fluidframework/common-definitions';
import { IEvent } from '@fluidframework/common-definitions';
import { IEventProvider } from '@fluidframework/common-definitions';
import { IFluidLoadable } from '@fluidframework/core-interfaces';
import { ITelemetryBaseEvent } from '@fluidframework/common-definitions';
import { ITelemetryBaseLogger } from '@fluidframework/common-definitions';
import { ITelemetryLoggerPropertyBags } from '@fluidframework/telemetry-utils';
import { TelemetryLogger } from '@fluidframework/telemetry-utils';
import { TypedEventEmitter } from '@fluidframework/common-utils';

// @internal
export interface AudienceChangeLogEntry extends LogEntry {
    changeKind: "added" | "removed";
    client: IClient;
    clientId: string;
}

// @internal
export function clearDebuggerRegistry(): void;

// @public
export interface CloseContainerMessage extends ISourcedDebuggerMessage<CloseContainerMessageData> {
    // (undocumented)
    type: "CLOSE_CONTAINER";
}

// @public
export type CloseContainerMessageData = HasContainerId;

// @public
export function closeFluidClientDebugger(containerId: string): void;

// @public
export interface ConnectContainerMessage extends ISourcedDebuggerMessage<ConnectContainerMessageData> {
    // (undocumented)
    type: "CONNECT_CONTAINER";
}

// @public
export type ConnectContainerMessageData = HasContainerId;

// Warning: (ae-incompatible-release-tags) The symbol "ConnectionStateChangeLogEntry" is marked as @public, but its signature references "StateChangeLogEntry" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "ConnectionStateChangeLogEntry" is marked as @public, but its signature references "ContainerStateChangeKind" which is marked as @internal
//
// @public
export interface ConnectionStateChangeLogEntry extends StateChangeLogEntry<ContainerStateChangeKind> {
    clientId: string | undefined;
}

// @public
export interface ContainerDataMessage extends ISourcedDebuggerMessage<ContainerDataMessageData> {
    // (undocumented)
    type: "CONTAINER_DATA";
}

// @public
export interface ContainerDataMessageData extends HasContainerId {
    containerData?: unknown;
}

// @public
export interface ContainerMetadata {
    id: string;
    nickname?: string;
}

// @internal
export enum ContainerStateChangeKind {
    Attached = "attached",
    Closed = "closed",
    Connected = "connected",
    Disconnected = "disconnected",
    Disposed = "disposed"
}

// @public
export interface ContainerStateChangeMessage extends ISourcedDebuggerMessage<ContainerStateChangeMessageData> {
    // (undocumented)
    type: "CONTAINER_STATE_CHANGE";
}

// @public
export interface ContainerStateChangeMessageData extends HasContainerId {
    containerState: ContainerStateMetadata;
}

// @public
export interface ContainerStateHistoryMessage extends ISourcedDebuggerMessage<ContainerStateHistoryMessageData> {
    // (undocumented)
    type: "CONTAINER_STATE_HISTORY";
}

// @public
export interface ContainerStateHistoryMessageData extends HasContainerId {
    history: ConnectionStateChangeLogEntry[];
}

// @public
export interface ContainerStateMetadata extends ContainerMetadata {
    // (undocumented)
    attachState: AttachState;
    audienceId?: string;
    // (undocumented)
    clientId?: string;
    closed: boolean;
    // (undocumented)
    connectionState: ConnectionState;
}

// @public
export const debuggerMessageSource: string;

// @internal
export class DebuggerRegistry extends TypedEventEmitter<DebuggerRegistryEvents> {
    constructor();
    closeDebugger(containerId: string): void;
    getRegisteredDebuggers(): Map<string, IFluidClientDebugger>;
    initializeDebugger(props: FluidClientDebuggerProps): void;
}

// @internal
export interface DebuggerRegistryEvents extends IEvent {
    // @eventProperty
    (event: "debuggerRegistered", listener: (containerId: string) => void): void;
    // @eventProperty
    (event: "debuggerClosed", listener: (containerId: string) => void): void;
}

// @public
export interface DisconnectContainerMessage extends ISourcedDebuggerMessage<DisconnectContainerMessageData> {
    // (undocumented)
    type: "DISCONNECT_CONTAINER";
}

// @public
export type DisconnectContainerMessageData = HasContainerId;

// @public
export interface FluidClientDebuggerProps {
    container: IContainer;
    containerData?: IFluidLoadable | Record<string, IFluidLoadable>;
    containerId: string;
    containerNickname?: string;
}

// @internal @sealed
export class FluidDebuggerLogger extends TelemetryLogger {
    static create(namespace?: string, properties?: ITelemetryLoggerPropertyBags): TelemetryLogger;
    static mixinLogger(namespace?: string, baseLogger?: ITelemetryBaseLogger, properties?: ITelemetryLoggerPropertyBags): TelemetryLogger;
    send(event: ITelemetryBaseEvent): void;
}

// @public
export interface GetContainerDataMessage extends ISourcedDebuggerMessage<HasContainerId> {
    // (undocumented)
    type: "GET_CONTAINER_DATA";
}

// @public
export interface GetContainerListMessage extends ISourcedDebuggerMessage<undefined> {
    // (undocumented)
    type: "GET_CONTAINER_LIST";
}

// @public
export interface GetContainerStateMessage extends ISourcedDebuggerMessage<HasContainerId> {
    // (undocumented)
    type: "GET_CONTAINER_STATE";
}

// @public
export type GetContainerStateMessageData = HasContainerId;

// @internal
export function getDebuggerRegistry(): DebuggerRegistry;

// @internal
export function getFluidClientDebugger(containerId: string): IFluidClientDebugger | undefined;

// @internal
export function getFluidClientDebuggers(): IFluidClientDebugger[];

// @internal
export function handleIncomingMessage(message: Partial<ISourcedDebuggerMessage>, handlers: InboundHandlers, loggingOptions?: MessageLoggingOptions): void;

// @internal
export function handleIncomingWindowMessage(event: MessageEvent<Partial<ISourcedDebuggerMessage>>, handlers: InboundHandlers, loggingOptions?: MessageLoggingOptions): void;

// @public
export interface HasContainerId {
    containerId: string;
}

// @public
export interface IDebuggerMessage<TData = unknown> {
    data: TData;
    type: string;
}

// @internal
export interface IFluidClientDebugger extends IEventProvider<IFluidClientDebuggerEvents>, IDisposable {
    readonly audience: IAudience;
    readonly container: IContainer;
    readonly containerData?: IFluidLoadable | Record<string, IFluidLoadable>;
    readonly containerId: string;
    readonly containerNickname?: string;
    dispose(): void;
    getAudienceHistory(): readonly AudienceChangeLogEntry[];
    getContainerConnectionLog(): readonly ConnectionStateChangeLogEntry[];
}

// @internal
export interface IFluidClientDebuggerEvents extends IEvent {
    (event: "disposed", listener: () => void): any;
}

// @internal
export interface IMessageRelay<TSend extends IDebuggerMessage = IDebuggerMessage, TReceive extends ISourcedDebuggerMessage = ISourcedDebuggerMessage> extends IEventProvider<IMessageRelayEvents<TReceive>> {
    postMessage: (message: TSend) => void;
}

// @internal
export interface IMessageRelayEvents<TMessage extends ISourcedDebuggerMessage = ISourcedDebuggerMessage> extends IEvent {
    (event: "message", listener: (message: TMessage) => void): any;
}

// @internal
export interface InboundHandlers {
    [type: string]: (message: ISourcedDebuggerMessage) => boolean;
}

// @public
export function initializeFluidClientDebugger(props: FluidClientDebuggerProps): void;

// @internal
export function isDebuggerMessage(value: Partial<ISourcedDebuggerMessage>): value is ISourcedDebuggerMessage;

// @public
export interface ISourcedDebuggerMessage<TData = unknown> extends IDebuggerMessage<TData> {
    source: string;
}

// @internal
export interface LogEntry {
    timestamp: number;
}

// @internal
export enum MemberChangeKind {
    Added = "Added",
    Removed = "Removed"
}

// @internal
export interface MessageLoggingOptions {
    context?: string;
}

// @internal
export function postMessageToWindow<TMessage extends ISourcedDebuggerMessage>(loggingOptions?: MessageLoggingOptions, ...messages: TMessage[]): void;

// @public
export interface RegistryChangeMessage extends ISourcedDebuggerMessage<RegistryChangeMessageData> {
    // (undocumented)
    type: "REGISTRY_CHANGE";
}

// @public
export interface RegistryChangeMessageData {
    containers: ContainerMetadata[];
}

// @internal
export interface StateChangeLogEntry<TState> extends LogEntry {
    newState: TState;
}

// @public
export interface TelemetryEventMessage extends ISourcedDebuggerMessage<TelemetryEventMessageData> {
    // (undocumented)
    type: "TELEMETRY_EVENT";
}

// @public
export interface TelemetryEventMessageData {
    contents: ITelemetryBaseEvent;
}

```
