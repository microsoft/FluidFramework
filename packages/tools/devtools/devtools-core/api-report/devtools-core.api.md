## API Report File for "@fluid-experimental/devtools-core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AttachState } from '@fluidframework/container-definitions';
import { ConnectionState } from '@fluidframework/container-loader';
import { IClient } from '@fluidframework/protocol-definitions';
import { IContainer } from '@fluidframework/container-definitions';
import { IDisposable } from '@fluidframework/core-interfaces';
import { IEvent } from '@fluidframework/core-interfaces';
import { IEventProvider } from '@fluidframework/core-interfaces';
import { IFluidLoadable } from '@fluidframework/core-interfaces';
import { ISharedObject } from '@fluidframework/shared-object-base';
import { ITelemetryBaseEvent } from '@fluidframework/core-interfaces';
import { ITelemetryBaseLogger } from '@fluidframework/core-interfaces';
import { Serializable } from '@fluidframework/datastore-definitions';

// @internal
export interface AudienceChangeLogEntry extends LogEntry {
    changeKind: "joined" | "left";
    client: IClient;
    clientId: string;
}

// @internal
export interface AudienceClientMetadata {
    client: IClient;
    clientId: string;
}

// @internal
export namespace AudienceSummary {
    const MessageType = "AUDIENCE_SUMMARY";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData extends HasContainerKey {
        audienceHistory: readonly AudienceChangeLogEntry[];
        audienceState: AudienceClientMetadata[];
        clientId: string | undefined;
    }
}

// @internal
export namespace CloseContainer {
    const MessageType = "CLOSE_CONTAINER";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export type MessageData = HasContainerKey;
}

// @internal
export namespace ConnectContainer {
    const MessageType = "CONNECT_CONTAINER";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export type MessageData = HasContainerKey;
}

// @internal
export interface ConnectionStateChangeLogEntry extends StateChangeLogEntry<ContainerStateChangeKind> {
    clientId: string | undefined;
}

// @internal
export interface ContainerDevtoolsFeatureFlags {
    // @deprecated
    "container-data"?: boolean;
    "containerDataEditing"?: boolean;
    "containerDataVisualization"?: boolean;
}

// @internal
export namespace ContainerDevtoolsFeatures {
    const MessageType = "CONTAINER_DEVTOOLS_FEATURES";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData extends HasContainerKey {
        features: ContainerDevtoolsFeatureFlags;
    }
}

// @internal
export interface ContainerDevtoolsProps extends HasContainerKey {
    container: IContainer;
    containerData?: Record<string, IFluidLoadable>;
}

// @internal
export type ContainerKey = string;

// @internal
export namespace ContainerList {
    const MessageType = "CONTAINER_LIST";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData {
        containers: ContainerKey[];
    }
}

// @internal
export namespace ContainerStateChange {
    const MessageType = "CONTAINER_STATE_CHANGE";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData extends HasContainerKey {
        containerState: ContainerStateMetadata;
    }
}

// @internal
export enum ContainerStateChangeKind {
    Attached = "attached",
    Closed = "closed",
    Connected = "connected",
    Disconnected = "disconnected",
    Disposed = "disposed"
}

// @internal
export namespace ContainerStateHistory {
    const MessageType = "CONTAINER_STATE_HISTORY";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData extends HasContainerKey {
        history: ConnectionStateChangeLogEntry[];
    }
}

// @internal
export interface ContainerStateMetadata extends HasContainerKey {
    // (undocumented)
    attachState: AttachState;
    // (undocumented)
    clientId?: string;
    closed: boolean;
    // (undocumented)
    connectionState: ConnectionState;
    userId?: string;
}

// @internal
export function createDevtoolsLogger(baseLogger?: ITelemetryBaseLogger): IDevtoolsLogger;

// @internal
export namespace DataEdit {
    const MessageType = "DATA_EDIT";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData extends HasContainerKey {
        edit: SharedObjectEdit;
    }
}

// @internal
export namespace DataVisualization {
    const MessageType = "DATA_VISUALIZATION";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData extends HasContainerKey, HasFluidObjectId {
        visualization: FluidObjectNode | undefined;
    }
}

// @internal
export namespace DevtoolsDisposed {
    const MessageType = "DEVTOOLS_DISPOSED";
    export function createMessage(): Message;
    export interface Message extends IDevtoolsMessage<undefined> {
        type: typeof MessageType;
    }
}

// @internal
export interface DevtoolsFeatureFlags {
    opLatencyTelemetry?: boolean;
    telemetry?: boolean;
}

// @internal
export namespace DevtoolsFeatures {
    const MessageType = "DEVTOOLS_FEATURES";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData {
        devtoolsVersion?: string;
        features: DevtoolsFeatureFlags;
    }
}

// @internal
export const devtoolsMessageSource: string;

// @internal
export namespace DisconnectContainer {
    const MessageType = "DISCONNECT_CONTAINER";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export type MessageData = HasContainerKey;
}

// @internal
export interface Edit {
    data: EditData;
    type?: EditType | string;
}

// @internal
export type EditData = Serializable<unknown> | null | undefined;

// @internal
export type EditSharedObject = (sharedObject: ISharedObject, edit: Edit) => Promise<void>;

// @internal
export const EditType: {
    readonly Boolean: "boolean";
    readonly Number: "number";
    readonly String: "string";
    readonly Undefined: "undefined";
    readonly Null: "null";
};

// @internal
export type EditType = (typeof EditType)[keyof typeof EditType];

// @internal
export interface FluidDevtoolsProps {
    initialContainers?: ContainerDevtoolsProps[];
    logger?: IDevtoolsLogger;
}

// @internal
export interface FluidHandleNode extends VisualNodeBase {
    fluidObjectId: string;
    nodeKind: VisualNodeKind.FluidHandleNode;
}

// @internal
export type FluidObjectId = string;

// @internal
export type FluidObjectNode = FluidObjectTreeNode | FluidObjectValueNode | FluidUnknownObjectNode;

// @internal
export interface FluidObjectNodeBase extends VisualNodeBase {
    fluidObjectId: FluidObjectId;
}

// @internal
export interface FluidObjectTreeNode extends TreeNodeBase, FluidObjectNodeBase {
    nodeKind: VisualNodeKind.FluidTreeNode;
}

// @internal
export interface FluidObjectValueNode extends ValueNodeBase, FluidObjectNodeBase {
    nodeKind: VisualNodeKind.FluidValueNode;
}

// @internal
export interface FluidUnknownObjectNode extends FluidObjectNodeBase {
    nodeKind: VisualNodeKind.FluidUnknownObjectNode;
}

// @internal
export namespace GetAudienceSummary {
    const MessageType = "GET_AUDIENCE_SUMMARY";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export type MessageData = HasContainerKey;
}

// @internal
export namespace GetContainerDevtoolsFeatures {
    const MessageType = "GET_CONTAINER_DEVTOOLS_FEATURES";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export type MessageData = HasContainerKey;
}

// @internal
export namespace GetContainerList {
    const MessageType = "GET_CONTAINER_LIST";
    export function createMessage(): Message;
    export interface Message extends IDevtoolsMessage<undefined> {
        type: typeof MessageType;
    }
}

// @internal
export namespace GetContainerState {
    const MessageType = "GET_CONTAINER_STATE";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<HasContainerKey> {
        type: typeof MessageType;
    }
    export type MessageData = HasContainerKey;
}

// @internal
export namespace GetDataVisualization {
    const MessageType = "GET_DATA_VISUALIZATION";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export type MessageData = HasContainerKey & HasFluidObjectId;
}

// @internal
export namespace GetDevtoolsFeatures {
    const MessageType = "GET_DEVTOOLS_FEATURES";
    export function createMessage(): Message;
    export interface Message extends IDevtoolsMessage<undefined> {
        type: typeof MessageType;
    }
}

// @internal
export namespace GetRootDataVisualizations {
    const MessageType = "GET_ROOT_DATA_VISUALIZATIONS";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export type MessageData = HasContainerKey;
}

// @internal
export namespace GetTelemetryHistory {
    const MessageType = "GET_TELEMETRY_HISTORY";
    export function createMessage(): Message;
    export interface Message extends IDevtoolsMessage<undefined> {
        type: typeof MessageType;
    }
}

// @internal
export function handleIncomingMessage(message: Partial<ISourcedDevtoolsMessage>, handlers: InboundHandlers, loggingOptions?: MessageLoggingOptions): void;

// @internal
export function handleIncomingWindowMessage(event: MessageEvent<Partial<ISourcedDevtoolsMessage>>, handlers: InboundHandlers, loggingOptions?: MessageLoggingOptions): void;

// @internal
export interface HasContainerKey {
    containerKey: ContainerKey;
}

// @internal
export interface HasFluidObjectId {
    fluidObjectId: FluidObjectId;
}

// @internal @sealed
export interface IDevtoolsLogger extends ITelemetryBaseLogger {
}

// @internal
export interface IDevtoolsMessage<TData = unknown> {
    data: TData;
    type: string;
}

// @internal
export interface IFluidDevtools extends IDisposable {
    closeContainerDevtools(containerKey: ContainerKey): void;
    registerContainerDevtools(props: ContainerDevtoolsProps): void;
}

// @internal
export interface IMessageRelay<TSend extends IDevtoolsMessage = IDevtoolsMessage, TReceive extends ISourcedDevtoolsMessage = ISourcedDevtoolsMessage> extends IEventProvider<IMessageRelayEvents<TReceive>> {
    postMessage<TPost extends TSend>(message: TPost): void;
}

// @internal
export interface IMessageRelayEvents<TMessage extends ISourcedDevtoolsMessage = ISourcedDevtoolsMessage> extends IEvent {
    (event: "message", listener: (message: TMessage) => void): any;
}

// @internal
export interface InboundHandlers {
    [type: string]: (message: ISourcedDevtoolsMessage) => Promise<boolean>;
}

// @internal
export function initializeDevtools(props?: FluidDevtoolsProps): IFluidDevtools;

// @internal
export function isDevtoolsMessage(value: Partial<ISourcedDevtoolsMessage>): value is ISourcedDevtoolsMessage;

// @internal
export interface ISourcedDevtoolsMessage<TData = unknown> extends IDevtoolsMessage<TData> {
    source: string;
}

// @internal
export interface ITimestampedTelemetryEvent {
    logContent: ITelemetryBaseEvent;
    timestamp: number;
}

// @internal
export interface LogEntry {
    timestamp: number;
}

// @internal
export enum MemberChangeKind {
    Joined = "Joined",
    Left = "Left"
}

// @internal
export interface MessageLoggingOptions {
    context?: string;
}

// @internal
export type Primitive = number | boolean | null | string | undefined;

// @internal
export namespace RootDataVisualizations {
    const MessageType = "ROOT_DATA_VISUALIZATIONS";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData extends HasContainerKey {
        visualizations: Record<string, RootHandleNode> | undefined;
    }
}

// @internal
export type RootHandleNode = FluidHandleNode | UnknownObjectNode;

// @internal
export interface SharedObjectEdit extends Edit, HasFluidObjectId {
}

// @internal
export interface StateChangeLogEntry<TState> extends LogEntry {
    newState: TState;
}

// @internal
export namespace TelemetryEvent {
    const MessageType = "TELEMETRY_EVENT";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData {
        event: ITimestampedTelemetryEvent;
    }
}

// @internal
export namespace TelemetryHistory {
    const MessageType = "TELEMETRY_HISTORY";
    export function createMessage(data: MessageData): Message;
    export interface Message extends IDevtoolsMessage<MessageData> {
        type: typeof MessageType;
    }
    export interface MessageData {
        contents: ITimestampedTelemetryEvent[];
    }
}

// @internal
export interface TreeNodeBase extends VisualNodeBase {
    children: Record<string, VisualChildNode>;
}

// @internal
export interface UnknownObjectNode extends VisualNodeBase {
    nodeKind: VisualNodeKind.UnknownObjectNode;
}

// @internal
export interface ValueNodeBase extends VisualNodeBase {
    value: Primitive;
}

// @internal
export type VisualChildNode = VisualTreeNode | VisualValueNode | FluidHandleNode | UnknownObjectNode;

// @internal
export type VisualNode = VisualTreeNode | VisualValueNode | FluidHandleNode | FluidObjectTreeNode | FluidObjectValueNode | FluidUnknownObjectNode | UnknownObjectNode;

// @internal
export interface VisualNodeBase {
    editProps?: {
        editTypes?: EditType[];
    };
    metadata?: Record<string, Primitive>;
    nodeKind: VisualNodeKind | string;
    typeMetadata?: string;
}

// @internal
export enum VisualNodeKind {
    // (undocumented)
    FluidHandleNode = "FluidHandleNode",
    // (undocumented)
    FluidTreeNode = "FluidTreeNode",
    // (undocumented)
    FluidUnknownObjectNode = "FluidUnknownObjectNode",
    // (undocumented)
    FluidValueNode = "FluidValueNode",
    // (undocumented)
    TreeNode = "TreeNode",
    // (undocumented)
    UnknownObjectNode = "UnknownObjectNode",
    // (undocumented)
    ValueNode = "ValueNode"
}

// @internal
export interface VisualTreeNode extends TreeNodeBase {
    nodeKind: VisualNodeKind.TreeNode;
}

// @internal
export interface VisualValueNode extends ValueNodeBase {
    nodeKind: VisualNodeKind.ValueNode;
}

```
