/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */
import * as old from "@fluid-experimental/devtools-core-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_AudienceChangeLogEntry": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_AudienceChangeLogEntry():
    TypeOnly<old.AudienceChangeLogEntry>;
declare function use_current_InterfaceDeclaration_AudienceChangeLogEntry(
    use: TypeOnly<current.AudienceChangeLogEntry>);
use_current_InterfaceDeclaration_AudienceChangeLogEntry(
    get_old_InterfaceDeclaration_AudienceChangeLogEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_AudienceChangeLogEntry": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_AudienceChangeLogEntry():
    TypeOnly<current.AudienceChangeLogEntry>;
declare function use_old_InterfaceDeclaration_AudienceChangeLogEntry(
    use: TypeOnly<old.AudienceChangeLogEntry>);
use_old_InterfaceDeclaration_AudienceChangeLogEntry(
    get_current_InterfaceDeclaration_AudienceChangeLogEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_AudienceClientMetadata": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_AudienceClientMetadata():
    TypeOnly<old.AudienceClientMetadata>;
declare function use_current_InterfaceDeclaration_AudienceClientMetadata(
    use: TypeOnly<current.AudienceClientMetadata>);
use_current_InterfaceDeclaration_AudienceClientMetadata(
    get_old_InterfaceDeclaration_AudienceClientMetadata());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_AudienceClientMetadata": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_AudienceClientMetadata():
    TypeOnly<current.AudienceClientMetadata>;
declare function use_old_InterfaceDeclaration_AudienceClientMetadata(
    use: TypeOnly<old.AudienceClientMetadata>);
use_old_InterfaceDeclaration_AudienceClientMetadata(
    get_current_InterfaceDeclaration_AudienceClientMetadata());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_AudienceSummary.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_AudienceSummary_Message():
    TypeOnly<old.AudienceSummary.Message>;
declare function use_current_InterfaceDeclaration_AudienceSummary_Message(
    use: TypeOnly<current.AudienceSummary.Message>);
use_current_InterfaceDeclaration_AudienceSummary_Message(
    get_old_InterfaceDeclaration_AudienceSummary_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_AudienceSummary.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_AudienceSummary_Message():
    TypeOnly<current.AudienceSummary.Message>;
declare function use_old_InterfaceDeclaration_AudienceSummary_Message(
    use: TypeOnly<old.AudienceSummary.Message>);
use_old_InterfaceDeclaration_AudienceSummary_Message(
    get_current_InterfaceDeclaration_AudienceSummary_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_AudienceSummary.MessageData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_AudienceSummary_MessageData():
    TypeOnly<old.AudienceSummary.MessageData>;
declare function use_current_InterfaceDeclaration_AudienceSummary_MessageData(
    use: TypeOnly<current.AudienceSummary.MessageData>);
use_current_InterfaceDeclaration_AudienceSummary_MessageData(
    get_old_InterfaceDeclaration_AudienceSummary_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_AudienceSummary.MessageData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_AudienceSummary_MessageData():
    TypeOnly<current.AudienceSummary.MessageData>;
declare function use_old_InterfaceDeclaration_AudienceSummary_MessageData(
    use: TypeOnly<old.AudienceSummary.MessageData>);
use_old_InterfaceDeclaration_AudienceSummary_MessageData(
    get_current_InterfaceDeclaration_AudienceSummary_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_AudienceSummary.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_AudienceSummary_MessageType():
    TypeOnly<typeof old.AudienceSummary.MessageType>;
declare function use_current_VariableDeclaration_AudienceSummary_MessageType(
    use: TypeOnly<typeof current.AudienceSummary.MessageType>);
use_current_VariableDeclaration_AudienceSummary_MessageType(
    get_old_VariableDeclaration_AudienceSummary_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_AudienceSummary.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_AudienceSummary_MessageType():
    TypeOnly<typeof current.AudienceSummary.MessageType>;
declare function use_old_VariableDeclaration_AudienceSummary_MessageType(
    use: TypeOnly<typeof old.AudienceSummary.MessageType>);
use_old_VariableDeclaration_AudienceSummary_MessageType(
    get_current_VariableDeclaration_AudienceSummary_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_AudienceSummary.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_AudienceSummary_createMessage():
    TypeOnly<typeof old.AudienceSummary.createMessage>;
declare function use_current_FunctionDeclaration_AudienceSummary_createMessage(
    use: TypeOnly<typeof current.AudienceSummary.createMessage>);
use_current_FunctionDeclaration_AudienceSummary_createMessage(
    get_old_FunctionDeclaration_AudienceSummary_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_AudienceSummary.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_AudienceSummary_createMessage():
    TypeOnly<typeof current.AudienceSummary.createMessage>;
declare function use_old_FunctionDeclaration_AudienceSummary_createMessage(
    use: TypeOnly<typeof old.AudienceSummary.createMessage>);
use_old_FunctionDeclaration_AudienceSummary_createMessage(
    get_current_FunctionDeclaration_AudienceSummary_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_CloseContainer.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_CloseContainer_Message():
    TypeOnly<old.CloseContainer.Message>;
declare function use_current_InterfaceDeclaration_CloseContainer_Message(
    use: TypeOnly<current.CloseContainer.Message>);
use_current_InterfaceDeclaration_CloseContainer_Message(
    get_old_InterfaceDeclaration_CloseContainer_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_CloseContainer.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_CloseContainer_Message():
    TypeOnly<current.CloseContainer.Message>;
declare function use_old_InterfaceDeclaration_CloseContainer_Message(
    use: TypeOnly<old.CloseContainer.Message>);
use_old_InterfaceDeclaration_CloseContainer_Message(
    get_current_InterfaceDeclaration_CloseContainer_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CloseContainer.MessageData": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_CloseContainer_MessageData():
    TypeOnly<old.CloseContainer.MessageData>;
declare function use_current_TypeAliasDeclaration_CloseContainer_MessageData(
    use: TypeOnly<current.CloseContainer.MessageData>);
use_current_TypeAliasDeclaration_CloseContainer_MessageData(
    get_old_TypeAliasDeclaration_CloseContainer_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CloseContainer.MessageData": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_CloseContainer_MessageData():
    TypeOnly<current.CloseContainer.MessageData>;
declare function use_old_TypeAliasDeclaration_CloseContainer_MessageData(
    use: TypeOnly<old.CloseContainer.MessageData>);
use_old_TypeAliasDeclaration_CloseContainer_MessageData(
    get_current_TypeAliasDeclaration_CloseContainer_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_CloseContainer.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_CloseContainer_MessageType():
    TypeOnly<typeof old.CloseContainer.MessageType>;
declare function use_current_VariableDeclaration_CloseContainer_MessageType(
    use: TypeOnly<typeof current.CloseContainer.MessageType>);
use_current_VariableDeclaration_CloseContainer_MessageType(
    get_old_VariableDeclaration_CloseContainer_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_CloseContainer.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_CloseContainer_MessageType():
    TypeOnly<typeof current.CloseContainer.MessageType>;
declare function use_old_VariableDeclaration_CloseContainer_MessageType(
    use: TypeOnly<typeof old.CloseContainer.MessageType>);
use_old_VariableDeclaration_CloseContainer_MessageType(
    get_current_VariableDeclaration_CloseContainer_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_CloseContainer.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_CloseContainer_createMessage():
    TypeOnly<typeof old.CloseContainer.createMessage>;
declare function use_current_FunctionDeclaration_CloseContainer_createMessage(
    use: TypeOnly<typeof current.CloseContainer.createMessage>);
use_current_FunctionDeclaration_CloseContainer_createMessage(
    get_old_FunctionDeclaration_CloseContainer_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_CloseContainer.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_CloseContainer_createMessage():
    TypeOnly<typeof current.CloseContainer.createMessage>;
declare function use_old_FunctionDeclaration_CloseContainer_createMessage(
    use: TypeOnly<typeof old.CloseContainer.createMessage>);
use_old_FunctionDeclaration_CloseContainer_createMessage(
    get_current_FunctionDeclaration_CloseContainer_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ConnectContainer.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ConnectContainer_Message():
    TypeOnly<old.ConnectContainer.Message>;
declare function use_current_InterfaceDeclaration_ConnectContainer_Message(
    use: TypeOnly<current.ConnectContainer.Message>);
use_current_InterfaceDeclaration_ConnectContainer_Message(
    get_old_InterfaceDeclaration_ConnectContainer_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ConnectContainer.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ConnectContainer_Message():
    TypeOnly<current.ConnectContainer.Message>;
declare function use_old_InterfaceDeclaration_ConnectContainer_Message(
    use: TypeOnly<old.ConnectContainer.Message>);
use_old_InterfaceDeclaration_ConnectContainer_Message(
    get_current_InterfaceDeclaration_ConnectContainer_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectContainer.MessageData": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConnectContainer_MessageData():
    TypeOnly<old.ConnectContainer.MessageData>;
declare function use_current_TypeAliasDeclaration_ConnectContainer_MessageData(
    use: TypeOnly<current.ConnectContainer.MessageData>);
use_current_TypeAliasDeclaration_ConnectContainer_MessageData(
    get_old_TypeAliasDeclaration_ConnectContainer_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConnectContainer.MessageData": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConnectContainer_MessageData():
    TypeOnly<current.ConnectContainer.MessageData>;
declare function use_old_TypeAliasDeclaration_ConnectContainer_MessageData(
    use: TypeOnly<old.ConnectContainer.MessageData>);
use_old_TypeAliasDeclaration_ConnectContainer_MessageData(
    get_current_TypeAliasDeclaration_ConnectContainer_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ConnectContainer.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_ConnectContainer_MessageType():
    TypeOnly<typeof old.ConnectContainer.MessageType>;
declare function use_current_VariableDeclaration_ConnectContainer_MessageType(
    use: TypeOnly<typeof current.ConnectContainer.MessageType>);
use_current_VariableDeclaration_ConnectContainer_MessageType(
    get_old_VariableDeclaration_ConnectContainer_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ConnectContainer.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_ConnectContainer_MessageType():
    TypeOnly<typeof current.ConnectContainer.MessageType>;
declare function use_old_VariableDeclaration_ConnectContainer_MessageType(
    use: TypeOnly<typeof old.ConnectContainer.MessageType>);
use_old_VariableDeclaration_ConnectContainer_MessageType(
    get_current_VariableDeclaration_ConnectContainer_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ConnectContainer.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_ConnectContainer_createMessage():
    TypeOnly<typeof old.ConnectContainer.createMessage>;
declare function use_current_FunctionDeclaration_ConnectContainer_createMessage(
    use: TypeOnly<typeof current.ConnectContainer.createMessage>);
use_current_FunctionDeclaration_ConnectContainer_createMessage(
    get_old_FunctionDeclaration_ConnectContainer_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ConnectContainer.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_ConnectContainer_createMessage():
    TypeOnly<typeof current.ConnectContainer.createMessage>;
declare function use_old_FunctionDeclaration_ConnectContainer_createMessage(
    use: TypeOnly<typeof old.ConnectContainer.createMessage>);
use_old_FunctionDeclaration_ConnectContainer_createMessage(
    get_current_FunctionDeclaration_ConnectContainer_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ConnectionStateChangeLogEntry": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ConnectionStateChangeLogEntry():
    TypeOnly<old.ConnectionStateChangeLogEntry>;
declare function use_current_InterfaceDeclaration_ConnectionStateChangeLogEntry(
    use: TypeOnly<current.ConnectionStateChangeLogEntry>);
use_current_InterfaceDeclaration_ConnectionStateChangeLogEntry(
    get_old_InterfaceDeclaration_ConnectionStateChangeLogEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ConnectionStateChangeLogEntry": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ConnectionStateChangeLogEntry():
    TypeOnly<current.ConnectionStateChangeLogEntry>;
declare function use_old_InterfaceDeclaration_ConnectionStateChangeLogEntry(
    use: TypeOnly<old.ConnectionStateChangeLogEntry>);
use_old_InterfaceDeclaration_ConnectionStateChangeLogEntry(
    get_current_InterfaceDeclaration_ConnectionStateChangeLogEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerDevtoolsFeatureFlags": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerDevtoolsFeatureFlags():
    TypeOnly<old.ContainerDevtoolsFeatureFlags>;
declare function use_current_InterfaceDeclaration_ContainerDevtoolsFeatureFlags(
    use: TypeOnly<current.ContainerDevtoolsFeatureFlags>);
use_current_InterfaceDeclaration_ContainerDevtoolsFeatureFlags(
    get_old_InterfaceDeclaration_ContainerDevtoolsFeatureFlags());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerDevtoolsFeatureFlags": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerDevtoolsFeatureFlags():
    TypeOnly<current.ContainerDevtoolsFeatureFlags>;
declare function use_old_InterfaceDeclaration_ContainerDevtoolsFeatureFlags(
    use: TypeOnly<old.ContainerDevtoolsFeatureFlags>);
use_old_InterfaceDeclaration_ContainerDevtoolsFeatureFlags(
    get_current_InterfaceDeclaration_ContainerDevtoolsFeatureFlags());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerDevtoolsFeatures.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerDevtoolsFeatures_Message():
    TypeOnly<old.ContainerDevtoolsFeatures.Message>;
declare function use_current_InterfaceDeclaration_ContainerDevtoolsFeatures_Message(
    use: TypeOnly<current.ContainerDevtoolsFeatures.Message>);
use_current_InterfaceDeclaration_ContainerDevtoolsFeatures_Message(
    get_old_InterfaceDeclaration_ContainerDevtoolsFeatures_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerDevtoolsFeatures.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerDevtoolsFeatures_Message():
    TypeOnly<current.ContainerDevtoolsFeatures.Message>;
declare function use_old_InterfaceDeclaration_ContainerDevtoolsFeatures_Message(
    use: TypeOnly<old.ContainerDevtoolsFeatures.Message>);
use_old_InterfaceDeclaration_ContainerDevtoolsFeatures_Message(
    get_current_InterfaceDeclaration_ContainerDevtoolsFeatures_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerDevtoolsFeatures.MessageData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerDevtoolsFeatures_MessageData():
    TypeOnly<old.ContainerDevtoolsFeatures.MessageData>;
declare function use_current_InterfaceDeclaration_ContainerDevtoolsFeatures_MessageData(
    use: TypeOnly<current.ContainerDevtoolsFeatures.MessageData>);
use_current_InterfaceDeclaration_ContainerDevtoolsFeatures_MessageData(
    get_old_InterfaceDeclaration_ContainerDevtoolsFeatures_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerDevtoolsFeatures.MessageData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerDevtoolsFeatures_MessageData():
    TypeOnly<current.ContainerDevtoolsFeatures.MessageData>;
declare function use_old_InterfaceDeclaration_ContainerDevtoolsFeatures_MessageData(
    use: TypeOnly<old.ContainerDevtoolsFeatures.MessageData>);
use_old_InterfaceDeclaration_ContainerDevtoolsFeatures_MessageData(
    get_current_InterfaceDeclaration_ContainerDevtoolsFeatures_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ContainerDevtoolsFeatures.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_ContainerDevtoolsFeatures_MessageType():
    TypeOnly<typeof old.ContainerDevtoolsFeatures.MessageType>;
declare function use_current_VariableDeclaration_ContainerDevtoolsFeatures_MessageType(
    use: TypeOnly<typeof current.ContainerDevtoolsFeatures.MessageType>);
use_current_VariableDeclaration_ContainerDevtoolsFeatures_MessageType(
    get_old_VariableDeclaration_ContainerDevtoolsFeatures_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ContainerDevtoolsFeatures.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_ContainerDevtoolsFeatures_MessageType():
    TypeOnly<typeof current.ContainerDevtoolsFeatures.MessageType>;
declare function use_old_VariableDeclaration_ContainerDevtoolsFeatures_MessageType(
    use: TypeOnly<typeof old.ContainerDevtoolsFeatures.MessageType>);
use_old_VariableDeclaration_ContainerDevtoolsFeatures_MessageType(
    get_current_VariableDeclaration_ContainerDevtoolsFeatures_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ContainerDevtoolsFeatures.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_ContainerDevtoolsFeatures_createMessage():
    TypeOnly<typeof old.ContainerDevtoolsFeatures.createMessage>;
declare function use_current_FunctionDeclaration_ContainerDevtoolsFeatures_createMessage(
    use: TypeOnly<typeof current.ContainerDevtoolsFeatures.createMessage>);
use_current_FunctionDeclaration_ContainerDevtoolsFeatures_createMessage(
    get_old_FunctionDeclaration_ContainerDevtoolsFeatures_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ContainerDevtoolsFeatures.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_ContainerDevtoolsFeatures_createMessage():
    TypeOnly<typeof current.ContainerDevtoolsFeatures.createMessage>;
declare function use_old_FunctionDeclaration_ContainerDevtoolsFeatures_createMessage(
    use: TypeOnly<typeof old.ContainerDevtoolsFeatures.createMessage>);
use_old_FunctionDeclaration_ContainerDevtoolsFeatures_createMessage(
    get_current_FunctionDeclaration_ContainerDevtoolsFeatures_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerDevtoolsProps": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerDevtoolsProps():
    TypeOnly<old.ContainerDevtoolsProps>;
declare function use_current_InterfaceDeclaration_ContainerDevtoolsProps(
    use: TypeOnly<current.ContainerDevtoolsProps>);
use_current_InterfaceDeclaration_ContainerDevtoolsProps(
    get_old_InterfaceDeclaration_ContainerDevtoolsProps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerDevtoolsProps": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerDevtoolsProps():
    TypeOnly<current.ContainerDevtoolsProps>;
declare function use_old_InterfaceDeclaration_ContainerDevtoolsProps(
    use: TypeOnly<old.ContainerDevtoolsProps>);
use_old_InterfaceDeclaration_ContainerDevtoolsProps(
    get_current_InterfaceDeclaration_ContainerDevtoolsProps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ContainerKey": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ContainerKey():
    TypeOnly<old.ContainerKey>;
declare function use_current_TypeAliasDeclaration_ContainerKey(
    use: TypeOnly<current.ContainerKey>);
use_current_TypeAliasDeclaration_ContainerKey(
    get_old_TypeAliasDeclaration_ContainerKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ContainerKey": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ContainerKey():
    TypeOnly<current.ContainerKey>;
declare function use_old_TypeAliasDeclaration_ContainerKey(
    use: TypeOnly<old.ContainerKey>);
use_old_TypeAliasDeclaration_ContainerKey(
    get_current_TypeAliasDeclaration_ContainerKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerList.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerList_Message():
    TypeOnly<old.ContainerList.Message>;
declare function use_current_InterfaceDeclaration_ContainerList_Message(
    use: TypeOnly<current.ContainerList.Message>);
use_current_InterfaceDeclaration_ContainerList_Message(
    get_old_InterfaceDeclaration_ContainerList_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerList.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerList_Message():
    TypeOnly<current.ContainerList.Message>;
declare function use_old_InterfaceDeclaration_ContainerList_Message(
    use: TypeOnly<old.ContainerList.Message>);
use_old_InterfaceDeclaration_ContainerList_Message(
    get_current_InterfaceDeclaration_ContainerList_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerList.MessageData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerList_MessageData():
    TypeOnly<old.ContainerList.MessageData>;
declare function use_current_InterfaceDeclaration_ContainerList_MessageData(
    use: TypeOnly<current.ContainerList.MessageData>);
use_current_InterfaceDeclaration_ContainerList_MessageData(
    get_old_InterfaceDeclaration_ContainerList_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerList.MessageData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerList_MessageData():
    TypeOnly<current.ContainerList.MessageData>;
declare function use_old_InterfaceDeclaration_ContainerList_MessageData(
    use: TypeOnly<old.ContainerList.MessageData>);
use_old_InterfaceDeclaration_ContainerList_MessageData(
    get_current_InterfaceDeclaration_ContainerList_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ContainerList.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_ContainerList_MessageType():
    TypeOnly<typeof old.ContainerList.MessageType>;
declare function use_current_VariableDeclaration_ContainerList_MessageType(
    use: TypeOnly<typeof current.ContainerList.MessageType>);
use_current_VariableDeclaration_ContainerList_MessageType(
    get_old_VariableDeclaration_ContainerList_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ContainerList.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_ContainerList_MessageType():
    TypeOnly<typeof current.ContainerList.MessageType>;
declare function use_old_VariableDeclaration_ContainerList_MessageType(
    use: TypeOnly<typeof old.ContainerList.MessageType>);
use_old_VariableDeclaration_ContainerList_MessageType(
    get_current_VariableDeclaration_ContainerList_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ContainerList.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_ContainerList_createMessage():
    TypeOnly<typeof old.ContainerList.createMessage>;
declare function use_current_FunctionDeclaration_ContainerList_createMessage(
    use: TypeOnly<typeof current.ContainerList.createMessage>);
use_current_FunctionDeclaration_ContainerList_createMessage(
    get_old_FunctionDeclaration_ContainerList_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ContainerList.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_ContainerList_createMessage():
    TypeOnly<typeof current.ContainerList.createMessage>;
declare function use_old_FunctionDeclaration_ContainerList_createMessage(
    use: TypeOnly<typeof old.ContainerList.createMessage>);
use_old_FunctionDeclaration_ContainerList_createMessage(
    get_current_FunctionDeclaration_ContainerList_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerStateChange.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerStateChange_Message():
    TypeOnly<old.ContainerStateChange.Message>;
declare function use_current_InterfaceDeclaration_ContainerStateChange_Message(
    use: TypeOnly<current.ContainerStateChange.Message>);
use_current_InterfaceDeclaration_ContainerStateChange_Message(
    get_old_InterfaceDeclaration_ContainerStateChange_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerStateChange.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerStateChange_Message():
    TypeOnly<current.ContainerStateChange.Message>;
declare function use_old_InterfaceDeclaration_ContainerStateChange_Message(
    use: TypeOnly<old.ContainerStateChange.Message>);
use_old_InterfaceDeclaration_ContainerStateChange_Message(
    get_current_InterfaceDeclaration_ContainerStateChange_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerStateChange.MessageData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerStateChange_MessageData():
    TypeOnly<old.ContainerStateChange.MessageData>;
declare function use_current_InterfaceDeclaration_ContainerStateChange_MessageData(
    use: TypeOnly<current.ContainerStateChange.MessageData>);
use_current_InterfaceDeclaration_ContainerStateChange_MessageData(
    get_old_InterfaceDeclaration_ContainerStateChange_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerStateChange.MessageData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerStateChange_MessageData():
    TypeOnly<current.ContainerStateChange.MessageData>;
declare function use_old_InterfaceDeclaration_ContainerStateChange_MessageData(
    use: TypeOnly<old.ContainerStateChange.MessageData>);
use_old_InterfaceDeclaration_ContainerStateChange_MessageData(
    get_current_InterfaceDeclaration_ContainerStateChange_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ContainerStateChange.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_ContainerStateChange_MessageType():
    TypeOnly<typeof old.ContainerStateChange.MessageType>;
declare function use_current_VariableDeclaration_ContainerStateChange_MessageType(
    use: TypeOnly<typeof current.ContainerStateChange.MessageType>);
use_current_VariableDeclaration_ContainerStateChange_MessageType(
    get_old_VariableDeclaration_ContainerStateChange_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ContainerStateChange.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_ContainerStateChange_MessageType():
    TypeOnly<typeof current.ContainerStateChange.MessageType>;
declare function use_old_VariableDeclaration_ContainerStateChange_MessageType(
    use: TypeOnly<typeof old.ContainerStateChange.MessageType>);
use_old_VariableDeclaration_ContainerStateChange_MessageType(
    get_current_VariableDeclaration_ContainerStateChange_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ContainerStateChange.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_ContainerStateChange_createMessage():
    TypeOnly<typeof old.ContainerStateChange.createMessage>;
declare function use_current_FunctionDeclaration_ContainerStateChange_createMessage(
    use: TypeOnly<typeof current.ContainerStateChange.createMessage>);
use_current_FunctionDeclaration_ContainerStateChange_createMessage(
    get_old_FunctionDeclaration_ContainerStateChange_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ContainerStateChange.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_ContainerStateChange_createMessage():
    TypeOnly<typeof current.ContainerStateChange.createMessage>;
declare function use_old_FunctionDeclaration_ContainerStateChange_createMessage(
    use: TypeOnly<typeof old.ContainerStateChange.createMessage>);
use_old_FunctionDeclaration_ContainerStateChange_createMessage(
    get_current_FunctionDeclaration_ContainerStateChange_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ContainerStateChangeKind": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_ContainerStateChangeKind():
    TypeOnly<old.ContainerStateChangeKind>;
declare function use_current_EnumDeclaration_ContainerStateChangeKind(
    use: TypeOnly<current.ContainerStateChangeKind>);
use_current_EnumDeclaration_ContainerStateChangeKind(
    get_old_EnumDeclaration_ContainerStateChangeKind());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ContainerStateChangeKind": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_ContainerStateChangeKind():
    TypeOnly<current.ContainerStateChangeKind>;
declare function use_old_EnumDeclaration_ContainerStateChangeKind(
    use: TypeOnly<old.ContainerStateChangeKind>);
use_old_EnumDeclaration_ContainerStateChangeKind(
    get_current_EnumDeclaration_ContainerStateChangeKind());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerStateHistory.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerStateHistory_Message():
    TypeOnly<old.ContainerStateHistory.Message>;
declare function use_current_InterfaceDeclaration_ContainerStateHistory_Message(
    use: TypeOnly<current.ContainerStateHistory.Message>);
use_current_InterfaceDeclaration_ContainerStateHistory_Message(
    get_old_InterfaceDeclaration_ContainerStateHistory_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerStateHistory.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerStateHistory_Message():
    TypeOnly<current.ContainerStateHistory.Message>;
declare function use_old_InterfaceDeclaration_ContainerStateHistory_Message(
    use: TypeOnly<old.ContainerStateHistory.Message>);
use_old_InterfaceDeclaration_ContainerStateHistory_Message(
    get_current_InterfaceDeclaration_ContainerStateHistory_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerStateHistory.MessageData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerStateHistory_MessageData():
    TypeOnly<old.ContainerStateHistory.MessageData>;
declare function use_current_InterfaceDeclaration_ContainerStateHistory_MessageData(
    use: TypeOnly<current.ContainerStateHistory.MessageData>);
use_current_InterfaceDeclaration_ContainerStateHistory_MessageData(
    get_old_InterfaceDeclaration_ContainerStateHistory_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerStateHistory.MessageData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerStateHistory_MessageData():
    TypeOnly<current.ContainerStateHistory.MessageData>;
declare function use_old_InterfaceDeclaration_ContainerStateHistory_MessageData(
    use: TypeOnly<old.ContainerStateHistory.MessageData>);
use_old_InterfaceDeclaration_ContainerStateHistory_MessageData(
    get_current_InterfaceDeclaration_ContainerStateHistory_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ContainerStateHistory.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_ContainerStateHistory_MessageType():
    TypeOnly<typeof old.ContainerStateHistory.MessageType>;
declare function use_current_VariableDeclaration_ContainerStateHistory_MessageType(
    use: TypeOnly<typeof current.ContainerStateHistory.MessageType>);
use_current_VariableDeclaration_ContainerStateHistory_MessageType(
    get_old_VariableDeclaration_ContainerStateHistory_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ContainerStateHistory.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_ContainerStateHistory_MessageType():
    TypeOnly<typeof current.ContainerStateHistory.MessageType>;
declare function use_old_VariableDeclaration_ContainerStateHistory_MessageType(
    use: TypeOnly<typeof old.ContainerStateHistory.MessageType>);
use_old_VariableDeclaration_ContainerStateHistory_MessageType(
    get_current_VariableDeclaration_ContainerStateHistory_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ContainerStateHistory.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_ContainerStateHistory_createMessage():
    TypeOnly<typeof old.ContainerStateHistory.createMessage>;
declare function use_current_FunctionDeclaration_ContainerStateHistory_createMessage(
    use: TypeOnly<typeof current.ContainerStateHistory.createMessage>);
use_current_FunctionDeclaration_ContainerStateHistory_createMessage(
    get_old_FunctionDeclaration_ContainerStateHistory_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ContainerStateHistory.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_ContainerStateHistory_createMessage():
    TypeOnly<typeof current.ContainerStateHistory.createMessage>;
declare function use_old_FunctionDeclaration_ContainerStateHistory_createMessage(
    use: TypeOnly<typeof old.ContainerStateHistory.createMessage>);
use_old_FunctionDeclaration_ContainerStateHistory_createMessage(
    get_current_FunctionDeclaration_ContainerStateHistory_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerStateMetadata": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerStateMetadata():
    TypeOnly<old.ContainerStateMetadata>;
declare function use_current_InterfaceDeclaration_ContainerStateMetadata(
    use: TypeOnly<current.ContainerStateMetadata>);
use_current_InterfaceDeclaration_ContainerStateMetadata(
    get_old_InterfaceDeclaration_ContainerStateMetadata());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerStateMetadata": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerStateMetadata():
    TypeOnly<current.ContainerStateMetadata>;
declare function use_old_InterfaceDeclaration_ContainerStateMetadata(
    use: TypeOnly<old.ContainerStateMetadata>);
use_old_InterfaceDeclaration_ContainerStateMetadata(
    get_current_InterfaceDeclaration_ContainerStateMetadata());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DataEdit.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_DataEdit_Message():
    TypeOnly<old.DataEdit.Message>;
declare function use_current_InterfaceDeclaration_DataEdit_Message(
    use: TypeOnly<current.DataEdit.Message>);
use_current_InterfaceDeclaration_DataEdit_Message(
    get_old_InterfaceDeclaration_DataEdit_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DataEdit.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_DataEdit_Message():
    TypeOnly<current.DataEdit.Message>;
declare function use_old_InterfaceDeclaration_DataEdit_Message(
    use: TypeOnly<old.DataEdit.Message>);
use_old_InterfaceDeclaration_DataEdit_Message(
    get_current_InterfaceDeclaration_DataEdit_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DataEdit.MessageData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_DataEdit_MessageData():
    TypeOnly<old.DataEdit.MessageData>;
declare function use_current_InterfaceDeclaration_DataEdit_MessageData(
    use: TypeOnly<current.DataEdit.MessageData>);
use_current_InterfaceDeclaration_DataEdit_MessageData(
    get_old_InterfaceDeclaration_DataEdit_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DataEdit.MessageData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_DataEdit_MessageData():
    TypeOnly<current.DataEdit.MessageData>;
declare function use_old_InterfaceDeclaration_DataEdit_MessageData(
    use: TypeOnly<old.DataEdit.MessageData>);
use_old_InterfaceDeclaration_DataEdit_MessageData(
    get_current_InterfaceDeclaration_DataEdit_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DataEdit.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_DataEdit_MessageType():
    TypeOnly<typeof old.DataEdit.MessageType>;
declare function use_current_VariableDeclaration_DataEdit_MessageType(
    use: TypeOnly<typeof current.DataEdit.MessageType>);
use_current_VariableDeclaration_DataEdit_MessageType(
    get_old_VariableDeclaration_DataEdit_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DataEdit.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_DataEdit_MessageType():
    TypeOnly<typeof current.DataEdit.MessageType>;
declare function use_old_VariableDeclaration_DataEdit_MessageType(
    use: TypeOnly<typeof old.DataEdit.MessageType>);
use_old_VariableDeclaration_DataEdit_MessageType(
    get_current_VariableDeclaration_DataEdit_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_DataEdit.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_DataEdit_createMessage():
    TypeOnly<typeof old.DataEdit.createMessage>;
declare function use_current_FunctionDeclaration_DataEdit_createMessage(
    use: TypeOnly<typeof current.DataEdit.createMessage>);
use_current_FunctionDeclaration_DataEdit_createMessage(
    get_old_FunctionDeclaration_DataEdit_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_DataEdit.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_DataEdit_createMessage():
    TypeOnly<typeof current.DataEdit.createMessage>;
declare function use_old_FunctionDeclaration_DataEdit_createMessage(
    use: TypeOnly<typeof old.DataEdit.createMessage>);
use_old_FunctionDeclaration_DataEdit_createMessage(
    get_current_FunctionDeclaration_DataEdit_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DataVisualization.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_DataVisualization_Message():
    TypeOnly<old.DataVisualization.Message>;
declare function use_current_InterfaceDeclaration_DataVisualization_Message(
    use: TypeOnly<current.DataVisualization.Message>);
use_current_InterfaceDeclaration_DataVisualization_Message(
    get_old_InterfaceDeclaration_DataVisualization_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DataVisualization.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_DataVisualization_Message():
    TypeOnly<current.DataVisualization.Message>;
declare function use_old_InterfaceDeclaration_DataVisualization_Message(
    use: TypeOnly<old.DataVisualization.Message>);
use_old_InterfaceDeclaration_DataVisualization_Message(
    get_current_InterfaceDeclaration_DataVisualization_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DataVisualization.MessageData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_DataVisualization_MessageData():
    TypeOnly<old.DataVisualization.MessageData>;
declare function use_current_InterfaceDeclaration_DataVisualization_MessageData(
    use: TypeOnly<current.DataVisualization.MessageData>);
use_current_InterfaceDeclaration_DataVisualization_MessageData(
    get_old_InterfaceDeclaration_DataVisualization_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DataVisualization.MessageData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_DataVisualization_MessageData():
    TypeOnly<current.DataVisualization.MessageData>;
declare function use_old_InterfaceDeclaration_DataVisualization_MessageData(
    use: TypeOnly<old.DataVisualization.MessageData>);
use_old_InterfaceDeclaration_DataVisualization_MessageData(
    get_current_InterfaceDeclaration_DataVisualization_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DataVisualization.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_DataVisualization_MessageType():
    TypeOnly<typeof old.DataVisualization.MessageType>;
declare function use_current_VariableDeclaration_DataVisualization_MessageType(
    use: TypeOnly<typeof current.DataVisualization.MessageType>);
use_current_VariableDeclaration_DataVisualization_MessageType(
    get_old_VariableDeclaration_DataVisualization_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DataVisualization.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_DataVisualization_MessageType():
    TypeOnly<typeof current.DataVisualization.MessageType>;
declare function use_old_VariableDeclaration_DataVisualization_MessageType(
    use: TypeOnly<typeof old.DataVisualization.MessageType>);
use_old_VariableDeclaration_DataVisualization_MessageType(
    get_current_VariableDeclaration_DataVisualization_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_DataVisualization.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_DataVisualization_createMessage():
    TypeOnly<typeof old.DataVisualization.createMessage>;
declare function use_current_FunctionDeclaration_DataVisualization_createMessage(
    use: TypeOnly<typeof current.DataVisualization.createMessage>);
use_current_FunctionDeclaration_DataVisualization_createMessage(
    get_old_FunctionDeclaration_DataVisualization_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_DataVisualization.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_DataVisualization_createMessage():
    TypeOnly<typeof current.DataVisualization.createMessage>;
declare function use_old_FunctionDeclaration_DataVisualization_createMessage(
    use: TypeOnly<typeof old.DataVisualization.createMessage>);
use_old_FunctionDeclaration_DataVisualization_createMessage(
    get_current_FunctionDeclaration_DataVisualization_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DevtoolsDisposed.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_DevtoolsDisposed_Message():
    TypeOnly<old.DevtoolsDisposed.Message>;
declare function use_current_InterfaceDeclaration_DevtoolsDisposed_Message(
    use: TypeOnly<current.DevtoolsDisposed.Message>);
use_current_InterfaceDeclaration_DevtoolsDisposed_Message(
    get_old_InterfaceDeclaration_DevtoolsDisposed_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DevtoolsDisposed.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_DevtoolsDisposed_Message():
    TypeOnly<current.DevtoolsDisposed.Message>;
declare function use_old_InterfaceDeclaration_DevtoolsDisposed_Message(
    use: TypeOnly<old.DevtoolsDisposed.Message>);
use_old_InterfaceDeclaration_DevtoolsDisposed_Message(
    get_current_InterfaceDeclaration_DevtoolsDisposed_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DevtoolsDisposed.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_DevtoolsDisposed_MessageType():
    TypeOnly<typeof old.DevtoolsDisposed.MessageType>;
declare function use_current_VariableDeclaration_DevtoolsDisposed_MessageType(
    use: TypeOnly<typeof current.DevtoolsDisposed.MessageType>);
use_current_VariableDeclaration_DevtoolsDisposed_MessageType(
    get_old_VariableDeclaration_DevtoolsDisposed_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DevtoolsDisposed.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_DevtoolsDisposed_MessageType():
    TypeOnly<typeof current.DevtoolsDisposed.MessageType>;
declare function use_old_VariableDeclaration_DevtoolsDisposed_MessageType(
    use: TypeOnly<typeof old.DevtoolsDisposed.MessageType>);
use_old_VariableDeclaration_DevtoolsDisposed_MessageType(
    get_current_VariableDeclaration_DevtoolsDisposed_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_DevtoolsDisposed.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_DevtoolsDisposed_createMessage():
    TypeOnly<typeof old.DevtoolsDisposed.createMessage>;
declare function use_current_FunctionDeclaration_DevtoolsDisposed_createMessage(
    use: TypeOnly<typeof current.DevtoolsDisposed.createMessage>);
use_current_FunctionDeclaration_DevtoolsDisposed_createMessage(
    get_old_FunctionDeclaration_DevtoolsDisposed_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_DevtoolsDisposed.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_DevtoolsDisposed_createMessage():
    TypeOnly<typeof current.DevtoolsDisposed.createMessage>;
declare function use_old_FunctionDeclaration_DevtoolsDisposed_createMessage(
    use: TypeOnly<typeof old.DevtoolsDisposed.createMessage>);
use_old_FunctionDeclaration_DevtoolsDisposed_createMessage(
    get_current_FunctionDeclaration_DevtoolsDisposed_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DevtoolsFeatureFlags": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_DevtoolsFeatureFlags():
    TypeOnly<old.DevtoolsFeatureFlags>;
declare function use_current_InterfaceDeclaration_DevtoolsFeatureFlags(
    use: TypeOnly<current.DevtoolsFeatureFlags>);
use_current_InterfaceDeclaration_DevtoolsFeatureFlags(
    get_old_InterfaceDeclaration_DevtoolsFeatureFlags());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DevtoolsFeatureFlags": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_DevtoolsFeatureFlags():
    TypeOnly<current.DevtoolsFeatureFlags>;
declare function use_old_InterfaceDeclaration_DevtoolsFeatureFlags(
    use: TypeOnly<old.DevtoolsFeatureFlags>);
use_old_InterfaceDeclaration_DevtoolsFeatureFlags(
    get_current_InterfaceDeclaration_DevtoolsFeatureFlags());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DevtoolsFeatures.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_DevtoolsFeatures_Message():
    TypeOnly<old.DevtoolsFeatures.Message>;
declare function use_current_InterfaceDeclaration_DevtoolsFeatures_Message(
    use: TypeOnly<current.DevtoolsFeatures.Message>);
use_current_InterfaceDeclaration_DevtoolsFeatures_Message(
    get_old_InterfaceDeclaration_DevtoolsFeatures_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DevtoolsFeatures.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_DevtoolsFeatures_Message():
    TypeOnly<current.DevtoolsFeatures.Message>;
declare function use_old_InterfaceDeclaration_DevtoolsFeatures_Message(
    use: TypeOnly<old.DevtoolsFeatures.Message>);
use_old_InterfaceDeclaration_DevtoolsFeatures_Message(
    get_current_InterfaceDeclaration_DevtoolsFeatures_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DevtoolsFeatures.MessageData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_DevtoolsFeatures_MessageData():
    TypeOnly<old.DevtoolsFeatures.MessageData>;
declare function use_current_InterfaceDeclaration_DevtoolsFeatures_MessageData(
    use: TypeOnly<current.DevtoolsFeatures.MessageData>);
use_current_InterfaceDeclaration_DevtoolsFeatures_MessageData(
    get_old_InterfaceDeclaration_DevtoolsFeatures_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DevtoolsFeatures.MessageData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_DevtoolsFeatures_MessageData():
    TypeOnly<current.DevtoolsFeatures.MessageData>;
declare function use_old_InterfaceDeclaration_DevtoolsFeatures_MessageData(
    use: TypeOnly<old.DevtoolsFeatures.MessageData>);
use_old_InterfaceDeclaration_DevtoolsFeatures_MessageData(
    get_current_InterfaceDeclaration_DevtoolsFeatures_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DevtoolsFeatures.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_DevtoolsFeatures_MessageType():
    TypeOnly<typeof old.DevtoolsFeatures.MessageType>;
declare function use_current_VariableDeclaration_DevtoolsFeatures_MessageType(
    use: TypeOnly<typeof current.DevtoolsFeatures.MessageType>);
use_current_VariableDeclaration_DevtoolsFeatures_MessageType(
    get_old_VariableDeclaration_DevtoolsFeatures_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DevtoolsFeatures.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_DevtoolsFeatures_MessageType():
    TypeOnly<typeof current.DevtoolsFeatures.MessageType>;
declare function use_old_VariableDeclaration_DevtoolsFeatures_MessageType(
    use: TypeOnly<typeof old.DevtoolsFeatures.MessageType>);
use_old_VariableDeclaration_DevtoolsFeatures_MessageType(
    get_current_VariableDeclaration_DevtoolsFeatures_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_DevtoolsFeatures.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_DevtoolsFeatures_createMessage():
    TypeOnly<typeof old.DevtoolsFeatures.createMessage>;
declare function use_current_FunctionDeclaration_DevtoolsFeatures_createMessage(
    use: TypeOnly<typeof current.DevtoolsFeatures.createMessage>);
use_current_FunctionDeclaration_DevtoolsFeatures_createMessage(
    get_old_FunctionDeclaration_DevtoolsFeatures_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_DevtoolsFeatures.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_DevtoolsFeatures_createMessage():
    TypeOnly<typeof current.DevtoolsFeatures.createMessage>;
declare function use_old_FunctionDeclaration_DevtoolsFeatures_createMessage(
    use: TypeOnly<typeof old.DevtoolsFeatures.createMessage>);
use_old_FunctionDeclaration_DevtoolsFeatures_createMessage(
    get_current_FunctionDeclaration_DevtoolsFeatures_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DevtoolsLogger": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DevtoolsLogger():
    TypeOnly<old.DevtoolsLogger>;
declare function use_current_ClassDeclaration_DevtoolsLogger(
    use: TypeOnly<current.DevtoolsLogger>);
use_current_ClassDeclaration_DevtoolsLogger(
    get_old_ClassDeclaration_DevtoolsLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DevtoolsLogger": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DevtoolsLogger():
    TypeOnly<current.DevtoolsLogger>;
declare function use_old_ClassDeclaration_DevtoolsLogger(
    use: TypeOnly<old.DevtoolsLogger>);
use_old_ClassDeclaration_DevtoolsLogger(
    get_current_ClassDeclaration_DevtoolsLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DisconnectContainer.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_DisconnectContainer_Message():
    TypeOnly<old.DisconnectContainer.Message>;
declare function use_current_InterfaceDeclaration_DisconnectContainer_Message(
    use: TypeOnly<current.DisconnectContainer.Message>);
use_current_InterfaceDeclaration_DisconnectContainer_Message(
    get_old_InterfaceDeclaration_DisconnectContainer_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DisconnectContainer.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_DisconnectContainer_Message():
    TypeOnly<current.DisconnectContainer.Message>;
declare function use_old_InterfaceDeclaration_DisconnectContainer_Message(
    use: TypeOnly<old.DisconnectContainer.Message>);
use_old_InterfaceDeclaration_DisconnectContainer_Message(
    get_current_InterfaceDeclaration_DisconnectContainer_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_DisconnectContainer.MessageData": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_DisconnectContainer_MessageData():
    TypeOnly<old.DisconnectContainer.MessageData>;
declare function use_current_TypeAliasDeclaration_DisconnectContainer_MessageData(
    use: TypeOnly<current.DisconnectContainer.MessageData>);
use_current_TypeAliasDeclaration_DisconnectContainer_MessageData(
    get_old_TypeAliasDeclaration_DisconnectContainer_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_DisconnectContainer.MessageData": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_DisconnectContainer_MessageData():
    TypeOnly<current.DisconnectContainer.MessageData>;
declare function use_old_TypeAliasDeclaration_DisconnectContainer_MessageData(
    use: TypeOnly<old.DisconnectContainer.MessageData>);
use_old_TypeAliasDeclaration_DisconnectContainer_MessageData(
    get_current_TypeAliasDeclaration_DisconnectContainer_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DisconnectContainer.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_DisconnectContainer_MessageType():
    TypeOnly<typeof old.DisconnectContainer.MessageType>;
declare function use_current_VariableDeclaration_DisconnectContainer_MessageType(
    use: TypeOnly<typeof current.DisconnectContainer.MessageType>);
use_current_VariableDeclaration_DisconnectContainer_MessageType(
    get_old_VariableDeclaration_DisconnectContainer_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DisconnectContainer.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_DisconnectContainer_MessageType():
    TypeOnly<typeof current.DisconnectContainer.MessageType>;
declare function use_old_VariableDeclaration_DisconnectContainer_MessageType(
    use: TypeOnly<typeof old.DisconnectContainer.MessageType>);
use_old_VariableDeclaration_DisconnectContainer_MessageType(
    get_current_VariableDeclaration_DisconnectContainer_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_DisconnectContainer.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_DisconnectContainer_createMessage():
    TypeOnly<typeof old.DisconnectContainer.createMessage>;
declare function use_current_FunctionDeclaration_DisconnectContainer_createMessage(
    use: TypeOnly<typeof current.DisconnectContainer.createMessage>);
use_current_FunctionDeclaration_DisconnectContainer_createMessage(
    get_old_FunctionDeclaration_DisconnectContainer_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_DisconnectContainer.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_DisconnectContainer_createMessage():
    TypeOnly<typeof current.DisconnectContainer.createMessage>;
declare function use_old_FunctionDeclaration_DisconnectContainer_createMessage(
    use: TypeOnly<typeof old.DisconnectContainer.createMessage>);
use_old_FunctionDeclaration_DisconnectContainer_createMessage(
    get_current_FunctionDeclaration_DisconnectContainer_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_Edit": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_Edit():
    TypeOnly<old.Edit>;
declare function use_current_InterfaceDeclaration_Edit(
    use: TypeOnly<current.Edit>);
use_current_InterfaceDeclaration_Edit(
    get_old_InterfaceDeclaration_Edit());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_Edit": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_Edit():
    TypeOnly<current.Edit>;
declare function use_old_InterfaceDeclaration_Edit(
    use: TypeOnly<old.Edit>);
use_old_InterfaceDeclaration_Edit(
    get_current_InterfaceDeclaration_Edit());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_EditData": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_EditData():
    TypeOnly<old.EditData>;
declare function use_current_TypeAliasDeclaration_EditData(
    use: TypeOnly<current.EditData>);
use_current_TypeAliasDeclaration_EditData(
    get_old_TypeAliasDeclaration_EditData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_EditData": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_EditData():
    TypeOnly<current.EditData>;
declare function use_old_TypeAliasDeclaration_EditData(
    use: TypeOnly<old.EditData>);
use_old_TypeAliasDeclaration_EditData(
    get_current_TypeAliasDeclaration_EditData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_EditSharedObject": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_EditSharedObject():
    TypeOnly<old.EditSharedObject>;
declare function use_current_TypeAliasDeclaration_EditSharedObject(
    use: TypeOnly<current.EditSharedObject>);
use_current_TypeAliasDeclaration_EditSharedObject(
    get_old_TypeAliasDeclaration_EditSharedObject());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_EditSharedObject": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_EditSharedObject():
    TypeOnly<current.EditSharedObject>;
declare function use_old_TypeAliasDeclaration_EditSharedObject(
    use: TypeOnly<old.EditSharedObject>);
use_old_TypeAliasDeclaration_EditSharedObject(
    get_current_TypeAliasDeclaration_EditSharedObject());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_EditType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_EditType():
    TypeOnly<typeof old.EditType>;
declare function use_current_VariableDeclaration_EditType(
    use: TypeOnly<typeof current.EditType>);
use_current_VariableDeclaration_EditType(
    get_old_VariableDeclaration_EditType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_EditType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_EditType():
    TypeOnly<typeof current.EditType>;
declare function use_old_VariableDeclaration_EditType(
    use: TypeOnly<typeof old.EditType>);
use_old_VariableDeclaration_EditType(
    get_current_VariableDeclaration_EditType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_EditType": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_EditType():
    TypeOnly<old.EditType>;
declare function use_current_TypeAliasDeclaration_EditType(
    use: TypeOnly<current.EditType>);
use_current_TypeAliasDeclaration_EditType(
    get_old_TypeAliasDeclaration_EditType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_EditType": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_EditType():
    TypeOnly<current.EditType>;
declare function use_old_TypeAliasDeclaration_EditType(
    use: TypeOnly<old.EditType>);
use_old_TypeAliasDeclaration_EditType(
    get_current_TypeAliasDeclaration_EditType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_FluidDevtoolsProps": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_FluidDevtoolsProps():
    TypeOnly<old.FluidDevtoolsProps>;
declare function use_current_InterfaceDeclaration_FluidDevtoolsProps(
    use: TypeOnly<current.FluidDevtoolsProps>);
use_current_InterfaceDeclaration_FluidDevtoolsProps(
    get_old_InterfaceDeclaration_FluidDevtoolsProps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_FluidDevtoolsProps": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_FluidDevtoolsProps():
    TypeOnly<current.FluidDevtoolsProps>;
declare function use_old_InterfaceDeclaration_FluidDevtoolsProps(
    use: TypeOnly<old.FluidDevtoolsProps>);
use_old_InterfaceDeclaration_FluidDevtoolsProps(
    get_current_InterfaceDeclaration_FluidDevtoolsProps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_FluidHandleNode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_FluidHandleNode():
    TypeOnly<old.FluidHandleNode>;
declare function use_current_InterfaceDeclaration_FluidHandleNode(
    use: TypeOnly<current.FluidHandleNode>);
use_current_InterfaceDeclaration_FluidHandleNode(
    get_old_InterfaceDeclaration_FluidHandleNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_FluidHandleNode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_FluidHandleNode():
    TypeOnly<current.FluidHandleNode>;
declare function use_old_InterfaceDeclaration_FluidHandleNode(
    use: TypeOnly<old.FluidHandleNode>);
use_old_InterfaceDeclaration_FluidHandleNode(
    get_current_InterfaceDeclaration_FluidHandleNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObjectId": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_FluidObjectId():
    TypeOnly<old.FluidObjectId>;
declare function use_current_TypeAliasDeclaration_FluidObjectId(
    use: TypeOnly<current.FluidObjectId>);
use_current_TypeAliasDeclaration_FluidObjectId(
    get_old_TypeAliasDeclaration_FluidObjectId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObjectId": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_FluidObjectId():
    TypeOnly<current.FluidObjectId>;
declare function use_old_TypeAliasDeclaration_FluidObjectId(
    use: TypeOnly<old.FluidObjectId>);
use_old_TypeAliasDeclaration_FluidObjectId(
    get_current_TypeAliasDeclaration_FluidObjectId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObjectNode": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_FluidObjectNode():
    TypeOnly<old.FluidObjectNode>;
declare function use_current_TypeAliasDeclaration_FluidObjectNode(
    use: TypeOnly<current.FluidObjectNode>);
use_current_TypeAliasDeclaration_FluidObjectNode(
    get_old_TypeAliasDeclaration_FluidObjectNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidObjectNode": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_FluidObjectNode():
    TypeOnly<current.FluidObjectNode>;
declare function use_old_TypeAliasDeclaration_FluidObjectNode(
    use: TypeOnly<old.FluidObjectNode>);
use_old_TypeAliasDeclaration_FluidObjectNode(
    get_current_TypeAliasDeclaration_FluidObjectNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_FluidObjectNodeBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_FluidObjectNodeBase():
    TypeOnly<old.FluidObjectNodeBase>;
declare function use_current_InterfaceDeclaration_FluidObjectNodeBase(
    use: TypeOnly<current.FluidObjectNodeBase>);
use_current_InterfaceDeclaration_FluidObjectNodeBase(
    get_old_InterfaceDeclaration_FluidObjectNodeBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_FluidObjectNodeBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_FluidObjectNodeBase():
    TypeOnly<current.FluidObjectNodeBase>;
declare function use_old_InterfaceDeclaration_FluidObjectNodeBase(
    use: TypeOnly<old.FluidObjectNodeBase>);
use_old_InterfaceDeclaration_FluidObjectNodeBase(
    get_current_InterfaceDeclaration_FluidObjectNodeBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_FluidObjectTreeNode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_FluidObjectTreeNode():
    TypeOnly<old.FluidObjectTreeNode>;
declare function use_current_InterfaceDeclaration_FluidObjectTreeNode(
    use: TypeOnly<current.FluidObjectTreeNode>);
use_current_InterfaceDeclaration_FluidObjectTreeNode(
    get_old_InterfaceDeclaration_FluidObjectTreeNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_FluidObjectTreeNode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_FluidObjectTreeNode():
    TypeOnly<current.FluidObjectTreeNode>;
declare function use_old_InterfaceDeclaration_FluidObjectTreeNode(
    use: TypeOnly<old.FluidObjectTreeNode>);
use_old_InterfaceDeclaration_FluidObjectTreeNode(
    get_current_InterfaceDeclaration_FluidObjectTreeNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_FluidObjectValueNode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_FluidObjectValueNode():
    TypeOnly<old.FluidObjectValueNode>;
declare function use_current_InterfaceDeclaration_FluidObjectValueNode(
    use: TypeOnly<current.FluidObjectValueNode>);
use_current_InterfaceDeclaration_FluidObjectValueNode(
    get_old_InterfaceDeclaration_FluidObjectValueNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_FluidObjectValueNode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_FluidObjectValueNode():
    TypeOnly<current.FluidObjectValueNode>;
declare function use_old_InterfaceDeclaration_FluidObjectValueNode(
    use: TypeOnly<old.FluidObjectValueNode>);
use_old_InterfaceDeclaration_FluidObjectValueNode(
    get_current_InterfaceDeclaration_FluidObjectValueNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_FluidUnknownObjectNode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_FluidUnknownObjectNode():
    TypeOnly<old.FluidUnknownObjectNode>;
declare function use_current_InterfaceDeclaration_FluidUnknownObjectNode(
    use: TypeOnly<current.FluidUnknownObjectNode>);
use_current_InterfaceDeclaration_FluidUnknownObjectNode(
    get_old_InterfaceDeclaration_FluidUnknownObjectNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_FluidUnknownObjectNode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_FluidUnknownObjectNode():
    TypeOnly<current.FluidUnknownObjectNode>;
declare function use_old_InterfaceDeclaration_FluidUnknownObjectNode(
    use: TypeOnly<old.FluidUnknownObjectNode>);
use_old_InterfaceDeclaration_FluidUnknownObjectNode(
    get_current_InterfaceDeclaration_FluidUnknownObjectNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetAudienceSummary.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_GetAudienceSummary_Message():
    TypeOnly<old.GetAudienceSummary.Message>;
declare function use_current_InterfaceDeclaration_GetAudienceSummary_Message(
    use: TypeOnly<current.GetAudienceSummary.Message>);
use_current_InterfaceDeclaration_GetAudienceSummary_Message(
    get_old_InterfaceDeclaration_GetAudienceSummary_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetAudienceSummary.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_GetAudienceSummary_Message():
    TypeOnly<current.GetAudienceSummary.Message>;
declare function use_old_InterfaceDeclaration_GetAudienceSummary_Message(
    use: TypeOnly<old.GetAudienceSummary.Message>);
use_old_InterfaceDeclaration_GetAudienceSummary_Message(
    get_current_InterfaceDeclaration_GetAudienceSummary_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GetAudienceSummary.MessageData": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_GetAudienceSummary_MessageData():
    TypeOnly<old.GetAudienceSummary.MessageData>;
declare function use_current_TypeAliasDeclaration_GetAudienceSummary_MessageData(
    use: TypeOnly<current.GetAudienceSummary.MessageData>);
use_current_TypeAliasDeclaration_GetAudienceSummary_MessageData(
    get_old_TypeAliasDeclaration_GetAudienceSummary_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GetAudienceSummary.MessageData": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_GetAudienceSummary_MessageData():
    TypeOnly<current.GetAudienceSummary.MessageData>;
declare function use_old_TypeAliasDeclaration_GetAudienceSummary_MessageData(
    use: TypeOnly<old.GetAudienceSummary.MessageData>);
use_old_TypeAliasDeclaration_GetAudienceSummary_MessageData(
    get_current_TypeAliasDeclaration_GetAudienceSummary_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetAudienceSummary.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_GetAudienceSummary_MessageType():
    TypeOnly<typeof old.GetAudienceSummary.MessageType>;
declare function use_current_VariableDeclaration_GetAudienceSummary_MessageType(
    use: TypeOnly<typeof current.GetAudienceSummary.MessageType>);
use_current_VariableDeclaration_GetAudienceSummary_MessageType(
    get_old_VariableDeclaration_GetAudienceSummary_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetAudienceSummary.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_GetAudienceSummary_MessageType():
    TypeOnly<typeof current.GetAudienceSummary.MessageType>;
declare function use_old_VariableDeclaration_GetAudienceSummary_MessageType(
    use: TypeOnly<typeof old.GetAudienceSummary.MessageType>);
use_old_VariableDeclaration_GetAudienceSummary_MessageType(
    get_current_VariableDeclaration_GetAudienceSummary_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetAudienceSummary.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_GetAudienceSummary_createMessage():
    TypeOnly<typeof old.GetAudienceSummary.createMessage>;
declare function use_current_FunctionDeclaration_GetAudienceSummary_createMessage(
    use: TypeOnly<typeof current.GetAudienceSummary.createMessage>);
use_current_FunctionDeclaration_GetAudienceSummary_createMessage(
    get_old_FunctionDeclaration_GetAudienceSummary_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetAudienceSummary.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_GetAudienceSummary_createMessage():
    TypeOnly<typeof current.GetAudienceSummary.createMessage>;
declare function use_old_FunctionDeclaration_GetAudienceSummary_createMessage(
    use: TypeOnly<typeof old.GetAudienceSummary.createMessage>);
use_old_FunctionDeclaration_GetAudienceSummary_createMessage(
    get_current_FunctionDeclaration_GetAudienceSummary_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetContainerDevtoolsFeatures.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_GetContainerDevtoolsFeatures_Message():
    TypeOnly<old.GetContainerDevtoolsFeatures.Message>;
declare function use_current_InterfaceDeclaration_GetContainerDevtoolsFeatures_Message(
    use: TypeOnly<current.GetContainerDevtoolsFeatures.Message>);
use_current_InterfaceDeclaration_GetContainerDevtoolsFeatures_Message(
    get_old_InterfaceDeclaration_GetContainerDevtoolsFeatures_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetContainerDevtoolsFeatures.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_GetContainerDevtoolsFeatures_Message():
    TypeOnly<current.GetContainerDevtoolsFeatures.Message>;
declare function use_old_InterfaceDeclaration_GetContainerDevtoolsFeatures_Message(
    use: TypeOnly<old.GetContainerDevtoolsFeatures.Message>);
use_old_InterfaceDeclaration_GetContainerDevtoolsFeatures_Message(
    get_current_InterfaceDeclaration_GetContainerDevtoolsFeatures_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GetContainerDevtoolsFeatures.MessageData": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_GetContainerDevtoolsFeatures_MessageData():
    TypeOnly<old.GetContainerDevtoolsFeatures.MessageData>;
declare function use_current_TypeAliasDeclaration_GetContainerDevtoolsFeatures_MessageData(
    use: TypeOnly<current.GetContainerDevtoolsFeatures.MessageData>);
use_current_TypeAliasDeclaration_GetContainerDevtoolsFeatures_MessageData(
    get_old_TypeAliasDeclaration_GetContainerDevtoolsFeatures_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GetContainerDevtoolsFeatures.MessageData": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_GetContainerDevtoolsFeatures_MessageData():
    TypeOnly<current.GetContainerDevtoolsFeatures.MessageData>;
declare function use_old_TypeAliasDeclaration_GetContainerDevtoolsFeatures_MessageData(
    use: TypeOnly<old.GetContainerDevtoolsFeatures.MessageData>);
use_old_TypeAliasDeclaration_GetContainerDevtoolsFeatures_MessageData(
    get_current_TypeAliasDeclaration_GetContainerDevtoolsFeatures_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetContainerDevtoolsFeatures.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_GetContainerDevtoolsFeatures_MessageType():
    TypeOnly<typeof old.GetContainerDevtoolsFeatures.MessageType>;
declare function use_current_VariableDeclaration_GetContainerDevtoolsFeatures_MessageType(
    use: TypeOnly<typeof current.GetContainerDevtoolsFeatures.MessageType>);
use_current_VariableDeclaration_GetContainerDevtoolsFeatures_MessageType(
    get_old_VariableDeclaration_GetContainerDevtoolsFeatures_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetContainerDevtoolsFeatures.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_GetContainerDevtoolsFeatures_MessageType():
    TypeOnly<typeof current.GetContainerDevtoolsFeatures.MessageType>;
declare function use_old_VariableDeclaration_GetContainerDevtoolsFeatures_MessageType(
    use: TypeOnly<typeof old.GetContainerDevtoolsFeatures.MessageType>);
use_old_VariableDeclaration_GetContainerDevtoolsFeatures_MessageType(
    get_current_VariableDeclaration_GetContainerDevtoolsFeatures_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetContainerDevtoolsFeatures.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_GetContainerDevtoolsFeatures_createMessage():
    TypeOnly<typeof old.GetContainerDevtoolsFeatures.createMessage>;
declare function use_current_FunctionDeclaration_GetContainerDevtoolsFeatures_createMessage(
    use: TypeOnly<typeof current.GetContainerDevtoolsFeatures.createMessage>);
use_current_FunctionDeclaration_GetContainerDevtoolsFeatures_createMessage(
    get_old_FunctionDeclaration_GetContainerDevtoolsFeatures_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetContainerDevtoolsFeatures.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_GetContainerDevtoolsFeatures_createMessage():
    TypeOnly<typeof current.GetContainerDevtoolsFeatures.createMessage>;
declare function use_old_FunctionDeclaration_GetContainerDevtoolsFeatures_createMessage(
    use: TypeOnly<typeof old.GetContainerDevtoolsFeatures.createMessage>);
use_old_FunctionDeclaration_GetContainerDevtoolsFeatures_createMessage(
    get_current_FunctionDeclaration_GetContainerDevtoolsFeatures_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetContainerList.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_GetContainerList_Message():
    TypeOnly<old.GetContainerList.Message>;
declare function use_current_InterfaceDeclaration_GetContainerList_Message(
    use: TypeOnly<current.GetContainerList.Message>);
use_current_InterfaceDeclaration_GetContainerList_Message(
    get_old_InterfaceDeclaration_GetContainerList_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetContainerList.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_GetContainerList_Message():
    TypeOnly<current.GetContainerList.Message>;
declare function use_old_InterfaceDeclaration_GetContainerList_Message(
    use: TypeOnly<old.GetContainerList.Message>);
use_old_InterfaceDeclaration_GetContainerList_Message(
    get_current_InterfaceDeclaration_GetContainerList_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetContainerList.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_GetContainerList_MessageType():
    TypeOnly<typeof old.GetContainerList.MessageType>;
declare function use_current_VariableDeclaration_GetContainerList_MessageType(
    use: TypeOnly<typeof current.GetContainerList.MessageType>);
use_current_VariableDeclaration_GetContainerList_MessageType(
    get_old_VariableDeclaration_GetContainerList_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetContainerList.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_GetContainerList_MessageType():
    TypeOnly<typeof current.GetContainerList.MessageType>;
declare function use_old_VariableDeclaration_GetContainerList_MessageType(
    use: TypeOnly<typeof old.GetContainerList.MessageType>);
use_old_VariableDeclaration_GetContainerList_MessageType(
    get_current_VariableDeclaration_GetContainerList_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetContainerList.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_GetContainerList_createMessage():
    TypeOnly<typeof old.GetContainerList.createMessage>;
declare function use_current_FunctionDeclaration_GetContainerList_createMessage(
    use: TypeOnly<typeof current.GetContainerList.createMessage>);
use_current_FunctionDeclaration_GetContainerList_createMessage(
    get_old_FunctionDeclaration_GetContainerList_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetContainerList.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_GetContainerList_createMessage():
    TypeOnly<typeof current.GetContainerList.createMessage>;
declare function use_old_FunctionDeclaration_GetContainerList_createMessage(
    use: TypeOnly<typeof old.GetContainerList.createMessage>);
use_old_FunctionDeclaration_GetContainerList_createMessage(
    get_current_FunctionDeclaration_GetContainerList_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetContainerState.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_GetContainerState_Message():
    TypeOnly<old.GetContainerState.Message>;
declare function use_current_InterfaceDeclaration_GetContainerState_Message(
    use: TypeOnly<current.GetContainerState.Message>);
use_current_InterfaceDeclaration_GetContainerState_Message(
    get_old_InterfaceDeclaration_GetContainerState_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetContainerState.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_GetContainerState_Message():
    TypeOnly<current.GetContainerState.Message>;
declare function use_old_InterfaceDeclaration_GetContainerState_Message(
    use: TypeOnly<old.GetContainerState.Message>);
use_old_InterfaceDeclaration_GetContainerState_Message(
    get_current_InterfaceDeclaration_GetContainerState_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GetContainerState.MessageData": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_GetContainerState_MessageData():
    TypeOnly<old.GetContainerState.MessageData>;
declare function use_current_TypeAliasDeclaration_GetContainerState_MessageData(
    use: TypeOnly<current.GetContainerState.MessageData>);
use_current_TypeAliasDeclaration_GetContainerState_MessageData(
    get_old_TypeAliasDeclaration_GetContainerState_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GetContainerState.MessageData": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_GetContainerState_MessageData():
    TypeOnly<current.GetContainerState.MessageData>;
declare function use_old_TypeAliasDeclaration_GetContainerState_MessageData(
    use: TypeOnly<old.GetContainerState.MessageData>);
use_old_TypeAliasDeclaration_GetContainerState_MessageData(
    get_current_TypeAliasDeclaration_GetContainerState_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetContainerState.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_GetContainerState_MessageType():
    TypeOnly<typeof old.GetContainerState.MessageType>;
declare function use_current_VariableDeclaration_GetContainerState_MessageType(
    use: TypeOnly<typeof current.GetContainerState.MessageType>);
use_current_VariableDeclaration_GetContainerState_MessageType(
    get_old_VariableDeclaration_GetContainerState_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetContainerState.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_GetContainerState_MessageType():
    TypeOnly<typeof current.GetContainerState.MessageType>;
declare function use_old_VariableDeclaration_GetContainerState_MessageType(
    use: TypeOnly<typeof old.GetContainerState.MessageType>);
use_old_VariableDeclaration_GetContainerState_MessageType(
    get_current_VariableDeclaration_GetContainerState_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetContainerState.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_GetContainerState_createMessage():
    TypeOnly<typeof old.GetContainerState.createMessage>;
declare function use_current_FunctionDeclaration_GetContainerState_createMessage(
    use: TypeOnly<typeof current.GetContainerState.createMessage>);
use_current_FunctionDeclaration_GetContainerState_createMessage(
    get_old_FunctionDeclaration_GetContainerState_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetContainerState.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_GetContainerState_createMessage():
    TypeOnly<typeof current.GetContainerState.createMessage>;
declare function use_old_FunctionDeclaration_GetContainerState_createMessage(
    use: TypeOnly<typeof old.GetContainerState.createMessage>);
use_old_FunctionDeclaration_GetContainerState_createMessage(
    get_current_FunctionDeclaration_GetContainerState_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetDataVisualization.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_GetDataVisualization_Message():
    TypeOnly<old.GetDataVisualization.Message>;
declare function use_current_InterfaceDeclaration_GetDataVisualization_Message(
    use: TypeOnly<current.GetDataVisualization.Message>);
use_current_InterfaceDeclaration_GetDataVisualization_Message(
    get_old_InterfaceDeclaration_GetDataVisualization_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetDataVisualization.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_GetDataVisualization_Message():
    TypeOnly<current.GetDataVisualization.Message>;
declare function use_old_InterfaceDeclaration_GetDataVisualization_Message(
    use: TypeOnly<old.GetDataVisualization.Message>);
use_old_InterfaceDeclaration_GetDataVisualization_Message(
    get_current_InterfaceDeclaration_GetDataVisualization_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GetDataVisualization.MessageData": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_GetDataVisualization_MessageData():
    TypeOnly<old.GetDataVisualization.MessageData>;
declare function use_current_TypeAliasDeclaration_GetDataVisualization_MessageData(
    use: TypeOnly<current.GetDataVisualization.MessageData>);
use_current_TypeAliasDeclaration_GetDataVisualization_MessageData(
    get_old_TypeAliasDeclaration_GetDataVisualization_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GetDataVisualization.MessageData": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_GetDataVisualization_MessageData():
    TypeOnly<current.GetDataVisualization.MessageData>;
declare function use_old_TypeAliasDeclaration_GetDataVisualization_MessageData(
    use: TypeOnly<old.GetDataVisualization.MessageData>);
use_old_TypeAliasDeclaration_GetDataVisualization_MessageData(
    get_current_TypeAliasDeclaration_GetDataVisualization_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetDataVisualization.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_GetDataVisualization_MessageType():
    TypeOnly<typeof old.GetDataVisualization.MessageType>;
declare function use_current_VariableDeclaration_GetDataVisualization_MessageType(
    use: TypeOnly<typeof current.GetDataVisualization.MessageType>);
use_current_VariableDeclaration_GetDataVisualization_MessageType(
    get_old_VariableDeclaration_GetDataVisualization_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetDataVisualization.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_GetDataVisualization_MessageType():
    TypeOnly<typeof current.GetDataVisualization.MessageType>;
declare function use_old_VariableDeclaration_GetDataVisualization_MessageType(
    use: TypeOnly<typeof old.GetDataVisualization.MessageType>);
use_old_VariableDeclaration_GetDataVisualization_MessageType(
    get_current_VariableDeclaration_GetDataVisualization_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetDataVisualization.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_GetDataVisualization_createMessage():
    TypeOnly<typeof old.GetDataVisualization.createMessage>;
declare function use_current_FunctionDeclaration_GetDataVisualization_createMessage(
    use: TypeOnly<typeof current.GetDataVisualization.createMessage>);
use_current_FunctionDeclaration_GetDataVisualization_createMessage(
    get_old_FunctionDeclaration_GetDataVisualization_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetDataVisualization.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_GetDataVisualization_createMessage():
    TypeOnly<typeof current.GetDataVisualization.createMessage>;
declare function use_old_FunctionDeclaration_GetDataVisualization_createMessage(
    use: TypeOnly<typeof old.GetDataVisualization.createMessage>);
use_old_FunctionDeclaration_GetDataVisualization_createMessage(
    get_current_FunctionDeclaration_GetDataVisualization_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetDevtoolsFeatures.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_GetDevtoolsFeatures_Message():
    TypeOnly<old.GetDevtoolsFeatures.Message>;
declare function use_current_InterfaceDeclaration_GetDevtoolsFeatures_Message(
    use: TypeOnly<current.GetDevtoolsFeatures.Message>);
use_current_InterfaceDeclaration_GetDevtoolsFeatures_Message(
    get_old_InterfaceDeclaration_GetDevtoolsFeatures_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetDevtoolsFeatures.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_GetDevtoolsFeatures_Message():
    TypeOnly<current.GetDevtoolsFeatures.Message>;
declare function use_old_InterfaceDeclaration_GetDevtoolsFeatures_Message(
    use: TypeOnly<old.GetDevtoolsFeatures.Message>);
use_old_InterfaceDeclaration_GetDevtoolsFeatures_Message(
    get_current_InterfaceDeclaration_GetDevtoolsFeatures_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetDevtoolsFeatures.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_GetDevtoolsFeatures_MessageType():
    TypeOnly<typeof old.GetDevtoolsFeatures.MessageType>;
declare function use_current_VariableDeclaration_GetDevtoolsFeatures_MessageType(
    use: TypeOnly<typeof current.GetDevtoolsFeatures.MessageType>);
use_current_VariableDeclaration_GetDevtoolsFeatures_MessageType(
    get_old_VariableDeclaration_GetDevtoolsFeatures_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetDevtoolsFeatures.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_GetDevtoolsFeatures_MessageType():
    TypeOnly<typeof current.GetDevtoolsFeatures.MessageType>;
declare function use_old_VariableDeclaration_GetDevtoolsFeatures_MessageType(
    use: TypeOnly<typeof old.GetDevtoolsFeatures.MessageType>);
use_old_VariableDeclaration_GetDevtoolsFeatures_MessageType(
    get_current_VariableDeclaration_GetDevtoolsFeatures_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetDevtoolsFeatures.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_GetDevtoolsFeatures_createMessage():
    TypeOnly<typeof old.GetDevtoolsFeatures.createMessage>;
declare function use_current_FunctionDeclaration_GetDevtoolsFeatures_createMessage(
    use: TypeOnly<typeof current.GetDevtoolsFeatures.createMessage>);
use_current_FunctionDeclaration_GetDevtoolsFeatures_createMessage(
    get_old_FunctionDeclaration_GetDevtoolsFeatures_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetDevtoolsFeatures.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_GetDevtoolsFeatures_createMessage():
    TypeOnly<typeof current.GetDevtoolsFeatures.createMessage>;
declare function use_old_FunctionDeclaration_GetDevtoolsFeatures_createMessage(
    use: TypeOnly<typeof old.GetDevtoolsFeatures.createMessage>);
use_old_FunctionDeclaration_GetDevtoolsFeatures_createMessage(
    get_current_FunctionDeclaration_GetDevtoolsFeatures_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetRootDataVisualizations.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_GetRootDataVisualizations_Message():
    TypeOnly<old.GetRootDataVisualizations.Message>;
declare function use_current_InterfaceDeclaration_GetRootDataVisualizations_Message(
    use: TypeOnly<current.GetRootDataVisualizations.Message>);
use_current_InterfaceDeclaration_GetRootDataVisualizations_Message(
    get_old_InterfaceDeclaration_GetRootDataVisualizations_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetRootDataVisualizations.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_GetRootDataVisualizations_Message():
    TypeOnly<current.GetRootDataVisualizations.Message>;
declare function use_old_InterfaceDeclaration_GetRootDataVisualizations_Message(
    use: TypeOnly<old.GetRootDataVisualizations.Message>);
use_old_InterfaceDeclaration_GetRootDataVisualizations_Message(
    get_current_InterfaceDeclaration_GetRootDataVisualizations_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GetRootDataVisualizations.MessageData": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_GetRootDataVisualizations_MessageData():
    TypeOnly<old.GetRootDataVisualizations.MessageData>;
declare function use_current_TypeAliasDeclaration_GetRootDataVisualizations_MessageData(
    use: TypeOnly<current.GetRootDataVisualizations.MessageData>);
use_current_TypeAliasDeclaration_GetRootDataVisualizations_MessageData(
    get_old_TypeAliasDeclaration_GetRootDataVisualizations_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GetRootDataVisualizations.MessageData": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_GetRootDataVisualizations_MessageData():
    TypeOnly<current.GetRootDataVisualizations.MessageData>;
declare function use_old_TypeAliasDeclaration_GetRootDataVisualizations_MessageData(
    use: TypeOnly<old.GetRootDataVisualizations.MessageData>);
use_old_TypeAliasDeclaration_GetRootDataVisualizations_MessageData(
    get_current_TypeAliasDeclaration_GetRootDataVisualizations_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetRootDataVisualizations.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_GetRootDataVisualizations_MessageType():
    TypeOnly<typeof old.GetRootDataVisualizations.MessageType>;
declare function use_current_VariableDeclaration_GetRootDataVisualizations_MessageType(
    use: TypeOnly<typeof current.GetRootDataVisualizations.MessageType>);
use_current_VariableDeclaration_GetRootDataVisualizations_MessageType(
    get_old_VariableDeclaration_GetRootDataVisualizations_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetRootDataVisualizations.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_GetRootDataVisualizations_MessageType():
    TypeOnly<typeof current.GetRootDataVisualizations.MessageType>;
declare function use_old_VariableDeclaration_GetRootDataVisualizations_MessageType(
    use: TypeOnly<typeof old.GetRootDataVisualizations.MessageType>);
use_old_VariableDeclaration_GetRootDataVisualizations_MessageType(
    get_current_VariableDeclaration_GetRootDataVisualizations_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetRootDataVisualizations.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_GetRootDataVisualizations_createMessage():
    TypeOnly<typeof old.GetRootDataVisualizations.createMessage>;
declare function use_current_FunctionDeclaration_GetRootDataVisualizations_createMessage(
    use: TypeOnly<typeof current.GetRootDataVisualizations.createMessage>);
use_current_FunctionDeclaration_GetRootDataVisualizations_createMessage(
    get_old_FunctionDeclaration_GetRootDataVisualizations_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetRootDataVisualizations.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_GetRootDataVisualizations_createMessage():
    TypeOnly<typeof current.GetRootDataVisualizations.createMessage>;
declare function use_old_FunctionDeclaration_GetRootDataVisualizations_createMessage(
    use: TypeOnly<typeof old.GetRootDataVisualizations.createMessage>);
use_old_FunctionDeclaration_GetRootDataVisualizations_createMessage(
    get_current_FunctionDeclaration_GetRootDataVisualizations_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetTelemetryHistory.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_GetTelemetryHistory_Message():
    TypeOnly<old.GetTelemetryHistory.Message>;
declare function use_current_InterfaceDeclaration_GetTelemetryHistory_Message(
    use: TypeOnly<current.GetTelemetryHistory.Message>);
use_current_InterfaceDeclaration_GetTelemetryHistory_Message(
    get_old_InterfaceDeclaration_GetTelemetryHistory_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_GetTelemetryHistory.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_GetTelemetryHistory_Message():
    TypeOnly<current.GetTelemetryHistory.Message>;
declare function use_old_InterfaceDeclaration_GetTelemetryHistory_Message(
    use: TypeOnly<old.GetTelemetryHistory.Message>);
use_old_InterfaceDeclaration_GetTelemetryHistory_Message(
    get_current_InterfaceDeclaration_GetTelemetryHistory_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetTelemetryHistory.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_GetTelemetryHistory_MessageType():
    TypeOnly<typeof old.GetTelemetryHistory.MessageType>;
declare function use_current_VariableDeclaration_GetTelemetryHistory_MessageType(
    use: TypeOnly<typeof current.GetTelemetryHistory.MessageType>);
use_current_VariableDeclaration_GetTelemetryHistory_MessageType(
    get_old_VariableDeclaration_GetTelemetryHistory_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GetTelemetryHistory.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_GetTelemetryHistory_MessageType():
    TypeOnly<typeof current.GetTelemetryHistory.MessageType>;
declare function use_old_VariableDeclaration_GetTelemetryHistory_MessageType(
    use: TypeOnly<typeof old.GetTelemetryHistory.MessageType>);
use_old_VariableDeclaration_GetTelemetryHistory_MessageType(
    get_current_VariableDeclaration_GetTelemetryHistory_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetTelemetryHistory.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_GetTelemetryHistory_createMessage():
    TypeOnly<typeof old.GetTelemetryHistory.createMessage>;
declare function use_current_FunctionDeclaration_GetTelemetryHistory_createMessage(
    use: TypeOnly<typeof current.GetTelemetryHistory.createMessage>);
use_current_FunctionDeclaration_GetTelemetryHistory_createMessage(
    get_old_FunctionDeclaration_GetTelemetryHistory_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_GetTelemetryHistory.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_GetTelemetryHistory_createMessage():
    TypeOnly<typeof current.GetTelemetryHistory.createMessage>;
declare function use_old_FunctionDeclaration_GetTelemetryHistory_createMessage(
    use: TypeOnly<typeof old.GetTelemetryHistory.createMessage>);
use_old_FunctionDeclaration_GetTelemetryHistory_createMessage(
    get_current_FunctionDeclaration_GetTelemetryHistory_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_HasContainerKey": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_HasContainerKey():
    TypeOnly<old.HasContainerKey>;
declare function use_current_InterfaceDeclaration_HasContainerKey(
    use: TypeOnly<current.HasContainerKey>);
use_current_InterfaceDeclaration_HasContainerKey(
    get_old_InterfaceDeclaration_HasContainerKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_HasContainerKey": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_HasContainerKey():
    TypeOnly<current.HasContainerKey>;
declare function use_old_InterfaceDeclaration_HasContainerKey(
    use: TypeOnly<old.HasContainerKey>);
use_old_InterfaceDeclaration_HasContainerKey(
    get_current_InterfaceDeclaration_HasContainerKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_HasFluidObjectId": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_HasFluidObjectId():
    TypeOnly<old.HasFluidObjectId>;
declare function use_current_InterfaceDeclaration_HasFluidObjectId(
    use: TypeOnly<current.HasFluidObjectId>);
use_current_InterfaceDeclaration_HasFluidObjectId(
    get_old_InterfaceDeclaration_HasFluidObjectId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_HasFluidObjectId": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_HasFluidObjectId():
    TypeOnly<current.HasFluidObjectId>;
declare function use_old_InterfaceDeclaration_HasFluidObjectId(
    use: TypeOnly<old.HasFluidObjectId>);
use_old_InterfaceDeclaration_HasFluidObjectId(
    get_current_InterfaceDeclaration_HasFluidObjectId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDevtoolsMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDevtoolsMessage():
    TypeOnly<old.IDevtoolsMessage>;
declare function use_current_InterfaceDeclaration_IDevtoolsMessage(
    use: TypeOnly<current.IDevtoolsMessage>);
use_current_InterfaceDeclaration_IDevtoolsMessage(
    get_old_InterfaceDeclaration_IDevtoolsMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDevtoolsMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDevtoolsMessage():
    TypeOnly<current.IDevtoolsMessage>;
declare function use_old_InterfaceDeclaration_IDevtoolsMessage(
    use: TypeOnly<old.IDevtoolsMessage>);
use_old_InterfaceDeclaration_IDevtoolsMessage(
    get_current_InterfaceDeclaration_IDevtoolsMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDevtools": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidDevtools():
    TypeOnly<old.IFluidDevtools>;
declare function use_current_InterfaceDeclaration_IFluidDevtools(
    use: TypeOnly<current.IFluidDevtools>);
use_current_InterfaceDeclaration_IFluidDevtools(
    get_old_InterfaceDeclaration_IFluidDevtools());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDevtools": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidDevtools():
    TypeOnly<current.IFluidDevtools>;
declare function use_old_InterfaceDeclaration_IFluidDevtools(
    use: TypeOnly<old.IFluidDevtools>);
use_old_InterfaceDeclaration_IFluidDevtools(
    get_current_InterfaceDeclaration_IFluidDevtools());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMessageRelay": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMessageRelay():
    TypeOnly<old.IMessageRelay>;
declare function use_current_InterfaceDeclaration_IMessageRelay(
    use: TypeOnly<current.IMessageRelay>);
use_current_InterfaceDeclaration_IMessageRelay(
    get_old_InterfaceDeclaration_IMessageRelay());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMessageRelay": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMessageRelay():
    TypeOnly<current.IMessageRelay>;
declare function use_old_InterfaceDeclaration_IMessageRelay(
    use: TypeOnly<old.IMessageRelay>);
use_old_InterfaceDeclaration_IMessageRelay(
    get_current_InterfaceDeclaration_IMessageRelay());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMessageRelayEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMessageRelayEvents():
    TypeOnly<old.IMessageRelayEvents>;
declare function use_current_InterfaceDeclaration_IMessageRelayEvents(
    use: TypeOnly<current.IMessageRelayEvents>);
use_current_InterfaceDeclaration_IMessageRelayEvents(
    get_old_InterfaceDeclaration_IMessageRelayEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMessageRelayEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMessageRelayEvents():
    TypeOnly<current.IMessageRelayEvents>;
declare function use_old_InterfaceDeclaration_IMessageRelayEvents(
    use: TypeOnly<old.IMessageRelayEvents>);
use_old_InterfaceDeclaration_IMessageRelayEvents(
    get_current_InterfaceDeclaration_IMessageRelayEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISourcedDevtoolsMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISourcedDevtoolsMessage():
    TypeOnly<old.ISourcedDevtoolsMessage>;
declare function use_current_InterfaceDeclaration_ISourcedDevtoolsMessage(
    use: TypeOnly<current.ISourcedDevtoolsMessage>);
use_current_InterfaceDeclaration_ISourcedDevtoolsMessage(
    get_old_InterfaceDeclaration_ISourcedDevtoolsMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISourcedDevtoolsMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISourcedDevtoolsMessage():
    TypeOnly<current.ISourcedDevtoolsMessage>;
declare function use_old_InterfaceDeclaration_ISourcedDevtoolsMessage(
    use: TypeOnly<old.ISourcedDevtoolsMessage>);
use_old_InterfaceDeclaration_ISourcedDevtoolsMessage(
    get_current_InterfaceDeclaration_ISourcedDevtoolsMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITimestampedTelemetryEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITimestampedTelemetryEvent():
    TypeOnly<old.ITimestampedTelemetryEvent>;
declare function use_current_InterfaceDeclaration_ITimestampedTelemetryEvent(
    use: TypeOnly<current.ITimestampedTelemetryEvent>);
use_current_InterfaceDeclaration_ITimestampedTelemetryEvent(
    get_old_InterfaceDeclaration_ITimestampedTelemetryEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITimestampedTelemetryEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITimestampedTelemetryEvent():
    TypeOnly<current.ITimestampedTelemetryEvent>;
declare function use_old_InterfaceDeclaration_ITimestampedTelemetryEvent(
    use: TypeOnly<old.ITimestampedTelemetryEvent>);
use_old_InterfaceDeclaration_ITimestampedTelemetryEvent(
    get_current_InterfaceDeclaration_ITimestampedTelemetryEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_InboundHandlers": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_InboundHandlers():
    TypeOnly<old.InboundHandlers>;
declare function use_current_InterfaceDeclaration_InboundHandlers(
    use: TypeOnly<current.InboundHandlers>);
use_current_InterfaceDeclaration_InboundHandlers(
    get_old_InterfaceDeclaration_InboundHandlers());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_InboundHandlers": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_InboundHandlers():
    TypeOnly<current.InboundHandlers>;
declare function use_old_InterfaceDeclaration_InboundHandlers(
    use: TypeOnly<old.InboundHandlers>);
use_old_InterfaceDeclaration_InboundHandlers(
    get_current_InterfaceDeclaration_InboundHandlers());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_LogEntry": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_LogEntry():
    TypeOnly<old.LogEntry>;
declare function use_current_InterfaceDeclaration_LogEntry(
    use: TypeOnly<current.LogEntry>);
use_current_InterfaceDeclaration_LogEntry(
    get_old_InterfaceDeclaration_LogEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_LogEntry": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_LogEntry():
    TypeOnly<current.LogEntry>;
declare function use_old_InterfaceDeclaration_LogEntry(
    use: TypeOnly<old.LogEntry>);
use_old_InterfaceDeclaration_LogEntry(
    get_current_InterfaceDeclaration_LogEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_MemberChangeKind": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_MemberChangeKind():
    TypeOnly<old.MemberChangeKind>;
declare function use_current_EnumDeclaration_MemberChangeKind(
    use: TypeOnly<current.MemberChangeKind>);
use_current_EnumDeclaration_MemberChangeKind(
    get_old_EnumDeclaration_MemberChangeKind());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_MemberChangeKind": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_MemberChangeKind():
    TypeOnly<current.MemberChangeKind>;
declare function use_old_EnumDeclaration_MemberChangeKind(
    use: TypeOnly<old.MemberChangeKind>);
use_old_EnumDeclaration_MemberChangeKind(
    get_current_EnumDeclaration_MemberChangeKind());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_MessageLoggingOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_MessageLoggingOptions():
    TypeOnly<old.MessageLoggingOptions>;
declare function use_current_InterfaceDeclaration_MessageLoggingOptions(
    use: TypeOnly<current.MessageLoggingOptions>);
use_current_InterfaceDeclaration_MessageLoggingOptions(
    get_old_InterfaceDeclaration_MessageLoggingOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_MessageLoggingOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_MessageLoggingOptions():
    TypeOnly<current.MessageLoggingOptions>;
declare function use_old_InterfaceDeclaration_MessageLoggingOptions(
    use: TypeOnly<old.MessageLoggingOptions>);
use_old_InterfaceDeclaration_MessageLoggingOptions(
    get_current_InterfaceDeclaration_MessageLoggingOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_Primitive": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_Primitive():
    TypeOnly<old.Primitive>;
declare function use_current_TypeAliasDeclaration_Primitive(
    use: TypeOnly<current.Primitive>);
use_current_TypeAliasDeclaration_Primitive(
    get_old_TypeAliasDeclaration_Primitive());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_Primitive": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_Primitive():
    TypeOnly<current.Primitive>;
declare function use_old_TypeAliasDeclaration_Primitive(
    use: TypeOnly<old.Primitive>);
use_old_TypeAliasDeclaration_Primitive(
    get_current_TypeAliasDeclaration_Primitive());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_RootDataVisualizations.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_RootDataVisualizations_Message():
    TypeOnly<old.RootDataVisualizations.Message>;
declare function use_current_InterfaceDeclaration_RootDataVisualizations_Message(
    use: TypeOnly<current.RootDataVisualizations.Message>);
use_current_InterfaceDeclaration_RootDataVisualizations_Message(
    get_old_InterfaceDeclaration_RootDataVisualizations_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_RootDataVisualizations.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_RootDataVisualizations_Message():
    TypeOnly<current.RootDataVisualizations.Message>;
declare function use_old_InterfaceDeclaration_RootDataVisualizations_Message(
    use: TypeOnly<old.RootDataVisualizations.Message>);
use_old_InterfaceDeclaration_RootDataVisualizations_Message(
    get_current_InterfaceDeclaration_RootDataVisualizations_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_RootDataVisualizations.MessageData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_RootDataVisualizations_MessageData():
    TypeOnly<old.RootDataVisualizations.MessageData>;
declare function use_current_InterfaceDeclaration_RootDataVisualizations_MessageData(
    use: TypeOnly<current.RootDataVisualizations.MessageData>);
use_current_InterfaceDeclaration_RootDataVisualizations_MessageData(
    get_old_InterfaceDeclaration_RootDataVisualizations_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_RootDataVisualizations.MessageData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_RootDataVisualizations_MessageData():
    TypeOnly<current.RootDataVisualizations.MessageData>;
declare function use_old_InterfaceDeclaration_RootDataVisualizations_MessageData(
    use: TypeOnly<old.RootDataVisualizations.MessageData>);
use_old_InterfaceDeclaration_RootDataVisualizations_MessageData(
    get_current_InterfaceDeclaration_RootDataVisualizations_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_RootDataVisualizations.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_RootDataVisualizations_MessageType():
    TypeOnly<typeof old.RootDataVisualizations.MessageType>;
declare function use_current_VariableDeclaration_RootDataVisualizations_MessageType(
    use: TypeOnly<typeof current.RootDataVisualizations.MessageType>);
use_current_VariableDeclaration_RootDataVisualizations_MessageType(
    get_old_VariableDeclaration_RootDataVisualizations_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_RootDataVisualizations.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_RootDataVisualizations_MessageType():
    TypeOnly<typeof current.RootDataVisualizations.MessageType>;
declare function use_old_VariableDeclaration_RootDataVisualizations_MessageType(
    use: TypeOnly<typeof old.RootDataVisualizations.MessageType>);
use_old_VariableDeclaration_RootDataVisualizations_MessageType(
    get_current_VariableDeclaration_RootDataVisualizations_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_RootDataVisualizations.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_RootDataVisualizations_createMessage():
    TypeOnly<typeof old.RootDataVisualizations.createMessage>;
declare function use_current_FunctionDeclaration_RootDataVisualizations_createMessage(
    use: TypeOnly<typeof current.RootDataVisualizations.createMessage>);
use_current_FunctionDeclaration_RootDataVisualizations_createMessage(
    get_old_FunctionDeclaration_RootDataVisualizations_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_RootDataVisualizations.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_RootDataVisualizations_createMessage():
    TypeOnly<typeof current.RootDataVisualizations.createMessage>;
declare function use_old_FunctionDeclaration_RootDataVisualizations_createMessage(
    use: TypeOnly<typeof old.RootDataVisualizations.createMessage>);
use_old_FunctionDeclaration_RootDataVisualizations_createMessage(
    get_current_FunctionDeclaration_RootDataVisualizations_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_RootHandleNode": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_RootHandleNode():
    TypeOnly<old.RootHandleNode>;
declare function use_current_TypeAliasDeclaration_RootHandleNode(
    use: TypeOnly<current.RootHandleNode>);
use_current_TypeAliasDeclaration_RootHandleNode(
    get_old_TypeAliasDeclaration_RootHandleNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_RootHandleNode": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_RootHandleNode():
    TypeOnly<current.RootHandleNode>;
declare function use_old_TypeAliasDeclaration_RootHandleNode(
    use: TypeOnly<old.RootHandleNode>);
use_old_TypeAliasDeclaration_RootHandleNode(
    get_current_TypeAliasDeclaration_RootHandleNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SharedObjectEdit": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_SharedObjectEdit():
    TypeOnly<old.SharedObjectEdit>;
declare function use_current_InterfaceDeclaration_SharedObjectEdit(
    use: TypeOnly<current.SharedObjectEdit>);
use_current_InterfaceDeclaration_SharedObjectEdit(
    get_old_InterfaceDeclaration_SharedObjectEdit());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SharedObjectEdit": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_SharedObjectEdit():
    TypeOnly<current.SharedObjectEdit>;
declare function use_old_InterfaceDeclaration_SharedObjectEdit(
    use: TypeOnly<old.SharedObjectEdit>);
use_old_InterfaceDeclaration_SharedObjectEdit(
    get_current_InterfaceDeclaration_SharedObjectEdit());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_StateChangeLogEntry": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_StateChangeLogEntry():
    TypeOnly<old.StateChangeLogEntry<any>>;
declare function use_current_InterfaceDeclaration_StateChangeLogEntry(
    use: TypeOnly<current.StateChangeLogEntry<any>>);
use_current_InterfaceDeclaration_StateChangeLogEntry(
    get_old_InterfaceDeclaration_StateChangeLogEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_StateChangeLogEntry": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_StateChangeLogEntry():
    TypeOnly<current.StateChangeLogEntry<any>>;
declare function use_old_InterfaceDeclaration_StateChangeLogEntry(
    use: TypeOnly<old.StateChangeLogEntry<any>>);
use_old_InterfaceDeclaration_StateChangeLogEntry(
    get_current_InterfaceDeclaration_StateChangeLogEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TelemetryEvent.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_TelemetryEvent_Message():
    TypeOnly<old.TelemetryEvent.Message>;
declare function use_current_InterfaceDeclaration_TelemetryEvent_Message(
    use: TypeOnly<current.TelemetryEvent.Message>);
use_current_InterfaceDeclaration_TelemetryEvent_Message(
    get_old_InterfaceDeclaration_TelemetryEvent_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TelemetryEvent.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_TelemetryEvent_Message():
    TypeOnly<current.TelemetryEvent.Message>;
declare function use_old_InterfaceDeclaration_TelemetryEvent_Message(
    use: TypeOnly<old.TelemetryEvent.Message>);
use_old_InterfaceDeclaration_TelemetryEvent_Message(
    get_current_InterfaceDeclaration_TelemetryEvent_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TelemetryEvent.MessageData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_TelemetryEvent_MessageData():
    TypeOnly<old.TelemetryEvent.MessageData>;
declare function use_current_InterfaceDeclaration_TelemetryEvent_MessageData(
    use: TypeOnly<current.TelemetryEvent.MessageData>);
use_current_InterfaceDeclaration_TelemetryEvent_MessageData(
    get_old_InterfaceDeclaration_TelemetryEvent_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TelemetryEvent.MessageData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_TelemetryEvent_MessageData():
    TypeOnly<current.TelemetryEvent.MessageData>;
declare function use_old_InterfaceDeclaration_TelemetryEvent_MessageData(
    use: TypeOnly<old.TelemetryEvent.MessageData>);
use_old_InterfaceDeclaration_TelemetryEvent_MessageData(
    get_current_InterfaceDeclaration_TelemetryEvent_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TelemetryEvent.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_TelemetryEvent_MessageType():
    TypeOnly<typeof old.TelemetryEvent.MessageType>;
declare function use_current_VariableDeclaration_TelemetryEvent_MessageType(
    use: TypeOnly<typeof current.TelemetryEvent.MessageType>);
use_current_VariableDeclaration_TelemetryEvent_MessageType(
    get_old_VariableDeclaration_TelemetryEvent_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TelemetryEvent.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_TelemetryEvent_MessageType():
    TypeOnly<typeof current.TelemetryEvent.MessageType>;
declare function use_old_VariableDeclaration_TelemetryEvent_MessageType(
    use: TypeOnly<typeof old.TelemetryEvent.MessageType>);
use_old_VariableDeclaration_TelemetryEvent_MessageType(
    get_current_VariableDeclaration_TelemetryEvent_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_TelemetryEvent.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_TelemetryEvent_createMessage():
    TypeOnly<typeof old.TelemetryEvent.createMessage>;
declare function use_current_FunctionDeclaration_TelemetryEvent_createMessage(
    use: TypeOnly<typeof current.TelemetryEvent.createMessage>);
use_current_FunctionDeclaration_TelemetryEvent_createMessage(
    get_old_FunctionDeclaration_TelemetryEvent_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_TelemetryEvent.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_TelemetryEvent_createMessage():
    TypeOnly<typeof current.TelemetryEvent.createMessage>;
declare function use_old_FunctionDeclaration_TelemetryEvent_createMessage(
    use: TypeOnly<typeof old.TelemetryEvent.createMessage>);
use_old_FunctionDeclaration_TelemetryEvent_createMessage(
    get_current_FunctionDeclaration_TelemetryEvent_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TelemetryHistory.Message": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_TelemetryHistory_Message():
    TypeOnly<old.TelemetryHistory.Message>;
declare function use_current_InterfaceDeclaration_TelemetryHistory_Message(
    use: TypeOnly<current.TelemetryHistory.Message>);
use_current_InterfaceDeclaration_TelemetryHistory_Message(
    get_old_InterfaceDeclaration_TelemetryHistory_Message());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TelemetryHistory.Message": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_TelemetryHistory_Message():
    TypeOnly<current.TelemetryHistory.Message>;
declare function use_old_InterfaceDeclaration_TelemetryHistory_Message(
    use: TypeOnly<old.TelemetryHistory.Message>);
use_old_InterfaceDeclaration_TelemetryHistory_Message(
    get_current_InterfaceDeclaration_TelemetryHistory_Message());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TelemetryHistory.MessageData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_TelemetryHistory_MessageData():
    TypeOnly<old.TelemetryHistory.MessageData>;
declare function use_current_InterfaceDeclaration_TelemetryHistory_MessageData(
    use: TypeOnly<current.TelemetryHistory.MessageData>);
use_current_InterfaceDeclaration_TelemetryHistory_MessageData(
    get_old_InterfaceDeclaration_TelemetryHistory_MessageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TelemetryHistory.MessageData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_TelemetryHistory_MessageData():
    TypeOnly<current.TelemetryHistory.MessageData>;
declare function use_old_InterfaceDeclaration_TelemetryHistory_MessageData(
    use: TypeOnly<old.TelemetryHistory.MessageData>);
use_old_InterfaceDeclaration_TelemetryHistory_MessageData(
    get_current_InterfaceDeclaration_TelemetryHistory_MessageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TelemetryHistory.MessageType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_TelemetryHistory_MessageType():
    TypeOnly<typeof old.TelemetryHistory.MessageType>;
declare function use_current_VariableDeclaration_TelemetryHistory_MessageType(
    use: TypeOnly<typeof current.TelemetryHistory.MessageType>);
use_current_VariableDeclaration_TelemetryHistory_MessageType(
    get_old_VariableDeclaration_TelemetryHistory_MessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TelemetryHistory.MessageType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_TelemetryHistory_MessageType():
    TypeOnly<typeof current.TelemetryHistory.MessageType>;
declare function use_old_VariableDeclaration_TelemetryHistory_MessageType(
    use: TypeOnly<typeof old.TelemetryHistory.MessageType>);
use_old_VariableDeclaration_TelemetryHistory_MessageType(
    get_current_VariableDeclaration_TelemetryHistory_MessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_TelemetryHistory.createMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_TelemetryHistory_createMessage():
    TypeOnly<typeof old.TelemetryHistory.createMessage>;
declare function use_current_FunctionDeclaration_TelemetryHistory_createMessage(
    use: TypeOnly<typeof current.TelemetryHistory.createMessage>);
use_current_FunctionDeclaration_TelemetryHistory_createMessage(
    get_old_FunctionDeclaration_TelemetryHistory_createMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_TelemetryHistory.createMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_TelemetryHistory_createMessage():
    TypeOnly<typeof current.TelemetryHistory.createMessage>;
declare function use_old_FunctionDeclaration_TelemetryHistory_createMessage(
    use: TypeOnly<typeof old.TelemetryHistory.createMessage>);
use_old_FunctionDeclaration_TelemetryHistory_createMessage(
    get_current_FunctionDeclaration_TelemetryHistory_createMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TreeNodeBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_TreeNodeBase():
    TypeOnly<old.TreeNodeBase>;
declare function use_current_InterfaceDeclaration_TreeNodeBase(
    use: TypeOnly<current.TreeNodeBase>);
use_current_InterfaceDeclaration_TreeNodeBase(
    get_old_InterfaceDeclaration_TreeNodeBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TreeNodeBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_TreeNodeBase():
    TypeOnly<current.TreeNodeBase>;
declare function use_old_InterfaceDeclaration_TreeNodeBase(
    use: TypeOnly<old.TreeNodeBase>);
use_old_InterfaceDeclaration_TreeNodeBase(
    get_current_InterfaceDeclaration_TreeNodeBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_UnknownObjectNode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_UnknownObjectNode():
    TypeOnly<old.UnknownObjectNode>;
declare function use_current_InterfaceDeclaration_UnknownObjectNode(
    use: TypeOnly<current.UnknownObjectNode>);
use_current_InterfaceDeclaration_UnknownObjectNode(
    get_old_InterfaceDeclaration_UnknownObjectNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_UnknownObjectNode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_UnknownObjectNode():
    TypeOnly<current.UnknownObjectNode>;
declare function use_old_InterfaceDeclaration_UnknownObjectNode(
    use: TypeOnly<old.UnknownObjectNode>);
use_old_InterfaceDeclaration_UnknownObjectNode(
    get_current_InterfaceDeclaration_UnknownObjectNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ValueNodeBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ValueNodeBase():
    TypeOnly<old.ValueNodeBase>;
declare function use_current_InterfaceDeclaration_ValueNodeBase(
    use: TypeOnly<current.ValueNodeBase>);
use_current_InterfaceDeclaration_ValueNodeBase(
    get_old_InterfaceDeclaration_ValueNodeBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ValueNodeBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ValueNodeBase():
    TypeOnly<current.ValueNodeBase>;
declare function use_old_InterfaceDeclaration_ValueNodeBase(
    use: TypeOnly<old.ValueNodeBase>);
use_old_InterfaceDeclaration_ValueNodeBase(
    get_current_InterfaceDeclaration_ValueNodeBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_VisualChildNode": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_VisualChildNode():
    TypeOnly<old.VisualChildNode>;
declare function use_current_TypeAliasDeclaration_VisualChildNode(
    use: TypeOnly<current.VisualChildNode>);
use_current_TypeAliasDeclaration_VisualChildNode(
    get_old_TypeAliasDeclaration_VisualChildNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_VisualChildNode": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_VisualChildNode():
    TypeOnly<current.VisualChildNode>;
declare function use_old_TypeAliasDeclaration_VisualChildNode(
    use: TypeOnly<old.VisualChildNode>);
use_old_TypeAliasDeclaration_VisualChildNode(
    get_current_TypeAliasDeclaration_VisualChildNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_VisualNode": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_VisualNode():
    TypeOnly<old.VisualNode>;
declare function use_current_TypeAliasDeclaration_VisualNode(
    use: TypeOnly<current.VisualNode>);
use_current_TypeAliasDeclaration_VisualNode(
    get_old_TypeAliasDeclaration_VisualNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_VisualNode": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_VisualNode():
    TypeOnly<current.VisualNode>;
declare function use_old_TypeAliasDeclaration_VisualNode(
    use: TypeOnly<old.VisualNode>);
use_old_TypeAliasDeclaration_VisualNode(
    get_current_TypeAliasDeclaration_VisualNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_VisualNodeBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_VisualNodeBase():
    TypeOnly<old.VisualNodeBase>;
declare function use_current_InterfaceDeclaration_VisualNodeBase(
    use: TypeOnly<current.VisualNodeBase>);
use_current_InterfaceDeclaration_VisualNodeBase(
    get_old_InterfaceDeclaration_VisualNodeBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_VisualNodeBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_VisualNodeBase():
    TypeOnly<current.VisualNodeBase>;
declare function use_old_InterfaceDeclaration_VisualNodeBase(
    use: TypeOnly<old.VisualNodeBase>);
use_old_InterfaceDeclaration_VisualNodeBase(
    get_current_InterfaceDeclaration_VisualNodeBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_VisualNodeKind": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_VisualNodeKind():
    TypeOnly<old.VisualNodeKind>;
declare function use_current_EnumDeclaration_VisualNodeKind(
    use: TypeOnly<current.VisualNodeKind>);
use_current_EnumDeclaration_VisualNodeKind(
    get_old_EnumDeclaration_VisualNodeKind());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_VisualNodeKind": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_VisualNodeKind():
    TypeOnly<current.VisualNodeKind>;
declare function use_old_EnumDeclaration_VisualNodeKind(
    use: TypeOnly<old.VisualNodeKind>);
use_old_EnumDeclaration_VisualNodeKind(
    get_current_EnumDeclaration_VisualNodeKind());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_VisualTreeNode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_VisualTreeNode():
    TypeOnly<old.VisualTreeNode>;
declare function use_current_InterfaceDeclaration_VisualTreeNode(
    use: TypeOnly<current.VisualTreeNode>);
use_current_InterfaceDeclaration_VisualTreeNode(
    get_old_InterfaceDeclaration_VisualTreeNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_VisualTreeNode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_VisualTreeNode():
    TypeOnly<current.VisualTreeNode>;
declare function use_old_InterfaceDeclaration_VisualTreeNode(
    use: TypeOnly<old.VisualTreeNode>);
use_old_InterfaceDeclaration_VisualTreeNode(
    get_current_InterfaceDeclaration_VisualTreeNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_VisualValueNode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_VisualValueNode():
    TypeOnly<old.VisualValueNode>;
declare function use_current_InterfaceDeclaration_VisualValueNode(
    use: TypeOnly<current.VisualValueNode>);
use_current_InterfaceDeclaration_VisualValueNode(
    get_old_InterfaceDeclaration_VisualValueNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_VisualValueNode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_VisualValueNode():
    TypeOnly<current.VisualValueNode>;
declare function use_old_InterfaceDeclaration_VisualValueNode(
    use: TypeOnly<old.VisualValueNode>);
use_old_InterfaceDeclaration_VisualValueNode(
    get_current_InterfaceDeclaration_VisualValueNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_devtoolsMessageSource": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_devtoolsMessageSource():
    TypeOnly<typeof old.devtoolsMessageSource>;
declare function use_current_VariableDeclaration_devtoolsMessageSource(
    use: TypeOnly<typeof current.devtoolsMessageSource>);
use_current_VariableDeclaration_devtoolsMessageSource(
    get_old_VariableDeclaration_devtoolsMessageSource());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_devtoolsMessageSource": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_devtoolsMessageSource():
    TypeOnly<typeof current.devtoolsMessageSource>;
declare function use_old_VariableDeclaration_devtoolsMessageSource(
    use: TypeOnly<typeof old.devtoolsMessageSource>);
use_old_VariableDeclaration_devtoolsMessageSource(
    get_current_VariableDeclaration_devtoolsMessageSource());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_handleIncomingMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_handleIncomingMessage():
    TypeOnly<typeof old.handleIncomingMessage>;
declare function use_current_FunctionDeclaration_handleIncomingMessage(
    use: TypeOnly<typeof current.handleIncomingMessage>);
use_current_FunctionDeclaration_handleIncomingMessage(
    get_old_FunctionDeclaration_handleIncomingMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_handleIncomingMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_handleIncomingMessage():
    TypeOnly<typeof current.handleIncomingMessage>;
declare function use_old_FunctionDeclaration_handleIncomingMessage(
    use: TypeOnly<typeof old.handleIncomingMessage>);
use_old_FunctionDeclaration_handleIncomingMessage(
    get_current_FunctionDeclaration_handleIncomingMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_handleIncomingWindowMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_handleIncomingWindowMessage():
    TypeOnly<typeof old.handleIncomingWindowMessage>;
declare function use_current_FunctionDeclaration_handleIncomingWindowMessage(
    use: TypeOnly<typeof current.handleIncomingWindowMessage>);
use_current_FunctionDeclaration_handleIncomingWindowMessage(
    get_old_FunctionDeclaration_handleIncomingWindowMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_handleIncomingWindowMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_handleIncomingWindowMessage():
    TypeOnly<typeof current.handleIncomingWindowMessage>;
declare function use_old_FunctionDeclaration_handleIncomingWindowMessage(
    use: TypeOnly<typeof old.handleIncomingWindowMessage>);
use_old_FunctionDeclaration_handleIncomingWindowMessage(
    get_current_FunctionDeclaration_handleIncomingWindowMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_initializeDevtools": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_initializeDevtools():
    TypeOnly<typeof old.initializeDevtools>;
declare function use_current_FunctionDeclaration_initializeDevtools(
    use: TypeOnly<typeof current.initializeDevtools>);
use_current_FunctionDeclaration_initializeDevtools(
    get_old_FunctionDeclaration_initializeDevtools());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_initializeDevtools": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_initializeDevtools():
    TypeOnly<typeof current.initializeDevtools>;
declare function use_old_FunctionDeclaration_initializeDevtools(
    use: TypeOnly<typeof old.initializeDevtools>);
use_old_FunctionDeclaration_initializeDevtools(
    get_current_FunctionDeclaration_initializeDevtools());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isDevtoolsMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isDevtoolsMessage():
    TypeOnly<typeof old.isDevtoolsMessage>;
declare function use_current_FunctionDeclaration_isDevtoolsMessage(
    use: TypeOnly<typeof current.isDevtoolsMessage>);
use_current_FunctionDeclaration_isDevtoolsMessage(
    get_old_FunctionDeclaration_isDevtoolsMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isDevtoolsMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isDevtoolsMessage():
    TypeOnly<typeof current.isDevtoolsMessage>;
declare function use_old_FunctionDeclaration_isDevtoolsMessage(
    use: TypeOnly<typeof old.isDevtoolsMessage>);
use_old_FunctionDeclaration_isDevtoolsMessage(
    get_current_FunctionDeclaration_isDevtoolsMessage());
