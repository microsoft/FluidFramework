/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/devtools-core-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_AudienceChangeLogEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_AudienceChangeLogEntry = requireAssignableTo<TypeOnly<old.AudienceChangeLogEntry>, TypeOnly<current.AudienceChangeLogEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_AudienceChangeLogEntry": {"backCompat": false}
 */
declare type current_as_old_for_Interface_AudienceChangeLogEntry = requireAssignableTo<TypeOnly<current.AudienceChangeLogEntry>, TypeOnly<old.AudienceChangeLogEntry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_AudienceClientMetadata": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_AudienceClientMetadata = requireAssignableTo<TypeOnly<old.AudienceClientMetadata>, TypeOnly<current.AudienceClientMetadata>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_AudienceClientMetadata": {"backCompat": false}
 */
declare type current_as_old_for_Interface_AudienceClientMetadata = requireAssignableTo<TypeOnly<current.AudienceClientMetadata>, TypeOnly<old.AudienceClientMetadata>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ConnectionStateChangeLogEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ConnectionStateChangeLogEntry = requireAssignableTo<TypeOnly<old.ConnectionStateChangeLogEntry>, TypeOnly<current.ConnectionStateChangeLogEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ConnectionStateChangeLogEntry": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ConnectionStateChangeLogEntry = requireAssignableTo<TypeOnly<current.ConnectionStateChangeLogEntry>, TypeOnly<old.ConnectionStateChangeLogEntry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ContainerDevtoolsFeatureFlags": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ContainerDevtoolsFeatureFlags = requireAssignableTo<TypeOnly<old.ContainerDevtoolsFeatureFlags>, TypeOnly<current.ContainerDevtoolsFeatureFlags>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ContainerDevtoolsFeatureFlags": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ContainerDevtoolsFeatureFlags = requireAssignableTo<TypeOnly<current.ContainerDevtoolsFeatureFlags>, TypeOnly<old.ContainerDevtoolsFeatureFlags>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ContainerDevtoolsProps": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ContainerDevtoolsProps = requireAssignableTo<TypeOnly<old.ContainerDevtoolsProps>, TypeOnly<current.ContainerDevtoolsProps>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ContainerDevtoolsProps": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ContainerDevtoolsProps = requireAssignableTo<TypeOnly<current.ContainerDevtoolsProps>, TypeOnly<old.ContainerDevtoolsProps>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ContainerKey": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ContainerKey = requireAssignableTo<TypeOnly<old.ContainerKey>, TypeOnly<current.ContainerKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ContainerKey": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ContainerKey = requireAssignableTo<TypeOnly<current.ContainerKey>, TypeOnly<old.ContainerKey>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ContainerStateChangeKind": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_ContainerStateChangeKind = requireAssignableTo<TypeOnly<old.ContainerStateChangeKind>, TypeOnly<current.ContainerStateChangeKind>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ContainerStateChangeKind": {"backCompat": false}
 */
declare type current_as_old_for_Enum_ContainerStateChangeKind = requireAssignableTo<TypeOnly<current.ContainerStateChangeKind>, TypeOnly<old.ContainerStateChangeKind>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ContainerStateMetadata": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ContainerStateMetadata = requireAssignableTo<TypeOnly<old.ContainerStateMetadata>, TypeOnly<current.ContainerStateMetadata>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ContainerStateMetadata": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ContainerStateMetadata = requireAssignableTo<TypeOnly<current.ContainerStateMetadata>, TypeOnly<old.ContainerStateMetadata>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_DevtoolsFeatureFlags": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_DevtoolsFeatureFlags = requireAssignableTo<TypeOnly<old.DevtoolsFeatureFlags>, TypeOnly<current.DevtoolsFeatureFlags>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_DevtoolsFeatureFlags": {"backCompat": false}
 */
declare type current_as_old_for_Interface_DevtoolsFeatureFlags = requireAssignableTo<TypeOnly<current.DevtoolsFeatureFlags>, TypeOnly<old.DevtoolsFeatureFlags>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_Edit": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_Edit = requireAssignableTo<TypeOnly<old.Edit>, TypeOnly<current.Edit>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_Edit": {"backCompat": false}
 */
declare type current_as_old_for_Interface_Edit = requireAssignableTo<TypeOnly<current.Edit>, TypeOnly<old.Edit>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_EditData": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_EditData = requireAssignableTo<TypeOnly<old.EditData>, TypeOnly<current.EditData>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_EditData": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_EditData = requireAssignableTo<TypeOnly<current.EditData>, TypeOnly<old.EditData>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_EditSharedObject": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_EditSharedObject = requireAssignableTo<TypeOnly<old.EditSharedObject>, TypeOnly<current.EditSharedObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_EditSharedObject": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_EditSharedObject = requireAssignableTo<TypeOnly<current.EditSharedObject>, TypeOnly<old.EditSharedObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_EditType": {"backCompat": false}
 */
declare type current_as_old_for_Variable_EditType = requireAssignableTo<TypeOnly<typeof current.EditType>, TypeOnly<typeof old.EditType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_EditType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_EditType = requireAssignableTo<TypeOnly<old.EditType>, TypeOnly<current.EditType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_EditType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_EditType = requireAssignableTo<TypeOnly<current.EditType>, TypeOnly<old.EditType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FluidDevtoolsProps": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_FluidDevtoolsProps = requireAssignableTo<TypeOnly<old.FluidDevtoolsProps>, TypeOnly<current.FluidDevtoolsProps>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FluidDevtoolsProps": {"backCompat": false}
 */
declare type current_as_old_for_Interface_FluidDevtoolsProps = requireAssignableTo<TypeOnly<current.FluidDevtoolsProps>, TypeOnly<old.FluidDevtoolsProps>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FluidHandleNode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_FluidHandleNode = requireAssignableTo<TypeOnly<old.FluidHandleNode>, TypeOnly<current.FluidHandleNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FluidHandleNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_FluidHandleNode = requireAssignableTo<TypeOnly<current.FluidHandleNode>, TypeOnly<old.FluidHandleNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObjectId": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_FluidObjectId = requireAssignableTo<TypeOnly<old.FluidObjectId>, TypeOnly<current.FluidObjectId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObjectId": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_FluidObjectId = requireAssignableTo<TypeOnly<current.FluidObjectId>, TypeOnly<old.FluidObjectId>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObjectNode": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_FluidObjectNode = requireAssignableTo<TypeOnly<old.FluidObjectNode>, TypeOnly<current.FluidObjectNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidObjectNode": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_FluidObjectNode = requireAssignableTo<TypeOnly<current.FluidObjectNode>, TypeOnly<old.FluidObjectNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FluidObjectNodeBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_FluidObjectNodeBase = requireAssignableTo<TypeOnly<old.FluidObjectNodeBase>, TypeOnly<current.FluidObjectNodeBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FluidObjectNodeBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_FluidObjectNodeBase = requireAssignableTo<TypeOnly<current.FluidObjectNodeBase>, TypeOnly<old.FluidObjectNodeBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FluidObjectTreeNode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_FluidObjectTreeNode = requireAssignableTo<TypeOnly<old.FluidObjectTreeNode>, TypeOnly<current.FluidObjectTreeNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FluidObjectTreeNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_FluidObjectTreeNode = requireAssignableTo<TypeOnly<current.FluidObjectTreeNode>, TypeOnly<old.FluidObjectTreeNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FluidObjectValueNode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_FluidObjectValueNode = requireAssignableTo<TypeOnly<old.FluidObjectValueNode>, TypeOnly<current.FluidObjectValueNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FluidObjectValueNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_FluidObjectValueNode = requireAssignableTo<TypeOnly<current.FluidObjectValueNode>, TypeOnly<old.FluidObjectValueNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FluidUnknownObjectNode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_FluidUnknownObjectNode = requireAssignableTo<TypeOnly<old.FluidUnknownObjectNode>, TypeOnly<current.FluidUnknownObjectNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FluidUnknownObjectNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_FluidUnknownObjectNode = requireAssignableTo<TypeOnly<current.FluidUnknownObjectNode>, TypeOnly<old.FluidUnknownObjectNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_HasContainerKey": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_HasContainerKey = requireAssignableTo<TypeOnly<old.HasContainerKey>, TypeOnly<current.HasContainerKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_HasContainerKey": {"backCompat": false}
 */
declare type current_as_old_for_Interface_HasContainerKey = requireAssignableTo<TypeOnly<current.HasContainerKey>, TypeOnly<old.HasContainerKey>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_HasFluidObjectId": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_HasFluidObjectId = requireAssignableTo<TypeOnly<old.HasFluidObjectId>, TypeOnly<current.HasFluidObjectId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_HasFluidObjectId": {"backCompat": false}
 */
declare type current_as_old_for_Interface_HasFluidObjectId = requireAssignableTo<TypeOnly<current.HasFluidObjectId>, TypeOnly<old.HasFluidObjectId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDevtoolsLogger": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDevtoolsLogger = requireAssignableTo<TypeOnly<current.IDevtoolsLogger>, TypeOnly<old.IDevtoolsLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDevtoolsMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDevtoolsMessage = requireAssignableTo<TypeOnly<old.IDevtoolsMessage>, TypeOnly<current.IDevtoolsMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDevtoolsMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDevtoolsMessage = requireAssignableTo<TypeOnly<current.IDevtoolsMessage>, TypeOnly<old.IDevtoolsMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDevtools": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDevtools = requireAssignableTo<TypeOnly<old.IFluidDevtools>, TypeOnly<current.IFluidDevtools>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDevtools": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDevtools = requireAssignableTo<TypeOnly<current.IFluidDevtools>, TypeOnly<old.IFluidDevtools>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMessageRelay": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMessageRelay = requireAssignableTo<TypeOnly<old.IMessageRelay>, TypeOnly<current.IMessageRelay>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMessageRelay": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMessageRelay = requireAssignableTo<TypeOnly<current.IMessageRelay>, TypeOnly<old.IMessageRelay>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMessageRelayEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMessageRelayEvents = requireAssignableTo<TypeOnly<old.IMessageRelayEvents>, TypeOnly<current.IMessageRelayEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMessageRelayEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMessageRelayEvents = requireAssignableTo<TypeOnly<current.IMessageRelayEvents>, TypeOnly<old.IMessageRelayEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISourcedDevtoolsMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISourcedDevtoolsMessage = requireAssignableTo<TypeOnly<old.ISourcedDevtoolsMessage>, TypeOnly<current.ISourcedDevtoolsMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISourcedDevtoolsMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISourcedDevtoolsMessage = requireAssignableTo<TypeOnly<current.ISourcedDevtoolsMessage>, TypeOnly<old.ISourcedDevtoolsMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITimestampedTelemetryEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITimestampedTelemetryEvent = requireAssignableTo<TypeOnly<old.ITimestampedTelemetryEvent>, TypeOnly<current.ITimestampedTelemetryEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITimestampedTelemetryEvent": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITimestampedTelemetryEvent = requireAssignableTo<TypeOnly<current.ITimestampedTelemetryEvent>, TypeOnly<old.ITimestampedTelemetryEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_InboundHandlers": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_InboundHandlers = requireAssignableTo<TypeOnly<old.InboundHandlers>, TypeOnly<current.InboundHandlers>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_InboundHandlers": {"backCompat": false}
 */
declare type current_as_old_for_Interface_InboundHandlers = requireAssignableTo<TypeOnly<current.InboundHandlers>, TypeOnly<old.InboundHandlers>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_LogEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_LogEntry = requireAssignableTo<TypeOnly<old.LogEntry>, TypeOnly<current.LogEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_LogEntry": {"backCompat": false}
 */
declare type current_as_old_for_Interface_LogEntry = requireAssignableTo<TypeOnly<current.LogEntry>, TypeOnly<old.LogEntry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_MemberChangeKind": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_MemberChangeKind = requireAssignableTo<TypeOnly<old.MemberChangeKind>, TypeOnly<current.MemberChangeKind>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_MemberChangeKind": {"backCompat": false}
 */
declare type current_as_old_for_Enum_MemberChangeKind = requireAssignableTo<TypeOnly<current.MemberChangeKind>, TypeOnly<old.MemberChangeKind>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MessageLoggingOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_MessageLoggingOptions = requireAssignableTo<TypeOnly<old.MessageLoggingOptions>, TypeOnly<current.MessageLoggingOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MessageLoggingOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_MessageLoggingOptions = requireAssignableTo<TypeOnly<current.MessageLoggingOptions>, TypeOnly<old.MessageLoggingOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Primitive": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_Primitive = requireAssignableTo<TypeOnly<old.Primitive>, TypeOnly<current.Primitive>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Primitive": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_Primitive = requireAssignableTo<TypeOnly<current.Primitive>, TypeOnly<old.Primitive>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RootHandleNode": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_RootHandleNode = requireAssignableTo<TypeOnly<old.RootHandleNode>, TypeOnly<current.RootHandleNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RootHandleNode": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_RootHandleNode = requireAssignableTo<TypeOnly<current.RootHandleNode>, TypeOnly<old.RootHandleNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SharedObjectEdit": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_SharedObjectEdit = requireAssignableTo<TypeOnly<old.SharedObjectEdit>, TypeOnly<current.SharedObjectEdit>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SharedObjectEdit": {"backCompat": false}
 */
declare type current_as_old_for_Interface_SharedObjectEdit = requireAssignableTo<TypeOnly<current.SharedObjectEdit>, TypeOnly<old.SharedObjectEdit>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_StateChangeLogEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_StateChangeLogEntry = requireAssignableTo<TypeOnly<old.StateChangeLogEntry<any>>, TypeOnly<current.StateChangeLogEntry<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_StateChangeLogEntry": {"backCompat": false}
 */
declare type current_as_old_for_Interface_StateChangeLogEntry = requireAssignableTo<TypeOnly<current.StateChangeLogEntry<any>>, TypeOnly<old.StateChangeLogEntry<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeNodeBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_TreeNodeBase = requireAssignableTo<TypeOnly<old.TreeNodeBase>, TypeOnly<current.TreeNodeBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeNodeBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeNodeBase = requireAssignableTo<TypeOnly<current.TreeNodeBase>, TypeOnly<old.TreeNodeBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_UnknownObjectNode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_UnknownObjectNode = requireAssignableTo<TypeOnly<old.UnknownObjectNode>, TypeOnly<current.UnknownObjectNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_UnknownObjectNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_UnknownObjectNode = requireAssignableTo<TypeOnly<current.UnknownObjectNode>, TypeOnly<old.UnknownObjectNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ValueNodeBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ValueNodeBase = requireAssignableTo<TypeOnly<old.ValueNodeBase>, TypeOnly<current.ValueNodeBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ValueNodeBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ValueNodeBase = requireAssignableTo<TypeOnly<current.ValueNodeBase>, TypeOnly<old.ValueNodeBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_VisualChildNode": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_VisualChildNode = requireAssignableTo<TypeOnly<old.VisualChildNode>, TypeOnly<current.VisualChildNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_VisualChildNode": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_VisualChildNode = requireAssignableTo<TypeOnly<current.VisualChildNode>, TypeOnly<old.VisualChildNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_VisualNode": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_VisualNode = requireAssignableTo<TypeOnly<old.VisualNode>, TypeOnly<current.VisualNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_VisualNode": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_VisualNode = requireAssignableTo<TypeOnly<current.VisualNode>, TypeOnly<old.VisualNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_VisualNodeBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_VisualNodeBase = requireAssignableTo<TypeOnly<old.VisualNodeBase>, TypeOnly<current.VisualNodeBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_VisualNodeBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_VisualNodeBase = requireAssignableTo<TypeOnly<current.VisualNodeBase>, TypeOnly<old.VisualNodeBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_VisualNodeKind": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_VisualNodeKind = requireAssignableTo<TypeOnly<old.VisualNodeKind>, TypeOnly<current.VisualNodeKind>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_VisualNodeKind": {"backCompat": false}
 */
declare type current_as_old_for_Enum_VisualNodeKind = requireAssignableTo<TypeOnly<current.VisualNodeKind>, TypeOnly<old.VisualNodeKind>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_VisualTreeNode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_VisualTreeNode = requireAssignableTo<TypeOnly<old.VisualTreeNode>, TypeOnly<current.VisualTreeNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_VisualTreeNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_VisualTreeNode = requireAssignableTo<TypeOnly<current.VisualTreeNode>, TypeOnly<old.VisualTreeNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_VisualValueNode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_VisualValueNode = requireAssignableTo<TypeOnly<old.VisualValueNode>, TypeOnly<current.VisualValueNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_VisualValueNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_VisualValueNode = requireAssignableTo<TypeOnly<current.VisualValueNode>, TypeOnly<old.VisualValueNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createDevtoolsLogger": {"backCompat": false}
 */
declare type current_as_old_for_Function_createDevtoolsLogger = requireAssignableTo<TypeOnly<typeof current.createDevtoolsLogger>, TypeOnly<typeof old.createDevtoolsLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_devtoolsMessageSource": {"backCompat": false}
 */
declare type current_as_old_for_Variable_devtoolsMessageSource = requireAssignableTo<TypeOnly<typeof current.devtoolsMessageSource>, TypeOnly<typeof old.devtoolsMessageSource>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_handleIncomingMessage": {"backCompat": false}
 */
declare type current_as_old_for_Function_handleIncomingMessage = requireAssignableTo<TypeOnly<typeof current.handleIncomingMessage>, TypeOnly<typeof old.handleIncomingMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_handleIncomingWindowMessage": {"backCompat": false}
 */
declare type current_as_old_for_Function_handleIncomingWindowMessage = requireAssignableTo<TypeOnly<typeof current.handleIncomingWindowMessage>, TypeOnly<typeof old.handleIncomingWindowMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_initializeDevtools": {"backCompat": false}
 */
declare type current_as_old_for_Function_initializeDevtools = requireAssignableTo<TypeOnly<typeof current.initializeDevtools>, TypeOnly<typeof old.initializeDevtools>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isDevtoolsMessage": {"backCompat": false}
 */
declare type current_as_old_for_Function_isDevtoolsMessage = requireAssignableTo<TypeOnly<typeof current.isDevtoolsMessage>, TypeOnly<typeof old.isDevtoolsMessage>>
