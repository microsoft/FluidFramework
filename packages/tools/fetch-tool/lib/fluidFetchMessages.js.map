{"version":3,"file":"fluidFetchMessages.js","sourceRoot":"","sources":["../src/fluidFetchMessages.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport fs from \"fs\";\nimport { assert } from \"@fluidframework/common-utils\";\nimport {\n    IDocumentService,\n} from \"@fluidframework/driver-definitions\";\nimport {\n    IClient,\n    ISequencedDocumentMessage,\n    MessageType,\n    ScopeType,\n} from \"@fluidframework/protocol-definitions\";\nimport { printMessageStats } from \"./fluidAnalyzeMessages\";\nimport {\n    connectToWebSocket,\n    dumpMessages,\n    dumpMessageStats,\n    paramActualFormatting,\n    messageTypeFilter,\n} from \"./fluidFetchArgs\";\n\nfunction filenameFromIndex(index: number): string {\n    return index === 0 ? \"\" : index.toString(); // support old tools...\n}\n\nlet currSeq: number;\n\nasync function* loadAllSequencedMessages(\n    documentService?: IDocumentService,\n    dir?: string,\n    files?: string[],\n    sequenceNumber: number = 0) {\n    let lastSeq = sequenceNumber;\n    currSeq = sequenceNumber + 1;\n\n    let seqNumMismatch = false;\n    // If we have local save, read ops from there first\n    if (files !== undefined) {\n        for (let i = 0; i < files.length; i++) {\n            const file = filenameFromIndex(i);\n            try {\n                console.log(`reading messages${file}.json`);\n                const fileContent = fs.readFileSync(`${dir}/messages${file}.json`, { encoding: \"utf-8\" });\n                const messages: ISequencedDocumentMessage[] = JSON.parse(fileContent);\n                seqNumMismatch = messages[0].sequenceNumber !== lastSeq + 1;\n                assert(!seqNumMismatch, 0x1b9 /* \"Unexpected value for sequence number of first message in file\" */);\n                yield messages;\n                lastSeq = messages[messages.length - 1].sequenceNumber;\n                currSeq = lastSeq;\n            } catch (e) {\n                console.error(`Error reading / parsing messages from ${files}`);\n                if (seqNumMismatch) {\n                    console.error(\"There are deleted ops in the document being requested,\" +\n                        \" please back up the existing messages.json file and delete it from its directory.\" +\n                        \" Then try fetch tool again.\");\n                }\n                console.error(e);\n                return;\n            }\n        }\n        if (lastSeq !== 0) {\n            console.log(`Read ${lastSeq} ops from local cache`);\n        }\n    }\n\n    if (!documentService) {\n        return;\n    }\n\n    const deltaStorage = await documentService.connectToDeltaStorage();\n\n    let timeStart = Date.now();\n    let requests = 0;\n    let opsStorage = 0;\n\n    const teststream = deltaStorage.fetchMessages(\n        lastSeq + 1,\n        lastSeq + 2);\n\n    let statusCode;\n    let innerMostErrorCode;\n    let response;\n\n    try {\n        await teststream.read();\n    } catch (error) {\n        statusCode = error.getTelemetryProperties().statusCode;\n        innerMostErrorCode = error.getTelemetryProperties().innerMostErrorCode;\n        if (statusCode !== 410 || innerMostErrorCode !== \"fluidDeltaDataNotAvailable\") {\n            throw error;\n        }\n        response = JSON.parse(error.getTelemetryProperties().response);\n        currSeq = response.error.firstAvailableDelta;\n        lastSeq = currSeq - 1;\n    }\n    const stream = deltaStorage.fetchMessages(\n        lastSeq + 1, // inclusive left\n        undefined, // to\n    );\n\n    while (true) {\n        const result = await stream.read();\n        if (result.done) {\n            break;\n        }\n        requests++;\n        const messages = result.value;\n\n        // Empty buckets should never be returned\n        assert(messages.length !== 0, 0x1ba /* \"should not return empty buckets\" */);\n        // console.log(`Loaded ops at ${messages[0].sequenceNumber}`);\n\n        // This parsing of message contents happens in delta manager. But when we analyze messages\n        // for message stats, we skip that path. So parsing of json contents needs to happen here.\n        for (const message of messages) {\n            if (typeof message.contents === \"string\"\n                && message.contents !== \"\"\n                && message.type !== MessageType.ClientLeave\n            ) {\n                message.contents = JSON.parse(message.contents);\n            }\n        }\n\n        opsStorage += messages.length;\n        lastSeq = messages[messages.length - 1].sequenceNumber;\n        yield messages;\n    }\n\n    // eslint-disable-next-line max-len\n    console.log(`\\n${Math.floor((Date.now() - timeStart) / 1000)} seconds to retrieve ${opsStorage} ops in ${requests} requests`);\n\n    if (connectToWebSocket) {\n        let logMsg = \"\";\n        const client: IClient = {\n            mode: \"write\",\n            permission: [],\n            scopes: [ScopeType.DocRead, ScopeType.DocWrite, ScopeType.SummaryWrite],\n            details: {\n                capabilities: { interactive: true },\n            },\n            user: { id: \"blah\" },\n        };\n        console.log(\"Retrieving messages from web socket\");\n        timeStart = Date.now();\n        const deltaStream = await documentService.connectToDeltaStream(client);\n        const initialMessages = deltaStream.initialMessages;\n        deltaStream.close();\n        console.log(`${Math.floor((Date.now() - timeStart) / 1000)} seconds to connect to web socket`);\n\n        if (initialMessages) {\n            const lastSequenceNumber = lastSeq;\n            const filtered = initialMessages.filter((a) => a.sequenceNumber > lastSequenceNumber);\n            const sorted = filtered.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n            lastSeq = sorted[sorted.length - 1].sequenceNumber;\n            // eslint-disable-next-line max-len\n            logMsg = ` (${opsStorage} delta storage, ${initialMessages.length} initial ws messages, ${initialMessages.length - sorted.length} dup)`;\n            yield sorted;\n        }\n        console.log(`${lastSeq} total messages${logMsg}`);\n    }\n}\n\nasync function* saveOps(\n    gen, // AsyncGenerator<ISequencedDocumentMessage[]>,\n    dir: string,\n    files: string[]) {\n    // Split into 100K ops\n    const chunk = 100 * 1000;\n\n    // Figure out first file we want to write to\n    let index = 0;\n    if (files.length !== 0) {\n        index = (files.length - 1);\n    }\n\n    let sequencedMessages: ISequencedDocumentMessage[] = [];\n    while (true) {\n        const result: IteratorResult<ISequencedDocumentMessage[]> = await gen.next();\n        let curr = index * chunk + currSeq;\n        if (!result.done) {\n            let messages = result.value;\n            yield messages;\n            if (messages[messages.length - 1].sequenceNumber < curr) {\n                // Nothing interesting.\n                continue;\n            }\n            if (messages[0].sequenceNumber < curr) {\n                messages = messages.filter((msg) => msg.sequenceNumber >= curr);\n            }\n            sequencedMessages = sequencedMessages.concat(messages);\n            assert(sequencedMessages[0].sequenceNumber === curr,\n                0x1bb /* \"Unexpected sequence number on first of messages to save\" */);\n            assert(sequencedMessages[sequencedMessages.length - 1].sequenceNumber\n                === curr + sequencedMessages.length - 1,\n                0x1bc /* \"Unexpected sequence number on last of messages to save\" */);\n        }\n\n        // Time to write it out?\n        while (sequencedMessages.length >= chunk || (result.done && sequencedMessages.length !== 0)) {\n            const name = filenameFromIndex(index);\n            const write = sequencedMessages.splice(0, chunk);\n            console.log(`writing messages${name}.json`);\n            fs.writeFileSync(\n                `${dir}/messages${name}.json`,\n                JSON.stringify(write, undefined, paramActualFormatting ? 0 : 2));\n            curr += chunk;\n            assert(sequencedMessages.length === 0 || sequencedMessages[0].sequenceNumber === curr,\n                0x1bd /* \"Stopped writing at unexpected sequence number\" */);\n            index++;\n        }\n\n        if (result.done) {\n            break;\n        }\n    }\n}\n\nexport async function fluidFetchMessages(documentService?: IDocumentService, saveDir?: string) {\n    const messageStats = dumpMessageStats || dumpMessages;\n    if (!messageStats && (saveDir === undefined || documentService === undefined)) {\n        return;\n    }\n\n    const files = !saveDir ?\n        undefined :\n        fs.readdirSync(saveDir)\n            .filter((file) => {\n                if (!file.startsWith(\"messages\")) {\n                    return false;\n                }\n                return true;\n            })\n            .sort((a, b) => a.localeCompare(b));\n\n    let generator = loadAllSequencedMessages(documentService, saveDir, files);\n\n    if (saveDir && files !== undefined && documentService) {\n        generator = saveOps(generator, saveDir, files);\n    }\n\n    if (messageStats) {\n        return printMessageStats(\n            generator,\n            dumpMessageStats,\n            dumpMessages,\n            messageTypeFilter);\n    } else {\n        let item;\n        for await (item of generator) { }\n    }\n}\n"]}