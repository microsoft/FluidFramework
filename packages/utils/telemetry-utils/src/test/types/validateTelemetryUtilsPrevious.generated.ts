/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/telemetry-utils-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DataCorruptionError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DataCorruptionError = requireAssignableTo<TypeOnly<old.DataCorruptionError>, TypeOnly<current.DataCorruptionError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DataCorruptionError": {"backCompat": false}
 */
declare type current_as_old_for_Class_DataCorruptionError = requireAssignableTo<TypeOnly<current.DataCorruptionError>, TypeOnly<old.DataCorruptionError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DataProcessingError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DataProcessingError = requireAssignableTo<TypeOnly<old.DataProcessingError>, TypeOnly<current.DataProcessingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DataProcessingError": {"backCompat": false}
 */
declare type current_as_old_for_Class_DataProcessingError = requireAssignableTo<TypeOnly<current.DataProcessingError>, TypeOnly<old.DataProcessingError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_EventEmitterWithErrorHandling": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_EventEmitterWithErrorHandling = requireAssignableTo<TypeOnly<old.EventEmitterWithErrorHandling>, TypeOnly<current.EventEmitterWithErrorHandling>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_EventEmitterWithErrorHandling": {"backCompat": false}
 */
declare type current_as_old_for_Class_EventEmitterWithErrorHandling = requireAssignableTo<TypeOnly<current.EventEmitterWithErrorHandling>, TypeOnly<old.EventEmitterWithErrorHandling>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_GenericError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_GenericError = requireAssignableTo<TypeOnly<old.GenericError>, TypeOnly<current.GenericError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_GenericError": {"backCompat": false}
 */
declare type current_as_old_for_Class_GenericError = requireAssignableTo<TypeOnly<current.GenericError>, TypeOnly<old.GenericError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LoggingError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_LoggingError = requireAssignableTo<TypeOnly<old.LoggingError>, TypeOnly<current.LoggingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LoggingError": {"backCompat": false}
 */
declare type current_as_old_for_Class_LoggingError = requireAssignableTo<TypeOnly<current.LoggingError>, TypeOnly<old.LoggingError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MockLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MockLogger = requireAssignableTo<TypeOnly<old.MockLogger>, TypeOnly<current.MockLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MockLogger": {"backCompat": false}
 */
declare type current_as_old_for_Class_MockLogger = requireAssignableTo<TypeOnly<current.MockLogger>, TypeOnly<old.MockLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MockLogger2": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MockLogger2 = requireAssignableTo<TypeOnly<old.MockLogger2>, TypeOnly<current.MockLogger2>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MockLogger2": {"backCompat": false}
 */
declare type current_as_old_for_Class_MockLogger2 = requireAssignableTo<TypeOnly<current.MockLogger2>, TypeOnly<old.MockLogger2>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PerformanceEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_PerformanceEvent = requireAssignableTo<TypeOnly<old.PerformanceEvent>, TypeOnly<current.PerformanceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PerformanceEvent": {"backCompat": false}
 */
declare type current_as_old_for_Class_PerformanceEvent = requireAssignableTo<TypeOnly<current.PerformanceEvent>, TypeOnly<old.PerformanceEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SampledTelemetryHelper": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SampledTelemetryHelper = requireAssignableTo<TypeOnly<old.SampledTelemetryHelper>, TypeOnly<current.SampledTelemetryHelper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SampledTelemetryHelper": {"backCompat": false}
 */
declare type current_as_old_for_Class_SampledTelemetryHelper = requireAssignableTo<TypeOnly<current.SampledTelemetryHelper>, TypeOnly<old.SampledTelemetryHelper>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TaggedLoggerAdapter": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TaggedLoggerAdapter = requireAssignableTo<TypeOnly<old.TaggedLoggerAdapter>, TypeOnly<current.TaggedLoggerAdapter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TaggedLoggerAdapter": {"backCompat": false}
 */
declare type current_as_old_for_Class_TaggedLoggerAdapter = requireAssignableTo<TypeOnly<current.TaggedLoggerAdapter>, TypeOnly<old.TaggedLoggerAdapter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TelemetryEventBatcher": {"backCompat": false}
 */
declare type current_as_old_for_Class_TelemetryEventBatcher = requireAssignableTo<TypeOnly<current.TelemetryEventBatcher<any>>, TypeOnly<old.TelemetryEventBatcher<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ThresholdCounter": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ThresholdCounter = requireAssignableTo<TypeOnly<old.ThresholdCounter>, TypeOnly<current.ThresholdCounter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ThresholdCounter": {"backCompat": false}
 */
declare type current_as_old_for_Class_ThresholdCounter = requireAssignableTo<TypeOnly<current.ThresholdCounter>, TypeOnly<old.ThresholdCounter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_UsageError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_UsageError = requireAssignableTo<TypeOnly<old.UsageError>, TypeOnly<current.UsageError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_UsageError": {"backCompat": false}
 */
declare type current_as_old_for_Class_UsageError = requireAssignableTo<TypeOnly<current.UsageError>, TypeOnly<old.UsageError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DataCorruptionError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DataCorruptionError = requireAssignableTo<TypeOnly<typeof current.DataCorruptionError>, TypeOnly<typeof old.DataCorruptionError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DataProcessingError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DataProcessingError = requireAssignableTo<TypeOnly<typeof current.DataProcessingError>, TypeOnly<typeof old.DataProcessingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_EventEmitterWithErrorHandling": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_EventEmitterWithErrorHandling = requireAssignableTo<TypeOnly<typeof current.EventEmitterWithErrorHandling>, TypeOnly<typeof old.EventEmitterWithErrorHandling>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_GenericError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_GenericError = requireAssignableTo<TypeOnly<typeof current.GenericError>, TypeOnly<typeof old.GenericError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_LoggingError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_LoggingError = requireAssignableTo<TypeOnly<typeof current.LoggingError>, TypeOnly<typeof old.LoggingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MockLogger": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MockLogger = requireAssignableTo<TypeOnly<typeof current.MockLogger>, TypeOnly<typeof old.MockLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MockLogger2": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MockLogger2 = requireAssignableTo<TypeOnly<typeof current.MockLogger2>, TypeOnly<typeof old.MockLogger2>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_PerformanceEvent": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_PerformanceEvent = requireAssignableTo<TypeOnly<typeof current.PerformanceEvent>, TypeOnly<typeof old.PerformanceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SampledTelemetryHelper": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SampledTelemetryHelper = requireAssignableTo<TypeOnly<typeof current.SampledTelemetryHelper>, TypeOnly<typeof old.SampledTelemetryHelper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TaggedLoggerAdapter": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TaggedLoggerAdapter = requireAssignableTo<TypeOnly<typeof current.TaggedLoggerAdapter>, TypeOnly<typeof old.TaggedLoggerAdapter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TelemetryEventBatcher": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TelemetryEventBatcher = requireAssignableTo<TypeOnly<typeof current.TelemetryEventBatcher>, TypeOnly<typeof old.TelemetryEventBatcher>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ThresholdCounter": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ThresholdCounter = requireAssignableTo<TypeOnly<typeof current.ThresholdCounter>, TypeOnly<typeof old.ThresholdCounter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_UsageError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_UsageError = requireAssignableTo<TypeOnly<typeof current.UsageError>, TypeOnly<typeof old.UsageError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_TelemetryDataTag": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_TelemetryDataTag = requireAssignableTo<TypeOnly<old.TelemetryDataTag>, TypeOnly<current.TelemetryDataTag>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_TelemetryDataTag": {"backCompat": false}
 */
declare type current_as_old_for_Enum_TelemetryDataTag = requireAssignableTo<TypeOnly<current.TelemetryDataTag>, TypeOnly<old.TelemetryDataTag>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createChildLogger": {"backCompat": false}
 */
declare type current_as_old_for_Function_createChildLogger = requireAssignableTo<TypeOnly<typeof current.createChildLogger>, TypeOnly<typeof old.createChildLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createChildMonitoringContext": {"backCompat": false}
 */
declare type current_as_old_for_Function_createChildMonitoringContext = requireAssignableTo<TypeOnly<typeof current.createChildMonitoringContext>, TypeOnly<typeof old.createChildMonitoringContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createConfigBasedOptionsProxy": {"backCompat": false}
 */
declare type current_as_old_for_Function_createConfigBasedOptionsProxy = requireAssignableTo<TypeOnly<typeof current.createConfigBasedOptionsProxy>, TypeOnly<typeof old.createConfigBasedOptionsProxy>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createMockLoggerExt": {"backCompat": false}
 */
declare type current_as_old_for_Function_createMockLoggerExt = requireAssignableTo<TypeOnly<typeof current.createMockLoggerExt>, TypeOnly<typeof old.createMockLoggerExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createMultiSinkLogger": {"backCompat": false}
 */
declare type current_as_old_for_Function_createMultiSinkLogger = requireAssignableTo<TypeOnly<typeof current.createMultiSinkLogger>, TypeOnly<typeof old.createMultiSinkLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createSampledLogger": {"backCompat": false}
 */
declare type current_as_old_for_Function_createSampledLogger = requireAssignableTo<TypeOnly<typeof current.createSampledLogger>, TypeOnly<typeof old.createSampledLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_extractLogSafeErrorProperties": {"backCompat": false}
 */
declare type current_as_old_for_Function_extractLogSafeErrorProperties = requireAssignableTo<TypeOnly<typeof current.extractLogSafeErrorProperties>, TypeOnly<typeof old.extractLogSafeErrorProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_formatTick": {"backCompat": false}
 */
declare type current_as_old_for_Function_formatTick = requireAssignableTo<TypeOnly<typeof current.formatTick>, TypeOnly<typeof old.formatTick>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_generateErrorWithStack": {"backCompat": false}
 */
declare type current_as_old_for_Function_generateErrorWithStack = requireAssignableTo<TypeOnly<typeof current.generateErrorWithStack>, TypeOnly<typeof old.generateErrorWithStack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_generateStack": {"backCompat": false}
 */
declare type current_as_old_for_Function_generateStack = requireAssignableTo<TypeOnly<typeof current.generateStack>, TypeOnly<typeof old.generateStack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isExternalError": {"backCompat": false}
 */
declare type current_as_old_for_Function_isExternalError = requireAssignableTo<TypeOnly<typeof current.isExternalError>, TypeOnly<typeof old.isExternalError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isFluidError": {"backCompat": false}
 */
declare type current_as_old_for_Function_isFluidError = requireAssignableTo<TypeOnly<typeof current.isFluidError>, TypeOnly<typeof old.isFluidError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isTaggedTelemetryPropertyValue": {"backCompat": false}
 */
declare type current_as_old_for_Function_isTaggedTelemetryPropertyValue = requireAssignableTo<TypeOnly<typeof current.isTaggedTelemetryPropertyValue>, TypeOnly<typeof old.isTaggedTelemetryPropertyValue>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_loggerToMonitoringContext": {"backCompat": false}
 */
declare type current_as_old_for_Function_loggerToMonitoringContext = requireAssignableTo<TypeOnly<typeof current.loggerToMonitoringContext>, TypeOnly<typeof old.loggerToMonitoringContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_measure": {"backCompat": false}
 */
declare type current_as_old_for_Function_measure = requireAssignableTo<TypeOnly<typeof current.measure>, TypeOnly<typeof old.measure>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_mixinMonitoringContext": {"backCompat": false}
 */
declare type current_as_old_for_Function_mixinMonitoringContext = requireAssignableTo<TypeOnly<typeof current.mixinMonitoringContext>, TypeOnly<typeof old.mixinMonitoringContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_normalizeError": {"backCompat": false}
 */
declare type current_as_old_for_Function_normalizeError = requireAssignableTo<TypeOnly<typeof current.normalizeError>, TypeOnly<typeof old.normalizeError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_numberFromString": {"backCompat": false}
 */
declare type current_as_old_for_Function_numberFromString = requireAssignableTo<TypeOnly<typeof current.numberFromString>, TypeOnly<typeof old.numberFromString>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_overwriteStack": {"backCompat": false}
 */
declare type current_as_old_for_Function_overwriteStack = requireAssignableTo<TypeOnly<typeof current.overwriteStack>, TypeOnly<typeof old.overwriteStack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_raiseConnectedEvent": {"backCompat": false}
 */
declare type current_as_old_for_Function_raiseConnectedEvent = requireAssignableTo<TypeOnly<typeof current.raiseConnectedEvent>, TypeOnly<typeof old.raiseConnectedEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_safeRaiseEvent": {"backCompat": false}
 */
declare type current_as_old_for_Function_safeRaiseEvent = requireAssignableTo<TypeOnly<typeof current.safeRaiseEvent>, TypeOnly<typeof old.safeRaiseEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_validatePrecondition": {"backCompat": false}
 */
declare type current_as_old_for_Function_validatePrecondition = requireAssignableTo<TypeOnly<typeof current.validatePrecondition>, TypeOnly<typeof old.validatePrecondition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_wrapError": {"backCompat": false}
 */
declare type current_as_old_for_Function_wrapError = requireAssignableTo<TypeOnly<typeof current.wrapError>, TypeOnly<typeof old.wrapError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_wrapErrorAndLog": {"backCompat": false}
 */
declare type current_as_old_for_Function_wrapErrorAndLog = requireAssignableTo<TypeOnly<typeof current.wrapErrorAndLog>, TypeOnly<typeof old.wrapErrorAndLog>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConfigProvider": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConfigProvider = requireAssignableTo<TypeOnly<old.IConfigProvider>, TypeOnly<current.IConfigProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConfigProvider": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConfigProvider = requireAssignableTo<TypeOnly<current.IConfigProvider>, TypeOnly<old.IConfigProvider>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICustomData": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICustomData = requireAssignableTo<TypeOnly<old.ICustomData<any>>, TypeOnly<current.ICustomData<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICustomData": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICustomData = requireAssignableTo<TypeOnly<current.ICustomData<any>>, TypeOnly<old.ICustomData<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEventSampler": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IEventSampler = requireAssignableTo<TypeOnly<old.IEventSampler>, TypeOnly<current.IEventSampler>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEventSampler": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IEventSampler = requireAssignableTo<TypeOnly<current.IEventSampler>, TypeOnly<old.IEventSampler>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidErrorAnnotations": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidErrorAnnotations = requireAssignableTo<TypeOnly<old.IFluidErrorAnnotations>, TypeOnly<current.IFluidErrorAnnotations>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidErrorAnnotations": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidErrorAnnotations = requireAssignableTo<TypeOnly<current.IFluidErrorAnnotations>, TypeOnly<old.IFluidErrorAnnotations>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidErrorBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidErrorBase = requireAssignableTo<TypeOnly<old.IFluidErrorBase>, TypeOnly<current.IFluidErrorBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidErrorBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidErrorBase = requireAssignableTo<TypeOnly<current.IFluidErrorBase>, TypeOnly<old.IFluidErrorBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMockLoggerExt": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMockLoggerExt = requireAssignableTo<TypeOnly<old.IMockLoggerExt>, TypeOnly<current.IMockLoggerExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMockLoggerExt": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMockLoggerExt = requireAssignableTo<TypeOnly<current.IMockLoggerExt>, TypeOnly<old.IMockLoggerExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPerformanceEventMarkers": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPerformanceEventMarkers = requireAssignableTo<TypeOnly<old.IPerformanceEventMarkers>, TypeOnly<current.IPerformanceEventMarkers>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPerformanceEventMarkers": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPerformanceEventMarkers = requireAssignableTo<TypeOnly<current.IPerformanceEventMarkers>, TypeOnly<old.IPerformanceEventMarkers>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISampledTelemetryLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISampledTelemetryLogger = requireAssignableTo<TypeOnly<old.ISampledTelemetryLogger>, TypeOnly<current.ISampledTelemetryLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISampledTelemetryLogger": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISampledTelemetryLogger = requireAssignableTo<TypeOnly<current.ISampledTelemetryLogger>, TypeOnly<old.ISampledTelemetryLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITaggedTelemetryPropertyTypeExt": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITaggedTelemetryPropertyTypeExt = requireAssignableTo<TypeOnly<old.ITaggedTelemetryPropertyTypeExt>, TypeOnly<current.ITaggedTelemetryPropertyTypeExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITaggedTelemetryPropertyTypeExt": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITaggedTelemetryPropertyTypeExt = requireAssignableTo<TypeOnly<current.ITaggedTelemetryPropertyTypeExt>, TypeOnly<old.ITaggedTelemetryPropertyTypeExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryErrorEventExt": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITelemetryErrorEventExt = requireAssignableTo<TypeOnly<old.ITelemetryErrorEventExt>, TypeOnly<current.ITelemetryErrorEventExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryErrorEventExt": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryErrorEventExt = requireAssignableTo<TypeOnly<current.ITelemetryErrorEventExt>, TypeOnly<old.ITelemetryErrorEventExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryEventExt": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITelemetryEventExt = requireAssignableTo<TypeOnly<old.ITelemetryEventExt>, TypeOnly<current.ITelemetryEventExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryEventExt": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryEventExt = requireAssignableTo<TypeOnly<current.ITelemetryEventExt>, TypeOnly<old.ITelemetryEventExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryGenericEventExt": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITelemetryGenericEventExt = requireAssignableTo<TypeOnly<old.ITelemetryGenericEventExt>, TypeOnly<current.ITelemetryGenericEventExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryGenericEventExt": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryGenericEventExt = requireAssignableTo<TypeOnly<current.ITelemetryGenericEventExt>, TypeOnly<old.ITelemetryGenericEventExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryLoggerExt": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITelemetryLoggerExt = requireAssignableTo<TypeOnly<old.ITelemetryLoggerExt>, TypeOnly<current.ITelemetryLoggerExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryLoggerExt": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryLoggerExt = requireAssignableTo<TypeOnly<current.ITelemetryLoggerExt>, TypeOnly<old.ITelemetryLoggerExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryLoggerPropertyBags": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITelemetryLoggerPropertyBags = requireAssignableTo<TypeOnly<old.ITelemetryLoggerPropertyBags>, TypeOnly<current.ITelemetryLoggerPropertyBags>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryLoggerPropertyBags": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryLoggerPropertyBags = requireAssignableTo<TypeOnly<current.ITelemetryLoggerPropertyBags>, TypeOnly<old.ITelemetryLoggerPropertyBags>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryPerformanceEventExt": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITelemetryPerformanceEventExt = requireAssignableTo<TypeOnly<old.ITelemetryPerformanceEventExt>, TypeOnly<current.ITelemetryPerformanceEventExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryPerformanceEventExt": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryPerformanceEventExt = requireAssignableTo<TypeOnly<current.ITelemetryPerformanceEventExt>, TypeOnly<old.ITelemetryPerformanceEventExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MonitoringContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_MonitoringContext = requireAssignableTo<TypeOnly<old.MonitoringContext>, TypeOnly<current.MonitoringContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MonitoringContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_MonitoringContext = requireAssignableTo<TypeOnly<current.MonitoringContext>, TypeOnly<old.MonitoringContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MultiSinkLoggerProperties": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_MultiSinkLoggerProperties = requireAssignableTo<TypeOnly<old.MultiSinkLoggerProperties>, TypeOnly<current.MultiSinkLoggerProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MultiSinkLoggerProperties": {"backCompat": false}
 */
declare type current_as_old_for_Interface_MultiSinkLoggerProperties = requireAssignableTo<TypeOnly<current.MultiSinkLoggerProperties>, TypeOnly<old.MultiSinkLoggerProperties>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_CustomMetrics": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_CustomMetrics = requireAssignableTo<TypeOnly<old.CustomMetrics<any>>, TypeOnly<current.CustomMetrics<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_CustomMetrics": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_CustomMetrics = requireAssignableTo<TypeOnly<current.CustomMetrics<any>>, TypeOnly<old.CustomMetrics<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ITelemetryLoggerPropertyBag": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ITelemetryLoggerPropertyBag = requireAssignableTo<TypeOnly<old.ITelemetryLoggerPropertyBag>, TypeOnly<current.ITelemetryLoggerPropertyBag>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ITelemetryLoggerPropertyBag": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ITelemetryLoggerPropertyBag = requireAssignableTo<TypeOnly<current.ITelemetryLoggerPropertyBag>, TypeOnly<old.ITelemetryLoggerPropertyBag>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ITelemetryPropertiesExt": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ITelemetryPropertiesExt = requireAssignableTo<TypeOnly<old.ITelemetryPropertiesExt>, TypeOnly<current.ITelemetryPropertiesExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ITelemetryPropertiesExt": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ITelemetryPropertiesExt = requireAssignableTo<TypeOnly<current.ITelemetryPropertiesExt>, TypeOnly<old.ITelemetryPropertiesExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MeasureReturnType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_MeasureReturnType = requireAssignableTo<TypeOnly<old.MeasureReturnType<any,any>>, TypeOnly<current.MeasureReturnType<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MeasureReturnType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_MeasureReturnType = requireAssignableTo<TypeOnly<current.MeasureReturnType<any,any>>, TypeOnly<old.MeasureReturnType<any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_OptionConfigReaders": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_OptionConfigReaders = requireAssignableTo<TypeOnly<old.OptionConfigReaders<any>>, TypeOnly<current.OptionConfigReaders<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_OptionConfigReaders": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_OptionConfigReaders = requireAssignableTo<TypeOnly<current.OptionConfigReaders<any>>, TypeOnly<old.OptionConfigReaders<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TelemetryEventCategory": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TelemetryEventCategory = requireAssignableTo<TypeOnly<old.TelemetryEventCategory>, TypeOnly<current.TelemetryEventCategory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TelemetryEventCategory": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TelemetryEventCategory = requireAssignableTo<TypeOnly<current.TelemetryEventCategory>, TypeOnly<old.TelemetryEventCategory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TelemetryEventPropertyTypeExt": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TelemetryEventPropertyTypeExt = requireAssignableTo<TypeOnly<old.TelemetryEventPropertyTypeExt>, TypeOnly<current.TelemetryEventPropertyTypeExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TelemetryEventPropertyTypeExt": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TelemetryEventPropertyTypeExt = requireAssignableTo<TypeOnly<current.TelemetryEventPropertyTypeExt>, TypeOnly<old.TelemetryEventPropertyTypeExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TelemetryEventPropertyTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TelemetryEventPropertyTypes = requireAssignableTo<TypeOnly<old.TelemetryEventPropertyTypes>, TypeOnly<current.TelemetryEventPropertyTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TelemetryEventPropertyTypes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TelemetryEventPropertyTypes = requireAssignableTo<TypeOnly<current.TelemetryEventPropertyTypes>, TypeOnly<old.TelemetryEventPropertyTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_connectedEventName": {"backCompat": false}
 */
declare type current_as_old_for_Variable_connectedEventName = requireAssignableTo<TypeOnly<typeof current.connectedEventName>, TypeOnly<typeof old.connectedEventName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_disconnectedEventName": {"backCompat": false}
 */
declare type current_as_old_for_Variable_disconnectedEventName = requireAssignableTo<TypeOnly<typeof current.disconnectedEventName>, TypeOnly<typeof old.disconnectedEventName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_eventNamespaceSeparator": {"backCompat": false}
 */
declare type current_as_old_for_Variable_eventNamespaceSeparator = requireAssignableTo<TypeOnly<typeof current.eventNamespaceSeparator>, TypeOnly<typeof old.eventNamespaceSeparator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_extractSafePropertiesFromMessage": {"backCompat": false}
 */
declare type current_as_old_for_Variable_extractSafePropertiesFromMessage = requireAssignableTo<TypeOnly<typeof current.extractSafePropertiesFromMessage>, TypeOnly<typeof old.extractSafePropertiesFromMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_getCircularReplacer": {"backCompat": false}
 */
declare type current_as_old_for_Variable_getCircularReplacer = requireAssignableTo<TypeOnly<typeof current.getCircularReplacer>, TypeOnly<typeof old.getCircularReplacer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_hasErrorInstanceId": {"backCompat": false}
 */
declare type current_as_old_for_Variable_hasErrorInstanceId = requireAssignableTo<TypeOnly<typeof current.hasErrorInstanceId>, TypeOnly<typeof old.hasErrorInstanceId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_isILoggingError": {"backCompat": false}
 */
declare type current_as_old_for_Variable_isILoggingError = requireAssignableTo<TypeOnly<typeof current.isILoggingError>, TypeOnly<typeof old.isILoggingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_NORMALIZED_ERROR_TYPE": {"backCompat": false}
 */
declare type current_as_old_for_Variable_NORMALIZED_ERROR_TYPE = requireAssignableTo<TypeOnly<typeof current.NORMALIZED_ERROR_TYPE>, TypeOnly<typeof old.NORMALIZED_ERROR_TYPE>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_sessionStorageConfigProvider": {"backCompat": false}
 */
declare type current_as_old_for_Variable_sessionStorageConfigProvider = requireAssignableTo<TypeOnly<typeof current.sessionStorageConfigProvider>, TypeOnly<typeof old.sessionStorageConfigProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_tagCodeArtifacts": {"backCompat": false}
 */
declare type current_as_old_for_Variable_tagCodeArtifacts = requireAssignableTo<TypeOnly<typeof current.tagCodeArtifacts>, TypeOnly<typeof old.tagCodeArtifacts>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_tagData": {"backCompat": false}
 */
declare type current_as_old_for_Variable_tagData = requireAssignableTo<TypeOnly<typeof current.tagData>, TypeOnly<typeof old.tagData>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_wrapConfigProviderWithDefaults": {"backCompat": false}
 */
declare type current_as_old_for_Variable_wrapConfigProviderWithDefaults = requireAssignableTo<TypeOnly<typeof current.wrapConfigProviderWithDefaults>, TypeOnly<typeof old.wrapConfigProviderWithDefaults>>
