/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/telemetry-utils-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DataCorruptionError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_DataCorruptionError():
    TypeOnly<old.DataCorruptionError>;
declare function use_current_ClassDeclaration_DataCorruptionError(
    use: TypeOnly<current.DataCorruptionError>): void;
use_current_ClassDeclaration_DataCorruptionError(
    get_old_ClassDeclaration_DataCorruptionError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DataCorruptionError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_DataCorruptionError():
    TypeOnly<current.DataCorruptionError>;
declare function use_old_ClassDeclaration_DataCorruptionError(
    use: TypeOnly<old.DataCorruptionError>): void;
use_old_ClassDeclaration_DataCorruptionError(
    get_current_ClassDeclaration_DataCorruptionError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DataProcessingError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_DataProcessingError():
    TypeOnly<old.DataProcessingError>;
declare function use_current_ClassDeclaration_DataProcessingError(
    use: TypeOnly<current.DataProcessingError>): void;
use_current_ClassDeclaration_DataProcessingError(
    get_old_ClassDeclaration_DataProcessingError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DataProcessingError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_DataProcessingError():
    TypeOnly<current.DataProcessingError>;
declare function use_old_ClassDeclaration_DataProcessingError(
    use: TypeOnly<old.DataProcessingError>): void;
use_old_ClassDeclaration_DataProcessingError(
    get_current_ClassDeclaration_DataProcessingError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_EventEmitterWithErrorHandling": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_EventEmitterWithErrorHandling():
    TypeOnly<old.EventEmitterWithErrorHandling>;
declare function use_current_ClassDeclaration_EventEmitterWithErrorHandling(
    use: TypeOnly<current.EventEmitterWithErrorHandling>): void;
use_current_ClassDeclaration_EventEmitterWithErrorHandling(
    get_old_ClassDeclaration_EventEmitterWithErrorHandling());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_EventEmitterWithErrorHandling": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_EventEmitterWithErrorHandling():
    TypeOnly<current.EventEmitterWithErrorHandling>;
declare function use_old_ClassDeclaration_EventEmitterWithErrorHandling(
    use: TypeOnly<old.EventEmitterWithErrorHandling>): void;
use_old_ClassDeclaration_EventEmitterWithErrorHandling(
    get_current_ClassDeclaration_EventEmitterWithErrorHandling());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_GenericError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_GenericError():
    TypeOnly<old.GenericError>;
declare function use_current_ClassDeclaration_GenericError(
    use: TypeOnly<current.GenericError>): void;
use_current_ClassDeclaration_GenericError(
    get_old_ClassDeclaration_GenericError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_GenericError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_GenericError():
    TypeOnly<current.GenericError>;
declare function use_old_ClassDeclaration_GenericError(
    use: TypeOnly<old.GenericError>): void;
use_old_ClassDeclaration_GenericError(
    get_current_ClassDeclaration_GenericError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConfigProvider": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IConfigProvider():
    TypeOnly<old.IConfigProvider>;
declare function use_current_InterfaceDeclaration_IConfigProvider(
    use: TypeOnly<current.IConfigProvider>): void;
use_current_InterfaceDeclaration_IConfigProvider(
    get_old_InterfaceDeclaration_IConfigProvider());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConfigProvider": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IConfigProvider():
    TypeOnly<current.IConfigProvider>;
declare function use_old_InterfaceDeclaration_IConfigProvider(
    use: TypeOnly<old.IConfigProvider>): void;
use_old_InterfaceDeclaration_IConfigProvider(
    get_current_InterfaceDeclaration_IConfigProvider());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEventSampler": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IEventSampler():
    TypeOnly<old.IEventSampler>;
declare function use_current_InterfaceDeclaration_IEventSampler(
    use: TypeOnly<current.IEventSampler>): void;
use_current_InterfaceDeclaration_IEventSampler(
    get_old_InterfaceDeclaration_IEventSampler());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEventSampler": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IEventSampler():
    TypeOnly<current.IEventSampler>;
declare function use_old_InterfaceDeclaration_IEventSampler(
    use: TypeOnly<old.IEventSampler>): void;
use_old_InterfaceDeclaration_IEventSampler(
    get_current_InterfaceDeclaration_IEventSampler());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidErrorAnnotations": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidErrorAnnotations():
    TypeOnly<old.IFluidErrorAnnotations>;
declare function use_current_InterfaceDeclaration_IFluidErrorAnnotations(
    use: TypeOnly<current.IFluidErrorAnnotations>): void;
use_current_InterfaceDeclaration_IFluidErrorAnnotations(
    get_old_InterfaceDeclaration_IFluidErrorAnnotations());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidErrorAnnotations": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidErrorAnnotations():
    TypeOnly<current.IFluidErrorAnnotations>;
declare function use_old_InterfaceDeclaration_IFluidErrorAnnotations(
    use: TypeOnly<old.IFluidErrorAnnotations>): void;
use_old_InterfaceDeclaration_IFluidErrorAnnotations(
    get_current_InterfaceDeclaration_IFluidErrorAnnotations());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidErrorBase": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidErrorBase():
    TypeOnly<old.IFluidErrorBase>;
declare function use_current_InterfaceDeclaration_IFluidErrorBase(
    use: TypeOnly<current.IFluidErrorBase>): void;
use_current_InterfaceDeclaration_IFluidErrorBase(
    get_old_InterfaceDeclaration_IFluidErrorBase());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidErrorBase": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidErrorBase():
    TypeOnly<current.IFluidErrorBase>;
declare function use_old_InterfaceDeclaration_IFluidErrorBase(
    use: TypeOnly<old.IFluidErrorBase>): void;
use_old_InterfaceDeclaration_IFluidErrorBase(
    get_current_InterfaceDeclaration_IFluidErrorBase());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMockLoggerExt": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMockLoggerExt():
    TypeOnly<old.IMockLoggerExt>;
declare function use_current_InterfaceDeclaration_IMockLoggerExt(
    use: TypeOnly<current.IMockLoggerExt>): void;
use_current_InterfaceDeclaration_IMockLoggerExt(
    get_old_InterfaceDeclaration_IMockLoggerExt());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMockLoggerExt": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMockLoggerExt():
    TypeOnly<current.IMockLoggerExt>;
declare function use_old_InterfaceDeclaration_IMockLoggerExt(
    use: TypeOnly<old.IMockLoggerExt>): void;
use_old_InterfaceDeclaration_IMockLoggerExt(
    get_current_InterfaceDeclaration_IMockLoggerExt());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IPerformanceEventMarkers": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IPerformanceEventMarkers():
    TypeOnly<old.IPerformanceEventMarkers>;
declare function use_current_InterfaceDeclaration_IPerformanceEventMarkers(
    use: TypeOnly<current.IPerformanceEventMarkers>): void;
use_current_InterfaceDeclaration_IPerformanceEventMarkers(
    get_old_InterfaceDeclaration_IPerformanceEventMarkers());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IPerformanceEventMarkers": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IPerformanceEventMarkers():
    TypeOnly<current.IPerformanceEventMarkers>;
declare function use_old_InterfaceDeclaration_IPerformanceEventMarkers(
    use: TypeOnly<old.IPerformanceEventMarkers>): void;
use_old_InterfaceDeclaration_IPerformanceEventMarkers(
    get_current_InterfaceDeclaration_IPerformanceEventMarkers());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISampledTelemetryLogger": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISampledTelemetryLogger():
    TypeOnly<old.ISampledTelemetryLogger>;
declare function use_current_InterfaceDeclaration_ISampledTelemetryLogger(
    use: TypeOnly<current.ISampledTelemetryLogger>): void;
use_current_InterfaceDeclaration_ISampledTelemetryLogger(
    get_old_InterfaceDeclaration_ISampledTelemetryLogger());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISampledTelemetryLogger": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISampledTelemetryLogger():
    TypeOnly<current.ISampledTelemetryLogger>;
declare function use_old_InterfaceDeclaration_ISampledTelemetryLogger(
    use: TypeOnly<old.ISampledTelemetryLogger>): void;
use_old_InterfaceDeclaration_ISampledTelemetryLogger(
    get_current_InterfaceDeclaration_ISampledTelemetryLogger());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt():
    TypeOnly<old.ITaggedTelemetryPropertyTypeExt>;
declare function use_current_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt(
    use: TypeOnly<current.ITaggedTelemetryPropertyTypeExt>): void;
use_current_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt(
    get_old_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt():
    TypeOnly<current.ITaggedTelemetryPropertyTypeExt>;
declare function use_old_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt(
    use: TypeOnly<old.ITaggedTelemetryPropertyTypeExt>): void;
use_old_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt(
    get_current_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryErrorEventExt": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITelemetryErrorEventExt():
    TypeOnly<old.ITelemetryErrorEventExt>;
declare function use_current_InterfaceDeclaration_ITelemetryErrorEventExt(
    use: TypeOnly<current.ITelemetryErrorEventExt>): void;
use_current_InterfaceDeclaration_ITelemetryErrorEventExt(
    get_old_InterfaceDeclaration_ITelemetryErrorEventExt());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryErrorEventExt": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITelemetryErrorEventExt():
    TypeOnly<current.ITelemetryErrorEventExt>;
declare function use_old_InterfaceDeclaration_ITelemetryErrorEventExt(
    use: TypeOnly<old.ITelemetryErrorEventExt>): void;
use_old_InterfaceDeclaration_ITelemetryErrorEventExt(
    get_current_InterfaceDeclaration_ITelemetryErrorEventExt());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryEventExt": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITelemetryEventExt():
    TypeOnly<old.ITelemetryEventExt>;
declare function use_current_InterfaceDeclaration_ITelemetryEventExt(
    use: TypeOnly<current.ITelemetryEventExt>): void;
use_current_InterfaceDeclaration_ITelemetryEventExt(
    get_old_InterfaceDeclaration_ITelemetryEventExt());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryEventExt": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITelemetryEventExt():
    TypeOnly<current.ITelemetryEventExt>;
declare function use_old_InterfaceDeclaration_ITelemetryEventExt(
    use: TypeOnly<old.ITelemetryEventExt>): void;
use_old_InterfaceDeclaration_ITelemetryEventExt(
    get_current_InterfaceDeclaration_ITelemetryEventExt());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryGenericEventExt": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITelemetryGenericEventExt():
    TypeOnly<old.ITelemetryGenericEventExt>;
declare function use_current_InterfaceDeclaration_ITelemetryGenericEventExt(
    use: TypeOnly<current.ITelemetryGenericEventExt>): void;
use_current_InterfaceDeclaration_ITelemetryGenericEventExt(
    get_old_InterfaceDeclaration_ITelemetryGenericEventExt());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryGenericEventExt": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITelemetryGenericEventExt():
    TypeOnly<current.ITelemetryGenericEventExt>;
declare function use_old_InterfaceDeclaration_ITelemetryGenericEventExt(
    use: TypeOnly<old.ITelemetryGenericEventExt>): void;
use_old_InterfaceDeclaration_ITelemetryGenericEventExt(
    get_current_InterfaceDeclaration_ITelemetryGenericEventExt());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryLoggerExt": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITelemetryLoggerExt():
    TypeOnly<old.ITelemetryLoggerExt>;
declare function use_current_InterfaceDeclaration_ITelemetryLoggerExt(
    use: TypeOnly<current.ITelemetryLoggerExt>): void;
use_current_InterfaceDeclaration_ITelemetryLoggerExt(
    get_old_InterfaceDeclaration_ITelemetryLoggerExt());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryLoggerExt": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITelemetryLoggerExt():
    TypeOnly<current.ITelemetryLoggerExt>;
declare function use_old_InterfaceDeclaration_ITelemetryLoggerExt(
    use: TypeOnly<old.ITelemetryLoggerExt>): void;
use_old_InterfaceDeclaration_ITelemetryLoggerExt(
    get_current_InterfaceDeclaration_ITelemetryLoggerExt());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ITelemetryLoggerPropertyBag": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ITelemetryLoggerPropertyBag():
    TypeOnly<old.ITelemetryLoggerPropertyBag>;
declare function use_current_TypeAliasDeclaration_ITelemetryLoggerPropertyBag(
    use: TypeOnly<current.ITelemetryLoggerPropertyBag>): void;
use_current_TypeAliasDeclaration_ITelemetryLoggerPropertyBag(
    get_old_TypeAliasDeclaration_ITelemetryLoggerPropertyBag());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ITelemetryLoggerPropertyBag": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ITelemetryLoggerPropertyBag():
    TypeOnly<current.ITelemetryLoggerPropertyBag>;
declare function use_old_TypeAliasDeclaration_ITelemetryLoggerPropertyBag(
    use: TypeOnly<old.ITelemetryLoggerPropertyBag>): void;
use_old_TypeAliasDeclaration_ITelemetryLoggerPropertyBag(
    get_current_TypeAliasDeclaration_ITelemetryLoggerPropertyBag());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryLoggerPropertyBags": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITelemetryLoggerPropertyBags():
    TypeOnly<old.ITelemetryLoggerPropertyBags>;
declare function use_current_InterfaceDeclaration_ITelemetryLoggerPropertyBags(
    use: TypeOnly<current.ITelemetryLoggerPropertyBags>): void;
use_current_InterfaceDeclaration_ITelemetryLoggerPropertyBags(
    get_old_InterfaceDeclaration_ITelemetryLoggerPropertyBags());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryLoggerPropertyBags": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITelemetryLoggerPropertyBags():
    TypeOnly<current.ITelemetryLoggerPropertyBags>;
declare function use_old_InterfaceDeclaration_ITelemetryLoggerPropertyBags(
    use: TypeOnly<old.ITelemetryLoggerPropertyBags>): void;
use_old_InterfaceDeclaration_ITelemetryLoggerPropertyBags(
    get_current_InterfaceDeclaration_ITelemetryLoggerPropertyBags());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryPerformanceEventExt": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITelemetryPerformanceEventExt():
    TypeOnly<old.ITelemetryPerformanceEventExt>;
declare function use_current_InterfaceDeclaration_ITelemetryPerformanceEventExt(
    use: TypeOnly<current.ITelemetryPerformanceEventExt>): void;
use_current_InterfaceDeclaration_ITelemetryPerformanceEventExt(
    get_old_InterfaceDeclaration_ITelemetryPerformanceEventExt());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryPerformanceEventExt": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITelemetryPerformanceEventExt():
    TypeOnly<current.ITelemetryPerformanceEventExt>;
declare function use_old_InterfaceDeclaration_ITelemetryPerformanceEventExt(
    use: TypeOnly<old.ITelemetryPerformanceEventExt>): void;
use_old_InterfaceDeclaration_ITelemetryPerformanceEventExt(
    get_current_InterfaceDeclaration_ITelemetryPerformanceEventExt());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ITelemetryPropertiesExt": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ITelemetryPropertiesExt():
    TypeOnly<old.ITelemetryPropertiesExt>;
declare function use_current_TypeAliasDeclaration_ITelemetryPropertiesExt(
    use: TypeOnly<current.ITelemetryPropertiesExt>): void;
use_current_TypeAliasDeclaration_ITelemetryPropertiesExt(
    get_old_TypeAliasDeclaration_ITelemetryPropertiesExt());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ITelemetryPropertiesExt": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ITelemetryPropertiesExt():
    TypeOnly<current.ITelemetryPropertiesExt>;
declare function use_old_TypeAliasDeclaration_ITelemetryPropertiesExt(
    use: TypeOnly<old.ITelemetryPropertiesExt>): void;
use_old_TypeAliasDeclaration_ITelemetryPropertiesExt(
    get_current_TypeAliasDeclaration_ITelemetryPropertiesExt());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LoggingError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_LoggingError():
    TypeOnly<old.LoggingError>;
declare function use_current_ClassDeclaration_LoggingError(
    use: TypeOnly<current.LoggingError>): void;
use_current_ClassDeclaration_LoggingError(
    get_old_ClassDeclaration_LoggingError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LoggingError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_LoggingError():
    TypeOnly<current.LoggingError>;
declare function use_old_ClassDeclaration_LoggingError(
    use: TypeOnly<old.LoggingError>): void;
use_old_ClassDeclaration_LoggingError(
    get_current_ClassDeclaration_LoggingError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockLogger": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_MockLogger():
    TypeOnly<old.MockLogger>;
declare function use_current_ClassDeclaration_MockLogger(
    use: TypeOnly<current.MockLogger>): void;
use_current_ClassDeclaration_MockLogger(
    get_old_ClassDeclaration_MockLogger());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockLogger": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_MockLogger():
    TypeOnly<current.MockLogger>;
declare function use_old_ClassDeclaration_MockLogger(
    use: TypeOnly<old.MockLogger>): void;
use_old_ClassDeclaration_MockLogger(
    get_current_ClassDeclaration_MockLogger());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MonitoringContext": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_MonitoringContext():
    TypeOnly<old.MonitoringContext>;
declare function use_current_InterfaceDeclaration_MonitoringContext(
    use: TypeOnly<current.MonitoringContext>): void;
use_current_InterfaceDeclaration_MonitoringContext(
    get_old_InterfaceDeclaration_MonitoringContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MonitoringContext": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_MonitoringContext():
    TypeOnly<current.MonitoringContext>;
declare function use_old_InterfaceDeclaration_MonitoringContext(
    use: TypeOnly<old.MonitoringContext>): void;
use_old_InterfaceDeclaration_MonitoringContext(
    get_current_InterfaceDeclaration_MonitoringContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MultiSinkLoggerProperties": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_MultiSinkLoggerProperties():
    TypeOnly<old.MultiSinkLoggerProperties>;
declare function use_current_InterfaceDeclaration_MultiSinkLoggerProperties(
    use: TypeOnly<current.MultiSinkLoggerProperties>): void;
use_current_InterfaceDeclaration_MultiSinkLoggerProperties(
    get_old_InterfaceDeclaration_MultiSinkLoggerProperties());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MultiSinkLoggerProperties": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_MultiSinkLoggerProperties():
    TypeOnly<current.MultiSinkLoggerProperties>;
declare function use_old_InterfaceDeclaration_MultiSinkLoggerProperties(
    use: TypeOnly<old.MultiSinkLoggerProperties>): void;
use_old_InterfaceDeclaration_MultiSinkLoggerProperties(
    get_current_InterfaceDeclaration_MultiSinkLoggerProperties());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_NORMALIZED_ERROR_TYPE": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_NORMALIZED_ERROR_TYPE():
    TypeOnly<typeof old.NORMALIZED_ERROR_TYPE>;
declare function use_current_VariableDeclaration_NORMALIZED_ERROR_TYPE(
    use: TypeOnly<typeof current.NORMALIZED_ERROR_TYPE>): void;
use_current_VariableDeclaration_NORMALIZED_ERROR_TYPE(
    get_old_VariableDeclaration_NORMALIZED_ERROR_TYPE());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_NORMALIZED_ERROR_TYPE": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_NORMALIZED_ERROR_TYPE():
    TypeOnly<typeof current.NORMALIZED_ERROR_TYPE>;
declare function use_old_VariableDeclaration_NORMALIZED_ERROR_TYPE(
    use: TypeOnly<typeof old.NORMALIZED_ERROR_TYPE>): void;
use_old_VariableDeclaration_NORMALIZED_ERROR_TYPE(
    get_current_VariableDeclaration_NORMALIZED_ERROR_TYPE());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_PerformanceEvent": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_PerformanceEvent():
    TypeOnly<old.PerformanceEvent>;
declare function use_current_ClassDeclaration_PerformanceEvent(
    use: TypeOnly<current.PerformanceEvent>): void;
use_current_ClassDeclaration_PerformanceEvent(
    get_old_ClassDeclaration_PerformanceEvent());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_PerformanceEvent": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_PerformanceEvent():
    TypeOnly<current.PerformanceEvent>;
declare function use_old_ClassDeclaration_PerformanceEvent(
    use: TypeOnly<old.PerformanceEvent>): void;
use_old_ClassDeclaration_PerformanceEvent(
    get_current_ClassDeclaration_PerformanceEvent());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SampledTelemetryHelper": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SampledTelemetryHelper():
    TypeOnly<old.SampledTelemetryHelper>;
declare function use_current_ClassDeclaration_SampledTelemetryHelper(
    use: TypeOnly<current.SampledTelemetryHelper>): void;
use_current_ClassDeclaration_SampledTelemetryHelper(
    get_old_ClassDeclaration_SampledTelemetryHelper());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SampledTelemetryHelper": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SampledTelemetryHelper():
    TypeOnly<current.SampledTelemetryHelper>;
declare function use_old_ClassDeclaration_SampledTelemetryHelper(
    use: TypeOnly<old.SampledTelemetryHelper>): void;
use_old_ClassDeclaration_SampledTelemetryHelper(
    get_current_ClassDeclaration_SampledTelemetryHelper());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TaggedLoggerAdapter": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TaggedLoggerAdapter():
    TypeOnly<old.TaggedLoggerAdapter>;
declare function use_current_ClassDeclaration_TaggedLoggerAdapter(
    use: TypeOnly<current.TaggedLoggerAdapter>): void;
use_current_ClassDeclaration_TaggedLoggerAdapter(
    get_old_ClassDeclaration_TaggedLoggerAdapter());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TaggedLoggerAdapter": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TaggedLoggerAdapter():
    TypeOnly<current.TaggedLoggerAdapter>;
declare function use_old_ClassDeclaration_TaggedLoggerAdapter(
    use: TypeOnly<old.TaggedLoggerAdapter>): void;
use_old_ClassDeclaration_TaggedLoggerAdapter(
    get_current_ClassDeclaration_TaggedLoggerAdapter());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_TelemetryDataTag": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_TelemetryDataTag():
    TypeOnly<old.TelemetryDataTag>;
declare function use_current_EnumDeclaration_TelemetryDataTag(
    use: TypeOnly<current.TelemetryDataTag>): void;
use_current_EnumDeclaration_TelemetryDataTag(
    get_old_EnumDeclaration_TelemetryDataTag());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_TelemetryDataTag": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_TelemetryDataTag():
    TypeOnly<current.TelemetryDataTag>;
declare function use_old_EnumDeclaration_TelemetryDataTag(
    use: TypeOnly<old.TelemetryDataTag>): void;
use_old_EnumDeclaration_TelemetryDataTag(
    get_current_EnumDeclaration_TelemetryDataTag());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TelemetryEventBatcher": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TelemetryEventBatcher():
    TypeOnly<current.TelemetryEventBatcher<any>>;
declare function use_old_ClassDeclaration_TelemetryEventBatcher(
    use: TypeOnly<old.TelemetryEventBatcher<any>>): void;
use_old_ClassDeclaration_TelemetryEventBatcher(
    get_current_ClassDeclaration_TelemetryEventBatcher());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TelemetryEventCategory": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_TelemetryEventCategory():
    TypeOnly<old.TelemetryEventCategory>;
declare function use_current_TypeAliasDeclaration_TelemetryEventCategory(
    use: TypeOnly<current.TelemetryEventCategory>): void;
use_current_TypeAliasDeclaration_TelemetryEventCategory(
    get_old_TypeAliasDeclaration_TelemetryEventCategory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TelemetryEventCategory": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_TelemetryEventCategory():
    TypeOnly<current.TelemetryEventCategory>;
declare function use_old_TypeAliasDeclaration_TelemetryEventCategory(
    use: TypeOnly<old.TelemetryEventCategory>): void;
use_old_TypeAliasDeclaration_TelemetryEventCategory(
    get_current_TypeAliasDeclaration_TelemetryEventCategory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TelemetryEventPropertyTypeExt": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_TelemetryEventPropertyTypeExt():
    TypeOnly<old.TelemetryEventPropertyTypeExt>;
declare function use_current_TypeAliasDeclaration_TelemetryEventPropertyTypeExt(
    use: TypeOnly<current.TelemetryEventPropertyTypeExt>): void;
use_current_TypeAliasDeclaration_TelemetryEventPropertyTypeExt(
    get_old_TypeAliasDeclaration_TelemetryEventPropertyTypeExt());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TelemetryEventPropertyTypeExt": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_TelemetryEventPropertyTypeExt():
    TypeOnly<current.TelemetryEventPropertyTypeExt>;
declare function use_old_TypeAliasDeclaration_TelemetryEventPropertyTypeExt(
    use: TypeOnly<old.TelemetryEventPropertyTypeExt>): void;
use_old_TypeAliasDeclaration_TelemetryEventPropertyTypeExt(
    get_current_TypeAliasDeclaration_TelemetryEventPropertyTypeExt());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TelemetryEventPropertyTypes": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_TelemetryEventPropertyTypes():
    TypeOnly<old.TelemetryEventPropertyTypes>;
declare function use_current_TypeAliasDeclaration_TelemetryEventPropertyTypes(
    use: TypeOnly<current.TelemetryEventPropertyTypes>): void;
use_current_TypeAliasDeclaration_TelemetryEventPropertyTypes(
    get_old_TypeAliasDeclaration_TelemetryEventPropertyTypes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TelemetryEventPropertyTypes": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_TelemetryEventPropertyTypes():
    TypeOnly<current.TelemetryEventPropertyTypes>;
declare function use_old_TypeAliasDeclaration_TelemetryEventPropertyTypes(
    use: TypeOnly<old.TelemetryEventPropertyTypes>): void;
use_old_TypeAliasDeclaration_TelemetryEventPropertyTypes(
    get_current_TypeAliasDeclaration_TelemetryEventPropertyTypes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ThresholdCounter": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_ThresholdCounter():
    TypeOnly<old.ThresholdCounter>;
declare function use_current_ClassDeclaration_ThresholdCounter(
    use: TypeOnly<current.ThresholdCounter>): void;
use_current_ClassDeclaration_ThresholdCounter(
    get_old_ClassDeclaration_ThresholdCounter());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ThresholdCounter": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_ThresholdCounter():
    TypeOnly<current.ThresholdCounter>;
declare function use_old_ClassDeclaration_ThresholdCounter(
    use: TypeOnly<old.ThresholdCounter>): void;
use_old_ClassDeclaration_ThresholdCounter(
    get_current_ClassDeclaration_ThresholdCounter());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_UsageError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_UsageError():
    TypeOnly<old.UsageError>;
declare function use_current_ClassDeclaration_UsageError(
    use: TypeOnly<current.UsageError>): void;
use_current_ClassDeclaration_UsageError(
    get_old_ClassDeclaration_UsageError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_UsageError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_UsageError():
    TypeOnly<current.UsageError>;
declare function use_old_ClassDeclaration_UsageError(
    use: TypeOnly<old.UsageError>): void;
use_old_ClassDeclaration_UsageError(
    get_current_ClassDeclaration_UsageError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_connectedEventName": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_connectedEventName():
    TypeOnly<typeof old.connectedEventName>;
declare function use_current_VariableDeclaration_connectedEventName(
    use: TypeOnly<typeof current.connectedEventName>): void;
use_current_VariableDeclaration_connectedEventName(
    get_old_VariableDeclaration_connectedEventName());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_connectedEventName": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_connectedEventName():
    TypeOnly<typeof current.connectedEventName>;
declare function use_old_VariableDeclaration_connectedEventName(
    use: TypeOnly<typeof old.connectedEventName>): void;
use_old_VariableDeclaration_connectedEventName(
    get_current_VariableDeclaration_connectedEventName());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createChildLogger": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createChildLogger():
    TypeOnly<typeof old.createChildLogger>;
declare function use_current_FunctionDeclaration_createChildLogger(
    use: TypeOnly<typeof current.createChildLogger>): void;
use_current_FunctionDeclaration_createChildLogger(
    get_old_FunctionDeclaration_createChildLogger());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createChildLogger": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createChildLogger():
    TypeOnly<typeof current.createChildLogger>;
declare function use_old_FunctionDeclaration_createChildLogger(
    use: TypeOnly<typeof old.createChildLogger>): void;
use_old_FunctionDeclaration_createChildLogger(
    get_current_FunctionDeclaration_createChildLogger());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createChildMonitoringContext": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createChildMonitoringContext():
    TypeOnly<typeof old.createChildMonitoringContext>;
declare function use_current_FunctionDeclaration_createChildMonitoringContext(
    use: TypeOnly<typeof current.createChildMonitoringContext>): void;
use_current_FunctionDeclaration_createChildMonitoringContext(
    get_old_FunctionDeclaration_createChildMonitoringContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createChildMonitoringContext": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createChildMonitoringContext():
    TypeOnly<typeof current.createChildMonitoringContext>;
declare function use_old_FunctionDeclaration_createChildMonitoringContext(
    use: TypeOnly<typeof old.createChildMonitoringContext>): void;
use_old_FunctionDeclaration_createChildMonitoringContext(
    get_current_FunctionDeclaration_createChildMonitoringContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createMockLoggerExt": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createMockLoggerExt():
    TypeOnly<typeof old.createMockLoggerExt>;
declare function use_current_FunctionDeclaration_createMockLoggerExt(
    use: TypeOnly<typeof current.createMockLoggerExt>): void;
use_current_FunctionDeclaration_createMockLoggerExt(
    get_old_FunctionDeclaration_createMockLoggerExt());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createMockLoggerExt": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createMockLoggerExt():
    TypeOnly<typeof current.createMockLoggerExt>;
declare function use_old_FunctionDeclaration_createMockLoggerExt(
    use: TypeOnly<typeof old.createMockLoggerExt>): void;
use_old_FunctionDeclaration_createMockLoggerExt(
    get_current_FunctionDeclaration_createMockLoggerExt());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createMultiSinkLogger": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createMultiSinkLogger():
    TypeOnly<typeof old.createMultiSinkLogger>;
declare function use_current_FunctionDeclaration_createMultiSinkLogger(
    use: TypeOnly<typeof current.createMultiSinkLogger>): void;
use_current_FunctionDeclaration_createMultiSinkLogger(
    get_old_FunctionDeclaration_createMultiSinkLogger());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createMultiSinkLogger": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createMultiSinkLogger():
    TypeOnly<typeof current.createMultiSinkLogger>;
declare function use_old_FunctionDeclaration_createMultiSinkLogger(
    use: TypeOnly<typeof old.createMultiSinkLogger>): void;
use_old_FunctionDeclaration_createMultiSinkLogger(
    get_current_FunctionDeclaration_createMultiSinkLogger());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSampledLogger": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createSampledLogger():
    TypeOnly<typeof old.createSampledLogger>;
declare function use_current_FunctionDeclaration_createSampledLogger(
    use: TypeOnly<typeof current.createSampledLogger>): void;
use_current_FunctionDeclaration_createSampledLogger(
    get_old_FunctionDeclaration_createSampledLogger());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSampledLogger": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createSampledLogger():
    TypeOnly<typeof current.createSampledLogger>;
declare function use_old_FunctionDeclaration_createSampledLogger(
    use: TypeOnly<typeof old.createSampledLogger>): void;
use_old_FunctionDeclaration_createSampledLogger(
    get_current_FunctionDeclaration_createSampledLogger());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_disconnectedEventName": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_disconnectedEventName():
    TypeOnly<typeof old.disconnectedEventName>;
declare function use_current_VariableDeclaration_disconnectedEventName(
    use: TypeOnly<typeof current.disconnectedEventName>): void;
use_current_VariableDeclaration_disconnectedEventName(
    get_old_VariableDeclaration_disconnectedEventName());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_disconnectedEventName": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_disconnectedEventName():
    TypeOnly<typeof current.disconnectedEventName>;
declare function use_old_VariableDeclaration_disconnectedEventName(
    use: TypeOnly<typeof old.disconnectedEventName>): void;
use_old_VariableDeclaration_disconnectedEventName(
    get_current_VariableDeclaration_disconnectedEventName());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_eventNamespaceSeparator": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_eventNamespaceSeparator():
    TypeOnly<typeof old.eventNamespaceSeparator>;
declare function use_current_VariableDeclaration_eventNamespaceSeparator(
    use: TypeOnly<typeof current.eventNamespaceSeparator>): void;
use_current_VariableDeclaration_eventNamespaceSeparator(
    get_old_VariableDeclaration_eventNamespaceSeparator());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_eventNamespaceSeparator": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_eventNamespaceSeparator():
    TypeOnly<typeof current.eventNamespaceSeparator>;
declare function use_old_VariableDeclaration_eventNamespaceSeparator(
    use: TypeOnly<typeof old.eventNamespaceSeparator>): void;
use_old_VariableDeclaration_eventNamespaceSeparator(
    get_current_VariableDeclaration_eventNamespaceSeparator());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_extractLogSafeErrorProperties": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_extractLogSafeErrorProperties():
    TypeOnly<typeof old.extractLogSafeErrorProperties>;
declare function use_current_FunctionDeclaration_extractLogSafeErrorProperties(
    use: TypeOnly<typeof current.extractLogSafeErrorProperties>): void;
use_current_FunctionDeclaration_extractLogSafeErrorProperties(
    get_old_FunctionDeclaration_extractLogSafeErrorProperties());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_extractLogSafeErrorProperties": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_extractLogSafeErrorProperties():
    TypeOnly<typeof current.extractLogSafeErrorProperties>;
declare function use_old_FunctionDeclaration_extractLogSafeErrorProperties(
    use: TypeOnly<typeof old.extractLogSafeErrorProperties>): void;
use_old_FunctionDeclaration_extractLogSafeErrorProperties(
    get_current_FunctionDeclaration_extractLogSafeErrorProperties());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_extractSafePropertiesFromMessage": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_extractSafePropertiesFromMessage():
    TypeOnly<typeof old.extractSafePropertiesFromMessage>;
declare function use_current_VariableDeclaration_extractSafePropertiesFromMessage(
    use: TypeOnly<typeof current.extractSafePropertiesFromMessage>): void;
use_current_VariableDeclaration_extractSafePropertiesFromMessage(
    get_old_VariableDeclaration_extractSafePropertiesFromMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_extractSafePropertiesFromMessage": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_extractSafePropertiesFromMessage():
    TypeOnly<typeof current.extractSafePropertiesFromMessage>;
declare function use_old_VariableDeclaration_extractSafePropertiesFromMessage(
    use: TypeOnly<typeof old.extractSafePropertiesFromMessage>): void;
use_old_VariableDeclaration_extractSafePropertiesFromMessage(
    get_current_VariableDeclaration_extractSafePropertiesFromMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_formatTick": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_formatTick():
    TypeOnly<typeof old.formatTick>;
declare function use_current_FunctionDeclaration_formatTick(
    use: TypeOnly<typeof current.formatTick>): void;
use_current_FunctionDeclaration_formatTick(
    get_old_FunctionDeclaration_formatTick());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_formatTick": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_formatTick():
    TypeOnly<typeof current.formatTick>;
declare function use_old_FunctionDeclaration_formatTick(
    use: TypeOnly<typeof old.formatTick>): void;
use_old_FunctionDeclaration_formatTick(
    get_current_FunctionDeclaration_formatTick());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_generateErrorWithStack": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_generateErrorWithStack():
    TypeOnly<typeof old.generateErrorWithStack>;
declare function use_current_FunctionDeclaration_generateErrorWithStack(
    use: TypeOnly<typeof current.generateErrorWithStack>): void;
use_current_FunctionDeclaration_generateErrorWithStack(
    get_old_FunctionDeclaration_generateErrorWithStack());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_generateErrorWithStack": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_generateErrorWithStack():
    TypeOnly<typeof current.generateErrorWithStack>;
declare function use_old_FunctionDeclaration_generateErrorWithStack(
    use: TypeOnly<typeof old.generateErrorWithStack>): void;
use_old_FunctionDeclaration_generateErrorWithStack(
    get_current_FunctionDeclaration_generateErrorWithStack());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_generateStack": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_generateStack():
    TypeOnly<typeof old.generateStack>;
declare function use_current_FunctionDeclaration_generateStack(
    use: TypeOnly<typeof current.generateStack>): void;
use_current_FunctionDeclaration_generateStack(
    get_old_FunctionDeclaration_generateStack());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_generateStack": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_generateStack():
    TypeOnly<typeof current.generateStack>;
declare function use_old_FunctionDeclaration_generateStack(
    use: TypeOnly<typeof old.generateStack>): void;
use_old_FunctionDeclaration_generateStack(
    get_current_FunctionDeclaration_generateStack());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getCircularReplacer": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_getCircularReplacer():
    TypeOnly<typeof old.getCircularReplacer>;
declare function use_current_VariableDeclaration_getCircularReplacer(
    use: TypeOnly<typeof current.getCircularReplacer>): void;
use_current_VariableDeclaration_getCircularReplacer(
    get_old_VariableDeclaration_getCircularReplacer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getCircularReplacer": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_getCircularReplacer():
    TypeOnly<typeof current.getCircularReplacer>;
declare function use_old_VariableDeclaration_getCircularReplacer(
    use: TypeOnly<typeof old.getCircularReplacer>): void;
use_old_VariableDeclaration_getCircularReplacer(
    get_current_VariableDeclaration_getCircularReplacer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_hasErrorInstanceId": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_hasErrorInstanceId():
    TypeOnly<typeof old.hasErrorInstanceId>;
declare function use_current_VariableDeclaration_hasErrorInstanceId(
    use: TypeOnly<typeof current.hasErrorInstanceId>): void;
use_current_VariableDeclaration_hasErrorInstanceId(
    get_old_VariableDeclaration_hasErrorInstanceId());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_hasErrorInstanceId": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_hasErrorInstanceId():
    TypeOnly<typeof current.hasErrorInstanceId>;
declare function use_old_VariableDeclaration_hasErrorInstanceId(
    use: TypeOnly<typeof old.hasErrorInstanceId>): void;
use_old_VariableDeclaration_hasErrorInstanceId(
    get_current_VariableDeclaration_hasErrorInstanceId());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isExternalError": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_isExternalError():
    TypeOnly<typeof old.isExternalError>;
declare function use_current_FunctionDeclaration_isExternalError(
    use: TypeOnly<typeof current.isExternalError>): void;
use_current_FunctionDeclaration_isExternalError(
    get_old_FunctionDeclaration_isExternalError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isExternalError": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_isExternalError():
    TypeOnly<typeof current.isExternalError>;
declare function use_old_FunctionDeclaration_isExternalError(
    use: TypeOnly<typeof old.isExternalError>): void;
use_old_FunctionDeclaration_isExternalError(
    get_current_FunctionDeclaration_isExternalError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isFluidError": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_isFluidError():
    TypeOnly<typeof old.isFluidError>;
declare function use_current_FunctionDeclaration_isFluidError(
    use: TypeOnly<typeof current.isFluidError>): void;
use_current_FunctionDeclaration_isFluidError(
    get_old_FunctionDeclaration_isFluidError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isFluidError": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_isFluidError():
    TypeOnly<typeof current.isFluidError>;
declare function use_old_FunctionDeclaration_isFluidError(
    use: TypeOnly<typeof old.isFluidError>): void;
use_old_FunctionDeclaration_isFluidError(
    get_current_FunctionDeclaration_isFluidError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isILoggingError": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_isILoggingError():
    TypeOnly<typeof old.isILoggingError>;
declare function use_current_VariableDeclaration_isILoggingError(
    use: TypeOnly<typeof current.isILoggingError>): void;
use_current_VariableDeclaration_isILoggingError(
    get_old_VariableDeclaration_isILoggingError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isILoggingError": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_isILoggingError():
    TypeOnly<typeof current.isILoggingError>;
declare function use_old_VariableDeclaration_isILoggingError(
    use: TypeOnly<typeof old.isILoggingError>): void;
use_old_VariableDeclaration_isILoggingError(
    get_current_VariableDeclaration_isILoggingError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isTaggedTelemetryPropertyValue": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_isTaggedTelemetryPropertyValue():
    TypeOnly<typeof old.isTaggedTelemetryPropertyValue>;
declare function use_current_FunctionDeclaration_isTaggedTelemetryPropertyValue(
    use: TypeOnly<typeof current.isTaggedTelemetryPropertyValue>): void;
use_current_FunctionDeclaration_isTaggedTelemetryPropertyValue(
    get_old_FunctionDeclaration_isTaggedTelemetryPropertyValue());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isTaggedTelemetryPropertyValue": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_isTaggedTelemetryPropertyValue():
    TypeOnly<typeof current.isTaggedTelemetryPropertyValue>;
declare function use_old_FunctionDeclaration_isTaggedTelemetryPropertyValue(
    use: TypeOnly<typeof old.isTaggedTelemetryPropertyValue>): void;
use_old_FunctionDeclaration_isTaggedTelemetryPropertyValue(
    get_current_FunctionDeclaration_isTaggedTelemetryPropertyValue());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_loggerToMonitoringContext": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_loggerToMonitoringContext():
    TypeOnly<typeof old.loggerToMonitoringContext>;
declare function use_current_FunctionDeclaration_loggerToMonitoringContext(
    use: TypeOnly<typeof current.loggerToMonitoringContext>): void;
use_current_FunctionDeclaration_loggerToMonitoringContext(
    get_old_FunctionDeclaration_loggerToMonitoringContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_loggerToMonitoringContext": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_loggerToMonitoringContext():
    TypeOnly<typeof current.loggerToMonitoringContext>;
declare function use_old_FunctionDeclaration_loggerToMonitoringContext(
    use: TypeOnly<typeof old.loggerToMonitoringContext>): void;
use_old_FunctionDeclaration_loggerToMonitoringContext(
    get_current_FunctionDeclaration_loggerToMonitoringContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_measure": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_measure():
    TypeOnly<typeof old.measure>;
declare function use_current_FunctionDeclaration_measure(
    use: TypeOnly<typeof current.measure>): void;
use_current_FunctionDeclaration_measure(
    get_old_FunctionDeclaration_measure());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_measure": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_measure():
    TypeOnly<typeof current.measure>;
declare function use_old_FunctionDeclaration_measure(
    use: TypeOnly<typeof old.measure>): void;
use_old_FunctionDeclaration_measure(
    get_current_FunctionDeclaration_measure());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_mixinMonitoringContext": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_mixinMonitoringContext():
    TypeOnly<typeof old.mixinMonitoringContext>;
declare function use_current_FunctionDeclaration_mixinMonitoringContext(
    use: TypeOnly<typeof current.mixinMonitoringContext>): void;
use_current_FunctionDeclaration_mixinMonitoringContext(
    get_old_FunctionDeclaration_mixinMonitoringContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_mixinMonitoringContext": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_mixinMonitoringContext():
    TypeOnly<typeof current.mixinMonitoringContext>;
declare function use_old_FunctionDeclaration_mixinMonitoringContext(
    use: TypeOnly<typeof old.mixinMonitoringContext>): void;
use_old_FunctionDeclaration_mixinMonitoringContext(
    get_current_FunctionDeclaration_mixinMonitoringContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_normalizeError": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_normalizeError():
    TypeOnly<typeof old.normalizeError>;
declare function use_current_FunctionDeclaration_normalizeError(
    use: TypeOnly<typeof current.normalizeError>): void;
use_current_FunctionDeclaration_normalizeError(
    get_old_FunctionDeclaration_normalizeError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_normalizeError": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_normalizeError():
    TypeOnly<typeof current.normalizeError>;
declare function use_old_FunctionDeclaration_normalizeError(
    use: TypeOnly<typeof old.normalizeError>): void;
use_old_FunctionDeclaration_normalizeError(
    get_current_FunctionDeclaration_normalizeError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_numberFromString": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_numberFromString():
    TypeOnly<typeof old.numberFromString>;
declare function use_current_FunctionDeclaration_numberFromString(
    use: TypeOnly<typeof current.numberFromString>): void;
use_current_FunctionDeclaration_numberFromString(
    get_old_FunctionDeclaration_numberFromString());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_numberFromString": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_numberFromString():
    TypeOnly<typeof current.numberFromString>;
declare function use_old_FunctionDeclaration_numberFromString(
    use: TypeOnly<typeof old.numberFromString>): void;
use_old_FunctionDeclaration_numberFromString(
    get_current_FunctionDeclaration_numberFromString());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_overwriteStack": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_overwriteStack():
    TypeOnly<typeof old.overwriteStack>;
declare function use_current_FunctionDeclaration_overwriteStack(
    use: TypeOnly<typeof current.overwriteStack>): void;
use_current_FunctionDeclaration_overwriteStack(
    get_old_FunctionDeclaration_overwriteStack());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_overwriteStack": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_overwriteStack():
    TypeOnly<typeof current.overwriteStack>;
declare function use_old_FunctionDeclaration_overwriteStack(
    use: TypeOnly<typeof old.overwriteStack>): void;
use_old_FunctionDeclaration_overwriteStack(
    get_current_FunctionDeclaration_overwriteStack());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_raiseConnectedEvent": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_raiseConnectedEvent():
    TypeOnly<typeof old.raiseConnectedEvent>;
declare function use_current_FunctionDeclaration_raiseConnectedEvent(
    use: TypeOnly<typeof current.raiseConnectedEvent>): void;
use_current_FunctionDeclaration_raiseConnectedEvent(
    get_old_FunctionDeclaration_raiseConnectedEvent());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_raiseConnectedEvent": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_raiseConnectedEvent():
    TypeOnly<typeof current.raiseConnectedEvent>;
declare function use_old_FunctionDeclaration_raiseConnectedEvent(
    use: TypeOnly<typeof old.raiseConnectedEvent>): void;
use_old_FunctionDeclaration_raiseConnectedEvent(
    get_current_FunctionDeclaration_raiseConnectedEvent());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_safeRaiseEvent": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_safeRaiseEvent():
    TypeOnly<typeof old.safeRaiseEvent>;
declare function use_current_FunctionDeclaration_safeRaiseEvent(
    use: TypeOnly<typeof current.safeRaiseEvent>): void;
use_current_FunctionDeclaration_safeRaiseEvent(
    get_old_FunctionDeclaration_safeRaiseEvent());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_safeRaiseEvent": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_safeRaiseEvent():
    TypeOnly<typeof current.safeRaiseEvent>;
declare function use_old_FunctionDeclaration_safeRaiseEvent(
    use: TypeOnly<typeof old.safeRaiseEvent>): void;
use_old_FunctionDeclaration_safeRaiseEvent(
    get_current_FunctionDeclaration_safeRaiseEvent());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_sessionStorageConfigProvider": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_sessionStorageConfigProvider():
    TypeOnly<typeof old.sessionStorageConfigProvider>;
declare function use_current_VariableDeclaration_sessionStorageConfigProvider(
    use: TypeOnly<typeof current.sessionStorageConfigProvider>): void;
use_current_VariableDeclaration_sessionStorageConfigProvider(
    get_old_VariableDeclaration_sessionStorageConfigProvider());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_sessionStorageConfigProvider": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_sessionStorageConfigProvider():
    TypeOnly<typeof current.sessionStorageConfigProvider>;
declare function use_old_VariableDeclaration_sessionStorageConfigProvider(
    use: TypeOnly<typeof old.sessionStorageConfigProvider>): void;
use_old_VariableDeclaration_sessionStorageConfigProvider(
    get_current_VariableDeclaration_sessionStorageConfigProvider());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_tagCodeArtifacts": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_tagCodeArtifacts():
    TypeOnly<typeof old.tagCodeArtifacts>;
declare function use_current_VariableDeclaration_tagCodeArtifacts(
    use: TypeOnly<typeof current.tagCodeArtifacts>): void;
use_current_VariableDeclaration_tagCodeArtifacts(
    get_old_VariableDeclaration_tagCodeArtifacts());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_tagCodeArtifacts": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_tagCodeArtifacts():
    TypeOnly<typeof current.tagCodeArtifacts>;
declare function use_old_VariableDeclaration_tagCodeArtifacts(
    use: TypeOnly<typeof old.tagCodeArtifacts>): void;
use_old_VariableDeclaration_tagCodeArtifacts(
    get_current_VariableDeclaration_tagCodeArtifacts());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_tagData": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_tagData():
    TypeOnly<typeof old.tagData>;
declare function use_current_VariableDeclaration_tagData(
    use: TypeOnly<typeof current.tagData>): void;
use_current_VariableDeclaration_tagData(
    get_old_VariableDeclaration_tagData());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_tagData": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_tagData():
    TypeOnly<typeof current.tagData>;
declare function use_old_VariableDeclaration_tagData(
    use: TypeOnly<typeof old.tagData>): void;
use_old_VariableDeclaration_tagData(
    get_current_VariableDeclaration_tagData());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_validatePrecondition": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_validatePrecondition():
    TypeOnly<typeof old.validatePrecondition>;
declare function use_current_FunctionDeclaration_validatePrecondition(
    use: TypeOnly<typeof current.validatePrecondition>): void;
use_current_FunctionDeclaration_validatePrecondition(
    get_old_FunctionDeclaration_validatePrecondition());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_validatePrecondition": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_validatePrecondition():
    TypeOnly<typeof current.validatePrecondition>;
declare function use_old_FunctionDeclaration_validatePrecondition(
    use: TypeOnly<typeof old.validatePrecondition>): void;
use_old_FunctionDeclaration_validatePrecondition(
    get_current_FunctionDeclaration_validatePrecondition());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_wrapConfigProviderWithDefaults": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_wrapConfigProviderWithDefaults():
    TypeOnly<typeof old.wrapConfigProviderWithDefaults>;
declare function use_current_VariableDeclaration_wrapConfigProviderWithDefaults(
    use: TypeOnly<typeof current.wrapConfigProviderWithDefaults>): void;
use_current_VariableDeclaration_wrapConfigProviderWithDefaults(
    get_old_VariableDeclaration_wrapConfigProviderWithDefaults());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_wrapConfigProviderWithDefaults": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_wrapConfigProviderWithDefaults():
    TypeOnly<typeof current.wrapConfigProviderWithDefaults>;
declare function use_old_VariableDeclaration_wrapConfigProviderWithDefaults(
    use: TypeOnly<typeof old.wrapConfigProviderWithDefaults>): void;
use_old_VariableDeclaration_wrapConfigProviderWithDefaults(
    get_current_VariableDeclaration_wrapConfigProviderWithDefaults());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapError": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_wrapError():
    TypeOnly<typeof old.wrapError>;
declare function use_current_FunctionDeclaration_wrapError(
    use: TypeOnly<typeof current.wrapError>): void;
use_current_FunctionDeclaration_wrapError(
    get_old_FunctionDeclaration_wrapError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapError": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_wrapError():
    TypeOnly<typeof current.wrapError>;
declare function use_old_FunctionDeclaration_wrapError(
    use: TypeOnly<typeof old.wrapError>): void;
use_old_FunctionDeclaration_wrapError(
    get_current_FunctionDeclaration_wrapError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapErrorAndLog": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_wrapErrorAndLog():
    TypeOnly<typeof old.wrapErrorAndLog>;
declare function use_current_FunctionDeclaration_wrapErrorAndLog(
    use: TypeOnly<typeof current.wrapErrorAndLog>): void;
use_current_FunctionDeclaration_wrapErrorAndLog(
    get_old_FunctionDeclaration_wrapErrorAndLog());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapErrorAndLog": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_wrapErrorAndLog():
    TypeOnly<typeof current.wrapErrorAndLog>;
declare function use_old_FunctionDeclaration_wrapErrorAndLog(
    use: TypeOnly<typeof old.wrapErrorAndLog>): void;
use_old_FunctionDeclaration_wrapErrorAndLog(
    get_current_FunctionDeclaration_wrapErrorAndLog());
