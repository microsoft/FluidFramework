/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/telemetry-utils-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DataCorruptionError": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_DataCorruptionError = requireAssignableTo<TypeOnly<old.DataCorruptionError>, TypeOnly<current.DataCorruptionError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DataCorruptionError": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_DataCorruptionError = requireAssignableTo<TypeOnly<current.DataCorruptionError>, TypeOnly<old.DataCorruptionError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DataProcessingError": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_DataProcessingError = requireAssignableTo<TypeOnly<old.DataProcessingError>, TypeOnly<current.DataProcessingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DataProcessingError": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_DataProcessingError = requireAssignableTo<TypeOnly<current.DataProcessingError>, TypeOnly<old.DataProcessingError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_EventEmitterWithErrorHandling": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_EventEmitterWithErrorHandling = requireAssignableTo<TypeOnly<old.EventEmitterWithErrorHandling>, TypeOnly<current.EventEmitterWithErrorHandling>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_EventEmitterWithErrorHandling": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_EventEmitterWithErrorHandling = requireAssignableTo<TypeOnly<current.EventEmitterWithErrorHandling>, TypeOnly<old.EventEmitterWithErrorHandling>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_GenericError": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_GenericError = requireAssignableTo<TypeOnly<old.GenericError>, TypeOnly<current.GenericError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_GenericError": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_GenericError = requireAssignableTo<TypeOnly<current.GenericError>, TypeOnly<old.GenericError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConfigProvider": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IConfigProvider = requireAssignableTo<TypeOnly<old.IConfigProvider>, TypeOnly<current.IConfigProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConfigProvider": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IConfigProvider = requireAssignableTo<TypeOnly<current.IConfigProvider>, TypeOnly<old.IConfigProvider>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEventSampler": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IEventSampler = requireAssignableTo<TypeOnly<old.IEventSampler>, TypeOnly<current.IEventSampler>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEventSampler": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IEventSampler = requireAssignableTo<TypeOnly<current.IEventSampler>, TypeOnly<old.IEventSampler>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidErrorAnnotations": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IFluidErrorAnnotations = requireAssignableTo<TypeOnly<old.IFluidErrorAnnotations>, TypeOnly<current.IFluidErrorAnnotations>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidErrorAnnotations": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IFluidErrorAnnotations = requireAssignableTo<TypeOnly<current.IFluidErrorAnnotations>, TypeOnly<old.IFluidErrorAnnotations>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidErrorBase": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IFluidErrorBase = requireAssignableTo<TypeOnly<old.IFluidErrorBase>, TypeOnly<current.IFluidErrorBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidErrorBase": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IFluidErrorBase = requireAssignableTo<TypeOnly<current.IFluidErrorBase>, TypeOnly<old.IFluidErrorBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMockLoggerExt": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMockLoggerExt = requireAssignableTo<TypeOnly<old.IMockLoggerExt>, TypeOnly<current.IMockLoggerExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMockLoggerExt": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMockLoggerExt = requireAssignableTo<TypeOnly<current.IMockLoggerExt>, TypeOnly<old.IMockLoggerExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IPerformanceEventMarkers": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IPerformanceEventMarkers = requireAssignableTo<TypeOnly<old.IPerformanceEventMarkers>, TypeOnly<current.IPerformanceEventMarkers>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IPerformanceEventMarkers": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IPerformanceEventMarkers = requireAssignableTo<TypeOnly<current.IPerformanceEventMarkers>, TypeOnly<old.IPerformanceEventMarkers>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISampledTelemetryLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ISampledTelemetryLogger = requireAssignableTo<TypeOnly<old.ISampledTelemetryLogger>, TypeOnly<current.ISampledTelemetryLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISampledTelemetryLogger": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ISampledTelemetryLogger = requireAssignableTo<TypeOnly<current.ISampledTelemetryLogger>, TypeOnly<old.ISampledTelemetryLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt = requireAssignableTo<TypeOnly<old.ITaggedTelemetryPropertyTypeExt>, TypeOnly<current.ITaggedTelemetryPropertyTypeExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt = requireAssignableTo<TypeOnly<current.ITaggedTelemetryPropertyTypeExt>, TypeOnly<old.ITaggedTelemetryPropertyTypeExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryErrorEventExt": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ITelemetryErrorEventExt = requireAssignableTo<TypeOnly<old.ITelemetryErrorEventExt>, TypeOnly<current.ITelemetryErrorEventExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryErrorEventExt": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ITelemetryErrorEventExt = requireAssignableTo<TypeOnly<current.ITelemetryErrorEventExt>, TypeOnly<old.ITelemetryErrorEventExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryEventExt": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ITelemetryEventExt = requireAssignableTo<TypeOnly<old.ITelemetryEventExt>, TypeOnly<current.ITelemetryEventExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryEventExt": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ITelemetryEventExt = requireAssignableTo<TypeOnly<current.ITelemetryEventExt>, TypeOnly<old.ITelemetryEventExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryGenericEventExt": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ITelemetryGenericEventExt = requireAssignableTo<TypeOnly<old.ITelemetryGenericEventExt>, TypeOnly<current.ITelemetryGenericEventExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryGenericEventExt": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ITelemetryGenericEventExt = requireAssignableTo<TypeOnly<current.ITelemetryGenericEventExt>, TypeOnly<old.ITelemetryGenericEventExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryLoggerExt": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ITelemetryLoggerExt = requireAssignableTo<TypeOnly<old.ITelemetryLoggerExt>, TypeOnly<current.ITelemetryLoggerExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryLoggerExt": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ITelemetryLoggerExt = requireAssignableTo<TypeOnly<current.ITelemetryLoggerExt>, TypeOnly<old.ITelemetryLoggerExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ITelemetryLoggerPropertyBag": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_ITelemetryLoggerPropertyBag = requireAssignableTo<TypeOnly<old.ITelemetryLoggerPropertyBag>, TypeOnly<current.ITelemetryLoggerPropertyBag>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ITelemetryLoggerPropertyBag": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_ITelemetryLoggerPropertyBag = requireAssignableTo<TypeOnly<current.ITelemetryLoggerPropertyBag>, TypeOnly<old.ITelemetryLoggerPropertyBag>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryLoggerPropertyBags": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ITelemetryLoggerPropertyBags = requireAssignableTo<TypeOnly<old.ITelemetryLoggerPropertyBags>, TypeOnly<current.ITelemetryLoggerPropertyBags>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryLoggerPropertyBags": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ITelemetryLoggerPropertyBags = requireAssignableTo<TypeOnly<current.ITelemetryLoggerPropertyBags>, TypeOnly<old.ITelemetryLoggerPropertyBags>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryPerformanceEventExt": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ITelemetryPerformanceEventExt = requireAssignableTo<TypeOnly<old.ITelemetryPerformanceEventExt>, TypeOnly<current.ITelemetryPerformanceEventExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryPerformanceEventExt": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ITelemetryPerformanceEventExt = requireAssignableTo<TypeOnly<current.ITelemetryPerformanceEventExt>, TypeOnly<old.ITelemetryPerformanceEventExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ITelemetryPropertiesExt": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_ITelemetryPropertiesExt = requireAssignableTo<TypeOnly<old.ITelemetryPropertiesExt>, TypeOnly<current.ITelemetryPropertiesExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ITelemetryPropertiesExt": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_ITelemetryPropertiesExt = requireAssignableTo<TypeOnly<current.ITelemetryPropertiesExt>, TypeOnly<old.ITelemetryPropertiesExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LoggingError": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_LoggingError = requireAssignableTo<TypeOnly<old.LoggingError>, TypeOnly<current.LoggingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LoggingError": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_LoggingError = requireAssignableTo<TypeOnly<current.LoggingError>, TypeOnly<old.LoggingError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockLogger = requireAssignableTo<TypeOnly<old.MockLogger>, TypeOnly<current.MockLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockLogger": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockLogger = requireAssignableTo<TypeOnly<current.MockLogger>, TypeOnly<old.MockLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MonitoringContext": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_MonitoringContext = requireAssignableTo<TypeOnly<old.MonitoringContext>, TypeOnly<current.MonitoringContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MonitoringContext": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_MonitoringContext = requireAssignableTo<TypeOnly<current.MonitoringContext>, TypeOnly<old.MonitoringContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MultiSinkLoggerProperties": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_MultiSinkLoggerProperties = requireAssignableTo<TypeOnly<old.MultiSinkLoggerProperties>, TypeOnly<current.MultiSinkLoggerProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MultiSinkLoggerProperties": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_MultiSinkLoggerProperties = requireAssignableTo<TypeOnly<current.MultiSinkLoggerProperties>, TypeOnly<old.MultiSinkLoggerProperties>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_NORMALIZED_ERROR_TYPE": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_NORMALIZED_ERROR_TYPE = requireAssignableTo<TypeOnly<typeof old.NORMALIZED_ERROR_TYPE>, TypeOnly<typeof current.NORMALIZED_ERROR_TYPE>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_NORMALIZED_ERROR_TYPE": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_NORMALIZED_ERROR_TYPE = requireAssignableTo<TypeOnly<typeof current.NORMALIZED_ERROR_TYPE>, TypeOnly<typeof old.NORMALIZED_ERROR_TYPE>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_PerformanceEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_PerformanceEvent = requireAssignableTo<TypeOnly<old.PerformanceEvent>, TypeOnly<current.PerformanceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_PerformanceEvent": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_PerformanceEvent = requireAssignableTo<TypeOnly<current.PerformanceEvent>, TypeOnly<old.PerformanceEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SampledTelemetryHelper": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_SampledTelemetryHelper = requireAssignableTo<TypeOnly<old.SampledTelemetryHelper>, TypeOnly<current.SampledTelemetryHelper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SampledTelemetryHelper": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_SampledTelemetryHelper = requireAssignableTo<TypeOnly<current.SampledTelemetryHelper>, TypeOnly<old.SampledTelemetryHelper>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TaggedLoggerAdapter": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_TaggedLoggerAdapter = requireAssignableTo<TypeOnly<old.TaggedLoggerAdapter>, TypeOnly<current.TaggedLoggerAdapter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TaggedLoggerAdapter": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_TaggedLoggerAdapter = requireAssignableTo<TypeOnly<current.TaggedLoggerAdapter>, TypeOnly<old.TaggedLoggerAdapter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_TelemetryDataTag": {"forwardCompat": false}
 */
declare type old_as_current_for_EnumDeclaration_TelemetryDataTag = requireAssignableTo<TypeOnly<old.TelemetryDataTag>, TypeOnly<current.TelemetryDataTag>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_TelemetryDataTag": {"backCompat": false}
 */
declare type current_as_old_for_EnumDeclaration_TelemetryDataTag = requireAssignableTo<TypeOnly<current.TelemetryDataTag>, TypeOnly<old.TelemetryDataTag>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TelemetryEventBatcher": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_TelemetryEventBatcher = requireAssignableTo<TypeOnly<current.TelemetryEventBatcher<any>>, TypeOnly<old.TelemetryEventBatcher<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TelemetryEventCategory": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_TelemetryEventCategory = requireAssignableTo<TypeOnly<old.TelemetryEventCategory>, TypeOnly<current.TelemetryEventCategory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TelemetryEventCategory": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_TelemetryEventCategory = requireAssignableTo<TypeOnly<current.TelemetryEventCategory>, TypeOnly<old.TelemetryEventCategory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TelemetryEventPropertyTypeExt": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_TelemetryEventPropertyTypeExt = requireAssignableTo<TypeOnly<old.TelemetryEventPropertyTypeExt>, TypeOnly<current.TelemetryEventPropertyTypeExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TelemetryEventPropertyTypeExt": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_TelemetryEventPropertyTypeExt = requireAssignableTo<TypeOnly<current.TelemetryEventPropertyTypeExt>, TypeOnly<old.TelemetryEventPropertyTypeExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TelemetryEventPropertyTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_TelemetryEventPropertyTypes = requireAssignableTo<TypeOnly<old.TelemetryEventPropertyTypes>, TypeOnly<current.TelemetryEventPropertyTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TelemetryEventPropertyTypes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_TelemetryEventPropertyTypes = requireAssignableTo<TypeOnly<current.TelemetryEventPropertyTypes>, TypeOnly<old.TelemetryEventPropertyTypes>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ThresholdCounter": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_ThresholdCounter = requireAssignableTo<TypeOnly<old.ThresholdCounter>, TypeOnly<current.ThresholdCounter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ThresholdCounter": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_ThresholdCounter = requireAssignableTo<TypeOnly<current.ThresholdCounter>, TypeOnly<old.ThresholdCounter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_UsageError": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_UsageError = requireAssignableTo<TypeOnly<old.UsageError>, TypeOnly<current.UsageError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_UsageError": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_UsageError = requireAssignableTo<TypeOnly<current.UsageError>, TypeOnly<old.UsageError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_connectedEventName": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_connectedEventName = requireAssignableTo<TypeOnly<typeof old.connectedEventName>, TypeOnly<typeof current.connectedEventName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_connectedEventName": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_connectedEventName = requireAssignableTo<TypeOnly<typeof current.connectedEventName>, TypeOnly<typeof old.connectedEventName>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createChildLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createChildLogger = requireAssignableTo<TypeOnly<typeof old.createChildLogger>, TypeOnly<typeof current.createChildLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createChildLogger": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createChildLogger = requireAssignableTo<TypeOnly<typeof current.createChildLogger>, TypeOnly<typeof old.createChildLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createChildMonitoringContext": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createChildMonitoringContext = requireAssignableTo<TypeOnly<typeof old.createChildMonitoringContext>, TypeOnly<typeof current.createChildMonitoringContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createChildMonitoringContext": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createChildMonitoringContext = requireAssignableTo<TypeOnly<typeof current.createChildMonitoringContext>, TypeOnly<typeof old.createChildMonitoringContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createMockLoggerExt": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createMockLoggerExt = requireAssignableTo<TypeOnly<typeof old.createMockLoggerExt>, TypeOnly<typeof current.createMockLoggerExt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createMockLoggerExt": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createMockLoggerExt = requireAssignableTo<TypeOnly<typeof current.createMockLoggerExt>, TypeOnly<typeof old.createMockLoggerExt>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createMultiSinkLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createMultiSinkLogger = requireAssignableTo<TypeOnly<typeof old.createMultiSinkLogger>, TypeOnly<typeof current.createMultiSinkLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createMultiSinkLogger": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createMultiSinkLogger = requireAssignableTo<TypeOnly<typeof current.createMultiSinkLogger>, TypeOnly<typeof old.createMultiSinkLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSampledLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createSampledLogger = requireAssignableTo<TypeOnly<typeof old.createSampledLogger>, TypeOnly<typeof current.createSampledLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSampledLogger": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createSampledLogger = requireAssignableTo<TypeOnly<typeof current.createSampledLogger>, TypeOnly<typeof old.createSampledLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_disconnectedEventName": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_disconnectedEventName = requireAssignableTo<TypeOnly<typeof old.disconnectedEventName>, TypeOnly<typeof current.disconnectedEventName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_disconnectedEventName": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_disconnectedEventName = requireAssignableTo<TypeOnly<typeof current.disconnectedEventName>, TypeOnly<typeof old.disconnectedEventName>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_eventNamespaceSeparator": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_eventNamespaceSeparator = requireAssignableTo<TypeOnly<typeof old.eventNamespaceSeparator>, TypeOnly<typeof current.eventNamespaceSeparator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_eventNamespaceSeparator": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_eventNamespaceSeparator = requireAssignableTo<TypeOnly<typeof current.eventNamespaceSeparator>, TypeOnly<typeof old.eventNamespaceSeparator>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_extractLogSafeErrorProperties": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_extractLogSafeErrorProperties = requireAssignableTo<TypeOnly<typeof old.extractLogSafeErrorProperties>, TypeOnly<typeof current.extractLogSafeErrorProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_extractLogSafeErrorProperties": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_extractLogSafeErrorProperties = requireAssignableTo<TypeOnly<typeof current.extractLogSafeErrorProperties>, TypeOnly<typeof old.extractLogSafeErrorProperties>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_extractSafePropertiesFromMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_extractSafePropertiesFromMessage = requireAssignableTo<TypeOnly<typeof old.extractSafePropertiesFromMessage>, TypeOnly<typeof current.extractSafePropertiesFromMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_extractSafePropertiesFromMessage": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_extractSafePropertiesFromMessage = requireAssignableTo<TypeOnly<typeof current.extractSafePropertiesFromMessage>, TypeOnly<typeof old.extractSafePropertiesFromMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_formatTick": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_formatTick = requireAssignableTo<TypeOnly<typeof old.formatTick>, TypeOnly<typeof current.formatTick>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_formatTick": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_formatTick = requireAssignableTo<TypeOnly<typeof current.formatTick>, TypeOnly<typeof old.formatTick>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_generateErrorWithStack": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_generateErrorWithStack = requireAssignableTo<TypeOnly<typeof old.generateErrorWithStack>, TypeOnly<typeof current.generateErrorWithStack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_generateErrorWithStack": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_generateErrorWithStack = requireAssignableTo<TypeOnly<typeof current.generateErrorWithStack>, TypeOnly<typeof old.generateErrorWithStack>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_generateStack": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_generateStack = requireAssignableTo<TypeOnly<typeof old.generateStack>, TypeOnly<typeof current.generateStack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_generateStack": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_generateStack = requireAssignableTo<TypeOnly<typeof current.generateStack>, TypeOnly<typeof old.generateStack>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getCircularReplacer": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_getCircularReplacer = requireAssignableTo<TypeOnly<typeof old.getCircularReplacer>, TypeOnly<typeof current.getCircularReplacer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getCircularReplacer": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_getCircularReplacer = requireAssignableTo<TypeOnly<typeof current.getCircularReplacer>, TypeOnly<typeof old.getCircularReplacer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_hasErrorInstanceId": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_hasErrorInstanceId = requireAssignableTo<TypeOnly<typeof old.hasErrorInstanceId>, TypeOnly<typeof current.hasErrorInstanceId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_hasErrorInstanceId": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_hasErrorInstanceId = requireAssignableTo<TypeOnly<typeof current.hasErrorInstanceId>, TypeOnly<typeof old.hasErrorInstanceId>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isExternalError": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_isExternalError = requireAssignableTo<TypeOnly<typeof old.isExternalError>, TypeOnly<typeof current.isExternalError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isExternalError": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_isExternalError = requireAssignableTo<TypeOnly<typeof current.isExternalError>, TypeOnly<typeof old.isExternalError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isFluidError": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_isFluidError = requireAssignableTo<TypeOnly<typeof old.isFluidError>, TypeOnly<typeof current.isFluidError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isFluidError": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_isFluidError = requireAssignableTo<TypeOnly<typeof current.isFluidError>, TypeOnly<typeof old.isFluidError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isILoggingError": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_isILoggingError = requireAssignableTo<TypeOnly<typeof old.isILoggingError>, TypeOnly<typeof current.isILoggingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_isILoggingError": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_isILoggingError = requireAssignableTo<TypeOnly<typeof current.isILoggingError>, TypeOnly<typeof old.isILoggingError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isTaggedTelemetryPropertyValue": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_isTaggedTelemetryPropertyValue = requireAssignableTo<TypeOnly<typeof old.isTaggedTelemetryPropertyValue>, TypeOnly<typeof current.isTaggedTelemetryPropertyValue>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isTaggedTelemetryPropertyValue": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_isTaggedTelemetryPropertyValue = requireAssignableTo<TypeOnly<typeof current.isTaggedTelemetryPropertyValue>, TypeOnly<typeof old.isTaggedTelemetryPropertyValue>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_loggerToMonitoringContext": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_loggerToMonitoringContext = requireAssignableTo<TypeOnly<typeof old.loggerToMonitoringContext>, TypeOnly<typeof current.loggerToMonitoringContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_loggerToMonitoringContext": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_loggerToMonitoringContext = requireAssignableTo<TypeOnly<typeof current.loggerToMonitoringContext>, TypeOnly<typeof old.loggerToMonitoringContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_measure": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_measure = requireAssignableTo<TypeOnly<typeof old.measure>, TypeOnly<typeof current.measure>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_measure": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_measure = requireAssignableTo<TypeOnly<typeof current.measure>, TypeOnly<typeof old.measure>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_mixinMonitoringContext": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_mixinMonitoringContext = requireAssignableTo<TypeOnly<typeof old.mixinMonitoringContext>, TypeOnly<typeof current.mixinMonitoringContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_mixinMonitoringContext": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_mixinMonitoringContext = requireAssignableTo<TypeOnly<typeof current.mixinMonitoringContext>, TypeOnly<typeof old.mixinMonitoringContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_normalizeError": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_normalizeError = requireAssignableTo<TypeOnly<typeof old.normalizeError>, TypeOnly<typeof current.normalizeError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_normalizeError": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_normalizeError = requireAssignableTo<TypeOnly<typeof current.normalizeError>, TypeOnly<typeof old.normalizeError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_numberFromString": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_numberFromString = requireAssignableTo<TypeOnly<typeof old.numberFromString>, TypeOnly<typeof current.numberFromString>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_numberFromString": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_numberFromString = requireAssignableTo<TypeOnly<typeof current.numberFromString>, TypeOnly<typeof old.numberFromString>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_overwriteStack": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_overwriteStack = requireAssignableTo<TypeOnly<typeof old.overwriteStack>, TypeOnly<typeof current.overwriteStack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_overwriteStack": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_overwriteStack = requireAssignableTo<TypeOnly<typeof current.overwriteStack>, TypeOnly<typeof old.overwriteStack>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_raiseConnectedEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_raiseConnectedEvent = requireAssignableTo<TypeOnly<typeof old.raiseConnectedEvent>, TypeOnly<typeof current.raiseConnectedEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_raiseConnectedEvent": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_raiseConnectedEvent = requireAssignableTo<TypeOnly<typeof current.raiseConnectedEvent>, TypeOnly<typeof old.raiseConnectedEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_safeRaiseEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_safeRaiseEvent = requireAssignableTo<TypeOnly<typeof old.safeRaiseEvent>, TypeOnly<typeof current.safeRaiseEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_safeRaiseEvent": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_safeRaiseEvent = requireAssignableTo<TypeOnly<typeof current.safeRaiseEvent>, TypeOnly<typeof old.safeRaiseEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_sessionStorageConfigProvider": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_sessionStorageConfigProvider = requireAssignableTo<TypeOnly<typeof old.sessionStorageConfigProvider>, TypeOnly<typeof current.sessionStorageConfigProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_sessionStorageConfigProvider": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_sessionStorageConfigProvider = requireAssignableTo<TypeOnly<typeof current.sessionStorageConfigProvider>, TypeOnly<typeof old.sessionStorageConfigProvider>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_tagCodeArtifacts": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_tagCodeArtifacts = requireAssignableTo<TypeOnly<typeof old.tagCodeArtifacts>, TypeOnly<typeof current.tagCodeArtifacts>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_tagCodeArtifacts": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_tagCodeArtifacts = requireAssignableTo<TypeOnly<typeof current.tagCodeArtifacts>, TypeOnly<typeof old.tagCodeArtifacts>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_tagData": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_tagData = requireAssignableTo<TypeOnly<typeof old.tagData>, TypeOnly<typeof current.tagData>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_tagData": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_tagData = requireAssignableTo<TypeOnly<typeof current.tagData>, TypeOnly<typeof old.tagData>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_validatePrecondition": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_validatePrecondition = requireAssignableTo<TypeOnly<typeof old.validatePrecondition>, TypeOnly<typeof current.validatePrecondition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_validatePrecondition": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_validatePrecondition = requireAssignableTo<TypeOnly<typeof current.validatePrecondition>, TypeOnly<typeof old.validatePrecondition>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_wrapConfigProviderWithDefaults": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_wrapConfigProviderWithDefaults = requireAssignableTo<TypeOnly<typeof old.wrapConfigProviderWithDefaults>, TypeOnly<typeof current.wrapConfigProviderWithDefaults>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_wrapConfigProviderWithDefaults": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_wrapConfigProviderWithDefaults = requireAssignableTo<TypeOnly<typeof current.wrapConfigProviderWithDefaults>, TypeOnly<typeof old.wrapConfigProviderWithDefaults>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapError": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_wrapError = requireAssignableTo<TypeOnly<typeof old.wrapError>, TypeOnly<typeof current.wrapError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapError": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_wrapError = requireAssignableTo<TypeOnly<typeof current.wrapError>, TypeOnly<typeof old.wrapError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapErrorAndLog": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_wrapErrorAndLog = requireAssignableTo<TypeOnly<typeof old.wrapErrorAndLog>, TypeOnly<typeof current.wrapErrorAndLog>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapErrorAndLog": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_wrapErrorAndLog = requireAssignableTo<TypeOnly<typeof current.wrapErrorAndLog>, TypeOnly<typeof old.wrapErrorAndLog>>
