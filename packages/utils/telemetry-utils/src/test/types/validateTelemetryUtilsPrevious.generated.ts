/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/telemetry-utils-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ChildLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ChildLogger = requireAssignableTo<TypeOnly<old.ChildLogger>, TypeOnly<current.ChildLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ChildLogger": {"backCompat": false}
 */
declare type current_as_old_for_Class_ChildLogger = requireAssignableTo<TypeOnly<current.ChildLogger>, TypeOnly<old.ChildLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DebugLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DebugLogger = requireAssignableTo<TypeOnly<old.DebugLogger>, TypeOnly<current.DebugLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DebugLogger": {"backCompat": false}
 */
declare type current_as_old_for_Class_DebugLogger = requireAssignableTo<TypeOnly<current.DebugLogger>, TypeOnly<old.DebugLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_EventEmitterWithErrorHandling": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_EventEmitterWithErrorHandling = requireAssignableTo<TypeOnly<old.EventEmitterWithErrorHandling>, TypeOnly<current.EventEmitterWithErrorHandling>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_EventEmitterWithErrorHandling": {"backCompat": false}
 */
declare type current_as_old_for_Class_EventEmitterWithErrorHandling = requireAssignableTo<TypeOnly<current.EventEmitterWithErrorHandling>, TypeOnly<old.EventEmitterWithErrorHandling>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LoggingError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_LoggingError = requireAssignableTo<TypeOnly<old.LoggingError>, TypeOnly<current.LoggingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LoggingError": {"backCompat": false}
 */
declare type current_as_old_for_Class_LoggingError = requireAssignableTo<TypeOnly<current.LoggingError>, TypeOnly<old.LoggingError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MockLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MockLogger = requireAssignableTo<TypeOnly<old.MockLogger>, TypeOnly<current.MockLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MockLogger": {"backCompat": false}
 */
declare type current_as_old_for_Class_MockLogger = requireAssignableTo<TypeOnly<current.MockLogger>, TypeOnly<old.MockLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MultiSinkLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MultiSinkLogger = requireAssignableTo<TypeOnly<old.MultiSinkLogger>, TypeOnly<current.MultiSinkLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MultiSinkLogger": {"backCompat": false}
 */
declare type current_as_old_for_Class_MultiSinkLogger = requireAssignableTo<TypeOnly<current.MultiSinkLogger>, TypeOnly<old.MultiSinkLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PerformanceEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_PerformanceEvent = requireAssignableTo<TypeOnly<old.PerformanceEvent>, TypeOnly<current.PerformanceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PerformanceEvent": {"backCompat": false}
 */
declare type current_as_old_for_Class_PerformanceEvent = requireAssignableTo<TypeOnly<current.PerformanceEvent>, TypeOnly<old.PerformanceEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SampledTelemetryHelper": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SampledTelemetryHelper = requireAssignableTo<TypeOnly<old.SampledTelemetryHelper>, TypeOnly<current.SampledTelemetryHelper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SampledTelemetryHelper": {"backCompat": false}
 */
declare type current_as_old_for_Class_SampledTelemetryHelper = requireAssignableTo<TypeOnly<current.SampledTelemetryHelper>, TypeOnly<old.SampledTelemetryHelper>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TaggedLoggerAdapter": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TaggedLoggerAdapter = requireAssignableTo<TypeOnly<old.TaggedLoggerAdapter>, TypeOnly<current.TaggedLoggerAdapter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TaggedLoggerAdapter": {"backCompat": false}
 */
declare type current_as_old_for_Class_TaggedLoggerAdapter = requireAssignableTo<TypeOnly<current.TaggedLoggerAdapter>, TypeOnly<old.TaggedLoggerAdapter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TelemetryLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TelemetryLogger = requireAssignableTo<TypeOnly<old.TelemetryLogger>, TypeOnly<current.TelemetryLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TelemetryLogger": {"backCompat": false}
 */
declare type current_as_old_for_Class_TelemetryLogger = requireAssignableTo<TypeOnly<current.TelemetryLogger>, TypeOnly<old.TelemetryLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TelemetryUTLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TelemetryUTLogger = requireAssignableTo<TypeOnly<old.TelemetryUTLogger>, TypeOnly<current.TelemetryUTLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TelemetryUTLogger": {"backCompat": false}
 */
declare type current_as_old_for_Class_TelemetryUTLogger = requireAssignableTo<TypeOnly<current.TelemetryUTLogger>, TypeOnly<old.TelemetryUTLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ThresholdCounter": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ThresholdCounter = requireAssignableTo<TypeOnly<old.ThresholdCounter>, TypeOnly<current.ThresholdCounter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ThresholdCounter": {"backCompat": false}
 */
declare type current_as_old_for_Class_ThresholdCounter = requireAssignableTo<TypeOnly<current.ThresholdCounter>, TypeOnly<old.ThresholdCounter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ChildLogger": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ChildLogger = requireAssignableTo<TypeOnly<typeof current.ChildLogger>, TypeOnly<typeof old.ChildLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DebugLogger": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DebugLogger = requireAssignableTo<TypeOnly<typeof current.DebugLogger>, TypeOnly<typeof old.DebugLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_EventEmitterWithErrorHandling": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_EventEmitterWithErrorHandling = requireAssignableTo<TypeOnly<typeof current.EventEmitterWithErrorHandling>, TypeOnly<typeof old.EventEmitterWithErrorHandling>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_LoggingError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_LoggingError = requireAssignableTo<TypeOnly<typeof current.LoggingError>, TypeOnly<typeof old.LoggingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MockLogger": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MockLogger = requireAssignableTo<TypeOnly<typeof current.MockLogger>, TypeOnly<typeof old.MockLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MultiSinkLogger": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MultiSinkLogger = requireAssignableTo<TypeOnly<typeof current.MultiSinkLogger>, TypeOnly<typeof old.MultiSinkLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_PerformanceEvent": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_PerformanceEvent = requireAssignableTo<TypeOnly<typeof current.PerformanceEvent>, TypeOnly<typeof old.PerformanceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SampledTelemetryHelper": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SampledTelemetryHelper = requireAssignableTo<TypeOnly<typeof current.SampledTelemetryHelper>, TypeOnly<typeof old.SampledTelemetryHelper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TaggedLoggerAdapter": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TaggedLoggerAdapter = requireAssignableTo<TypeOnly<typeof current.TaggedLoggerAdapter>, TypeOnly<typeof old.TaggedLoggerAdapter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TelemetryLogger": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TelemetryLogger = requireAssignableTo<TypeOnly<typeof current.TelemetryLogger>, TypeOnly<typeof old.TelemetryLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TelemetryUTLogger": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TelemetryUTLogger = requireAssignableTo<TypeOnly<typeof current.TelemetryUTLogger>, TypeOnly<typeof old.TelemetryUTLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ThresholdCounter": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ThresholdCounter = requireAssignableTo<TypeOnly<typeof current.ThresholdCounter>, TypeOnly<typeof old.ThresholdCounter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_TelemetryDataTag": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_TelemetryDataTag = requireAssignableTo<TypeOnly<old.TelemetryDataTag>, TypeOnly<current.TelemetryDataTag>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_TelemetryDataTag": {"backCompat": false}
 */
declare type current_as_old_for_Enum_TelemetryDataTag = requireAssignableTo<TypeOnly<current.TelemetryDataTag>, TypeOnly<old.TelemetryDataTag>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_extractLogSafeErrorProperties": {"backCompat": false}
 */
declare type current_as_old_for_Function_extractLogSafeErrorProperties = requireAssignableTo<TypeOnly<typeof current.extractLogSafeErrorProperties>, TypeOnly<typeof old.extractLogSafeErrorProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_generateErrorWithStack": {"backCompat": false}
 */
declare type current_as_old_for_Function_generateErrorWithStack = requireAssignableTo<TypeOnly<typeof current.generateErrorWithStack>, TypeOnly<typeof old.generateErrorWithStack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_generateStack": {"backCompat": false}
 */
declare type current_as_old_for_Function_generateStack = requireAssignableTo<TypeOnly<typeof current.generateStack>, TypeOnly<typeof old.generateStack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isExternalError": {"backCompat": false}
 */
declare type current_as_old_for_Function_isExternalError = requireAssignableTo<TypeOnly<typeof current.isExternalError>, TypeOnly<typeof old.isExternalError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isFluidError": {"backCompat": false}
 */
declare type current_as_old_for_Function_isFluidError = requireAssignableTo<TypeOnly<typeof current.isFluidError>, TypeOnly<typeof old.isFluidError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isTaggedTelemetryPropertyValue": {"backCompat": false}
 */
declare type current_as_old_for_Function_isTaggedTelemetryPropertyValue = requireAssignableTo<TypeOnly<typeof current.isTaggedTelemetryPropertyValue>, TypeOnly<typeof old.isTaggedTelemetryPropertyValue>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isValidLegacyError": {"backCompat": false}
 */
declare type current_as_old_for_Function_isValidLegacyError = requireAssignableTo<TypeOnly<typeof current.isValidLegacyError>, TypeOnly<typeof old.isValidLegacyError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_loggerToMonitoringContext": {"backCompat": false}
 */
declare type current_as_old_for_Function_loggerToMonitoringContext = requireAssignableTo<TypeOnly<typeof current.loggerToMonitoringContext>, TypeOnly<typeof old.loggerToMonitoringContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_logIfFalse": {"backCompat": false}
 */
declare type current_as_old_for_Function_logIfFalse = requireAssignableTo<TypeOnly<typeof current.logIfFalse>, TypeOnly<typeof old.logIfFalse>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_mixinMonitoringContext": {"backCompat": false}
 */
declare type current_as_old_for_Function_mixinMonitoringContext = requireAssignableTo<TypeOnly<typeof current.mixinMonitoringContext>, TypeOnly<typeof old.mixinMonitoringContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_normalizeError": {"backCompat": false}
 */
declare type current_as_old_for_Function_normalizeError = requireAssignableTo<TypeOnly<typeof current.normalizeError>, TypeOnly<typeof old.normalizeError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_raiseConnectedEvent": {"backCompat": false}
 */
declare type current_as_old_for_Function_raiseConnectedEvent = requireAssignableTo<TypeOnly<typeof current.raiseConnectedEvent>, TypeOnly<typeof old.raiseConnectedEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_safeRaiseEvent": {"backCompat": false}
 */
declare type current_as_old_for_Function_safeRaiseEvent = requireAssignableTo<TypeOnly<typeof current.safeRaiseEvent>, TypeOnly<typeof old.safeRaiseEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_wrapError": {"backCompat": false}
 */
declare type current_as_old_for_Function_wrapError = requireAssignableTo<TypeOnly<typeof current.wrapError>, TypeOnly<typeof old.wrapError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_wrapErrorAndLog": {"backCompat": false}
 */
declare type current_as_old_for_Function_wrapErrorAndLog = requireAssignableTo<TypeOnly<typeof current.wrapErrorAndLog>, TypeOnly<typeof old.wrapErrorAndLog>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConfigProvider": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConfigProvider = requireAssignableTo<TypeOnly<old.IConfigProvider>, TypeOnly<current.IConfigProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConfigProvider": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConfigProvider = requireAssignableTo<TypeOnly<current.IConfigProvider>, TypeOnly<old.IConfigProvider>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConfigProviderBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConfigProviderBase = requireAssignableTo<TypeOnly<old.IConfigProviderBase>, TypeOnly<current.IConfigProviderBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConfigProviderBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConfigProviderBase = requireAssignableTo<TypeOnly<current.IConfigProviderBase>, TypeOnly<old.IConfigProviderBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidErrorAnnotations": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidErrorAnnotations = requireAssignableTo<TypeOnly<old.IFluidErrorAnnotations>, TypeOnly<current.IFluidErrorAnnotations>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidErrorAnnotations": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidErrorAnnotations = requireAssignableTo<TypeOnly<current.IFluidErrorAnnotations>, TypeOnly<old.IFluidErrorAnnotations>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidErrorBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidErrorBase = requireAssignableTo<TypeOnly<old.IFluidErrorBase>, TypeOnly<current.IFluidErrorBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidErrorBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidErrorBase = requireAssignableTo<TypeOnly<current.IFluidErrorBase>, TypeOnly<old.IFluidErrorBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPerformanceEventMarkers": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPerformanceEventMarkers = requireAssignableTo<TypeOnly<old.IPerformanceEventMarkers>, TypeOnly<current.IPerformanceEventMarkers>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPerformanceEventMarkers": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPerformanceEventMarkers = requireAssignableTo<TypeOnly<current.IPerformanceEventMarkers>, TypeOnly<old.IPerformanceEventMarkers>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryLoggerPropertyBag": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITelemetryLoggerPropertyBag = requireAssignableTo<TypeOnly<old.ITelemetryLoggerPropertyBag>, TypeOnly<current.ITelemetryLoggerPropertyBag>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryLoggerPropertyBag": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryLoggerPropertyBag = requireAssignableTo<TypeOnly<current.ITelemetryLoggerPropertyBag>, TypeOnly<old.ITelemetryLoggerPropertyBag>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryLoggerPropertyBags": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITelemetryLoggerPropertyBags = requireAssignableTo<TypeOnly<old.ITelemetryLoggerPropertyBags>, TypeOnly<current.ITelemetryLoggerPropertyBags>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryLoggerPropertyBags": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryLoggerPropertyBags = requireAssignableTo<TypeOnly<current.ITelemetryLoggerPropertyBags>, TypeOnly<old.ITelemetryLoggerPropertyBags>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MonitoringContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_MonitoringContext = requireAssignableTo<TypeOnly<old.MonitoringContext>, TypeOnly<current.MonitoringContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MonitoringContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_MonitoringContext = requireAssignableTo<TypeOnly<current.MonitoringContext>, TypeOnly<old.MonitoringContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ConfigTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ConfigTypes = requireAssignableTo<TypeOnly<old.ConfigTypes>, TypeOnly<current.ConfigTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ConfigTypes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ConfigTypes = requireAssignableTo<TypeOnly<current.ConfigTypes>, TypeOnly<old.ConfigTypes>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TelemetryEventPropertyTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TelemetryEventPropertyTypes = requireAssignableTo<TypeOnly<old.TelemetryEventPropertyTypes>, TypeOnly<current.TelemetryEventPropertyTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TelemetryEventPropertyTypes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TelemetryEventPropertyTypes = requireAssignableTo<TypeOnly<current.TelemetryEventPropertyTypes>, TypeOnly<old.TelemetryEventPropertyTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_connectedEventName": {"backCompat": false}
 */
declare type current_as_old_for_Variable_connectedEventName = requireAssignableTo<TypeOnly<typeof current.connectedEventName>, TypeOnly<typeof old.connectedEventName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_disconnectedEventName": {"backCompat": false}
 */
declare type current_as_old_for_Variable_disconnectedEventName = requireAssignableTo<TypeOnly<typeof current.disconnectedEventName>, TypeOnly<typeof old.disconnectedEventName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_getCircularReplacer": {"backCompat": false}
 */
declare type current_as_old_for_Variable_getCircularReplacer = requireAssignableTo<TypeOnly<typeof current.getCircularReplacer>, TypeOnly<typeof old.getCircularReplacer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_hasErrorInstanceId": {"backCompat": false}
 */
declare type current_as_old_for_Variable_hasErrorInstanceId = requireAssignableTo<TypeOnly<typeof current.hasErrorInstanceId>, TypeOnly<typeof old.hasErrorInstanceId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_isILoggingError": {"backCompat": false}
 */
declare type current_as_old_for_Variable_isILoggingError = requireAssignableTo<TypeOnly<typeof current.isILoggingError>, TypeOnly<typeof old.isILoggingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_sessionStorageConfigProvider": {"backCompat": false}
 */
declare type current_as_old_for_Variable_sessionStorageConfigProvider = requireAssignableTo<TypeOnly<typeof current.sessionStorageConfigProvider>, TypeOnly<typeof old.sessionStorageConfigProvider>>
