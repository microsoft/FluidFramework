/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */
import type * as old from "@fluidframework/telemetry-utils-previous";
import type * as current from "../../index";


// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedTypeAliasDeclaration_ConfigTypes": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedTypeAliasDeclaration_ConfigTypes": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DataCorruptionError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DataCorruptionError():
    TypeOnly<old.DataCorruptionError>;
declare function use_current_ClassDeclaration_DataCorruptionError(
    use: TypeOnly<current.DataCorruptionError>): void;
use_current_ClassDeclaration_DataCorruptionError(
    get_old_ClassDeclaration_DataCorruptionError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DataCorruptionError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DataCorruptionError():
    TypeOnly<current.DataCorruptionError>;
declare function use_old_ClassDeclaration_DataCorruptionError(
    use: TypeOnly<old.DataCorruptionError>): void;
use_old_ClassDeclaration_DataCorruptionError(
    get_current_ClassDeclaration_DataCorruptionError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DataProcessingError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DataProcessingError():
    TypeOnly<old.DataProcessingError>;
declare function use_current_ClassDeclaration_DataProcessingError(
    use: TypeOnly<current.DataProcessingError>): void;
use_current_ClassDeclaration_DataProcessingError(
    get_old_ClassDeclaration_DataProcessingError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DataProcessingError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DataProcessingError():
    TypeOnly<current.DataProcessingError>;
declare function use_old_ClassDeclaration_DataProcessingError(
    use: TypeOnly<old.DataProcessingError>): void;
use_old_ClassDeclaration_DataProcessingError(
    get_current_ClassDeclaration_DataProcessingError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EventEmitterWithErrorHandling": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_EventEmitterWithErrorHandling():
    TypeOnly<old.EventEmitterWithErrorHandling>;
declare function use_current_ClassDeclaration_EventEmitterWithErrorHandling(
    use: TypeOnly<current.EventEmitterWithErrorHandling>): void;
use_current_ClassDeclaration_EventEmitterWithErrorHandling(
    get_old_ClassDeclaration_EventEmitterWithErrorHandling());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EventEmitterWithErrorHandling": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_EventEmitterWithErrorHandling():
    TypeOnly<current.EventEmitterWithErrorHandling>;
declare function use_old_ClassDeclaration_EventEmitterWithErrorHandling(
    use: TypeOnly<old.EventEmitterWithErrorHandling>): void;
use_old_ClassDeclaration_EventEmitterWithErrorHandling(
    get_current_ClassDeclaration_EventEmitterWithErrorHandling());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_GenericError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_GenericError():
    TypeOnly<old.GenericError>;
declare function use_current_ClassDeclaration_GenericError(
    use: TypeOnly<current.GenericError>): void;
use_current_ClassDeclaration_GenericError(
    get_old_ClassDeclaration_GenericError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_GenericError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_GenericError():
    TypeOnly<current.GenericError>;
declare function use_old_ClassDeclaration_GenericError(
    use: TypeOnly<old.GenericError>): void;
use_old_ClassDeclaration_GenericError(
    get_current_ClassDeclaration_GenericError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConfigProvider": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConfigProvider():
    TypeOnly<old.IConfigProvider>;
declare function use_current_InterfaceDeclaration_IConfigProvider(
    use: TypeOnly<current.IConfigProvider>): void;
use_current_InterfaceDeclaration_IConfigProvider(
    get_old_InterfaceDeclaration_IConfigProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConfigProvider": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConfigProvider():
    TypeOnly<current.IConfigProvider>;
declare function use_old_InterfaceDeclaration_IConfigProvider(
    use: TypeOnly<old.IConfigProvider>): void;
use_old_InterfaceDeclaration_IConfigProvider(
    get_current_InterfaceDeclaration_IConfigProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedInterfaceDeclaration_IConfigProviderBase": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedInterfaceDeclaration_IConfigProviderBase": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEventSampler": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IEventSampler():
    TypeOnly<old.IEventSampler>;
declare function use_current_InterfaceDeclaration_IEventSampler(
    use: TypeOnly<current.IEventSampler>): void;
use_current_InterfaceDeclaration_IEventSampler(
    get_old_InterfaceDeclaration_IEventSampler());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEventSampler": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IEventSampler():
    TypeOnly<current.IEventSampler>;
declare function use_old_InterfaceDeclaration_IEventSampler(
    use: TypeOnly<old.IEventSampler>): void;
use_old_InterfaceDeclaration_IEventSampler(
    get_current_InterfaceDeclaration_IEventSampler());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidErrorAnnotations": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidErrorAnnotations():
    TypeOnly<old.IFluidErrorAnnotations>;
declare function use_current_InterfaceDeclaration_IFluidErrorAnnotations(
    use: TypeOnly<current.IFluidErrorAnnotations>): void;
use_current_InterfaceDeclaration_IFluidErrorAnnotations(
    get_old_InterfaceDeclaration_IFluidErrorAnnotations());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidErrorAnnotations": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidErrorAnnotations():
    TypeOnly<current.IFluidErrorAnnotations>;
declare function use_old_InterfaceDeclaration_IFluidErrorAnnotations(
    use: TypeOnly<old.IFluidErrorAnnotations>): void;
use_old_InterfaceDeclaration_IFluidErrorAnnotations(
    get_current_InterfaceDeclaration_IFluidErrorAnnotations());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidErrorBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidErrorBase():
    TypeOnly<old.IFluidErrorBase>;
declare function use_current_InterfaceDeclaration_IFluidErrorBase(
    use: TypeOnly<current.IFluidErrorBase>): void;
use_current_InterfaceDeclaration_IFluidErrorBase(
    get_old_InterfaceDeclaration_IFluidErrorBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidErrorBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidErrorBase():
    TypeOnly<current.IFluidErrorBase>;
declare function use_old_InterfaceDeclaration_IFluidErrorBase(
    use: TypeOnly<old.IFluidErrorBase>): void;
use_old_InterfaceDeclaration_IFluidErrorBase(
    get_current_InterfaceDeclaration_IFluidErrorBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPerformanceEventMarkers": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPerformanceEventMarkers():
    TypeOnly<old.IPerformanceEventMarkers>;
declare function use_current_InterfaceDeclaration_IPerformanceEventMarkers(
    use: TypeOnly<current.IPerformanceEventMarkers>): void;
use_current_InterfaceDeclaration_IPerformanceEventMarkers(
    get_old_InterfaceDeclaration_IPerformanceEventMarkers());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPerformanceEventMarkers": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPerformanceEventMarkers():
    TypeOnly<current.IPerformanceEventMarkers>;
declare function use_old_InterfaceDeclaration_IPerformanceEventMarkers(
    use: TypeOnly<old.IPerformanceEventMarkers>): void;
use_old_InterfaceDeclaration_IPerformanceEventMarkers(
    get_current_InterfaceDeclaration_IPerformanceEventMarkers());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISampledTelemetryLogger": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISampledTelemetryLogger():
    TypeOnly<old.ISampledTelemetryLogger>;
declare function use_current_InterfaceDeclaration_ISampledTelemetryLogger(
    use: TypeOnly<current.ISampledTelemetryLogger>): void;
use_current_InterfaceDeclaration_ISampledTelemetryLogger(
    get_old_InterfaceDeclaration_ISampledTelemetryLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISampledTelemetryLogger": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISampledTelemetryLogger():
    TypeOnly<current.ISampledTelemetryLogger>;
declare function use_old_InterfaceDeclaration_ISampledTelemetryLogger(
    use: TypeOnly<old.ISampledTelemetryLogger>): void;
use_old_InterfaceDeclaration_ISampledTelemetryLogger(
    get_current_InterfaceDeclaration_ISampledTelemetryLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt():
    TypeOnly<old.ITaggedTelemetryPropertyTypeExt>;
declare function use_current_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt(
    use: TypeOnly<current.ITaggedTelemetryPropertyTypeExt>): void;
use_current_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt(
    get_old_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt():
    TypeOnly<current.ITaggedTelemetryPropertyTypeExt>;
declare function use_old_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt(
    use: TypeOnly<old.ITaggedTelemetryPropertyTypeExt>): void;
use_old_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt(
    get_current_InterfaceDeclaration_ITaggedTelemetryPropertyTypeExt());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryErrorEventExt": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryErrorEventExt():
    TypeOnly<old.ITelemetryErrorEventExt>;
declare function use_current_InterfaceDeclaration_ITelemetryErrorEventExt(
    use: TypeOnly<current.ITelemetryErrorEventExt>): void;
use_current_InterfaceDeclaration_ITelemetryErrorEventExt(
    get_old_InterfaceDeclaration_ITelemetryErrorEventExt());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryErrorEventExt": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryErrorEventExt():
    TypeOnly<current.ITelemetryErrorEventExt>;
declare function use_old_InterfaceDeclaration_ITelemetryErrorEventExt(
    use: TypeOnly<old.ITelemetryErrorEventExt>): void;
use_old_InterfaceDeclaration_ITelemetryErrorEventExt(
    get_current_InterfaceDeclaration_ITelemetryErrorEventExt());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryEventExt": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryEventExt():
    TypeOnly<old.ITelemetryEventExt>;
declare function use_current_InterfaceDeclaration_ITelemetryEventExt(
    use: TypeOnly<current.ITelemetryEventExt>): void;
use_current_InterfaceDeclaration_ITelemetryEventExt(
    get_old_InterfaceDeclaration_ITelemetryEventExt());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryEventExt": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryEventExt():
    TypeOnly<current.ITelemetryEventExt>;
declare function use_old_InterfaceDeclaration_ITelemetryEventExt(
    use: TypeOnly<old.ITelemetryEventExt>): void;
use_old_InterfaceDeclaration_ITelemetryEventExt(
    get_current_InterfaceDeclaration_ITelemetryEventExt());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryGenericEventExt": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryGenericEventExt():
    TypeOnly<old.ITelemetryGenericEventExt>;
declare function use_current_InterfaceDeclaration_ITelemetryGenericEventExt(
    use: TypeOnly<current.ITelemetryGenericEventExt>): void;
use_current_InterfaceDeclaration_ITelemetryGenericEventExt(
    get_old_InterfaceDeclaration_ITelemetryGenericEventExt());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryGenericEventExt": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryGenericEventExt():
    TypeOnly<current.ITelemetryGenericEventExt>;
declare function use_old_InterfaceDeclaration_ITelemetryGenericEventExt(
    use: TypeOnly<old.ITelemetryGenericEventExt>): void;
use_old_InterfaceDeclaration_ITelemetryGenericEventExt(
    get_current_InterfaceDeclaration_ITelemetryGenericEventExt());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryLoggerExt": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryLoggerExt():
    TypeOnly<old.ITelemetryLoggerExt>;
declare function use_current_InterfaceDeclaration_ITelemetryLoggerExt(
    use: TypeOnly<current.ITelemetryLoggerExt>): void;
use_current_InterfaceDeclaration_ITelemetryLoggerExt(
    get_old_InterfaceDeclaration_ITelemetryLoggerExt());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryLoggerExt": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryLoggerExt():
    TypeOnly<current.ITelemetryLoggerExt>;
declare function use_old_InterfaceDeclaration_ITelemetryLoggerExt(
    use: TypeOnly<old.ITelemetryLoggerExt>): void;
use_old_InterfaceDeclaration_ITelemetryLoggerExt(
    get_current_InterfaceDeclaration_ITelemetryLoggerExt());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryLoggerPropertyBag": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryLoggerPropertyBag():
    TypeOnly<old.ITelemetryLoggerPropertyBag>;
declare function use_current_InterfaceDeclaration_ITelemetryLoggerPropertyBag(
    use: TypeOnly<current.ITelemetryLoggerPropertyBag>): void;
use_current_InterfaceDeclaration_ITelemetryLoggerPropertyBag(
    get_old_InterfaceDeclaration_ITelemetryLoggerPropertyBag());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryLoggerPropertyBag": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryLoggerPropertyBag():
    TypeOnly<current.ITelemetryLoggerPropertyBag>;
declare function use_old_InterfaceDeclaration_ITelemetryLoggerPropertyBag(
    use: TypeOnly<old.ITelemetryLoggerPropertyBag>): void;
use_old_InterfaceDeclaration_ITelemetryLoggerPropertyBag(
    get_current_InterfaceDeclaration_ITelemetryLoggerPropertyBag());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryLoggerPropertyBags": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryLoggerPropertyBags():
    TypeOnly<old.ITelemetryLoggerPropertyBags>;
declare function use_current_InterfaceDeclaration_ITelemetryLoggerPropertyBags(
    use: TypeOnly<current.ITelemetryLoggerPropertyBags>): void;
use_current_InterfaceDeclaration_ITelemetryLoggerPropertyBags(
    get_old_InterfaceDeclaration_ITelemetryLoggerPropertyBags());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryLoggerPropertyBags": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryLoggerPropertyBags():
    TypeOnly<current.ITelemetryLoggerPropertyBags>;
declare function use_old_InterfaceDeclaration_ITelemetryLoggerPropertyBags(
    use: TypeOnly<old.ITelemetryLoggerPropertyBags>): void;
use_old_InterfaceDeclaration_ITelemetryLoggerPropertyBags(
    get_current_InterfaceDeclaration_ITelemetryLoggerPropertyBags());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryPerformanceEventExt": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryPerformanceEventExt():
    TypeOnly<old.ITelemetryPerformanceEventExt>;
declare function use_current_InterfaceDeclaration_ITelemetryPerformanceEventExt(
    use: TypeOnly<current.ITelemetryPerformanceEventExt>): void;
use_current_InterfaceDeclaration_ITelemetryPerformanceEventExt(
    get_old_InterfaceDeclaration_ITelemetryPerformanceEventExt());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryPerformanceEventExt": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryPerformanceEventExt():
    TypeOnly<current.ITelemetryPerformanceEventExt>;
declare function use_old_InterfaceDeclaration_ITelemetryPerformanceEventExt(
    use: TypeOnly<old.ITelemetryPerformanceEventExt>): void;
use_old_InterfaceDeclaration_ITelemetryPerformanceEventExt(
    get_current_InterfaceDeclaration_ITelemetryPerformanceEventExt());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryPropertiesExt": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryPropertiesExt():
    TypeOnly<old.ITelemetryPropertiesExt>;
declare function use_current_InterfaceDeclaration_ITelemetryPropertiesExt(
    use: TypeOnly<current.ITelemetryPropertiesExt>): void;
use_current_InterfaceDeclaration_ITelemetryPropertiesExt(
    get_old_InterfaceDeclaration_ITelemetryPropertiesExt());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryPropertiesExt": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryPropertiesExt():
    TypeOnly<current.ITelemetryPropertiesExt>;
declare function use_old_InterfaceDeclaration_ITelemetryPropertiesExt(
    use: TypeOnly<old.ITelemetryPropertiesExt>): void;
use_old_InterfaceDeclaration_ITelemetryPropertiesExt(
    get_current_InterfaceDeclaration_ITelemetryPropertiesExt());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LoggingError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_LoggingError():
    TypeOnly<old.LoggingError>;
declare function use_current_ClassDeclaration_LoggingError(
    use: TypeOnly<current.LoggingError>): void;
use_current_ClassDeclaration_LoggingError(
    get_old_ClassDeclaration_LoggingError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LoggingError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_LoggingError():
    TypeOnly<current.LoggingError>;
declare function use_old_ClassDeclaration_LoggingError(
    use: TypeOnly<old.LoggingError>): void;
use_old_ClassDeclaration_LoggingError(
    get_current_ClassDeclaration_LoggingError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MockLogger": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MockLogger():
    TypeOnly<old.MockLogger>;
declare function use_current_ClassDeclaration_MockLogger(
    use: TypeOnly<current.MockLogger>): void;
use_current_ClassDeclaration_MockLogger(
    get_old_ClassDeclaration_MockLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MockLogger": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MockLogger():
    TypeOnly<current.MockLogger>;
declare function use_old_ClassDeclaration_MockLogger(
    use: TypeOnly<old.MockLogger>): void;
use_old_ClassDeclaration_MockLogger(
    get_current_ClassDeclaration_MockLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_MonitoringContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_MonitoringContext():
    TypeOnly<old.MonitoringContext>;
declare function use_current_InterfaceDeclaration_MonitoringContext(
    use: TypeOnly<current.MonitoringContext>): void;
use_current_InterfaceDeclaration_MonitoringContext(
    get_old_InterfaceDeclaration_MonitoringContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_MonitoringContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_MonitoringContext():
    TypeOnly<current.MonitoringContext>;
declare function use_old_InterfaceDeclaration_MonitoringContext(
    use: TypeOnly<old.MonitoringContext>): void;
use_old_InterfaceDeclaration_MonitoringContext(
    get_current_InterfaceDeclaration_MonitoringContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_NORMALIZED_ERROR_TYPE": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_NORMALIZED_ERROR_TYPE():
    TypeOnly<typeof old.NORMALIZED_ERROR_TYPE>;
declare function use_current_VariableDeclaration_NORMALIZED_ERROR_TYPE(
    use: TypeOnly<typeof current.NORMALIZED_ERROR_TYPE>): void;
use_current_VariableDeclaration_NORMALIZED_ERROR_TYPE(
    get_old_VariableDeclaration_NORMALIZED_ERROR_TYPE());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_NORMALIZED_ERROR_TYPE": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_NORMALIZED_ERROR_TYPE():
    TypeOnly<typeof current.NORMALIZED_ERROR_TYPE>;
declare function use_old_VariableDeclaration_NORMALIZED_ERROR_TYPE(
    use: TypeOnly<typeof old.NORMALIZED_ERROR_TYPE>): void;
use_old_VariableDeclaration_NORMALIZED_ERROR_TYPE(
    get_current_VariableDeclaration_NORMALIZED_ERROR_TYPE());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PerformanceEvent": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_PerformanceEvent():
    TypeOnly<old.PerformanceEvent>;
declare function use_current_ClassDeclaration_PerformanceEvent(
    use: TypeOnly<current.PerformanceEvent>): void;
use_current_ClassDeclaration_PerformanceEvent(
    get_old_ClassDeclaration_PerformanceEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PerformanceEvent": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_PerformanceEvent():
    TypeOnly<current.PerformanceEvent>;
declare function use_old_ClassDeclaration_PerformanceEvent(
    use: TypeOnly<old.PerformanceEvent>): void;
use_old_ClassDeclaration_PerformanceEvent(
    get_current_ClassDeclaration_PerformanceEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SampledTelemetryHelper": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SampledTelemetryHelper():
    TypeOnly<old.SampledTelemetryHelper>;
declare function use_current_ClassDeclaration_SampledTelemetryHelper(
    use: TypeOnly<current.SampledTelemetryHelper>): void;
use_current_ClassDeclaration_SampledTelemetryHelper(
    get_old_ClassDeclaration_SampledTelemetryHelper());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SampledTelemetryHelper": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SampledTelemetryHelper():
    TypeOnly<current.SampledTelemetryHelper>;
declare function use_old_ClassDeclaration_SampledTelemetryHelper(
    use: TypeOnly<old.SampledTelemetryHelper>): void;
use_old_ClassDeclaration_SampledTelemetryHelper(
    get_current_ClassDeclaration_SampledTelemetryHelper());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TaggedLoggerAdapter": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TaggedLoggerAdapter():
    TypeOnly<old.TaggedLoggerAdapter>;
declare function use_current_ClassDeclaration_TaggedLoggerAdapter(
    use: TypeOnly<current.TaggedLoggerAdapter>): void;
use_current_ClassDeclaration_TaggedLoggerAdapter(
    get_old_ClassDeclaration_TaggedLoggerAdapter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TaggedLoggerAdapter": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TaggedLoggerAdapter():
    TypeOnly<current.TaggedLoggerAdapter>;
declare function use_old_ClassDeclaration_TaggedLoggerAdapter(
    use: TypeOnly<old.TaggedLoggerAdapter>): void;
use_old_ClassDeclaration_TaggedLoggerAdapter(
    get_current_ClassDeclaration_TaggedLoggerAdapter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_TelemetryDataTag": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_TelemetryDataTag():
    TypeOnly<old.TelemetryDataTag>;
declare function use_current_EnumDeclaration_TelemetryDataTag(
    use: TypeOnly<current.TelemetryDataTag>): void;
use_current_EnumDeclaration_TelemetryDataTag(
    get_old_EnumDeclaration_TelemetryDataTag());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_TelemetryDataTag": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_TelemetryDataTag():
    TypeOnly<current.TelemetryDataTag>;
declare function use_old_EnumDeclaration_TelemetryDataTag(
    use: TypeOnly<old.TelemetryDataTag>): void;
use_old_EnumDeclaration_TelemetryDataTag(
    get_current_EnumDeclaration_TelemetryDataTag());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventCategory": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TelemetryEventCategory():
    TypeOnly<old.TelemetryEventCategory>;
declare function use_current_TypeAliasDeclaration_TelemetryEventCategory(
    use: TypeOnly<current.TelemetryEventCategory>): void;
use_current_TypeAliasDeclaration_TelemetryEventCategory(
    get_old_TypeAliasDeclaration_TelemetryEventCategory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventCategory": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TelemetryEventCategory():
    TypeOnly<current.TelemetryEventCategory>;
declare function use_old_TypeAliasDeclaration_TelemetryEventCategory(
    use: TypeOnly<old.TelemetryEventCategory>): void;
use_old_TypeAliasDeclaration_TelemetryEventCategory(
    get_current_TypeAliasDeclaration_TelemetryEventCategory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventPropertyTypeExt": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TelemetryEventPropertyTypeExt():
    TypeOnly<old.TelemetryEventPropertyTypeExt>;
declare function use_current_TypeAliasDeclaration_TelemetryEventPropertyTypeExt(
    use: TypeOnly<current.TelemetryEventPropertyTypeExt>): void;
use_current_TypeAliasDeclaration_TelemetryEventPropertyTypeExt(
    get_old_TypeAliasDeclaration_TelemetryEventPropertyTypeExt());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventPropertyTypeExt": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TelemetryEventPropertyTypeExt():
    TypeOnly<current.TelemetryEventPropertyTypeExt>;
declare function use_old_TypeAliasDeclaration_TelemetryEventPropertyTypeExt(
    use: TypeOnly<old.TelemetryEventPropertyTypeExt>): void;
use_old_TypeAliasDeclaration_TelemetryEventPropertyTypeExt(
    get_current_TypeAliasDeclaration_TelemetryEventPropertyTypeExt());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventPropertyTypes": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TelemetryEventPropertyTypes():
    TypeOnly<old.TelemetryEventPropertyTypes>;
declare function use_current_TypeAliasDeclaration_TelemetryEventPropertyTypes(
    use: TypeOnly<current.TelemetryEventPropertyTypes>): void;
use_current_TypeAliasDeclaration_TelemetryEventPropertyTypes(
    get_old_TypeAliasDeclaration_TelemetryEventPropertyTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventPropertyTypes": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TelemetryEventPropertyTypes():
    TypeOnly<current.TelemetryEventPropertyTypes>;
declare function use_old_TypeAliasDeclaration_TelemetryEventPropertyTypes(
    use: TypeOnly<old.TelemetryEventPropertyTypes>): void;
use_old_TypeAliasDeclaration_TelemetryEventPropertyTypes(
    get_current_TypeAliasDeclaration_TelemetryEventPropertyTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TelemetryNullLogger": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TelemetryNullLogger():
    TypeOnly<old.TelemetryNullLogger>;
declare function use_current_ClassDeclaration_TelemetryNullLogger(
    use: TypeOnly<current.TelemetryNullLogger>): void;
use_current_ClassDeclaration_TelemetryNullLogger(
    get_old_ClassDeclaration_TelemetryNullLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TelemetryNullLogger": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TelemetryNullLogger():
    TypeOnly<current.TelemetryNullLogger>;
declare function use_old_ClassDeclaration_TelemetryNullLogger(
    use: TypeOnly<old.TelemetryNullLogger>): void;
use_old_ClassDeclaration_TelemetryNullLogger(
    get_current_ClassDeclaration_TelemetryNullLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ThresholdCounter": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ThresholdCounter():
    TypeOnly<old.ThresholdCounter>;
declare function use_current_ClassDeclaration_ThresholdCounter(
    use: TypeOnly<current.ThresholdCounter>): void;
use_current_ClassDeclaration_ThresholdCounter(
    get_old_ClassDeclaration_ThresholdCounter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ThresholdCounter": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ThresholdCounter():
    TypeOnly<current.ThresholdCounter>;
declare function use_old_ClassDeclaration_ThresholdCounter(
    use: TypeOnly<old.ThresholdCounter>): void;
use_old_ClassDeclaration_ThresholdCounter(
    get_current_ClassDeclaration_ThresholdCounter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_UsageError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_UsageError():
    TypeOnly<old.UsageError>;
declare function use_current_ClassDeclaration_UsageError(
    use: TypeOnly<current.UsageError>): void;
use_current_ClassDeclaration_UsageError(
    get_old_ClassDeclaration_UsageError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_UsageError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_UsageError():
    TypeOnly<current.UsageError>;
declare function use_old_ClassDeclaration_UsageError(
    use: TypeOnly<old.UsageError>): void;
use_old_ClassDeclaration_UsageError(
    get_current_ClassDeclaration_UsageError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_connectedEventName": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_connectedEventName():
    TypeOnly<typeof old.connectedEventName>;
declare function use_current_VariableDeclaration_connectedEventName(
    use: TypeOnly<typeof current.connectedEventName>): void;
use_current_VariableDeclaration_connectedEventName(
    get_old_VariableDeclaration_connectedEventName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_connectedEventName": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_connectedEventName():
    TypeOnly<typeof current.connectedEventName>;
declare function use_old_VariableDeclaration_connectedEventName(
    use: TypeOnly<typeof old.connectedEventName>): void;
use_old_VariableDeclaration_connectedEventName(
    get_current_VariableDeclaration_connectedEventName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createChildLogger": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createChildLogger():
    TypeOnly<typeof old.createChildLogger>;
declare function use_current_FunctionDeclaration_createChildLogger(
    use: TypeOnly<typeof current.createChildLogger>): void;
use_current_FunctionDeclaration_createChildLogger(
    get_old_FunctionDeclaration_createChildLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createChildLogger": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createChildLogger():
    TypeOnly<typeof current.createChildLogger>;
declare function use_old_FunctionDeclaration_createChildLogger(
    use: TypeOnly<typeof old.createChildLogger>): void;
use_old_FunctionDeclaration_createChildLogger(
    get_current_FunctionDeclaration_createChildLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createChildMonitoringContext": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createChildMonitoringContext():
    TypeOnly<typeof old.createChildMonitoringContext>;
declare function use_current_FunctionDeclaration_createChildMonitoringContext(
    use: TypeOnly<typeof current.createChildMonitoringContext>): void;
use_current_FunctionDeclaration_createChildMonitoringContext(
    get_old_FunctionDeclaration_createChildMonitoringContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createChildMonitoringContext": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createChildMonitoringContext():
    TypeOnly<typeof current.createChildMonitoringContext>;
declare function use_old_FunctionDeclaration_createChildMonitoringContext(
    use: TypeOnly<typeof old.createChildMonitoringContext>): void;
use_old_FunctionDeclaration_createChildMonitoringContext(
    get_current_FunctionDeclaration_createChildMonitoringContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createMultiSinkLogger": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createMultiSinkLogger():
    TypeOnly<typeof old.createMultiSinkLogger>;
declare function use_current_FunctionDeclaration_createMultiSinkLogger(
    use: TypeOnly<typeof current.createMultiSinkLogger>): void;
use_current_FunctionDeclaration_createMultiSinkLogger(
    get_old_FunctionDeclaration_createMultiSinkLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createMultiSinkLogger": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createMultiSinkLogger():
    TypeOnly<typeof current.createMultiSinkLogger>;
declare function use_old_FunctionDeclaration_createMultiSinkLogger(
    use: TypeOnly<typeof old.createMultiSinkLogger>): void;
use_old_FunctionDeclaration_createMultiSinkLogger(
    get_current_FunctionDeclaration_createMultiSinkLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createSampledLogger": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createSampledLogger():
    TypeOnly<typeof old.createSampledLogger>;
declare function use_current_FunctionDeclaration_createSampledLogger(
    use: TypeOnly<typeof current.createSampledLogger>): void;
use_current_FunctionDeclaration_createSampledLogger(
    get_old_FunctionDeclaration_createSampledLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createSampledLogger": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createSampledLogger():
    TypeOnly<typeof current.createSampledLogger>;
declare function use_old_FunctionDeclaration_createSampledLogger(
    use: TypeOnly<typeof old.createSampledLogger>): void;
use_old_FunctionDeclaration_createSampledLogger(
    get_current_FunctionDeclaration_createSampledLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_disconnectedEventName": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_disconnectedEventName():
    TypeOnly<typeof old.disconnectedEventName>;
declare function use_current_VariableDeclaration_disconnectedEventName(
    use: TypeOnly<typeof current.disconnectedEventName>): void;
use_current_VariableDeclaration_disconnectedEventName(
    get_old_VariableDeclaration_disconnectedEventName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_disconnectedEventName": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_disconnectedEventName():
    TypeOnly<typeof current.disconnectedEventName>;
declare function use_old_VariableDeclaration_disconnectedEventName(
    use: TypeOnly<typeof old.disconnectedEventName>): void;
use_old_VariableDeclaration_disconnectedEventName(
    get_current_VariableDeclaration_disconnectedEventName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_eventNamespaceSeparator": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_eventNamespaceSeparator():
    TypeOnly<typeof old.eventNamespaceSeparator>;
declare function use_current_VariableDeclaration_eventNamespaceSeparator(
    use: TypeOnly<typeof current.eventNamespaceSeparator>): void;
use_current_VariableDeclaration_eventNamespaceSeparator(
    get_old_VariableDeclaration_eventNamespaceSeparator());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_eventNamespaceSeparator": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_eventNamespaceSeparator():
    TypeOnly<typeof current.eventNamespaceSeparator>;
declare function use_old_VariableDeclaration_eventNamespaceSeparator(
    use: TypeOnly<typeof old.eventNamespaceSeparator>): void;
use_old_VariableDeclaration_eventNamespaceSeparator(
    get_current_VariableDeclaration_eventNamespaceSeparator());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_extractLogSafeErrorProperties": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_extractLogSafeErrorProperties():
    TypeOnly<typeof old.extractLogSafeErrorProperties>;
declare function use_current_FunctionDeclaration_extractLogSafeErrorProperties(
    use: TypeOnly<typeof current.extractLogSafeErrorProperties>): void;
use_current_FunctionDeclaration_extractLogSafeErrorProperties(
    get_old_FunctionDeclaration_extractLogSafeErrorProperties());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_extractLogSafeErrorProperties": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_extractLogSafeErrorProperties():
    TypeOnly<typeof current.extractLogSafeErrorProperties>;
declare function use_old_FunctionDeclaration_extractLogSafeErrorProperties(
    use: TypeOnly<typeof old.extractLogSafeErrorProperties>): void;
use_old_FunctionDeclaration_extractLogSafeErrorProperties(
    get_current_FunctionDeclaration_extractLogSafeErrorProperties());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_extractSafePropertiesFromMessage": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_extractSafePropertiesFromMessage():
    TypeOnly<typeof old.extractSafePropertiesFromMessage>;
declare function use_current_VariableDeclaration_extractSafePropertiesFromMessage(
    use: TypeOnly<typeof current.extractSafePropertiesFromMessage>): void;
use_current_VariableDeclaration_extractSafePropertiesFromMessage(
    get_old_VariableDeclaration_extractSafePropertiesFromMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_extractSafePropertiesFromMessage": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_extractSafePropertiesFromMessage():
    TypeOnly<typeof current.extractSafePropertiesFromMessage>;
declare function use_old_VariableDeclaration_extractSafePropertiesFromMessage(
    use: TypeOnly<typeof old.extractSafePropertiesFromMessage>): void;
use_old_VariableDeclaration_extractSafePropertiesFromMessage(
    get_current_VariableDeclaration_extractSafePropertiesFromMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_formatTick": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_formatTick():
    TypeOnly<typeof old.formatTick>;
declare function use_current_FunctionDeclaration_formatTick(
    use: TypeOnly<typeof current.formatTick>): void;
use_current_FunctionDeclaration_formatTick(
    get_old_FunctionDeclaration_formatTick());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_formatTick": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_formatTick():
    TypeOnly<typeof current.formatTick>;
declare function use_old_FunctionDeclaration_formatTick(
    use: TypeOnly<typeof old.formatTick>): void;
use_old_FunctionDeclaration_formatTick(
    get_current_FunctionDeclaration_formatTick());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateErrorWithStack": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_generateErrorWithStack():
    TypeOnly<typeof old.generateErrorWithStack>;
declare function use_current_FunctionDeclaration_generateErrorWithStack(
    use: TypeOnly<typeof current.generateErrorWithStack>): void;
use_current_FunctionDeclaration_generateErrorWithStack(
    get_old_FunctionDeclaration_generateErrorWithStack());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateErrorWithStack": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_generateErrorWithStack():
    TypeOnly<typeof current.generateErrorWithStack>;
declare function use_old_FunctionDeclaration_generateErrorWithStack(
    use: TypeOnly<typeof old.generateErrorWithStack>): void;
use_old_FunctionDeclaration_generateErrorWithStack(
    get_current_FunctionDeclaration_generateErrorWithStack());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateStack": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_generateStack():
    TypeOnly<typeof old.generateStack>;
declare function use_current_FunctionDeclaration_generateStack(
    use: TypeOnly<typeof current.generateStack>): void;
use_current_FunctionDeclaration_generateStack(
    get_old_FunctionDeclaration_generateStack());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateStack": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_generateStack():
    TypeOnly<typeof current.generateStack>;
declare function use_old_FunctionDeclaration_generateStack(
    use: TypeOnly<typeof old.generateStack>): void;
use_old_FunctionDeclaration_generateStack(
    get_current_FunctionDeclaration_generateStack());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getCircularReplacer": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getCircularReplacer():
    TypeOnly<typeof old.getCircularReplacer>;
declare function use_current_VariableDeclaration_getCircularReplacer(
    use: TypeOnly<typeof current.getCircularReplacer>): void;
use_current_VariableDeclaration_getCircularReplacer(
    get_old_VariableDeclaration_getCircularReplacer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getCircularReplacer": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getCircularReplacer():
    TypeOnly<typeof current.getCircularReplacer>;
declare function use_old_VariableDeclaration_getCircularReplacer(
    use: TypeOnly<typeof old.getCircularReplacer>): void;
use_old_VariableDeclaration_getCircularReplacer(
    get_current_VariableDeclaration_getCircularReplacer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_hasErrorInstanceId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_hasErrorInstanceId():
    TypeOnly<typeof old.hasErrorInstanceId>;
declare function use_current_VariableDeclaration_hasErrorInstanceId(
    use: TypeOnly<typeof current.hasErrorInstanceId>): void;
use_current_VariableDeclaration_hasErrorInstanceId(
    get_old_VariableDeclaration_hasErrorInstanceId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_hasErrorInstanceId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_hasErrorInstanceId():
    TypeOnly<typeof current.hasErrorInstanceId>;
declare function use_old_VariableDeclaration_hasErrorInstanceId(
    use: TypeOnly<typeof old.hasErrorInstanceId>): void;
use_old_VariableDeclaration_hasErrorInstanceId(
    get_current_VariableDeclaration_hasErrorInstanceId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isExternalError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isExternalError():
    TypeOnly<typeof old.isExternalError>;
declare function use_current_FunctionDeclaration_isExternalError(
    use: TypeOnly<typeof current.isExternalError>): void;
use_current_FunctionDeclaration_isExternalError(
    get_old_FunctionDeclaration_isExternalError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isExternalError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isExternalError():
    TypeOnly<typeof current.isExternalError>;
declare function use_old_FunctionDeclaration_isExternalError(
    use: TypeOnly<typeof old.isExternalError>): void;
use_old_FunctionDeclaration_isExternalError(
    get_current_FunctionDeclaration_isExternalError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isFluidError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isFluidError():
    TypeOnly<typeof old.isFluidError>;
declare function use_current_FunctionDeclaration_isFluidError(
    use: TypeOnly<typeof current.isFluidError>): void;
use_current_FunctionDeclaration_isFluidError(
    get_old_FunctionDeclaration_isFluidError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isFluidError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isFluidError():
    TypeOnly<typeof current.isFluidError>;
declare function use_old_FunctionDeclaration_isFluidError(
    use: TypeOnly<typeof old.isFluidError>): void;
use_old_FunctionDeclaration_isFluidError(
    get_current_FunctionDeclaration_isFluidError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isILoggingError": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isILoggingError():
    TypeOnly<typeof old.isILoggingError>;
declare function use_current_VariableDeclaration_isILoggingError(
    use: TypeOnly<typeof current.isILoggingError>): void;
use_current_VariableDeclaration_isILoggingError(
    get_old_VariableDeclaration_isILoggingError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isILoggingError": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isILoggingError():
    TypeOnly<typeof current.isILoggingError>;
declare function use_old_VariableDeclaration_isILoggingError(
    use: TypeOnly<typeof old.isILoggingError>): void;
use_old_VariableDeclaration_isILoggingError(
    get_current_VariableDeclaration_isILoggingError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isTaggedTelemetryPropertyValue": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isTaggedTelemetryPropertyValue():
    TypeOnly<typeof old.isTaggedTelemetryPropertyValue>;
declare function use_current_FunctionDeclaration_isTaggedTelemetryPropertyValue(
    use: TypeOnly<typeof current.isTaggedTelemetryPropertyValue>): void;
use_current_FunctionDeclaration_isTaggedTelemetryPropertyValue(
    get_old_FunctionDeclaration_isTaggedTelemetryPropertyValue());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isTaggedTelemetryPropertyValue": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isTaggedTelemetryPropertyValue():
    TypeOnly<typeof current.isTaggedTelemetryPropertyValue>;
declare function use_old_FunctionDeclaration_isTaggedTelemetryPropertyValue(
    use: TypeOnly<typeof old.isTaggedTelemetryPropertyValue>): void;
use_old_FunctionDeclaration_isTaggedTelemetryPropertyValue(
    get_current_FunctionDeclaration_isTaggedTelemetryPropertyValue());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isValidLegacyError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isValidLegacyError():
    TypeOnly<typeof old.isValidLegacyError>;
declare function use_current_FunctionDeclaration_isValidLegacyError(
    use: TypeOnly<typeof current.isValidLegacyError>): void;
use_current_FunctionDeclaration_isValidLegacyError(
    get_old_FunctionDeclaration_isValidLegacyError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isValidLegacyError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isValidLegacyError():
    TypeOnly<typeof current.isValidLegacyError>;
declare function use_old_FunctionDeclaration_isValidLegacyError(
    use: TypeOnly<typeof old.isValidLegacyError>): void;
use_old_FunctionDeclaration_isValidLegacyError(
    get_current_FunctionDeclaration_isValidLegacyError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_logIfFalse": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_logIfFalse():
    TypeOnly<typeof old.logIfFalse>;
declare function use_current_FunctionDeclaration_logIfFalse(
    use: TypeOnly<typeof current.logIfFalse>): void;
use_current_FunctionDeclaration_logIfFalse(
    get_old_FunctionDeclaration_logIfFalse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_logIfFalse": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_logIfFalse():
    TypeOnly<typeof current.logIfFalse>;
declare function use_old_FunctionDeclaration_logIfFalse(
    use: TypeOnly<typeof old.logIfFalse>): void;
use_old_FunctionDeclaration_logIfFalse(
    get_current_FunctionDeclaration_logIfFalse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_loggerToMonitoringContext": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_loggerToMonitoringContext():
    TypeOnly<typeof old.loggerToMonitoringContext>;
declare function use_current_FunctionDeclaration_loggerToMonitoringContext(
    use: TypeOnly<typeof current.loggerToMonitoringContext>): void;
use_current_FunctionDeclaration_loggerToMonitoringContext(
    get_old_FunctionDeclaration_loggerToMonitoringContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_loggerToMonitoringContext": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_loggerToMonitoringContext():
    TypeOnly<typeof current.loggerToMonitoringContext>;
declare function use_old_FunctionDeclaration_loggerToMonitoringContext(
    use: TypeOnly<typeof old.loggerToMonitoringContext>): void;
use_old_FunctionDeclaration_loggerToMonitoringContext(
    get_current_FunctionDeclaration_loggerToMonitoringContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_mixinMonitoringContext": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_mixinMonitoringContext():
    TypeOnly<typeof old.mixinMonitoringContext>;
declare function use_current_FunctionDeclaration_mixinMonitoringContext(
    use: TypeOnly<typeof current.mixinMonitoringContext>): void;
use_current_FunctionDeclaration_mixinMonitoringContext(
    get_old_FunctionDeclaration_mixinMonitoringContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_mixinMonitoringContext": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_mixinMonitoringContext():
    TypeOnly<typeof current.mixinMonitoringContext>;
declare function use_old_FunctionDeclaration_mixinMonitoringContext(
    use: TypeOnly<typeof old.mixinMonitoringContext>): void;
use_old_FunctionDeclaration_mixinMonitoringContext(
    get_current_FunctionDeclaration_mixinMonitoringContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_normalizeError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_normalizeError():
    TypeOnly<typeof old.normalizeError>;
declare function use_current_FunctionDeclaration_normalizeError(
    use: TypeOnly<typeof current.normalizeError>): void;
use_current_FunctionDeclaration_normalizeError(
    get_old_FunctionDeclaration_normalizeError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_normalizeError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_normalizeError():
    TypeOnly<typeof current.normalizeError>;
declare function use_old_FunctionDeclaration_normalizeError(
    use: TypeOnly<typeof old.normalizeError>): void;
use_old_FunctionDeclaration_normalizeError(
    get_current_FunctionDeclaration_normalizeError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_numberFromString": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_numberFromString():
    TypeOnly<typeof old.numberFromString>;
declare function use_current_FunctionDeclaration_numberFromString(
    use: TypeOnly<typeof current.numberFromString>): void;
use_current_FunctionDeclaration_numberFromString(
    get_old_FunctionDeclaration_numberFromString());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_numberFromString": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_numberFromString():
    TypeOnly<typeof current.numberFromString>;
declare function use_old_FunctionDeclaration_numberFromString(
    use: TypeOnly<typeof old.numberFromString>): void;
use_old_FunctionDeclaration_numberFromString(
    get_current_FunctionDeclaration_numberFromString());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_overwriteStack": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_overwriteStack():
    TypeOnly<typeof old.overwriteStack>;
declare function use_current_FunctionDeclaration_overwriteStack(
    use: TypeOnly<typeof current.overwriteStack>): void;
use_current_FunctionDeclaration_overwriteStack(
    get_old_FunctionDeclaration_overwriteStack());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_overwriteStack": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_overwriteStack():
    TypeOnly<typeof current.overwriteStack>;
declare function use_old_FunctionDeclaration_overwriteStack(
    use: TypeOnly<typeof old.overwriteStack>): void;
use_old_FunctionDeclaration_overwriteStack(
    get_current_FunctionDeclaration_overwriteStack());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_raiseConnectedEvent": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_raiseConnectedEvent():
    TypeOnly<typeof old.raiseConnectedEvent>;
declare function use_current_FunctionDeclaration_raiseConnectedEvent(
    use: TypeOnly<typeof current.raiseConnectedEvent>): void;
use_current_FunctionDeclaration_raiseConnectedEvent(
    get_old_FunctionDeclaration_raiseConnectedEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_raiseConnectedEvent": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_raiseConnectedEvent():
    TypeOnly<typeof current.raiseConnectedEvent>;
declare function use_old_FunctionDeclaration_raiseConnectedEvent(
    use: TypeOnly<typeof old.raiseConnectedEvent>): void;
use_old_FunctionDeclaration_raiseConnectedEvent(
    get_current_FunctionDeclaration_raiseConnectedEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_safeRaiseEvent": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_safeRaiseEvent():
    TypeOnly<typeof old.safeRaiseEvent>;
declare function use_current_FunctionDeclaration_safeRaiseEvent(
    use: TypeOnly<typeof current.safeRaiseEvent>): void;
use_current_FunctionDeclaration_safeRaiseEvent(
    get_old_FunctionDeclaration_safeRaiseEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_safeRaiseEvent": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_safeRaiseEvent():
    TypeOnly<typeof current.safeRaiseEvent>;
declare function use_old_FunctionDeclaration_safeRaiseEvent(
    use: TypeOnly<typeof old.safeRaiseEvent>): void;
use_old_FunctionDeclaration_safeRaiseEvent(
    get_current_FunctionDeclaration_safeRaiseEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_sessionStorageConfigProvider": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_sessionStorageConfigProvider():
    TypeOnly<typeof old.sessionStorageConfigProvider>;
declare function use_current_VariableDeclaration_sessionStorageConfigProvider(
    use: TypeOnly<typeof current.sessionStorageConfigProvider>): void;
use_current_VariableDeclaration_sessionStorageConfigProvider(
    get_old_VariableDeclaration_sessionStorageConfigProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_sessionStorageConfigProvider": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_sessionStorageConfigProvider():
    TypeOnly<typeof current.sessionStorageConfigProvider>;
declare function use_old_VariableDeclaration_sessionStorageConfigProvider(
    use: TypeOnly<typeof old.sessionStorageConfigProvider>): void;
use_old_VariableDeclaration_sessionStorageConfigProvider(
    get_current_VariableDeclaration_sessionStorageConfigProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_tagCodeArtifacts": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_tagCodeArtifacts():
    TypeOnly<typeof old.tagCodeArtifacts>;
declare function use_current_VariableDeclaration_tagCodeArtifacts(
    use: TypeOnly<typeof current.tagCodeArtifacts>): void;
use_current_VariableDeclaration_tagCodeArtifacts(
    get_old_VariableDeclaration_tagCodeArtifacts());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_tagCodeArtifacts": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_tagCodeArtifacts():
    TypeOnly<typeof current.tagCodeArtifacts>;
declare function use_old_VariableDeclaration_tagCodeArtifacts(
    use: TypeOnly<typeof old.tagCodeArtifacts>): void;
use_old_VariableDeclaration_tagCodeArtifacts(
    get_current_VariableDeclaration_tagCodeArtifacts());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_tagData": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_tagData():
    TypeOnly<typeof old.tagData>;
declare function use_current_VariableDeclaration_tagData(
    use: TypeOnly<typeof current.tagData>): void;
use_current_VariableDeclaration_tagData(
    get_old_VariableDeclaration_tagData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_tagData": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_tagData():
    TypeOnly<typeof current.tagData>;
declare function use_old_VariableDeclaration_tagData(
    use: TypeOnly<typeof old.tagData>): void;
use_old_VariableDeclaration_tagData(
    get_current_VariableDeclaration_tagData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_wrapError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_wrapError():
    TypeOnly<typeof old.wrapError>;
declare function use_current_FunctionDeclaration_wrapError(
    use: TypeOnly<typeof current.wrapError>): void;
use_current_FunctionDeclaration_wrapError(
    get_old_FunctionDeclaration_wrapError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_wrapError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_wrapError():
    TypeOnly<typeof current.wrapError>;
declare function use_old_FunctionDeclaration_wrapError(
    use: TypeOnly<typeof old.wrapError>): void;
use_old_FunctionDeclaration_wrapError(
    get_current_FunctionDeclaration_wrapError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_wrapErrorAndLog": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_wrapErrorAndLog():
    TypeOnly<typeof old.wrapErrorAndLog>;
declare function use_current_FunctionDeclaration_wrapErrorAndLog(
    use: TypeOnly<typeof current.wrapErrorAndLog>): void;
use_current_FunctionDeclaration_wrapErrorAndLog(
    get_old_FunctionDeclaration_wrapErrorAndLog());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_wrapErrorAndLog": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_wrapErrorAndLog():
    TypeOnly<typeof current.wrapErrorAndLog>;
declare function use_old_FunctionDeclaration_wrapErrorAndLog(
    use: TypeOnly<typeof old.wrapErrorAndLog>): void;
use_old_FunctionDeclaration_wrapErrorAndLog(
    get_current_FunctionDeclaration_wrapErrorAndLog());
