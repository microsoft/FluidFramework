/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "@fluidframework/telemetry-utils-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ChildLogger": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ChildLogger():
    TypeOnly<old.ChildLogger>;
declare function use_current_ClassDeclaration_ChildLogger(
    use: TypeOnly<current.ChildLogger>);
use_current_ClassDeclaration_ChildLogger(
    get_old_ClassDeclaration_ChildLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ChildLogger": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ChildLogger():
    TypeOnly<current.ChildLogger>;
declare function use_old_ClassDeclaration_ChildLogger(
    use: TypeOnly<old.ChildLogger>);
use_old_ClassDeclaration_ChildLogger(
    get_current_ClassDeclaration_ChildLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConfigTypes": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConfigTypes():
    TypeOnly<old.ConfigTypes>;
declare function use_current_TypeAliasDeclaration_ConfigTypes(
    use: TypeOnly<current.ConfigTypes>);
use_current_TypeAliasDeclaration_ConfigTypes(
    get_old_TypeAliasDeclaration_ConfigTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConfigTypes": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConfigTypes():
    TypeOnly<current.ConfigTypes>;
declare function use_old_TypeAliasDeclaration_ConfigTypes(
    use: TypeOnly<old.ConfigTypes>);
use_old_TypeAliasDeclaration_ConfigTypes(
    get_current_TypeAliasDeclaration_ConfigTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_connectedEventName": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_connectedEventName():
    TypeOnly<typeof old.connectedEventName>;
declare function use_current_VariableDeclaration_connectedEventName(
    use: TypeOnly<typeof current.connectedEventName>);
use_current_VariableDeclaration_connectedEventName(
    get_old_VariableDeclaration_connectedEventName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_connectedEventName": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_connectedEventName():
    TypeOnly<typeof current.connectedEventName>;
declare function use_old_VariableDeclaration_connectedEventName(
    use: TypeOnly<typeof old.connectedEventName>);
use_old_VariableDeclaration_connectedEventName(
    get_current_VariableDeclaration_connectedEventName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DebugLogger": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DebugLogger():
    TypeOnly<old.DebugLogger>;
declare function use_current_ClassDeclaration_DebugLogger(
    use: TypeOnly<current.DebugLogger>);
use_current_ClassDeclaration_DebugLogger(
    get_old_ClassDeclaration_DebugLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DebugLogger": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DebugLogger():
    TypeOnly<current.DebugLogger>;
declare function use_old_ClassDeclaration_DebugLogger(
    use: TypeOnly<old.DebugLogger>);
use_old_ClassDeclaration_DebugLogger(
    get_current_ClassDeclaration_DebugLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_disconnectedEventName": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_disconnectedEventName():
    TypeOnly<typeof old.disconnectedEventName>;
declare function use_current_VariableDeclaration_disconnectedEventName(
    use: TypeOnly<typeof current.disconnectedEventName>);
use_current_VariableDeclaration_disconnectedEventName(
    get_old_VariableDeclaration_disconnectedEventName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_disconnectedEventName": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_disconnectedEventName():
    TypeOnly<typeof current.disconnectedEventName>;
declare function use_old_VariableDeclaration_disconnectedEventName(
    use: TypeOnly<typeof old.disconnectedEventName>);
use_old_VariableDeclaration_disconnectedEventName(
    get_current_VariableDeclaration_disconnectedEventName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EventEmitterWithErrorHandling": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_EventEmitterWithErrorHandling():
    TypeOnly<old.EventEmitterWithErrorHandling>;
declare function use_current_ClassDeclaration_EventEmitterWithErrorHandling(
    use: TypeOnly<current.EventEmitterWithErrorHandling>);
use_current_ClassDeclaration_EventEmitterWithErrorHandling(
    get_old_ClassDeclaration_EventEmitterWithErrorHandling());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EventEmitterWithErrorHandling": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_EventEmitterWithErrorHandling():
    TypeOnly<current.EventEmitterWithErrorHandling>;
declare function use_old_ClassDeclaration_EventEmitterWithErrorHandling(
    use: TypeOnly<old.EventEmitterWithErrorHandling>);
use_old_ClassDeclaration_EventEmitterWithErrorHandling(
    get_current_ClassDeclaration_EventEmitterWithErrorHandling());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_extractLogSafeErrorProperties": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_extractLogSafeErrorProperties():
    TypeOnly<typeof old.extractLogSafeErrorProperties>;
declare function use_current_FunctionDeclaration_extractLogSafeErrorProperties(
    use: TypeOnly<typeof current.extractLogSafeErrorProperties>);
use_current_FunctionDeclaration_extractLogSafeErrorProperties(
    get_old_FunctionDeclaration_extractLogSafeErrorProperties());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_extractLogSafeErrorProperties": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_extractLogSafeErrorProperties():
    TypeOnly<typeof current.extractLogSafeErrorProperties>;
declare function use_old_FunctionDeclaration_extractLogSafeErrorProperties(
    use: TypeOnly<typeof old.extractLogSafeErrorProperties>);
use_old_FunctionDeclaration_extractLogSafeErrorProperties(
    get_current_FunctionDeclaration_extractLogSafeErrorProperties());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateErrorWithStack": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_generateErrorWithStack():
    TypeOnly<typeof old.generateErrorWithStack>;
declare function use_current_FunctionDeclaration_generateErrorWithStack(
    use: TypeOnly<typeof current.generateErrorWithStack>);
use_current_FunctionDeclaration_generateErrorWithStack(
    get_old_FunctionDeclaration_generateErrorWithStack());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateErrorWithStack": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_generateErrorWithStack():
    TypeOnly<typeof current.generateErrorWithStack>;
declare function use_old_FunctionDeclaration_generateErrorWithStack(
    use: TypeOnly<typeof old.generateErrorWithStack>);
use_old_FunctionDeclaration_generateErrorWithStack(
    get_current_FunctionDeclaration_generateErrorWithStack());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateStack": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_generateStack():
    TypeOnly<typeof old.generateStack>;
declare function use_current_FunctionDeclaration_generateStack(
    use: TypeOnly<typeof current.generateStack>);
use_current_FunctionDeclaration_generateStack(
    get_old_FunctionDeclaration_generateStack());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateStack": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_generateStack():
    TypeOnly<typeof current.generateStack>;
declare function use_old_FunctionDeclaration_generateStack(
    use: TypeOnly<typeof old.generateStack>);
use_old_FunctionDeclaration_generateStack(
    get_current_FunctionDeclaration_generateStack());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getCircularReplacer": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getCircularReplacer():
    TypeOnly<typeof old.getCircularReplacer>;
declare function use_current_VariableDeclaration_getCircularReplacer(
    use: TypeOnly<typeof current.getCircularReplacer>);
use_current_VariableDeclaration_getCircularReplacer(
    get_old_VariableDeclaration_getCircularReplacer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getCircularReplacer": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getCircularReplacer():
    TypeOnly<typeof current.getCircularReplacer>;
declare function use_old_VariableDeclaration_getCircularReplacer(
    use: TypeOnly<typeof old.getCircularReplacer>);
use_old_VariableDeclaration_getCircularReplacer(
    get_current_VariableDeclaration_getCircularReplacer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_hasErrorInstanceId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_hasErrorInstanceId():
    TypeOnly<typeof old.hasErrorInstanceId>;
declare function use_current_VariableDeclaration_hasErrorInstanceId(
    use: TypeOnly<typeof current.hasErrorInstanceId>);
use_current_VariableDeclaration_hasErrorInstanceId(
    get_old_VariableDeclaration_hasErrorInstanceId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_hasErrorInstanceId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_hasErrorInstanceId():
    TypeOnly<typeof current.hasErrorInstanceId>;
declare function use_old_VariableDeclaration_hasErrorInstanceId(
    use: TypeOnly<typeof old.hasErrorInstanceId>);
use_old_VariableDeclaration_hasErrorInstanceId(
    get_current_VariableDeclaration_hasErrorInstanceId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConfigProvider": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConfigProvider():
    TypeOnly<old.IConfigProvider>;
declare function use_current_InterfaceDeclaration_IConfigProvider(
    use: TypeOnly<current.IConfigProvider>);
use_current_InterfaceDeclaration_IConfigProvider(
    get_old_InterfaceDeclaration_IConfigProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConfigProvider": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConfigProvider():
    TypeOnly<current.IConfigProvider>;
declare function use_old_InterfaceDeclaration_IConfigProvider(
    use: TypeOnly<old.IConfigProvider>);
use_old_InterfaceDeclaration_IConfigProvider(
    get_current_InterfaceDeclaration_IConfigProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConfigProviderBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConfigProviderBase():
    TypeOnly<old.IConfigProviderBase>;
declare function use_current_InterfaceDeclaration_IConfigProviderBase(
    use: TypeOnly<current.IConfigProviderBase>);
use_current_InterfaceDeclaration_IConfigProviderBase(
    get_old_InterfaceDeclaration_IConfigProviderBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConfigProviderBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConfigProviderBase():
    TypeOnly<current.IConfigProviderBase>;
declare function use_old_InterfaceDeclaration_IConfigProviderBase(
    use: TypeOnly<old.IConfigProviderBase>);
use_old_InterfaceDeclaration_IConfigProviderBase(
    get_current_InterfaceDeclaration_IConfigProviderBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidErrorAnnotations": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidErrorAnnotations():
    TypeOnly<old.IFluidErrorAnnotations>;
declare function use_current_InterfaceDeclaration_IFluidErrorAnnotations(
    use: TypeOnly<current.IFluidErrorAnnotations>);
use_current_InterfaceDeclaration_IFluidErrorAnnotations(
    get_old_InterfaceDeclaration_IFluidErrorAnnotations());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidErrorAnnotations": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidErrorAnnotations():
    TypeOnly<current.IFluidErrorAnnotations>;
declare function use_old_InterfaceDeclaration_IFluidErrorAnnotations(
    use: TypeOnly<old.IFluidErrorAnnotations>);
use_old_InterfaceDeclaration_IFluidErrorAnnotations(
    get_current_InterfaceDeclaration_IFluidErrorAnnotations());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidErrorBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidErrorBase():
    TypeOnly<old.IFluidErrorBase>;
declare function use_current_InterfaceDeclaration_IFluidErrorBase(
    use: TypeOnly<current.IFluidErrorBase>);
use_current_InterfaceDeclaration_IFluidErrorBase(
    get_old_InterfaceDeclaration_IFluidErrorBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidErrorBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidErrorBase():
    TypeOnly<current.IFluidErrorBase>;
declare function use_old_InterfaceDeclaration_IFluidErrorBase(
    use: TypeOnly<old.IFluidErrorBase>);
use_old_InterfaceDeclaration_IFluidErrorBase(
    get_current_InterfaceDeclaration_IFluidErrorBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPerformanceEventMarkers": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPerformanceEventMarkers():
    TypeOnly<old.IPerformanceEventMarkers>;
declare function use_current_InterfaceDeclaration_IPerformanceEventMarkers(
    use: TypeOnly<current.IPerformanceEventMarkers>);
use_current_InterfaceDeclaration_IPerformanceEventMarkers(
    get_old_InterfaceDeclaration_IPerformanceEventMarkers());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPerformanceEventMarkers": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPerformanceEventMarkers():
    TypeOnly<current.IPerformanceEventMarkers>;
declare function use_old_InterfaceDeclaration_IPerformanceEventMarkers(
    use: TypeOnly<old.IPerformanceEventMarkers>);
use_old_InterfaceDeclaration_IPerformanceEventMarkers(
    get_current_InterfaceDeclaration_IPerformanceEventMarkers());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isExternalError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isExternalError():
    TypeOnly<typeof old.isExternalError>;
declare function use_current_FunctionDeclaration_isExternalError(
    use: TypeOnly<typeof current.isExternalError>);
use_current_FunctionDeclaration_isExternalError(
    get_old_FunctionDeclaration_isExternalError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isExternalError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isExternalError():
    TypeOnly<typeof current.isExternalError>;
declare function use_old_FunctionDeclaration_isExternalError(
    use: TypeOnly<typeof old.isExternalError>);
use_old_FunctionDeclaration_isExternalError(
    get_current_FunctionDeclaration_isExternalError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isFluidError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isFluidError():
    TypeOnly<typeof old.isFluidError>;
declare function use_current_FunctionDeclaration_isFluidError(
    use: TypeOnly<typeof current.isFluidError>);
use_current_FunctionDeclaration_isFluidError(
    get_old_FunctionDeclaration_isFluidError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isFluidError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isFluidError():
    TypeOnly<typeof current.isFluidError>;
declare function use_old_FunctionDeclaration_isFluidError(
    use: TypeOnly<typeof old.isFluidError>);
use_old_FunctionDeclaration_isFluidError(
    get_current_FunctionDeclaration_isFluidError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isILoggingError": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isILoggingError():
    TypeOnly<typeof old.isILoggingError>;
declare function use_current_VariableDeclaration_isILoggingError(
    use: TypeOnly<typeof current.isILoggingError>);
use_current_VariableDeclaration_isILoggingError(
    get_old_VariableDeclaration_isILoggingError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isILoggingError": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isILoggingError():
    TypeOnly<typeof current.isILoggingError>;
declare function use_old_VariableDeclaration_isILoggingError(
    use: TypeOnly<typeof old.isILoggingError>);
use_old_VariableDeclaration_isILoggingError(
    get_current_VariableDeclaration_isILoggingError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isTaggedTelemetryPropertyValue": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isTaggedTelemetryPropertyValue():
    TypeOnly<typeof old.isTaggedTelemetryPropertyValue>;
declare function use_current_FunctionDeclaration_isTaggedTelemetryPropertyValue(
    use: TypeOnly<typeof current.isTaggedTelemetryPropertyValue>);
use_current_FunctionDeclaration_isTaggedTelemetryPropertyValue(
    get_old_FunctionDeclaration_isTaggedTelemetryPropertyValue());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isTaggedTelemetryPropertyValue": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isTaggedTelemetryPropertyValue():
    TypeOnly<typeof current.isTaggedTelemetryPropertyValue>;
declare function use_old_FunctionDeclaration_isTaggedTelemetryPropertyValue(
    use: TypeOnly<typeof old.isTaggedTelemetryPropertyValue>);
use_old_FunctionDeclaration_isTaggedTelemetryPropertyValue(
    get_current_FunctionDeclaration_isTaggedTelemetryPropertyValue());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isValidLegacyError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isValidLegacyError():
    TypeOnly<typeof old.isValidLegacyError>;
declare function use_current_FunctionDeclaration_isValidLegacyError(
    use: TypeOnly<typeof current.isValidLegacyError>);
use_current_FunctionDeclaration_isValidLegacyError(
    get_old_FunctionDeclaration_isValidLegacyError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isValidLegacyError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isValidLegacyError():
    TypeOnly<typeof current.isValidLegacyError>;
declare function use_old_FunctionDeclaration_isValidLegacyError(
    use: TypeOnly<typeof old.isValidLegacyError>);
use_old_FunctionDeclaration_isValidLegacyError(
    get_current_FunctionDeclaration_isValidLegacyError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryLoggerPropertyBag": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryLoggerPropertyBag():
    TypeOnly<old.ITelemetryLoggerPropertyBag>;
declare function use_current_InterfaceDeclaration_ITelemetryLoggerPropertyBag(
    use: TypeOnly<current.ITelemetryLoggerPropertyBag>);
use_current_InterfaceDeclaration_ITelemetryLoggerPropertyBag(
    get_old_InterfaceDeclaration_ITelemetryLoggerPropertyBag());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryLoggerPropertyBag": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryLoggerPropertyBag():
    TypeOnly<current.ITelemetryLoggerPropertyBag>;
declare function use_old_InterfaceDeclaration_ITelemetryLoggerPropertyBag(
    use: TypeOnly<old.ITelemetryLoggerPropertyBag>);
use_old_InterfaceDeclaration_ITelemetryLoggerPropertyBag(
    get_current_InterfaceDeclaration_ITelemetryLoggerPropertyBag());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryLoggerPropertyBags": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryLoggerPropertyBags():
    TypeOnly<old.ITelemetryLoggerPropertyBags>;
declare function use_current_InterfaceDeclaration_ITelemetryLoggerPropertyBags(
    use: TypeOnly<current.ITelemetryLoggerPropertyBags>);
use_current_InterfaceDeclaration_ITelemetryLoggerPropertyBags(
    get_old_InterfaceDeclaration_ITelemetryLoggerPropertyBags());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryLoggerPropertyBags": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryLoggerPropertyBags():
    TypeOnly<current.ITelemetryLoggerPropertyBags>;
declare function use_old_InterfaceDeclaration_ITelemetryLoggerPropertyBags(
    use: TypeOnly<old.ITelemetryLoggerPropertyBags>);
use_old_InterfaceDeclaration_ITelemetryLoggerPropertyBags(
    get_current_InterfaceDeclaration_ITelemetryLoggerPropertyBags());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_loggerToMonitoringContext": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_loggerToMonitoringContext():
    TypeOnly<typeof old.loggerToMonitoringContext>;
declare function use_current_FunctionDeclaration_loggerToMonitoringContext(
    use: TypeOnly<typeof current.loggerToMonitoringContext>);
use_current_FunctionDeclaration_loggerToMonitoringContext(
    get_old_FunctionDeclaration_loggerToMonitoringContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_loggerToMonitoringContext": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_loggerToMonitoringContext():
    TypeOnly<typeof current.loggerToMonitoringContext>;
declare function use_old_FunctionDeclaration_loggerToMonitoringContext(
    use: TypeOnly<typeof old.loggerToMonitoringContext>);
use_old_FunctionDeclaration_loggerToMonitoringContext(
    get_current_FunctionDeclaration_loggerToMonitoringContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LoggingError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_LoggingError():
    TypeOnly<old.LoggingError>;
declare function use_current_ClassDeclaration_LoggingError(
    use: TypeOnly<current.LoggingError>);
use_current_ClassDeclaration_LoggingError(
    get_old_ClassDeclaration_LoggingError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LoggingError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_LoggingError():
    TypeOnly<current.LoggingError>;
declare function use_old_ClassDeclaration_LoggingError(
    use: TypeOnly<old.LoggingError>);
use_old_ClassDeclaration_LoggingError(
    get_current_ClassDeclaration_LoggingError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_logIfFalse": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_logIfFalse():
    TypeOnly<typeof old.logIfFalse>;
declare function use_current_FunctionDeclaration_logIfFalse(
    use: TypeOnly<typeof current.logIfFalse>);
use_current_FunctionDeclaration_logIfFalse(
    get_old_FunctionDeclaration_logIfFalse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_logIfFalse": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_logIfFalse():
    TypeOnly<typeof current.logIfFalse>;
declare function use_old_FunctionDeclaration_logIfFalse(
    use: TypeOnly<typeof old.logIfFalse>);
use_old_FunctionDeclaration_logIfFalse(
    get_current_FunctionDeclaration_logIfFalse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_mixinMonitoringContext": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_mixinMonitoringContext():
    TypeOnly<typeof old.mixinMonitoringContext>;
declare function use_current_FunctionDeclaration_mixinMonitoringContext(
    use: TypeOnly<typeof current.mixinMonitoringContext>);
use_current_FunctionDeclaration_mixinMonitoringContext(
    get_old_FunctionDeclaration_mixinMonitoringContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_mixinMonitoringContext": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_mixinMonitoringContext():
    TypeOnly<typeof current.mixinMonitoringContext>;
declare function use_old_FunctionDeclaration_mixinMonitoringContext(
    use: TypeOnly<typeof old.mixinMonitoringContext>);
use_old_FunctionDeclaration_mixinMonitoringContext(
    get_current_FunctionDeclaration_mixinMonitoringContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MockLogger": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MockLogger():
    TypeOnly<old.MockLogger>;
declare function use_current_ClassDeclaration_MockLogger(
    use: TypeOnly<current.MockLogger>);
use_current_ClassDeclaration_MockLogger(
    get_old_ClassDeclaration_MockLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MockLogger": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MockLogger():
    TypeOnly<current.MockLogger>;
declare function use_old_ClassDeclaration_MockLogger(
    use: TypeOnly<old.MockLogger>);
use_old_ClassDeclaration_MockLogger(
    get_current_ClassDeclaration_MockLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_MonitoringContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_MonitoringContext():
    TypeOnly<old.MonitoringContext>;
declare function use_current_InterfaceDeclaration_MonitoringContext(
    use: TypeOnly<current.MonitoringContext>);
use_current_InterfaceDeclaration_MonitoringContext(
    get_old_InterfaceDeclaration_MonitoringContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_MonitoringContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_MonitoringContext():
    TypeOnly<current.MonitoringContext>;
declare function use_old_InterfaceDeclaration_MonitoringContext(
    use: TypeOnly<old.MonitoringContext>);
use_old_InterfaceDeclaration_MonitoringContext(
    get_current_InterfaceDeclaration_MonitoringContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MultiSinkLogger": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MultiSinkLogger():
    TypeOnly<old.MultiSinkLogger>;
declare function use_current_ClassDeclaration_MultiSinkLogger(
    use: TypeOnly<current.MultiSinkLogger>);
use_current_ClassDeclaration_MultiSinkLogger(
    get_old_ClassDeclaration_MultiSinkLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MultiSinkLogger": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MultiSinkLogger():
    TypeOnly<current.MultiSinkLogger>;
declare function use_old_ClassDeclaration_MultiSinkLogger(
    use: TypeOnly<old.MultiSinkLogger>);
use_old_ClassDeclaration_MultiSinkLogger(
    get_current_ClassDeclaration_MultiSinkLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_NORMALIZED_ERROR_TYPE": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_NORMALIZED_ERROR_TYPE():
    TypeOnly<typeof old.NORMALIZED_ERROR_TYPE>;
declare function use_current_VariableDeclaration_NORMALIZED_ERROR_TYPE(
    use: TypeOnly<typeof current.NORMALIZED_ERROR_TYPE>);
use_current_VariableDeclaration_NORMALIZED_ERROR_TYPE(
    get_old_VariableDeclaration_NORMALIZED_ERROR_TYPE());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_NORMALIZED_ERROR_TYPE": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_NORMALIZED_ERROR_TYPE():
    TypeOnly<typeof current.NORMALIZED_ERROR_TYPE>;
declare function use_old_VariableDeclaration_NORMALIZED_ERROR_TYPE(
    use: TypeOnly<typeof old.NORMALIZED_ERROR_TYPE>);
use_old_VariableDeclaration_NORMALIZED_ERROR_TYPE(
    get_current_VariableDeclaration_NORMALIZED_ERROR_TYPE());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_normalizeError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_normalizeError():
    TypeOnly<typeof old.normalizeError>;
declare function use_current_FunctionDeclaration_normalizeError(
    use: TypeOnly<typeof current.normalizeError>);
use_current_FunctionDeclaration_normalizeError(
    get_old_FunctionDeclaration_normalizeError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_normalizeError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_normalizeError():
    TypeOnly<typeof current.normalizeError>;
declare function use_old_FunctionDeclaration_normalizeError(
    use: TypeOnly<typeof old.normalizeError>);
use_old_FunctionDeclaration_normalizeError(
    get_current_FunctionDeclaration_normalizeError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PerformanceEvent": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_PerformanceEvent():
    TypeOnly<old.PerformanceEvent>;
declare function use_current_ClassDeclaration_PerformanceEvent(
    use: TypeOnly<current.PerformanceEvent>);
use_current_ClassDeclaration_PerformanceEvent(
    get_old_ClassDeclaration_PerformanceEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PerformanceEvent": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_PerformanceEvent():
    TypeOnly<current.PerformanceEvent>;
declare function use_old_ClassDeclaration_PerformanceEvent(
    use: TypeOnly<old.PerformanceEvent>);
use_old_ClassDeclaration_PerformanceEvent(
    get_current_ClassDeclaration_PerformanceEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_raiseConnectedEvent": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_raiseConnectedEvent():
    TypeOnly<typeof old.raiseConnectedEvent>;
declare function use_current_FunctionDeclaration_raiseConnectedEvent(
    use: TypeOnly<typeof current.raiseConnectedEvent>);
use_current_FunctionDeclaration_raiseConnectedEvent(
    get_old_FunctionDeclaration_raiseConnectedEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_raiseConnectedEvent": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_raiseConnectedEvent():
    TypeOnly<typeof current.raiseConnectedEvent>;
declare function use_old_FunctionDeclaration_raiseConnectedEvent(
    use: TypeOnly<typeof old.raiseConnectedEvent>);
use_old_FunctionDeclaration_raiseConnectedEvent(
    get_current_FunctionDeclaration_raiseConnectedEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_safeRaiseEvent": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_safeRaiseEvent():
    TypeOnly<typeof old.safeRaiseEvent>;
declare function use_current_FunctionDeclaration_safeRaiseEvent(
    use: TypeOnly<typeof current.safeRaiseEvent>);
use_current_FunctionDeclaration_safeRaiseEvent(
    get_old_FunctionDeclaration_safeRaiseEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_safeRaiseEvent": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_safeRaiseEvent():
    TypeOnly<typeof current.safeRaiseEvent>;
declare function use_old_FunctionDeclaration_safeRaiseEvent(
    use: TypeOnly<typeof old.safeRaiseEvent>);
use_old_FunctionDeclaration_safeRaiseEvent(
    get_current_FunctionDeclaration_safeRaiseEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SampledTelemetryHelper": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SampledTelemetryHelper():
    TypeOnly<old.SampledTelemetryHelper>;
declare function use_current_ClassDeclaration_SampledTelemetryHelper(
    use: TypeOnly<current.SampledTelemetryHelper>);
use_current_ClassDeclaration_SampledTelemetryHelper(
    get_old_ClassDeclaration_SampledTelemetryHelper());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SampledTelemetryHelper": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SampledTelemetryHelper():
    TypeOnly<current.SampledTelemetryHelper>;
declare function use_old_ClassDeclaration_SampledTelemetryHelper(
    use: TypeOnly<old.SampledTelemetryHelper>);
use_old_ClassDeclaration_SampledTelemetryHelper(
    get_current_ClassDeclaration_SampledTelemetryHelper());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_sessionStorageConfigProvider": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_sessionStorageConfigProvider():
    TypeOnly<typeof old.sessionStorageConfigProvider>;
declare function use_current_VariableDeclaration_sessionStorageConfigProvider(
    use: TypeOnly<typeof current.sessionStorageConfigProvider>);
use_current_VariableDeclaration_sessionStorageConfigProvider(
    get_old_VariableDeclaration_sessionStorageConfigProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_sessionStorageConfigProvider": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_sessionStorageConfigProvider():
    TypeOnly<typeof current.sessionStorageConfigProvider>;
declare function use_old_VariableDeclaration_sessionStorageConfigProvider(
    use: TypeOnly<typeof old.sessionStorageConfigProvider>);
use_old_VariableDeclaration_sessionStorageConfigProvider(
    get_current_VariableDeclaration_sessionStorageConfigProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TaggedLoggerAdapter": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TaggedLoggerAdapter():
    TypeOnly<old.TaggedLoggerAdapter>;
declare function use_current_ClassDeclaration_TaggedLoggerAdapter(
    use: TypeOnly<current.TaggedLoggerAdapter>);
use_current_ClassDeclaration_TaggedLoggerAdapter(
    get_old_ClassDeclaration_TaggedLoggerAdapter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TaggedLoggerAdapter": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TaggedLoggerAdapter():
    TypeOnly<current.TaggedLoggerAdapter>;
declare function use_old_ClassDeclaration_TaggedLoggerAdapter(
    use: TypeOnly<old.TaggedLoggerAdapter>);
use_old_ClassDeclaration_TaggedLoggerAdapter(
    get_current_ClassDeclaration_TaggedLoggerAdapter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_TelemetryDataTag": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_TelemetryDataTag():
    TypeOnly<old.TelemetryDataTag>;
declare function use_current_EnumDeclaration_TelemetryDataTag(
    use: TypeOnly<current.TelemetryDataTag>);
use_current_EnumDeclaration_TelemetryDataTag(
    get_old_EnumDeclaration_TelemetryDataTag());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_TelemetryDataTag": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_TelemetryDataTag():
    TypeOnly<current.TelemetryDataTag>;
declare function use_old_EnumDeclaration_TelemetryDataTag(
    use: TypeOnly<old.TelemetryDataTag>);
use_old_EnumDeclaration_TelemetryDataTag(
    get_current_EnumDeclaration_TelemetryDataTag());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventPropertyTypes": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TelemetryEventPropertyTypes():
    TypeOnly<old.TelemetryEventPropertyTypes>;
declare function use_current_TypeAliasDeclaration_TelemetryEventPropertyTypes(
    use: TypeOnly<current.TelemetryEventPropertyTypes>);
use_current_TypeAliasDeclaration_TelemetryEventPropertyTypes(
    get_old_TypeAliasDeclaration_TelemetryEventPropertyTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TelemetryEventPropertyTypes": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TelemetryEventPropertyTypes():
    TypeOnly<current.TelemetryEventPropertyTypes>;
declare function use_old_TypeAliasDeclaration_TelemetryEventPropertyTypes(
    use: TypeOnly<old.TelemetryEventPropertyTypes>);
use_old_TypeAliasDeclaration_TelemetryEventPropertyTypes(
    get_current_TypeAliasDeclaration_TelemetryEventPropertyTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TelemetryLogger": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TelemetryLogger():
    TypeOnly<old.TelemetryLogger>;
declare function use_current_ClassDeclaration_TelemetryLogger(
    use: TypeOnly<current.TelemetryLogger>);
use_current_ClassDeclaration_TelemetryLogger(
    get_old_ClassDeclaration_TelemetryLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TelemetryLogger": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TelemetryLogger():
    TypeOnly<current.TelemetryLogger>;
declare function use_old_ClassDeclaration_TelemetryLogger(
    use: TypeOnly<old.TelemetryLogger>);
use_old_ClassDeclaration_TelemetryLogger(
    get_current_ClassDeclaration_TelemetryLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TelemetryUTLogger": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TelemetryUTLogger():
    TypeOnly<old.TelemetryUTLogger>;
declare function use_current_ClassDeclaration_TelemetryUTLogger(
    use: TypeOnly<current.TelemetryUTLogger>);
use_current_ClassDeclaration_TelemetryUTLogger(
    get_old_ClassDeclaration_TelemetryUTLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TelemetryUTLogger": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TelemetryUTLogger():
    TypeOnly<current.TelemetryUTLogger>;
declare function use_old_ClassDeclaration_TelemetryUTLogger(
    use: TypeOnly<old.TelemetryUTLogger>);
use_old_ClassDeclaration_TelemetryUTLogger(
    get_current_ClassDeclaration_TelemetryUTLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ThresholdCounter": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ThresholdCounter():
    TypeOnly<old.ThresholdCounter>;
declare function use_current_ClassDeclaration_ThresholdCounter(
    use: TypeOnly<current.ThresholdCounter>);
use_current_ClassDeclaration_ThresholdCounter(
    get_old_ClassDeclaration_ThresholdCounter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ThresholdCounter": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ThresholdCounter():
    TypeOnly<current.ThresholdCounter>;
declare function use_old_ClassDeclaration_ThresholdCounter(
    use: TypeOnly<old.ThresholdCounter>);
use_old_ClassDeclaration_ThresholdCounter(
    get_current_ClassDeclaration_ThresholdCounter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_wrapError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_wrapError():
    TypeOnly<typeof old.wrapError>;
declare function use_current_FunctionDeclaration_wrapError(
    use: TypeOnly<typeof current.wrapError>);
use_current_FunctionDeclaration_wrapError(
    get_old_FunctionDeclaration_wrapError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_wrapError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_wrapError():
    TypeOnly<typeof current.wrapError>;
declare function use_old_FunctionDeclaration_wrapError(
    use: TypeOnly<typeof old.wrapError>);
use_old_FunctionDeclaration_wrapError(
    get_current_FunctionDeclaration_wrapError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_wrapErrorAndLog": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_wrapErrorAndLog():
    TypeOnly<typeof old.wrapErrorAndLog>;
declare function use_current_FunctionDeclaration_wrapErrorAndLog(
    use: TypeOnly<typeof current.wrapErrorAndLog>);
use_current_FunctionDeclaration_wrapErrorAndLog(
    get_old_FunctionDeclaration_wrapErrorAndLog());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_wrapErrorAndLog": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_wrapErrorAndLog():
    TypeOnly<typeof current.wrapErrorAndLog>;
declare function use_old_FunctionDeclaration_wrapErrorAndLog(
    use: TypeOnly<typeof old.wrapErrorAndLog>);
use_old_FunctionDeclaration_wrapErrorAndLog(
    get_current_FunctionDeclaration_wrapErrorAndLog());
