/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "@fluidframework/odsp-doclib-utils-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_authRequestWithRetry": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_authRequestWithRetry():
    TypeOnly<typeof old.authRequestWithRetry>;
declare function use_current_FunctionDeclaration_authRequestWithRetry(
    use: TypeOnly<typeof current.authRequestWithRetry>);
use_current_FunctionDeclaration_authRequestWithRetry(
    get_old_FunctionDeclaration_authRequestWithRetry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_authRequestWithRetry": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_authRequestWithRetry():
    TypeOnly<typeof current.authRequestWithRetry>;
declare function use_old_FunctionDeclaration_authRequestWithRetry(
    use: TypeOnly<typeof old.authRequestWithRetry>);
use_old_FunctionDeclaration_authRequestWithRetry(
    get_current_FunctionDeclaration_authRequestWithRetry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createOdspNetworkError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createOdspNetworkError():
    TypeOnly<typeof old.createOdspNetworkError>;
declare function use_current_FunctionDeclaration_createOdspNetworkError(
    use: TypeOnly<typeof current.createOdspNetworkError>);
use_current_FunctionDeclaration_createOdspNetworkError(
    get_old_FunctionDeclaration_createOdspNetworkError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createOdspNetworkError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createOdspNetworkError():
    TypeOnly<typeof current.createOdspNetworkError>;
declare function use_old_FunctionDeclaration_createOdspNetworkError(
    use: TypeOnly<typeof old.createOdspNetworkError>);
use_old_FunctionDeclaration_createOdspNetworkError(
    get_current_FunctionDeclaration_createOdspNetworkError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_enrichOdspError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_enrichOdspError():
    TypeOnly<typeof old.enrichOdspError>;
declare function use_current_FunctionDeclaration_enrichOdspError(
    use: TypeOnly<typeof current.enrichOdspError>);
use_current_FunctionDeclaration_enrichOdspError(
    get_old_FunctionDeclaration_enrichOdspError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_enrichOdspError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_enrichOdspError():
    TypeOnly<typeof current.enrichOdspError>;
declare function use_old_FunctionDeclaration_enrichOdspError(
    use: TypeOnly<typeof old.enrichOdspError>);
use_old_FunctionDeclaration_enrichOdspError(
    get_current_FunctionDeclaration_enrichOdspError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_fetchIncorrectResponse": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_fetchIncorrectResponse():
    TypeOnly<typeof old.fetchIncorrectResponse>;
declare function use_current_VariableDeclaration_fetchIncorrectResponse(
    use: TypeOnly<typeof current.fetchIncorrectResponse>);
use_current_VariableDeclaration_fetchIncorrectResponse(
    get_old_VariableDeclaration_fetchIncorrectResponse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_fetchIncorrectResponse": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_fetchIncorrectResponse():
    TypeOnly<typeof current.fetchIncorrectResponse>;
declare function use_old_VariableDeclaration_fetchIncorrectResponse(
    use: TypeOnly<typeof old.fetchIncorrectResponse>);
use_old_VariableDeclaration_fetchIncorrectResponse(
    get_current_VariableDeclaration_fetchIncorrectResponse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_fetchTokens": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_fetchTokens():
    TypeOnly<typeof old.fetchTokens>;
declare function use_current_FunctionDeclaration_fetchTokens(
    use: TypeOnly<typeof current.fetchTokens>);
use_current_FunctionDeclaration_fetchTokens(
    get_old_FunctionDeclaration_fetchTokens());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_fetchTokens": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_fetchTokens():
    TypeOnly<typeof current.fetchTokens>;
declare function use_old_FunctionDeclaration_fetchTokens(
    use: TypeOnly<typeof old.fetchTokens>);
use_old_FunctionDeclaration_fetchTokens(
    get_current_FunctionDeclaration_fetchTokens());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getAadTenant": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getAadTenant():
    TypeOnly<typeof old.getAadTenant>;
declare function use_current_FunctionDeclaration_getAadTenant(
    use: TypeOnly<typeof current.getAadTenant>);
use_current_FunctionDeclaration_getAadTenant(
    get_old_FunctionDeclaration_getAadTenant());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getAadTenant": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getAadTenant():
    TypeOnly<typeof current.getAadTenant>;
declare function use_old_FunctionDeclaration_getAadTenant(
    use: TypeOnly<typeof old.getAadTenant>);
use_old_FunctionDeclaration_getAadTenant(
    get_current_FunctionDeclaration_getAadTenant());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getAadUrl": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getAadUrl():
    TypeOnly<typeof old.getAadUrl>;
declare function use_current_FunctionDeclaration_getAadUrl(
    use: TypeOnly<typeof current.getAadUrl>);
use_current_FunctionDeclaration_getAadUrl(
    get_old_FunctionDeclaration_getAadUrl());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getAadUrl": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getAadUrl():
    TypeOnly<typeof current.getAadUrl>;
declare function use_old_FunctionDeclaration_getAadUrl(
    use: TypeOnly<typeof old.getAadUrl>);
use_old_FunctionDeclaration_getAadUrl(
    get_current_FunctionDeclaration_getAadUrl());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getAsync": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getAsync():
    TypeOnly<typeof old.getAsync>;
declare function use_current_FunctionDeclaration_getAsync(
    use: TypeOnly<typeof current.getAsync>);
use_current_FunctionDeclaration_getAsync(
    get_old_FunctionDeclaration_getAsync());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getAsync": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getAsync():
    TypeOnly<typeof current.getAsync>;
declare function use_old_FunctionDeclaration_getAsync(
    use: TypeOnly<typeof old.getAsync>);
use_old_FunctionDeclaration_getAsync(
    get_current_FunctionDeclaration_getAsync());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getChildrenByDriveItem": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getChildrenByDriveItem():
    TypeOnly<typeof old.getChildrenByDriveItem>;
declare function use_current_FunctionDeclaration_getChildrenByDriveItem(
    use: TypeOnly<typeof current.getChildrenByDriveItem>);
use_current_FunctionDeclaration_getChildrenByDriveItem(
    get_old_FunctionDeclaration_getChildrenByDriveItem());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getChildrenByDriveItem": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getChildrenByDriveItem():
    TypeOnly<typeof current.getChildrenByDriveItem>;
declare function use_old_FunctionDeclaration_getChildrenByDriveItem(
    use: TypeOnly<typeof old.getChildrenByDriveItem>);
use_old_FunctionDeclaration_getChildrenByDriveItem(
    get_current_FunctionDeclaration_getChildrenByDriveItem());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getDriveId": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getDriveId():
    TypeOnly<typeof old.getDriveId>;
declare function use_current_FunctionDeclaration_getDriveId(
    use: TypeOnly<typeof current.getDriveId>);
use_current_FunctionDeclaration_getDriveId(
    get_old_FunctionDeclaration_getDriveId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getDriveId": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getDriveId():
    TypeOnly<typeof current.getDriveId>;
declare function use_old_FunctionDeclaration_getDriveId(
    use: TypeOnly<typeof old.getDriveId>);
use_old_FunctionDeclaration_getDriveId(
    get_current_FunctionDeclaration_getDriveId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getDriveItemByRootFileName": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getDriveItemByRootFileName():
    TypeOnly<typeof old.getDriveItemByRootFileName>;
declare function use_current_FunctionDeclaration_getDriveItemByRootFileName(
    use: TypeOnly<typeof current.getDriveItemByRootFileName>);
use_current_FunctionDeclaration_getDriveItemByRootFileName(
    get_old_FunctionDeclaration_getDriveItemByRootFileName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getDriveItemByRootFileName": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getDriveItemByRootFileName():
    TypeOnly<typeof current.getDriveItemByRootFileName>;
declare function use_old_FunctionDeclaration_getDriveItemByRootFileName(
    use: TypeOnly<typeof old.getDriveItemByRootFileName>);
use_old_FunctionDeclaration_getDriveItemByRootFileName(
    get_current_FunctionDeclaration_getDriveItemByRootFileName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getDriveItemByServerRelativePath": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getDriveItemByServerRelativePath():
    TypeOnly<typeof old.getDriveItemByServerRelativePath>;
declare function use_current_FunctionDeclaration_getDriveItemByServerRelativePath(
    use: TypeOnly<typeof current.getDriveItemByServerRelativePath>);
use_current_FunctionDeclaration_getDriveItemByServerRelativePath(
    get_old_FunctionDeclaration_getDriveItemByServerRelativePath());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getDriveItemByServerRelativePath": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getDriveItemByServerRelativePath():
    TypeOnly<typeof current.getDriveItemByServerRelativePath>;
declare function use_old_FunctionDeclaration_getDriveItemByServerRelativePath(
    use: TypeOnly<typeof old.getDriveItemByServerRelativePath>);
use_old_FunctionDeclaration_getDriveItemByServerRelativePath(
    get_current_FunctionDeclaration_getDriveItemByServerRelativePath());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getDriveItemFromDriveAndItem": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getDriveItemFromDriveAndItem():
    TypeOnly<typeof old.getDriveItemFromDriveAndItem>;
declare function use_current_FunctionDeclaration_getDriveItemFromDriveAndItem(
    use: TypeOnly<typeof current.getDriveItemFromDriveAndItem>);
use_current_FunctionDeclaration_getDriveItemFromDriveAndItem(
    get_old_FunctionDeclaration_getDriveItemFromDriveAndItem());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getDriveItemFromDriveAndItem": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getDriveItemFromDriveAndItem():
    TypeOnly<typeof current.getDriveItemFromDriveAndItem>;
declare function use_old_FunctionDeclaration_getDriveItemFromDriveAndItem(
    use: TypeOnly<typeof old.getDriveItemFromDriveAndItem>);
use_old_FunctionDeclaration_getDriveItemFromDriveAndItem(
    get_current_FunctionDeclaration_getDriveItemFromDriveAndItem());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getFetchTokenUrl": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getFetchTokenUrl():
    TypeOnly<typeof old.getFetchTokenUrl>;
declare function use_current_FunctionDeclaration_getFetchTokenUrl(
    use: TypeOnly<typeof current.getFetchTokenUrl>);
use_current_FunctionDeclaration_getFetchTokenUrl(
    get_old_FunctionDeclaration_getFetchTokenUrl());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getFetchTokenUrl": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getFetchTokenUrl():
    TypeOnly<typeof current.getFetchTokenUrl>;
declare function use_old_FunctionDeclaration_getFetchTokenUrl(
    use: TypeOnly<typeof old.getFetchTokenUrl>);
use_old_FunctionDeclaration_getFetchTokenUrl(
    get_current_FunctionDeclaration_getFetchTokenUrl());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getLoginPageUrl": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getLoginPageUrl():
    TypeOnly<typeof old.getLoginPageUrl>;
declare function use_current_FunctionDeclaration_getLoginPageUrl(
    use: TypeOnly<typeof current.getLoginPageUrl>);
use_current_FunctionDeclaration_getLoginPageUrl(
    get_old_FunctionDeclaration_getLoginPageUrl());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getLoginPageUrl": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getLoginPageUrl():
    TypeOnly<typeof current.getLoginPageUrl>;
declare function use_old_FunctionDeclaration_getLoginPageUrl(
    use: TypeOnly<typeof old.getLoginPageUrl>);
use_old_FunctionDeclaration_getLoginPageUrl(
    get_current_FunctionDeclaration_getLoginPageUrl());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getOdspRefreshTokenFn": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getOdspRefreshTokenFn():
    TypeOnly<typeof old.getOdspRefreshTokenFn>;
declare function use_current_VariableDeclaration_getOdspRefreshTokenFn(
    use: TypeOnly<typeof current.getOdspRefreshTokenFn>);
use_current_VariableDeclaration_getOdspRefreshTokenFn(
    get_old_VariableDeclaration_getOdspRefreshTokenFn());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getOdspRefreshTokenFn": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getOdspRefreshTokenFn():
    TypeOnly<typeof current.getOdspRefreshTokenFn>;
declare function use_old_VariableDeclaration_getOdspRefreshTokenFn(
    use: TypeOnly<typeof old.getOdspRefreshTokenFn>);
use_old_VariableDeclaration_getOdspRefreshTokenFn(
    get_current_VariableDeclaration_getOdspRefreshTokenFn());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getOdspScope": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getOdspScope():
    TypeOnly<typeof old.getOdspScope>;
declare function use_current_VariableDeclaration_getOdspScope(
    use: TypeOnly<typeof current.getOdspScope>);
use_current_VariableDeclaration_getOdspScope(
    get_old_VariableDeclaration_getOdspScope());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getOdspScope": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getOdspScope():
    TypeOnly<typeof current.getOdspScope>;
declare function use_old_VariableDeclaration_getOdspScope(
    use: TypeOnly<typeof old.getOdspScope>);
use_old_VariableDeclaration_getOdspScope(
    get_current_VariableDeclaration_getOdspScope());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getPushRefreshTokenFn": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getPushRefreshTokenFn():
    TypeOnly<typeof old.getPushRefreshTokenFn>;
declare function use_current_VariableDeclaration_getPushRefreshTokenFn(
    use: TypeOnly<typeof current.getPushRefreshTokenFn>);
use_current_VariableDeclaration_getPushRefreshTokenFn(
    get_old_VariableDeclaration_getPushRefreshTokenFn());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getPushRefreshTokenFn": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getPushRefreshTokenFn():
    TypeOnly<typeof current.getPushRefreshTokenFn>;
declare function use_old_VariableDeclaration_getPushRefreshTokenFn(
    use: TypeOnly<typeof old.getPushRefreshTokenFn>);
use_old_VariableDeclaration_getPushRefreshTokenFn(
    get_current_VariableDeclaration_getPushRefreshTokenFn());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getRefreshTokenFn": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getRefreshTokenFn():
    TypeOnly<typeof old.getRefreshTokenFn>;
declare function use_current_VariableDeclaration_getRefreshTokenFn(
    use: TypeOnly<typeof current.getRefreshTokenFn>);
use_current_VariableDeclaration_getRefreshTokenFn(
    get_old_VariableDeclaration_getRefreshTokenFn());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getRefreshTokenFn": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getRefreshTokenFn():
    TypeOnly<typeof current.getRefreshTokenFn>;
declare function use_old_VariableDeclaration_getRefreshTokenFn(
    use: TypeOnly<typeof old.getRefreshTokenFn>);
use_old_VariableDeclaration_getRefreshTokenFn(
    get_current_VariableDeclaration_getRefreshTokenFn());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getServer": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getServer():
    TypeOnly<typeof old.getServer>;
declare function use_current_FunctionDeclaration_getServer(
    use: TypeOnly<typeof current.getServer>);
use_current_FunctionDeclaration_getServer(
    get_old_FunctionDeclaration_getServer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getServer": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getServer():
    TypeOnly<typeof current.getServer>;
declare function use_old_FunctionDeclaration_getServer(
    use: TypeOnly<typeof old.getServer>);
use_old_FunctionDeclaration_getServer(
    get_current_FunctionDeclaration_getServer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getSiteUrl": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getSiteUrl():
    TypeOnly<typeof old.getSiteUrl>;
declare function use_current_FunctionDeclaration_getSiteUrl(
    use: TypeOnly<typeof current.getSiteUrl>);
use_current_FunctionDeclaration_getSiteUrl(
    get_old_FunctionDeclaration_getSiteUrl());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getSiteUrl": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getSiteUrl():
    TypeOnly<typeof current.getSiteUrl>;
declare function use_old_FunctionDeclaration_getSiteUrl(
    use: TypeOnly<typeof old.getSiteUrl>);
use_old_FunctionDeclaration_getSiteUrl(
    get_current_FunctionDeclaration_getSiteUrl());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse():
    TypeOnly<typeof old.getSPOAndGraphRequestIdsFromResponse>;
declare function use_current_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse(
    use: TypeOnly<typeof current.getSPOAndGraphRequestIdsFromResponse>);
use_current_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse(
    get_old_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse():
    TypeOnly<typeof current.getSPOAndGraphRequestIdsFromResponse>;
declare function use_old_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse(
    use: TypeOnly<typeof old.getSPOAndGraphRequestIdsFromResponse>);
use_old_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse(
    get_current_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IClientConfig():
    TypeOnly<old.IClientConfig>;
declare function use_current_InterfaceDeclaration_IClientConfig(
    use: TypeOnly<current.IClientConfig>);
use_current_InterfaceDeclaration_IClientConfig(
    get_old_InterfaceDeclaration_IClientConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IClientConfig():
    TypeOnly<current.IClientConfig>;
declare function use_old_InterfaceDeclaration_IClientConfig(
    use: TypeOnly<old.IClientConfig>);
use_old_InterfaceDeclaration_IClientConfig(
    get_current_InterfaceDeclaration_IClientConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedInterfaceDeclaration_IFacetCodes": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedInterfaceDeclaration_IFacetCodes": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOdspAuthRequestInfo": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOdspAuthRequestInfo():
    TypeOnly<old.IOdspAuthRequestInfo>;
declare function use_current_InterfaceDeclaration_IOdspAuthRequestInfo(
    use: TypeOnly<current.IOdspAuthRequestInfo>);
use_current_InterfaceDeclaration_IOdspAuthRequestInfo(
    get_old_InterfaceDeclaration_IOdspAuthRequestInfo());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOdspAuthRequestInfo": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOdspAuthRequestInfo():
    TypeOnly<current.IOdspAuthRequestInfo>;
declare function use_old_InterfaceDeclaration_IOdspAuthRequestInfo(
    use: TypeOnly<old.IOdspAuthRequestInfo>);
use_old_InterfaceDeclaration_IOdspAuthRequestInfo(
    get_current_InterfaceDeclaration_IOdspAuthRequestInfo());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOdspDriveItem": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOdspDriveItem():
    TypeOnly<old.IOdspDriveItem>;
declare function use_current_InterfaceDeclaration_IOdspDriveItem(
    use: TypeOnly<current.IOdspDriveItem>);
use_current_InterfaceDeclaration_IOdspDriveItem(
    get_old_InterfaceDeclaration_IOdspDriveItem());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOdspDriveItem": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOdspDriveItem():
    TypeOnly<current.IOdspDriveItem>;
declare function use_old_InterfaceDeclaration_IOdspDriveItem(
    use: TypeOnly<old.IOdspDriveItem>);
use_old_InterfaceDeclaration_IOdspDriveItem(
    get_current_InterfaceDeclaration_IOdspDriveItem());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOdspTokens": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOdspTokens():
    TypeOnly<old.IOdspTokens>;
declare function use_current_InterfaceDeclaration_IOdspTokens(
    use: TypeOnly<current.IOdspTokens>);
use_current_InterfaceDeclaration_IOdspTokens(
    get_old_InterfaceDeclaration_IOdspTokens());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOdspTokens": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOdspTokens():
    TypeOnly<current.IOdspTokens>;
declare function use_old_InterfaceDeclaration_IOdspTokens(
    use: TypeOnly<old.IOdspTokens>);
use_old_InterfaceDeclaration_IOdspTokens(
    get_current_InterfaceDeclaration_IOdspTokens());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isOdspHostname": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isOdspHostname():
    TypeOnly<typeof old.isOdspHostname>;
declare function use_current_FunctionDeclaration_isOdspHostname(
    use: TypeOnly<typeof current.isOdspHostname>);
use_current_FunctionDeclaration_isOdspHostname(
    get_old_FunctionDeclaration_isOdspHostname());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isOdspHostname": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isOdspHostname():
    TypeOnly<typeof current.isOdspHostname>;
declare function use_old_FunctionDeclaration_isOdspHostname(
    use: TypeOnly<typeof old.isOdspHostname>);
use_old_FunctionDeclaration_isOdspHostname(
    get_current_FunctionDeclaration_isOdspHostname());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isPushChannelHostname": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isPushChannelHostname():
    TypeOnly<typeof old.isPushChannelHostname>;
declare function use_current_FunctionDeclaration_isPushChannelHostname(
    use: TypeOnly<typeof current.isPushChannelHostname>);
use_current_FunctionDeclaration_isPushChannelHostname(
    get_old_FunctionDeclaration_isPushChannelHostname());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isPushChannelHostname": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isPushChannelHostname():
    TypeOnly<typeof current.isPushChannelHostname>;
declare function use_old_FunctionDeclaration_isPushChannelHostname(
    use: TypeOnly<typeof old.isPushChannelHostname>);
use_old_FunctionDeclaration_isPushChannelHostname(
    get_current_FunctionDeclaration_isPushChannelHostname());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_OdspErrorResponse": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_OdspErrorResponse():
    TypeOnly<old.OdspErrorResponse>;
declare function use_current_InterfaceDeclaration_OdspErrorResponse(
    use: TypeOnly<current.OdspErrorResponse>);
use_current_InterfaceDeclaration_OdspErrorResponse(
    get_old_InterfaceDeclaration_OdspErrorResponse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_OdspErrorResponse": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_OdspErrorResponse():
    TypeOnly<current.OdspErrorResponse>;
declare function use_old_InterfaceDeclaration_OdspErrorResponse(
    use: TypeOnly<old.OdspErrorResponse>);
use_old_InterfaceDeclaration_OdspErrorResponse(
    get_current_InterfaceDeclaration_OdspErrorResponse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_OdspErrorResponseInnerError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_OdspErrorResponseInnerError():
    TypeOnly<old.OdspErrorResponseInnerError>;
declare function use_current_InterfaceDeclaration_OdspErrorResponseInnerError(
    use: TypeOnly<current.OdspErrorResponseInnerError>);
use_current_InterfaceDeclaration_OdspErrorResponseInnerError(
    get_old_InterfaceDeclaration_OdspErrorResponseInnerError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_OdspErrorResponseInnerError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_OdspErrorResponseInnerError():
    TypeOnly<current.OdspErrorResponseInnerError>;
declare function use_old_InterfaceDeclaration_OdspErrorResponseInnerError(
    use: TypeOnly<old.OdspErrorResponseInnerError>);
use_old_InterfaceDeclaration_OdspErrorResponseInnerError(
    get_current_InterfaceDeclaration_OdspErrorResponseInnerError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_OdspServiceReadOnlyErrorCode": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_OdspServiceReadOnlyErrorCode():
    TypeOnly<typeof old.OdspServiceReadOnlyErrorCode>;
declare function use_current_VariableDeclaration_OdspServiceReadOnlyErrorCode(
    use: TypeOnly<typeof current.OdspServiceReadOnlyErrorCode>);
use_current_VariableDeclaration_OdspServiceReadOnlyErrorCode(
    get_old_VariableDeclaration_OdspServiceReadOnlyErrorCode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_OdspServiceReadOnlyErrorCode": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_OdspServiceReadOnlyErrorCode():
    TypeOnly<typeof current.OdspServiceReadOnlyErrorCode>;
declare function use_old_VariableDeclaration_OdspServiceReadOnlyErrorCode(
    use: TypeOnly<typeof old.OdspServiceReadOnlyErrorCode>);
use_old_VariableDeclaration_OdspServiceReadOnlyErrorCode(
    get_current_VariableDeclaration_OdspServiceReadOnlyErrorCode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_parseFacetCodes": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_parseFacetCodes():
    TypeOnly<typeof old.parseFacetCodes>;
declare function use_current_FunctionDeclaration_parseFacetCodes(
    use: TypeOnly<typeof current.parseFacetCodes>);
use_current_FunctionDeclaration_parseFacetCodes(
    get_old_FunctionDeclaration_parseFacetCodes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_parseFacetCodes": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_parseFacetCodes():
    TypeOnly<typeof current.parseFacetCodes>;
declare function use_old_FunctionDeclaration_parseFacetCodes(
    use: TypeOnly<typeof old.parseFacetCodes>);
use_old_FunctionDeclaration_parseFacetCodes(
    get_current_FunctionDeclaration_parseFacetCodes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_postAsync": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_postAsync():
    TypeOnly<typeof old.postAsync>;
declare function use_current_FunctionDeclaration_postAsync(
    use: TypeOnly<typeof current.postAsync>);
use_current_FunctionDeclaration_postAsync(
    get_old_FunctionDeclaration_postAsync());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_postAsync": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_postAsync():
    TypeOnly<typeof current.postAsync>;
declare function use_old_FunctionDeclaration_postAsync(
    use: TypeOnly<typeof old.postAsync>);
use_old_FunctionDeclaration_postAsync(
    get_current_FunctionDeclaration_postAsync());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_pushScope": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_pushScope():
    TypeOnly<typeof old.pushScope>;
declare function use_current_VariableDeclaration_pushScope(
    use: TypeOnly<typeof current.pushScope>);
use_current_VariableDeclaration_pushScope(
    get_old_VariableDeclaration_pushScope());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_pushScope": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_pushScope():
    TypeOnly<typeof current.pushScope>;
declare function use_old_VariableDeclaration_pushScope(
    use: TypeOnly<typeof old.pushScope>);
use_old_VariableDeclaration_pushScope(
    get_current_VariableDeclaration_pushScope());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_putAsync": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_putAsync():
    TypeOnly<typeof old.putAsync>;
declare function use_current_FunctionDeclaration_putAsync(
    use: TypeOnly<typeof current.putAsync>);
use_current_FunctionDeclaration_putAsync(
    get_old_FunctionDeclaration_putAsync());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_putAsync": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_putAsync():
    TypeOnly<typeof current.putAsync>;
declare function use_old_FunctionDeclaration_putAsync(
    use: TypeOnly<typeof old.putAsync>);
use_old_FunctionDeclaration_putAsync(
    get_current_FunctionDeclaration_putAsync());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_refreshTokens": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_refreshTokens():
    TypeOnly<typeof old.refreshTokens>;
declare function use_current_FunctionDeclaration_refreshTokens(
    use: TypeOnly<typeof current.refreshTokens>);
use_current_FunctionDeclaration_refreshTokens(
    get_old_FunctionDeclaration_refreshTokens());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_refreshTokens": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_refreshTokens():
    TypeOnly<typeof current.refreshTokens>;
declare function use_old_FunctionDeclaration_refreshTokens(
    use: TypeOnly<typeof old.refreshTokens>);
use_old_FunctionDeclaration_refreshTokens(
    get_current_FunctionDeclaration_refreshTokens());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_throwOdspNetworkError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_throwOdspNetworkError():
    TypeOnly<typeof old.throwOdspNetworkError>;
declare function use_current_FunctionDeclaration_throwOdspNetworkError(
    use: TypeOnly<typeof current.throwOdspNetworkError>);
use_current_FunctionDeclaration_throwOdspNetworkError(
    get_old_FunctionDeclaration_throwOdspNetworkError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_throwOdspNetworkError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_throwOdspNetworkError():
    TypeOnly<typeof current.throwOdspNetworkError>;
declare function use_old_FunctionDeclaration_throwOdspNetworkError(
    use: TypeOnly<typeof old.throwOdspNetworkError>);
use_old_FunctionDeclaration_throwOdspNetworkError(
    get_current_FunctionDeclaration_throwOdspNetworkError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TokenRequestCredentials": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TokenRequestCredentials():
    TypeOnly<old.TokenRequestCredentials>;
declare function use_current_TypeAliasDeclaration_TokenRequestCredentials(
    use: TypeOnly<current.TokenRequestCredentials>);
use_current_TypeAliasDeclaration_TokenRequestCredentials(
    get_old_TypeAliasDeclaration_TokenRequestCredentials());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TokenRequestCredentials": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TokenRequestCredentials():
    TypeOnly<current.TokenRequestCredentials>;
declare function use_old_TypeAliasDeclaration_TokenRequestCredentials(
    use: TypeOnly<old.TokenRequestCredentials>);
use_old_TypeAliasDeclaration_TokenRequestCredentials(
    get_current_TypeAliasDeclaration_TokenRequestCredentials());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_tryParseErrorResponse": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_tryParseErrorResponse():
    TypeOnly<typeof old.tryParseErrorResponse>;
declare function use_current_FunctionDeclaration_tryParseErrorResponse(
    use: TypeOnly<typeof current.tryParseErrorResponse>);
use_current_FunctionDeclaration_tryParseErrorResponse(
    get_old_FunctionDeclaration_tryParseErrorResponse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_tryParseErrorResponse": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_tryParseErrorResponse():
    TypeOnly<typeof current.tryParseErrorResponse>;
declare function use_old_FunctionDeclaration_tryParseErrorResponse(
    use: TypeOnly<typeof old.tryParseErrorResponse>);
use_old_FunctionDeclaration_tryParseErrorResponse(
    get_current_FunctionDeclaration_tryParseErrorResponse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_unauthPostAsync": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_unauthPostAsync():
    TypeOnly<typeof old.unauthPostAsync>;
declare function use_current_FunctionDeclaration_unauthPostAsync(
    use: TypeOnly<typeof current.unauthPostAsync>);
use_current_FunctionDeclaration_unauthPostAsync(
    get_old_FunctionDeclaration_unauthPostAsync());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_unauthPostAsync": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_unauthPostAsync():
    TypeOnly<typeof current.unauthPostAsync>;
declare function use_old_FunctionDeclaration_unauthPostAsync(
    use: TypeOnly<typeof old.unauthPostAsync>);
use_old_FunctionDeclaration_unauthPostAsync(
    get_current_FunctionDeclaration_unauthPostAsync());
