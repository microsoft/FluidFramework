/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/odsp-doclib-utils-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOdspAuthRequestInfo": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IOdspAuthRequestInfo():
    TypeOnly<old.IOdspAuthRequestInfo>;
declare function use_current_InterfaceDeclaration_IOdspAuthRequestInfo(
    use: TypeOnly<current.IOdspAuthRequestInfo>): void;
use_current_InterfaceDeclaration_IOdspAuthRequestInfo(
    get_old_InterfaceDeclaration_IOdspAuthRequestInfo());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOdspAuthRequestInfo": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IOdspAuthRequestInfo():
    TypeOnly<current.IOdspAuthRequestInfo>;
declare function use_old_InterfaceDeclaration_IOdspAuthRequestInfo(
    use: TypeOnly<old.IOdspAuthRequestInfo>): void;
use_old_InterfaceDeclaration_IOdspAuthRequestInfo(
    get_current_InterfaceDeclaration_IOdspAuthRequestInfo());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOdspDriveItem": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IOdspDriveItem():
    TypeOnly<old.IOdspDriveItem>;
declare function use_current_InterfaceDeclaration_IOdspDriveItem(
    use: TypeOnly<current.IOdspDriveItem>): void;
use_current_InterfaceDeclaration_IOdspDriveItem(
    get_old_InterfaceDeclaration_IOdspDriveItem());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOdspDriveItem": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IOdspDriveItem():
    TypeOnly<current.IOdspDriveItem>;
declare function use_old_InterfaceDeclaration_IOdspDriveItem(
    use: TypeOnly<old.IOdspDriveItem>): void;
use_old_InterfaceDeclaration_IOdspDriveItem(
    get_current_InterfaceDeclaration_IOdspDriveItem());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOdspTokens": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IOdspTokens():
    TypeOnly<old.IOdspTokens>;
declare function use_current_InterfaceDeclaration_IOdspTokens(
    use: TypeOnly<current.IOdspTokens>): void;
use_current_InterfaceDeclaration_IOdspTokens(
    get_old_InterfaceDeclaration_IOdspTokens());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOdspTokens": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IOdspTokens():
    TypeOnly<current.IOdspTokens>;
declare function use_old_InterfaceDeclaration_IOdspTokens(
    use: TypeOnly<old.IOdspTokens>): void;
use_old_InterfaceDeclaration_IOdspTokens(
    get_current_InterfaceDeclaration_IOdspTokens());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IPublicClientConfig": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IPublicClientConfig():
    TypeOnly<old.IPublicClientConfig>;
declare function use_current_InterfaceDeclaration_IPublicClientConfig(
    use: TypeOnly<current.IPublicClientConfig>): void;
use_current_InterfaceDeclaration_IPublicClientConfig(
    get_old_InterfaceDeclaration_IPublicClientConfig());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IPublicClientConfig": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IPublicClientConfig():
    TypeOnly<current.IPublicClientConfig>;
declare function use_old_InterfaceDeclaration_IPublicClientConfig(
    use: TypeOnly<old.IPublicClientConfig>): void;
use_old_InterfaceDeclaration_IPublicClientConfig(
    get_current_InterfaceDeclaration_IPublicClientConfig());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_OdspErrorResponse": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_OdspErrorResponse():
    TypeOnly<old.OdspErrorResponse>;
declare function use_current_InterfaceDeclaration_OdspErrorResponse(
    use: TypeOnly<current.OdspErrorResponse>): void;
use_current_InterfaceDeclaration_OdspErrorResponse(
    get_old_InterfaceDeclaration_OdspErrorResponse());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_OdspErrorResponse": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_OdspErrorResponse():
    TypeOnly<current.OdspErrorResponse>;
declare function use_old_InterfaceDeclaration_OdspErrorResponse(
    use: TypeOnly<old.OdspErrorResponse>): void;
use_old_InterfaceDeclaration_OdspErrorResponse(
    get_current_InterfaceDeclaration_OdspErrorResponse());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_OdspErrorResponseInnerError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_OdspErrorResponseInnerError():
    TypeOnly<old.OdspErrorResponseInnerError>;
declare function use_current_InterfaceDeclaration_OdspErrorResponseInnerError(
    use: TypeOnly<current.OdspErrorResponseInnerError>): void;
use_current_InterfaceDeclaration_OdspErrorResponseInnerError(
    get_old_InterfaceDeclaration_OdspErrorResponseInnerError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_OdspErrorResponseInnerError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_OdspErrorResponseInnerError():
    TypeOnly<current.OdspErrorResponseInnerError>;
declare function use_old_InterfaceDeclaration_OdspErrorResponseInnerError(
    use: TypeOnly<old.OdspErrorResponseInnerError>): void;
use_old_InterfaceDeclaration_OdspErrorResponseInnerError(
    get_current_InterfaceDeclaration_OdspErrorResponseInnerError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_OdspRedirectError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_OdspRedirectError():
    TypeOnly<old.OdspRedirectError>;
declare function use_current_ClassDeclaration_OdspRedirectError(
    use: TypeOnly<current.OdspRedirectError>): void;
use_current_ClassDeclaration_OdspRedirectError(
    get_old_ClassDeclaration_OdspRedirectError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_OdspRedirectError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_OdspRedirectError():
    TypeOnly<current.OdspRedirectError>;
declare function use_old_ClassDeclaration_OdspRedirectError(
    use: TypeOnly<old.OdspRedirectError>): void;
use_old_ClassDeclaration_OdspRedirectError(
    get_current_ClassDeclaration_OdspRedirectError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_OdspServiceReadOnlyErrorCode": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_OdspServiceReadOnlyErrorCode():
    TypeOnly<typeof old.OdspServiceReadOnlyErrorCode>;
declare function use_current_VariableDeclaration_OdspServiceReadOnlyErrorCode(
    use: TypeOnly<typeof current.OdspServiceReadOnlyErrorCode>): void;
use_current_VariableDeclaration_OdspServiceReadOnlyErrorCode(
    get_old_VariableDeclaration_OdspServiceReadOnlyErrorCode());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_OdspServiceReadOnlyErrorCode": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_OdspServiceReadOnlyErrorCode():
    TypeOnly<typeof current.OdspServiceReadOnlyErrorCode>;
declare function use_old_VariableDeclaration_OdspServiceReadOnlyErrorCode(
    use: TypeOnly<typeof old.OdspServiceReadOnlyErrorCode>): void;
use_old_VariableDeclaration_OdspServiceReadOnlyErrorCode(
    get_current_VariableDeclaration_OdspServiceReadOnlyErrorCode());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TokenRequestCredentials": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_TokenRequestCredentials():
    TypeOnly<old.TokenRequestCredentials>;
declare function use_current_TypeAliasDeclaration_TokenRequestCredentials(
    use: TypeOnly<current.TokenRequestCredentials>): void;
use_current_TypeAliasDeclaration_TokenRequestCredentials(
    get_old_TypeAliasDeclaration_TokenRequestCredentials());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_TokenRequestCredentials": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_TokenRequestCredentials():
    TypeOnly<current.TokenRequestCredentials>;
declare function use_old_TypeAliasDeclaration_TokenRequestCredentials(
    use: TypeOnly<old.TokenRequestCredentials>): void;
use_old_TypeAliasDeclaration_TokenRequestCredentials(
    get_current_TypeAliasDeclaration_TokenRequestCredentials());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_authRequestWithRetry": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_authRequestWithRetry():
    TypeOnly<typeof old.authRequestWithRetry>;
declare function use_current_FunctionDeclaration_authRequestWithRetry(
    use: TypeOnly<typeof current.authRequestWithRetry>): void;
use_current_FunctionDeclaration_authRequestWithRetry(
    get_old_FunctionDeclaration_authRequestWithRetry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_authRequestWithRetry": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_authRequestWithRetry():
    TypeOnly<typeof current.authRequestWithRetry>;
declare function use_old_FunctionDeclaration_authRequestWithRetry(
    use: TypeOnly<typeof old.authRequestWithRetry>): void;
use_old_FunctionDeclaration_authRequestWithRetry(
    get_current_FunctionDeclaration_authRequestWithRetry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createOdspNetworkError": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createOdspNetworkError():
    TypeOnly<typeof old.createOdspNetworkError>;
declare function use_current_FunctionDeclaration_createOdspNetworkError(
    use: TypeOnly<typeof current.createOdspNetworkError>): void;
use_current_FunctionDeclaration_createOdspNetworkError(
    get_old_FunctionDeclaration_createOdspNetworkError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createOdspNetworkError": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createOdspNetworkError():
    TypeOnly<typeof current.createOdspNetworkError>;
declare function use_old_FunctionDeclaration_createOdspNetworkError(
    use: TypeOnly<typeof old.createOdspNetworkError>): void;
use_old_FunctionDeclaration_createOdspNetworkError(
    get_current_FunctionDeclaration_createOdspNetworkError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_enrichOdspError": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_enrichOdspError():
    TypeOnly<typeof old.enrichOdspError>;
declare function use_current_FunctionDeclaration_enrichOdspError(
    use: TypeOnly<typeof current.enrichOdspError>): void;
use_current_FunctionDeclaration_enrichOdspError(
    get_old_FunctionDeclaration_enrichOdspError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_enrichOdspError": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_enrichOdspError():
    TypeOnly<typeof current.enrichOdspError>;
declare function use_old_FunctionDeclaration_enrichOdspError(
    use: TypeOnly<typeof old.enrichOdspError>): void;
use_old_FunctionDeclaration_enrichOdspError(
    get_current_FunctionDeclaration_enrichOdspError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_fetchIncorrectResponse": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_fetchIncorrectResponse():
    TypeOnly<typeof old.fetchIncorrectResponse>;
declare function use_current_VariableDeclaration_fetchIncorrectResponse(
    use: TypeOnly<typeof current.fetchIncorrectResponse>): void;
use_current_VariableDeclaration_fetchIncorrectResponse(
    get_old_VariableDeclaration_fetchIncorrectResponse());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_fetchIncorrectResponse": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_fetchIncorrectResponse():
    TypeOnly<typeof current.fetchIncorrectResponse>;
declare function use_old_VariableDeclaration_fetchIncorrectResponse(
    use: TypeOnly<typeof old.fetchIncorrectResponse>): void;
use_old_VariableDeclaration_fetchIncorrectResponse(
    get_current_VariableDeclaration_fetchIncorrectResponse());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_fetchTokens": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_fetchTokens():
    TypeOnly<typeof old.fetchTokens>;
declare function use_current_FunctionDeclaration_fetchTokens(
    use: TypeOnly<typeof current.fetchTokens>): void;
use_current_FunctionDeclaration_fetchTokens(
    get_old_FunctionDeclaration_fetchTokens());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_fetchTokens": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_fetchTokens():
    TypeOnly<typeof current.fetchTokens>;
declare function use_old_FunctionDeclaration_fetchTokens(
    use: TypeOnly<typeof old.fetchTokens>): void;
use_old_FunctionDeclaration_fetchTokens(
    get_current_FunctionDeclaration_fetchTokens());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getAadTenant": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getAadTenant():
    TypeOnly<typeof old.getAadTenant>;
declare function use_current_FunctionDeclaration_getAadTenant(
    use: TypeOnly<typeof current.getAadTenant>): void;
use_current_FunctionDeclaration_getAadTenant(
    get_old_FunctionDeclaration_getAadTenant());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getAadTenant": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getAadTenant():
    TypeOnly<typeof current.getAadTenant>;
declare function use_old_FunctionDeclaration_getAadTenant(
    use: TypeOnly<typeof old.getAadTenant>): void;
use_old_FunctionDeclaration_getAadTenant(
    get_current_FunctionDeclaration_getAadTenant());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getAadUrl": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getAadUrl():
    TypeOnly<typeof old.getAadUrl>;
declare function use_current_FunctionDeclaration_getAadUrl(
    use: TypeOnly<typeof current.getAadUrl>): void;
use_current_FunctionDeclaration_getAadUrl(
    get_old_FunctionDeclaration_getAadUrl());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getAadUrl": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getAadUrl():
    TypeOnly<typeof current.getAadUrl>;
declare function use_old_FunctionDeclaration_getAadUrl(
    use: TypeOnly<typeof old.getAadUrl>): void;
use_old_FunctionDeclaration_getAadUrl(
    get_current_FunctionDeclaration_getAadUrl());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getAsync": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getAsync():
    TypeOnly<typeof old.getAsync>;
declare function use_current_FunctionDeclaration_getAsync(
    use: TypeOnly<typeof current.getAsync>): void;
use_current_FunctionDeclaration_getAsync(
    get_old_FunctionDeclaration_getAsync());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getAsync": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getAsync():
    TypeOnly<typeof current.getAsync>;
declare function use_old_FunctionDeclaration_getAsync(
    use: TypeOnly<typeof old.getAsync>): void;
use_old_FunctionDeclaration_getAsync(
    get_current_FunctionDeclaration_getAsync());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getChildrenByDriveItem": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getChildrenByDriveItem():
    TypeOnly<typeof old.getChildrenByDriveItem>;
declare function use_current_FunctionDeclaration_getChildrenByDriveItem(
    use: TypeOnly<typeof current.getChildrenByDriveItem>): void;
use_current_FunctionDeclaration_getChildrenByDriveItem(
    get_old_FunctionDeclaration_getChildrenByDriveItem());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getChildrenByDriveItem": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getChildrenByDriveItem():
    TypeOnly<typeof current.getChildrenByDriveItem>;
declare function use_old_FunctionDeclaration_getChildrenByDriveItem(
    use: TypeOnly<typeof old.getChildrenByDriveItem>): void;
use_old_FunctionDeclaration_getChildrenByDriveItem(
    get_current_FunctionDeclaration_getChildrenByDriveItem());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getDriveId": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getDriveId():
    TypeOnly<typeof old.getDriveId>;
declare function use_current_FunctionDeclaration_getDriveId(
    use: TypeOnly<typeof current.getDriveId>): void;
use_current_FunctionDeclaration_getDriveId(
    get_old_FunctionDeclaration_getDriveId());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getDriveId": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getDriveId():
    TypeOnly<typeof current.getDriveId>;
declare function use_old_FunctionDeclaration_getDriveId(
    use: TypeOnly<typeof old.getDriveId>): void;
use_old_FunctionDeclaration_getDriveId(
    get_current_FunctionDeclaration_getDriveId());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getDriveItemByRootFileName": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getDriveItemByRootFileName():
    TypeOnly<typeof old.getDriveItemByRootFileName>;
declare function use_current_FunctionDeclaration_getDriveItemByRootFileName(
    use: TypeOnly<typeof current.getDriveItemByRootFileName>): void;
use_current_FunctionDeclaration_getDriveItemByRootFileName(
    get_old_FunctionDeclaration_getDriveItemByRootFileName());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getDriveItemByRootFileName": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getDriveItemByRootFileName():
    TypeOnly<typeof current.getDriveItemByRootFileName>;
declare function use_old_FunctionDeclaration_getDriveItemByRootFileName(
    use: TypeOnly<typeof old.getDriveItemByRootFileName>): void;
use_old_FunctionDeclaration_getDriveItemByRootFileName(
    get_current_FunctionDeclaration_getDriveItemByRootFileName());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getDriveItemByServerRelativePath": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getDriveItemByServerRelativePath():
    TypeOnly<typeof old.getDriveItemByServerRelativePath>;
declare function use_current_FunctionDeclaration_getDriveItemByServerRelativePath(
    use: TypeOnly<typeof current.getDriveItemByServerRelativePath>): void;
use_current_FunctionDeclaration_getDriveItemByServerRelativePath(
    get_old_FunctionDeclaration_getDriveItemByServerRelativePath());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getDriveItemByServerRelativePath": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getDriveItemByServerRelativePath():
    TypeOnly<typeof current.getDriveItemByServerRelativePath>;
declare function use_old_FunctionDeclaration_getDriveItemByServerRelativePath(
    use: TypeOnly<typeof old.getDriveItemByServerRelativePath>): void;
use_old_FunctionDeclaration_getDriveItemByServerRelativePath(
    get_current_FunctionDeclaration_getDriveItemByServerRelativePath());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getDriveItemFromDriveAndItem": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getDriveItemFromDriveAndItem():
    TypeOnly<typeof old.getDriveItemFromDriveAndItem>;
declare function use_current_FunctionDeclaration_getDriveItemFromDriveAndItem(
    use: TypeOnly<typeof current.getDriveItemFromDriveAndItem>): void;
use_current_FunctionDeclaration_getDriveItemFromDriveAndItem(
    get_old_FunctionDeclaration_getDriveItemFromDriveAndItem());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getDriveItemFromDriveAndItem": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getDriveItemFromDriveAndItem():
    TypeOnly<typeof current.getDriveItemFromDriveAndItem>;
declare function use_old_FunctionDeclaration_getDriveItemFromDriveAndItem(
    use: TypeOnly<typeof old.getDriveItemFromDriveAndItem>): void;
use_old_FunctionDeclaration_getDriveItemFromDriveAndItem(
    get_current_FunctionDeclaration_getDriveItemFromDriveAndItem());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getFetchTokenUrl": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getFetchTokenUrl():
    TypeOnly<typeof old.getFetchTokenUrl>;
declare function use_current_FunctionDeclaration_getFetchTokenUrl(
    use: TypeOnly<typeof current.getFetchTokenUrl>): void;
use_current_FunctionDeclaration_getFetchTokenUrl(
    get_old_FunctionDeclaration_getFetchTokenUrl());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getFetchTokenUrl": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getFetchTokenUrl():
    TypeOnly<typeof current.getFetchTokenUrl>;
declare function use_old_FunctionDeclaration_getFetchTokenUrl(
    use: TypeOnly<typeof old.getFetchTokenUrl>): void;
use_old_FunctionDeclaration_getFetchTokenUrl(
    get_current_FunctionDeclaration_getFetchTokenUrl());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getLoginPageUrl": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getLoginPageUrl():
    TypeOnly<typeof old.getLoginPageUrl>;
declare function use_current_FunctionDeclaration_getLoginPageUrl(
    use: TypeOnly<typeof current.getLoginPageUrl>): void;
use_current_FunctionDeclaration_getLoginPageUrl(
    get_old_FunctionDeclaration_getLoginPageUrl());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getLoginPageUrl": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getLoginPageUrl():
    TypeOnly<typeof current.getLoginPageUrl>;
declare function use_old_FunctionDeclaration_getLoginPageUrl(
    use: TypeOnly<typeof old.getLoginPageUrl>): void;
use_old_FunctionDeclaration_getLoginPageUrl(
    get_current_FunctionDeclaration_getLoginPageUrl());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getOdspRefreshTokenFn": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_getOdspRefreshTokenFn():
    TypeOnly<typeof old.getOdspRefreshTokenFn>;
declare function use_current_VariableDeclaration_getOdspRefreshTokenFn(
    use: TypeOnly<typeof current.getOdspRefreshTokenFn>): void;
use_current_VariableDeclaration_getOdspRefreshTokenFn(
    get_old_VariableDeclaration_getOdspRefreshTokenFn());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getOdspRefreshTokenFn": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_getOdspRefreshTokenFn():
    TypeOnly<typeof current.getOdspRefreshTokenFn>;
declare function use_old_VariableDeclaration_getOdspRefreshTokenFn(
    use: TypeOnly<typeof old.getOdspRefreshTokenFn>): void;
use_old_VariableDeclaration_getOdspRefreshTokenFn(
    get_current_VariableDeclaration_getOdspRefreshTokenFn());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getOdspScope": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_getOdspScope():
    TypeOnly<typeof old.getOdspScope>;
declare function use_current_VariableDeclaration_getOdspScope(
    use: TypeOnly<typeof current.getOdspScope>): void;
use_current_VariableDeclaration_getOdspScope(
    get_old_VariableDeclaration_getOdspScope());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getOdspScope": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_getOdspScope():
    TypeOnly<typeof current.getOdspScope>;
declare function use_old_VariableDeclaration_getOdspScope(
    use: TypeOnly<typeof old.getOdspScope>): void;
use_old_VariableDeclaration_getOdspScope(
    get_current_VariableDeclaration_getOdspScope());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getPushRefreshTokenFn": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_getPushRefreshTokenFn():
    TypeOnly<typeof old.getPushRefreshTokenFn>;
declare function use_current_VariableDeclaration_getPushRefreshTokenFn(
    use: TypeOnly<typeof current.getPushRefreshTokenFn>): void;
use_current_VariableDeclaration_getPushRefreshTokenFn(
    get_old_VariableDeclaration_getPushRefreshTokenFn());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getPushRefreshTokenFn": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_getPushRefreshTokenFn():
    TypeOnly<typeof current.getPushRefreshTokenFn>;
declare function use_old_VariableDeclaration_getPushRefreshTokenFn(
    use: TypeOnly<typeof old.getPushRefreshTokenFn>): void;
use_old_VariableDeclaration_getPushRefreshTokenFn(
    get_current_VariableDeclaration_getPushRefreshTokenFn());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getRefreshTokenFn": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_getRefreshTokenFn():
    TypeOnly<typeof old.getRefreshTokenFn>;
declare function use_current_VariableDeclaration_getRefreshTokenFn(
    use: TypeOnly<typeof current.getRefreshTokenFn>): void;
use_current_VariableDeclaration_getRefreshTokenFn(
    get_old_VariableDeclaration_getRefreshTokenFn());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getRefreshTokenFn": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_getRefreshTokenFn():
    TypeOnly<typeof current.getRefreshTokenFn>;
declare function use_old_VariableDeclaration_getRefreshTokenFn(
    use: TypeOnly<typeof old.getRefreshTokenFn>): void;
use_old_VariableDeclaration_getRefreshTokenFn(
    get_current_VariableDeclaration_getRefreshTokenFn());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse():
    TypeOnly<typeof old.getSPOAndGraphRequestIdsFromResponse>;
declare function use_current_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse(
    use: TypeOnly<typeof current.getSPOAndGraphRequestIdsFromResponse>): void;
use_current_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse(
    get_old_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse():
    TypeOnly<typeof current.getSPOAndGraphRequestIdsFromResponse>;
declare function use_old_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse(
    use: TypeOnly<typeof old.getSPOAndGraphRequestIdsFromResponse>): void;
use_old_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse(
    get_current_FunctionDeclaration_getSPOAndGraphRequestIdsFromResponse());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getServer": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getServer():
    TypeOnly<typeof old.getServer>;
declare function use_current_FunctionDeclaration_getServer(
    use: TypeOnly<typeof current.getServer>): void;
use_current_FunctionDeclaration_getServer(
    get_old_FunctionDeclaration_getServer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getServer": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getServer():
    TypeOnly<typeof current.getServer>;
declare function use_old_FunctionDeclaration_getServer(
    use: TypeOnly<typeof old.getServer>): void;
use_old_FunctionDeclaration_getServer(
    get_current_FunctionDeclaration_getServer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getSiteUrl": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getSiteUrl():
    TypeOnly<typeof old.getSiteUrl>;
declare function use_current_FunctionDeclaration_getSiteUrl(
    use: TypeOnly<typeof current.getSiteUrl>): void;
use_current_FunctionDeclaration_getSiteUrl(
    get_old_FunctionDeclaration_getSiteUrl());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getSiteUrl": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getSiteUrl():
    TypeOnly<typeof current.getSiteUrl>;
declare function use_old_FunctionDeclaration_getSiteUrl(
    use: TypeOnly<typeof old.getSiteUrl>): void;
use_old_FunctionDeclaration_getSiteUrl(
    get_current_FunctionDeclaration_getSiteUrl());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_hasFacetCodes": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_hasFacetCodes():
    TypeOnly<typeof old.hasFacetCodes>;
declare function use_current_FunctionDeclaration_hasFacetCodes(
    use: TypeOnly<typeof current.hasFacetCodes>): void;
use_current_FunctionDeclaration_hasFacetCodes(
    get_old_FunctionDeclaration_hasFacetCodes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_hasFacetCodes": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_hasFacetCodes():
    TypeOnly<typeof current.hasFacetCodes>;
declare function use_old_FunctionDeclaration_hasFacetCodes(
    use: TypeOnly<typeof old.hasFacetCodes>): void;
use_old_FunctionDeclaration_hasFacetCodes(
    get_current_FunctionDeclaration_hasFacetCodes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_hasRedirectionLocation": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_hasRedirectionLocation():
    TypeOnly<typeof old.hasRedirectionLocation>;
declare function use_current_FunctionDeclaration_hasRedirectionLocation(
    use: TypeOnly<typeof current.hasRedirectionLocation>): void;
use_current_FunctionDeclaration_hasRedirectionLocation(
    get_old_FunctionDeclaration_hasRedirectionLocation());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_hasRedirectionLocation": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_hasRedirectionLocation():
    TypeOnly<typeof current.hasRedirectionLocation>;
declare function use_old_FunctionDeclaration_hasRedirectionLocation(
    use: TypeOnly<typeof old.hasRedirectionLocation>): void;
use_old_FunctionDeclaration_hasRedirectionLocation(
    get_current_FunctionDeclaration_hasRedirectionLocation());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isOdspHostname": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_isOdspHostname():
    TypeOnly<typeof old.isOdspHostname>;
declare function use_current_FunctionDeclaration_isOdspHostname(
    use: TypeOnly<typeof current.isOdspHostname>): void;
use_current_FunctionDeclaration_isOdspHostname(
    get_old_FunctionDeclaration_isOdspHostname());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isOdspHostname": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_isOdspHostname():
    TypeOnly<typeof current.isOdspHostname>;
declare function use_old_FunctionDeclaration_isOdspHostname(
    use: TypeOnly<typeof old.isOdspHostname>): void;
use_old_FunctionDeclaration_isOdspHostname(
    get_current_FunctionDeclaration_isOdspHostname());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isPushChannelHostname": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_isPushChannelHostname():
    TypeOnly<typeof old.isPushChannelHostname>;
declare function use_current_FunctionDeclaration_isPushChannelHostname(
    use: TypeOnly<typeof current.isPushChannelHostname>): void;
use_current_FunctionDeclaration_isPushChannelHostname(
    get_old_FunctionDeclaration_isPushChannelHostname());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isPushChannelHostname": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_isPushChannelHostname():
    TypeOnly<typeof current.isPushChannelHostname>;
declare function use_old_FunctionDeclaration_isPushChannelHostname(
    use: TypeOnly<typeof old.isPushChannelHostname>): void;
use_old_FunctionDeclaration_isPushChannelHostname(
    get_current_FunctionDeclaration_isPushChannelHostname());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_parseFacetCodes": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_parseFacetCodes():
    TypeOnly<typeof old.parseFacetCodes>;
declare function use_current_FunctionDeclaration_parseFacetCodes(
    use: TypeOnly<typeof current.parseFacetCodes>): void;
use_current_FunctionDeclaration_parseFacetCodes(
    get_old_FunctionDeclaration_parseFacetCodes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_parseFacetCodes": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_parseFacetCodes():
    TypeOnly<typeof current.parseFacetCodes>;
declare function use_old_FunctionDeclaration_parseFacetCodes(
    use: TypeOnly<typeof old.parseFacetCodes>): void;
use_old_FunctionDeclaration_parseFacetCodes(
    get_current_FunctionDeclaration_parseFacetCodes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_postAsync": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_postAsync():
    TypeOnly<typeof old.postAsync>;
declare function use_current_FunctionDeclaration_postAsync(
    use: TypeOnly<typeof current.postAsync>): void;
use_current_FunctionDeclaration_postAsync(
    get_old_FunctionDeclaration_postAsync());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_postAsync": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_postAsync():
    TypeOnly<typeof current.postAsync>;
declare function use_old_FunctionDeclaration_postAsync(
    use: TypeOnly<typeof old.postAsync>): void;
use_old_FunctionDeclaration_postAsync(
    get_current_FunctionDeclaration_postAsync());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_pushScope": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_pushScope():
    TypeOnly<typeof old.pushScope>;
declare function use_current_VariableDeclaration_pushScope(
    use: TypeOnly<typeof current.pushScope>): void;
use_current_VariableDeclaration_pushScope(
    get_old_VariableDeclaration_pushScope());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_pushScope": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_pushScope():
    TypeOnly<typeof current.pushScope>;
declare function use_old_VariableDeclaration_pushScope(
    use: TypeOnly<typeof old.pushScope>): void;
use_old_VariableDeclaration_pushScope(
    get_current_VariableDeclaration_pushScope());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_putAsync": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_putAsync():
    TypeOnly<typeof old.putAsync>;
declare function use_current_FunctionDeclaration_putAsync(
    use: TypeOnly<typeof current.putAsync>): void;
use_current_FunctionDeclaration_putAsync(
    get_old_FunctionDeclaration_putAsync());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_putAsync": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_putAsync():
    TypeOnly<typeof current.putAsync>;
declare function use_old_FunctionDeclaration_putAsync(
    use: TypeOnly<typeof old.putAsync>): void;
use_old_FunctionDeclaration_putAsync(
    get_current_FunctionDeclaration_putAsync());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_refreshTokens": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_refreshTokens():
    TypeOnly<typeof old.refreshTokens>;
declare function use_current_FunctionDeclaration_refreshTokens(
    use: TypeOnly<typeof current.refreshTokens>): void;
use_current_FunctionDeclaration_refreshTokens(
    get_old_FunctionDeclaration_refreshTokens());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_refreshTokens": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_refreshTokens():
    TypeOnly<typeof current.refreshTokens>;
declare function use_old_FunctionDeclaration_refreshTokens(
    use: TypeOnly<typeof old.refreshTokens>): void;
use_old_FunctionDeclaration_refreshTokens(
    get_current_FunctionDeclaration_refreshTokens());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_throwOdspNetworkError": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_throwOdspNetworkError():
    TypeOnly<typeof old.throwOdspNetworkError>;
declare function use_current_FunctionDeclaration_throwOdspNetworkError(
    use: TypeOnly<typeof current.throwOdspNetworkError>): void;
use_current_FunctionDeclaration_throwOdspNetworkError(
    get_old_FunctionDeclaration_throwOdspNetworkError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_throwOdspNetworkError": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_throwOdspNetworkError():
    TypeOnly<typeof current.throwOdspNetworkError>;
declare function use_old_FunctionDeclaration_throwOdspNetworkError(
    use: TypeOnly<typeof old.throwOdspNetworkError>): void;
use_old_FunctionDeclaration_throwOdspNetworkError(
    get_current_FunctionDeclaration_throwOdspNetworkError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_tryParseErrorResponse": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_tryParseErrorResponse():
    TypeOnly<typeof old.tryParseErrorResponse>;
declare function use_current_FunctionDeclaration_tryParseErrorResponse(
    use: TypeOnly<typeof current.tryParseErrorResponse>): void;
use_current_FunctionDeclaration_tryParseErrorResponse(
    get_old_FunctionDeclaration_tryParseErrorResponse());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_tryParseErrorResponse": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_tryParseErrorResponse():
    TypeOnly<typeof current.tryParseErrorResponse>;
declare function use_old_FunctionDeclaration_tryParseErrorResponse(
    use: TypeOnly<typeof old.tryParseErrorResponse>): void;
use_old_FunctionDeclaration_tryParseErrorResponse(
    get_current_FunctionDeclaration_tryParseErrorResponse());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_unauthPostAsync": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_unauthPostAsync():
    TypeOnly<typeof old.unauthPostAsync>;
declare function use_current_FunctionDeclaration_unauthPostAsync(
    use: TypeOnly<typeof current.unauthPostAsync>): void;
use_current_FunctionDeclaration_unauthPostAsync(
    get_old_FunctionDeclaration_unauthPostAsync());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_unauthPostAsync": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_unauthPostAsync():
    TypeOnly<typeof current.unauthPostAsync>;
declare function use_old_FunctionDeclaration_unauthPostAsync(
    use: TypeOnly<typeof old.unauthPostAsync>): void;
use_old_FunctionDeclaration_unauthPostAsync(
    get_current_FunctionDeclaration_unauthPostAsync());
