/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

import { Heap, IComparer, IHeapNode } from "@microsoft/fluid-core-utils";
import * as _ from "lodash";
import { IClientSequenceNumber } from "./checkpointContext";

const SequenceNumberComparer: IComparer<IClientSequenceNumber> = {
    compare: (a, b) =>  a.referenceSequenceNumber - b.referenceSequenceNumber,
    min: {
        canEvict: true,
        clientId: undefined,
        clientSequenceNumber: 0,
        lastUpdate: -1,
        nack: false,
        referenceSequenceNumber: -1,
        scopes: [],
    },
};

export class ClientSequenceNumberManager {
    private clientNodeMap = new Map<string, IHeapNode<IClientSequenceNumber>>();
    private clientSeqNumbers = new Heap<IClientSequenceNumber>(SequenceNumberComparer);
    private lastUpdate = 0;
    private recentIdleEnd: number | undefined;

    constructor(
        private readonly idleTimeout: number,
        private readonly clientIdleTimeout: number) { }

    public has(clientId: string): boolean {
        return this.clientNodeMap.has(clientId);
    }

    public get(clientId: string): IClientSequenceNumber {
        const node = this.clientNodeMap.get(clientId);
        if (node === undefined) {
            return undefined;
        }
        return node.value;
    }

    public count() {
        return this.clientNodeMap.size;
    }

    public peek() {
        const node = this.clientSeqNumbers.peek();
        if (node === undefined) {
            return undefined;
        }
        return node.value;
    }

    public cloneValues(): IClientSequenceNumber[] {
        const clients: IClientSequenceNumber[] = [];
        for (const [, value] of this.clientNodeMap) {
            clients.push(_.clone(value.value));
        }
        return clients;
    }

    /**
     * Begins tracking or updates an already tracked client.
     * @param clientId The client identifier
     * @param clientSequenceNumber The sequence number generated by client
     * @param referenceSequenceNumber The sequence number the client is at
     * @param timestamp The time of the operation
     * @param canEvict Flag indicating whether or not we can evict the client (branch clients cannot be evicted)
     * @param scopes scope of the client
     * @param nack Flag indicating whether we have nacked this client
     */
    public upsertClient(
        clientId: string,
        clientSequenceNumber: number,
        referenceSequenceNumber: number,
        timestamp: number,
        canEvict: boolean,
        scopes: string[] = [],
        nack: boolean = false) {

        // Add the client ID to our map if this is the first time we've seen it
        if (!this.clientNodeMap.has(clientId)) {
            const newNode = this.clientSeqNumbers.add({
                canEvict,
                clientId,
                clientSequenceNumber,
                lastUpdate: timestamp,
                nack,
                referenceSequenceNumber,
                scopes,
            });
            this.clientNodeMap.set(clientId, newNode);
        }

        // And then update its values
        this.updateClient(clientId, timestamp, clientSequenceNumber, referenceSequenceNumber, nack);
    }

    /**
     * Removes the provided client from the list of tracked clients.
     * Returns false if the client has been removed earlier.
     */
    public removeClient(clientId: string): boolean {
        if (!this.clientNodeMap.has(clientId)) {
            return false;
        }

        // Remove the client from the list of nodes
        const details = this.clientNodeMap.get(clientId);
        this.clientSeqNumbers.remove(details);
        this.clientNodeMap.delete(clientId);
        return true;
    }

    /**
     * Retrieves the minimum sequence number.
     */
    public getMinimumSequenceNumber(): number {
        if (this.clientSeqNumbers.count() > 0) {
            const client = this.clientSeqNumbers.peek();
            return client.value.referenceSequenceNumber;
        } else {
            return -1;
        }
    }

    public getIdleClient(): IClientSequenceNumber {
        if (this.clientNodeMap.size > 0) {
            const node = this.clientSeqNumbers.peek();
            const client = node.value;
            if (client.canEvict
                && this.recentIdleEnd === undefined
                && (this.lastUpdate - client.lastUpdate > this.clientIdleTimeout)) {
                    return client;
            }
        }
    }

    /**
     * Updates the sequence number of the specified client
     */
    private updateClient(
        clientId: string,
        timestamp: number,
        clientSequenceNumber: number,
        referenceSequenceNumber: number,
        nack: boolean) {

        if (timestamp > this.lastUpdate) {
            // if the gap between the last update, and this update
            // is greater than the client timeout then we were idle
            // so track the end time of this idle period
            if (timestamp - this.lastUpdate > this.idleTimeout) {
                this.recentIdleEnd = timestamp;
            }
            this.lastUpdate = timestamp;

            if (this.recentIdleEnd !== undefined) {
                // once the difference between this update and the recent
                // idle end is greater than the idle timeout then we
                // are not longer recently idle, so clear the recent idle end
                if (timestamp - this.recentIdleEnd > this.idleTimeout) {
                    this.recentIdleEnd = undefined;
                } else {
                    // if the oldest client has been updated since idle ended
                    // then the idle can be cleared as well,
                    // as we're not recently idle
                    const client = this.peek();
                    if (client.lastUpdate > this.recentIdleEnd) {
                        this.recentIdleEnd = undefined;
                    }
                }
            }
        }

        // Lookup the node and then update its value based on the message
        const heapNode = this.clientNodeMap.get(clientId);
        heapNode.value.referenceSequenceNumber = referenceSequenceNumber;
        heapNode.value.clientSequenceNumber = clientSequenceNumber;
        heapNode.value.lastUpdate = timestamp;
        heapNode.value.nack = nack;
        this.clientSeqNumbers.update(heapNode);
    }
}
