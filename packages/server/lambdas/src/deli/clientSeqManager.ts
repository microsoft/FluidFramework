/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

import { Heap, IComparer, IHeapNode } from "@microsoft/fluid-core-utils";
import * as _ from "lodash";
import { IClientSequenceNumber } from "./checkpointContext";

const SequenceNumberComparer: IComparer<IClientSequenceNumber> = {
    compare: (a, b) =>  a.referenceSequenceNumber - b.referenceSequenceNumber,
    min: {
        canEvict: true,
        clientId: undefined,
        clientSequenceNumber: 0,
        lastUpdate: -1,
        nack: false,
        referenceSequenceNumber: -1,
        scopes: [],
    },
};

export class ClientSequenceNumberManager {
    private clientNodeMap = new Map<string, IHeapNode<IClientSequenceNumber>>();
    private clientSeqNumbers = new Heap<IClientSequenceNumber>(SequenceNumberComparer);
    private lastUpdate = -1;
    private fullIdlePeriod = { start: 0, end: 0 };

    constructor(private readonly clientIdleTimeout: number) { }

    public get lastFullIdlePeriod() {
        return Object.freeze(this.fullIdlePeriod);
    }

    public has(clientId: string): boolean {
        return this.clientNodeMap.has(clientId);
    }

    public get(clientId: string): IClientSequenceNumber {
        const node = this.clientNodeMap.get(clientId);
        if (node === undefined) {
            return undefined;
        }
        return node.value;
    }

    public count() {
        return this.clientNodeMap.size;
    }

    public peek() {
        const node = this.clientSeqNumbers.peek();
        if (node === undefined) {
            return undefined;
        }
        return node.value;
    }

    public cloneValues(): IClientSequenceNumber[] {
        const clients: IClientSequenceNumber[] = [];
        for (const [, value] of this.clientNodeMap) {
            clients.push(_.clone(value.value));
        }
        return clients;
    }

    /**
     * Begins tracking or updates an already tracked client.
     * @param clientId The client identifier
     * @param clientSequenceNumber The sequence number generated by client
     * @param referenceSequenceNumber The sequence number the client is at
     * @param timestamp The time of the operation
     * @param canEvict Flag indicating whether or not we can evict the client (branch clients cannot be evicted)
     * @param scopes scope of the client
     * @param nack Flag indicating whether we have nacked this client
     */
    public upsertClient(
        clientId: string,
        clientSequenceNumber: number,
        referenceSequenceNumber: number,
        timestamp: number,
        canEvict: boolean,
        scopes: string[] = [],
        nack: boolean = false) {

        // Add the client ID to our map if this is the first time we've seen it
        if (!this.clientNodeMap.has(clientId)) {
            const newNode = this.clientSeqNumbers.add({
                canEvict,
                clientId,
                clientSequenceNumber,
                lastUpdate: timestamp,
                nack,
                referenceSequenceNumber,
                scopes,
            });
            this.clientNodeMap.set(clientId, newNode);
        }

        // And then update its values
        this.updateClient(clientId, timestamp, clientSequenceNumber, referenceSequenceNumber, nack);
    }

    /**
     * Removes the provided client from the list of tracked clients.
     * Returns false if the client has been removed earlier.
     */
    public removeClient(clientId: string): boolean {
        if (!this.clientNodeMap.has(clientId)) {
            return false;
        }

        // Remove the client from the list of nodes
        const details = this.clientNodeMap.get(clientId);
        this.clientSeqNumbers.remove(details);
        this.clientNodeMap.delete(clientId);
        return true;
    }

    /**
     * Retrieves the minimum sequence number.
     */
    public getMinimumSequenceNumber(): number {
        if (this.clientSeqNumbers.count() > 0) {
            const client = this.clientSeqNumbers.peek();
            return client.value.referenceSequenceNumber;
        } else {
            return -1;
        }
    }

    public getIdleClient(): IClientSequenceNumber {
        if (this.clientNodeMap.size > 1) {
            const node = this.clientSeqNumbers.peek();
            const client = node.value;
            if (client.canEvict
                && (client.lastUpdate <= this.fullIdlePeriod.start - this.clientIdleTimeout
                    || client.lastUpdate >= this.fullIdlePeriod.end)
                && this.lastUpdate - client.lastUpdate > this.clientIdleTimeout) {
                    return client;
            }
        }
    }

    /**
     * Updates the sequence number of the specified client
     */
    private updateClient(
        clientId: string,
        timestamp: number,
        clientSequenceNumber: number,
        referenceSequenceNumber: number,
        nack: boolean) {

        if (timestamp > this.lastUpdate) {
            // if the gap between the last update, and this update
            // is greater than the client timeout then we were idle
            // so track the end time of this idle period
            if (this.lastUpdate > 0 &&  timestamp - this.lastUpdate > this.clientIdleTimeout) {
                this.fullIdlePeriod = {start: this.lastUpdate, end: timestamp};
            }
            this.lastUpdate = timestamp;
        }

        // Lookup the node and then update its value based on the message
        const heapNode = this.clientNodeMap.get(clientId);
        heapNode.value.referenceSequenceNumber = referenceSequenceNumber;
        heapNode.value.clientSequenceNumber = clientSequenceNumber;
        heapNode.value.lastUpdate = timestamp;
        heapNode.value.nack = nack;
        this.clientSeqNumbers.update(heapNode);
    }
}
