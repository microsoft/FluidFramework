{"version":3,"file":"componentRuntime.js","sourceRoot":"","sources":["../src/componentRuntime.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { strict as assert } from \"assert\";\nimport { EventEmitter } from \"events\";\nimport { ITelemetryLogger } from \"@fluidframework/common-definitions\";\nimport {\n    IFluidHandle,\n    IFluidHandleContext,\n    IRequest,\n    IResponse,\n} from \"@fluidframework/component-core-interfaces\";\nimport {\n    IAudience,\n    IBlobManager,\n    IDeltaManager,\n    IGenericBlob,\n    ContainerWarning,\n    ILoader,\n    BindState,\n    AttachState,\n} from \"@fluidframework/container-definitions\";\nimport {\n    Deferred,\n    unreachableCase,\n} from \"@fluidframework/common-utils\";\nimport {\n    ChildLogger,\n    raiseConnectedEvent,\n} from \"@fluidframework/telemetry-utils\";\nimport { buildSnapshotTree } from \"@fluidframework/driver-utils\";\nimport { TreeTreeEntry } from \"@fluidframework/protocol-base\";\nimport {\n    IClientDetails,\n    IDocumentMessage,\n    IQuorum,\n    ISequencedDocumentMessage,\n    ITreeEntry,\n} from \"@fluidframework/protocol-definitions\";\nimport {\n    IAttachMessage,\n    IFluidDataStoreContext,\n    IFluidDataStoreRegistry,\n    IFluidDataStoreChannel,\n    IEnvelope,\n    IInboundSignalMessage,\n    SchedulerType,\n    ISummaryTreeWithStats,\n    CreateSummarizerNodeSource,\n} from \"@fluidframework/runtime-definitions\";\nimport { generateHandleContextPath, SummaryTreeBuilder } from \"@fluidframework/runtime-utils\";\nimport { IChannel, IFluidDataStoreRuntime, IChannelFactory } from \"@fluidframework/component-runtime-definitions\";\nimport { v4 as uuid } from \"uuid\";\nimport { IChannelContext, snapshotChannel } from \"./channelContext\";\nimport { LocalChannelContext } from \"./localChannelContext\";\nimport { RemoteChannelContext } from \"./remoteChannelContext\";\n\nexport enum ComponentMessageType {\n    // Creates a new channel\n    Attach = \"attach\",\n    ChannelOp = \"op\",\n}\n\nexport interface ISharedObjectRegistry {\n    // TODO consider making this async. A consequence is that either the creation of a distributed data type\n    // is async or we need a new API to split the synchronous vs. asynchronous creation.\n    get(name: string): IChannelFactory | undefined;\n}\n\n/**\n * Base component class\n */\nexport class FluidDataStoreRuntime extends EventEmitter implements IFluidDataStoreChannel,\n    IFluidDataStoreRuntime, IFluidHandleContext {\n    /**\n     * Loads the component runtime\n     * @param context - The component context\n     * @param sharedObjectRegistry - The registry of shared objects used by this component\n     * @param activeCallback - The callback called when the component runtime in active\n     * @param componentRegistry - The registry of components created and used by this component\n     */\n    public static load(\n        context: IFluidDataStoreContext,\n        sharedObjectRegistry: ISharedObjectRegistry,\n        componentRegistry?: IFluidDataStoreRegistry,\n    ): FluidDataStoreRuntime {\n        const logger = ChildLogger.create(context.containerRuntime.logger, undefined, { componentId: uuid() });\n        const runtime = new FluidDataStoreRuntime(\n            context,\n            context.documentId,\n            context.id,\n            context.parentBranch,\n            context.existing,\n            context.options,\n            context.blobManager,\n            context.deltaManager,\n            context.getQuorum(),\n            context.getAudience(),\n            context.snapshotFn,\n            sharedObjectRegistry,\n            componentRegistry,\n            logger);\n\n        context.bindRuntime(runtime);\n        return runtime;\n    }\n\n    public get IFluidRouter() { return this; }\n\n    public get connected(): boolean {\n        return this.componentContext.connected;\n    }\n\n    public get leader(): boolean {\n        return this.componentContext.leader;\n    }\n\n    public get clientId(): string | undefined {\n        return this.componentContext.clientId;\n    }\n\n    public get clientDetails(): IClientDetails {\n        return this.componentContext.containerRuntime.clientDetails;\n    }\n\n    public get loader(): ILoader {\n        return this.componentContext.loader;\n    }\n\n    public get isAttached(): boolean {\n        return this.attachState !== AttachState.Detached;\n    }\n\n    public get attachState(): AttachState {\n        return this._attachState;\n    }\n\n    /**\n     * @deprecated - 0.21 back-compat\n     */\n    public get path(): string {\n        return this.id;\n    }\n\n    public get absolutePath(): string {\n        return generateHandleContextPath(this.id, this.routeContext);\n    }\n\n    public get routeContext(): IFluidHandleContext {\n        return this.componentContext.containerRuntime.IFluidHandleContext;\n    }\n\n    public get IFluidSerializer() { return this.componentContext.containerRuntime.IFluidSerializer; }\n\n    public get IFluidHandleContext() { return this; }\n    public get IFluidDataStoreRegistry() { return this.componentRegistry; }\n\n    private _disposed = false;\n    public get disposed() { return this._disposed; }\n\n    private readonly contexts = new Map<string, IChannelContext>();\n    private readonly contextsDeferred = new Map<string, Deferred<IChannelContext>>();\n    private readonly pendingAttach = new Map<string, IAttachMessage>();\n    private requestHandler: ((request: IRequest) => Promise<IResponse>) | undefined;\n    private bindState: BindState;\n    // This is used to break the recursion while attaching the graph. Also tells the attach state of the graph.\n    private graphAttachState: AttachState = AttachState.Detached;\n    private readonly deferredAttached = new Deferred<void>();\n    private readonly localChannelContextQueue = new Map<string, LocalChannelContext>();\n    private readonly notBoundedChannelContextSet = new Set<string>();\n    private boundhandles: Set<IFluidHandle> | undefined;\n    private _attachState: AttachState;\n\n    private constructor(\n        private readonly componentContext: IFluidDataStoreContext,\n        public readonly documentId: string,\n        public readonly id: string,\n        public readonly parentBranch: string | null,\n        public existing: boolean,\n        public readonly options: any,\n        private readonly blobManager: IBlobManager,\n        public readonly deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>,\n        private readonly quorum: IQuorum,\n        private readonly audience: IAudience,\n        private readonly snapshotFn: (message: string) => Promise<void>,\n        private readonly sharedObjectRegistry: ISharedObjectRegistry,\n        private readonly componentRegistry: IFluidDataStoreRegistry | undefined,\n        public readonly logger: ITelemetryLogger,\n    ) {\n        super();\n\n        const tree = componentContext.baseSnapshot;\n\n        // Must always receive the component type inside of the attributes\n        if (tree?.trees !== undefined) {\n            Object.keys(tree.trees).forEach((path) => {\n                const channelContext = new RemoteChannelContext(\n                    this,\n                    componentContext,\n                    componentContext.storage,\n                    (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata),\n                    (address: string) => this.setChannelDirty(address),\n                    path,\n                    tree.trees[path],\n                    this.sharedObjectRegistry,\n                    undefined /* extraBlobs */,\n                    componentContext.branch,\n                    this.componentContext.summaryTracker.createOrGetChild(\n                        path,\n                        this.deltaManager.lastSequenceNumber,\n                    ),\n                    this.componentContext.getCreateChildSummarizerNodeFn(\n                        path,\n                        { type: CreateSummarizerNodeSource.FromSummary },\n                    ));\n                const deferred = new Deferred<IChannelContext>();\n                deferred.resolve(channelContext);\n\n                this.contexts.set(path, channelContext);\n                this.contextsDeferred.set(path, deferred);\n            });\n        }\n\n        this.attachListener();\n        this.bindState = existing ? BindState.Bound : BindState.NotBound;\n        this._attachState = existing ? AttachState.Attached : AttachState.Detached;\n\n        // If it's existing we know it has been attached.\n        if (existing) {\n            this.deferredAttached.resolve();\n        }\n    }\n\n    public dispose(): void {\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n\n        this.emit(\"dispose\");\n    }\n\n    public async request(request: IRequest): Promise<IResponse> {\n        // System routes\n        if (request.url === `/${SchedulerType}`) {\n            return this.componentContext.containerRuntime.request(request);\n        }\n\n        // Parse out the leading slash\n        const id = request.url.startsWith(\"/\") ? request.url.substr(1) : request.url;\n\n        // Check for a data type reference first\n        if (this.contextsDeferred.has(id)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const value = await this.contextsDeferred.get(id)!.promise;\n            const channel = await value.getChannel();\n\n            return { mimeType: \"fluid/object\", status: 200, value: channel };\n        }\n\n        // Otherwise defer to an attached request handler\n        if (this.requestHandler === undefined) {\n            return { status: 404, mimeType: \"text/plain\", value: `${request.url} not found` };\n        } else {\n            return this.requestHandler(request);\n        }\n    }\n\n    public registerRequestHandler(handler: (request: IRequest) => Promise<IResponse>) {\n        this.requestHandler = handler;\n    }\n\n    public async getChannel(id: string): Promise<IChannel> {\n        this.verifyNotClosed();\n\n        // TODO we don't assume any channels (even root) in the runtime. If you request a channel that doesn't exist\n        // we will never resolve the promise. May want a flag to getChannel that doesn't wait for the promise if\n        // it doesn't exist\n        if (!this.contextsDeferred.has(id)) {\n            this.contextsDeferred.set(id, new Deferred<IChannelContext>());\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const context = await this.contextsDeferred.get(id)!.promise;\n        const channel = await context.getChannel();\n\n        return channel;\n    }\n\n    public createChannel(id: string = uuid(), type: string): IChannel {\n        this.verifyNotClosed();\n\n        assert(!this.contexts.has(id), \"createChannel() with existing ID\");\n        this.notBoundedChannelContextSet.add(id);\n        const context = new LocalChannelContext(\n            id,\n            this.sharedObjectRegistry,\n            type,\n            this,\n            this.componentContext,\n            this.componentContext.storage,\n            (content, localOpMetadata) => this.submitChannelOp(id, content, localOpMetadata),\n            (address: string) => this.setChannelDirty(address));\n        this.contexts.set(id, context);\n\n        if (this.contextsDeferred.has(id)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.contextsDeferred.get(id)!.resolve(context);\n        } else {\n            const deferred = new Deferred<IChannelContext>();\n            deferred.resolve(context);\n            this.contextsDeferred.set(id, deferred);\n        }\n\n        return context.channel;\n    }\n\n    /**\n     * Binds a channel with the runtime. If the runtime is attached we will attach the channel right away.\n     * If the runtime is not attached we will defer the attach until the runtime attaches.\n     * @param channel - channel to be registered.\n     */\n    public bindChannel(channel: IChannel): void {\n        assert(this.notBoundedChannelContextSet.has(channel.id), \"Channel to be binded should be in not bounded set\");\n        this.notBoundedChannelContextSet.delete(channel.id);\n        // If our Component is attached, then attach the channel.\n        if (this.isAttached) {\n            this.attachChannel(channel);\n            return;\n        } else {\n            this.bind(channel.handle);\n\n            // If our Component is local then add the channel to the queue\n            if (!this.localChannelContextQueue.has(channel.id)) {\n                this.localChannelContextQueue.set(channel.id, this.contexts.get(channel.id) as LocalChannelContext);\n            }\n        }\n    }\n\n    public attachGraph() {\n        if (this.graphAttachState !== AttachState.Detached) {\n            return;\n        }\n        this.graphAttachState = AttachState.Attaching;\n        if (this.boundhandles !== undefined) {\n            this.boundhandles.forEach((handle) => {\n                handle.attachGraph();\n            });\n            this.boundhandles = undefined;\n        }\n\n        // Flush the queue to set any pre-existing channels to local\n        this.localChannelContextQueue.forEach((channel) => {\n            // When we are attaching the component we don't need to send attach for the registered services.\n            // This is because they will be captured as part of the Attach component snapshot\n            channel.attach();\n        });\n\n        this.localChannelContextQueue.clear();\n        this.bindToContext();\n        this.graphAttachState = AttachState.Attached;\n    }\n\n    /**\n     * Binds this runtime to the container\n     * This includes the following:\n     * 1. Sending an Attach op that includes all existing state\n     * 2. Attaching the graph if the component becomes attached.\n     */\n    public bindToContext() {\n        if (this.bindState !== BindState.NotBound) {\n            return;\n        }\n        this.bindState = BindState.Binding;\n        // Attach the runtime to the container via this callback\n        this.componentContext.bindToContext(this);\n\n        this.bindState = BindState.Bound;\n    }\n\n    public bind(handle: IFluidHandle): void {\n        // If the component is already attached or its graph is already in attaching or attached state,\n        // then attach the incoming handle too.\n        if (this.isAttached || this.graphAttachState !== AttachState.Detached) {\n            handle.attachGraph();\n            return;\n        }\n        if (this.boundhandles === undefined) {\n            this.boundhandles = new Set<IFluidHandle>();\n        }\n\n        this.boundhandles.add(handle);\n    }\n\n    public setConnectionState(connected: boolean, clientId?: string) {\n        this.verifyNotClosed();\n\n        for (const [, object] of this.contexts) {\n            object.setConnectionState(connected, clientId);\n        }\n\n        raiseConnectedEvent(this.logger, this, connected, clientId);\n    }\n\n    public getQuorum(): IQuorum {\n        return this.quorum;\n    }\n\n    public getAudience(): IAudience {\n        return this.audience;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    public snapshot(message: string): Promise<void> {\n        this.verifyNotClosed();\n        return this.snapshotFn(message);\n    }\n\n    public async uploadBlob(file: IGenericBlob): Promise<IGenericBlob> {\n        this.verifyNotClosed();\n\n        const blob = await this.blobManager.createBlob(file);\n        file.id = blob.id;\n        file.url = blob.url;\n\n        return file;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    public getBlob(blobId: string): Promise<IGenericBlob | undefined> {\n        this.verifyNotClosed();\n\n        return this.blobManager.getBlob(blobId);\n    }\n\n    public async getBlobMetadata(): Promise<IGenericBlob[]> {\n        return this.blobManager.getBlobMetadata();\n    }\n\n    public process(message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown) {\n        this.verifyNotClosed();\n        switch (message.type) {\n            case ComponentMessageType.Attach: {\n                const attachMessage = message.contents as IAttachMessage;\n                const id = attachMessage.id;\n\n                // If a non-local operation then go and create the object\n                // Otherwise mark it as officially attached.\n                if (local) {\n                    assert(this.pendingAttach.has(id), \"Unexpected attach (local) channel OP\");\n                    this.pendingAttach.delete(id);\n                } else {\n                    assert(!this.contexts.has(id), \"Unexpected attach channel OP\");\n\n                    // Create storage service that wraps the attach data\n                    const origin = message.origin?.id ?? this.documentId;\n\n                    const flatBlobs = new Map<string, string>();\n                    const snapshotTreeP = buildSnapshotTree(attachMessage.snapshot.entries, flatBlobs);\n                    // flatBlobsP's validity is contingent on snapshotTreeP's resolution\n                    const flatBlobsP = snapshotTreeP.then((snapshotTree) => { return flatBlobs; });\n\n                    const remoteChannelContext = new RemoteChannelContext(\n                        this,\n                        this.componentContext,\n                        this.componentContext.storage,\n                        (content, localContentMetadata) => this.submitChannelOp(id, content, localContentMetadata),\n                        (address: string) => this.setChannelDirty(address),\n                        id,\n                        snapshotTreeP,\n                        this.sharedObjectRegistry,\n                        flatBlobsP,\n                        origin,\n                        this.componentContext.summaryTracker.createOrGetChild(\n                            id,\n                            message.sequenceNumber,\n                        ),\n                        this.componentContext.getCreateChildSummarizerNodeFn(\n                            id,\n                            {\n                                type: CreateSummarizerNodeSource.FromAttach,\n                                sequenceNumber: message.sequenceNumber,\n                                snapshot: attachMessage.snapshot,\n                            },\n                        ),\n                        attachMessage.type);\n\n                    this.contexts.set(id, remoteChannelContext);\n                    if (this.contextsDeferred.has(id)) {\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        this.contextsDeferred.get(id)!.resolve(remoteChannelContext);\n                    } else {\n                        const deferred = new Deferred<IChannelContext>();\n                        deferred.resolve(remoteChannelContext);\n                        this.contextsDeferred.set(id, deferred);\n                    }\n                }\n                break;\n            }\n\n            case ComponentMessageType.ChannelOp:\n                this.processChannelOp(message, local, localOpMetadata);\n                break;\n            default:\n        }\n\n        this.emit(\"op\", message);\n    }\n\n    public processSignal(message: IInboundSignalMessage, local: boolean) {\n        this.emit(\"signal\", message, local);\n    }\n\n    private isChannelAttached(id: string): boolean {\n        return (\n            // Added in createChannel\n            // Removed when bindChannel is called\n            !this.notBoundedChannelContextSet.has(id)\n            // Added in bindChannel only if this is not attached yet\n            // Removed when this is attached by calling attachGraph\n            && !this.localChannelContextQueue.has(id)\n            // Added in attachChannel called by bindChannel\n            // Removed when attach op is broadcast\n            && !this.pendingAttach.has(id)\n        );\n    }\n\n    public async snapshotInternal(fullTree: boolean = false): Promise<ITreeEntry[]> {\n        // Craft the .attributes file for each shared object\n        const entries = await Promise.all(Array.from(this.contexts)\n            .filter(([key, _]) => {\n                const isAttached = this.isChannelAttached(key);\n                // We are not expecting local dds! Summary may not capture local state.\n                assert(isAttached, \"Not expecting detached channels during summarize\");\n                // If the object is registered - and we have received the sequenced op creating the object\n                // (i.e. it has a base mapping) - then we go ahead and snapshot\n                return isAttached;\n            }).map(async ([key, value]) => {\n                const snapshot = await value.snapshot(fullTree);\n\n                // And then store the tree\n                return new TreeTreeEntry(key, snapshot);\n            }));\n\n        return entries;\n    }\n\n    public async summarize(fullTree = false): Promise<ISummaryTreeWithStats> {\n        const builder = new SummaryTreeBuilder();\n\n        // Iterate over each component and ask it to snapshot\n        await Promise.all(Array.from(this.contexts)\n            .filter(([key, _]) => {\n                const isAttached = this.isChannelAttached(key);\n                // We are not expecting local dds! Summary may not capture local state.\n                assert(isAttached, \"Not expecting detached channels during summarize\");\n                // If the object is registered - and we have received the sequenced op creating the object\n                // (i.e. it has a base mapping) - then we go ahead and snapshot\n                return isAttached;\n            }).map(async ([key, value]) => {\n                const channelSummary = await value.summarize(fullTree);\n                builder.addWithStats(key, channelSummary);\n            }));\n\n        return builder.getSummaryTree();\n    }\n\n    public getAttachSnapshot(): ITreeEntry[] {\n        const entries: ITreeEntry[] = [];\n        this.attachGraph();\n\n        // Craft the .attributes file for each shared object\n        for (const [objectId, value] of this.contexts) {\n            if (!(value instanceof LocalChannelContext)) {\n                throw new Error(\"Should only be called with local channel handles\");\n            }\n\n            if (!this.notBoundedChannelContextSet.has(objectId)) {\n                const snapshot = value.getAttachSnapshot();\n\n                // And then store the tree\n                entries.push(new TreeTreeEntry(objectId, snapshot));\n            }\n        }\n\n        return entries;\n    }\n\n    public submitMessage(type: ComponentMessageType, content: any, localOpMetadata: unknown) {\n        this.submit(type, content, localOpMetadata);\n    }\n\n    public submitSignal(type: string, content: any) {\n        this.verifyNotClosed();\n        return this.componentContext.submitSignal(type, content);\n    }\n\n    /**\n     * Will return when the component is attached.\n     */\n    public async waitAttached(): Promise<void> {\n        return this.deferredAttached.promise;\n    }\n\n    public raiseContainerWarning(warning: ContainerWarning): void {\n        this.componentContext.raiseContainerWarning(warning);\n    }\n\n    /**\n     * Attach channel should only be called after the componentRuntime has been attached\n     */\n    private attachChannel(channel: IChannel): void {\n        this.verifyNotClosed();\n        // If this handle is already attached no need to attach again.\n        if (channel.handle.isAttached) {\n            return;\n        }\n\n        channel.handle.attachGraph();\n\n        assert(this.isAttached, \"Component should be attached to attach the channel.\");\n        // Get the object snapshot only if the component is Bound and its graph is attached too,\n        // because if the graph is attaching, then it would get included in the component snapshot.\n        if (this.bindState === BindState.Bound && this.graphAttachState === AttachState.Attached) {\n            const snapshot = snapshotChannel(channel);\n\n            const message: IAttachMessage = {\n                id: channel.id,\n                snapshot,\n                type: channel.attributes.type,\n            };\n            this.pendingAttach.set(channel.id, message);\n            this.submit(ComponentMessageType.Attach, message);\n        }\n\n        const context = this.contexts.get(channel.id) as LocalChannelContext;\n        context.attach();\n    }\n\n    private submitChannelOp(address: string, contents: any, localOpMetadata: unknown) {\n        const envelope: IEnvelope = { address, contents };\n        this.submit(ComponentMessageType.ChannelOp, envelope, localOpMetadata);\n    }\n\n    private submit(\n        type: ComponentMessageType,\n        content: any,\n        localOpMetadata: unknown = undefined): void {\n        this.verifyNotClosed();\n        this.componentContext.submitMessage(type, content, localOpMetadata);\n    }\n\n    /**\n     * For messages of type MessageType.Operation, finds the right channel and asks it to resubmit the message.\n     * For all other messages, just submit it again.\n     * This typically happens when we reconnect and there are unacked messages.\n     * @param content - The content of the original message.\n     * @param localOpMetadata - The local metadata associated with the original message.\n     */\n    public reSubmit(type: ComponentMessageType, content: any, localOpMetadata: unknown) {\n        this.verifyNotClosed();\n\n        switch (type) {\n            case ComponentMessageType.ChannelOp:\n                {\n                    // For Operations, find the right channel and trigger resubmission on it.\n                    const envelope = content as IEnvelope;\n                    const channelContext = this.contexts.get(envelope.address);\n                    assert(channelContext, \"There should be a channel context for the op\");\n                    channelContext.reSubmit(envelope.contents, localOpMetadata);\n                    break;\n                }\n            case ComponentMessageType.Attach:\n                // For Attach messages, just submit them again.\n                this.submit(type, content, localOpMetadata);\n                break;\n            default:\n                unreachableCase(type);\n        }\n    }\n\n    private setChannelDirty(address: string): void {\n        this.verifyNotClosed();\n        this.componentContext.setChannelDirty(address);\n    }\n\n    private processChannelOp(message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown) {\n        this.verifyNotClosed();\n\n        const envelope = message.contents as IEnvelope;\n\n        const transformed: ISequencedDocumentMessage = {\n            ...message,\n            contents: envelope.contents,\n        };\n\n        const channelContext = this.contexts.get(envelope.address);\n        assert(channelContext, \"Channel not found\");\n        channelContext.processOp(transformed, local, localOpMetadata);\n\n        return channelContext;\n    }\n\n    private attachListener() {\n        this.setMaxListeners(Number.MAX_SAFE_INTEGER);\n        this.componentContext.on(\"leader\", () => {\n            this.emit(\"leader\");\n        });\n        this.componentContext.on(\"notleader\", () => {\n            this.emit(\"notleader\");\n        });\n        this.componentContext.once(\"attaching\", () => {\n            assert(this.bindState !== BindState.NotBound, \"Component attaching should not occur if it is not bound\");\n            this._attachState = AttachState.Attaching;\n            // This promise resolution will be moved to attached event once we fix the scheduler.\n            this.deferredAttached.resolve();\n            this.emit(\"attaching\");\n        });\n        this.componentContext.once(\"attached\", () => {\n            assert(this.bindState === BindState.Bound, \"Component should only be attached after it is bound\");\n            this._attachState = AttachState.Attached;\n            this.emit(\"attached\");\n        });\n    }\n\n    private verifyNotClosed() {\n        if (this._disposed) {\n            throw new Error(\"Runtime is closed\");\n        }\n    }\n}\n"]}