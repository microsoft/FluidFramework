{"version":3,"file":"componentHandle.js","sourceRoot":"","sources":["../src/componentHandle.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAUH,OAAO,EAAE,WAAW,EAAE,MAAM,uCAAuC,CAAC;AACpE,OAAO,EAAE,yBAAyB,EAAE,MAAM,+BAA+B,CAAC;AAE1E,MAAM,OAAO,gBAAgB;IAczB;;;;;OAKG;IACH,YACuB,KAAQ,EACX,IAAY,EACZ,YAAiC;QAF9B,UAAK,GAAL,KAAK,CAAG;QACX,SAAI,GAAJ,IAAI,CAAQ;QACZ,iBAAY,GAAZ,YAAY,CAAqB;QAtBrD,2GAA2G;QACnG,qBAAgB,GAAgB,WAAW,CAAC,QAAQ,CAAC;QAuBzD,IAAI,CAAC,YAAY,GAAG,yBAAyB,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;IAC3E,CAAC;IApBD,IAAW,YAAY,KAAmB,OAAO,IAAI,CAAC,CAAC,CAAC;IACxD,IAAW,mBAAmB,KAA0B,OAAO,IAAI,CAAC,CAAC,CAAC;IACtE,IAAW,YAAY,KAAmB,OAAO,IAAI,CAAC,CAAC,CAAC;IAExD,IAAW,UAAU;QACjB,OAAO,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC;IACxC,CAAC;IAgBM,KAAK,CAAC,GAAG;QACZ,OAAO,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;IAEM,WAAW;QACd,kGAAkG;QAClG,IAAI,IAAI,CAAC,gBAAgB,KAAK,WAAW,CAAC,QAAQ,EAAE;YAChD,OAAO;SACV;QACD,IAAI,CAAC,gBAAgB,GAAG,WAAW,CAAC,SAAS,CAAC;QAC9C,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE;YAC1B,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,KAAK,EAAE;gBAC7B,MAAM,CAAC,WAAW,EAAE,CAAC;aACxB;YAED,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;SAC1B;QACD,IAAI,CAAC,YAAY,CAAC,WAAW,EAAE,CAAC;QAChC,IAAI,CAAC,gBAAgB,GAAG,WAAW,CAAC,QAAQ,CAAC;IACjD,CAAC;IAEM,IAAI,CAAC,MAAoB;QAC5B,yFAAyF;QACzF,uCAAuC;QACvC,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,gBAAgB,KAAK,WAAW,CAAC,QAAQ,EAAE;YACnE,MAAM,CAAC,WAAW,EAAE,CAAC;YACrB,OAAO;SACV;QACD,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE;YAC1B,IAAI,CAAC,KAAK,GAAG,IAAI,GAAG,EAAgB,CAAC;SACxC;QAED,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IAC3B,CAAC;IAEM,KAAK,CAAC,OAAO,CAAC,OAAiB;QAClC,IAAI,IAAI,CAAC,KAAK,CAAC,YAAY,KAAK,SAAS,EAAE;YACvC,OAAO,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;SACnD;aAAM;YACH,OAAO,EAAE,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAE,YAAY,EAAE,KAAK,EAAE,GAAG,OAAO,CAAC,GAAG,YAAY,EAAE,CAAC;SACrF;IACL,CAAC;CACJ","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    IFluidObject,\n    IFluidHandle,\n    IFluidHandleContext,\n    IFluidRouter,\n    IRequest,\n    IResponse,\n} from \"@fluidframework/component-core-interfaces\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { generateHandleContextPath } from \"@fluidframework/runtime-utils\";\n\nexport class FluidOjectHandle<T extends IFluidObject = IFluidObject> implements IFluidHandle {\n    // This is used to break the recursion while attaching the graph. Also tells the attach state of the graph.\n    private graphAttachState: AttachState = AttachState.Detached;\n    private bound: Set<IFluidHandle> | undefined;\n    public readonly absolutePath: string;\n\n    public get IFluidRouter(): IFluidRouter { return this; }\n    public get IFluidHandleContext(): IFluidHandleContext { return this; }\n    public get IFluidHandle(): IFluidHandle { return this; }\n\n    public get isAttached(): boolean {\n        return this.routeContext.isAttached;\n    }\n\n    /**\n     * Creates a new FluidOjectHandle.\n     * @param value - The IFluidObject object this handle is for.\n     * @param path - The path to this handle relative to the routeContext.\n     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.\n     */\n    constructor(\n        protected readonly value: T,\n        public readonly path: string,\n        public readonly routeContext: IFluidHandleContext,\n    ) {\n        this.absolutePath = generateHandleContextPath(path, this.routeContext);\n    }\n\n    public async get(): Promise<any> {\n        return this.value;\n    }\n\n    public attachGraph(): void {\n        // If this handle is already in attaching state in the graph or attached, no need to attach again.\n        if (this.graphAttachState !== AttachState.Detached) {\n            return;\n        }\n        this.graphAttachState = AttachState.Attaching;\n        if (this.bound !== undefined) {\n            for (const handle of this.bound) {\n                handle.attachGraph();\n            }\n\n            this.bound = undefined;\n        }\n        this.routeContext.attachGraph();\n        this.graphAttachState = AttachState.Attached;\n    }\n\n    public bind(handle: IFluidHandle) {\n        // If the dds is already attached or its graph is already in attaching or attached state,\n        // then attach the incoming handle too.\n        if (this.isAttached || this.graphAttachState !== AttachState.Detached) {\n            handle.attachGraph();\n            return;\n        }\n        if (this.bound === undefined) {\n            this.bound = new Set<IFluidHandle>();\n        }\n\n        this.bound.add(handle);\n    }\n\n    public async request(request: IRequest): Promise<IResponse> {\n        if (this.value.IFluidRouter !== undefined) {\n            return this.value.IFluidRouter.request(request);\n        } else {\n            return { status: 404, mimeType: \"text/plain\", value: `${request.url} not found` };\n        }\n    }\n}\n"]}