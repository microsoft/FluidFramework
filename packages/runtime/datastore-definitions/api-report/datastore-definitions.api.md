## API Report File for "@fluidframework/datastore-definitions"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AttachState } from '@fluidframework/container-definitions';
import { FluidObject } from '@fluidframework/core-interfaces';
import { IAudience } from '@fluidframework/container-definitions';
import { IDeltaManager } from '@fluidframework/container-definitions';
import { IDisposable } from '@fluidframework/core-interfaces';
import { IDocumentMessage } from '@fluidframework/protocol-definitions';
import { IEvent } from '@fluidframework/core-interfaces';
import { IEventProvider } from '@fluidframework/core-interfaces';
import { IExperimentalIncrementalSummaryContext } from '@fluidframework/runtime-definitions';
import { IFluidHandle } from '@fluidframework/core-interfaces';
import { IFluidHandleContext } from '@fluidframework/core-interfaces';
import { IFluidLoadable } from '@fluidframework/core-interfaces';
import { IGarbageCollectionData } from '@fluidframework/runtime-definitions';
import { IIdCompressor } from '@fluidframework/id-compressor';
import { IInboundSignalMessage } from '@fluidframework/runtime-definitions';
import { ILoaderOptions } from '@fluidframework/container-definitions';
import { IQuorumClients } from '@fluidframework/protocol-definitions';
import { ISequencedDocumentMessage } from '@fluidframework/protocol-definitions';
import { ISummaryTreeWithStats } from '@fluidframework/runtime-definitions';
import { ITelemetryContext } from '@fluidframework/runtime-definitions';
import { ITelemetryLogger } from '@fluidframework/core-interfaces';

// @public (undocumented)
export interface IChannel extends IFluidLoadable {
    // (undocumented)
    readonly attributes: IChannelAttributes;
    connect(services: IChannelServices): void;
    getAttachSummary(fullTree?: boolean, trackState?: boolean, telemetryContext?: ITelemetryContext): ISummaryTreeWithStats;
    getGCData(fullGC?: boolean): IGarbageCollectionData;
    readonly id: string;
    isAttached(): boolean;
    summarize(fullTree?: boolean, trackState?: boolean, telemetryContext?: ITelemetryContext, incrementalSummaryContext?: IExperimentalIncrementalSummaryContext): Promise<ISummaryTreeWithStats>;
}

// @public
export interface IChannelAttributes {
    readonly packageVersion?: string;
    readonly snapshotFormatVersion: string;
    readonly type: string;
}

// @public
export interface IChannelFactory {
    readonly attributes: IChannelAttributes;
    create(runtime: IFluidDataStoreRuntime, id: string): IChannel;
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, channelAttributes: Readonly<IChannelAttributes>): Promise<IChannel>;
    readonly type: string;
}

// @public
export interface IChannelServices {
    // (undocumented)
    deltaConnection: IDeltaConnection;
    // (undocumented)
    objectStorage: IChannelStorageService;
}

// @public
export interface IChannelStorageService {
    contains(path: string): Promise<boolean>;
    list(path: string): Promise<string[]>;
    readBlob(path: string): Promise<ArrayBufferLike>;
}

// @public
export interface IDeltaConnection {
    addedGCOutboundReference?(srcHandle: IFluidHandle, outboundHandle: IFluidHandle): void;
    attach(handler: IDeltaHandler): void;
    // (undocumented)
    connected: boolean;
    dirty(): void;
    submit(messageContent: any, localOpMetadata: unknown): void;
}

// @public
export interface IDeltaHandler {
    applyStashedOp(message: any): unknown;
    process: (message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown) => void;
    reSubmit(message: any, localOpMetadata: unknown): void;
    rollback?(message: any, localOpMetadata: unknown): void;
    setConnectionState(connected: boolean): void;
}

// @public
export interface IFluidDataStoreRuntime extends IEventProvider<IFluidDataStoreRuntimeEvents>, IDisposable {
    readonly attachState: AttachState;
    bindChannel(channel: IChannel): void;
    // (undocumented)
    readonly channelsRoutingContext: IFluidHandleContext;
    // (undocumented)
    readonly clientId: string | undefined;
    // (undocumented)
    readonly connected: boolean;
    createChannel(id: string | undefined, type: string): IChannel;
    // (undocumented)
    readonly deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;
    ensureNoDataModelChanges<T>(callback: () => T): T;
    readonly entryPoint: IFluidHandle<FluidObject>;
    getAudience(): IAudience;
    getChannel(id: string): Promise<IChannel>;
    getQuorum(): IQuorumClients;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly idCompressor?: IIdCompressor;
    // (undocumented)
    readonly IFluidHandleContext: IFluidHandleContext;
    // (undocumented)
    readonly logger: ITelemetryLogger;
    // (undocumented)
    readonly objectsRoutingContext: IFluidHandleContext;
    // (undocumented)
    readonly options: ILoaderOptions;
    // (undocumented)
    readonly rootRoutingContext: IFluidHandleContext;
    submitSignal(type: string, content: any, targetClientId?: string): void;
    uploadBlob(blob: ArrayBufferLike, signal?: AbortSignal): Promise<IFluidHandle<ArrayBufferLike>>;
    waitAttached(): Promise<void>;
}

// @public
export interface IFluidDataStoreRuntimeEvents extends IEvent {
    // (undocumented)
    (event: "disconnected" | "dispose" | "attaching" | "attached", listener: () => void): any;
    // (undocumented)
    (event: "op", listener: (message: ISequencedDocumentMessage) => void): any;
    // (undocumented)
    (event: "signal", listener: (message: IInboundSignalMessage, local: boolean) => void): any;
    // (undocumented)
    (event: "connected", listener: (clientId: string) => void): any;
}

// @alpha (undocumented)
export interface Internal_InterfaceOfJsonableTypesWith<T> {
    // (undocumented)
    [index: string | number]: JsonableTypeWith<T>;
}

// @alpha
export type Jsonable<T, TReplaced = never> = boolean extends (T extends never ? true : false) ? JsonableTypeWith<TReplaced> : unknown extends T ? JsonableTypeWith<TReplaced> : T extends undefined | null | boolean | number | string | TReplaced ? T : Extract<T, Function> extends never ? T extends object ? T extends (infer U)[] ? Jsonable<U, TReplaced>[] : {
    [K in keyof T]: Extract<K, symbol> extends never ? Jsonable<T[K], TReplaced> : never;
} : never : never;

// @alpha
export type JsonableTypeWith<T> = undefined | null | boolean | number | string | T | Internal_InterfaceOfJsonableTypesWith<T> | ArrayLike<JsonableTypeWith<T>>;

// @alpha
export type Serializable<T> = Jsonable<T, IFluidHandle>;

```
