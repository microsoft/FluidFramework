## API Report File for "@fluidframework/datastore-definitions"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { AttachState } from '@fluidframework/container-definitions';
import type { ErasedType } from '@fluidframework/core-interfaces';
import type { FluidObject } from '@fluidframework/core-interfaces';
import type { IAudience } from '@fluidframework/container-definitions';
import type { IDisposable } from '@fluidframework/core-interfaces';
import type { IEvent } from '@fluidframework/core-interfaces';
import type { IEventProvider } from '@fluidframework/core-interfaces';
import type { IExperimentalIncrementalSummaryContext } from '@fluidframework/runtime-definitions/internal';
import type { IFluidHandle } from '@fluidframework/core-interfaces';
import type { IFluidHandleContext } from '@fluidframework/core-interfaces/internal';
import type { IFluidLoadable } from '@fluidframework/core-interfaces';
import type { IGarbageCollectionData } from '@fluidframework/runtime-definitions/internal';
import type { IIdCompressor } from '@fluidframework/id-compressor';
import type { IInboundSignalMessage } from '@fluidframework/runtime-definitions';
import type { IQuorumClients } from '@fluidframework/driver-definitions';
import type { ISequencedDocumentMessage } from '@fluidframework/driver-definitions';
import type { ISummaryTreeWithStats } from '@fluidframework/runtime-definitions/internal';
import type { ITelemetryBaseLogger } from '@fluidframework/core-interfaces';
import type { ITelemetryContext } from '@fluidframework/runtime-definitions/internal';

// @alpha (undocumented)
export interface IChannel extends IFluidLoadable {
    // (undocumented)
    readonly attributes: IChannelAttributes;
    connect(services: IChannelServices): void;
    getAttachSummary(fullTree?: boolean, trackState?: boolean, telemetryContext?: ITelemetryContext): ISummaryTreeWithStats;
    getGCData(fullGC?: boolean): IGarbageCollectionData;
    readonly id: string;
    isAttached(): boolean;
    summarize(fullTree?: boolean, trackState?: boolean, telemetryContext?: ITelemetryContext, incrementalSummaryContext?: IExperimentalIncrementalSummaryContext): Promise<ISummaryTreeWithStats>;
}

// @alpha
export interface IChannelAttributes {
    readonly packageVersion?: string;
    readonly snapshotFormatVersion: string;
    readonly type: string;
}

// @alpha
export interface IChannelFactory<out TChannel = unknown> {
    readonly attributes: IChannelAttributes;
    create(runtime: IFluidDataStoreRuntime, id: string): TChannel & IChannel;
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, channelAttributes: Readonly<IChannelAttributes>): Promise<TChannel & IChannel>;
    readonly type: string;
}

// @alpha
export interface IChannelServices {
    // (undocumented)
    deltaConnection: IDeltaConnection;
    // (undocumented)
    objectStorage: IChannelStorageService;
}

// @alpha
export interface IChannelStorageService {
    contains(path: string): Promise<boolean>;
    list(path: string): Promise<string[]>;
    readBlob(path: string): Promise<ArrayBufferLike>;
}

// @alpha
export interface IDeltaConnection {
    // @deprecated (undocumented)
    addedGCOutboundReference?(srcHandle: IFluidHandle, outboundHandle: IFluidHandle): void;
    attach(handler: IDeltaHandler): void;
    // (undocumented)
    connected: boolean;
    dirty(): void;
    submit(messageContent: any, localOpMetadata: unknown): void;
}

// @alpha
export interface IDeltaHandler {
    applyStashedOp(message: any): void;
    process: (message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown) => void;
    reSubmit(message: any, localOpMetadata: unknown): void;
    rollback?(message: any, localOpMetadata: unknown): void;
    setConnectionState(connected: boolean): void;
}

// @alpha
export type IDeltaManagerErased = ErasedType<"@fluidframework/container-definitions.IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>">;

// @alpha @sealed
export interface IFluidDataStoreRuntime extends IEventProvider<IFluidDataStoreRuntimeEvents>, IDisposable {
    addChannel(channel: IChannel): void;
    readonly attachState: AttachState;
    bindChannel(channel: IChannel): void;
    // (undocumented)
    readonly channelsRoutingContext: IFluidHandleContext;
    // (undocumented)
    readonly clientId: string | undefined;
    // (undocumented)
    readonly connected: boolean;
    createChannel(id: string | undefined, type: string): IChannel;
    // (undocumented)
    readonly deltaManager: IDeltaManagerErased;
    readonly entryPoint: IFluidHandle<FluidObject>;
    getAudience(): IAudience;
    getChannel(id: string): Promise<IChannel>;
    getQuorum(): IQuorumClients;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly idCompressor?: IIdCompressor;
    // (undocumented)
    readonly IFluidHandleContext: IFluidHandleContext;
    // (undocumented)
    readonly logger: ITelemetryBaseLogger;
    // (undocumented)
    readonly objectsRoutingContext: IFluidHandleContext;
    // (undocumented)
    readonly options: Record<string | number, any>;
    // (undocumented)
    readonly rootRoutingContext: IFluidHandleContext;
    submitSignal: (type: string, content: unknown, targetClientId?: string) => void;
    uploadBlob(blob: ArrayBufferLike, signal?: AbortSignal): Promise<IFluidHandle<ArrayBufferLike>>;
    waitAttached(): Promise<void>;
}

// @alpha
export interface IFluidDataStoreRuntimeEvents extends IEvent {
    // (undocumented)
    (event: "disconnected" | "dispose" | "attaching" | "attached", listener: () => void): any;
    // (undocumented)
    (event: "op", listener: (message: ISequencedDocumentMessage) => void): any;
    // (undocumented)
    (event: "signal", listener: (message: IInboundSignalMessage, local: boolean) => void): any;
    // (undocumented)
    (event: "connected", listener: (clientId: string) => void): any;
}

// @alpha (undocumented)
export interface Internal_InterfaceOfJsonableTypesWith<T> {
    // (undocumented)
    [index: string | number]: JsonableTypeWith<T>;
}

// @alpha
export type Jsonable<T, TReplaced = never> = boolean extends (T extends never ? true : false) ? JsonableTypeWith<TReplaced> : unknown extends T ? JsonableTypeWith<TReplaced> : T extends undefined | null | boolean | number | string | TReplaced ? T : Extract<T, Function> extends never ? T extends object ? T extends (infer U)[] ? Jsonable<U, TReplaced>[] : {
    [K in keyof T]: Extract<K, symbol> extends never ? Jsonable<T[K], TReplaced> : never;
} : never : never;

// @alpha
export type JsonableTypeWith<T> = undefined | null | boolean | number | string | T | Internal_InterfaceOfJsonableTypesWith<T> | ArrayLike<JsonableTypeWith<T>>;

// @alpha
export type Serializable<T> = Jsonable<T, IFluidHandle>;

```
