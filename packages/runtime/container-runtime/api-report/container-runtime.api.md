## API Report File for "@fluidframework/container-runtime"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AliasResult } from '@fluidframework/runtime-definitions/internal';
import { AttachState } from '@fluidframework/container-definitions';
import { ContainerWarning } from '@fluidframework/container-definitions/internal';
import { CreateChildSummarizerNodeFn } from '@fluidframework/runtime-definitions/internal';
import { CreateChildSummarizerNodeParam } from '@fluidframework/runtime-definitions/internal';
import { FluidDataStoreRegistryEntry } from '@fluidframework/runtime-definitions/internal';
import { FluidObject } from '@fluidframework/core-interfaces';
import { FlushMode } from '@fluidframework/runtime-definitions/internal';
import { IAudience } from '@fluidframework/container-definitions';
import { IClientDetails } from '@fluidframework/driver-definitions';
import { IContainerContext } from '@fluidframework/container-definitions/internal';
import { IContainerRuntime } from '@fluidframework/container-runtime-definitions/internal';
import { IContainerRuntimeBase } from '@fluidframework/runtime-definitions/internal';
import { IContainerRuntimeEvents } from '@fluidframework/container-runtime-definitions/internal';
import { ICriticalContainerError } from '@fluidframework/container-definitions';
import { IDataStore } from '@fluidframework/runtime-definitions/internal';
import { IDeltaManager } from '@fluidframework/container-definitions/internal';
import { IDisposable } from '@fluidframework/core-interfaces';
import { IDocumentMessage } from '@fluidframework/driver-definitions/internal';
import { IDocumentStorageService } from '@fluidframework/driver-definitions/internal';
import { IEnvelope } from '@fluidframework/runtime-definitions/internal';
import { IEvent } from '@fluidframework/core-interfaces';
import { IEventProvider } from '@fluidframework/core-interfaces';
import { IFluidDataStoreChannel } from '@fluidframework/runtime-definitions/internal';
import { IFluidDataStoreContext } from '@fluidframework/runtime-definitions/internal';
import { IFluidDataStoreContextDetached } from '@fluidframework/runtime-definitions/internal';
import { IFluidDataStoreFactory } from '@fluidframework/runtime-definitions/internal';
import { IFluidDataStoreRegistry } from '@fluidframework/runtime-definitions/internal';
import { IFluidHandle } from '@fluidframework/core-interfaces';
import { IFluidHandleContext } from '@fluidframework/core-interfaces/internal';
import { IFluidHandleInternal } from '@fluidframework/core-interfaces/internal';
import { IFluidParentContext } from '@fluidframework/runtime-definitions/internal';
import { IGarbageCollectionData } from '@fluidframework/runtime-definitions/internal';
import { IGarbageCollectionDetailsBase } from '@fluidframework/runtime-definitions/internal';
import { IGetPendingLocalStateProps } from '@fluidframework/container-definitions/internal';
import type { IIdCompressor } from '@fluidframework/id-compressor';
import type { IIdCompressorCore } from '@fluidframework/id-compressor/internal';
import { IInboundSignalMessage } from '@fluidframework/runtime-definitions';
import { IProvideFluidHandleContext } from '@fluidframework/core-interfaces/internal';
import { IQuorumClients } from '@fluidframework/driver-definitions';
import { IRequest } from '@fluidframework/core-interfaces';
import { IResponse } from '@fluidframework/core-interfaces';
import { IRuntime } from '@fluidframework/container-definitions/internal';
import { ISequencedDocumentMessage } from '@fluidframework/driver-definitions';
import { ISignalMessage } from '@fluidframework/driver-definitions';
import type { ISnapshot } from '@fluidframework/driver-definitions/internal';
import { ISnapshotTree } from '@fluidframework/driver-definitions/internal';
import { ISummarizeResult } from '@fluidframework/runtime-definitions/internal';
import { ISummarizerNodeWithGC } from '@fluidframework/runtime-definitions/internal';
import { ISummaryAck } from '@fluidframework/driver-definitions/internal';
import { ISummaryContent } from '@fluidframework/driver-definitions/internal';
import { ISummaryNack } from '@fluidframework/driver-definitions/internal';
import { ISummaryStats } from '@fluidframework/runtime-definitions/internal';
import { ISummaryTree } from '@fluidframework/driver-definitions';
import { ISummaryTreeWithStats } from '@fluidframework/runtime-definitions/internal';
import { ITelemetryBaseLogger } from '@fluidframework/core-interfaces';
import { ITelemetryContext } from '@fluidframework/runtime-definitions/internal';
import { ITelemetryLoggerExt } from '@fluidframework/telemetry-utils/internal';
import { MessageType } from '@fluidframework/driver-definitions/internal';
import { MonitoringContext } from '@fluidframework/telemetry-utils/internal';
import { NamedFluidDataStoreRegistryEntries } from '@fluidframework/runtime-definitions/internal';
import { SummarizeInternalFn } from '@fluidframework/runtime-definitions/internal';
import { TypedEventEmitter } from '@fluid-internal/client-utils';

// @internal
export const agentSchedulerId = "_scheduler";

// @internal
export const AllowInactiveRequestHeaderKey = "allowInactive";

// @alpha
export const AllowTombstoneRequestHeaderKey = "allowTombstone";

// @internal
export class ChannelCollection implements IFluidDataStoreChannel, IDisposable {
    constructor(baseSnapshot: ISnapshotTree | ISnapshot | undefined, parentContext: IFluidParentContext, baseLogger: ITelemetryBaseLogger, gcNodeUpdated: (props: IGCNodeUpdatedProps) => void, isDataStoreDeleted: (nodePath: string) => boolean, aliasMap: Map<string, string>, provideEntryPoint: (runtime: ChannelCollection) => Promise<FluidObject>);
    // (undocumented)
    get aliases(): ReadonlyMap<string, string>;
    // (undocumented)
    protected applyStashedChannelChannelOp(envelope: IEnvelope): Promise<unknown>;
    // (undocumented)
    applyStashedOp(content: unknown): Promise<unknown>;
    // (undocumented)
    readonly attachOpFiredForDataStore: Set<string>;
    // (undocumented)
    protected readonly baseSnapshot: ISnapshotTree | ISnapshot | undefined;
    // (undocumented)
    readonly containerLoadStats: {
        readonly containerLoadDataStoreCount: number;
        readonly referencedDataStoreCount: number;
    };
    // (undocumented)
    protected readonly contexts: DataStoreContexts;
    // (undocumented)
    protected createContext<T extends LocalFluidDataStoreContext>(id: string, pkg: Readonly<string[]>, contextCtor: new (props: ILocalDetachedFluidDataStoreContextProps) => T, createProps?: any, loadingGroupId?: string): T;
    // (undocumented)
    createDataStoreContext(pkg: Readonly<string[]>, props?: any, loadingGroupId?: string): IFluidDataStoreContextInternal;
    protected createDataStoreId(): string;
    // (undocumented)
    createDetachedDataStore(pkg: Readonly<string[]>, loadingGroupId?: string): IFluidDataStoreContextDetached;
    // (undocumented)
    deleteChild(dataStoreId: string): void;
    deleteSweepReadyNodes(sweepReadyDataStoreRoutes: readonly string[]): readonly string[];
    // (undocumented)
    readonly dispose: () => void;
    // (undocumented)
    get disposed(): boolean;
    // (undocumented)
    readonly entryPoint: IFluidHandleInternal<FluidObject>;
    getAttachSummary(telemetryContext?: ITelemetryContext): ISummaryTreeWithStats;
    getDataStoreIfAvailable(id: string, requestHeaderData: RuntimeHeaderData): Promise<IFluidDataStoreContextInternal | undefined>;
    getDataStorePackagePath(nodePath: string): Promise<readonly string[] | undefined>;
    getGCData(fullGC?: boolean): Promise<IGarbageCollectionData>;
    getGCNodeType(nodePath: string): GCNodeType | undefined;
    // (undocumented)
    internalId(maybeAlias: string): string;
    makeVisibleAndAttachGraph(): void;
    // (undocumented)
    protected readonly mc: MonitoringContext;
    // (undocumented)
    readonly parentContext: IFluidParentContext;
    // (undocumented)
    get pendingAliases(): Map<string, Promise<AliasResult>>;
    // (undocumented)
    process(message: ISequencedDocumentMessage, local: boolean, localMessageMetadata: unknown, addedOutboundReference?: (fromNodePath: string, toNodePath: string) => void): void;
    // (undocumented)
    processAliasMessageCore(internalId: string, alias: string): boolean;
    // (undocumented)
    protected processChannelOp(address: string, message: ISequencedDocumentMessage, local: boolean, localMessageMetadata: unknown): void;
    // (undocumented)
    processSignal(messageArg: IInboundSignalMessage, local: boolean): void;
    // (undocumented)
    request(request: IRequest): Promise<IResponse>;
    // (undocumented)
    reSubmit(type: string, content: any, localOpMetadata: unknown): void;
    // (undocumented)
    protected reSubmitChannelOp(type: string, content: any, localOpMetadata: unknown): void;
    // (undocumented)
    rollback(type: string, content: any, localOpMetadata: unknown): void;
    // (undocumented)
    setAttachState(attachState: AttachState.Attaching | AttachState.Attached): void;
    // (undocumented)
    setConnectionState(connected: boolean, clientId?: string): void;
    // (undocumented)
    get size(): number;
    // (undocumented)
    protected submitAttachChannelOp(localContext: LocalFluidDataStoreContext): void;
    // (undocumented)
    summarize(fullTree: boolean, trackState: boolean, telemetryContext?: ITelemetryContext): Promise<ISummaryTreeWithStats>;
    updateStateBeforeGC(): Promise<void>;
    updateTombstonedRoutes(tombstonedRoutes: readonly string[]): void;
    updateUsedRoutes(usedRoutes: readonly string[]): void;
    // (undocumented)
    waitIfPendingAlias(maybeAlias: string): Promise<AliasResult>;
    // (undocumented)
    protected wrapContextForInnerChannel(id: string): IFluidParentContext;
}

// @internal (undocumented)
export class ChannelCollectionFactory<T extends ChannelCollection = ChannelCollection> implements IFluidDataStoreFactory {
    constructor(registryEntries: NamedFluidDataStoreRegistryEntries, provideEntryPoint: (runtime: IFluidDataStoreChannel) => Promise<FluidObject>, ctor: (...args: ConstructorParameters<typeof ChannelCollection>) => T);
    // (undocumented)
    get IFluidDataStoreFactory(): this;
    // (undocumented)
    IFluidDataStoreRegistry: IFluidDataStoreRegistry;
    // (undocumented)
    instantiateDataStore(context: IFluidDataStoreContext, _existing: boolean): Promise<IFluidDataStoreChannel>;
    // (undocumented)
    readonly type = "ChannelCollectionChannel";
}

// @internal
export type CompatModeBehavior =
/** Ignore the op. It won't be persisted if this client summarizes */
"Ignore"
/** Fail processing immediately. (The container will close) */
| "FailToProcess";

// @alpha
export enum CompressionAlgorithms {
    // (undocumented)
    lz4 = "lz4"
}

// @alpha (undocumented)
export enum ContainerMessageType {
    // (undocumented)
    Alias = "alias",
    // (undocumented)
    Attach = "attach",
    // (undocumented)
    BlobAttach = "blobAttach",
    // (undocumented)
    ChunkedOp = "chunkedOp",
    DocumentSchemaChange = "schema",
    // (undocumented)
    FluidDataStoreOp = "component",
    GC = "GC",
    IdAllocation = "idAllocation",
    // (undocumented)
    Rejoin = "rejoin"
}

// @alpha
export class ContainerRuntime extends TypedEventEmitter<IContainerRuntimeEvents & ISummarizerEvents> implements IContainerRuntime, IRuntime, ISummarizerRuntime, ISummarizerInternalsProvider, IProvideFluidHandleContext {
    protected constructor(context: IContainerContext, registry: IFluidDataStoreRegistry, metadata: IContainerRuntimeMetadata | undefined, electedSummarizerData: ISerializedElection | undefined, chunks: [string, string[]][], dataStoreAliasMap: [string, string][], runtimeOptions: Readonly<Required<IContainerRuntimeOptions>>, containerScope: FluidObject, baseLogger: ITelemetryBaseLogger, existing: boolean, blobManagerSnapshot: IBlobManagerLoadInfo, _storage: IDocumentStorageService, createIdCompressor: () => Promise<IIdCompressor & IIdCompressorCore>, documentsSchemaController: DocumentsSchemaController, featureGatesForTelemetry: Record<string, boolean | number | undefined>, provideEntryPoint: (containerRuntime: IContainerRuntime) => Promise<FluidObject>, requestHandler?: ((request: IRequest, runtime: IContainerRuntime) => Promise<IResponse>) | undefined, summaryConfiguration?: ISummaryConfiguration);
    // (undocumented)
    protected addContainerStateToSummary(summaryTree: ISummaryTreeWithStats, fullTree: boolean, trackState: boolean, telemetryContext?: ITelemetryContext): void;
    addedGCOutboundReference(srcHandle: {
        absolutePath: string;
    }, outboundHandle: {
        absolutePath: string;
    }): void;
    // (undocumented)
    get attachState(): AttachState;
    // (undocumented)
    readonly baseLogger: ITelemetryBaseLogger;
    // (undocumented)
    readonly clientDetails: IClientDetails;
    // (undocumented)
    get clientId(): string | undefined;
    // (undocumented)
    readonly closeFn: (error?: ICriticalContainerError) => void;
    collectGarbage(options: {
        logger?: ITelemetryLoggerExt;
        runSweep?: boolean;
        fullGC?: boolean;
    }, telemetryContext?: ITelemetryContext): Promise<IGCStats | undefined>;
    // (undocumented)
    get connected(): boolean;
    // (undocumented)
    get containerRuntime(): this;
    // (undocumented)
    createDataStore(pkg: Readonly<string | string[]>, loadingGroupId?: string): Promise<IDataStore>;
    // @deprecated (undocumented)
    _createDataStoreWithProps(pkg: Readonly<string | string[]>, props?: any): Promise<IDataStore>;
    // (undocumented)
    createDetachedDataStore(pkg: Readonly<string[]>, loadingGroupId?: string): IFluidDataStoreContextDetached;
    createSummary(blobRedirectTable?: Map<string, string>, telemetryContext?: ITelemetryContext): ISummaryTree;
    // (undocumented)
    deleteChildSummarizerNode(id: string): void;
    deleteSweepReadyNodes(sweepReadyRoutes: readonly string[]): readonly string[];
    readonly deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;
    // (undocumented)
    dispose(error?: Error): void;
    // (undocumented)
    get disposed(): boolean;
    // (undocumented)
    readonly disposeFn: (error?: ICriticalContainerError) => void;
    // (undocumented)
    enqueueSummarize(options: IEnqueueSummarizeOptions): EnqueueSummarizeResult;
    ensureNoDataModelChanges<T>(callback: () => T): T;
    // (undocumented)
    get flushMode(): FlushMode;
    get gcThrowOnTombstoneUsage(): boolean;
    get gcTombstoneEnforcementAllowed(): boolean;
    generateDocumentUniqueId(): string | (number & {
        readonly SessionUnique: "cea55054-6b82-4cbf-ad19-1fa645ea3b3e";
    } & {
        readonly OpNormalized: "9209432d-a959-4df7-b2ad-767ead4dbcae";
    });
    // (undocumented)
    readonly getAbsoluteUrl: (relativeUrl: string) => Promise<string | undefined>;
    getAliasedDataStoreEntryPoint(alias: string): Promise<IFluidHandle<FluidObject> | undefined>;
    // (undocumented)
    getAudience(): IAudience;
    // (undocumented)
    getCreateChildSummarizerNodeFn(id: string, createParam: CreateChildSummarizerNodeParam): (summarizeInternal: SummarizeInternalFn, getGCDataFn: (fullGC?: boolean) => Promise<IGarbageCollectionData>) => ISummarizerNodeWithGC;
    getCurrentReferenceTimestampMs(): number | undefined;
    getEntryPoint(): Promise<FluidObject>;
    getGCData(fullGC?: boolean): Promise<IGarbageCollectionData>;
    getGCNodePackagePath(nodePath: string): Promise<readonly string[] | undefined>;
    getNodeType(nodePath: string): GCNodeType;
    // (undocumented)
    getPendingLocalState(props?: IGetPendingLocalStateProps): unknown;
    // (undocumented)
    getQuorum(): IQuorumClients;
    getSnapshotForLoadingGroupId(loadingGroupIds: string[], pathParts: string[]): Promise<{
        snapshotTree: ISnapshotTree;
        sequenceNumber: number;
    }>;
    get idCompressor(): (IIdCompressor & IIdCompressorCore) | undefined;
    // (undocumented)
    get idCompressorMode(): IdCompressorMode;
    // (undocumented)
    get IFluidDataStoreRegistry(): IFluidDataStoreRegistry;
    // (undocumented)
    get IFluidHandleContext(): IFluidHandleContext;
    get isDirty(): boolean;
    protected _loadIdCompressor: Promise<void> | undefined;
    static loadRuntime(params: {
        context: IContainerContext;
        registryEntries: NamedFluidDataStoreRegistryEntries;
        existing: boolean;
        runtimeOptions?: IContainerRuntimeOptions;
        containerScope?: FluidObject;
        containerRuntimeCtor?: typeof ContainerRuntime;
        requestHandler?: (request: IRequest, runtime: IContainerRuntime) => Promise<IResponse>;
        provideEntryPoint: (containerRuntime: IContainerRuntime) => Promise<FluidObject>;
    }): Promise<ContainerRuntime>;
    // (undocumented)
    makeLocallyVisible(): void;
    // (undocumented)
    notifyOpReplay(message: ISequencedDocumentMessage): Promise<void>;
    // (undocumented)
    onSchemaChange(schema: IDocumentSchemaCurrent): void;
    // (undocumented)
    readonly options: Record<string | number, any>;
    orderSequentially<T>(callback: () => T): T;
    // (undocumented)
    process(messageArg: ISequencedDocumentMessage, local: boolean): void;
    // (undocumented)
    processSignal(message: ISignalMessage, local: boolean): void;
    refreshLatestSummaryAck(options: IRefreshSummaryAckOptions): Promise<void>;
    resolveHandle(request: IRequest): Promise<IResponse>;
    // (undocumented)
    get scope(): FluidObject;
    get sessionSchema(): {
        explicitSchemaControl?: true | undefined;
        compressionLz4?: true | undefined;
        idCompressorMode?: IdCompressorMode;
        opGroupingEnabled?: true | undefined;
        disallowedVersions?: string[] | undefined;
    };
    // (undocumented)
    setAttachState(attachState: AttachState.Attaching | AttachState.Attached): void;
    // (undocumented)
    setChannelDirty(address: string): void;
    // (undocumented)
    setConnectionState(connected: boolean, clientId?: string): void;
    // (undocumented)
    get storage(): IDocumentStorageService;
    // (undocumented)
    submitMessage(type: ContainerMessageType.FluidDataStoreOp | ContainerMessageType.Alias | ContainerMessageType.Attach, contents: any, localOpMetadata?: unknown): void;
    submitSignal(type: string, content: unknown, targetClientId?: string): void;
    submitSummary(options: ISubmitSummaryOptions): Promise<SubmitSummaryResult>;
    summarize(options: {
        fullTree?: boolean;
        trackState?: boolean;
        summaryLogger?: ITelemetryLoggerExt;
        runGC?: boolean;
        fullGC?: boolean;
        runSweep?: boolean;
    }): Promise<ISummaryTreeWithStats>;
    // (undocumented)
    summarizeOnDemand(options: IOnDemandSummarizeOptions): ISummarizeResults;
    get summarizerClientId(): string | undefined;
    updateStateBeforeGC(): Promise<void>;
    updateTombstonedRoutes(tombstonedRoutes: readonly string[]): void;
    updateUsedRoutes(usedRoutes: readonly string[]): void;
    // (undocumented)
    uploadBlob(blob: ArrayBufferLike, signal?: AbortSignal): Promise<IFluidHandleInternal<ArrayBufferLike>>;
}

// @internal @deprecated
export interface ContainerRuntimeMessage {
    compatDetails?: IContainerRuntimeMessageCompatDetails;
    contents: any;
    type: ContainerMessageType;
}

// @alpha
export const currentDocumentVersionSchema = 1;

// @internal (undocumented)
export class DataStoreContexts implements Iterable<[string, FluidDataStoreContext]>, IDisposable {
    // (undocumented)
    [Symbol.iterator](): Iterator<[string, FluidDataStoreContext]>;
    constructor(baseLogger: ITelemetryBaseLogger);
    addBoundOrRemoted(context: FluidDataStoreContext): void;
    addUnbound(context: LocalFluidDataStoreContext): void;
    bind(id: string): void;
    // (undocumented)
    delete(id: string): boolean;
    // (undocumented)
    readonly dispose: () => void;
    // (undocumented)
    get disposed(): boolean;
    // (undocumented)
    get(id: string): FluidDataStoreContext | undefined;
    getBoundOrRemoted(id: string, wait: boolean): Promise<FluidDataStoreContext | undefined>;
    // (undocumented)
    getRecentlyDeletedContext(id: string): FluidDataStoreContext | undefined;
    getUnbound(id: string): LocalFluidDataStoreContext | undefined;
    // (undocumented)
    has(id: string): boolean;
    // (undocumented)
    isNotBound(id: string): boolean;
    // (undocumented)
    notBoundLength(): number;
    // (undocumented)
    get size(): number;
}

// @alpha (undocumented)
export const DefaultSummaryConfiguration: ISummaryConfiguration;

// @alpha
export const DeletedResponseHeaderKey = "wasDeleted";

// @internal
export function detectOutboundReferences(address: string, contents: unknown, addedOutboundReference: (fromNodePath: string, toNodePath: string) => void): void;

// @alpha (undocumented)
export const disabledCompressionConfig: ICompressionRuntimeOptions;

// @alpha
export type DocumentSchemaValueType = string | string[] | true | number | undefined;

// @alpha
export class DocumentsSchemaController {
    constructor(existing: boolean, snapshotSequenceNumber: number, documentMetadataSchema: IDocumentSchema | undefined, features: IDocumentSchemaFeatures, onSchemaChange: (schema: IDocumentSchemaCurrent) => void);
    maybeSendSchemaMessage(): IDocumentSchemaChangeMessage | undefined;
    // (undocumented)
    onDisconnect(): void;
    processDocumentSchemaOp(content: IDocumentSchemaChangeMessage, local: boolean, sequenceNumber: number): boolean;
    // (undocumented)
    sessionSchema: IDocumentSchemaCurrent;
    // (undocumented)
    summarizeDocumentSchema(refSeq: number): IDocumentSchemaCurrent | undefined;
}

// @alpha (undocumented)
export type EnqueueSummarizeResult = (ISummarizeResults & {
    readonly alreadyEnqueued?: undefined;
}) | (ISummarizeResults & {
    readonly alreadyEnqueued: true;
    readonly overridden: true;
}) | {
    readonly alreadyEnqueued: true;
    readonly overridden?: undefined;
};

// @internal
export abstract class FluidDataStoreContext extends TypedEventEmitter<IFluidDataStoreContextEvents> implements IFluidDataStoreContextInternal, IFluidParentContext, IDisposable {
    constructor(props: IFluidDataStoreContextProps, existing: boolean, isLocalDataStore: boolean, makeLocallyVisibleFn: () => void);
    // @deprecated (undocumented)
    addedGCOutboundReference(srcHandle: IFluidHandleInternal, outboundHandle: IFluidHandleInternal): void;
    addedGCOutboundRoute(fromPath: string, toPath: string): void;
    // (undocumented)
    applyStashedOp(contents: any): Promise<unknown>;
    // (undocumented)
    get attachState(): AttachState;
    // (undocumented)
    protected _attachState: AttachState;
    // (undocumented)
    get baseLogger(): ITelemetryBaseLogger;
    // (undocumented)
    get baseSnapshot(): ISnapshotTree | undefined;
    // (undocumented)
    protected _baseSnapshot: ISnapshotTree | undefined;
    // (undocumented)
    protected bindRuntime(channel: IFluidDataStoreChannel, existing: boolean): Promise<void>;
    // (undocumented)
    protected channel: IFluidDataStoreChannel | undefined;
    // (undocumented)
    protected channelP: Promise<IFluidDataStoreChannel> | undefined;
    // (undocumented)
    get clientDetails(): IClientDetails;
    // (undocumented)
    get clientId(): string | undefined;
    // (undocumented)
    protected completeBindingRuntime(channel: IFluidDataStoreChannel): void;
    // (undocumented)
    get connected(): boolean;
    // (undocumented)
    get containerRuntime(): IContainerRuntimeBase;
    delete(): void;
    // (undocumented)
    deleteChildSummarizerNode(id: string): void;
    protected deleted: boolean;
    // (undocumented)
    get deltaManager(): IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;
    // (undocumented)
    protected detachedRuntimeCreation: boolean;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    // (undocumented)
    ensureNoDataModelChanges<T>(callback: () => T): T;
    // (undocumented)
    protected factoryFromPackagePath(): Promise<IFluidDataStoreFactory>;
    readonly gcThrowOnTombstoneUsage: boolean;
    // (undocumented)
    readonly gcTombstoneEnforcementAllowed: boolean;
    // (undocumented)
    getAbsoluteUrl(relativeUrl: string): Promise<string | undefined>;
    abstract getAttachData(includeGCData: boolean, telemetryContext?: ITelemetryContext): {
        attachSummary: ISummaryTreeWithStats;
        type: string;
    };
    // (undocumented)
    getAudience(): IAudience;
    // @deprecated (undocumented)
    getBaseGCDetails(): Promise<IGarbageCollectionDetailsBase>;
    // (undocumented)
    getCreateChildSummarizerNodeFn(id: string, createParam: CreateChildSummarizerNodeParam): (summarizeInternal: SummarizeInternalFn, getGCDataFn: (fullGC?: boolean) => Promise<IGarbageCollectionData>) => ISummarizerNodeWithGC;
    getGCData(fullGC?: boolean): Promise<IGarbageCollectionData>;
    // (undocumented)
    abstract getInitialSnapshotDetails(): Promise<ISnapshotDetails>;
    // (undocumented)
    getQuorum(): IQuorumClients;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    get idCompressor(): IIdCompressor | undefined;
    protected identifyLocalChangeInSummarizer(eventName: string, type?: string): void;
    // (undocumented)
    get IFluidDataStoreRegistry(): IFluidDataStoreRegistry | undefined;
    // (undocumented)
    get IFluidHandleContext(): IFluidHandleContext;
    protected isInMemoryRoot(): boolean;
    // (undocumented)
    get isLoaded(): boolean;
    // (undocumented)
    readonly isLocalDataStore: boolean;
    isRoot(aliasedDataStores?: Set<string>): Promise<boolean>;
    // (undocumented)
    readonly loadingGroupId: string | undefined;
    makeLocallyVisible(): void;
    // (undocumented)
    protected readonly mc: MonitoringContext;
    // (undocumented)
    get options(): Record<string | number, any>;
    // (undocumented)
    get packagePath(): readonly string[];
    // (undocumented)
    protected pending: ISequencedDocumentMessage[] | undefined;
    // (undocumented)
    protected pkg?: readonly string[];
    // (undocumented)
    process(message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown): void;
    // (undocumented)
    protected processPendingOps(channel: IFluidDataStoreChannel): void;
    // (undocumented)
    processSignal(message: IInboundSignalMessage, local: boolean): void;
    // (undocumented)
    realize(): Promise<IFluidDataStoreChannel>;
    // (undocumented)
    protected registry: IFluidDataStoreRegistry | undefined;
    // @deprecated (undocumented)
    request(request: IRequest): Promise<IResponse>;
    // (undocumented)
    reSubmit(type: string, contents: any, localOpMetadata: unknown): void;
    // (undocumented)
    rollback(type: string, contents: any, localOpMetadata: unknown): void;
    // (undocumented)
    readonly scope: FluidObject;
    // (undocumented)
    abstract setAttachState(attachState: AttachState.Attaching | AttachState.Attached): void;
    setChannelDirty(address: string): void;
    setConnectionState(connected: boolean, clientId?: string): void;
    // @deprecated (undocumented)
    setInMemoryRoot(): void;
    // (undocumented)
    setTombstone(tombstone: boolean): void;
    // (undocumented)
    readonly storage: IDocumentStorageService;
    // (undocumented)
    submitMessage(type: string, content: any, localOpMetadata: unknown): void;
    submitSignal(type: string, content: unknown, targetClientId?: string): void;
    summarize(fullTree?: boolean, trackState?: boolean, telemetryContext?: ITelemetryContext): Promise<ISummarizeResult>;
    // (undocumented)
    protected readonly summarizerNode: ISummarizerNodeWithGC;
    // (undocumented)
    get tombstoned(): boolean;
    updateUsedRoutes(usedRoutes: string[]): void;
    // (undocumented)
    uploadBlob(blob: ArrayBufferLike, signal?: AbortSignal): Promise<IFluidHandleInternal<ArrayBufferLike>>;
}

// @internal (undocumented)
export class FluidDataStoreRegistry implements IFluidDataStoreRegistry {
    constructor(namedEntries: NamedFluidDataStoreRegistryEntries);
    // (undocumented)
    get(name: string): Promise<FluidDataStoreRegistryEntry | undefined>;
    // (undocumented)
    get IFluidDataStoreRegistry(): this;
}

// @alpha (undocumented)
export type GCFeatureMatrix = {
    gcGeneration?: number;
    tombstoneGeneration?: undefined;
} | {
    tombstoneGeneration: number;
};

// @alpha
export const GCNodeType: {
    readonly DataStore: "DataStore";
    readonly SubDataStore: "SubDataStore";
    readonly Blob: "Blob";
    readonly Other: "Other";
};

// @alpha (undocumented)
export type GCNodeType = (typeof GCNodeType)[keyof typeof GCNodeType];

// @alpha (undocumented)
export type GCVersion = number;

// @alpha
export interface IAckedSummary {
    // (undocumented)
    readonly summaryAck: ISummaryAckMessage;
    // (undocumented)
    readonly summaryOp: ISummaryOpMessage;
}

// @alpha (undocumented)
export interface IAckSummaryResult {
    // (undocumented)
    readonly ackNackDuration: number;
    // (undocumented)
    readonly summaryAckOp: ISummaryAckMessage;
}

// @alpha
export interface IBaseSummarizeResult {
    readonly error: IRetriableFailureError | undefined;
    // (undocumented)
    readonly minimumSequenceNumber: number;
    readonly referenceSequenceNumber: number;
    // (undocumented)
    readonly stage: "base";
}

// @alpha
export interface IBlobManagerLoadInfo {
    // (undocumented)
    ids?: string[];
    // (undocumented)
    redirectTable?: [string, string][];
}

// @alpha (undocumented)
export interface IBroadcastSummaryResult {
    // (undocumented)
    readonly broadcastDuration: number;
    // (undocumented)
    readonly summarizeOp: ISummaryOpMessage;
}

// @alpha
export interface ICancellableSummarizerController extends ISummaryCancellationToken {
    // (undocumented)
    stop(reason: SummarizerStopReason): void;
}

// @alpha
export interface ICancellationToken<T> {
    readonly cancelled: boolean;
    readonly waitCancelled: Promise<T>;
}

// @internal (undocumented)
export interface IChunkedOp {
    // (undocumented)
    chunkId: number;
    // (undocumented)
    contents: string;
    // (undocumented)
    originalCompression?: string;
    // (undocumented)
    originalMetadata?: Record<string, unknown>;
    // (undocumented)
    totalChunks: number;
}

// @alpha
export interface IClientSummaryWatcher extends IDisposable {
    // (undocumented)
    waitFlushed(): Promise<IAckedSummary | undefined>;
    // (undocumented)
    watchSummary(clientSequenceNumber: number): ISummary;
}

// @alpha
export interface ICompressionRuntimeOptions {
    readonly compressionAlgorithm: CompressionAlgorithms;
    readonly minimumBatchSizeInBytes: number;
}

// @alpha (undocumented)
export interface IConnectableRuntime {
    // (undocumented)
    readonly clientId: string | undefined;
    // (undocumented)
    readonly connected: boolean;
    // (undocumented)
    readonly disposed: boolean;
    // (undocumented)
    once(event: "connected" | "disconnected" | "dispose", listener: () => void): this;
}

// @internal
export interface IContainerRuntimeMessageCompatDetails {
    behavior: CompatModeBehavior;
}

// @alpha (undocumented)
export interface IContainerRuntimeMetadata extends ICreateContainerMetadata, IGCMetadata {
    readonly disableIsolatedChannels?: true;
    // (undocumented)
    readonly documentSchema?: IDocumentSchema;
    readonly lastMessage?: ISummaryMetadataMessage;
    // @deprecated (undocumented)
    readonly message?: ISummaryMetadataMessage;
    // (undocumented)
    readonly summaryFormatVersion: 1;
    readonly summaryNumber?: number;
    readonly telemetryDocumentId?: string;
}

// @alpha
export interface IContainerRuntimeOptions {
    readonly chunkSizeInBytes?: number;
    readonly compressionOptions?: ICompressionRuntimeOptions;
    readonly enableGroupedBatching?: boolean;
    readonly enableRuntimeIdCompressor?: IdCompressorMode;
    readonly explicitSchemaControl?: boolean;
    readonly flushMode?: FlushMode;
    // (undocumented)
    readonly gcOptions?: IGCRuntimeOptions;
    readonly loadSequenceNumberVerification?: "close" | "log" | "bypass";
    readonly maxBatchSizeInBytes?: number;
    // (undocumented)
    readonly summaryOptions?: ISummaryRuntimeOptions;
}

// @alpha (undocumented)
export interface ICreateContainerMetadata {
    createContainerRuntimeVersion?: string;
    createContainerTimestamp?: number;
}

// @alpha
export type IdCompressorMode = "on" | "delayed" | undefined;

// @alpha
export interface IDocumentSchema {
    // (undocumented)
    refSeq: number;
    // (undocumented)
    runtime: Record<string, DocumentSchemaValueType>;
    // (undocumented)
    version: number;
}

// @alpha
export type IDocumentSchemaChangeMessage = IDocumentSchema;

// @alpha
export type IDocumentSchemaCurrent = {
    version: 1;
    refSeq: number;
    runtime: {
        [P in keyof IDocumentSchemaFeatures]?: IDocumentSchemaFeatures[P] extends boolean ? true : IDocumentSchemaFeatures[P];
    };
};

// @alpha
export interface IDocumentSchemaFeatures {
    // (undocumented)
    compressionLz4: boolean;
    disallowedVersions: string[];
    // (undocumented)
    explicitSchemaControl: boolean;
    // (undocumented)
    idCompressorMode: IdCompressorMode;
    // (undocumented)
    opGroupingEnabled: boolean;
}

// @alpha
export interface IEnqueueSummarizeOptions extends IOnDemandSummarizeOptions {
    readonly afterSequenceNumber?: number;
    readonly override?: boolean;
}

// @alpha @deprecated (undocumented)
export interface IFluidDataStoreAttributes0 {
    readonly isRootDataStore?: boolean;
    // (undocumented)
    pkg: string;
    // (undocumented)
    readonly snapshotFormatVersion?: undefined;
    // (undocumented)
    readonly summaryFormatVersion?: undefined;
}

// @alpha @deprecated (undocumented)
export interface IFluidDataStoreAttributes1 extends OmitAttributesVersions<IFluidDataStoreAttributes0> {
    // (undocumented)
    readonly snapshotFormatVersion: "0.1";
    // (undocumented)
    readonly summaryFormatVersion?: undefined;
}

// @alpha @deprecated (undocumented)
export interface IFluidDataStoreAttributes2 extends OmitAttributesVersions<IFluidDataStoreAttributes1> {
    readonly disableIsolatedChannels?: true;
    readonly snapshotFormatVersion?: undefined;
    // (undocumented)
    readonly summaryFormatVersion: 2;
}

// @internal (undocumented)
export interface IFluidDataStoreContextEvents extends IEvent {
    // (undocumented)
    (event: "attaching" | "attached", listener: () => void): any;
}

// @internal
export interface IFluidDataStoreContextInternal extends IFluidDataStoreContext {
    // (undocumented)
    getAttachData(includeGCData: boolean, telemetryContext?: ITelemetryContext): {
        attachSummary: ISummaryTreeWithStats;
        type: string;
    };
    // (undocumented)
    getInitialSnapshotDetails(): Promise<ISnapshotDetails>;
    // (undocumented)
    isRoot(): Promise<boolean>;
    // (undocumented)
    realize(): Promise<IFluidDataStoreChannel>;
}

// @internal
export interface IFluidDataStoreContextProps {
    // (undocumented)
    readonly createSummarizerNodeFn: CreateChildSummarizerNodeFn;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly loadingGroupId?: string;
    // (undocumented)
    readonly parentContext: IFluidParentContext;
    // (undocumented)
    readonly pkg?: Readonly<string[]>;
    // (undocumented)
    readonly scope: FluidObject;
    // (undocumented)
    readonly storage: IDocumentStorageService;
}

// @alpha
export interface IGCMetadata {
    readonly gcFeature?: GCVersion;
    readonly gcFeatureMatrix?: GCFeatureMatrix;
    readonly sessionExpiryTimeoutMs?: number;
    // @deprecated
    readonly sweepEnabled?: boolean;
    readonly tombstoneTimeoutMs?: number;
}

// @internal
export interface IGCNodeUpdatedProps {
    headerData?: RuntimeHeaderData;
    node: {
        type: (typeof GCNodeType)["DataStore" | "Blob"];
        path: string;
    };
    packagePath?: readonly string[];
    reason: "Loaded" | "Changed";
    request?: IRequest;
    timestampMs?: number;
}

// @alpha (undocumented)
export interface IGCRuntimeOptions {
    [key: string]: any;
    enableGCSweep?: true;
    runFullGC?: boolean;
    sessionExpiryTimeoutMs?: number;
    sweepGracePeriodMs?: number;
}

// @alpha
export interface IGCStats extends IMarkPhaseStats, ISweepPhaseStats {
}

// @alpha
export interface IGeneratedSummaryStats extends ISummaryStats {
    readonly dataStoreCount: number;
    readonly gcBlobNodeCount?: number;
    readonly gcStateUpdatedDataStoreCount?: number;
    readonly gcTotalBlobsSize?: number;
    readonly summarizedDataStoreCount: number;
    readonly summaryNumber: number;
}

// @alpha
export interface IGenerateSummaryTreeResult extends Omit<IBaseSummarizeResult, "stage"> {
    readonly generateDuration: number;
    // (undocumented)
    readonly stage: "generate";
    readonly summaryStats: IGeneratedSummaryStats;
    readonly summaryTree: ISummaryTree;
}

// @internal
export interface ILocalDetachedFluidDataStoreContextProps extends ILocalFluidDataStoreContextProps {
    // (undocumented)
    readonly channelToDataStoreFn: (channel: IFluidDataStoreChannel) => IDataStore;
}

// @internal
export interface ILocalFluidDataStoreContextProps extends IFluidDataStoreContextProps {
    // @deprecated (undocumented)
    readonly createProps?: any;
    // (undocumented)
    readonly makeLocallyVisibleFn: () => void;
    // (undocumented)
    readonly pkg: Readonly<string[]> | undefined;
    // (undocumented)
    readonly snapshotTree: ISnapshotTree | undefined;
}

// @alpha
export interface IMarkPhaseStats {
    attachmentBlobCount: number;
    dataStoreCount: number;
    nodeCount: number;
    unrefAttachmentBlobCount: number;
    unrefDataStoreCount: number;
    unrefNodeCount: number;
    updatedAttachmentBlobCount: number;
    updatedDataStoreCount: number;
    updatedNodeCount: number;
}

// @alpha (undocumented)
export interface INackSummaryResult {
    // (undocumented)
    readonly ackNackDuration: number;
    // (undocumented)
    readonly summaryNackOp: ISummaryNackMessage;
}

// @alpha
export const InactiveResponseHeaderKey = "isInactive";

// @alpha (undocumented)
export interface IOnDemandSummarizeOptions extends ISummarizeOptions {
    readonly reason: string;
    readonly retryOnFailure?: boolean;
}

// @alpha
export interface IRefreshSummaryAckOptions {
    readonly ackHandle: string;
    readonly proposalHandle: string | undefined;
    readonly summaryLogger: ITelemetryLoggerExt;
    readonly summaryRefSeq: number;
}

// @alpha
export interface IRetriableFailureError extends Error {
    // (undocumented)
    readonly retryAfterSeconds?: number;
}

// @alpha
export interface ISerializedElection {
    readonly electedClientId: string | undefined;
    readonly electedParentId: string | undefined;
    readonly electionSequenceNumber: number;
}

// @internal (undocumented)
export interface ISnapshotDetails {
    // (undocumented)
    isRootDataStore: boolean;
    // (undocumented)
    pkg: readonly string[];
    // (undocumented)
    sequenceNumber?: number;
    // (undocumented)
    snapshot?: ISnapshotTree;
}

// @internal @deprecated (undocumented)
export function isRuntimeMessage(message: ISequencedDocumentMessage): boolean;

// @alpha
export interface ISubmitSummaryOpResult extends Omit<IUploadSummaryResult, "stage" | "error"> {
    readonly clientSequenceNumber: number;
    // (undocumented)
    readonly stage: "submit";
    readonly submitOpDuration: number;
}

// @alpha (undocumented)
export interface ISubmitSummaryOptions extends ISummarizeOptions {
    readonly cancellationToken: ISummaryCancellationToken;
    readonly finalAttempt?: boolean;
    readonly latestSummaryRefSeqNum: number;
    readonly summaryLogger: ITelemetryLoggerExt;
}

// @alpha (undocumented)
export interface ISummarizeEventProps {
    // (undocumented)
    currentAttempt: number;
    // (undocumented)
    error?: any;
    // (undocumented)
    maxAttempts: number;
    // (undocumented)
    result: "success" | "failure" | "canceled";
}

// @alpha
export interface ISummarizeOptions {
    readonly fullTree?: boolean;
}

// @alpha (undocumented)
export interface ISummarizer extends IEventProvider<ISummarizerEvents> {
    // (undocumented)
    close(): void;
    enqueueSummarize(options: IEnqueueSummarizeOptions): EnqueueSummarizeResult;
    readonly ISummarizer?: ISummarizer;
    // (undocumented)
    run(onBehalfOf: string): Promise<SummarizerStopReason>;
    // (undocumented)
    stop(reason: SummarizerStopReason): void;
    summarizeOnDemand(options: IOnDemandSummarizeOptions): ISummarizeResults;
}

// @alpha (undocumented)
export interface ISummarizeResults {
    readonly receivedSummaryAckOrNack: Promise<SummarizeResultPart<IAckSummaryResult, INackSummaryResult>>;
    readonly summaryOpBroadcasted: Promise<SummarizeResultPart<IBroadcastSummaryResult>>;
    readonly summarySubmitted: Promise<SummarizeResultPart<SubmitSummaryResult, SubmitSummaryFailureData>>;
}

// @alpha (undocumented)
export interface ISummarizerEvents extends IEvent {
    // (undocumented)
    (event: "summarize", listener: (props: ISummarizeEventProps) => void): any;
}

// @alpha (undocumented)
export interface ISummarizerInternalsProvider {
    refreshLatestSummaryAck(options: IRefreshSummaryAckOptions): Promise<void>;
    submitSummary(options: ISubmitSummaryOptions): Promise<SubmitSummaryResult>;
}

// @alpha (undocumented)
export interface ISummarizerRuntime extends IConnectableRuntime {
    // (undocumented)
    readonly baseLogger: ITelemetryBaseLogger;
    // (undocumented)
    closeFn(): void;
    // (undocumented)
    readonly deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;
    // (undocumented)
    disposeFn(): void;
    // (undocumented)
    off(event: "op", listener: (op: ISequencedDocumentMessage, runtimeMessage?: boolean) => void): this;
    // (undocumented)
    on(event: "op", listener: (op: ISequencedDocumentMessage, runtimeMessage?: boolean) => void): this;
    readonly summarizerClientId: string | undefined;
}

// @internal (undocumented)
export interface ISummarizingWarning extends ContainerWarning {
    // (undocumented)
    readonly errorType: "summarizingError";
    // (undocumented)
    readonly logged: boolean;
}

// @alpha
export interface ISummary {
    // (undocumented)
    readonly clientId: string;
    // (undocumented)
    readonly clientSequenceNumber: number;
    // (undocumented)
    waitAckNack(): Promise<ISummaryAckMessage | ISummaryNackMessage>;
    // (undocumented)
    waitBroadcast(): Promise<ISummaryOpMessage>;
}

// @alpha
export interface ISummaryAckMessage extends ISequencedDocumentMessage {
    // (undocumented)
    contents: ISummaryAck;
    // (undocumented)
    type: MessageType.SummaryAck;
}

// @alpha (undocumented)
export interface ISummaryBaseConfiguration {
    initialSummarizerDelayMs: number;
    maxAckWaitTime: number;
    maxOpsSinceLastSummary: number;
}

// @alpha
export type ISummaryCancellationToken = ICancellationToken<SummarizerStopReason>;

// @alpha (undocumented)
export interface ISummaryCollectionOpEvents extends IEvent {
    // (undocumented)
    (event: OpActionEventName, listener: OpActionEventListener): any;
}

// @alpha (undocumented)
export type ISummaryConfiguration = ISummaryConfigurationDisableSummarizer | ISummaryConfigurationDisableHeuristics | ISummaryConfigurationHeuristics;

// @alpha (undocumented)
export interface ISummaryConfigurationDisableHeuristics extends ISummaryBaseConfiguration {
    // (undocumented)
    state: "disableHeuristics";
}

// @alpha (undocumented)
export interface ISummaryConfigurationDisableSummarizer {
    // (undocumented)
    state: "disabled";
}

// @alpha (undocumented)
export interface ISummaryConfigurationHeuristics extends ISummaryBaseConfiguration {
    maxIdleTime: number;
    maxOps: number;
    maxTime: number;
    minIdleTime: number;
    minOpsForLastSummaryAttempt: number;
    nonRuntimeHeuristicThreshold?: number;
    nonRuntimeOpWeight: number;
    runtimeOpWeight: number;
    // (undocumented)
    state: "enabled";
}

// @alpha
export type ISummaryMetadataMessage = Pick<ISequencedDocumentMessage, "clientId" | "clientSequenceNumber" | "minimumSequenceNumber" | "referenceSequenceNumber" | "sequenceNumber" | "timestamp" | "type">;

// @alpha
export interface ISummaryNackMessage extends ISequencedDocumentMessage {
    // (undocumented)
    contents: ISummaryNack;
    // (undocumented)
    type: MessageType.SummaryNack;
}

// @alpha
export interface ISummaryOpMessage extends ISequencedDocumentMessage {
    // (undocumented)
    contents: ISummaryContent;
    // (undocumented)
    type: MessageType.Summarize;
}

// @alpha (undocumented)
export interface ISummaryRuntimeOptions {
    // @deprecated
    initialSummarizerDelayMs?: number;
    summaryConfigOverrides?: ISummaryConfiguration;
}

// @alpha
export interface ISweepPhaseStats {
    deletedAttachmentBlobCount: number;
    deletedDataStoreCount: number;
    deletedNodeCount: number;
    lifetimeAttachmentBlobCount: number;
    lifetimeDataStoreCount: number;
    lifetimeNodeCount: number;
}

// @alpha
export interface IUploadSummaryResult extends Omit<IGenerateSummaryTreeResult, "stage"> {
    readonly handle: string;
    // (undocumented)
    readonly stage: "upload";
    readonly uploadDuration: number;
}

// @internal
export class LocalFluidDataStoreContext extends LocalFluidDataStoreContextBase {
    constructor(props: ILocalFluidDataStoreContextProps);
}

// @internal
export class LocalFluidDataStoreContextBase extends FluidDataStoreContext {
    constructor(props: ILocalFluidDataStoreContextProps);
    // @deprecated (undocumented)
    readonly createProps?: any;
    delete(): void;
    // (undocumented)
    getAttachData(includeGCData: boolean, telemetryContext?: ITelemetryContext): {
        attachSummary: ISummaryTreeWithStats;
        type: string;
    };
    // (undocumented)
    getInitialSnapshotDetails(): Promise<ISnapshotDetails>;
    // (undocumented)
    setAttachState(attachState: AttachState.Attaching | AttachState.Attached): void;
}

// @internal
export const neverCancelledSummaryToken: ISummaryCancellationToken;

// @alpha @deprecated (undocumented)
export type OmitAttributesVersions<T> = Omit<T, "snapshotFormatVersion" | "summaryFormatVersion">;

// @alpha (undocumented)
export type OpActionEventListener = (op: ISequencedDocumentMessage) => void;

// @alpha (undocumented)
export type OpActionEventName = MessageType.Summarize | MessageType.SummaryAck | MessageType.SummaryNack | "default";

// @alpha @deprecated
export type ReadFluidDataStoreAttributes = IFluidDataStoreAttributes0 | IFluidDataStoreAttributes1 | IFluidDataStoreAttributes2;

// @internal
export interface RecentlyAddedContainerRuntimeMessageDetails {
    compatDetails: IContainerRuntimeMessageCompatDetails;
}

// @internal
export interface RuntimeHeaderData {
    // (undocumented)
    allowInactive?: boolean;
    // (undocumented)
    allowTombstone?: boolean;
    // (undocumented)
    viaHandle?: boolean;
    // (undocumented)
    wait?: boolean;
}

// @internal
export enum RuntimeHeaders {
    viaHandle = "viaHandle",
    wait = "wait"
}

// @alpha
export interface SubmitSummaryFailureData {
    // (undocumented)
    stage: SummaryStage;
}

// @alpha
export type SubmitSummaryResult = IBaseSummarizeResult | IGenerateSummaryTreeResult | IUploadSummaryResult | ISubmitSummaryOpResult;

// @alpha
export class Summarizer extends TypedEventEmitter<ISummarizerEvents> implements ISummarizer {
    constructor(
    runtime: ISummarizerRuntime, configurationGetter: () => ISummaryConfiguration,
    internalsProvider: ISummarizerInternalsProvider, handleContext: IFluidHandleContext, summaryCollection: SummaryCollection, runCoordinatorCreateFn: (runtime: IConnectableRuntime) => Promise<ICancellableSummarizerController>);
    // (undocumented)
    close(): void;
    dispose(): void;
    // (undocumented)
    enqueueSummarize(options: IEnqueueSummarizeOptions): EnqueueSummarizeResult;
    // (undocumented)
    get ISummarizer(): this;
    // (undocumented)
    recordSummaryAttempt?(summaryRefSeqNum?: number): void;
    // (undocumented)
    run(onBehalfOf: string): Promise<SummarizerStopReason>;
    stop(reason: SummarizerStopReason): void;
    static stopReasonCanRunLastSummary(stopReason: SummarizerStopReason): boolean;
    // (undocumented)
    summarizeOnDemand(options: IOnDemandSummarizeOptions): ISummarizeResults;
    // (undocumented)
    readonly summaryCollection: SummaryCollection;
}

// @alpha (undocumented)
export type SummarizeResultPart<TSuccess, TFailure = undefined> = {
    success: true;
    data: TSuccess;
} | {
    success: false;
    data: TFailure | undefined;
    message: string;
    error: IRetriableFailureError;
};

// @alpha (undocumented)
export type SummarizerStopReason =
/** Summarizer client failed to summarize in all attempts. */
"failToSummarize"
/** Parent client reported that it is no longer connected. */
| "parentNotConnected"
/**
* Parent client reported that it is no longer elected the summarizer.
* This is the normal flow; a disconnect will always trigger the parent
* client to no longer be elected as responsible for summaries. Then it
* tries to stop its spawned summarizer client.
*/
| "notElectedParent"
/**
* We are not already running the summarizer and we are not the current elected client id.
*/
| "notElectedClient"
/** Summarizer client was disconnected */
| "summarizerClientDisconnected"
/** running summarizer threw an exception */
| "summarizerException"
/**
* The previous summary state on the summarizer is not the most recently acked summary. this also happens when the
* first submitSummary attempt fails for any reason and there's a 2nd summary attempt without an ack
*/
| "latestSummaryStateStale";

// @alpha
export class SummaryCollection extends TypedEventEmitter<ISummaryCollectionOpEvents> {
    constructor(deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>, logger: ITelemetryLoggerExt);
    // (undocumented)
    addOpListener(listener: () => void): void;
    createWatcher(clientId: string): IClientSummaryWatcher;
    // (undocumented)
    emit(event: OpActionEventName, ...args: Parameters<OpActionEventListener>): boolean;
    // (undocumented)
    get latestAck(): IAckedSummary | undefined;
    // (undocumented)
    get opsSinceLastAck(): number;
    // (undocumented)
    removeOpListener(listener: () => void): void;
    // (undocumented)
    removeWatcher(clientId: string): void;
    // (undocumented)
    setPendingAckTimerTimeoutCallback(maxAckWaitTime: number, timeoutCallback: () => void): void;
    // (undocumented)
    unsetPendingAckTimerTimeoutCallback(): void;
    waitFlushed(): Promise<IAckedSummary | undefined>;
    waitSummaryAck(referenceSequenceNumber: number): Promise<IAckedSummary>;
}

// @alpha
export type SummaryStage = SubmitSummaryResult["stage"] | "unknown";

// @alpha
export const TombstoneResponseHeaderKey = "isTombstoned";

// @internal
export interface UnknownContainerRuntimeMessage extends Partial<RecentlyAddedContainerRuntimeMessageDetails> {
    contents: unknown;
    type: "__unknown_container_message_type__never_use_as_value__";
}

// @internal
export function unpackRuntimeMessage(message: ISequencedDocumentMessage): boolean;

// (No @packageDocumentation comment for this package)

```
