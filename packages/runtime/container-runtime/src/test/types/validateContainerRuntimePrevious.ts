/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "@fluidframework/container-runtime-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_agentSchedulerId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_agentSchedulerId():
    TypeOnly<typeof old.agentSchedulerId>;
declare function use_current_VariableDeclaration_agentSchedulerId(
    use: TypeOnly<typeof current.agentSchedulerId>);
use_current_VariableDeclaration_agentSchedulerId(
    get_old_VariableDeclaration_agentSchedulerId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_agentSchedulerId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_agentSchedulerId():
    TypeOnly<typeof current.agentSchedulerId>;
declare function use_old_VariableDeclaration_agentSchedulerId(
    use: TypeOnly<typeof old.agentSchedulerId>);
use_old_VariableDeclaration_agentSchedulerId(
    get_current_VariableDeclaration_agentSchedulerId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ContainerMessageType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_ContainerMessageType():
    TypeOnly<old.ContainerMessageType>;
declare function use_current_EnumDeclaration_ContainerMessageType(
    use: TypeOnly<current.ContainerMessageType>);
use_current_EnumDeclaration_ContainerMessageType(
    get_old_EnumDeclaration_ContainerMessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ContainerMessageType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_ContainerMessageType():
    TypeOnly<current.ContainerMessageType>;
declare function use_old_EnumDeclaration_ContainerMessageType(
    use: TypeOnly<old.ContainerMessageType>);
use_old_EnumDeclaration_ContainerMessageType(
    get_current_EnumDeclaration_ContainerMessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ContainerRuntime": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ContainerRuntime():
    TypeOnly<old.ContainerRuntime>;
declare function use_current_ClassDeclaration_ContainerRuntime(
    use: TypeOnly<current.ContainerRuntime>);
use_current_ClassDeclaration_ContainerRuntime(
    get_old_ClassDeclaration_ContainerRuntime());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ContainerRuntime": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ContainerRuntime():
    TypeOnly<current.ContainerRuntime>;
declare function use_old_ClassDeclaration_ContainerRuntime(
    use: TypeOnly<old.ContainerRuntime>);
use_old_ClassDeclaration_ContainerRuntime(
    // @ts-expect-error compatibility expected to be broken
    get_current_ClassDeclaration_ContainerRuntime());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerRuntimeMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerRuntimeMessage():
    TypeOnly<old.ContainerRuntimeMessage>;
declare function use_current_InterfaceDeclaration_ContainerRuntimeMessage(
    use: TypeOnly<current.ContainerRuntimeMessage>);
use_current_InterfaceDeclaration_ContainerRuntimeMessage(
    get_old_InterfaceDeclaration_ContainerRuntimeMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerRuntimeMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerRuntimeMessage():
    TypeOnly<current.ContainerRuntimeMessage>;
declare function use_old_InterfaceDeclaration_ContainerRuntimeMessage(
    use: TypeOnly<old.ContainerRuntimeMessage>);
use_old_InterfaceDeclaration_ContainerRuntimeMessage(
    get_current_InterfaceDeclaration_ContainerRuntimeMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DefaultSummaryConfiguration": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_DefaultSummaryConfiguration():
    TypeOnly<typeof old.DefaultSummaryConfiguration>;
declare function use_current_VariableDeclaration_DefaultSummaryConfiguration(
    use: TypeOnly<typeof current.DefaultSummaryConfiguration>);
use_current_VariableDeclaration_DefaultSummaryConfiguration(
    // @ts-expect-error compatibility expected to be broken
    get_old_VariableDeclaration_DefaultSummaryConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DefaultSummaryConfiguration": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_DefaultSummaryConfiguration():
    TypeOnly<typeof current.DefaultSummaryConfiguration>;
declare function use_old_VariableDeclaration_DefaultSummaryConfiguration(
    use: TypeOnly<typeof old.DefaultSummaryConfiguration>);
use_old_VariableDeclaration_DefaultSummaryConfiguration(
    get_current_VariableDeclaration_DefaultSummaryConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeltaScheduler": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DeltaScheduler():
    TypeOnly<old.DeltaScheduler>;
declare function use_current_ClassDeclaration_DeltaScheduler(
    use: TypeOnly<current.DeltaScheduler>);
use_current_ClassDeclaration_DeltaScheduler(
    get_old_ClassDeclaration_DeltaScheduler());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeltaScheduler": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DeltaScheduler():
    TypeOnly<current.DeltaScheduler>;
declare function use_old_ClassDeclaration_DeltaScheduler(
    use: TypeOnly<old.DeltaScheduler>);
use_old_ClassDeclaration_DeltaScheduler(
    get_current_ClassDeclaration_DeltaScheduler());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_EnqueueSummarizeResult": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_EnqueueSummarizeResult():
    TypeOnly<old.EnqueueSummarizeResult>;
declare function use_current_TypeAliasDeclaration_EnqueueSummarizeResult(
    use: TypeOnly<current.EnqueueSummarizeResult>);
use_current_TypeAliasDeclaration_EnqueueSummarizeResult(
    get_old_TypeAliasDeclaration_EnqueueSummarizeResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_EnqueueSummarizeResult": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_EnqueueSummarizeResult():
    TypeOnly<current.EnqueueSummarizeResult>;
declare function use_old_TypeAliasDeclaration_EnqueueSummarizeResult(
    use: TypeOnly<old.EnqueueSummarizeResult>);
use_old_TypeAliasDeclaration_EnqueueSummarizeResult(
    get_current_TypeAliasDeclaration_EnqueueSummarizeResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_FluidDataStoreRegistry": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_FluidDataStoreRegistry():
    TypeOnly<old.FluidDataStoreRegistry>;
declare function use_current_ClassDeclaration_FluidDataStoreRegistry(
    use: TypeOnly<current.FluidDataStoreRegistry>);
use_current_ClassDeclaration_FluidDataStoreRegistry(
    get_old_ClassDeclaration_FluidDataStoreRegistry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_FluidDataStoreRegistry": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_FluidDataStoreRegistry():
    TypeOnly<current.FluidDataStoreRegistry>;
declare function use_old_ClassDeclaration_FluidDataStoreRegistry(
    use: TypeOnly<old.FluidDataStoreRegistry>);
use_old_ClassDeclaration_FluidDataStoreRegistry(
    get_current_ClassDeclaration_FluidDataStoreRegistry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_gcBlobPrefix": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_gcBlobPrefix():
    TypeOnly<typeof old.gcBlobPrefix>;
declare function use_current_VariableDeclaration_gcBlobPrefix(
    use: TypeOnly<typeof current.gcBlobPrefix>);
use_current_VariableDeclaration_gcBlobPrefix(
    get_old_VariableDeclaration_gcBlobPrefix());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_gcBlobPrefix": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_gcBlobPrefix():
    TypeOnly<typeof current.gcBlobPrefix>;
declare function use_old_VariableDeclaration_gcBlobPrefix(
    use: TypeOnly<typeof old.gcBlobPrefix>);
use_old_VariableDeclaration_gcBlobPrefix(
    get_current_VariableDeclaration_gcBlobPrefix());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_gcTreeKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_gcTreeKey():
    TypeOnly<typeof old.gcTreeKey>;
declare function use_current_VariableDeclaration_gcTreeKey(
    use: TypeOnly<typeof current.gcTreeKey>);
use_current_VariableDeclaration_gcTreeKey(
    get_old_VariableDeclaration_gcTreeKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_gcTreeKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_gcTreeKey():
    TypeOnly<typeof current.gcTreeKey>;
declare function use_old_VariableDeclaration_gcTreeKey(
    use: TypeOnly<typeof old.gcTreeKey>);
use_old_VariableDeclaration_gcTreeKey(
    get_current_VariableDeclaration_gcTreeKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAckedSummary": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAckedSummary():
    TypeOnly<old.IAckedSummary>;
declare function use_current_InterfaceDeclaration_IAckedSummary(
    use: TypeOnly<current.IAckedSummary>);
use_current_InterfaceDeclaration_IAckedSummary(
    get_old_InterfaceDeclaration_IAckedSummary());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAckedSummary": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAckedSummary():
    TypeOnly<current.IAckedSummary>;
declare function use_old_InterfaceDeclaration_IAckedSummary(
    use: TypeOnly<old.IAckedSummary>);
use_old_InterfaceDeclaration_IAckedSummary(
    get_current_InterfaceDeclaration_IAckedSummary());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAckSummaryResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAckSummaryResult():
    TypeOnly<old.IAckSummaryResult>;
declare function use_current_InterfaceDeclaration_IAckSummaryResult(
    use: TypeOnly<current.IAckSummaryResult>);
use_current_InterfaceDeclaration_IAckSummaryResult(
    get_old_InterfaceDeclaration_IAckSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAckSummaryResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAckSummaryResult():
    TypeOnly<current.IAckSummaryResult>;
declare function use_old_InterfaceDeclaration_IAckSummaryResult(
    use: TypeOnly<old.IAckSummaryResult>);
use_old_InterfaceDeclaration_IAckSummaryResult(
    get_current_InterfaceDeclaration_IAckSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBaseSummarizeResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IBaseSummarizeResult():
    TypeOnly<old.IBaseSummarizeResult>;
declare function use_current_InterfaceDeclaration_IBaseSummarizeResult(
    use: TypeOnly<current.IBaseSummarizeResult>);
use_current_InterfaceDeclaration_IBaseSummarizeResult(
    get_old_InterfaceDeclaration_IBaseSummarizeResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBaseSummarizeResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IBaseSummarizeResult():
    TypeOnly<current.IBaseSummarizeResult>;
declare function use_old_InterfaceDeclaration_IBaseSummarizeResult(
    use: TypeOnly<old.IBaseSummarizeResult>);
use_old_InterfaceDeclaration_IBaseSummarizeResult(
    get_current_InterfaceDeclaration_IBaseSummarizeResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBroadcastSummaryResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IBroadcastSummaryResult():
    TypeOnly<old.IBroadcastSummaryResult>;
declare function use_current_InterfaceDeclaration_IBroadcastSummaryResult(
    use: TypeOnly<current.IBroadcastSummaryResult>);
use_current_InterfaceDeclaration_IBroadcastSummaryResult(
    get_old_InterfaceDeclaration_IBroadcastSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBroadcastSummaryResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IBroadcastSummaryResult():
    TypeOnly<current.IBroadcastSummaryResult>;
declare function use_old_InterfaceDeclaration_IBroadcastSummaryResult(
    use: TypeOnly<old.IBroadcastSummaryResult>);
use_old_InterfaceDeclaration_IBroadcastSummaryResult(
    get_current_InterfaceDeclaration_IBroadcastSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICancellableSummarizerController": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICancellableSummarizerController():
    TypeOnly<old.ICancellableSummarizerController>;
declare function use_current_InterfaceDeclaration_ICancellableSummarizerController(
    use: TypeOnly<current.ICancellableSummarizerController>);
use_current_InterfaceDeclaration_ICancellableSummarizerController(
    get_old_InterfaceDeclaration_ICancellableSummarizerController());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICancellableSummarizerController": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICancellableSummarizerController():
    TypeOnly<current.ICancellableSummarizerController>;
declare function use_old_InterfaceDeclaration_ICancellableSummarizerController(
    use: TypeOnly<old.ICancellableSummarizerController>);
use_old_InterfaceDeclaration_ICancellableSummarizerController(
    get_current_InterfaceDeclaration_ICancellableSummarizerController());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICancellationToken": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICancellationToken():
    TypeOnly<old.ICancellationToken<any>>;
declare function use_current_InterfaceDeclaration_ICancellationToken(
    use: TypeOnly<current.ICancellationToken<any>>);
use_current_InterfaceDeclaration_ICancellationToken(
    get_old_InterfaceDeclaration_ICancellationToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICancellationToken": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICancellationToken():
    TypeOnly<current.ICancellationToken<any>>;
declare function use_old_InterfaceDeclaration_ICancellationToken(
    use: TypeOnly<old.ICancellationToken<any>>);
use_old_InterfaceDeclaration_ICancellationToken(
    get_current_InterfaceDeclaration_ICancellationToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IChunkedOp": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IChunkedOp():
    TypeOnly<old.IChunkedOp>;
declare function use_current_InterfaceDeclaration_IChunkedOp(
    use: TypeOnly<current.IChunkedOp>);
use_current_InterfaceDeclaration_IChunkedOp(
    get_old_InterfaceDeclaration_IChunkedOp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IChunkedOp": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IChunkedOp():
    TypeOnly<current.IChunkedOp>;
declare function use_old_InterfaceDeclaration_IChunkedOp(
    use: TypeOnly<old.IChunkedOp>);
use_old_InterfaceDeclaration_IChunkedOp(
    get_current_InterfaceDeclaration_IChunkedOp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientSummaryWatcher": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IClientSummaryWatcher():
    TypeOnly<old.IClientSummaryWatcher>;
declare function use_current_InterfaceDeclaration_IClientSummaryWatcher(
    use: TypeOnly<current.IClientSummaryWatcher>);
use_current_InterfaceDeclaration_IClientSummaryWatcher(
    get_old_InterfaceDeclaration_IClientSummaryWatcher());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientSummaryWatcher": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IClientSummaryWatcher():
    TypeOnly<current.IClientSummaryWatcher>;
declare function use_old_InterfaceDeclaration_IClientSummaryWatcher(
    use: TypeOnly<old.IClientSummaryWatcher>);
use_old_InterfaceDeclaration_IClientSummaryWatcher(
    get_current_InterfaceDeclaration_IClientSummaryWatcher());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnectableRuntime": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConnectableRuntime():
    TypeOnly<old.IConnectableRuntime>;
declare function use_current_InterfaceDeclaration_IConnectableRuntime(
    use: TypeOnly<current.IConnectableRuntime>);
use_current_InterfaceDeclaration_IConnectableRuntime(
    get_old_InterfaceDeclaration_IConnectableRuntime());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnectableRuntime": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConnectableRuntime():
    TypeOnly<current.IConnectableRuntime>;
declare function use_old_InterfaceDeclaration_IConnectableRuntime(
    use: TypeOnly<old.IConnectableRuntime>);
use_old_InterfaceDeclaration_IConnectableRuntime(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IConnectableRuntime());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerRuntimeOptions():
    TypeOnly<old.IContainerRuntimeOptions>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeOptions(
    use: TypeOnly<current.IContainerRuntimeOptions>);
use_current_InterfaceDeclaration_IContainerRuntimeOptions(
    get_old_InterfaceDeclaration_IContainerRuntimeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerRuntimeOptions():
    TypeOnly<current.IContainerRuntimeOptions>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeOptions(
    use: TypeOnly<old.IContainerRuntimeOptions>);
use_old_InterfaceDeclaration_IContainerRuntimeOptions(
    get_current_InterfaceDeclaration_IContainerRuntimeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEnqueueSummarizeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IEnqueueSummarizeOptions():
    TypeOnly<old.IEnqueueSummarizeOptions>;
declare function use_current_InterfaceDeclaration_IEnqueueSummarizeOptions(
    use: TypeOnly<current.IEnqueueSummarizeOptions>);
use_current_InterfaceDeclaration_IEnqueueSummarizeOptions(
    get_old_InterfaceDeclaration_IEnqueueSummarizeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEnqueueSummarizeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IEnqueueSummarizeOptions():
    TypeOnly<current.IEnqueueSummarizeOptions>;
declare function use_old_InterfaceDeclaration_IEnqueueSummarizeOptions(
    use: TypeOnly<old.IEnqueueSummarizeOptions>);
use_old_InterfaceDeclaration_IEnqueueSummarizeOptions(
    get_current_InterfaceDeclaration_IEnqueueSummarizeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGarbageCollectionRuntime": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGarbageCollectionRuntime():
    TypeOnly<old.IGarbageCollectionRuntime>;
declare function use_current_InterfaceDeclaration_IGarbageCollectionRuntime(
    use: TypeOnly<current.IGarbageCollectionRuntime>);
use_current_InterfaceDeclaration_IGarbageCollectionRuntime(
    get_old_InterfaceDeclaration_IGarbageCollectionRuntime());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGarbageCollectionRuntime": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGarbageCollectionRuntime():
    TypeOnly<current.IGarbageCollectionRuntime>;
declare function use_old_InterfaceDeclaration_IGarbageCollectionRuntime(
    use: TypeOnly<old.IGarbageCollectionRuntime>);
use_old_InterfaceDeclaration_IGarbageCollectionRuntime(
    get_current_InterfaceDeclaration_IGarbageCollectionRuntime());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGCRuntimeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGCRuntimeOptions():
    TypeOnly<old.IGCRuntimeOptions>;
declare function use_current_InterfaceDeclaration_IGCRuntimeOptions(
    use: TypeOnly<current.IGCRuntimeOptions>);
use_current_InterfaceDeclaration_IGCRuntimeOptions(
    get_old_InterfaceDeclaration_IGCRuntimeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGCRuntimeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGCRuntimeOptions():
    TypeOnly<current.IGCRuntimeOptions>;
declare function use_old_InterfaceDeclaration_IGCRuntimeOptions(
    use: TypeOnly<old.IGCRuntimeOptions>);
use_old_InterfaceDeclaration_IGCRuntimeOptions(
    get_current_InterfaceDeclaration_IGCRuntimeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGCStats": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGCStats():
    TypeOnly<old.IGCStats>;
declare function use_current_InterfaceDeclaration_IGCStats(
    use: TypeOnly<current.IGCStats>);
use_current_InterfaceDeclaration_IGCStats(
    get_old_InterfaceDeclaration_IGCStats());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGCStats": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGCStats():
    TypeOnly<current.IGCStats>;
declare function use_old_InterfaceDeclaration_IGCStats(
    use: TypeOnly<old.IGCStats>);
use_old_InterfaceDeclaration_IGCStats(
    get_current_InterfaceDeclaration_IGCStats());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGeneratedSummaryStats": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGeneratedSummaryStats():
    TypeOnly<old.IGeneratedSummaryStats>;
declare function use_current_InterfaceDeclaration_IGeneratedSummaryStats(
    use: TypeOnly<current.IGeneratedSummaryStats>);
use_current_InterfaceDeclaration_IGeneratedSummaryStats(
    get_old_InterfaceDeclaration_IGeneratedSummaryStats());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGeneratedSummaryStats": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGeneratedSummaryStats():
    TypeOnly<current.IGeneratedSummaryStats>;
declare function use_old_InterfaceDeclaration_IGeneratedSummaryStats(
    use: TypeOnly<old.IGeneratedSummaryStats>);
use_old_InterfaceDeclaration_IGeneratedSummaryStats(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IGeneratedSummaryStats());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGenerateSummaryTreeResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGenerateSummaryTreeResult():
    TypeOnly<old.IGenerateSummaryTreeResult>;
declare function use_current_InterfaceDeclaration_IGenerateSummaryTreeResult(
    use: TypeOnly<current.IGenerateSummaryTreeResult>);
use_current_InterfaceDeclaration_IGenerateSummaryTreeResult(
    get_old_InterfaceDeclaration_IGenerateSummaryTreeResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGenerateSummaryTreeResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGenerateSummaryTreeResult():
    TypeOnly<current.IGenerateSummaryTreeResult>;
declare function use_old_InterfaceDeclaration_IGenerateSummaryTreeResult(
    use: TypeOnly<old.IGenerateSummaryTreeResult>);
use_old_InterfaceDeclaration_IGenerateSummaryTreeResult(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IGenerateSummaryTreeResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INackSummaryResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_INackSummaryResult():
    TypeOnly<old.INackSummaryResult>;
declare function use_current_InterfaceDeclaration_INackSummaryResult(
    use: TypeOnly<current.INackSummaryResult>);
use_current_InterfaceDeclaration_INackSummaryResult(
    get_old_InterfaceDeclaration_INackSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INackSummaryResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_INackSummaryResult():
    TypeOnly<current.INackSummaryResult>;
declare function use_old_InterfaceDeclaration_INackSummaryResult(
    use: TypeOnly<old.INackSummaryResult>);
use_old_InterfaceDeclaration_INackSummaryResult(
    get_current_InterfaceDeclaration_INackSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOnDemandSummarizeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOnDemandSummarizeOptions():
    TypeOnly<old.IOnDemandSummarizeOptions>;
declare function use_current_InterfaceDeclaration_IOnDemandSummarizeOptions(
    use: TypeOnly<current.IOnDemandSummarizeOptions>);
use_current_InterfaceDeclaration_IOnDemandSummarizeOptions(
    get_old_InterfaceDeclaration_IOnDemandSummarizeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOnDemandSummarizeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOnDemandSummarizeOptions():
    TypeOnly<current.IOnDemandSummarizeOptions>;
declare function use_old_InterfaceDeclaration_IOnDemandSummarizeOptions(
    use: TypeOnly<old.IOnDemandSummarizeOptions>);
use_old_InterfaceDeclaration_IOnDemandSummarizeOptions(
    get_current_InterfaceDeclaration_IOnDemandSummarizeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingFlush": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPendingFlush():
    TypeOnly<old.IPendingFlush>;
declare function use_current_InterfaceDeclaration_IPendingFlush(
    use: TypeOnly<current.IPendingFlush>);
use_current_InterfaceDeclaration_IPendingFlush(
    get_old_InterfaceDeclaration_IPendingFlush());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingFlush": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPendingFlush():
    TypeOnly<current.IPendingFlush>;
declare function use_old_InterfaceDeclaration_IPendingFlush(
    use: TypeOnly<old.IPendingFlush>);
use_old_InterfaceDeclaration_IPendingFlush(
    get_current_InterfaceDeclaration_IPendingFlush());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingFlushMode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPendingFlushMode():
    TypeOnly<old.IPendingFlushMode>;
declare function use_current_InterfaceDeclaration_IPendingFlushMode(
    use: TypeOnly<current.IPendingFlushMode>);
use_current_InterfaceDeclaration_IPendingFlushMode(
    get_old_InterfaceDeclaration_IPendingFlushMode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingFlushMode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPendingFlushMode():
    TypeOnly<current.IPendingFlushMode>;
declare function use_old_InterfaceDeclaration_IPendingFlushMode(
    use: TypeOnly<old.IPendingFlushMode>);
use_old_InterfaceDeclaration_IPendingFlushMode(
    get_current_InterfaceDeclaration_IPendingFlushMode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingLocalState": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPendingLocalState():
    TypeOnly<old.IPendingLocalState>;
declare function use_current_InterfaceDeclaration_IPendingLocalState(
    use: TypeOnly<current.IPendingLocalState>);
use_current_InterfaceDeclaration_IPendingLocalState(
    get_old_InterfaceDeclaration_IPendingLocalState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingLocalState": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPendingLocalState():
    TypeOnly<current.IPendingLocalState>;
declare function use_old_InterfaceDeclaration_IPendingLocalState(
    use: TypeOnly<old.IPendingLocalState>);
use_old_InterfaceDeclaration_IPendingLocalState(
    get_current_InterfaceDeclaration_IPendingLocalState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPendingMessage():
    TypeOnly<old.IPendingMessage>;
declare function use_current_InterfaceDeclaration_IPendingMessage(
    use: TypeOnly<current.IPendingMessage>);
use_current_InterfaceDeclaration_IPendingMessage(
    get_old_InterfaceDeclaration_IPendingMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPendingMessage():
    TypeOnly<current.IPendingMessage>;
declare function use_old_InterfaceDeclaration_IPendingMessage(
    use: TypeOnly<old.IPendingMessage>);
use_old_InterfaceDeclaration_IPendingMessage(
    get_current_InterfaceDeclaration_IPendingMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedInterfaceDeclaration_IPendingRuntimeState": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedInterfaceDeclaration_IPendingRuntimeState": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IPendingState": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IPendingState():
    TypeOnly<old.IPendingState>;
declare function use_current_TypeAliasDeclaration_IPendingState(
    use: TypeOnly<current.IPendingState>);
use_current_TypeAliasDeclaration_IPendingState(
    get_old_TypeAliasDeclaration_IPendingState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IPendingState": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IPendingState():
    TypeOnly<current.IPendingState>;
declare function use_old_TypeAliasDeclaration_IPendingState(
    use: TypeOnly<old.IPendingState>);
use_old_TypeAliasDeclaration_IPendingState(
    get_current_TypeAliasDeclaration_IPendingState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideSummarizer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideSummarizer():
    TypeOnly<old.IProvideSummarizer>;
declare function use_current_InterfaceDeclaration_IProvideSummarizer(
    use: TypeOnly<current.IProvideSummarizer>);
use_current_InterfaceDeclaration_IProvideSummarizer(
    get_old_InterfaceDeclaration_IProvideSummarizer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideSummarizer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideSummarizer():
    TypeOnly<current.IProvideSummarizer>;
declare function use_old_InterfaceDeclaration_IProvideSummarizer(
    use: TypeOnly<old.IProvideSummarizer>);
use_old_InterfaceDeclaration_IProvideSummarizer(
    get_current_InterfaceDeclaration_IProvideSummarizer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRootSummaryTreeWithStats": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRootSummaryTreeWithStats():
    TypeOnly<old.IRootSummaryTreeWithStats>;
declare function use_current_InterfaceDeclaration_IRootSummaryTreeWithStats(
    use: TypeOnly<current.IRootSummaryTreeWithStats>);
use_current_InterfaceDeclaration_IRootSummaryTreeWithStats(
    get_old_InterfaceDeclaration_IRootSummaryTreeWithStats());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRootSummaryTreeWithStats": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRootSummaryTreeWithStats():
    TypeOnly<current.IRootSummaryTreeWithStats>;
declare function use_old_InterfaceDeclaration_IRootSummaryTreeWithStats(
    use: TypeOnly<old.IRootSummaryTreeWithStats>);
use_old_InterfaceDeclaration_IRootSummaryTreeWithStats(
    get_current_InterfaceDeclaration_IRootSummaryTreeWithStats());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isRuntimeMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isRuntimeMessage():
    TypeOnly<typeof old.isRuntimeMessage>;
declare function use_current_FunctionDeclaration_isRuntimeMessage(
    use: TypeOnly<typeof current.isRuntimeMessage>);
use_current_FunctionDeclaration_isRuntimeMessage(
    get_old_FunctionDeclaration_isRuntimeMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isRuntimeMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isRuntimeMessage():
    TypeOnly<typeof current.isRuntimeMessage>;
declare function use_old_FunctionDeclaration_isRuntimeMessage(
    use: TypeOnly<typeof old.isRuntimeMessage>);
use_old_FunctionDeclaration_isRuntimeMessage(
    get_current_FunctionDeclaration_isRuntimeMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISubmitSummaryOpResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISubmitSummaryOpResult():
    TypeOnly<old.ISubmitSummaryOpResult>;
declare function use_current_InterfaceDeclaration_ISubmitSummaryOpResult(
    use: TypeOnly<current.ISubmitSummaryOpResult>);
use_current_InterfaceDeclaration_ISubmitSummaryOpResult(
    get_old_InterfaceDeclaration_ISubmitSummaryOpResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISubmitSummaryOpResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISubmitSummaryOpResult():
    TypeOnly<current.ISubmitSummaryOpResult>;
declare function use_old_InterfaceDeclaration_ISubmitSummaryOpResult(
    use: TypeOnly<old.ISubmitSummaryOpResult>);
use_old_InterfaceDeclaration_ISubmitSummaryOpResult(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_ISubmitSummaryOpResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISubmitSummaryOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISubmitSummaryOptions():
    TypeOnly<old.ISubmitSummaryOptions>;
declare function use_current_InterfaceDeclaration_ISubmitSummaryOptions(
    use: TypeOnly<current.ISubmitSummaryOptions>);
use_current_InterfaceDeclaration_ISubmitSummaryOptions(
    get_old_InterfaceDeclaration_ISubmitSummaryOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISubmitSummaryOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISubmitSummaryOptions():
    TypeOnly<current.ISubmitSummaryOptions>;
declare function use_old_InterfaceDeclaration_ISubmitSummaryOptions(
    use: TypeOnly<old.ISubmitSummaryOptions>);
use_old_InterfaceDeclaration_ISubmitSummaryOptions(
    get_current_InterfaceDeclaration_ISubmitSummaryOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizeOptions():
    TypeOnly<old.ISummarizeOptions>;
declare function use_current_InterfaceDeclaration_ISummarizeOptions(
    use: TypeOnly<current.ISummarizeOptions>);
use_current_InterfaceDeclaration_ISummarizeOptions(
    get_old_InterfaceDeclaration_ISummarizeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizeOptions():
    TypeOnly<current.ISummarizeOptions>;
declare function use_old_InterfaceDeclaration_ISummarizeOptions(
    use: TypeOnly<old.ISummarizeOptions>);
use_old_InterfaceDeclaration_ISummarizeOptions(
    get_current_InterfaceDeclaration_ISummarizeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ISummarizer": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_ISummarizer():
    TypeOnly<typeof old.ISummarizer>;
declare function use_current_VariableDeclaration_ISummarizer(
    use: TypeOnly<typeof current.ISummarizer>);
use_current_VariableDeclaration_ISummarizer(
    get_old_VariableDeclaration_ISummarizer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ISummarizer": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_ISummarizer():
    TypeOnly<typeof current.ISummarizer>;
declare function use_old_VariableDeclaration_ISummarizer(
    use: TypeOnly<typeof old.ISummarizer>);
use_old_VariableDeclaration_ISummarizer(
    get_current_VariableDeclaration_ISummarizer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizer():
    TypeOnly<old.ISummarizer>;
declare function use_current_InterfaceDeclaration_ISummarizer(
    use: TypeOnly<current.ISummarizer>);
use_current_InterfaceDeclaration_ISummarizer(
    get_old_InterfaceDeclaration_ISummarizer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizer():
    TypeOnly<current.ISummarizer>;
declare function use_old_InterfaceDeclaration_ISummarizer(
    use: TypeOnly<old.ISummarizer>);
use_old_InterfaceDeclaration_ISummarizer(
    get_current_InterfaceDeclaration_ISummarizer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeResults": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizeResults():
    TypeOnly<old.ISummarizeResults>;
declare function use_current_InterfaceDeclaration_ISummarizeResults(
    use: TypeOnly<current.ISummarizeResults>);
use_current_InterfaceDeclaration_ISummarizeResults(
    get_old_InterfaceDeclaration_ISummarizeResults());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeResults": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizeResults():
    TypeOnly<current.ISummarizeResults>;
declare function use_old_InterfaceDeclaration_ISummarizeResults(
    use: TypeOnly<old.ISummarizeResults>);
use_old_InterfaceDeclaration_ISummarizeResults(
    get_current_InterfaceDeclaration_ISummarizeResults());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerEvents():
    TypeOnly<old.ISummarizerEvents>;
declare function use_current_InterfaceDeclaration_ISummarizerEvents(
    use: TypeOnly<current.ISummarizerEvents>);
use_current_InterfaceDeclaration_ISummarizerEvents(
    get_old_InterfaceDeclaration_ISummarizerEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerEvents():
    TypeOnly<current.ISummarizerEvents>;
declare function use_old_InterfaceDeclaration_ISummarizerEvents(
    use: TypeOnly<old.ISummarizerEvents>);
use_old_InterfaceDeclaration_ISummarizerEvents(
    get_current_InterfaceDeclaration_ISummarizerEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerInternalsProvider": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerInternalsProvider():
    TypeOnly<old.ISummarizerInternalsProvider>;
declare function use_current_InterfaceDeclaration_ISummarizerInternalsProvider(
    use: TypeOnly<current.ISummarizerInternalsProvider>);
use_current_InterfaceDeclaration_ISummarizerInternalsProvider(
    get_old_InterfaceDeclaration_ISummarizerInternalsProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerInternalsProvider": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerInternalsProvider():
    TypeOnly<current.ISummarizerInternalsProvider>;
declare function use_old_InterfaceDeclaration_ISummarizerInternalsProvider(
    use: TypeOnly<old.ISummarizerInternalsProvider>);
use_old_InterfaceDeclaration_ISummarizerInternalsProvider(
    get_current_InterfaceDeclaration_ISummarizerInternalsProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerRuntime": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerRuntime():
    TypeOnly<old.ISummarizerRuntime>;
declare function use_current_InterfaceDeclaration_ISummarizerRuntime(
    use: TypeOnly<current.ISummarizerRuntime>);
use_current_InterfaceDeclaration_ISummarizerRuntime(
    get_old_InterfaceDeclaration_ISummarizerRuntime());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerRuntime": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerRuntime():
    TypeOnly<current.ISummarizerRuntime>;
declare function use_old_InterfaceDeclaration_ISummarizerRuntime(
    use: TypeOnly<old.ISummarizerRuntime>);
use_old_InterfaceDeclaration_ISummarizerRuntime(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_ISummarizerRuntime());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizingWarning": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizingWarning():
    TypeOnly<old.ISummarizingWarning>;
declare function use_current_InterfaceDeclaration_ISummarizingWarning(
    use: TypeOnly<current.ISummarizingWarning>);
use_current_InterfaceDeclaration_ISummarizingWarning(
    get_old_InterfaceDeclaration_ISummarizingWarning());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizingWarning": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizingWarning():
    TypeOnly<current.ISummarizingWarning>;
declare function use_old_InterfaceDeclaration_ISummarizingWarning(
    use: TypeOnly<old.ISummarizingWarning>);
use_old_InterfaceDeclaration_ISummarizingWarning(
    get_current_InterfaceDeclaration_ISummarizingWarning());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummary": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummary():
    TypeOnly<old.ISummary>;
declare function use_current_InterfaceDeclaration_ISummary(
    use: TypeOnly<current.ISummary>);
use_current_InterfaceDeclaration_ISummary(
    get_old_InterfaceDeclaration_ISummary());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummary": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummary():
    TypeOnly<current.ISummary>;
declare function use_old_InterfaceDeclaration_ISummary(
    use: TypeOnly<old.ISummary>);
use_old_InterfaceDeclaration_ISummary(
    get_current_InterfaceDeclaration_ISummary());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryAckMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryAckMessage():
    TypeOnly<old.ISummaryAckMessage>;
declare function use_current_InterfaceDeclaration_ISummaryAckMessage(
    use: TypeOnly<current.ISummaryAckMessage>);
use_current_InterfaceDeclaration_ISummaryAckMessage(
    get_old_InterfaceDeclaration_ISummaryAckMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryAckMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryAckMessage():
    TypeOnly<current.ISummaryAckMessage>;
declare function use_old_InterfaceDeclaration_ISummaryAckMessage(
    use: TypeOnly<old.ISummaryAckMessage>);
use_old_InterfaceDeclaration_ISummaryAckMessage(
    get_current_InterfaceDeclaration_ISummaryAckMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryBaseConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryBaseConfiguration():
    TypeOnly<old.ISummaryBaseConfiguration>;
declare function use_current_InterfaceDeclaration_ISummaryBaseConfiguration(
    use: TypeOnly<current.ISummaryBaseConfiguration>);
use_current_InterfaceDeclaration_ISummaryBaseConfiguration(
    get_old_InterfaceDeclaration_ISummaryBaseConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryBaseConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryBaseConfiguration():
    TypeOnly<current.ISummaryBaseConfiguration>;
declare function use_old_InterfaceDeclaration_ISummaryBaseConfiguration(
    use: TypeOnly<old.ISummaryBaseConfiguration>);
use_old_InterfaceDeclaration_ISummaryBaseConfiguration(
    get_current_InterfaceDeclaration_ISummaryBaseConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISummaryCancellationToken": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ISummaryCancellationToken():
    TypeOnly<old.ISummaryCancellationToken>;
declare function use_current_TypeAliasDeclaration_ISummaryCancellationToken(
    use: TypeOnly<current.ISummaryCancellationToken>);
use_current_TypeAliasDeclaration_ISummaryCancellationToken(
    get_old_TypeAliasDeclaration_ISummaryCancellationToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISummaryCancellationToken": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ISummaryCancellationToken():
    TypeOnly<current.ISummaryCancellationToken>;
declare function use_old_TypeAliasDeclaration_ISummaryCancellationToken(
    use: TypeOnly<old.ISummaryCancellationToken>);
use_old_TypeAliasDeclaration_ISummaryCancellationToken(
    get_current_TypeAliasDeclaration_ISummaryCancellationToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryCollectionOpEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryCollectionOpEvents():
    TypeOnly<old.ISummaryCollectionOpEvents>;
declare function use_current_InterfaceDeclaration_ISummaryCollectionOpEvents(
    use: TypeOnly<current.ISummaryCollectionOpEvents>);
use_current_InterfaceDeclaration_ISummaryCollectionOpEvents(
    get_old_InterfaceDeclaration_ISummaryCollectionOpEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryCollectionOpEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryCollectionOpEvents():
    TypeOnly<current.ISummaryCollectionOpEvents>;
declare function use_old_InterfaceDeclaration_ISummaryCollectionOpEvents(
    use: TypeOnly<old.ISummaryCollectionOpEvents>);
use_old_InterfaceDeclaration_ISummaryCollectionOpEvents(
    get_current_InterfaceDeclaration_ISummaryCollectionOpEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISummaryConfiguration": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ISummaryConfiguration():
    TypeOnly<old.ISummaryConfiguration>;
declare function use_current_TypeAliasDeclaration_ISummaryConfiguration(
    use: TypeOnly<current.ISummaryConfiguration>);
use_current_TypeAliasDeclaration_ISummaryConfiguration(
    // @ts-expect-error compatibility expected to be broken
    get_old_TypeAliasDeclaration_ISummaryConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISummaryConfiguration": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ISummaryConfiguration():
    TypeOnly<current.ISummaryConfiguration>;
declare function use_old_TypeAliasDeclaration_ISummaryConfiguration(
    use: TypeOnly<old.ISummaryConfiguration>);
use_old_TypeAliasDeclaration_ISummaryConfiguration(
    get_current_TypeAliasDeclaration_ISummaryConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationDisableHeuristics": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics():
    TypeOnly<old.ISummaryConfigurationDisableHeuristics>;
declare function use_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    use: TypeOnly<current.ISummaryConfigurationDisableHeuristics>);
use_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    get_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationDisableHeuristics": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics():
    TypeOnly<current.ISummaryConfigurationDisableHeuristics>;
declare function use_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    use: TypeOnly<old.ISummaryConfigurationDisableHeuristics>);
use_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    get_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationDisableSummarizer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer():
    TypeOnly<old.ISummaryConfigurationDisableSummarizer>;
declare function use_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    use: TypeOnly<current.ISummaryConfigurationDisableSummarizer>);
use_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    get_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationDisableSummarizer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer():
    TypeOnly<current.ISummaryConfigurationDisableSummarizer>;
declare function use_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    use: TypeOnly<old.ISummaryConfigurationDisableSummarizer>);
use_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    get_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationHeuristics": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryConfigurationHeuristics():
    TypeOnly<old.ISummaryConfigurationHeuristics>;
declare function use_current_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    use: TypeOnly<current.ISummaryConfigurationHeuristics>);
use_current_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_ISummaryConfigurationHeuristics());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationHeuristics": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryConfigurationHeuristics():
    TypeOnly<current.ISummaryConfigurationHeuristics>;
declare function use_old_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    use: TypeOnly<old.ISummaryConfigurationHeuristics>);
use_old_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    get_current_InterfaceDeclaration_ISummaryConfigurationHeuristics());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryNackMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryNackMessage():
    TypeOnly<old.ISummaryNackMessage>;
declare function use_current_InterfaceDeclaration_ISummaryNackMessage(
    use: TypeOnly<current.ISummaryNackMessage>);
use_current_InterfaceDeclaration_ISummaryNackMessage(
    get_old_InterfaceDeclaration_ISummaryNackMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryNackMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryNackMessage():
    TypeOnly<current.ISummaryNackMessage>;
declare function use_old_InterfaceDeclaration_ISummaryNackMessage(
    use: TypeOnly<old.ISummaryNackMessage>);
use_old_InterfaceDeclaration_ISummaryNackMessage(
    get_current_InterfaceDeclaration_ISummaryNackMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryOpMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryOpMessage():
    TypeOnly<old.ISummaryOpMessage>;
declare function use_current_InterfaceDeclaration_ISummaryOpMessage(
    use: TypeOnly<current.ISummaryOpMessage>);
use_current_InterfaceDeclaration_ISummaryOpMessage(
    get_old_InterfaceDeclaration_ISummaryOpMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryOpMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryOpMessage():
    TypeOnly<current.ISummaryOpMessage>;
declare function use_old_InterfaceDeclaration_ISummaryOpMessage(
    use: TypeOnly<old.ISummaryOpMessage>);
use_old_InterfaceDeclaration_ISummaryOpMessage(
    get_current_InterfaceDeclaration_ISummaryOpMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryRuntimeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryRuntimeOptions():
    TypeOnly<old.ISummaryRuntimeOptions>;
declare function use_current_InterfaceDeclaration_ISummaryRuntimeOptions(
    use: TypeOnly<current.ISummaryRuntimeOptions>);
use_current_InterfaceDeclaration_ISummaryRuntimeOptions(
    get_old_InterfaceDeclaration_ISummaryRuntimeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryRuntimeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryRuntimeOptions():
    TypeOnly<current.ISummaryRuntimeOptions>;
declare function use_old_InterfaceDeclaration_ISummaryRuntimeOptions(
    use: TypeOnly<old.ISummaryRuntimeOptions>);
use_old_InterfaceDeclaration_ISummaryRuntimeOptions(
    get_current_InterfaceDeclaration_ISummaryRuntimeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUploadSummaryResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IUploadSummaryResult():
    TypeOnly<old.IUploadSummaryResult>;
declare function use_current_InterfaceDeclaration_IUploadSummaryResult(
    use: TypeOnly<current.IUploadSummaryResult>);
use_current_InterfaceDeclaration_IUploadSummaryResult(
    get_old_InterfaceDeclaration_IUploadSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUploadSummaryResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IUploadSummaryResult():
    TypeOnly<current.IUploadSummaryResult>;
declare function use_old_InterfaceDeclaration_IUploadSummaryResult(
    use: TypeOnly<old.IUploadSummaryResult>);
use_old_InterfaceDeclaration_IUploadSummaryResult(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IUploadSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_neverCancelledSummaryToken": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_neverCancelledSummaryToken():
    TypeOnly<typeof old.neverCancelledSummaryToken>;
declare function use_current_VariableDeclaration_neverCancelledSummaryToken(
    use: TypeOnly<typeof current.neverCancelledSummaryToken>);
use_current_VariableDeclaration_neverCancelledSummaryToken(
    get_old_VariableDeclaration_neverCancelledSummaryToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_neverCancelledSummaryToken": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_neverCancelledSummaryToken():
    TypeOnly<typeof current.neverCancelledSummaryToken>;
declare function use_old_VariableDeclaration_neverCancelledSummaryToken(
    use: TypeOnly<typeof old.neverCancelledSummaryToken>);
use_old_VariableDeclaration_neverCancelledSummaryToken(
    get_current_VariableDeclaration_neverCancelledSummaryToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OpActionEventListener": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_OpActionEventListener():
    TypeOnly<old.OpActionEventListener>;
declare function use_current_TypeAliasDeclaration_OpActionEventListener(
    use: TypeOnly<current.OpActionEventListener>);
use_current_TypeAliasDeclaration_OpActionEventListener(
    get_old_TypeAliasDeclaration_OpActionEventListener());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OpActionEventListener": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_OpActionEventListener():
    TypeOnly<current.OpActionEventListener>;
declare function use_old_TypeAliasDeclaration_OpActionEventListener(
    use: TypeOnly<old.OpActionEventListener>);
use_old_TypeAliasDeclaration_OpActionEventListener(
    get_current_TypeAliasDeclaration_OpActionEventListener());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OpActionEventName": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_OpActionEventName():
    TypeOnly<old.OpActionEventName>;
declare function use_current_TypeAliasDeclaration_OpActionEventName(
    use: TypeOnly<current.OpActionEventName>);
use_current_TypeAliasDeclaration_OpActionEventName(
    get_old_TypeAliasDeclaration_OpActionEventName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OpActionEventName": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_OpActionEventName():
    TypeOnly<current.OpActionEventName>;
declare function use_old_TypeAliasDeclaration_OpActionEventName(
    use: TypeOnly<old.OpActionEventName>);
use_old_TypeAliasDeclaration_OpActionEventName(
    get_current_TypeAliasDeclaration_OpActionEventName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RuntimeHeaders": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_RuntimeHeaders():
    TypeOnly<old.RuntimeHeaders>;
declare function use_current_EnumDeclaration_RuntimeHeaders(
    use: TypeOnly<current.RuntimeHeaders>);
use_current_EnumDeclaration_RuntimeHeaders(
    get_old_EnumDeclaration_RuntimeHeaders());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RuntimeHeaders": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_RuntimeHeaders():
    TypeOnly<current.RuntimeHeaders>;
declare function use_old_EnumDeclaration_RuntimeHeaders(
    use: TypeOnly<old.RuntimeHeaders>);
use_old_EnumDeclaration_RuntimeHeaders(
    get_current_EnumDeclaration_RuntimeHeaders());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RuntimeMessage": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_RuntimeMessage():
    TypeOnly<old.RuntimeMessage>;
declare function use_current_EnumDeclaration_RuntimeMessage(
    use: TypeOnly<current.RuntimeMessage>);
use_current_EnumDeclaration_RuntimeMessage(
    get_old_EnumDeclaration_RuntimeMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RuntimeMessage": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_RuntimeMessage():
    TypeOnly<current.RuntimeMessage>;
declare function use_old_EnumDeclaration_RuntimeMessage(
    use: TypeOnly<old.RuntimeMessage>);
use_old_EnumDeclaration_RuntimeMessage(
    get_current_EnumDeclaration_RuntimeMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScheduleManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ScheduleManager():
    TypeOnly<old.ScheduleManager>;
declare function use_current_ClassDeclaration_ScheduleManager(
    use: TypeOnly<current.ScheduleManager>);
use_current_ClassDeclaration_ScheduleManager(
    get_old_ClassDeclaration_ScheduleManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScheduleManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ScheduleManager():
    TypeOnly<current.ScheduleManager>;
declare function use_old_ClassDeclaration_ScheduleManager(
    use: TypeOnly<old.ScheduleManager>);
use_old_ClassDeclaration_ScheduleManager(
    get_current_ClassDeclaration_ScheduleManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SubmitSummaryResult": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SubmitSummaryResult():
    TypeOnly<old.SubmitSummaryResult>;
declare function use_current_TypeAliasDeclaration_SubmitSummaryResult(
    use: TypeOnly<current.SubmitSummaryResult>);
use_current_TypeAliasDeclaration_SubmitSummaryResult(
    get_old_TypeAliasDeclaration_SubmitSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SubmitSummaryResult": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SubmitSummaryResult():
    TypeOnly<current.SubmitSummaryResult>;
declare function use_old_TypeAliasDeclaration_SubmitSummaryResult(
    use: TypeOnly<old.SubmitSummaryResult>);
use_old_TypeAliasDeclaration_SubmitSummaryResult(
    // @ts-expect-error compatibility expected to be broken
    get_current_TypeAliasDeclaration_SubmitSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Summarizer": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Summarizer():
    TypeOnly<old.Summarizer>;
declare function use_current_ClassDeclaration_Summarizer(
    use: TypeOnly<current.Summarizer>);
use_current_ClassDeclaration_Summarizer(
    get_old_ClassDeclaration_Summarizer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Summarizer": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Summarizer():
    TypeOnly<current.Summarizer>;
declare function use_old_ClassDeclaration_Summarizer(
    use: TypeOnly<old.Summarizer>);
use_old_ClassDeclaration_Summarizer(
    get_current_ClassDeclaration_Summarizer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizeResultPart": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummarizeResultPart():
    TypeOnly<old.SummarizeResultPart<any,any>>;
declare function use_current_TypeAliasDeclaration_SummarizeResultPart(
    use: TypeOnly<current.SummarizeResultPart<any,any>>);
use_current_TypeAliasDeclaration_SummarizeResultPart(
    get_old_TypeAliasDeclaration_SummarizeResultPart());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizeResultPart": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummarizeResultPart():
    TypeOnly<current.SummarizeResultPart<any,any>>;
declare function use_old_TypeAliasDeclaration_SummarizeResultPart(
    use: TypeOnly<old.SummarizeResultPart<any,any>>);
use_old_TypeAliasDeclaration_SummarizeResultPart(
    get_current_TypeAliasDeclaration_SummarizeResultPart());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizerStopReason": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummarizerStopReason():
    TypeOnly<old.SummarizerStopReason>;
declare function use_current_TypeAliasDeclaration_SummarizerStopReason(
    use: TypeOnly<current.SummarizerStopReason>);
use_current_TypeAliasDeclaration_SummarizerStopReason(
    get_old_TypeAliasDeclaration_SummarizerStopReason());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizerStopReason": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummarizerStopReason():
    TypeOnly<current.SummarizerStopReason>;
declare function use_old_TypeAliasDeclaration_SummarizerStopReason(
    use: TypeOnly<old.SummarizerStopReason>);
use_old_TypeAliasDeclaration_SummarizerStopReason(
    get_current_TypeAliasDeclaration_SummarizerStopReason());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryCollection": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SummaryCollection():
    TypeOnly<old.SummaryCollection>;
declare function use_current_ClassDeclaration_SummaryCollection(
    use: TypeOnly<current.SummaryCollection>);
use_current_ClassDeclaration_SummaryCollection(
    get_old_ClassDeclaration_SummaryCollection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryCollection": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SummaryCollection():
    TypeOnly<current.SummaryCollection>;
declare function use_old_ClassDeclaration_SummaryCollection(
    use: TypeOnly<old.SummaryCollection>);
use_old_ClassDeclaration_SummaryCollection(
    get_current_ClassDeclaration_SummaryCollection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_unpackRuntimeMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_unpackRuntimeMessage():
    TypeOnly<typeof old.unpackRuntimeMessage>;
declare function use_current_FunctionDeclaration_unpackRuntimeMessage(
    use: TypeOnly<typeof current.unpackRuntimeMessage>);
use_current_FunctionDeclaration_unpackRuntimeMessage(
    get_old_FunctionDeclaration_unpackRuntimeMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_unpackRuntimeMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_unpackRuntimeMessage():
    TypeOnly<typeof current.unpackRuntimeMessage>;
declare function use_old_FunctionDeclaration_unpackRuntimeMessage(
    use: TypeOnly<typeof old.unpackRuntimeMessage>);
use_old_FunctionDeclaration_unpackRuntimeMessage(
    get_current_FunctionDeclaration_unpackRuntimeMessage());
