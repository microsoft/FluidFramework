/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */
import type * as old from "@fluidframework/container-runtime-previous";
import type * as current from "../../index";


// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_AllowInactiveRequestHeaderKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_AllowInactiveRequestHeaderKey():
    TypeOnly<typeof old.AllowInactiveRequestHeaderKey>;
declare function use_current_VariableDeclaration_AllowInactiveRequestHeaderKey(
    use: TypeOnly<typeof current.AllowInactiveRequestHeaderKey>);
use_current_VariableDeclaration_AllowInactiveRequestHeaderKey(
    get_old_VariableDeclaration_AllowInactiveRequestHeaderKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_AllowInactiveRequestHeaderKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_AllowInactiveRequestHeaderKey():
    TypeOnly<typeof current.AllowInactiveRequestHeaderKey>;
declare function use_old_VariableDeclaration_AllowInactiveRequestHeaderKey(
    use: TypeOnly<typeof old.AllowInactiveRequestHeaderKey>);
use_old_VariableDeclaration_AllowInactiveRequestHeaderKey(
    get_current_VariableDeclaration_AllowInactiveRequestHeaderKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_AllowTombstoneRequestHeaderKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_AllowTombstoneRequestHeaderKey():
    TypeOnly<typeof old.AllowTombstoneRequestHeaderKey>;
declare function use_current_VariableDeclaration_AllowTombstoneRequestHeaderKey(
    use: TypeOnly<typeof current.AllowTombstoneRequestHeaderKey>);
use_current_VariableDeclaration_AllowTombstoneRequestHeaderKey(
    get_old_VariableDeclaration_AllowTombstoneRequestHeaderKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_AllowTombstoneRequestHeaderKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_AllowTombstoneRequestHeaderKey():
    TypeOnly<typeof current.AllowTombstoneRequestHeaderKey>;
declare function use_old_VariableDeclaration_AllowTombstoneRequestHeaderKey(
    use: TypeOnly<typeof old.AllowTombstoneRequestHeaderKey>);
use_old_VariableDeclaration_AllowTombstoneRequestHeaderKey(
    get_current_VariableDeclaration_AllowTombstoneRequestHeaderKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CompatModeBehavior": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_CompatModeBehavior():
    TypeOnly<old.CompatModeBehavior>;
declare function use_current_TypeAliasDeclaration_CompatModeBehavior(
    use: TypeOnly<current.CompatModeBehavior>);
use_current_TypeAliasDeclaration_CompatModeBehavior(
    get_old_TypeAliasDeclaration_CompatModeBehavior());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CompatModeBehavior": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_CompatModeBehavior():
    TypeOnly<current.CompatModeBehavior>;
declare function use_old_TypeAliasDeclaration_CompatModeBehavior(
    use: TypeOnly<old.CompatModeBehavior>);
use_old_TypeAliasDeclaration_CompatModeBehavior(
    get_current_TypeAliasDeclaration_CompatModeBehavior());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_CompressionAlgorithms": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_CompressionAlgorithms():
    TypeOnly<old.CompressionAlgorithms>;
declare function use_current_EnumDeclaration_CompressionAlgorithms(
    use: TypeOnly<current.CompressionAlgorithms>);
use_current_EnumDeclaration_CompressionAlgorithms(
    get_old_EnumDeclaration_CompressionAlgorithms());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_CompressionAlgorithms": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_CompressionAlgorithms():
    TypeOnly<current.CompressionAlgorithms>;
declare function use_old_EnumDeclaration_CompressionAlgorithms(
    use: TypeOnly<old.CompressionAlgorithms>);
use_old_EnumDeclaration_CompressionAlgorithms(
    get_current_EnumDeclaration_CompressionAlgorithms());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ContainerMessageType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_ContainerMessageType():
    TypeOnly<old.ContainerMessageType>;
declare function use_current_EnumDeclaration_ContainerMessageType(
    use: TypeOnly<current.ContainerMessageType>);
use_current_EnumDeclaration_ContainerMessageType(
    get_old_EnumDeclaration_ContainerMessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ContainerMessageType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_ContainerMessageType():
    TypeOnly<current.ContainerMessageType>;
declare function use_old_EnumDeclaration_ContainerMessageType(
    use: TypeOnly<old.ContainerMessageType>);
use_old_EnumDeclaration_ContainerMessageType(
    get_current_EnumDeclaration_ContainerMessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ContainerRuntime": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ContainerRuntime():
    TypeOnly<old.ContainerRuntime>;
declare function use_current_ClassDeclaration_ContainerRuntime(
    use: TypeOnly<current.ContainerRuntime>);
use_current_ClassDeclaration_ContainerRuntime(
    get_old_ClassDeclaration_ContainerRuntime());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ContainerRuntime": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ContainerRuntime():
    TypeOnly<current.ContainerRuntime>;
declare function use_old_ClassDeclaration_ContainerRuntime(
    use: TypeOnly<old.ContainerRuntime>);
use_old_ClassDeclaration_ContainerRuntime(
    get_current_ClassDeclaration_ContainerRuntime());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerRuntimeMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerRuntimeMessage():
    TypeOnly<old.ContainerRuntimeMessage>;
declare function use_current_InterfaceDeclaration_ContainerRuntimeMessage(
    use: TypeOnly<current.ContainerRuntimeMessage>);
use_current_InterfaceDeclaration_ContainerRuntimeMessage(
    get_old_InterfaceDeclaration_ContainerRuntimeMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerRuntimeMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerRuntimeMessage():
    TypeOnly<current.ContainerRuntimeMessage>;
declare function use_old_InterfaceDeclaration_ContainerRuntimeMessage(
    use: TypeOnly<old.ContainerRuntimeMessage>);
use_old_InterfaceDeclaration_ContainerRuntimeMessage(
    get_current_InterfaceDeclaration_ContainerRuntimeMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DefaultSummaryConfiguration": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_DefaultSummaryConfiguration():
    TypeOnly<typeof old.DefaultSummaryConfiguration>;
declare function use_current_VariableDeclaration_DefaultSummaryConfiguration(
    use: TypeOnly<typeof current.DefaultSummaryConfiguration>);
use_current_VariableDeclaration_DefaultSummaryConfiguration(
    get_old_VariableDeclaration_DefaultSummaryConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DefaultSummaryConfiguration": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_DefaultSummaryConfiguration():
    TypeOnly<typeof current.DefaultSummaryConfiguration>;
declare function use_old_VariableDeclaration_DefaultSummaryConfiguration(
    use: TypeOnly<typeof old.DefaultSummaryConfiguration>);
use_old_VariableDeclaration_DefaultSummaryConfiguration(
    get_current_VariableDeclaration_DefaultSummaryConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_EnqueueSummarizeResult": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_EnqueueSummarizeResult():
    TypeOnly<old.EnqueueSummarizeResult>;
declare function use_current_TypeAliasDeclaration_EnqueueSummarizeResult(
    use: TypeOnly<current.EnqueueSummarizeResult>);
use_current_TypeAliasDeclaration_EnqueueSummarizeResult(
    get_old_TypeAliasDeclaration_EnqueueSummarizeResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_EnqueueSummarizeResult": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_EnqueueSummarizeResult():
    TypeOnly<current.EnqueueSummarizeResult>;
declare function use_old_TypeAliasDeclaration_EnqueueSummarizeResult(
    use: TypeOnly<old.EnqueueSummarizeResult>);
use_old_TypeAliasDeclaration_EnqueueSummarizeResult(
    get_current_TypeAliasDeclaration_EnqueueSummarizeResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_FluidDataStoreRegistry": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_FluidDataStoreRegistry():
    TypeOnly<old.FluidDataStoreRegistry>;
declare function use_current_ClassDeclaration_FluidDataStoreRegistry(
    use: TypeOnly<current.FluidDataStoreRegistry>);
use_current_ClassDeclaration_FluidDataStoreRegistry(
    get_old_ClassDeclaration_FluidDataStoreRegistry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_FluidDataStoreRegistry": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_FluidDataStoreRegistry():
    TypeOnly<current.FluidDataStoreRegistry>;
declare function use_old_ClassDeclaration_FluidDataStoreRegistry(
    use: TypeOnly<old.FluidDataStoreRegistry>);
use_old_ClassDeclaration_FluidDataStoreRegistry(
    get_current_ClassDeclaration_FluidDataStoreRegistry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAckSummaryResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAckSummaryResult():
    TypeOnly<old.IAckSummaryResult>;
declare function use_current_InterfaceDeclaration_IAckSummaryResult(
    use: TypeOnly<current.IAckSummaryResult>);
use_current_InterfaceDeclaration_IAckSummaryResult(
    get_old_InterfaceDeclaration_IAckSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAckSummaryResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAckSummaryResult():
    TypeOnly<current.IAckSummaryResult>;
declare function use_old_InterfaceDeclaration_IAckSummaryResult(
    use: TypeOnly<old.IAckSummaryResult>);
use_old_InterfaceDeclaration_IAckSummaryResult(
    get_current_InterfaceDeclaration_IAckSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAckedSummary": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAckedSummary():
    TypeOnly<old.IAckedSummary>;
declare function use_current_InterfaceDeclaration_IAckedSummary(
    use: TypeOnly<current.IAckedSummary>);
use_current_InterfaceDeclaration_IAckedSummary(
    get_old_InterfaceDeclaration_IAckedSummary());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAckedSummary": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAckedSummary():
    TypeOnly<current.IAckedSummary>;
declare function use_old_InterfaceDeclaration_IAckedSummary(
    use: TypeOnly<old.IAckedSummary>);
use_old_InterfaceDeclaration_IAckedSummary(
    get_current_InterfaceDeclaration_IAckedSummary());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBaseSummarizeResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IBaseSummarizeResult():
    TypeOnly<old.IBaseSummarizeResult>;
declare function use_current_InterfaceDeclaration_IBaseSummarizeResult(
    use: TypeOnly<current.IBaseSummarizeResult>);
use_current_InterfaceDeclaration_IBaseSummarizeResult(
    get_old_InterfaceDeclaration_IBaseSummarizeResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBaseSummarizeResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IBaseSummarizeResult():
    TypeOnly<current.IBaseSummarizeResult>;
declare function use_old_InterfaceDeclaration_IBaseSummarizeResult(
    use: TypeOnly<old.IBaseSummarizeResult>);
use_old_InterfaceDeclaration_IBaseSummarizeResult(
    get_current_InterfaceDeclaration_IBaseSummarizeResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBroadcastSummaryResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IBroadcastSummaryResult():
    TypeOnly<old.IBroadcastSummaryResult>;
declare function use_current_InterfaceDeclaration_IBroadcastSummaryResult(
    use: TypeOnly<current.IBroadcastSummaryResult>);
use_current_InterfaceDeclaration_IBroadcastSummaryResult(
    get_old_InterfaceDeclaration_IBroadcastSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBroadcastSummaryResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IBroadcastSummaryResult():
    TypeOnly<current.IBroadcastSummaryResult>;
declare function use_old_InterfaceDeclaration_IBroadcastSummaryResult(
    use: TypeOnly<old.IBroadcastSummaryResult>);
use_old_InterfaceDeclaration_IBroadcastSummaryResult(
    get_current_InterfaceDeclaration_IBroadcastSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICancellableSummarizerController": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICancellableSummarizerController():
    TypeOnly<old.ICancellableSummarizerController>;
declare function use_current_InterfaceDeclaration_ICancellableSummarizerController(
    use: TypeOnly<current.ICancellableSummarizerController>);
use_current_InterfaceDeclaration_ICancellableSummarizerController(
    get_old_InterfaceDeclaration_ICancellableSummarizerController());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICancellableSummarizerController": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICancellableSummarizerController():
    TypeOnly<current.ICancellableSummarizerController>;
declare function use_old_InterfaceDeclaration_ICancellableSummarizerController(
    use: TypeOnly<old.ICancellableSummarizerController>);
use_old_InterfaceDeclaration_ICancellableSummarizerController(
    get_current_InterfaceDeclaration_ICancellableSummarizerController());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICancellationToken": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICancellationToken():
    TypeOnly<old.ICancellationToken<any>>;
declare function use_current_InterfaceDeclaration_ICancellationToken(
    use: TypeOnly<current.ICancellationToken<any>>);
use_current_InterfaceDeclaration_ICancellationToken(
    get_old_InterfaceDeclaration_ICancellationToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICancellationToken": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICancellationToken():
    TypeOnly<current.ICancellationToken<any>>;
declare function use_old_InterfaceDeclaration_ICancellationToken(
    use: TypeOnly<old.ICancellationToken<any>>);
use_old_InterfaceDeclaration_ICancellationToken(
    get_current_InterfaceDeclaration_ICancellationToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IChunkedOp": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IChunkedOp():
    TypeOnly<old.IChunkedOp>;
declare function use_current_InterfaceDeclaration_IChunkedOp(
    use: TypeOnly<current.IChunkedOp>);
use_current_InterfaceDeclaration_IChunkedOp(
    get_old_InterfaceDeclaration_IChunkedOp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IChunkedOp": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IChunkedOp():
    TypeOnly<current.IChunkedOp>;
declare function use_old_InterfaceDeclaration_IChunkedOp(
    use: TypeOnly<old.IChunkedOp>);
use_old_InterfaceDeclaration_IChunkedOp(
    get_current_InterfaceDeclaration_IChunkedOp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientSummaryWatcher": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IClientSummaryWatcher():
    TypeOnly<old.IClientSummaryWatcher>;
declare function use_current_InterfaceDeclaration_IClientSummaryWatcher(
    use: TypeOnly<current.IClientSummaryWatcher>);
use_current_InterfaceDeclaration_IClientSummaryWatcher(
    get_old_InterfaceDeclaration_IClientSummaryWatcher());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientSummaryWatcher": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IClientSummaryWatcher():
    TypeOnly<current.IClientSummaryWatcher>;
declare function use_old_InterfaceDeclaration_IClientSummaryWatcher(
    use: TypeOnly<old.IClientSummaryWatcher>);
use_old_InterfaceDeclaration_IClientSummaryWatcher(
    get_current_InterfaceDeclaration_IClientSummaryWatcher());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICompressionRuntimeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICompressionRuntimeOptions():
    TypeOnly<old.ICompressionRuntimeOptions>;
declare function use_current_InterfaceDeclaration_ICompressionRuntimeOptions(
    use: TypeOnly<current.ICompressionRuntimeOptions>);
use_current_InterfaceDeclaration_ICompressionRuntimeOptions(
    get_old_InterfaceDeclaration_ICompressionRuntimeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICompressionRuntimeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICompressionRuntimeOptions():
    TypeOnly<current.ICompressionRuntimeOptions>;
declare function use_old_InterfaceDeclaration_ICompressionRuntimeOptions(
    use: TypeOnly<old.ICompressionRuntimeOptions>);
use_old_InterfaceDeclaration_ICompressionRuntimeOptions(
    get_current_InterfaceDeclaration_ICompressionRuntimeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnectableRuntime": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConnectableRuntime():
    TypeOnly<old.IConnectableRuntime>;
declare function use_current_InterfaceDeclaration_IConnectableRuntime(
    use: TypeOnly<current.IConnectableRuntime>);
use_current_InterfaceDeclaration_IConnectableRuntime(
    get_old_InterfaceDeclaration_IConnectableRuntime());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnectableRuntime": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConnectableRuntime():
    TypeOnly<current.IConnectableRuntime>;
declare function use_old_InterfaceDeclaration_IConnectableRuntime(
    use: TypeOnly<old.IConnectableRuntime>);
use_old_InterfaceDeclaration_IConnectableRuntime(
    get_current_InterfaceDeclaration_IConnectableRuntime());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeMessageCompatDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails():
    TypeOnly<old.IContainerRuntimeMessageCompatDetails>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails(
    use: TypeOnly<current.IContainerRuntimeMessageCompatDetails>);
use_current_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails(
    get_old_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeMessageCompatDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails():
    TypeOnly<current.IContainerRuntimeMessageCompatDetails>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails(
    use: TypeOnly<old.IContainerRuntimeMessageCompatDetails>);
use_old_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails(
    get_current_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerRuntimeOptions():
    TypeOnly<old.IContainerRuntimeOptions>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeOptions(
    use: TypeOnly<current.IContainerRuntimeOptions>);
use_current_InterfaceDeclaration_IContainerRuntimeOptions(
    get_old_InterfaceDeclaration_IContainerRuntimeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerRuntimeOptions():
    TypeOnly<current.IContainerRuntimeOptions>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeOptions(
    use: TypeOnly<old.IContainerRuntimeOptions>);
use_old_InterfaceDeclaration_IContainerRuntimeOptions(
    get_current_InterfaceDeclaration_IContainerRuntimeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEnqueueSummarizeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IEnqueueSummarizeOptions():
    TypeOnly<old.IEnqueueSummarizeOptions>;
declare function use_current_InterfaceDeclaration_IEnqueueSummarizeOptions(
    use: TypeOnly<current.IEnqueueSummarizeOptions>);
use_current_InterfaceDeclaration_IEnqueueSummarizeOptions(
    get_old_InterfaceDeclaration_IEnqueueSummarizeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEnqueueSummarizeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IEnqueueSummarizeOptions():
    TypeOnly<current.IEnqueueSummarizeOptions>;
declare function use_old_InterfaceDeclaration_IEnqueueSummarizeOptions(
    use: TypeOnly<old.IEnqueueSummarizeOptions>);
use_old_InterfaceDeclaration_IEnqueueSummarizeOptions(
    get_current_InterfaceDeclaration_IEnqueueSummarizeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGCRuntimeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGCRuntimeOptions():
    TypeOnly<old.IGCRuntimeOptions>;
declare function use_current_InterfaceDeclaration_IGCRuntimeOptions(
    use: TypeOnly<current.IGCRuntimeOptions>);
use_current_InterfaceDeclaration_IGCRuntimeOptions(
    get_old_InterfaceDeclaration_IGCRuntimeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGCRuntimeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGCRuntimeOptions():
    TypeOnly<current.IGCRuntimeOptions>;
declare function use_old_InterfaceDeclaration_IGCRuntimeOptions(
    use: TypeOnly<old.IGCRuntimeOptions>);
use_old_InterfaceDeclaration_IGCRuntimeOptions(
    get_current_InterfaceDeclaration_IGCRuntimeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGCStats": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGCStats():
    TypeOnly<old.IGCStats>;
declare function use_current_InterfaceDeclaration_IGCStats(
    use: TypeOnly<current.IGCStats>);
use_current_InterfaceDeclaration_IGCStats(
    get_old_InterfaceDeclaration_IGCStats());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGCStats": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGCStats():
    TypeOnly<current.IGCStats>;
declare function use_old_InterfaceDeclaration_IGCStats(
    use: TypeOnly<old.IGCStats>);
use_old_InterfaceDeclaration_IGCStats(
    get_current_InterfaceDeclaration_IGCStats());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGenerateSummaryTreeResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGenerateSummaryTreeResult():
    TypeOnly<old.IGenerateSummaryTreeResult>;
declare function use_current_InterfaceDeclaration_IGenerateSummaryTreeResult(
    use: TypeOnly<current.IGenerateSummaryTreeResult>);
use_current_InterfaceDeclaration_IGenerateSummaryTreeResult(
    get_old_InterfaceDeclaration_IGenerateSummaryTreeResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGenerateSummaryTreeResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGenerateSummaryTreeResult():
    TypeOnly<current.IGenerateSummaryTreeResult>;
declare function use_old_InterfaceDeclaration_IGenerateSummaryTreeResult(
    use: TypeOnly<old.IGenerateSummaryTreeResult>);
use_old_InterfaceDeclaration_IGenerateSummaryTreeResult(
    get_current_InterfaceDeclaration_IGenerateSummaryTreeResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGeneratedSummaryStats": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGeneratedSummaryStats():
    TypeOnly<old.IGeneratedSummaryStats>;
declare function use_current_InterfaceDeclaration_IGeneratedSummaryStats(
    use: TypeOnly<current.IGeneratedSummaryStats>);
use_current_InterfaceDeclaration_IGeneratedSummaryStats(
    get_old_InterfaceDeclaration_IGeneratedSummaryStats());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGeneratedSummaryStats": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGeneratedSummaryStats():
    TypeOnly<current.IGeneratedSummaryStats>;
declare function use_old_InterfaceDeclaration_IGeneratedSummaryStats(
    use: TypeOnly<old.IGeneratedSummaryStats>);
use_old_InterfaceDeclaration_IGeneratedSummaryStats(
    get_current_InterfaceDeclaration_IGeneratedSummaryStats());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INackSummaryResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_INackSummaryResult():
    TypeOnly<old.INackSummaryResult>;
declare function use_current_InterfaceDeclaration_INackSummaryResult(
    use: TypeOnly<current.INackSummaryResult>);
use_current_InterfaceDeclaration_INackSummaryResult(
    get_old_InterfaceDeclaration_INackSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INackSummaryResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_INackSummaryResult():
    TypeOnly<current.INackSummaryResult>;
declare function use_old_InterfaceDeclaration_INackSummaryResult(
    use: TypeOnly<old.INackSummaryResult>);
use_old_InterfaceDeclaration_INackSummaryResult(
    get_current_InterfaceDeclaration_INackSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOnDemandSummarizeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOnDemandSummarizeOptions():
    TypeOnly<old.IOnDemandSummarizeOptions>;
declare function use_current_InterfaceDeclaration_IOnDemandSummarizeOptions(
    use: TypeOnly<current.IOnDemandSummarizeOptions>);
use_current_InterfaceDeclaration_IOnDemandSummarizeOptions(
    get_old_InterfaceDeclaration_IOnDemandSummarizeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOnDemandSummarizeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOnDemandSummarizeOptions():
    TypeOnly<current.IOnDemandSummarizeOptions>;
declare function use_old_InterfaceDeclaration_IOnDemandSummarizeOptions(
    use: TypeOnly<old.IOnDemandSummarizeOptions>);
use_old_InterfaceDeclaration_IOnDemandSummarizeOptions(
    get_current_InterfaceDeclaration_IOnDemandSummarizeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRefreshSummaryAckOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRefreshSummaryAckOptions():
    TypeOnly<old.IRefreshSummaryAckOptions>;
declare function use_current_InterfaceDeclaration_IRefreshSummaryAckOptions(
    use: TypeOnly<current.IRefreshSummaryAckOptions>);
use_current_InterfaceDeclaration_IRefreshSummaryAckOptions(
    get_old_InterfaceDeclaration_IRefreshSummaryAckOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRefreshSummaryAckOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRefreshSummaryAckOptions():
    TypeOnly<current.IRefreshSummaryAckOptions>;
declare function use_old_InterfaceDeclaration_IRefreshSummaryAckOptions(
    use: TypeOnly<old.IRefreshSummaryAckOptions>);
use_old_InterfaceDeclaration_IRefreshSummaryAckOptions(
    get_current_InterfaceDeclaration_IRefreshSummaryAckOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRetriableFailureResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRetriableFailureResult():
    TypeOnly<old.IRetriableFailureResult>;
declare function use_current_InterfaceDeclaration_IRetriableFailureResult(
    use: TypeOnly<current.IRetriableFailureResult>);
use_current_InterfaceDeclaration_IRetriableFailureResult(
    get_old_InterfaceDeclaration_IRetriableFailureResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRetriableFailureResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRetriableFailureResult():
    TypeOnly<current.IRetriableFailureResult>;
declare function use_old_InterfaceDeclaration_IRetriableFailureResult(
    use: TypeOnly<old.IRetriableFailureResult>);
use_old_InterfaceDeclaration_IRetriableFailureResult(
    get_current_InterfaceDeclaration_IRetriableFailureResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISubmitSummaryOpResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISubmitSummaryOpResult():
    TypeOnly<old.ISubmitSummaryOpResult>;
declare function use_current_InterfaceDeclaration_ISubmitSummaryOpResult(
    use: TypeOnly<current.ISubmitSummaryOpResult>);
use_current_InterfaceDeclaration_ISubmitSummaryOpResult(
    get_old_InterfaceDeclaration_ISubmitSummaryOpResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISubmitSummaryOpResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISubmitSummaryOpResult():
    TypeOnly<current.ISubmitSummaryOpResult>;
declare function use_old_InterfaceDeclaration_ISubmitSummaryOpResult(
    use: TypeOnly<old.ISubmitSummaryOpResult>);
use_old_InterfaceDeclaration_ISubmitSummaryOpResult(
    get_current_InterfaceDeclaration_ISubmitSummaryOpResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISubmitSummaryOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISubmitSummaryOptions():
    TypeOnly<old.ISubmitSummaryOptions>;
declare function use_current_InterfaceDeclaration_ISubmitSummaryOptions(
    use: TypeOnly<current.ISubmitSummaryOptions>);
use_current_InterfaceDeclaration_ISubmitSummaryOptions(
    get_old_InterfaceDeclaration_ISubmitSummaryOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISubmitSummaryOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISubmitSummaryOptions():
    TypeOnly<current.ISubmitSummaryOptions>;
declare function use_old_InterfaceDeclaration_ISubmitSummaryOptions(
    use: TypeOnly<old.ISubmitSummaryOptions>);
use_old_InterfaceDeclaration_ISubmitSummaryOptions(
    get_current_InterfaceDeclaration_ISubmitSummaryOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeEventProps": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizeEventProps():
    TypeOnly<old.ISummarizeEventProps>;
declare function use_current_InterfaceDeclaration_ISummarizeEventProps(
    use: TypeOnly<current.ISummarizeEventProps>);
use_current_InterfaceDeclaration_ISummarizeEventProps(
    get_old_InterfaceDeclaration_ISummarizeEventProps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeEventProps": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizeEventProps():
    TypeOnly<current.ISummarizeEventProps>;
declare function use_old_InterfaceDeclaration_ISummarizeEventProps(
    use: TypeOnly<old.ISummarizeEventProps>);
use_old_InterfaceDeclaration_ISummarizeEventProps(
    get_current_InterfaceDeclaration_ISummarizeEventProps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizeOptions():
    TypeOnly<old.ISummarizeOptions>;
declare function use_current_InterfaceDeclaration_ISummarizeOptions(
    use: TypeOnly<current.ISummarizeOptions>);
use_current_InterfaceDeclaration_ISummarizeOptions(
    get_old_InterfaceDeclaration_ISummarizeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizeOptions():
    TypeOnly<current.ISummarizeOptions>;
declare function use_old_InterfaceDeclaration_ISummarizeOptions(
    use: TypeOnly<old.ISummarizeOptions>);
use_old_InterfaceDeclaration_ISummarizeOptions(
    get_current_InterfaceDeclaration_ISummarizeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeResults": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizeResults():
    TypeOnly<old.ISummarizeResults>;
declare function use_current_InterfaceDeclaration_ISummarizeResults(
    use: TypeOnly<current.ISummarizeResults>);
use_current_InterfaceDeclaration_ISummarizeResults(
    get_old_InterfaceDeclaration_ISummarizeResults());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeResults": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizeResults():
    TypeOnly<current.ISummarizeResults>;
declare function use_old_InterfaceDeclaration_ISummarizeResults(
    use: TypeOnly<old.ISummarizeResults>);
use_old_InterfaceDeclaration_ISummarizeResults(
    get_current_InterfaceDeclaration_ISummarizeResults());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizer():
    TypeOnly<old.ISummarizer>;
declare function use_current_InterfaceDeclaration_ISummarizer(
    use: TypeOnly<current.ISummarizer>);
use_current_InterfaceDeclaration_ISummarizer(
    get_old_InterfaceDeclaration_ISummarizer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizer():
    TypeOnly<current.ISummarizer>;
declare function use_old_InterfaceDeclaration_ISummarizer(
    use: TypeOnly<old.ISummarizer>);
use_old_InterfaceDeclaration_ISummarizer(
    get_current_InterfaceDeclaration_ISummarizer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerEvents():
    TypeOnly<old.ISummarizerEvents>;
declare function use_current_InterfaceDeclaration_ISummarizerEvents(
    use: TypeOnly<current.ISummarizerEvents>);
use_current_InterfaceDeclaration_ISummarizerEvents(
    get_old_InterfaceDeclaration_ISummarizerEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerEvents():
    TypeOnly<current.ISummarizerEvents>;
declare function use_old_InterfaceDeclaration_ISummarizerEvents(
    use: TypeOnly<old.ISummarizerEvents>);
use_old_InterfaceDeclaration_ISummarizerEvents(
    get_current_InterfaceDeclaration_ISummarizerEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerInternalsProvider": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerInternalsProvider():
    TypeOnly<old.ISummarizerInternalsProvider>;
declare function use_current_InterfaceDeclaration_ISummarizerInternalsProvider(
    use: TypeOnly<current.ISummarizerInternalsProvider>);
use_current_InterfaceDeclaration_ISummarizerInternalsProvider(
    get_old_InterfaceDeclaration_ISummarizerInternalsProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerInternalsProvider": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerInternalsProvider():
    TypeOnly<current.ISummarizerInternalsProvider>;
declare function use_old_InterfaceDeclaration_ISummarizerInternalsProvider(
    use: TypeOnly<old.ISummarizerInternalsProvider>);
use_old_InterfaceDeclaration_ISummarizerInternalsProvider(
    get_current_InterfaceDeclaration_ISummarizerInternalsProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerRuntime": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerRuntime():
    TypeOnly<old.ISummarizerRuntime>;
declare function use_current_InterfaceDeclaration_ISummarizerRuntime(
    use: TypeOnly<current.ISummarizerRuntime>);
use_current_InterfaceDeclaration_ISummarizerRuntime(
    get_old_InterfaceDeclaration_ISummarizerRuntime());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerRuntime": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerRuntime():
    TypeOnly<current.ISummarizerRuntime>;
declare function use_old_InterfaceDeclaration_ISummarizerRuntime(
    use: TypeOnly<old.ISummarizerRuntime>);
use_old_InterfaceDeclaration_ISummarizerRuntime(
    get_current_InterfaceDeclaration_ISummarizerRuntime());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizingWarning": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizingWarning():
    TypeOnly<old.ISummarizingWarning>;
declare function use_current_InterfaceDeclaration_ISummarizingWarning(
    use: TypeOnly<current.ISummarizingWarning>);
use_current_InterfaceDeclaration_ISummarizingWarning(
    get_old_InterfaceDeclaration_ISummarizingWarning());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizingWarning": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizingWarning():
    TypeOnly<current.ISummarizingWarning>;
declare function use_old_InterfaceDeclaration_ISummarizingWarning(
    use: TypeOnly<old.ISummarizingWarning>);
use_old_InterfaceDeclaration_ISummarizingWarning(
    get_current_InterfaceDeclaration_ISummarizingWarning());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummary": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummary():
    TypeOnly<old.ISummary>;
declare function use_current_InterfaceDeclaration_ISummary(
    use: TypeOnly<current.ISummary>);
use_current_InterfaceDeclaration_ISummary(
    get_old_InterfaceDeclaration_ISummary());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummary": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummary():
    TypeOnly<current.ISummary>;
declare function use_old_InterfaceDeclaration_ISummary(
    use: TypeOnly<old.ISummary>);
use_old_InterfaceDeclaration_ISummary(
    get_current_InterfaceDeclaration_ISummary());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryAckMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryAckMessage():
    TypeOnly<old.ISummaryAckMessage>;
declare function use_current_InterfaceDeclaration_ISummaryAckMessage(
    use: TypeOnly<current.ISummaryAckMessage>);
use_current_InterfaceDeclaration_ISummaryAckMessage(
    get_old_InterfaceDeclaration_ISummaryAckMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryAckMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryAckMessage():
    TypeOnly<current.ISummaryAckMessage>;
declare function use_old_InterfaceDeclaration_ISummaryAckMessage(
    use: TypeOnly<old.ISummaryAckMessage>);
use_old_InterfaceDeclaration_ISummaryAckMessage(
    get_current_InterfaceDeclaration_ISummaryAckMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryBaseConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryBaseConfiguration():
    TypeOnly<old.ISummaryBaseConfiguration>;
declare function use_current_InterfaceDeclaration_ISummaryBaseConfiguration(
    use: TypeOnly<current.ISummaryBaseConfiguration>);
use_current_InterfaceDeclaration_ISummaryBaseConfiguration(
    get_old_InterfaceDeclaration_ISummaryBaseConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryBaseConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryBaseConfiguration():
    TypeOnly<current.ISummaryBaseConfiguration>;
declare function use_old_InterfaceDeclaration_ISummaryBaseConfiguration(
    use: TypeOnly<old.ISummaryBaseConfiguration>);
use_old_InterfaceDeclaration_ISummaryBaseConfiguration(
    get_current_InterfaceDeclaration_ISummaryBaseConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISummaryCancellationToken": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ISummaryCancellationToken():
    TypeOnly<old.ISummaryCancellationToken>;
declare function use_current_TypeAliasDeclaration_ISummaryCancellationToken(
    use: TypeOnly<current.ISummaryCancellationToken>);
use_current_TypeAliasDeclaration_ISummaryCancellationToken(
    get_old_TypeAliasDeclaration_ISummaryCancellationToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISummaryCancellationToken": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ISummaryCancellationToken():
    TypeOnly<current.ISummaryCancellationToken>;
declare function use_old_TypeAliasDeclaration_ISummaryCancellationToken(
    use: TypeOnly<old.ISummaryCancellationToken>);
use_old_TypeAliasDeclaration_ISummaryCancellationToken(
    get_current_TypeAliasDeclaration_ISummaryCancellationToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryCollectionOpEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryCollectionOpEvents():
    TypeOnly<old.ISummaryCollectionOpEvents>;
declare function use_current_InterfaceDeclaration_ISummaryCollectionOpEvents(
    use: TypeOnly<current.ISummaryCollectionOpEvents>);
use_current_InterfaceDeclaration_ISummaryCollectionOpEvents(
    get_old_InterfaceDeclaration_ISummaryCollectionOpEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryCollectionOpEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryCollectionOpEvents():
    TypeOnly<current.ISummaryCollectionOpEvents>;
declare function use_old_InterfaceDeclaration_ISummaryCollectionOpEvents(
    use: TypeOnly<old.ISummaryCollectionOpEvents>);
use_old_InterfaceDeclaration_ISummaryCollectionOpEvents(
    get_current_InterfaceDeclaration_ISummaryCollectionOpEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISummaryConfiguration": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ISummaryConfiguration():
    TypeOnly<old.ISummaryConfiguration>;
declare function use_current_TypeAliasDeclaration_ISummaryConfiguration(
    use: TypeOnly<current.ISummaryConfiguration>);
use_current_TypeAliasDeclaration_ISummaryConfiguration(
    get_old_TypeAliasDeclaration_ISummaryConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISummaryConfiguration": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ISummaryConfiguration():
    TypeOnly<current.ISummaryConfiguration>;
declare function use_old_TypeAliasDeclaration_ISummaryConfiguration(
    use: TypeOnly<old.ISummaryConfiguration>);
use_old_TypeAliasDeclaration_ISummaryConfiguration(
    get_current_TypeAliasDeclaration_ISummaryConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationDisableHeuristics": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics():
    TypeOnly<old.ISummaryConfigurationDisableHeuristics>;
declare function use_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    use: TypeOnly<current.ISummaryConfigurationDisableHeuristics>);
use_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    get_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationDisableHeuristics": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics():
    TypeOnly<current.ISummaryConfigurationDisableHeuristics>;
declare function use_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    use: TypeOnly<old.ISummaryConfigurationDisableHeuristics>);
use_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    get_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationDisableSummarizer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer():
    TypeOnly<old.ISummaryConfigurationDisableSummarizer>;
declare function use_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    use: TypeOnly<current.ISummaryConfigurationDisableSummarizer>);
use_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    get_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationDisableSummarizer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer():
    TypeOnly<current.ISummaryConfigurationDisableSummarizer>;
declare function use_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    use: TypeOnly<old.ISummaryConfigurationDisableSummarizer>);
use_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    get_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationHeuristics": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryConfigurationHeuristics():
    TypeOnly<old.ISummaryConfigurationHeuristics>;
declare function use_current_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    use: TypeOnly<current.ISummaryConfigurationHeuristics>);
use_current_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    get_old_InterfaceDeclaration_ISummaryConfigurationHeuristics());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationHeuristics": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryConfigurationHeuristics():
    TypeOnly<current.ISummaryConfigurationHeuristics>;
declare function use_old_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    use: TypeOnly<old.ISummaryConfigurationHeuristics>);
use_old_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    get_current_InterfaceDeclaration_ISummaryConfigurationHeuristics());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryNackMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryNackMessage():
    TypeOnly<old.ISummaryNackMessage>;
declare function use_current_InterfaceDeclaration_ISummaryNackMessage(
    use: TypeOnly<current.ISummaryNackMessage>);
use_current_InterfaceDeclaration_ISummaryNackMessage(
    get_old_InterfaceDeclaration_ISummaryNackMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryNackMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryNackMessage():
    TypeOnly<current.ISummaryNackMessage>;
declare function use_old_InterfaceDeclaration_ISummaryNackMessage(
    use: TypeOnly<old.ISummaryNackMessage>);
use_old_InterfaceDeclaration_ISummaryNackMessage(
    get_current_InterfaceDeclaration_ISummaryNackMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryOpMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryOpMessage():
    TypeOnly<old.ISummaryOpMessage>;
declare function use_current_InterfaceDeclaration_ISummaryOpMessage(
    use: TypeOnly<current.ISummaryOpMessage>);
use_current_InterfaceDeclaration_ISummaryOpMessage(
    get_old_InterfaceDeclaration_ISummaryOpMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryOpMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryOpMessage():
    TypeOnly<current.ISummaryOpMessage>;
declare function use_old_InterfaceDeclaration_ISummaryOpMessage(
    use: TypeOnly<old.ISummaryOpMessage>);
use_old_InterfaceDeclaration_ISummaryOpMessage(
    get_current_InterfaceDeclaration_ISummaryOpMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryRuntimeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryRuntimeOptions():
    TypeOnly<old.ISummaryRuntimeOptions>;
declare function use_current_InterfaceDeclaration_ISummaryRuntimeOptions(
    use: TypeOnly<current.ISummaryRuntimeOptions>);
use_current_InterfaceDeclaration_ISummaryRuntimeOptions(
    get_old_InterfaceDeclaration_ISummaryRuntimeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryRuntimeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryRuntimeOptions():
    TypeOnly<current.ISummaryRuntimeOptions>;
declare function use_old_InterfaceDeclaration_ISummaryRuntimeOptions(
    use: TypeOnly<old.ISummaryRuntimeOptions>);
use_old_InterfaceDeclaration_ISummaryRuntimeOptions(
    get_current_InterfaceDeclaration_ISummaryRuntimeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUploadSummaryResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IUploadSummaryResult():
    TypeOnly<old.IUploadSummaryResult>;
declare function use_current_InterfaceDeclaration_IUploadSummaryResult(
    use: TypeOnly<current.IUploadSummaryResult>);
use_current_InterfaceDeclaration_IUploadSummaryResult(
    get_old_InterfaceDeclaration_IUploadSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUploadSummaryResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IUploadSummaryResult():
    TypeOnly<current.IUploadSummaryResult>;
declare function use_old_InterfaceDeclaration_IUploadSummaryResult(
    use: TypeOnly<old.IUploadSummaryResult>);
use_old_InterfaceDeclaration_IUploadSummaryResult(
    get_current_InterfaceDeclaration_IUploadSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_InactiveResponseHeaderKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_InactiveResponseHeaderKey():
    TypeOnly<typeof old.InactiveResponseHeaderKey>;
declare function use_current_VariableDeclaration_InactiveResponseHeaderKey(
    use: TypeOnly<typeof current.InactiveResponseHeaderKey>);
use_current_VariableDeclaration_InactiveResponseHeaderKey(
    get_old_VariableDeclaration_InactiveResponseHeaderKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_InactiveResponseHeaderKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_InactiveResponseHeaderKey():
    TypeOnly<typeof current.InactiveResponseHeaderKey>;
declare function use_old_VariableDeclaration_InactiveResponseHeaderKey(
    use: TypeOnly<typeof old.InactiveResponseHeaderKey>);
use_old_VariableDeclaration_InactiveResponseHeaderKey(
    get_current_VariableDeclaration_InactiveResponseHeaderKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OpActionEventListener": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_OpActionEventListener():
    TypeOnly<old.OpActionEventListener>;
declare function use_current_TypeAliasDeclaration_OpActionEventListener(
    use: TypeOnly<current.OpActionEventListener>);
use_current_TypeAliasDeclaration_OpActionEventListener(
    get_old_TypeAliasDeclaration_OpActionEventListener());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OpActionEventListener": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_OpActionEventListener():
    TypeOnly<current.OpActionEventListener>;
declare function use_old_TypeAliasDeclaration_OpActionEventListener(
    use: TypeOnly<old.OpActionEventListener>);
use_old_TypeAliasDeclaration_OpActionEventListener(
    get_current_TypeAliasDeclaration_OpActionEventListener());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OpActionEventName": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_OpActionEventName():
    TypeOnly<old.OpActionEventName>;
declare function use_current_TypeAliasDeclaration_OpActionEventName(
    use: TypeOnly<current.OpActionEventName>);
use_current_TypeAliasDeclaration_OpActionEventName(
    get_old_TypeAliasDeclaration_OpActionEventName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OpActionEventName": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_OpActionEventName():
    TypeOnly<current.OpActionEventName>;
declare function use_old_TypeAliasDeclaration_OpActionEventName(
    use: TypeOnly<old.OpActionEventName>);
use_old_TypeAliasDeclaration_OpActionEventName(
    get_current_TypeAliasDeclaration_OpActionEventName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails():
    TypeOnly<old.RecentlyAddedContainerRuntimeMessageDetails>;
declare function use_current_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails(
    use: TypeOnly<current.RecentlyAddedContainerRuntimeMessageDetails>);
use_current_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails(
    get_old_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails():
    TypeOnly<current.RecentlyAddedContainerRuntimeMessageDetails>;
declare function use_old_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails(
    use: TypeOnly<old.RecentlyAddedContainerRuntimeMessageDetails>);
use_old_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails(
    get_current_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RuntimeHeaders": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_RuntimeHeaders():
    TypeOnly<old.RuntimeHeaders>;
declare function use_current_EnumDeclaration_RuntimeHeaders(
    use: TypeOnly<current.RuntimeHeaders>);
use_current_EnumDeclaration_RuntimeHeaders(
    get_old_EnumDeclaration_RuntimeHeaders());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RuntimeHeaders": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_RuntimeHeaders():
    TypeOnly<current.RuntimeHeaders>;
declare function use_old_EnumDeclaration_RuntimeHeaders(
    use: TypeOnly<old.RuntimeHeaders>);
use_old_EnumDeclaration_RuntimeHeaders(
    get_current_EnumDeclaration_RuntimeHeaders());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RuntimeMessage": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_RuntimeMessage():
    TypeOnly<old.RuntimeMessage>;
declare function use_current_EnumDeclaration_RuntimeMessage(
    use: TypeOnly<current.RuntimeMessage>);
use_current_EnumDeclaration_RuntimeMessage(
    get_old_EnumDeclaration_RuntimeMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RuntimeMessage": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_RuntimeMessage():
    TypeOnly<current.RuntimeMessage>;
declare function use_old_EnumDeclaration_RuntimeMessage(
    use: TypeOnly<old.RuntimeMessage>);
use_old_EnumDeclaration_RuntimeMessage(
    get_current_EnumDeclaration_RuntimeMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SubmitSummaryFailureData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_SubmitSummaryFailureData():
    TypeOnly<old.SubmitSummaryFailureData>;
declare function use_current_InterfaceDeclaration_SubmitSummaryFailureData(
    use: TypeOnly<current.SubmitSummaryFailureData>);
use_current_InterfaceDeclaration_SubmitSummaryFailureData(
    get_old_InterfaceDeclaration_SubmitSummaryFailureData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SubmitSummaryFailureData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_SubmitSummaryFailureData():
    TypeOnly<current.SubmitSummaryFailureData>;
declare function use_old_InterfaceDeclaration_SubmitSummaryFailureData(
    use: TypeOnly<old.SubmitSummaryFailureData>);
use_old_InterfaceDeclaration_SubmitSummaryFailureData(
    get_current_InterfaceDeclaration_SubmitSummaryFailureData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SubmitSummaryResult": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SubmitSummaryResult():
    TypeOnly<old.SubmitSummaryResult>;
declare function use_current_TypeAliasDeclaration_SubmitSummaryResult(
    use: TypeOnly<current.SubmitSummaryResult>);
use_current_TypeAliasDeclaration_SubmitSummaryResult(
    get_old_TypeAliasDeclaration_SubmitSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SubmitSummaryResult": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SubmitSummaryResult():
    TypeOnly<current.SubmitSummaryResult>;
declare function use_old_TypeAliasDeclaration_SubmitSummaryResult(
    use: TypeOnly<old.SubmitSummaryResult>);
use_old_TypeAliasDeclaration_SubmitSummaryResult(
    get_current_TypeAliasDeclaration_SubmitSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizeResultPart": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummarizeResultPart():
    TypeOnly<old.SummarizeResultPart<any,any>>;
declare function use_current_TypeAliasDeclaration_SummarizeResultPart(
    use: TypeOnly<current.SummarizeResultPart<any,any>>);
use_current_TypeAliasDeclaration_SummarizeResultPart(
    get_old_TypeAliasDeclaration_SummarizeResultPart());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizeResultPart": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummarizeResultPart():
    TypeOnly<current.SummarizeResultPart<any,any>>;
declare function use_old_TypeAliasDeclaration_SummarizeResultPart(
    use: TypeOnly<old.SummarizeResultPart<any,any>>);
use_old_TypeAliasDeclaration_SummarizeResultPart(
    get_current_TypeAliasDeclaration_SummarizeResultPart());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Summarizer": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Summarizer():
    TypeOnly<old.Summarizer>;
declare function use_current_ClassDeclaration_Summarizer(
    use: TypeOnly<current.Summarizer>);
use_current_ClassDeclaration_Summarizer(
    get_old_ClassDeclaration_Summarizer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Summarizer": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Summarizer():
    TypeOnly<current.Summarizer>;
declare function use_old_ClassDeclaration_Summarizer(
    use: TypeOnly<old.Summarizer>);
use_old_ClassDeclaration_Summarizer(
    get_current_ClassDeclaration_Summarizer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizerStopReason": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummarizerStopReason():
    TypeOnly<old.SummarizerStopReason>;
declare function use_current_TypeAliasDeclaration_SummarizerStopReason(
    use: TypeOnly<current.SummarizerStopReason>);
use_current_TypeAliasDeclaration_SummarizerStopReason(
    get_old_TypeAliasDeclaration_SummarizerStopReason());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizerStopReason": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummarizerStopReason():
    TypeOnly<current.SummarizerStopReason>;
declare function use_old_TypeAliasDeclaration_SummarizerStopReason(
    use: TypeOnly<old.SummarizerStopReason>);
use_old_TypeAliasDeclaration_SummarizerStopReason(
    get_current_TypeAliasDeclaration_SummarizerStopReason());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryCollection": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SummaryCollection():
    TypeOnly<old.SummaryCollection>;
declare function use_current_ClassDeclaration_SummaryCollection(
    use: TypeOnly<current.SummaryCollection>);
use_current_ClassDeclaration_SummaryCollection(
    get_old_ClassDeclaration_SummaryCollection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryCollection": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SummaryCollection():
    TypeOnly<current.SummaryCollection>;
declare function use_old_ClassDeclaration_SummaryCollection(
    use: TypeOnly<old.SummaryCollection>);
use_old_ClassDeclaration_SummaryCollection(
    get_current_ClassDeclaration_SummaryCollection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryStage": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummaryStage():
    TypeOnly<old.SummaryStage>;
declare function use_current_TypeAliasDeclaration_SummaryStage(
    use: TypeOnly<current.SummaryStage>);
use_current_TypeAliasDeclaration_SummaryStage(
    get_old_TypeAliasDeclaration_SummaryStage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryStage": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummaryStage():
    TypeOnly<current.SummaryStage>;
declare function use_old_TypeAliasDeclaration_SummaryStage(
    use: TypeOnly<old.SummaryStage>);
use_old_TypeAliasDeclaration_SummaryStage(
    get_current_TypeAliasDeclaration_SummaryStage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TombstoneResponseHeaderKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_TombstoneResponseHeaderKey():
    TypeOnly<typeof old.TombstoneResponseHeaderKey>;
declare function use_current_VariableDeclaration_TombstoneResponseHeaderKey(
    use: TypeOnly<typeof current.TombstoneResponseHeaderKey>);
use_current_VariableDeclaration_TombstoneResponseHeaderKey(
    get_old_VariableDeclaration_TombstoneResponseHeaderKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TombstoneResponseHeaderKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_TombstoneResponseHeaderKey():
    TypeOnly<typeof current.TombstoneResponseHeaderKey>;
declare function use_old_VariableDeclaration_TombstoneResponseHeaderKey(
    use: TypeOnly<typeof old.TombstoneResponseHeaderKey>);
use_old_VariableDeclaration_TombstoneResponseHeaderKey(
    get_current_VariableDeclaration_TombstoneResponseHeaderKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_agentSchedulerId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_agentSchedulerId():
    TypeOnly<typeof old.agentSchedulerId>;
declare function use_current_VariableDeclaration_agentSchedulerId(
    use: TypeOnly<typeof current.agentSchedulerId>);
use_current_VariableDeclaration_agentSchedulerId(
    get_old_VariableDeclaration_agentSchedulerId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_agentSchedulerId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_agentSchedulerId():
    TypeOnly<typeof current.agentSchedulerId>;
declare function use_old_VariableDeclaration_agentSchedulerId(
    use: TypeOnly<typeof old.agentSchedulerId>);
use_old_VariableDeclaration_agentSchedulerId(
    get_current_VariableDeclaration_agentSchedulerId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_assertIsStableId": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_assertIsStableId():
    TypeOnly<typeof old.assertIsStableId>;
declare function use_current_FunctionDeclaration_assertIsStableId(
    use: TypeOnly<typeof current.assertIsStableId>);
use_current_FunctionDeclaration_assertIsStableId(
    get_old_FunctionDeclaration_assertIsStableId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_assertIsStableId": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_assertIsStableId():
    TypeOnly<typeof current.assertIsStableId>;
declare function use_old_FunctionDeclaration_assertIsStableId(
    use: TypeOnly<typeof old.assertIsStableId>);
use_old_FunctionDeclaration_assertIsStableId(
    get_current_FunctionDeclaration_assertIsStableId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateStableId": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_generateStableId():
    TypeOnly<typeof old.generateStableId>;
declare function use_current_FunctionDeclaration_generateStableId(
    use: TypeOnly<typeof current.generateStableId>);
use_current_FunctionDeclaration_generateStableId(
    get_old_FunctionDeclaration_generateStableId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateStableId": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_generateStableId():
    TypeOnly<typeof current.generateStableId>;
declare function use_old_FunctionDeclaration_generateStableId(
    use: TypeOnly<typeof old.generateStableId>);
use_old_FunctionDeclaration_generateStableId(
    get_current_FunctionDeclaration_generateStableId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isRuntimeMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isRuntimeMessage():
    TypeOnly<typeof old.isRuntimeMessage>;
declare function use_current_FunctionDeclaration_isRuntimeMessage(
    use: TypeOnly<typeof current.isRuntimeMessage>);
use_current_FunctionDeclaration_isRuntimeMessage(
    get_old_FunctionDeclaration_isRuntimeMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isRuntimeMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isRuntimeMessage():
    TypeOnly<typeof current.isRuntimeMessage>;
declare function use_old_FunctionDeclaration_isRuntimeMessage(
    use: TypeOnly<typeof old.isRuntimeMessage>);
use_old_FunctionDeclaration_isRuntimeMessage(
    get_current_FunctionDeclaration_isRuntimeMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isStableId": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isStableId():
    TypeOnly<typeof old.isStableId>;
declare function use_current_FunctionDeclaration_isStableId(
    use: TypeOnly<typeof current.isStableId>);
use_current_FunctionDeclaration_isStableId(
    get_old_FunctionDeclaration_isStableId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isStableId": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isStableId():
    TypeOnly<typeof current.isStableId>;
declare function use_old_FunctionDeclaration_isStableId(
    use: TypeOnly<typeof old.isStableId>);
use_old_FunctionDeclaration_isStableId(
    get_current_FunctionDeclaration_isStableId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_neverCancelledSummaryToken": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_neverCancelledSummaryToken():
    TypeOnly<typeof old.neverCancelledSummaryToken>;
declare function use_current_VariableDeclaration_neverCancelledSummaryToken(
    use: TypeOnly<typeof current.neverCancelledSummaryToken>);
use_current_VariableDeclaration_neverCancelledSummaryToken(
    get_old_VariableDeclaration_neverCancelledSummaryToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_neverCancelledSummaryToken": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_neverCancelledSummaryToken():
    TypeOnly<typeof current.neverCancelledSummaryToken>;
declare function use_old_VariableDeclaration_neverCancelledSummaryToken(
    use: TypeOnly<typeof old.neverCancelledSummaryToken>);
use_old_VariableDeclaration_neverCancelledSummaryToken(
    get_current_VariableDeclaration_neverCancelledSummaryToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_unpackRuntimeMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_unpackRuntimeMessage():
    TypeOnly<typeof old.unpackRuntimeMessage>;
declare function use_current_FunctionDeclaration_unpackRuntimeMessage(
    use: TypeOnly<typeof current.unpackRuntimeMessage>);
use_current_FunctionDeclaration_unpackRuntimeMessage(
    get_old_FunctionDeclaration_unpackRuntimeMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_unpackRuntimeMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_unpackRuntimeMessage():
    TypeOnly<typeof current.unpackRuntimeMessage>;
declare function use_old_FunctionDeclaration_unpackRuntimeMessage(
    use: TypeOnly<typeof old.unpackRuntimeMessage>);
use_old_FunctionDeclaration_unpackRuntimeMessage(
    get_current_FunctionDeclaration_unpackRuntimeMessage());
