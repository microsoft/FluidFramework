/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/container-runtime-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ContainerRuntime": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ContainerRuntime = requireAssignableTo<TypeOnly<old.ContainerRuntime>, TypeOnly<current.ContainerRuntime>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ContainerRuntime": {"backCompat": false}
 */
declare type current_as_old_for_Class_ContainerRuntime = requireAssignableTo<TypeOnly<current.ContainerRuntime>, TypeOnly<old.ContainerRuntime>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DocumentsSchemaController": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DocumentsSchemaController = requireAssignableTo<TypeOnly<old.DocumentsSchemaController>, TypeOnly<current.DocumentsSchemaController>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DocumentsSchemaController": {"backCompat": false}
 */
declare type current_as_old_for_Class_DocumentsSchemaController = requireAssignableTo<TypeOnly<current.DocumentsSchemaController>, TypeOnly<old.DocumentsSchemaController>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Summarizer": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Summarizer = requireAssignableTo<TypeOnly<old.Summarizer>, TypeOnly<current.Summarizer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Summarizer": {"backCompat": false}
 */
declare type current_as_old_for_Class_Summarizer = requireAssignableTo<TypeOnly<current.Summarizer>, TypeOnly<old.Summarizer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SummaryCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SummaryCollection = requireAssignableTo<TypeOnly<old.SummaryCollection>, TypeOnly<current.SummaryCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SummaryCollection": {"backCompat": false}
 */
declare type current_as_old_for_Class_SummaryCollection = requireAssignableTo<TypeOnly<current.SummaryCollection>, TypeOnly<old.SummaryCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ContainerRuntime": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ContainerRuntime = requireAssignableTo<TypeOnly<typeof current.ContainerRuntime>, TypeOnly<typeof old.ContainerRuntime>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DocumentsSchemaController": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DocumentsSchemaController = requireAssignableTo<TypeOnly<typeof current.DocumentsSchemaController>, TypeOnly<typeof old.DocumentsSchemaController>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Summarizer": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Summarizer = requireAssignableTo<TypeOnly<typeof current.Summarizer>, TypeOnly<typeof old.Summarizer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SummaryCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SummaryCollection = requireAssignableTo<TypeOnly<typeof current.SummaryCollection>, TypeOnly<typeof old.SummaryCollection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_CompressionAlgorithms": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_CompressionAlgorithms = requireAssignableTo<TypeOnly<old.CompressionAlgorithms>, TypeOnly<current.CompressionAlgorithms>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_CompressionAlgorithms": {"backCompat": false}
 */
declare type current_as_old_for_Enum_CompressionAlgorithms = requireAssignableTo<TypeOnly<current.CompressionAlgorithms>, TypeOnly<old.CompressionAlgorithms>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ContainerMessageType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_ContainerMessageType = requireAssignableTo<TypeOnly<old.ContainerMessageType>, TypeOnly<current.ContainerMessageType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ContainerMessageType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_ContainerMessageType = requireAssignableTo<TypeOnly<current.ContainerMessageType>, TypeOnly<old.ContainerMessageType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_loadContainerRuntime": {"backCompat": false}
 */
declare type current_as_old_for_Function_loadContainerRuntime = requireAssignableTo<TypeOnly<typeof current.loadContainerRuntime>, TypeOnly<typeof old.loadContainerRuntime>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAckedSummary": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IAckedSummary = requireAssignableTo<TypeOnly<old.IAckedSummary>, TypeOnly<current.IAckedSummary>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAckedSummary": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IAckedSummary = requireAssignableTo<TypeOnly<current.IAckedSummary>, TypeOnly<old.IAckedSummary>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAckSummaryResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IAckSummaryResult = requireAssignableTo<TypeOnly<old.IAckSummaryResult>, TypeOnly<current.IAckSummaryResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAckSummaryResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IAckSummaryResult = requireAssignableTo<TypeOnly<current.IAckSummaryResult>, TypeOnly<old.IAckSummaryResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBaseSummarizeResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IBaseSummarizeResult = requireAssignableTo<TypeOnly<old.IBaseSummarizeResult>, TypeOnly<current.IBaseSummarizeResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBaseSummarizeResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IBaseSummarizeResult = requireAssignableTo<TypeOnly<current.IBaseSummarizeResult>, TypeOnly<old.IBaseSummarizeResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBlobManagerLoadInfo": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IBlobManagerLoadInfo = requireAssignableTo<TypeOnly<old.IBlobManagerLoadInfo>, TypeOnly<current.IBlobManagerLoadInfo>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBlobManagerLoadInfo": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IBlobManagerLoadInfo = requireAssignableTo<TypeOnly<current.IBlobManagerLoadInfo>, TypeOnly<old.IBlobManagerLoadInfo>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBroadcastSummaryResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IBroadcastSummaryResult = requireAssignableTo<TypeOnly<old.IBroadcastSummaryResult>, TypeOnly<current.IBroadcastSummaryResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBroadcastSummaryResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IBroadcastSummaryResult = requireAssignableTo<TypeOnly<current.IBroadcastSummaryResult>, TypeOnly<old.IBroadcastSummaryResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICancellableSummarizerController": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICancellableSummarizerController = requireAssignableTo<TypeOnly<old.ICancellableSummarizerController>, TypeOnly<current.ICancellableSummarizerController>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICancellableSummarizerController": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICancellableSummarizerController = requireAssignableTo<TypeOnly<current.ICancellableSummarizerController>, TypeOnly<old.ICancellableSummarizerController>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICancellationToken": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICancellationToken = requireAssignableTo<TypeOnly<old.ICancellationToken<any>>, TypeOnly<current.ICancellationToken<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICancellationToken": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICancellationToken = requireAssignableTo<TypeOnly<current.ICancellationToken<any>>, TypeOnly<old.ICancellationToken<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientSummaryWatcher": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IClientSummaryWatcher = requireAssignableTo<TypeOnly<old.IClientSummaryWatcher>, TypeOnly<current.IClientSummaryWatcher>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientSummaryWatcher": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IClientSummaryWatcher = requireAssignableTo<TypeOnly<current.IClientSummaryWatcher>, TypeOnly<old.IClientSummaryWatcher>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICompressionRuntimeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICompressionRuntimeOptions = requireAssignableTo<TypeOnly<old.ICompressionRuntimeOptions>, TypeOnly<current.ICompressionRuntimeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICompressionRuntimeOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICompressionRuntimeOptions = requireAssignableTo<TypeOnly<current.ICompressionRuntimeOptions>, TypeOnly<old.ICompressionRuntimeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnectableRuntime": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConnectableRuntime = requireAssignableTo<TypeOnly<old.IConnectableRuntime>, TypeOnly<current.IConnectableRuntime>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnectableRuntime": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConnectableRuntime = requireAssignableTo<TypeOnly<current.IConnectableRuntime>, TypeOnly<old.IConnectableRuntime>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContainerRuntimeMetadata": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IContainerRuntimeMetadata = requireAssignableTo<TypeOnly<old.IContainerRuntimeMetadata>, TypeOnly<current.IContainerRuntimeMetadata>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContainerRuntimeMetadata": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IContainerRuntimeMetadata = requireAssignableTo<TypeOnly<current.IContainerRuntimeMetadata>, TypeOnly<old.IContainerRuntimeMetadata>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContainerRuntimeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IContainerRuntimeOptions = requireAssignableTo<TypeOnly<old.IContainerRuntimeOptions>, TypeOnly<current.IContainerRuntimeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContainerRuntimeOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IContainerRuntimeOptions = requireAssignableTo<TypeOnly<current.IContainerRuntimeOptions>, TypeOnly<old.IContainerRuntimeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICreateContainerMetadata": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICreateContainerMetadata = requireAssignableTo<TypeOnly<old.ICreateContainerMetadata>, TypeOnly<current.ICreateContainerMetadata>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICreateContainerMetadata": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICreateContainerMetadata = requireAssignableTo<TypeOnly<current.ICreateContainerMetadata>, TypeOnly<old.ICreateContainerMetadata>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentSchema": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentSchema = requireAssignableTo<TypeOnly<old.IDocumentSchema>, TypeOnly<current.IDocumentSchema>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentSchema": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentSchema = requireAssignableTo<TypeOnly<current.IDocumentSchema>, TypeOnly<old.IDocumentSchema>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentSchemaFeatures": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentSchemaFeatures = requireAssignableTo<TypeOnly<old.IDocumentSchemaFeatures>, TypeOnly<current.IDocumentSchemaFeatures>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentSchemaFeatures": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentSchemaFeatures = requireAssignableTo<TypeOnly<current.IDocumentSchemaFeatures>, TypeOnly<old.IDocumentSchemaFeatures>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEnqueueSummarizeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IEnqueueSummarizeOptions = requireAssignableTo<TypeOnly<old.IEnqueueSummarizeOptions>, TypeOnly<current.IEnqueueSummarizeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEnqueueSummarizeOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IEnqueueSummarizeOptions = requireAssignableTo<TypeOnly<current.IEnqueueSummarizeOptions>, TypeOnly<old.IEnqueueSummarizeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreAttributes0": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDataStoreAttributes0 = requireAssignableTo<TypeOnly<old.IFluidDataStoreAttributes0>, TypeOnly<current.IFluidDataStoreAttributes0>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreAttributes0": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDataStoreAttributes0 = requireAssignableTo<TypeOnly<current.IFluidDataStoreAttributes0>, TypeOnly<old.IFluidDataStoreAttributes0>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreAttributes1": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDataStoreAttributes1 = requireAssignableTo<TypeOnly<old.IFluidDataStoreAttributes1>, TypeOnly<current.IFluidDataStoreAttributes1>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreAttributes1": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDataStoreAttributes1 = requireAssignableTo<TypeOnly<current.IFluidDataStoreAttributes1>, TypeOnly<old.IFluidDataStoreAttributes1>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreAttributes2": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDataStoreAttributes2 = requireAssignableTo<TypeOnly<old.IFluidDataStoreAttributes2>, TypeOnly<current.IFluidDataStoreAttributes2>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreAttributes2": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDataStoreAttributes2 = requireAssignableTo<TypeOnly<current.IFluidDataStoreAttributes2>, TypeOnly<old.IFluidDataStoreAttributes2>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGCMetadata": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGCMetadata = requireAssignableTo<TypeOnly<old.IGCMetadata>, TypeOnly<current.IGCMetadata>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGCMetadata": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGCMetadata = requireAssignableTo<TypeOnly<current.IGCMetadata>, TypeOnly<old.IGCMetadata>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGCRuntimeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGCRuntimeOptions = requireAssignableTo<TypeOnly<old.IGCRuntimeOptions>, TypeOnly<current.IGCRuntimeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGCRuntimeOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGCRuntimeOptions = requireAssignableTo<TypeOnly<current.IGCRuntimeOptions>, TypeOnly<old.IGCRuntimeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGCStats": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGCStats = requireAssignableTo<TypeOnly<old.IGCStats>, TypeOnly<current.IGCStats>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGCStats": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGCStats = requireAssignableTo<TypeOnly<current.IGCStats>, TypeOnly<old.IGCStats>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGeneratedSummaryStats": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGeneratedSummaryStats = requireAssignableTo<TypeOnly<old.IGeneratedSummaryStats>, TypeOnly<current.IGeneratedSummaryStats>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGeneratedSummaryStats": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGeneratedSummaryStats = requireAssignableTo<TypeOnly<current.IGeneratedSummaryStats>, TypeOnly<old.IGeneratedSummaryStats>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGenerateSummaryTreeResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGenerateSummaryTreeResult = requireAssignableTo<TypeOnly<old.IGenerateSummaryTreeResult>, TypeOnly<current.IGenerateSummaryTreeResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGenerateSummaryTreeResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGenerateSummaryTreeResult = requireAssignableTo<TypeOnly<current.IGenerateSummaryTreeResult>, TypeOnly<old.IGenerateSummaryTreeResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMarkPhaseStats": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMarkPhaseStats = requireAssignableTo<TypeOnly<old.IMarkPhaseStats>, TypeOnly<current.IMarkPhaseStats>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMarkPhaseStats": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMarkPhaseStats = requireAssignableTo<TypeOnly<current.IMarkPhaseStats>, TypeOnly<old.IMarkPhaseStats>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INackSummaryResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_INackSummaryResult = requireAssignableTo<TypeOnly<old.INackSummaryResult>, TypeOnly<current.INackSummaryResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INackSummaryResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_INackSummaryResult = requireAssignableTo<TypeOnly<current.INackSummaryResult>, TypeOnly<old.INackSummaryResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IOnDemandSummarizeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IOnDemandSummarizeOptions = requireAssignableTo<TypeOnly<old.IOnDemandSummarizeOptions>, TypeOnly<current.IOnDemandSummarizeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IOnDemandSummarizeOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IOnDemandSummarizeOptions = requireAssignableTo<TypeOnly<current.IOnDemandSummarizeOptions>, TypeOnly<old.IOnDemandSummarizeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRefreshSummaryAckOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRefreshSummaryAckOptions = requireAssignableTo<TypeOnly<old.IRefreshSummaryAckOptions>, TypeOnly<current.IRefreshSummaryAckOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRefreshSummaryAckOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRefreshSummaryAckOptions = requireAssignableTo<TypeOnly<current.IRefreshSummaryAckOptions>, TypeOnly<old.IRefreshSummaryAckOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRetriableFailureError": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRetriableFailureError = requireAssignableTo<TypeOnly<old.IRetriableFailureError>, TypeOnly<current.IRetriableFailureError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRetriableFailureError": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRetriableFailureError = requireAssignableTo<TypeOnly<current.IRetriableFailureError>, TypeOnly<old.IRetriableFailureError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializedElection": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISerializedElection = requireAssignableTo<TypeOnly<old.ISerializedElection>, TypeOnly<current.ISerializedElection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializedElection": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISerializedElection = requireAssignableTo<TypeOnly<current.ISerializedElection>, TypeOnly<old.ISerializedElection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISubmitSummaryOpResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISubmitSummaryOpResult = requireAssignableTo<TypeOnly<old.ISubmitSummaryOpResult>, TypeOnly<current.ISubmitSummaryOpResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISubmitSummaryOpResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISubmitSummaryOpResult = requireAssignableTo<TypeOnly<current.ISubmitSummaryOpResult>, TypeOnly<old.ISubmitSummaryOpResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISubmitSummaryOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISubmitSummaryOptions = requireAssignableTo<TypeOnly<old.ISubmitSummaryOptions>, TypeOnly<current.ISubmitSummaryOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISubmitSummaryOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISubmitSummaryOptions = requireAssignableTo<TypeOnly<current.ISubmitSummaryOptions>, TypeOnly<old.ISubmitSummaryOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeEventProps": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizeEventProps = requireAssignableTo<TypeOnly<old.ISummarizeEventProps>, TypeOnly<current.ISummarizeEventProps>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeEventProps": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizeEventProps = requireAssignableTo<TypeOnly<current.ISummarizeEventProps>, TypeOnly<old.ISummarizeEventProps>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizeOptions = requireAssignableTo<TypeOnly<old.ISummarizeOptions>, TypeOnly<current.ISummarizeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizeOptions = requireAssignableTo<TypeOnly<current.ISummarizeOptions>, TypeOnly<old.ISummarizeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizer = requireAssignableTo<TypeOnly<old.ISummarizer>, TypeOnly<current.ISummarizer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizer = requireAssignableTo<TypeOnly<current.ISummarizer>, TypeOnly<old.ISummarizer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeResults": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizeResults = requireAssignableTo<TypeOnly<old.ISummarizeResults>, TypeOnly<current.ISummarizeResults>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeResults": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizeResults = requireAssignableTo<TypeOnly<current.ISummarizeResults>, TypeOnly<old.ISummarizeResults>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizerEvents = requireAssignableTo<TypeOnly<old.ISummarizerEvents>, TypeOnly<current.ISummarizerEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizerEvents = requireAssignableTo<TypeOnly<current.ISummarizerEvents>, TypeOnly<old.ISummarizerEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerInternalsProvider": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizerInternalsProvider = requireAssignableTo<TypeOnly<old.ISummarizerInternalsProvider>, TypeOnly<current.ISummarizerInternalsProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerInternalsProvider": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizerInternalsProvider = requireAssignableTo<TypeOnly<current.ISummarizerInternalsProvider>, TypeOnly<old.ISummarizerInternalsProvider>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerRuntime": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizerRuntime = requireAssignableTo<TypeOnly<old.ISummarizerRuntime>, TypeOnly<current.ISummarizerRuntime>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerRuntime": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizerRuntime = requireAssignableTo<TypeOnly<current.ISummarizerRuntime>, TypeOnly<old.ISummarizerRuntime>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummary": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummary = requireAssignableTo<TypeOnly<old.ISummary>, TypeOnly<current.ISummary>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummary": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummary = requireAssignableTo<TypeOnly<current.ISummary>, TypeOnly<old.ISummary>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryAckMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryAckMessage = requireAssignableTo<TypeOnly<old.ISummaryAckMessage>, TypeOnly<current.ISummaryAckMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryAckMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryAckMessage = requireAssignableTo<TypeOnly<current.ISummaryAckMessage>, TypeOnly<old.ISummaryAckMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryBaseConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryBaseConfiguration = requireAssignableTo<TypeOnly<old.ISummaryBaseConfiguration>, TypeOnly<current.ISummaryBaseConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryBaseConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryBaseConfiguration = requireAssignableTo<TypeOnly<current.ISummaryBaseConfiguration>, TypeOnly<old.ISummaryBaseConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryCollectionOpEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryCollectionOpEvents = requireAssignableTo<TypeOnly<old.ISummaryCollectionOpEvents>, TypeOnly<current.ISummaryCollectionOpEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryCollectionOpEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryCollectionOpEvents = requireAssignableTo<TypeOnly<current.ISummaryCollectionOpEvents>, TypeOnly<old.ISummaryCollectionOpEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryConfigurationDisableHeuristics": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryConfigurationDisableHeuristics = requireAssignableTo<TypeOnly<old.ISummaryConfigurationDisableHeuristics>, TypeOnly<current.ISummaryConfigurationDisableHeuristics>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryConfigurationDisableHeuristics": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryConfigurationDisableHeuristics = requireAssignableTo<TypeOnly<current.ISummaryConfigurationDisableHeuristics>, TypeOnly<old.ISummaryConfigurationDisableHeuristics>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryConfigurationDisableSummarizer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryConfigurationDisableSummarizer = requireAssignableTo<TypeOnly<old.ISummaryConfigurationDisableSummarizer>, TypeOnly<current.ISummaryConfigurationDisableSummarizer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryConfigurationDisableSummarizer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryConfigurationDisableSummarizer = requireAssignableTo<TypeOnly<current.ISummaryConfigurationDisableSummarizer>, TypeOnly<old.ISummaryConfigurationDisableSummarizer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryConfigurationHeuristics": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryConfigurationHeuristics = requireAssignableTo<TypeOnly<old.ISummaryConfigurationHeuristics>, TypeOnly<current.ISummaryConfigurationHeuristics>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryConfigurationHeuristics": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryConfigurationHeuristics = requireAssignableTo<TypeOnly<current.ISummaryConfigurationHeuristics>, TypeOnly<old.ISummaryConfigurationHeuristics>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryNackMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryNackMessage = requireAssignableTo<TypeOnly<old.ISummaryNackMessage>, TypeOnly<current.ISummaryNackMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryNackMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryNackMessage = requireAssignableTo<TypeOnly<current.ISummaryNackMessage>, TypeOnly<old.ISummaryNackMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryOpMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryOpMessage = requireAssignableTo<TypeOnly<old.ISummaryOpMessage>, TypeOnly<current.ISummaryOpMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryOpMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryOpMessage = requireAssignableTo<TypeOnly<current.ISummaryOpMessage>, TypeOnly<old.ISummaryOpMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryRuntimeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryRuntimeOptions = requireAssignableTo<TypeOnly<old.ISummaryRuntimeOptions>, TypeOnly<current.ISummaryRuntimeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryRuntimeOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryRuntimeOptions = requireAssignableTo<TypeOnly<current.ISummaryRuntimeOptions>, TypeOnly<old.ISummaryRuntimeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISweepPhaseStats": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISweepPhaseStats = requireAssignableTo<TypeOnly<old.ISweepPhaseStats>, TypeOnly<current.ISweepPhaseStats>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISweepPhaseStats": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISweepPhaseStats = requireAssignableTo<TypeOnly<current.ISweepPhaseStats>, TypeOnly<old.ISweepPhaseStats>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUploadSummaryResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IUploadSummaryResult = requireAssignableTo<TypeOnly<old.IUploadSummaryResult>, TypeOnly<current.IUploadSummaryResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUploadSummaryResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IUploadSummaryResult = requireAssignableTo<TypeOnly<current.IUploadSummaryResult>, TypeOnly<old.IUploadSummaryResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_LoadContainerRuntimeParams": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_LoadContainerRuntimeParams = requireAssignableTo<TypeOnly<old.LoadContainerRuntimeParams>, TypeOnly<current.LoadContainerRuntimeParams>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_LoadContainerRuntimeParams": {"backCompat": false}
 */
declare type current_as_old_for_Interface_LoadContainerRuntimeParams = requireAssignableTo<TypeOnly<current.LoadContainerRuntimeParams>, TypeOnly<old.LoadContainerRuntimeParams>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SubmitSummaryFailureData": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_SubmitSummaryFailureData = requireAssignableTo<TypeOnly<old.SubmitSummaryFailureData>, TypeOnly<current.SubmitSummaryFailureData>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SubmitSummaryFailureData": {"backCompat": false}
 */
declare type current_as_old_for_Interface_SubmitSummaryFailureData = requireAssignableTo<TypeOnly<current.SubmitSummaryFailureData>, TypeOnly<old.SubmitSummaryFailureData>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_DocumentSchemaValueType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_DocumentSchemaValueType = requireAssignableTo<TypeOnly<old.DocumentSchemaValueType>, TypeOnly<current.DocumentSchemaValueType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_DocumentSchemaValueType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_DocumentSchemaValueType = requireAssignableTo<TypeOnly<current.DocumentSchemaValueType>, TypeOnly<old.DocumentSchemaValueType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_EnqueueSummarizeResult": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_EnqueueSummarizeResult = requireAssignableTo<TypeOnly<old.EnqueueSummarizeResult>, TypeOnly<current.EnqueueSummarizeResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_EnqueueSummarizeResult": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_EnqueueSummarizeResult = requireAssignableTo<TypeOnly<current.EnqueueSummarizeResult>, TypeOnly<old.EnqueueSummarizeResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_GCFeatureMatrix": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_GCFeatureMatrix = requireAssignableTo<TypeOnly<old.GCFeatureMatrix>, TypeOnly<current.GCFeatureMatrix>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_GCFeatureMatrix": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_GCFeatureMatrix = requireAssignableTo<TypeOnly<current.GCFeatureMatrix>, TypeOnly<old.GCFeatureMatrix>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_GCNodeType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_GCNodeType = requireAssignableTo<TypeOnly<old.GCNodeType>, TypeOnly<current.GCNodeType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_GCNodeType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_GCNodeType = requireAssignableTo<TypeOnly<current.GCNodeType>, TypeOnly<old.GCNodeType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_GCVersion": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_GCVersion = requireAssignableTo<TypeOnly<old.GCVersion>, TypeOnly<current.GCVersion>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_GCVersion": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_GCVersion = requireAssignableTo<TypeOnly<current.GCVersion>, TypeOnly<old.GCVersion>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IdCompressorMode": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IdCompressorMode = requireAssignableTo<TypeOnly<old.IdCompressorMode>, TypeOnly<current.IdCompressorMode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IdCompressorMode": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IdCompressorMode = requireAssignableTo<TypeOnly<current.IdCompressorMode>, TypeOnly<old.IdCompressorMode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IDocumentSchemaChangeMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IDocumentSchemaChangeMessage = requireAssignableTo<TypeOnly<old.IDocumentSchemaChangeMessage>, TypeOnly<current.IDocumentSchemaChangeMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IDocumentSchemaChangeMessage": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IDocumentSchemaChangeMessage = requireAssignableTo<TypeOnly<current.IDocumentSchemaChangeMessage>, TypeOnly<old.IDocumentSchemaChangeMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IDocumentSchemaCurrent": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IDocumentSchemaCurrent = requireAssignableTo<TypeOnly<old.IDocumentSchemaCurrent>, TypeOnly<current.IDocumentSchemaCurrent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IDocumentSchemaCurrent": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IDocumentSchemaCurrent = requireAssignableTo<TypeOnly<current.IDocumentSchemaCurrent>, TypeOnly<old.IDocumentSchemaCurrent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISummaryCancellationToken": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ISummaryCancellationToken = requireAssignableTo<TypeOnly<old.ISummaryCancellationToken>, TypeOnly<current.ISummaryCancellationToken>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISummaryCancellationToken": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ISummaryCancellationToken = requireAssignableTo<TypeOnly<current.ISummaryCancellationToken>, TypeOnly<old.ISummaryCancellationToken>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISummaryConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ISummaryConfiguration = requireAssignableTo<TypeOnly<old.ISummaryConfiguration>, TypeOnly<current.ISummaryConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISummaryConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ISummaryConfiguration = requireAssignableTo<TypeOnly<current.ISummaryConfiguration>, TypeOnly<old.ISummaryConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISummaryMetadataMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ISummaryMetadataMessage = requireAssignableTo<TypeOnly<old.ISummaryMetadataMessage>, TypeOnly<current.ISummaryMetadataMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISummaryMetadataMessage": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ISummaryMetadataMessage = requireAssignableTo<TypeOnly<current.ISummaryMetadataMessage>, TypeOnly<old.ISummaryMetadataMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_OmitAttributesVersions": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_OmitAttributesVersions = requireAssignableTo<TypeOnly<old.OmitAttributesVersions<any>>, TypeOnly<current.OmitAttributesVersions<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_OmitAttributesVersions": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_OmitAttributesVersions = requireAssignableTo<TypeOnly<current.OmitAttributesVersions<any>>, TypeOnly<old.OmitAttributesVersions<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_OpActionEventListener": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_OpActionEventListener = requireAssignableTo<TypeOnly<old.OpActionEventListener>, TypeOnly<current.OpActionEventListener>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_OpActionEventListener": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_OpActionEventListener = requireAssignableTo<TypeOnly<current.OpActionEventListener>, TypeOnly<old.OpActionEventListener>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_OpActionEventName": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_OpActionEventName = requireAssignableTo<TypeOnly<old.OpActionEventName>, TypeOnly<current.OpActionEventName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_OpActionEventName": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_OpActionEventName = requireAssignableTo<TypeOnly<current.OpActionEventName>, TypeOnly<old.OpActionEventName>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ReadFluidDataStoreAttributes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ReadFluidDataStoreAttributes = requireAssignableTo<TypeOnly<old.ReadFluidDataStoreAttributes>, TypeOnly<current.ReadFluidDataStoreAttributes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ReadFluidDataStoreAttributes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ReadFluidDataStoreAttributes = requireAssignableTo<TypeOnly<current.ReadFluidDataStoreAttributes>, TypeOnly<old.ReadFluidDataStoreAttributes>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SubmitSummaryResult": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SubmitSummaryResult = requireAssignableTo<TypeOnly<old.SubmitSummaryResult>, TypeOnly<current.SubmitSummaryResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SubmitSummaryResult": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SubmitSummaryResult = requireAssignableTo<TypeOnly<current.SubmitSummaryResult>, TypeOnly<old.SubmitSummaryResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummarizeResultPart": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SummarizeResultPart = requireAssignableTo<TypeOnly<old.SummarizeResultPart<any>>, TypeOnly<current.SummarizeResultPart<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummarizeResultPart": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SummarizeResultPart = requireAssignableTo<TypeOnly<current.SummarizeResultPart<any>>, TypeOnly<old.SummarizeResultPart<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummarizerStopReason": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SummarizerStopReason = requireAssignableTo<TypeOnly<old.SummarizerStopReason>, TypeOnly<current.SummarizerStopReason>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummarizerStopReason": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SummarizerStopReason = requireAssignableTo<TypeOnly<current.SummarizerStopReason>, TypeOnly<old.SummarizerStopReason>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryStage": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SummaryStage = requireAssignableTo<TypeOnly<old.SummaryStage>, TypeOnly<current.SummaryStage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummaryStage": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SummaryStage = requireAssignableTo<TypeOnly<current.SummaryStage>, TypeOnly<old.SummaryStage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_AllowTombstoneRequestHeaderKey": {"backCompat": false}
 */
declare type current_as_old_for_Variable_AllowTombstoneRequestHeaderKey = requireAssignableTo<TypeOnly<typeof current.AllowTombstoneRequestHeaderKey>, TypeOnly<typeof old.AllowTombstoneRequestHeaderKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_currentDocumentVersionSchema": {"backCompat": false}
 */
declare type current_as_old_for_Variable_currentDocumentVersionSchema = requireAssignableTo<TypeOnly<typeof current.currentDocumentVersionSchema>, TypeOnly<typeof old.currentDocumentVersionSchema>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_DefaultSummaryConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Variable_DefaultSummaryConfiguration = requireAssignableTo<TypeOnly<typeof current.DefaultSummaryConfiguration>, TypeOnly<typeof old.DefaultSummaryConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_DeletedResponseHeaderKey": {"backCompat": false}
 */
declare type current_as_old_for_Variable_DeletedResponseHeaderKey = requireAssignableTo<TypeOnly<typeof current.DeletedResponseHeaderKey>, TypeOnly<typeof old.DeletedResponseHeaderKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_disabledCompressionConfig": {"backCompat": false}
 */
declare type current_as_old_for_Variable_disabledCompressionConfig = requireAssignableTo<TypeOnly<typeof current.disabledCompressionConfig>, TypeOnly<typeof old.disabledCompressionConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_GCNodeType": {"backCompat": false}
 */
declare type current_as_old_for_Variable_GCNodeType = requireAssignableTo<TypeOnly<typeof current.GCNodeType>, TypeOnly<typeof old.GCNodeType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_InactiveResponseHeaderKey": {"backCompat": false}
 */
declare type current_as_old_for_Variable_InactiveResponseHeaderKey = requireAssignableTo<TypeOnly<typeof current.InactiveResponseHeaderKey>, TypeOnly<typeof old.InactiveResponseHeaderKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_TombstoneResponseHeaderKey": {"backCompat": false}
 */
declare type current_as_old_for_Variable_TombstoneResponseHeaderKey = requireAssignableTo<TypeOnly<typeof current.TombstoneResponseHeaderKey>, TypeOnly<typeof old.TombstoneResponseHeaderKey>>
