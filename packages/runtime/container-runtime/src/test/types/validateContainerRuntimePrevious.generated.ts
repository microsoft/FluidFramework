/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/container-runtime-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ContainerRuntime": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ContainerRuntime = requireAssignableTo<TypeOnly<old.ContainerRuntime>, TypeOnly<current.ContainerRuntime>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ContainerRuntime": {"backCompat": false}
 */
declare type current_as_old_for_Class_ContainerRuntime = requireAssignableTo<TypeOnly<current.ContainerRuntime>, TypeOnly<old.ContainerRuntime>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DeltaScheduler": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DeltaScheduler = requireAssignableTo<TypeOnly<old.DeltaScheduler>, TypeOnly<current.DeltaScheduler>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DeltaScheduler": {"backCompat": false}
 */
declare type current_as_old_for_Class_DeltaScheduler = requireAssignableTo<TypeOnly<current.DeltaScheduler>, TypeOnly<old.DeltaScheduler>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_FluidDataStoreRegistry": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_FluidDataStoreRegistry = requireAssignableTo<TypeOnly<old.FluidDataStoreRegistry>, TypeOnly<current.FluidDataStoreRegistry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_FluidDataStoreRegistry": {"backCompat": false}
 */
declare type current_as_old_for_Class_FluidDataStoreRegistry = requireAssignableTo<TypeOnly<current.FluidDataStoreRegistry>, TypeOnly<old.FluidDataStoreRegistry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ScheduleManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ScheduleManager = requireAssignableTo<TypeOnly<old.ScheduleManager>, TypeOnly<current.ScheduleManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ScheduleManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_ScheduleManager = requireAssignableTo<TypeOnly<current.ScheduleManager>, TypeOnly<old.ScheduleManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Summarizer": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Summarizer = requireAssignableTo<TypeOnly<old.Summarizer>, TypeOnly<current.Summarizer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Summarizer": {"backCompat": false}
 */
declare type current_as_old_for_Class_Summarizer = requireAssignableTo<TypeOnly<current.Summarizer>, TypeOnly<old.Summarizer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SummaryCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SummaryCollection = requireAssignableTo<TypeOnly<old.SummaryCollection>, TypeOnly<current.SummaryCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SummaryCollection": {"backCompat": false}
 */
declare type current_as_old_for_Class_SummaryCollection = requireAssignableTo<TypeOnly<current.SummaryCollection>, TypeOnly<old.SummaryCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ContainerRuntime": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ContainerRuntime = requireAssignableTo<TypeOnly<typeof current.ContainerRuntime>, TypeOnly<typeof old.ContainerRuntime>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DeltaScheduler": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DeltaScheduler = requireAssignableTo<TypeOnly<typeof current.DeltaScheduler>, TypeOnly<typeof old.DeltaScheduler>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_FluidDataStoreRegistry": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_FluidDataStoreRegistry = requireAssignableTo<TypeOnly<typeof current.FluidDataStoreRegistry>, TypeOnly<typeof old.FluidDataStoreRegistry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ScheduleManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ScheduleManager = requireAssignableTo<TypeOnly<typeof current.ScheduleManager>, TypeOnly<typeof old.ScheduleManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Summarizer": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Summarizer = requireAssignableTo<TypeOnly<typeof current.Summarizer>, TypeOnly<typeof old.Summarizer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SummaryCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SummaryCollection = requireAssignableTo<TypeOnly<typeof current.SummaryCollection>, TypeOnly<typeof old.SummaryCollection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ContainerMessageType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_ContainerMessageType = requireAssignableTo<TypeOnly<old.ContainerMessageType>, TypeOnly<current.ContainerMessageType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ContainerMessageType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_ContainerMessageType = requireAssignableTo<TypeOnly<current.ContainerMessageType>, TypeOnly<old.ContainerMessageType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_RuntimeHeaders": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_RuntimeHeaders = requireAssignableTo<TypeOnly<old.RuntimeHeaders>, TypeOnly<current.RuntimeHeaders>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_RuntimeHeaders": {"backCompat": false}
 */
declare type current_as_old_for_Enum_RuntimeHeaders = requireAssignableTo<TypeOnly<current.RuntimeHeaders>, TypeOnly<old.RuntimeHeaders>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_RuntimeMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_RuntimeMessage = requireAssignableTo<TypeOnly<old.RuntimeMessage>, TypeOnly<current.RuntimeMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_RuntimeMessage": {"backCompat": false}
 */
declare type current_as_old_for_Enum_RuntimeMessage = requireAssignableTo<TypeOnly<current.RuntimeMessage>, TypeOnly<old.RuntimeMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isRuntimeMessage": {"backCompat": false}
 */
declare type current_as_old_for_Function_isRuntimeMessage = requireAssignableTo<TypeOnly<typeof current.isRuntimeMessage>, TypeOnly<typeof old.isRuntimeMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_unpackRuntimeMessage": {"backCompat": false}
 */
declare type current_as_old_for_Function_unpackRuntimeMessage = requireAssignableTo<TypeOnly<typeof current.unpackRuntimeMessage>, TypeOnly<typeof old.unpackRuntimeMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ContainerRuntimeMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ContainerRuntimeMessage = requireAssignableTo<TypeOnly<old.ContainerRuntimeMessage>, TypeOnly<current.ContainerRuntimeMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ContainerRuntimeMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ContainerRuntimeMessage = requireAssignableTo<TypeOnly<current.ContainerRuntimeMessage>, TypeOnly<old.ContainerRuntimeMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAckedSummary": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IAckedSummary = requireAssignableTo<TypeOnly<old.IAckedSummary>, TypeOnly<current.IAckedSummary>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAckedSummary": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IAckedSummary = requireAssignableTo<TypeOnly<current.IAckedSummary>, TypeOnly<old.IAckedSummary>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAckSummaryResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IAckSummaryResult = requireAssignableTo<TypeOnly<old.IAckSummaryResult>, TypeOnly<current.IAckSummaryResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAckSummaryResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IAckSummaryResult = requireAssignableTo<TypeOnly<current.IAckSummaryResult>, TypeOnly<old.IAckSummaryResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBaseSummarizeResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IBaseSummarizeResult = requireAssignableTo<TypeOnly<old.IBaseSummarizeResult>, TypeOnly<current.IBaseSummarizeResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBaseSummarizeResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IBaseSummarizeResult = requireAssignableTo<TypeOnly<current.IBaseSummarizeResult>, TypeOnly<old.IBaseSummarizeResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBroadcastSummaryResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IBroadcastSummaryResult = requireAssignableTo<TypeOnly<old.IBroadcastSummaryResult>, TypeOnly<current.IBroadcastSummaryResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBroadcastSummaryResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IBroadcastSummaryResult = requireAssignableTo<TypeOnly<current.IBroadcastSummaryResult>, TypeOnly<old.IBroadcastSummaryResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICancellableSummarizerController": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICancellableSummarizerController = requireAssignableTo<TypeOnly<old.ICancellableSummarizerController>, TypeOnly<current.ICancellableSummarizerController>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICancellableSummarizerController": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICancellableSummarizerController = requireAssignableTo<TypeOnly<current.ICancellableSummarizerController>, TypeOnly<old.ICancellableSummarizerController>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICancellationToken": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICancellationToken = requireAssignableTo<TypeOnly<old.ICancellationToken<never>>, TypeOnly<current.ICancellationToken<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICancellationToken": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICancellationToken = requireAssignableTo<TypeOnly<current.ICancellationToken<never>>, TypeOnly<old.ICancellationToken<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IChunkedOp": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IChunkedOp = requireAssignableTo<TypeOnly<old.IChunkedOp>, TypeOnly<current.IChunkedOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IChunkedOp": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IChunkedOp = requireAssignableTo<TypeOnly<current.IChunkedOp>, TypeOnly<old.IChunkedOp>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientSummaryWatcher": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IClientSummaryWatcher = requireAssignableTo<TypeOnly<old.IClientSummaryWatcher>, TypeOnly<current.IClientSummaryWatcher>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientSummaryWatcher": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IClientSummaryWatcher = requireAssignableTo<TypeOnly<current.IClientSummaryWatcher>, TypeOnly<old.IClientSummaryWatcher>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnectableRuntime": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConnectableRuntime = requireAssignableTo<TypeOnly<old.IConnectableRuntime>, TypeOnly<current.IConnectableRuntime>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnectableRuntime": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConnectableRuntime = requireAssignableTo<TypeOnly<current.IConnectableRuntime>, TypeOnly<old.IConnectableRuntime>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContainerRuntimeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IContainerRuntimeOptions = requireAssignableTo<TypeOnly<old.IContainerRuntimeOptions>, TypeOnly<current.IContainerRuntimeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContainerRuntimeOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IContainerRuntimeOptions = requireAssignableTo<TypeOnly<current.IContainerRuntimeOptions>, TypeOnly<old.IContainerRuntimeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEnqueueSummarizeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IEnqueueSummarizeOptions = requireAssignableTo<TypeOnly<old.IEnqueueSummarizeOptions>, TypeOnly<current.IEnqueueSummarizeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEnqueueSummarizeOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IEnqueueSummarizeOptions = requireAssignableTo<TypeOnly<current.IEnqueueSummarizeOptions>, TypeOnly<old.IEnqueueSummarizeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGarbageCollectionRuntime": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGarbageCollectionRuntime = requireAssignableTo<TypeOnly<old.IGarbageCollectionRuntime>, TypeOnly<current.IGarbageCollectionRuntime>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGarbageCollectionRuntime": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGarbageCollectionRuntime = requireAssignableTo<TypeOnly<current.IGarbageCollectionRuntime>, TypeOnly<old.IGarbageCollectionRuntime>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGCRuntimeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGCRuntimeOptions = requireAssignableTo<TypeOnly<old.IGCRuntimeOptions>, TypeOnly<current.IGCRuntimeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGCRuntimeOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGCRuntimeOptions = requireAssignableTo<TypeOnly<current.IGCRuntimeOptions>, TypeOnly<old.IGCRuntimeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGCStats": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGCStats = requireAssignableTo<TypeOnly<old.IGCStats>, TypeOnly<current.IGCStats>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGCStats": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGCStats = requireAssignableTo<TypeOnly<current.IGCStats>, TypeOnly<old.IGCStats>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGeneratedSummaryStats": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGeneratedSummaryStats = requireAssignableTo<TypeOnly<old.IGeneratedSummaryStats>, TypeOnly<current.IGeneratedSummaryStats>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGeneratedSummaryStats": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGeneratedSummaryStats = requireAssignableTo<TypeOnly<current.IGeneratedSummaryStats>, TypeOnly<old.IGeneratedSummaryStats>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGenerateSummaryTreeResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGenerateSummaryTreeResult = requireAssignableTo<TypeOnly<old.IGenerateSummaryTreeResult>, TypeOnly<current.IGenerateSummaryTreeResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGenerateSummaryTreeResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGenerateSummaryTreeResult = requireAssignableTo<TypeOnly<current.IGenerateSummaryTreeResult>, TypeOnly<old.IGenerateSummaryTreeResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INackSummaryResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_INackSummaryResult = requireAssignableTo<TypeOnly<old.INackSummaryResult>, TypeOnly<current.INackSummaryResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INackSummaryResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_INackSummaryResult = requireAssignableTo<TypeOnly<current.INackSummaryResult>, TypeOnly<old.INackSummaryResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IOnDemandSummarizeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IOnDemandSummarizeOptions = requireAssignableTo<TypeOnly<old.IOnDemandSummarizeOptions>, TypeOnly<current.IOnDemandSummarizeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IOnDemandSummarizeOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IOnDemandSummarizeOptions = requireAssignableTo<TypeOnly<current.IOnDemandSummarizeOptions>, TypeOnly<old.IOnDemandSummarizeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingFlush": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPendingFlush = requireAssignableTo<TypeOnly<old.IPendingFlush>, TypeOnly<current.IPendingFlush>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingFlush": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPendingFlush = requireAssignableTo<TypeOnly<current.IPendingFlush>, TypeOnly<old.IPendingFlush>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingFlushMode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPendingFlushMode = requireAssignableTo<TypeOnly<old.IPendingFlushMode>, TypeOnly<current.IPendingFlushMode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingFlushMode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPendingFlushMode = requireAssignableTo<TypeOnly<current.IPendingFlushMode>, TypeOnly<old.IPendingFlushMode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingLocalState": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPendingLocalState = requireAssignableTo<TypeOnly<old.IPendingLocalState>, TypeOnly<current.IPendingLocalState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingLocalState": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPendingLocalState = requireAssignableTo<TypeOnly<current.IPendingLocalState>, TypeOnly<old.IPendingLocalState>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPendingMessage = requireAssignableTo<TypeOnly<old.IPendingMessage>, TypeOnly<current.IPendingMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPendingMessage = requireAssignableTo<TypeOnly<current.IPendingMessage>, TypeOnly<old.IPendingMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingRuntimeState": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPendingRuntimeState = requireAssignableTo<TypeOnly<old.IPendingRuntimeState>, TypeOnly<current.IPendingRuntimeState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingRuntimeState": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPendingRuntimeState = requireAssignableTo<TypeOnly<current.IPendingRuntimeState>, TypeOnly<old.IPendingRuntimeState>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideSummarizer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProvideSummarizer = requireAssignableTo<TypeOnly<old.IProvideSummarizer>, TypeOnly<current.IProvideSummarizer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideSummarizer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProvideSummarizer = requireAssignableTo<TypeOnly<current.IProvideSummarizer>, TypeOnly<old.IProvideSummarizer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRootSummaryTreeWithStats": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRootSummaryTreeWithStats = requireAssignableTo<TypeOnly<old.IRootSummaryTreeWithStats>, TypeOnly<current.IRootSummaryTreeWithStats>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRootSummaryTreeWithStats": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRootSummaryTreeWithStats = requireAssignableTo<TypeOnly<current.IRootSummaryTreeWithStats>, TypeOnly<old.IRootSummaryTreeWithStats>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISubmitSummaryOpResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISubmitSummaryOpResult = requireAssignableTo<TypeOnly<old.ISubmitSummaryOpResult>, TypeOnly<current.ISubmitSummaryOpResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISubmitSummaryOpResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISubmitSummaryOpResult = requireAssignableTo<TypeOnly<current.ISubmitSummaryOpResult>, TypeOnly<old.ISubmitSummaryOpResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISubmitSummaryOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISubmitSummaryOptions = requireAssignableTo<TypeOnly<old.ISubmitSummaryOptions>, TypeOnly<current.ISubmitSummaryOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISubmitSummaryOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISubmitSummaryOptions = requireAssignableTo<TypeOnly<current.ISubmitSummaryOptions>, TypeOnly<old.ISubmitSummaryOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizeOptions = requireAssignableTo<TypeOnly<old.ISummarizeOptions>, TypeOnly<current.ISummarizeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizeOptions = requireAssignableTo<TypeOnly<current.ISummarizeOptions>, TypeOnly<old.ISummarizeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizer = requireAssignableTo<TypeOnly<old.ISummarizer>, TypeOnly<current.ISummarizer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizer = requireAssignableTo<TypeOnly<current.ISummarizer>, TypeOnly<old.ISummarizer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeResults": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizeResults = requireAssignableTo<TypeOnly<old.ISummarizeResults>, TypeOnly<current.ISummarizeResults>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeResults": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizeResults = requireAssignableTo<TypeOnly<current.ISummarizeResults>, TypeOnly<old.ISummarizeResults>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizerEvents = requireAssignableTo<TypeOnly<old.ISummarizerEvents>, TypeOnly<current.ISummarizerEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizerEvents = requireAssignableTo<TypeOnly<current.ISummarizerEvents>, TypeOnly<old.ISummarizerEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerInternalsProvider": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizerInternalsProvider = requireAssignableTo<TypeOnly<old.ISummarizerInternalsProvider>, TypeOnly<current.ISummarizerInternalsProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerInternalsProvider": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizerInternalsProvider = requireAssignableTo<TypeOnly<current.ISummarizerInternalsProvider>, TypeOnly<old.ISummarizerInternalsProvider>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerRuntime": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizerRuntime = requireAssignableTo<TypeOnly<old.ISummarizerRuntime>, TypeOnly<current.ISummarizerRuntime>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerRuntime": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizerRuntime = requireAssignableTo<TypeOnly<current.ISummarizerRuntime>, TypeOnly<old.ISummarizerRuntime>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizingWarning": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizingWarning = requireAssignableTo<TypeOnly<old.ISummarizingWarning>, TypeOnly<current.ISummarizingWarning>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizingWarning": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizingWarning = requireAssignableTo<TypeOnly<current.ISummarizingWarning>, TypeOnly<old.ISummarizingWarning>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummary": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummary = requireAssignableTo<TypeOnly<old.ISummary>, TypeOnly<current.ISummary>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummary": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummary = requireAssignableTo<TypeOnly<current.ISummary>, TypeOnly<old.ISummary>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryAckMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryAckMessage = requireAssignableTo<TypeOnly<old.ISummaryAckMessage>, TypeOnly<current.ISummaryAckMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryAckMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryAckMessage = requireAssignableTo<TypeOnly<current.ISummaryAckMessage>, TypeOnly<old.ISummaryAckMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryBaseConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryBaseConfiguration = requireAssignableTo<TypeOnly<old.ISummaryBaseConfiguration>, TypeOnly<current.ISummaryBaseConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryBaseConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryBaseConfiguration = requireAssignableTo<TypeOnly<current.ISummaryBaseConfiguration>, TypeOnly<old.ISummaryBaseConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryCollectionOpEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryCollectionOpEvents = requireAssignableTo<TypeOnly<old.ISummaryCollectionOpEvents>, TypeOnly<current.ISummaryCollectionOpEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryCollectionOpEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryCollectionOpEvents = requireAssignableTo<TypeOnly<current.ISummaryCollectionOpEvents>, TypeOnly<old.ISummaryCollectionOpEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryConfigurationDisableHeuristics": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryConfigurationDisableHeuristics = requireAssignableTo<TypeOnly<old.ISummaryConfigurationDisableHeuristics>, TypeOnly<current.ISummaryConfigurationDisableHeuristics>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryConfigurationDisableHeuristics": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryConfigurationDisableHeuristics = requireAssignableTo<TypeOnly<current.ISummaryConfigurationDisableHeuristics>, TypeOnly<old.ISummaryConfigurationDisableHeuristics>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryConfigurationDisableSummarizer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryConfigurationDisableSummarizer = requireAssignableTo<TypeOnly<old.ISummaryConfigurationDisableSummarizer>, TypeOnly<current.ISummaryConfigurationDisableSummarizer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryConfigurationDisableSummarizer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryConfigurationDisableSummarizer = requireAssignableTo<TypeOnly<current.ISummaryConfigurationDisableSummarizer>, TypeOnly<old.ISummaryConfigurationDisableSummarizer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryConfigurationHeuristics": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryConfigurationHeuristics = requireAssignableTo<TypeOnly<old.ISummaryConfigurationHeuristics>, TypeOnly<current.ISummaryConfigurationHeuristics>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryConfigurationHeuristics": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryConfigurationHeuristics = requireAssignableTo<TypeOnly<current.ISummaryConfigurationHeuristics>, TypeOnly<old.ISummaryConfigurationHeuristics>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryNackMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryNackMessage = requireAssignableTo<TypeOnly<old.ISummaryNackMessage>, TypeOnly<current.ISummaryNackMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryNackMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryNackMessage = requireAssignableTo<TypeOnly<current.ISummaryNackMessage>, TypeOnly<old.ISummaryNackMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryOpMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryOpMessage = requireAssignableTo<TypeOnly<old.ISummaryOpMessage>, TypeOnly<current.ISummaryOpMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryOpMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryOpMessage = requireAssignableTo<TypeOnly<current.ISummaryOpMessage>, TypeOnly<old.ISummaryOpMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryRuntimeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryRuntimeOptions = requireAssignableTo<TypeOnly<old.ISummaryRuntimeOptions>, TypeOnly<current.ISummaryRuntimeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryRuntimeOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryRuntimeOptions = requireAssignableTo<TypeOnly<current.ISummaryRuntimeOptions>, TypeOnly<old.ISummaryRuntimeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUploadSummaryResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IUploadSummaryResult = requireAssignableTo<TypeOnly<old.IUploadSummaryResult>, TypeOnly<current.IUploadSummaryResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUploadSummaryResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IUploadSummaryResult = requireAssignableTo<TypeOnly<current.IUploadSummaryResult>, TypeOnly<old.IUploadSummaryResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_EnqueueSummarizeResult": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_EnqueueSummarizeResult = requireAssignableTo<TypeOnly<old.EnqueueSummarizeResult>, TypeOnly<current.EnqueueSummarizeResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_EnqueueSummarizeResult": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_EnqueueSummarizeResult = requireAssignableTo<TypeOnly<current.EnqueueSummarizeResult>, TypeOnly<old.EnqueueSummarizeResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IPendingState": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IPendingState = requireAssignableTo<TypeOnly<old.IPendingState>, TypeOnly<current.IPendingState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IPendingState": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IPendingState = requireAssignableTo<TypeOnly<current.IPendingState>, TypeOnly<old.IPendingState>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISummaryCancellationToken": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ISummaryCancellationToken = requireAssignableTo<TypeOnly<old.ISummaryCancellationToken>, TypeOnly<current.ISummaryCancellationToken>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISummaryCancellationToken": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ISummaryCancellationToken = requireAssignableTo<TypeOnly<current.ISummaryCancellationToken>, TypeOnly<old.ISummaryCancellationToken>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISummaryConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ISummaryConfiguration = requireAssignableTo<TypeOnly<old.ISummaryConfiguration>, TypeOnly<current.ISummaryConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISummaryConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ISummaryConfiguration = requireAssignableTo<TypeOnly<current.ISummaryConfiguration>, TypeOnly<old.ISummaryConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_OpActionEventListener": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_OpActionEventListener = requireAssignableTo<TypeOnly<old.OpActionEventListener>, TypeOnly<current.OpActionEventListener>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_OpActionEventListener": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_OpActionEventListener = requireAssignableTo<TypeOnly<current.OpActionEventListener>, TypeOnly<old.OpActionEventListener>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_OpActionEventName": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_OpActionEventName = requireAssignableTo<TypeOnly<old.OpActionEventName>, TypeOnly<current.OpActionEventName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_OpActionEventName": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_OpActionEventName = requireAssignableTo<TypeOnly<current.OpActionEventName>, TypeOnly<old.OpActionEventName>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SubmitSummaryResult": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SubmitSummaryResult = requireAssignableTo<TypeOnly<old.SubmitSummaryResult>, TypeOnly<current.SubmitSummaryResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SubmitSummaryResult": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SubmitSummaryResult = requireAssignableTo<TypeOnly<current.SubmitSummaryResult>, TypeOnly<old.SubmitSummaryResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummarizeResultPart": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SummarizeResultPart = requireAssignableTo<TypeOnly<old.SummarizeResultPart<never>>, TypeOnly<current.SummarizeResultPart<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummarizeResultPart": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SummarizeResultPart = requireAssignableTo<TypeOnly<current.SummarizeResultPart<never>>, TypeOnly<old.SummarizeResultPart<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummarizerStopReason": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SummarizerStopReason = requireAssignableTo<TypeOnly<old.SummarizerStopReason>, TypeOnly<current.SummarizerStopReason>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummarizerStopReason": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SummarizerStopReason = requireAssignableTo<TypeOnly<current.SummarizerStopReason>, TypeOnly<old.SummarizerStopReason>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_agentSchedulerId": {"backCompat": false}
 */
declare type current_as_old_for_Variable_agentSchedulerId = requireAssignableTo<TypeOnly<typeof current.agentSchedulerId>, TypeOnly<typeof old.agentSchedulerId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_DefaultSummaryConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Variable_DefaultSummaryConfiguration = requireAssignableTo<TypeOnly<typeof current.DefaultSummaryConfiguration>, TypeOnly<typeof old.DefaultSummaryConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_gcBlobPrefix": {"backCompat": false}
 */
declare type current_as_old_for_Variable_gcBlobPrefix = requireAssignableTo<TypeOnly<typeof current.gcBlobPrefix>, TypeOnly<typeof old.gcBlobPrefix>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_gcTreeKey": {"backCompat": false}
 */
declare type current_as_old_for_Variable_gcTreeKey = requireAssignableTo<TypeOnly<typeof current.gcTreeKey>, TypeOnly<typeof old.gcTreeKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_ISummarizer": {"backCompat": false}
 */
declare type current_as_old_for_Variable_ISummarizer = requireAssignableTo<TypeOnly<typeof current.ISummarizer>, TypeOnly<typeof old.ISummarizer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_neverCancelledSummaryToken": {"backCompat": false}
 */
declare type current_as_old_for_Variable_neverCancelledSummaryToken = requireAssignableTo<TypeOnly<typeof current.neverCancelledSummaryToken>, TypeOnly<typeof old.neverCancelledSummaryToken>>
