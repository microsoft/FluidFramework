/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */
import type * as old from "@fluidframework/container-runtime-previous";
import type * as current from "../../index";


// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_AllowInactiveRequestHeaderKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_AllowInactiveRequestHeaderKey():
    TypeOnly<typeof old.AllowInactiveRequestHeaderKey>;
declare function use_current_VariableDeclaration_AllowInactiveRequestHeaderKey(
    use: TypeOnly<typeof current.AllowInactiveRequestHeaderKey>): void;
use_current_VariableDeclaration_AllowInactiveRequestHeaderKey(
    get_old_VariableDeclaration_AllowInactiveRequestHeaderKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_AllowInactiveRequestHeaderKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_AllowInactiveRequestHeaderKey():
    TypeOnly<typeof current.AllowInactiveRequestHeaderKey>;
declare function use_old_VariableDeclaration_AllowInactiveRequestHeaderKey(
    use: TypeOnly<typeof old.AllowInactiveRequestHeaderKey>): void;
use_old_VariableDeclaration_AllowInactiveRequestHeaderKey(
    get_current_VariableDeclaration_AllowInactiveRequestHeaderKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_AllowTombstoneRequestHeaderKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_AllowTombstoneRequestHeaderKey():
    TypeOnly<typeof old.AllowTombstoneRequestHeaderKey>;
declare function use_current_VariableDeclaration_AllowTombstoneRequestHeaderKey(
    use: TypeOnly<typeof current.AllowTombstoneRequestHeaderKey>): void;
use_current_VariableDeclaration_AllowTombstoneRequestHeaderKey(
    get_old_VariableDeclaration_AllowTombstoneRequestHeaderKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_AllowTombstoneRequestHeaderKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_AllowTombstoneRequestHeaderKey():
    TypeOnly<typeof current.AllowTombstoneRequestHeaderKey>;
declare function use_old_VariableDeclaration_AllowTombstoneRequestHeaderKey(
    use: TypeOnly<typeof old.AllowTombstoneRequestHeaderKey>): void;
use_old_VariableDeclaration_AllowTombstoneRequestHeaderKey(
    get_current_VariableDeclaration_AllowTombstoneRequestHeaderKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CompatModeBehavior": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_CompatModeBehavior():
    TypeOnly<old.CompatModeBehavior>;
declare function use_current_TypeAliasDeclaration_CompatModeBehavior(
    use: TypeOnly<current.CompatModeBehavior>): void;
use_current_TypeAliasDeclaration_CompatModeBehavior(
    get_old_TypeAliasDeclaration_CompatModeBehavior());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CompatModeBehavior": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_CompatModeBehavior():
    TypeOnly<current.CompatModeBehavior>;
declare function use_old_TypeAliasDeclaration_CompatModeBehavior(
    use: TypeOnly<old.CompatModeBehavior>): void;
use_old_TypeAliasDeclaration_CompatModeBehavior(
    get_current_TypeAliasDeclaration_CompatModeBehavior());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_CompressionAlgorithms": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_CompressionAlgorithms():
    TypeOnly<old.CompressionAlgorithms>;
declare function use_current_EnumDeclaration_CompressionAlgorithms(
    use: TypeOnly<current.CompressionAlgorithms>): void;
use_current_EnumDeclaration_CompressionAlgorithms(
    get_old_EnumDeclaration_CompressionAlgorithms());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_CompressionAlgorithms": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_CompressionAlgorithms():
    TypeOnly<current.CompressionAlgorithms>;
declare function use_old_EnumDeclaration_CompressionAlgorithms(
    use: TypeOnly<old.CompressionAlgorithms>): void;
use_old_EnumDeclaration_CompressionAlgorithms(
    get_current_EnumDeclaration_CompressionAlgorithms());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ContainerMessageType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_ContainerMessageType():
    TypeOnly<old.ContainerMessageType>;
declare function use_current_EnumDeclaration_ContainerMessageType(
    use: TypeOnly<current.ContainerMessageType>): void;
use_current_EnumDeclaration_ContainerMessageType(
    get_old_EnumDeclaration_ContainerMessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ContainerMessageType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_ContainerMessageType():
    TypeOnly<current.ContainerMessageType>;
declare function use_old_EnumDeclaration_ContainerMessageType(
    use: TypeOnly<old.ContainerMessageType>): void;
use_old_EnumDeclaration_ContainerMessageType(
    get_current_EnumDeclaration_ContainerMessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ContainerRuntime": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ContainerRuntime():
    TypeOnly<old.ContainerRuntime>;
declare function use_current_ClassDeclaration_ContainerRuntime(
    use: TypeOnly<current.ContainerRuntime>): void;
use_current_ClassDeclaration_ContainerRuntime(
    get_old_ClassDeclaration_ContainerRuntime());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ContainerRuntime": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ContainerRuntime():
    TypeOnly<current.ContainerRuntime>;
declare function use_old_ClassDeclaration_ContainerRuntime(
    use: TypeOnly<old.ContainerRuntime>): void;
use_old_ClassDeclaration_ContainerRuntime(
    // @ts-expect-error compatibility expected to be broken
    get_current_ClassDeclaration_ContainerRuntime());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerRuntimeMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerRuntimeMessage():
    TypeOnly<old.ContainerRuntimeMessage>;
declare function use_current_InterfaceDeclaration_ContainerRuntimeMessage(
    use: TypeOnly<current.ContainerRuntimeMessage>): void;
use_current_InterfaceDeclaration_ContainerRuntimeMessage(
    get_old_InterfaceDeclaration_ContainerRuntimeMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerRuntimeMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerRuntimeMessage():
    TypeOnly<current.ContainerRuntimeMessage>;
declare function use_old_InterfaceDeclaration_ContainerRuntimeMessage(
    use: TypeOnly<old.ContainerRuntimeMessage>): void;
use_old_InterfaceDeclaration_ContainerRuntimeMessage(
    get_current_InterfaceDeclaration_ContainerRuntimeMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DefaultSummaryConfiguration": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_DefaultSummaryConfiguration():
    TypeOnly<typeof old.DefaultSummaryConfiguration>;
declare function use_current_VariableDeclaration_DefaultSummaryConfiguration(
    use: TypeOnly<typeof current.DefaultSummaryConfiguration>): void;
use_current_VariableDeclaration_DefaultSummaryConfiguration(
    get_old_VariableDeclaration_DefaultSummaryConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DefaultSummaryConfiguration": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_DefaultSummaryConfiguration():
    TypeOnly<typeof current.DefaultSummaryConfiguration>;
declare function use_old_VariableDeclaration_DefaultSummaryConfiguration(
    use: TypeOnly<typeof old.DefaultSummaryConfiguration>): void;
use_old_VariableDeclaration_DefaultSummaryConfiguration(
    get_current_VariableDeclaration_DefaultSummaryConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_EnqueueSummarizeResult": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_EnqueueSummarizeResult():
    TypeOnly<old.EnqueueSummarizeResult>;
declare function use_current_TypeAliasDeclaration_EnqueueSummarizeResult(
    use: TypeOnly<current.EnqueueSummarizeResult>): void;
use_current_TypeAliasDeclaration_EnqueueSummarizeResult(
    get_old_TypeAliasDeclaration_EnqueueSummarizeResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_EnqueueSummarizeResult": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_EnqueueSummarizeResult():
    TypeOnly<current.EnqueueSummarizeResult>;
declare function use_old_TypeAliasDeclaration_EnqueueSummarizeResult(
    use: TypeOnly<old.EnqueueSummarizeResult>): void;
use_old_TypeAliasDeclaration_EnqueueSummarizeResult(
    get_current_TypeAliasDeclaration_EnqueueSummarizeResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_FluidDataStoreRegistry": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_FluidDataStoreRegistry():
    TypeOnly<old.FluidDataStoreRegistry>;
declare function use_current_ClassDeclaration_FluidDataStoreRegistry(
    use: TypeOnly<current.FluidDataStoreRegistry>): void;
use_current_ClassDeclaration_FluidDataStoreRegistry(
    get_old_ClassDeclaration_FluidDataStoreRegistry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_FluidDataStoreRegistry": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_FluidDataStoreRegistry():
    TypeOnly<current.FluidDataStoreRegistry>;
declare function use_old_ClassDeclaration_FluidDataStoreRegistry(
    use: TypeOnly<old.FluidDataStoreRegistry>): void;
use_old_ClassDeclaration_FluidDataStoreRegistry(
    get_current_ClassDeclaration_FluidDataStoreRegistry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedInterfaceDeclaration_GCFeatureMatrix": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_GCFeatureMatrix():
    TypeOnly<old.GCFeatureMatrix>;
declare function use_current_RemovedInterfaceDeclaration_GCFeatureMatrix(
    use: TypeOnly<current.GCFeatureMatrix>): void;
use_current_RemovedInterfaceDeclaration_GCFeatureMatrix(
    get_old_InterfaceDeclaration_GCFeatureMatrix());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedInterfaceDeclaration_GCFeatureMatrix": {"backCompat": false}
*/
declare function get_current_RemovedInterfaceDeclaration_GCFeatureMatrix():
    TypeOnly<current.GCFeatureMatrix>;
declare function use_old_InterfaceDeclaration_GCFeatureMatrix(
    use: TypeOnly<old.GCFeatureMatrix>): void;
use_old_InterfaceDeclaration_GCFeatureMatrix(
    get_current_RemovedInterfaceDeclaration_GCFeatureMatrix());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GCNodeType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_GCNodeType():
    TypeOnly<typeof old.GCNodeType>;
declare function use_current_VariableDeclaration_GCNodeType(
    use: TypeOnly<typeof current.GCNodeType>): void;
use_current_VariableDeclaration_GCNodeType(
    get_old_VariableDeclaration_GCNodeType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GCNodeType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_GCNodeType():
    TypeOnly<typeof current.GCNodeType>;
declare function use_old_VariableDeclaration_GCNodeType(
    use: TypeOnly<typeof old.GCNodeType>): void;
use_old_VariableDeclaration_GCNodeType(
    get_current_VariableDeclaration_GCNodeType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GCNodeType": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_GCNodeType():
    TypeOnly<old.GCNodeType>;
declare function use_current_TypeAliasDeclaration_GCNodeType(
    use: TypeOnly<current.GCNodeType>): void;
use_current_TypeAliasDeclaration_GCNodeType(
    get_old_TypeAliasDeclaration_GCNodeType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GCNodeType": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_GCNodeType():
    TypeOnly<current.GCNodeType>;
declare function use_old_TypeAliasDeclaration_GCNodeType(
    use: TypeOnly<old.GCNodeType>): void;
use_old_TypeAliasDeclaration_GCNodeType(
    get_current_TypeAliasDeclaration_GCNodeType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GCVersion": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_GCVersion():
    TypeOnly<old.GCVersion>;
declare function use_current_TypeAliasDeclaration_GCVersion(
    use: TypeOnly<current.GCVersion>): void;
use_current_TypeAliasDeclaration_GCVersion(
    get_old_TypeAliasDeclaration_GCVersion());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GCVersion": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_GCVersion():
    TypeOnly<current.GCVersion>;
declare function use_old_TypeAliasDeclaration_GCVersion(
    use: TypeOnly<old.GCVersion>): void;
use_old_TypeAliasDeclaration_GCVersion(
    get_current_TypeAliasDeclaration_GCVersion());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAckSummaryResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAckSummaryResult():
    TypeOnly<old.IAckSummaryResult>;
declare function use_current_InterfaceDeclaration_IAckSummaryResult(
    use: TypeOnly<current.IAckSummaryResult>): void;
use_current_InterfaceDeclaration_IAckSummaryResult(
    get_old_InterfaceDeclaration_IAckSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAckSummaryResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAckSummaryResult():
    TypeOnly<current.IAckSummaryResult>;
declare function use_old_InterfaceDeclaration_IAckSummaryResult(
    use: TypeOnly<old.IAckSummaryResult>): void;
use_old_InterfaceDeclaration_IAckSummaryResult(
    get_current_InterfaceDeclaration_IAckSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAckedSummary": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAckedSummary():
    TypeOnly<old.IAckedSummary>;
declare function use_current_InterfaceDeclaration_IAckedSummary(
    use: TypeOnly<current.IAckedSummary>): void;
use_current_InterfaceDeclaration_IAckedSummary(
    get_old_InterfaceDeclaration_IAckedSummary());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAckedSummary": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAckedSummary():
    TypeOnly<current.IAckedSummary>;
declare function use_old_InterfaceDeclaration_IAckedSummary(
    use: TypeOnly<old.IAckedSummary>): void;
use_old_InterfaceDeclaration_IAckedSummary(
    get_current_InterfaceDeclaration_IAckedSummary());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBaseSummarizeResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IBaseSummarizeResult():
    TypeOnly<old.IBaseSummarizeResult>;
declare function use_current_InterfaceDeclaration_IBaseSummarizeResult(
    use: TypeOnly<current.IBaseSummarizeResult>): void;
use_current_InterfaceDeclaration_IBaseSummarizeResult(
    get_old_InterfaceDeclaration_IBaseSummarizeResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBaseSummarizeResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IBaseSummarizeResult():
    TypeOnly<current.IBaseSummarizeResult>;
declare function use_old_InterfaceDeclaration_IBaseSummarizeResult(
    use: TypeOnly<old.IBaseSummarizeResult>): void;
use_old_InterfaceDeclaration_IBaseSummarizeResult(
    get_current_InterfaceDeclaration_IBaseSummarizeResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBlobManagerLoadInfo": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IBlobManagerLoadInfo():
    TypeOnly<old.IBlobManagerLoadInfo>;
declare function use_current_InterfaceDeclaration_IBlobManagerLoadInfo(
    use: TypeOnly<current.IBlobManagerLoadInfo>): void;
use_current_InterfaceDeclaration_IBlobManagerLoadInfo(
    get_old_InterfaceDeclaration_IBlobManagerLoadInfo());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBlobManagerLoadInfo": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IBlobManagerLoadInfo():
    TypeOnly<current.IBlobManagerLoadInfo>;
declare function use_old_InterfaceDeclaration_IBlobManagerLoadInfo(
    use: TypeOnly<old.IBlobManagerLoadInfo>): void;
use_old_InterfaceDeclaration_IBlobManagerLoadInfo(
    get_current_InterfaceDeclaration_IBlobManagerLoadInfo());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBroadcastSummaryResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IBroadcastSummaryResult():
    TypeOnly<old.IBroadcastSummaryResult>;
declare function use_current_InterfaceDeclaration_IBroadcastSummaryResult(
    use: TypeOnly<current.IBroadcastSummaryResult>): void;
use_current_InterfaceDeclaration_IBroadcastSummaryResult(
    get_old_InterfaceDeclaration_IBroadcastSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBroadcastSummaryResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IBroadcastSummaryResult():
    TypeOnly<current.IBroadcastSummaryResult>;
declare function use_old_InterfaceDeclaration_IBroadcastSummaryResult(
    use: TypeOnly<old.IBroadcastSummaryResult>): void;
use_old_InterfaceDeclaration_IBroadcastSummaryResult(
    get_current_InterfaceDeclaration_IBroadcastSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICancellableSummarizerController": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICancellableSummarizerController():
    TypeOnly<old.ICancellableSummarizerController>;
declare function use_current_InterfaceDeclaration_ICancellableSummarizerController(
    use: TypeOnly<current.ICancellableSummarizerController>): void;
use_current_InterfaceDeclaration_ICancellableSummarizerController(
    get_old_InterfaceDeclaration_ICancellableSummarizerController());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICancellableSummarizerController": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICancellableSummarizerController():
    TypeOnly<current.ICancellableSummarizerController>;
declare function use_old_InterfaceDeclaration_ICancellableSummarizerController(
    use: TypeOnly<old.ICancellableSummarizerController>): void;
use_old_InterfaceDeclaration_ICancellableSummarizerController(
    get_current_InterfaceDeclaration_ICancellableSummarizerController());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICancellationToken": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICancellationToken():
    TypeOnly<old.ICancellationToken<any>>;
declare function use_current_InterfaceDeclaration_ICancellationToken(
    use: TypeOnly<current.ICancellationToken<any>>): void;
use_current_InterfaceDeclaration_ICancellationToken(
    get_old_InterfaceDeclaration_ICancellationToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICancellationToken": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICancellationToken():
    TypeOnly<current.ICancellationToken<any>>;
declare function use_old_InterfaceDeclaration_ICancellationToken(
    use: TypeOnly<old.ICancellationToken<any>>): void;
use_old_InterfaceDeclaration_ICancellationToken(
    get_current_InterfaceDeclaration_ICancellationToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IChunkedOp": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IChunkedOp():
    TypeOnly<old.IChunkedOp>;
declare function use_current_InterfaceDeclaration_IChunkedOp(
    use: TypeOnly<current.IChunkedOp>): void;
use_current_InterfaceDeclaration_IChunkedOp(
    get_old_InterfaceDeclaration_IChunkedOp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IChunkedOp": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IChunkedOp():
    TypeOnly<current.IChunkedOp>;
declare function use_old_InterfaceDeclaration_IChunkedOp(
    use: TypeOnly<old.IChunkedOp>): void;
use_old_InterfaceDeclaration_IChunkedOp(
    get_current_InterfaceDeclaration_IChunkedOp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientSummaryWatcher": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IClientSummaryWatcher():
    TypeOnly<old.IClientSummaryWatcher>;
declare function use_current_InterfaceDeclaration_IClientSummaryWatcher(
    use: TypeOnly<current.IClientSummaryWatcher>): void;
use_current_InterfaceDeclaration_IClientSummaryWatcher(
    get_old_InterfaceDeclaration_IClientSummaryWatcher());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientSummaryWatcher": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IClientSummaryWatcher():
    TypeOnly<current.IClientSummaryWatcher>;
declare function use_old_InterfaceDeclaration_IClientSummaryWatcher(
    use: TypeOnly<old.IClientSummaryWatcher>): void;
use_old_InterfaceDeclaration_IClientSummaryWatcher(
    get_current_InterfaceDeclaration_IClientSummaryWatcher());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICompressionRuntimeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICompressionRuntimeOptions():
    TypeOnly<old.ICompressionRuntimeOptions>;
declare function use_current_InterfaceDeclaration_ICompressionRuntimeOptions(
    use: TypeOnly<current.ICompressionRuntimeOptions>): void;
use_current_InterfaceDeclaration_ICompressionRuntimeOptions(
    get_old_InterfaceDeclaration_ICompressionRuntimeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICompressionRuntimeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICompressionRuntimeOptions():
    TypeOnly<current.ICompressionRuntimeOptions>;
declare function use_old_InterfaceDeclaration_ICompressionRuntimeOptions(
    use: TypeOnly<old.ICompressionRuntimeOptions>): void;
use_old_InterfaceDeclaration_ICompressionRuntimeOptions(
    get_current_InterfaceDeclaration_ICompressionRuntimeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnectableRuntime": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConnectableRuntime():
    TypeOnly<old.IConnectableRuntime>;
declare function use_current_InterfaceDeclaration_IConnectableRuntime(
    use: TypeOnly<current.IConnectableRuntime>): void;
use_current_InterfaceDeclaration_IConnectableRuntime(
    get_old_InterfaceDeclaration_IConnectableRuntime());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnectableRuntime": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConnectableRuntime():
    TypeOnly<current.IConnectableRuntime>;
declare function use_old_InterfaceDeclaration_IConnectableRuntime(
    use: TypeOnly<old.IConnectableRuntime>): void;
use_old_InterfaceDeclaration_IConnectableRuntime(
    get_current_InterfaceDeclaration_IConnectableRuntime());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeMessageCompatDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails():
    TypeOnly<old.IContainerRuntimeMessageCompatDetails>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails(
    use: TypeOnly<current.IContainerRuntimeMessageCompatDetails>): void;
use_current_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails(
    get_old_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeMessageCompatDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails():
    TypeOnly<current.IContainerRuntimeMessageCompatDetails>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails(
    use: TypeOnly<old.IContainerRuntimeMessageCompatDetails>): void;
use_old_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails(
    get_current_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeMetadata": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerRuntimeMetadata():
    TypeOnly<old.IContainerRuntimeMetadata>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeMetadata(
    use: TypeOnly<current.IContainerRuntimeMetadata>): void;
use_current_InterfaceDeclaration_IContainerRuntimeMetadata(
    get_old_InterfaceDeclaration_IContainerRuntimeMetadata());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeMetadata": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerRuntimeMetadata():
    TypeOnly<current.IContainerRuntimeMetadata>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeMetadata(
    use: TypeOnly<old.IContainerRuntimeMetadata>): void;
use_old_InterfaceDeclaration_IContainerRuntimeMetadata(
    get_current_InterfaceDeclaration_IContainerRuntimeMetadata());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerRuntimeOptions():
    TypeOnly<old.IContainerRuntimeOptions>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeOptions(
    use: TypeOnly<current.IContainerRuntimeOptions>): void;
use_current_InterfaceDeclaration_IContainerRuntimeOptions(
    get_old_InterfaceDeclaration_IContainerRuntimeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerRuntimeOptions():
    TypeOnly<current.IContainerRuntimeOptions>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeOptions(
    use: TypeOnly<old.IContainerRuntimeOptions>): void;
use_old_InterfaceDeclaration_IContainerRuntimeOptions(
    get_current_InterfaceDeclaration_IContainerRuntimeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICreateContainerMetadata": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICreateContainerMetadata():
    TypeOnly<old.ICreateContainerMetadata>;
declare function use_current_InterfaceDeclaration_ICreateContainerMetadata(
    use: TypeOnly<current.ICreateContainerMetadata>): void;
use_current_InterfaceDeclaration_ICreateContainerMetadata(
    get_old_InterfaceDeclaration_ICreateContainerMetadata());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICreateContainerMetadata": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICreateContainerMetadata():
    TypeOnly<current.ICreateContainerMetadata>;
declare function use_old_InterfaceDeclaration_ICreateContainerMetadata(
    use: TypeOnly<old.ICreateContainerMetadata>): void;
use_old_InterfaceDeclaration_ICreateContainerMetadata(
    get_current_InterfaceDeclaration_ICreateContainerMetadata());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEnqueueSummarizeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IEnqueueSummarizeOptions():
    TypeOnly<old.IEnqueueSummarizeOptions>;
declare function use_current_InterfaceDeclaration_IEnqueueSummarizeOptions(
    use: TypeOnly<current.IEnqueueSummarizeOptions>): void;
use_current_InterfaceDeclaration_IEnqueueSummarizeOptions(
    get_old_InterfaceDeclaration_IEnqueueSummarizeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEnqueueSummarizeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IEnqueueSummarizeOptions():
    TypeOnly<current.IEnqueueSummarizeOptions>;
declare function use_old_InterfaceDeclaration_IEnqueueSummarizeOptions(
    use: TypeOnly<old.IEnqueueSummarizeOptions>): void;
use_old_InterfaceDeclaration_IEnqueueSummarizeOptions(
    get_current_InterfaceDeclaration_IEnqueueSummarizeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGCMetadata": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGCMetadata():
    TypeOnly<old.IGCMetadata>;
declare function use_current_InterfaceDeclaration_IGCMetadata(
    use: TypeOnly<current.IGCMetadata>): void;
use_current_InterfaceDeclaration_IGCMetadata(
    get_old_InterfaceDeclaration_IGCMetadata());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGCMetadata": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGCMetadata():
    TypeOnly<current.IGCMetadata>;
declare function use_old_InterfaceDeclaration_IGCMetadata(
    use: TypeOnly<old.IGCMetadata>): void;
use_old_InterfaceDeclaration_IGCMetadata(
    get_current_InterfaceDeclaration_IGCMetadata());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGCRuntimeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGCRuntimeOptions():
    TypeOnly<old.IGCRuntimeOptions>;
declare function use_current_InterfaceDeclaration_IGCRuntimeOptions(
    use: TypeOnly<current.IGCRuntimeOptions>): void;
use_current_InterfaceDeclaration_IGCRuntimeOptions(
    get_old_InterfaceDeclaration_IGCRuntimeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGCRuntimeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGCRuntimeOptions():
    TypeOnly<current.IGCRuntimeOptions>;
declare function use_old_InterfaceDeclaration_IGCRuntimeOptions(
    use: TypeOnly<old.IGCRuntimeOptions>): void;
use_old_InterfaceDeclaration_IGCRuntimeOptions(
    get_current_InterfaceDeclaration_IGCRuntimeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGCStats": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGCStats():
    TypeOnly<old.IGCStats>;
declare function use_current_InterfaceDeclaration_IGCStats(
    use: TypeOnly<current.IGCStats>): void;
use_current_InterfaceDeclaration_IGCStats(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IGCStats());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGCStats": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGCStats():
    TypeOnly<current.IGCStats>;
declare function use_old_InterfaceDeclaration_IGCStats(
    use: TypeOnly<old.IGCStats>): void;
use_old_InterfaceDeclaration_IGCStats(
    get_current_InterfaceDeclaration_IGCStats());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGenerateSummaryTreeResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGenerateSummaryTreeResult():
    TypeOnly<old.IGenerateSummaryTreeResult>;
declare function use_current_InterfaceDeclaration_IGenerateSummaryTreeResult(
    use: TypeOnly<current.IGenerateSummaryTreeResult>): void;
use_current_InterfaceDeclaration_IGenerateSummaryTreeResult(
    get_old_InterfaceDeclaration_IGenerateSummaryTreeResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGenerateSummaryTreeResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGenerateSummaryTreeResult():
    TypeOnly<current.IGenerateSummaryTreeResult>;
declare function use_old_InterfaceDeclaration_IGenerateSummaryTreeResult(
    use: TypeOnly<old.IGenerateSummaryTreeResult>): void;
use_old_InterfaceDeclaration_IGenerateSummaryTreeResult(
    get_current_InterfaceDeclaration_IGenerateSummaryTreeResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGeneratedSummaryStats": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGeneratedSummaryStats():
    TypeOnly<old.IGeneratedSummaryStats>;
declare function use_current_InterfaceDeclaration_IGeneratedSummaryStats(
    use: TypeOnly<current.IGeneratedSummaryStats>): void;
use_current_InterfaceDeclaration_IGeneratedSummaryStats(
    get_old_InterfaceDeclaration_IGeneratedSummaryStats());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGeneratedSummaryStats": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGeneratedSummaryStats():
    TypeOnly<current.IGeneratedSummaryStats>;
declare function use_old_InterfaceDeclaration_IGeneratedSummaryStats(
    use: TypeOnly<old.IGeneratedSummaryStats>): void;
use_old_InterfaceDeclaration_IGeneratedSummaryStats(
    get_current_InterfaceDeclaration_IGeneratedSummaryStats());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INackSummaryResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_INackSummaryResult():
    TypeOnly<old.INackSummaryResult>;
declare function use_current_InterfaceDeclaration_INackSummaryResult(
    use: TypeOnly<current.INackSummaryResult>): void;
use_current_InterfaceDeclaration_INackSummaryResult(
    get_old_InterfaceDeclaration_INackSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INackSummaryResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_INackSummaryResult():
    TypeOnly<current.INackSummaryResult>;
declare function use_old_InterfaceDeclaration_INackSummaryResult(
    use: TypeOnly<old.INackSummaryResult>): void;
use_old_InterfaceDeclaration_INackSummaryResult(
    get_current_InterfaceDeclaration_INackSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOnDemandSummarizeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOnDemandSummarizeOptions():
    TypeOnly<old.IOnDemandSummarizeOptions>;
declare function use_current_InterfaceDeclaration_IOnDemandSummarizeOptions(
    use: TypeOnly<current.IOnDemandSummarizeOptions>): void;
use_current_InterfaceDeclaration_IOnDemandSummarizeOptions(
    get_old_InterfaceDeclaration_IOnDemandSummarizeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOnDemandSummarizeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOnDemandSummarizeOptions():
    TypeOnly<current.IOnDemandSummarizeOptions>;
declare function use_old_InterfaceDeclaration_IOnDemandSummarizeOptions(
    use: TypeOnly<old.IOnDemandSummarizeOptions>): void;
use_old_InterfaceDeclaration_IOnDemandSummarizeOptions(
    get_current_InterfaceDeclaration_IOnDemandSummarizeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRefreshSummaryAckOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRefreshSummaryAckOptions():
    TypeOnly<old.IRefreshSummaryAckOptions>;
declare function use_current_InterfaceDeclaration_IRefreshSummaryAckOptions(
    use: TypeOnly<current.IRefreshSummaryAckOptions>): void;
use_current_InterfaceDeclaration_IRefreshSummaryAckOptions(
    get_old_InterfaceDeclaration_IRefreshSummaryAckOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRefreshSummaryAckOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRefreshSummaryAckOptions():
    TypeOnly<current.IRefreshSummaryAckOptions>;
declare function use_old_InterfaceDeclaration_IRefreshSummaryAckOptions(
    use: TypeOnly<old.IRefreshSummaryAckOptions>): void;
use_old_InterfaceDeclaration_IRefreshSummaryAckOptions(
    get_current_InterfaceDeclaration_IRefreshSummaryAckOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRetriableFailureResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRetriableFailureResult():
    TypeOnly<old.IRetriableFailureResult>;
declare function use_current_InterfaceDeclaration_IRetriableFailureResult(
    use: TypeOnly<current.IRetriableFailureResult>): void;
use_current_InterfaceDeclaration_IRetriableFailureResult(
    get_old_InterfaceDeclaration_IRetriableFailureResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRetriableFailureResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRetriableFailureResult():
    TypeOnly<current.IRetriableFailureResult>;
declare function use_old_InterfaceDeclaration_IRetriableFailureResult(
    use: TypeOnly<old.IRetriableFailureResult>): void;
use_old_InterfaceDeclaration_IRetriableFailureResult(
    get_current_InterfaceDeclaration_IRetriableFailureResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISerializedElection": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISerializedElection():
    TypeOnly<old.ISerializedElection>;
declare function use_current_InterfaceDeclaration_ISerializedElection(
    use: TypeOnly<current.ISerializedElection>): void;
use_current_InterfaceDeclaration_ISerializedElection(
    get_old_InterfaceDeclaration_ISerializedElection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISerializedElection": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISerializedElection():
    TypeOnly<current.ISerializedElection>;
declare function use_old_InterfaceDeclaration_ISerializedElection(
    use: TypeOnly<old.ISerializedElection>): void;
use_old_InterfaceDeclaration_ISerializedElection(
    get_current_InterfaceDeclaration_ISerializedElection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISubmitSummaryOpResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISubmitSummaryOpResult():
    TypeOnly<old.ISubmitSummaryOpResult>;
declare function use_current_InterfaceDeclaration_ISubmitSummaryOpResult(
    use: TypeOnly<current.ISubmitSummaryOpResult>): void;
use_current_InterfaceDeclaration_ISubmitSummaryOpResult(
    get_old_InterfaceDeclaration_ISubmitSummaryOpResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISubmitSummaryOpResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISubmitSummaryOpResult():
    TypeOnly<current.ISubmitSummaryOpResult>;
declare function use_old_InterfaceDeclaration_ISubmitSummaryOpResult(
    use: TypeOnly<old.ISubmitSummaryOpResult>): void;
use_old_InterfaceDeclaration_ISubmitSummaryOpResult(
    get_current_InterfaceDeclaration_ISubmitSummaryOpResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISubmitSummaryOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISubmitSummaryOptions():
    TypeOnly<old.ISubmitSummaryOptions>;
declare function use_current_InterfaceDeclaration_ISubmitSummaryOptions(
    use: TypeOnly<current.ISubmitSummaryOptions>): void;
use_current_InterfaceDeclaration_ISubmitSummaryOptions(
    get_old_InterfaceDeclaration_ISubmitSummaryOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISubmitSummaryOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISubmitSummaryOptions():
    TypeOnly<current.ISubmitSummaryOptions>;
declare function use_old_InterfaceDeclaration_ISubmitSummaryOptions(
    use: TypeOnly<old.ISubmitSummaryOptions>): void;
use_old_InterfaceDeclaration_ISubmitSummaryOptions(
    get_current_InterfaceDeclaration_ISubmitSummaryOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeEventProps": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizeEventProps():
    TypeOnly<old.ISummarizeEventProps>;
declare function use_current_InterfaceDeclaration_ISummarizeEventProps(
    use: TypeOnly<current.ISummarizeEventProps>): void;
use_current_InterfaceDeclaration_ISummarizeEventProps(
    get_old_InterfaceDeclaration_ISummarizeEventProps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeEventProps": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizeEventProps():
    TypeOnly<current.ISummarizeEventProps>;
declare function use_old_InterfaceDeclaration_ISummarizeEventProps(
    use: TypeOnly<old.ISummarizeEventProps>): void;
use_old_InterfaceDeclaration_ISummarizeEventProps(
    get_current_InterfaceDeclaration_ISummarizeEventProps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizeOptions():
    TypeOnly<old.ISummarizeOptions>;
declare function use_current_InterfaceDeclaration_ISummarizeOptions(
    use: TypeOnly<current.ISummarizeOptions>): void;
use_current_InterfaceDeclaration_ISummarizeOptions(
    get_old_InterfaceDeclaration_ISummarizeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizeOptions():
    TypeOnly<current.ISummarizeOptions>;
declare function use_old_InterfaceDeclaration_ISummarizeOptions(
    use: TypeOnly<old.ISummarizeOptions>): void;
use_old_InterfaceDeclaration_ISummarizeOptions(
    get_current_InterfaceDeclaration_ISummarizeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeResults": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizeResults():
    TypeOnly<old.ISummarizeResults>;
declare function use_current_InterfaceDeclaration_ISummarizeResults(
    use: TypeOnly<current.ISummarizeResults>): void;
use_current_InterfaceDeclaration_ISummarizeResults(
    get_old_InterfaceDeclaration_ISummarizeResults());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeResults": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizeResults():
    TypeOnly<current.ISummarizeResults>;
declare function use_old_InterfaceDeclaration_ISummarizeResults(
    use: TypeOnly<old.ISummarizeResults>): void;
use_old_InterfaceDeclaration_ISummarizeResults(
    get_current_InterfaceDeclaration_ISummarizeResults());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizer():
    TypeOnly<old.ISummarizer>;
declare function use_current_InterfaceDeclaration_ISummarizer(
    use: TypeOnly<current.ISummarizer>): void;
use_current_InterfaceDeclaration_ISummarizer(
    get_old_InterfaceDeclaration_ISummarizer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizer():
    TypeOnly<current.ISummarizer>;
declare function use_old_InterfaceDeclaration_ISummarizer(
    use: TypeOnly<old.ISummarizer>): void;
use_old_InterfaceDeclaration_ISummarizer(
    get_current_InterfaceDeclaration_ISummarizer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerEvents():
    TypeOnly<old.ISummarizerEvents>;
declare function use_current_InterfaceDeclaration_ISummarizerEvents(
    use: TypeOnly<current.ISummarizerEvents>): void;
use_current_InterfaceDeclaration_ISummarizerEvents(
    get_old_InterfaceDeclaration_ISummarizerEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerEvents():
    TypeOnly<current.ISummarizerEvents>;
declare function use_old_InterfaceDeclaration_ISummarizerEvents(
    use: TypeOnly<old.ISummarizerEvents>): void;
use_old_InterfaceDeclaration_ISummarizerEvents(
    get_current_InterfaceDeclaration_ISummarizerEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerInternalsProvider": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerInternalsProvider():
    TypeOnly<old.ISummarizerInternalsProvider>;
declare function use_current_InterfaceDeclaration_ISummarizerInternalsProvider(
    use: TypeOnly<current.ISummarizerInternalsProvider>): void;
use_current_InterfaceDeclaration_ISummarizerInternalsProvider(
    get_old_InterfaceDeclaration_ISummarizerInternalsProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerInternalsProvider": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerInternalsProvider():
    TypeOnly<current.ISummarizerInternalsProvider>;
declare function use_old_InterfaceDeclaration_ISummarizerInternalsProvider(
    use: TypeOnly<old.ISummarizerInternalsProvider>): void;
use_old_InterfaceDeclaration_ISummarizerInternalsProvider(
    get_current_InterfaceDeclaration_ISummarizerInternalsProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerRuntime": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerRuntime():
    TypeOnly<old.ISummarizerRuntime>;
declare function use_current_InterfaceDeclaration_ISummarizerRuntime(
    use: TypeOnly<current.ISummarizerRuntime>): void;
use_current_InterfaceDeclaration_ISummarizerRuntime(
    get_old_InterfaceDeclaration_ISummarizerRuntime());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerRuntime": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerRuntime():
    TypeOnly<current.ISummarizerRuntime>;
declare function use_old_InterfaceDeclaration_ISummarizerRuntime(
    use: TypeOnly<old.ISummarizerRuntime>): void;
use_old_InterfaceDeclaration_ISummarizerRuntime(
    get_current_InterfaceDeclaration_ISummarizerRuntime());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizingWarning": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizingWarning():
    TypeOnly<old.ISummarizingWarning>;
declare function use_current_InterfaceDeclaration_ISummarizingWarning(
    use: TypeOnly<current.ISummarizingWarning>): void;
use_current_InterfaceDeclaration_ISummarizingWarning(
    get_old_InterfaceDeclaration_ISummarizingWarning());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizingWarning": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizingWarning():
    TypeOnly<current.ISummarizingWarning>;
declare function use_old_InterfaceDeclaration_ISummarizingWarning(
    use: TypeOnly<old.ISummarizingWarning>): void;
use_old_InterfaceDeclaration_ISummarizingWarning(
    get_current_InterfaceDeclaration_ISummarizingWarning());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummary": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummary():
    TypeOnly<old.ISummary>;
declare function use_current_InterfaceDeclaration_ISummary(
    use: TypeOnly<current.ISummary>): void;
use_current_InterfaceDeclaration_ISummary(
    get_old_InterfaceDeclaration_ISummary());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummary": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummary():
    TypeOnly<current.ISummary>;
declare function use_old_InterfaceDeclaration_ISummary(
    use: TypeOnly<old.ISummary>): void;
use_old_InterfaceDeclaration_ISummary(
    get_current_InterfaceDeclaration_ISummary());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryAckMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryAckMessage():
    TypeOnly<old.ISummaryAckMessage>;
declare function use_current_InterfaceDeclaration_ISummaryAckMessage(
    use: TypeOnly<current.ISummaryAckMessage>): void;
use_current_InterfaceDeclaration_ISummaryAckMessage(
    get_old_InterfaceDeclaration_ISummaryAckMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryAckMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryAckMessage():
    TypeOnly<current.ISummaryAckMessage>;
declare function use_old_InterfaceDeclaration_ISummaryAckMessage(
    use: TypeOnly<old.ISummaryAckMessage>): void;
use_old_InterfaceDeclaration_ISummaryAckMessage(
    get_current_InterfaceDeclaration_ISummaryAckMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryBaseConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryBaseConfiguration():
    TypeOnly<old.ISummaryBaseConfiguration>;
declare function use_current_InterfaceDeclaration_ISummaryBaseConfiguration(
    use: TypeOnly<current.ISummaryBaseConfiguration>): void;
use_current_InterfaceDeclaration_ISummaryBaseConfiguration(
    get_old_InterfaceDeclaration_ISummaryBaseConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryBaseConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryBaseConfiguration():
    TypeOnly<current.ISummaryBaseConfiguration>;
declare function use_old_InterfaceDeclaration_ISummaryBaseConfiguration(
    use: TypeOnly<old.ISummaryBaseConfiguration>): void;
use_old_InterfaceDeclaration_ISummaryBaseConfiguration(
    get_current_InterfaceDeclaration_ISummaryBaseConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISummaryCancellationToken": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ISummaryCancellationToken():
    TypeOnly<old.ISummaryCancellationToken>;
declare function use_current_TypeAliasDeclaration_ISummaryCancellationToken(
    use: TypeOnly<current.ISummaryCancellationToken>): void;
use_current_TypeAliasDeclaration_ISummaryCancellationToken(
    get_old_TypeAliasDeclaration_ISummaryCancellationToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISummaryCancellationToken": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ISummaryCancellationToken():
    TypeOnly<current.ISummaryCancellationToken>;
declare function use_old_TypeAliasDeclaration_ISummaryCancellationToken(
    use: TypeOnly<old.ISummaryCancellationToken>): void;
use_old_TypeAliasDeclaration_ISummaryCancellationToken(
    get_current_TypeAliasDeclaration_ISummaryCancellationToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryCollectionOpEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryCollectionOpEvents():
    TypeOnly<old.ISummaryCollectionOpEvents>;
declare function use_current_InterfaceDeclaration_ISummaryCollectionOpEvents(
    use: TypeOnly<current.ISummaryCollectionOpEvents>): void;
use_current_InterfaceDeclaration_ISummaryCollectionOpEvents(
    get_old_InterfaceDeclaration_ISummaryCollectionOpEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryCollectionOpEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryCollectionOpEvents():
    TypeOnly<current.ISummaryCollectionOpEvents>;
declare function use_old_InterfaceDeclaration_ISummaryCollectionOpEvents(
    use: TypeOnly<old.ISummaryCollectionOpEvents>): void;
use_old_InterfaceDeclaration_ISummaryCollectionOpEvents(
    get_current_InterfaceDeclaration_ISummaryCollectionOpEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISummaryConfiguration": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ISummaryConfiguration():
    TypeOnly<old.ISummaryConfiguration>;
declare function use_current_TypeAliasDeclaration_ISummaryConfiguration(
    use: TypeOnly<current.ISummaryConfiguration>): void;
use_current_TypeAliasDeclaration_ISummaryConfiguration(
    get_old_TypeAliasDeclaration_ISummaryConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISummaryConfiguration": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ISummaryConfiguration():
    TypeOnly<current.ISummaryConfiguration>;
declare function use_old_TypeAliasDeclaration_ISummaryConfiguration(
    use: TypeOnly<old.ISummaryConfiguration>): void;
use_old_TypeAliasDeclaration_ISummaryConfiguration(
    get_current_TypeAliasDeclaration_ISummaryConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationDisableHeuristics": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics():
    TypeOnly<old.ISummaryConfigurationDisableHeuristics>;
declare function use_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    use: TypeOnly<current.ISummaryConfigurationDisableHeuristics>): void;
use_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    get_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationDisableHeuristics": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics():
    TypeOnly<current.ISummaryConfigurationDisableHeuristics>;
declare function use_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    use: TypeOnly<old.ISummaryConfigurationDisableHeuristics>): void;
use_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    get_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationDisableSummarizer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer():
    TypeOnly<old.ISummaryConfigurationDisableSummarizer>;
declare function use_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    use: TypeOnly<current.ISummaryConfigurationDisableSummarizer>): void;
use_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    get_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationDisableSummarizer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer():
    TypeOnly<current.ISummaryConfigurationDisableSummarizer>;
declare function use_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    use: TypeOnly<old.ISummaryConfigurationDisableSummarizer>): void;
use_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    get_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationHeuristics": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryConfigurationHeuristics():
    TypeOnly<old.ISummaryConfigurationHeuristics>;
declare function use_current_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    use: TypeOnly<current.ISummaryConfigurationHeuristics>): void;
use_current_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    get_old_InterfaceDeclaration_ISummaryConfigurationHeuristics());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryConfigurationHeuristics": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryConfigurationHeuristics():
    TypeOnly<current.ISummaryConfigurationHeuristics>;
declare function use_old_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    use: TypeOnly<old.ISummaryConfigurationHeuristics>): void;
use_old_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    get_current_InterfaceDeclaration_ISummaryConfigurationHeuristics());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISummaryMetadataMessage": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ISummaryMetadataMessage():
    TypeOnly<old.ISummaryMetadataMessage>;
declare function use_current_TypeAliasDeclaration_ISummaryMetadataMessage(
    use: TypeOnly<current.ISummaryMetadataMessage>): void;
use_current_TypeAliasDeclaration_ISummaryMetadataMessage(
    get_old_TypeAliasDeclaration_ISummaryMetadataMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ISummaryMetadataMessage": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ISummaryMetadataMessage():
    TypeOnly<current.ISummaryMetadataMessage>;
declare function use_old_TypeAliasDeclaration_ISummaryMetadataMessage(
    use: TypeOnly<old.ISummaryMetadataMessage>): void;
use_old_TypeAliasDeclaration_ISummaryMetadataMessage(
    get_current_TypeAliasDeclaration_ISummaryMetadataMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryNackMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryNackMessage():
    TypeOnly<old.ISummaryNackMessage>;
declare function use_current_InterfaceDeclaration_ISummaryNackMessage(
    use: TypeOnly<current.ISummaryNackMessage>): void;
use_current_InterfaceDeclaration_ISummaryNackMessage(
    get_old_InterfaceDeclaration_ISummaryNackMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryNackMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryNackMessage():
    TypeOnly<current.ISummaryNackMessage>;
declare function use_old_InterfaceDeclaration_ISummaryNackMessage(
    use: TypeOnly<old.ISummaryNackMessage>): void;
use_old_InterfaceDeclaration_ISummaryNackMessage(
    get_current_InterfaceDeclaration_ISummaryNackMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryOpMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryOpMessage():
    TypeOnly<old.ISummaryOpMessage>;
declare function use_current_InterfaceDeclaration_ISummaryOpMessage(
    use: TypeOnly<current.ISummaryOpMessage>): void;
use_current_InterfaceDeclaration_ISummaryOpMessage(
    get_old_InterfaceDeclaration_ISummaryOpMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryOpMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryOpMessage():
    TypeOnly<current.ISummaryOpMessage>;
declare function use_old_InterfaceDeclaration_ISummaryOpMessage(
    use: TypeOnly<old.ISummaryOpMessage>): void;
use_old_InterfaceDeclaration_ISummaryOpMessage(
    get_current_InterfaceDeclaration_ISummaryOpMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryRuntimeOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryRuntimeOptions():
    TypeOnly<old.ISummaryRuntimeOptions>;
declare function use_current_InterfaceDeclaration_ISummaryRuntimeOptions(
    use: TypeOnly<current.ISummaryRuntimeOptions>): void;
use_current_InterfaceDeclaration_ISummaryRuntimeOptions(
    get_old_InterfaceDeclaration_ISummaryRuntimeOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryRuntimeOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryRuntimeOptions():
    TypeOnly<current.ISummaryRuntimeOptions>;
declare function use_old_InterfaceDeclaration_ISummaryRuntimeOptions(
    use: TypeOnly<old.ISummaryRuntimeOptions>): void;
use_old_InterfaceDeclaration_ISummaryRuntimeOptions(
    get_current_InterfaceDeclaration_ISummaryRuntimeOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUploadSummaryResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IUploadSummaryResult():
    TypeOnly<old.IUploadSummaryResult>;
declare function use_current_InterfaceDeclaration_IUploadSummaryResult(
    use: TypeOnly<current.IUploadSummaryResult>): void;
use_current_InterfaceDeclaration_IUploadSummaryResult(
    get_old_InterfaceDeclaration_IUploadSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUploadSummaryResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IUploadSummaryResult():
    TypeOnly<current.IUploadSummaryResult>;
declare function use_old_InterfaceDeclaration_IUploadSummaryResult(
    use: TypeOnly<old.IUploadSummaryResult>): void;
use_old_InterfaceDeclaration_IUploadSummaryResult(
    get_current_InterfaceDeclaration_IUploadSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_InactiveResponseHeaderKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_InactiveResponseHeaderKey():
    TypeOnly<typeof old.InactiveResponseHeaderKey>;
declare function use_current_VariableDeclaration_InactiveResponseHeaderKey(
    use: TypeOnly<typeof current.InactiveResponseHeaderKey>): void;
use_current_VariableDeclaration_InactiveResponseHeaderKey(
    get_old_VariableDeclaration_InactiveResponseHeaderKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_InactiveResponseHeaderKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_InactiveResponseHeaderKey():
    TypeOnly<typeof current.InactiveResponseHeaderKey>;
declare function use_old_VariableDeclaration_InactiveResponseHeaderKey(
    use: TypeOnly<typeof old.InactiveResponseHeaderKey>): void;
use_old_VariableDeclaration_InactiveResponseHeaderKey(
    get_current_VariableDeclaration_InactiveResponseHeaderKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OpActionEventListener": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_OpActionEventListener():
    TypeOnly<old.OpActionEventListener>;
declare function use_current_TypeAliasDeclaration_OpActionEventListener(
    use: TypeOnly<current.OpActionEventListener>): void;
use_current_TypeAliasDeclaration_OpActionEventListener(
    get_old_TypeAliasDeclaration_OpActionEventListener());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OpActionEventListener": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_OpActionEventListener():
    TypeOnly<current.OpActionEventListener>;
declare function use_old_TypeAliasDeclaration_OpActionEventListener(
    use: TypeOnly<old.OpActionEventListener>): void;
use_old_TypeAliasDeclaration_OpActionEventListener(
    get_current_TypeAliasDeclaration_OpActionEventListener());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OpActionEventName": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_OpActionEventName():
    TypeOnly<old.OpActionEventName>;
declare function use_current_TypeAliasDeclaration_OpActionEventName(
    use: TypeOnly<current.OpActionEventName>): void;
use_current_TypeAliasDeclaration_OpActionEventName(
    get_old_TypeAliasDeclaration_OpActionEventName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_OpActionEventName": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_OpActionEventName():
    TypeOnly<current.OpActionEventName>;
declare function use_old_TypeAliasDeclaration_OpActionEventName(
    use: TypeOnly<old.OpActionEventName>): void;
use_old_TypeAliasDeclaration_OpActionEventName(
    get_current_TypeAliasDeclaration_OpActionEventName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails():
    TypeOnly<old.RecentlyAddedContainerRuntimeMessageDetails>;
declare function use_current_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails(
    use: TypeOnly<current.RecentlyAddedContainerRuntimeMessageDetails>): void;
use_current_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails(
    get_old_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails():
    TypeOnly<current.RecentlyAddedContainerRuntimeMessageDetails>;
declare function use_old_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails(
    use: TypeOnly<old.RecentlyAddedContainerRuntimeMessageDetails>): void;
use_old_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails(
    get_current_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RuntimeHeaders": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_RuntimeHeaders():
    TypeOnly<old.RuntimeHeaders>;
declare function use_current_EnumDeclaration_RuntimeHeaders(
    use: TypeOnly<current.RuntimeHeaders>): void;
use_current_EnumDeclaration_RuntimeHeaders(
    get_old_EnumDeclaration_RuntimeHeaders());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RuntimeHeaders": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_RuntimeHeaders():
    TypeOnly<current.RuntimeHeaders>;
declare function use_old_EnumDeclaration_RuntimeHeaders(
    use: TypeOnly<old.RuntimeHeaders>): void;
use_old_EnumDeclaration_RuntimeHeaders(
    get_current_EnumDeclaration_RuntimeHeaders());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RuntimeMessage": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_RuntimeMessage():
    TypeOnly<old.RuntimeMessage>;
declare function use_current_EnumDeclaration_RuntimeMessage(
    use: TypeOnly<current.RuntimeMessage>): void;
use_current_EnumDeclaration_RuntimeMessage(
    get_old_EnumDeclaration_RuntimeMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RuntimeMessage": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_RuntimeMessage():
    TypeOnly<current.RuntimeMessage>;
declare function use_old_EnumDeclaration_RuntimeMessage(
    use: TypeOnly<old.RuntimeMessage>): void;
use_old_EnumDeclaration_RuntimeMessage(
    get_current_EnumDeclaration_RuntimeMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SubmitSummaryFailureData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_SubmitSummaryFailureData():
    TypeOnly<old.SubmitSummaryFailureData>;
declare function use_current_InterfaceDeclaration_SubmitSummaryFailureData(
    use: TypeOnly<current.SubmitSummaryFailureData>): void;
use_current_InterfaceDeclaration_SubmitSummaryFailureData(
    get_old_InterfaceDeclaration_SubmitSummaryFailureData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SubmitSummaryFailureData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_SubmitSummaryFailureData():
    TypeOnly<current.SubmitSummaryFailureData>;
declare function use_old_InterfaceDeclaration_SubmitSummaryFailureData(
    use: TypeOnly<old.SubmitSummaryFailureData>): void;
use_old_InterfaceDeclaration_SubmitSummaryFailureData(
    get_current_InterfaceDeclaration_SubmitSummaryFailureData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SubmitSummaryResult": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SubmitSummaryResult():
    TypeOnly<old.SubmitSummaryResult>;
declare function use_current_TypeAliasDeclaration_SubmitSummaryResult(
    use: TypeOnly<current.SubmitSummaryResult>): void;
use_current_TypeAliasDeclaration_SubmitSummaryResult(
    get_old_TypeAliasDeclaration_SubmitSummaryResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SubmitSummaryResult": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SubmitSummaryResult():
    TypeOnly<current.SubmitSummaryResult>;
declare function use_old_TypeAliasDeclaration_SubmitSummaryResult(
    use: TypeOnly<old.SubmitSummaryResult>): void;
use_old_TypeAliasDeclaration_SubmitSummaryResult(
    get_current_TypeAliasDeclaration_SubmitSummaryResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizeResultPart": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummarizeResultPart():
    TypeOnly<old.SummarizeResultPart<any,any>>;
declare function use_current_TypeAliasDeclaration_SummarizeResultPart(
    use: TypeOnly<current.SummarizeResultPart<any,any>>): void;
use_current_TypeAliasDeclaration_SummarizeResultPart(
    get_old_TypeAliasDeclaration_SummarizeResultPart());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizeResultPart": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummarizeResultPart():
    TypeOnly<current.SummarizeResultPart<any,any>>;
declare function use_old_TypeAliasDeclaration_SummarizeResultPart(
    use: TypeOnly<old.SummarizeResultPart<any,any>>): void;
use_old_TypeAliasDeclaration_SummarizeResultPart(
    get_current_TypeAliasDeclaration_SummarizeResultPart());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Summarizer": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Summarizer():
    TypeOnly<old.Summarizer>;
declare function use_current_ClassDeclaration_Summarizer(
    use: TypeOnly<current.Summarizer>): void;
use_current_ClassDeclaration_Summarizer(
    get_old_ClassDeclaration_Summarizer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Summarizer": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Summarizer():
    TypeOnly<current.Summarizer>;
declare function use_old_ClassDeclaration_Summarizer(
    use: TypeOnly<old.Summarizer>): void;
use_old_ClassDeclaration_Summarizer(
    get_current_ClassDeclaration_Summarizer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizerStopReason": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummarizerStopReason():
    TypeOnly<old.SummarizerStopReason>;
declare function use_current_TypeAliasDeclaration_SummarizerStopReason(
    use: TypeOnly<current.SummarizerStopReason>): void;
use_current_TypeAliasDeclaration_SummarizerStopReason(
    get_old_TypeAliasDeclaration_SummarizerStopReason());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizerStopReason": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummarizerStopReason():
    TypeOnly<current.SummarizerStopReason>;
declare function use_old_TypeAliasDeclaration_SummarizerStopReason(
    use: TypeOnly<old.SummarizerStopReason>): void;
use_old_TypeAliasDeclaration_SummarizerStopReason(
    get_current_TypeAliasDeclaration_SummarizerStopReason());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryCollection": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SummaryCollection():
    TypeOnly<old.SummaryCollection>;
declare function use_current_ClassDeclaration_SummaryCollection(
    use: TypeOnly<current.SummaryCollection>): void;
use_current_ClassDeclaration_SummaryCollection(
    get_old_ClassDeclaration_SummaryCollection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryCollection": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SummaryCollection():
    TypeOnly<current.SummaryCollection>;
declare function use_old_ClassDeclaration_SummaryCollection(
    use: TypeOnly<old.SummaryCollection>): void;
use_old_ClassDeclaration_SummaryCollection(
    get_current_ClassDeclaration_SummaryCollection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryStage": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummaryStage():
    TypeOnly<old.SummaryStage>;
declare function use_current_TypeAliasDeclaration_SummaryStage(
    use: TypeOnly<current.SummaryStage>): void;
use_current_TypeAliasDeclaration_SummaryStage(
    get_old_TypeAliasDeclaration_SummaryStage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummaryStage": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummaryStage():
    TypeOnly<current.SummaryStage>;
declare function use_old_TypeAliasDeclaration_SummaryStage(
    use: TypeOnly<old.SummaryStage>): void;
use_old_TypeAliasDeclaration_SummaryStage(
    get_current_TypeAliasDeclaration_SummaryStage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_TEST_requestSummarizer": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_TEST_requestSummarizer": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TombstoneResponseHeaderKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_TombstoneResponseHeaderKey():
    TypeOnly<typeof old.TombstoneResponseHeaderKey>;
declare function use_current_VariableDeclaration_TombstoneResponseHeaderKey(
    use: TypeOnly<typeof current.TombstoneResponseHeaderKey>): void;
use_current_VariableDeclaration_TombstoneResponseHeaderKey(
    get_old_VariableDeclaration_TombstoneResponseHeaderKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TombstoneResponseHeaderKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_TombstoneResponseHeaderKey():
    TypeOnly<typeof current.TombstoneResponseHeaderKey>;
declare function use_old_VariableDeclaration_TombstoneResponseHeaderKey(
    use: TypeOnly<typeof old.TombstoneResponseHeaderKey>): void;
use_old_VariableDeclaration_TombstoneResponseHeaderKey(
    get_current_VariableDeclaration_TombstoneResponseHeaderKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_agentSchedulerId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_agentSchedulerId():
    TypeOnly<typeof old.agentSchedulerId>;
declare function use_current_VariableDeclaration_agentSchedulerId(
    use: TypeOnly<typeof current.agentSchedulerId>): void;
use_current_VariableDeclaration_agentSchedulerId(
    get_old_VariableDeclaration_agentSchedulerId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_agentSchedulerId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_agentSchedulerId():
    TypeOnly<typeof current.agentSchedulerId>;
declare function use_old_VariableDeclaration_agentSchedulerId(
    use: TypeOnly<typeof old.agentSchedulerId>): void;
use_old_VariableDeclaration_agentSchedulerId(
    get_current_VariableDeclaration_agentSchedulerId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_assertIsStableId": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_assertIsStableId():
    TypeOnly<typeof old.assertIsStableId>;
declare function use_current_FunctionDeclaration_assertIsStableId(
    use: TypeOnly<typeof current.assertIsStableId>): void;
use_current_FunctionDeclaration_assertIsStableId(
    get_old_FunctionDeclaration_assertIsStableId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_assertIsStableId": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_assertIsStableId():
    TypeOnly<typeof current.assertIsStableId>;
declare function use_old_FunctionDeclaration_assertIsStableId(
    use: TypeOnly<typeof old.assertIsStableId>): void;
use_old_FunctionDeclaration_assertIsStableId(
    get_current_FunctionDeclaration_assertIsStableId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateStableId": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_generateStableId():
    TypeOnly<typeof old.generateStableId>;
declare function use_current_FunctionDeclaration_generateStableId(
    use: TypeOnly<typeof current.generateStableId>): void;
use_current_FunctionDeclaration_generateStableId(
    get_old_FunctionDeclaration_generateStableId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateStableId": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_generateStableId():
    TypeOnly<typeof current.generateStableId>;
declare function use_old_FunctionDeclaration_generateStableId(
    use: TypeOnly<typeof old.generateStableId>): void;
use_old_FunctionDeclaration_generateStableId(
    get_current_FunctionDeclaration_generateStableId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isRuntimeMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isRuntimeMessage():
    TypeOnly<typeof old.isRuntimeMessage>;
declare function use_current_FunctionDeclaration_isRuntimeMessage(
    use: TypeOnly<typeof current.isRuntimeMessage>): void;
use_current_FunctionDeclaration_isRuntimeMessage(
    get_old_FunctionDeclaration_isRuntimeMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isRuntimeMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isRuntimeMessage():
    TypeOnly<typeof current.isRuntimeMessage>;
declare function use_old_FunctionDeclaration_isRuntimeMessage(
    use: TypeOnly<typeof old.isRuntimeMessage>): void;
use_old_FunctionDeclaration_isRuntimeMessage(
    get_current_FunctionDeclaration_isRuntimeMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isStableId": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isStableId():
    TypeOnly<typeof old.isStableId>;
declare function use_current_FunctionDeclaration_isStableId(
    use: TypeOnly<typeof current.isStableId>): void;
use_current_FunctionDeclaration_isStableId(
    get_old_FunctionDeclaration_isStableId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isStableId": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isStableId():
    TypeOnly<typeof current.isStableId>;
declare function use_old_FunctionDeclaration_isStableId(
    use: TypeOnly<typeof old.isStableId>): void;
use_old_FunctionDeclaration_isStableId(
    get_current_FunctionDeclaration_isStableId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_neverCancelledSummaryToken": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_neverCancelledSummaryToken():
    TypeOnly<typeof old.neverCancelledSummaryToken>;
declare function use_current_VariableDeclaration_neverCancelledSummaryToken(
    use: TypeOnly<typeof current.neverCancelledSummaryToken>): void;
use_current_VariableDeclaration_neverCancelledSummaryToken(
    get_old_VariableDeclaration_neverCancelledSummaryToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_neverCancelledSummaryToken": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_neverCancelledSummaryToken():
    TypeOnly<typeof current.neverCancelledSummaryToken>;
declare function use_old_VariableDeclaration_neverCancelledSummaryToken(
    use: TypeOnly<typeof old.neverCancelledSummaryToken>): void;
use_old_VariableDeclaration_neverCancelledSummaryToken(
    get_current_VariableDeclaration_neverCancelledSummaryToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_unpackRuntimeMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_unpackRuntimeMessage():
    TypeOnly<typeof old.unpackRuntimeMessage>;
declare function use_current_FunctionDeclaration_unpackRuntimeMessage(
    use: TypeOnly<typeof current.unpackRuntimeMessage>): void;
use_current_FunctionDeclaration_unpackRuntimeMessage(
    get_old_FunctionDeclaration_unpackRuntimeMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_unpackRuntimeMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_unpackRuntimeMessage():
    TypeOnly<typeof current.unpackRuntimeMessage>;
declare function use_old_FunctionDeclaration_unpackRuntimeMessage(
    use: TypeOnly<typeof old.unpackRuntimeMessage>): void;
use_old_FunctionDeclaration_unpackRuntimeMessage(
    get_current_FunctionDeclaration_unpackRuntimeMessage());
