/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/container-runtime-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_AllowInactiveRequestHeaderKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_AllowInactiveRequestHeaderKey():
    TypeOnly<typeof old.AllowInactiveRequestHeaderKey>;
declare function use_current_VariableDeclaration_AllowInactiveRequestHeaderKey(
    use: TypeOnly<typeof current.AllowInactiveRequestHeaderKey>): void;
use_current_VariableDeclaration_AllowInactiveRequestHeaderKey(
    get_old_VariableDeclaration_AllowInactiveRequestHeaderKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_AllowInactiveRequestHeaderKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_AllowInactiveRequestHeaderKey():
    TypeOnly<typeof current.AllowInactiveRequestHeaderKey>;
declare function use_old_VariableDeclaration_AllowInactiveRequestHeaderKey(
    use: TypeOnly<typeof old.AllowInactiveRequestHeaderKey>): void;
use_old_VariableDeclaration_AllowInactiveRequestHeaderKey(
    get_current_VariableDeclaration_AllowInactiveRequestHeaderKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_AllowTombstoneRequestHeaderKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_AllowTombstoneRequestHeaderKey():
    TypeOnly<typeof old.AllowTombstoneRequestHeaderKey>;
declare function use_current_VariableDeclaration_AllowTombstoneRequestHeaderKey(
    use: TypeOnly<typeof current.AllowTombstoneRequestHeaderKey>): void;
use_current_VariableDeclaration_AllowTombstoneRequestHeaderKey(
    get_old_VariableDeclaration_AllowTombstoneRequestHeaderKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_AllowTombstoneRequestHeaderKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_AllowTombstoneRequestHeaderKey():
    TypeOnly<typeof current.AllowTombstoneRequestHeaderKey>;
declare function use_old_VariableDeclaration_AllowTombstoneRequestHeaderKey(
    use: TypeOnly<typeof old.AllowTombstoneRequestHeaderKey>): void;
use_old_VariableDeclaration_AllowTombstoneRequestHeaderKey(
    get_current_VariableDeclaration_AllowTombstoneRequestHeaderKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ChannelCollection": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_ChannelCollection():
    TypeOnly<old.ChannelCollection>;
declare function use_current_ClassDeclaration_ChannelCollection(
    use: TypeOnly<current.ChannelCollection>): void;
use_current_ClassDeclaration_ChannelCollection(
    get_old_ClassDeclaration_ChannelCollection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ChannelCollection": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_ChannelCollection():
    TypeOnly<current.ChannelCollection>;
declare function use_old_ClassDeclaration_ChannelCollection(
    use: TypeOnly<old.ChannelCollection>): void;
use_old_ClassDeclaration_ChannelCollection(
    get_current_ClassDeclaration_ChannelCollection());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ChannelCollectionFactory": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_ChannelCollectionFactory():
    TypeOnly<old.ChannelCollectionFactory>;
declare function use_current_ClassDeclaration_ChannelCollectionFactory(
    use: TypeOnly<current.ChannelCollectionFactory>): void;
use_current_ClassDeclaration_ChannelCollectionFactory(
    get_old_ClassDeclaration_ChannelCollectionFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ChannelCollectionFactory": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_ChannelCollectionFactory():
    TypeOnly<current.ChannelCollectionFactory>;
declare function use_old_ClassDeclaration_ChannelCollectionFactory(
    use: TypeOnly<old.ChannelCollectionFactory>): void;
use_old_ClassDeclaration_ChannelCollectionFactory(
    get_current_ClassDeclaration_ChannelCollectionFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_CompatModeBehavior": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_CompatModeBehavior():
    TypeOnly<old.CompatModeBehavior>;
declare function use_current_TypeAliasDeclaration_CompatModeBehavior(
    use: TypeOnly<current.CompatModeBehavior>): void;
use_current_TypeAliasDeclaration_CompatModeBehavior(
    get_old_TypeAliasDeclaration_CompatModeBehavior());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_CompatModeBehavior": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_CompatModeBehavior():
    TypeOnly<current.CompatModeBehavior>;
declare function use_old_TypeAliasDeclaration_CompatModeBehavior(
    use: TypeOnly<old.CompatModeBehavior>): void;
use_old_TypeAliasDeclaration_CompatModeBehavior(
    get_current_TypeAliasDeclaration_CompatModeBehavior());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_CompressionAlgorithms": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_CompressionAlgorithms():
    TypeOnly<old.CompressionAlgorithms>;
declare function use_current_EnumDeclaration_CompressionAlgorithms(
    use: TypeOnly<current.CompressionAlgorithms>): void;
use_current_EnumDeclaration_CompressionAlgorithms(
    get_old_EnumDeclaration_CompressionAlgorithms());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_CompressionAlgorithms": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_CompressionAlgorithms():
    TypeOnly<current.CompressionAlgorithms>;
declare function use_old_EnumDeclaration_CompressionAlgorithms(
    use: TypeOnly<old.CompressionAlgorithms>): void;
use_old_EnumDeclaration_CompressionAlgorithms(
    get_current_EnumDeclaration_CompressionAlgorithms());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_ContainerMessageType": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_ContainerMessageType():
    TypeOnly<old.ContainerMessageType>;
declare function use_current_EnumDeclaration_ContainerMessageType(
    use: TypeOnly<current.ContainerMessageType>): void;
use_current_EnumDeclaration_ContainerMessageType(
    get_old_EnumDeclaration_ContainerMessageType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_ContainerMessageType": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_ContainerMessageType():
    TypeOnly<current.ContainerMessageType>;
declare function use_old_EnumDeclaration_ContainerMessageType(
    use: TypeOnly<old.ContainerMessageType>): void;
use_old_EnumDeclaration_ContainerMessageType(
    get_current_EnumDeclaration_ContainerMessageType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ContainerRuntime": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_ContainerRuntime():
    TypeOnly<old.ContainerRuntime>;
declare function use_current_ClassDeclaration_ContainerRuntime(
    use: TypeOnly<current.ContainerRuntime>): void;
use_current_ClassDeclaration_ContainerRuntime(
    get_old_ClassDeclaration_ContainerRuntime());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ContainerRuntime": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_ContainerRuntime():
    TypeOnly<current.ContainerRuntime>;
declare function use_old_ClassDeclaration_ContainerRuntime(
    use: TypeOnly<old.ContainerRuntime>): void;
use_old_ClassDeclaration_ContainerRuntime(
    get_current_ClassDeclaration_ContainerRuntime());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DataStoreContexts": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_DataStoreContexts():
    TypeOnly<old.DataStoreContexts>;
declare function use_current_ClassDeclaration_DataStoreContexts(
    use: TypeOnly<current.DataStoreContexts>): void;
use_current_ClassDeclaration_DataStoreContexts(
    get_old_ClassDeclaration_DataStoreContexts());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DataStoreContexts": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_DataStoreContexts():
    TypeOnly<current.DataStoreContexts>;
declare function use_old_ClassDeclaration_DataStoreContexts(
    use: TypeOnly<old.DataStoreContexts>): void;
use_old_ClassDeclaration_DataStoreContexts(
    get_current_ClassDeclaration_DataStoreContexts());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_DefaultSummaryConfiguration": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_DefaultSummaryConfiguration():
    TypeOnly<typeof old.DefaultSummaryConfiguration>;
declare function use_current_VariableDeclaration_DefaultSummaryConfiguration(
    use: TypeOnly<typeof current.DefaultSummaryConfiguration>): void;
use_current_VariableDeclaration_DefaultSummaryConfiguration(
    get_old_VariableDeclaration_DefaultSummaryConfiguration());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_DefaultSummaryConfiguration": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_DefaultSummaryConfiguration():
    TypeOnly<typeof current.DefaultSummaryConfiguration>;
declare function use_old_VariableDeclaration_DefaultSummaryConfiguration(
    use: TypeOnly<typeof old.DefaultSummaryConfiguration>): void;
use_old_VariableDeclaration_DefaultSummaryConfiguration(
    get_current_VariableDeclaration_DefaultSummaryConfiguration());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_DeletedResponseHeaderKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_DeletedResponseHeaderKey():
    TypeOnly<typeof old.DeletedResponseHeaderKey>;
declare function use_current_VariableDeclaration_DeletedResponseHeaderKey(
    use: TypeOnly<typeof current.DeletedResponseHeaderKey>): void;
use_current_VariableDeclaration_DeletedResponseHeaderKey(
    get_old_VariableDeclaration_DeletedResponseHeaderKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_DeletedResponseHeaderKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_DeletedResponseHeaderKey():
    TypeOnly<typeof current.DeletedResponseHeaderKey>;
declare function use_old_VariableDeclaration_DeletedResponseHeaderKey(
    use: TypeOnly<typeof old.DeletedResponseHeaderKey>): void;
use_old_VariableDeclaration_DeletedResponseHeaderKey(
    get_current_VariableDeclaration_DeletedResponseHeaderKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_DocumentSchemaValueType": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_DocumentSchemaValueType():
    TypeOnly<old.DocumentSchemaValueType>;
declare function use_current_TypeAliasDeclaration_DocumentSchemaValueType(
    use: TypeOnly<current.DocumentSchemaValueType>): void;
use_current_TypeAliasDeclaration_DocumentSchemaValueType(
    get_old_TypeAliasDeclaration_DocumentSchemaValueType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_DocumentSchemaValueType": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_DocumentSchemaValueType():
    TypeOnly<current.DocumentSchemaValueType>;
declare function use_old_TypeAliasDeclaration_DocumentSchemaValueType(
    use: TypeOnly<old.DocumentSchemaValueType>): void;
use_old_TypeAliasDeclaration_DocumentSchemaValueType(
    get_current_TypeAliasDeclaration_DocumentSchemaValueType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DocumentsSchemaController": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_DocumentsSchemaController():
    TypeOnly<old.DocumentsSchemaController>;
declare function use_current_ClassDeclaration_DocumentsSchemaController(
    use: TypeOnly<current.DocumentsSchemaController>): void;
use_current_ClassDeclaration_DocumentsSchemaController(
    get_old_ClassDeclaration_DocumentsSchemaController());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DocumentsSchemaController": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_DocumentsSchemaController():
    TypeOnly<current.DocumentsSchemaController>;
declare function use_old_ClassDeclaration_DocumentsSchemaController(
    use: TypeOnly<old.DocumentsSchemaController>): void;
use_old_ClassDeclaration_DocumentsSchemaController(
    get_current_ClassDeclaration_DocumentsSchemaController());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_EnqueueSummarizeResult": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_EnqueueSummarizeResult():
    TypeOnly<old.EnqueueSummarizeResult>;
declare function use_current_TypeAliasDeclaration_EnqueueSummarizeResult(
    use: TypeOnly<current.EnqueueSummarizeResult>): void;
use_current_TypeAliasDeclaration_EnqueueSummarizeResult(
    get_old_TypeAliasDeclaration_EnqueueSummarizeResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_EnqueueSummarizeResult": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_EnqueueSummarizeResult():
    TypeOnly<current.EnqueueSummarizeResult>;
declare function use_old_TypeAliasDeclaration_EnqueueSummarizeResult(
    use: TypeOnly<old.EnqueueSummarizeResult>): void;
use_old_TypeAliasDeclaration_EnqueueSummarizeResult(
    get_current_TypeAliasDeclaration_EnqueueSummarizeResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_FluidDataStoreContext": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_FluidDataStoreContext():
    TypeOnly<old.FluidDataStoreContext>;
declare function use_current_ClassDeclaration_FluidDataStoreContext(
    use: TypeOnly<current.FluidDataStoreContext>): void;
use_current_ClassDeclaration_FluidDataStoreContext(
    get_old_ClassDeclaration_FluidDataStoreContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_FluidDataStoreContext": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_FluidDataStoreContext():
    TypeOnly<current.FluidDataStoreContext>;
declare function use_old_ClassDeclaration_FluidDataStoreContext(
    use: TypeOnly<old.FluidDataStoreContext>): void;
use_old_ClassDeclaration_FluidDataStoreContext(
    get_current_ClassDeclaration_FluidDataStoreContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_FluidDataStoreRegistry": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_FluidDataStoreRegistry():
    TypeOnly<old.FluidDataStoreRegistry>;
declare function use_current_ClassDeclaration_FluidDataStoreRegistry(
    use: TypeOnly<current.FluidDataStoreRegistry>): void;
use_current_ClassDeclaration_FluidDataStoreRegistry(
    get_old_ClassDeclaration_FluidDataStoreRegistry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_FluidDataStoreRegistry": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_FluidDataStoreRegistry():
    TypeOnly<current.FluidDataStoreRegistry>;
declare function use_old_ClassDeclaration_FluidDataStoreRegistry(
    use: TypeOnly<old.FluidDataStoreRegistry>): void;
use_old_ClassDeclaration_FluidDataStoreRegistry(
    get_current_ClassDeclaration_FluidDataStoreRegistry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_GCFeatureMatrix": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_GCFeatureMatrix():
    TypeOnly<old.GCFeatureMatrix>;
declare function use_current_TypeAliasDeclaration_GCFeatureMatrix(
    use: TypeOnly<current.GCFeatureMatrix>): void;
use_current_TypeAliasDeclaration_GCFeatureMatrix(
    get_old_TypeAliasDeclaration_GCFeatureMatrix());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_GCFeatureMatrix": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_GCFeatureMatrix():
    TypeOnly<current.GCFeatureMatrix>;
declare function use_old_TypeAliasDeclaration_GCFeatureMatrix(
    use: TypeOnly<old.GCFeatureMatrix>): void;
use_old_TypeAliasDeclaration_GCFeatureMatrix(
    get_current_TypeAliasDeclaration_GCFeatureMatrix());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_GCNodeType": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_GCNodeType():
    TypeOnly<typeof old.GCNodeType>;
declare function use_current_VariableDeclaration_GCNodeType(
    use: TypeOnly<typeof current.GCNodeType>): void;
use_current_VariableDeclaration_GCNodeType(
    get_old_VariableDeclaration_GCNodeType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_GCNodeType": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_GCNodeType():
    TypeOnly<typeof current.GCNodeType>;
declare function use_old_VariableDeclaration_GCNodeType(
    use: TypeOnly<typeof old.GCNodeType>): void;
use_old_VariableDeclaration_GCNodeType(
    get_current_VariableDeclaration_GCNodeType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_GCNodeType": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_GCNodeType():
    TypeOnly<old.GCNodeType>;
declare function use_current_TypeAliasDeclaration_GCNodeType(
    use: TypeOnly<current.GCNodeType>): void;
use_current_TypeAliasDeclaration_GCNodeType(
    get_old_TypeAliasDeclaration_GCNodeType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_GCNodeType": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_GCNodeType():
    TypeOnly<current.GCNodeType>;
declare function use_old_TypeAliasDeclaration_GCNodeType(
    use: TypeOnly<old.GCNodeType>): void;
use_old_TypeAliasDeclaration_GCNodeType(
    get_current_TypeAliasDeclaration_GCNodeType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_GCVersion": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_GCVersion():
    TypeOnly<old.GCVersion>;
declare function use_current_TypeAliasDeclaration_GCVersion(
    use: TypeOnly<current.GCVersion>): void;
use_current_TypeAliasDeclaration_GCVersion(
    get_old_TypeAliasDeclaration_GCVersion());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_GCVersion": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_GCVersion():
    TypeOnly<current.GCVersion>;
declare function use_old_TypeAliasDeclaration_GCVersion(
    use: TypeOnly<old.GCVersion>): void;
use_old_TypeAliasDeclaration_GCVersion(
    get_current_TypeAliasDeclaration_GCVersion());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAckSummaryResult": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IAckSummaryResult():
    TypeOnly<old.IAckSummaryResult>;
declare function use_current_InterfaceDeclaration_IAckSummaryResult(
    use: TypeOnly<current.IAckSummaryResult>): void;
use_current_InterfaceDeclaration_IAckSummaryResult(
    get_old_InterfaceDeclaration_IAckSummaryResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAckSummaryResult": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IAckSummaryResult():
    TypeOnly<current.IAckSummaryResult>;
declare function use_old_InterfaceDeclaration_IAckSummaryResult(
    use: TypeOnly<old.IAckSummaryResult>): void;
use_old_InterfaceDeclaration_IAckSummaryResult(
    get_current_InterfaceDeclaration_IAckSummaryResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAckedSummary": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IAckedSummary():
    TypeOnly<old.IAckedSummary>;
declare function use_current_InterfaceDeclaration_IAckedSummary(
    use: TypeOnly<current.IAckedSummary>): void;
use_current_InterfaceDeclaration_IAckedSummary(
    get_old_InterfaceDeclaration_IAckedSummary());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAckedSummary": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IAckedSummary():
    TypeOnly<current.IAckedSummary>;
declare function use_old_InterfaceDeclaration_IAckedSummary(
    use: TypeOnly<old.IAckedSummary>): void;
use_old_InterfaceDeclaration_IAckedSummary(
    get_current_InterfaceDeclaration_IAckedSummary());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IBaseSummarizeResult": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IBaseSummarizeResult():
    TypeOnly<old.IBaseSummarizeResult>;
declare function use_current_InterfaceDeclaration_IBaseSummarizeResult(
    use: TypeOnly<current.IBaseSummarizeResult>): void;
use_current_InterfaceDeclaration_IBaseSummarizeResult(
    get_old_InterfaceDeclaration_IBaseSummarizeResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IBaseSummarizeResult": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IBaseSummarizeResult():
    TypeOnly<current.IBaseSummarizeResult>;
declare function use_old_InterfaceDeclaration_IBaseSummarizeResult(
    use: TypeOnly<old.IBaseSummarizeResult>): void;
use_old_InterfaceDeclaration_IBaseSummarizeResult(
    get_current_InterfaceDeclaration_IBaseSummarizeResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IBlobManagerLoadInfo": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IBlobManagerLoadInfo():
    TypeOnly<old.IBlobManagerLoadInfo>;
declare function use_current_InterfaceDeclaration_IBlobManagerLoadInfo(
    use: TypeOnly<current.IBlobManagerLoadInfo>): void;
use_current_InterfaceDeclaration_IBlobManagerLoadInfo(
    get_old_InterfaceDeclaration_IBlobManagerLoadInfo());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IBlobManagerLoadInfo": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IBlobManagerLoadInfo():
    TypeOnly<current.IBlobManagerLoadInfo>;
declare function use_old_InterfaceDeclaration_IBlobManagerLoadInfo(
    use: TypeOnly<old.IBlobManagerLoadInfo>): void;
use_old_InterfaceDeclaration_IBlobManagerLoadInfo(
    get_current_InterfaceDeclaration_IBlobManagerLoadInfo());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IBroadcastSummaryResult": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IBroadcastSummaryResult():
    TypeOnly<old.IBroadcastSummaryResult>;
declare function use_current_InterfaceDeclaration_IBroadcastSummaryResult(
    use: TypeOnly<current.IBroadcastSummaryResult>): void;
use_current_InterfaceDeclaration_IBroadcastSummaryResult(
    get_old_InterfaceDeclaration_IBroadcastSummaryResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IBroadcastSummaryResult": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IBroadcastSummaryResult():
    TypeOnly<current.IBroadcastSummaryResult>;
declare function use_old_InterfaceDeclaration_IBroadcastSummaryResult(
    use: TypeOnly<old.IBroadcastSummaryResult>): void;
use_old_InterfaceDeclaration_IBroadcastSummaryResult(
    get_current_InterfaceDeclaration_IBroadcastSummaryResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICancellableSummarizerController": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ICancellableSummarizerController():
    TypeOnly<old.ICancellableSummarizerController>;
declare function use_current_InterfaceDeclaration_ICancellableSummarizerController(
    use: TypeOnly<current.ICancellableSummarizerController>): void;
use_current_InterfaceDeclaration_ICancellableSummarizerController(
    get_old_InterfaceDeclaration_ICancellableSummarizerController());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICancellableSummarizerController": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ICancellableSummarizerController():
    TypeOnly<current.ICancellableSummarizerController>;
declare function use_old_InterfaceDeclaration_ICancellableSummarizerController(
    use: TypeOnly<old.ICancellableSummarizerController>): void;
use_old_InterfaceDeclaration_ICancellableSummarizerController(
    get_current_InterfaceDeclaration_ICancellableSummarizerController());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICancellationToken": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ICancellationToken():
    TypeOnly<old.ICancellationToken<any>>;
declare function use_current_InterfaceDeclaration_ICancellationToken(
    use: TypeOnly<current.ICancellationToken<any>>): void;
use_current_InterfaceDeclaration_ICancellationToken(
    get_old_InterfaceDeclaration_ICancellationToken());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICancellationToken": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ICancellationToken():
    TypeOnly<current.ICancellationToken<any>>;
declare function use_old_InterfaceDeclaration_ICancellationToken(
    use: TypeOnly<old.ICancellationToken<any>>): void;
use_old_InterfaceDeclaration_ICancellationToken(
    get_current_InterfaceDeclaration_ICancellationToken());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IChunkedOp": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IChunkedOp():
    TypeOnly<old.IChunkedOp>;
declare function use_current_InterfaceDeclaration_IChunkedOp(
    use: TypeOnly<current.IChunkedOp>): void;
use_current_InterfaceDeclaration_IChunkedOp(
    get_old_InterfaceDeclaration_IChunkedOp());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IChunkedOp": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IChunkedOp():
    TypeOnly<current.IChunkedOp>;
declare function use_old_InterfaceDeclaration_IChunkedOp(
    use: TypeOnly<old.IChunkedOp>): void;
use_old_InterfaceDeclaration_IChunkedOp(
    get_current_InterfaceDeclaration_IChunkedOp());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IClientSummaryWatcher": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IClientSummaryWatcher():
    TypeOnly<old.IClientSummaryWatcher>;
declare function use_current_InterfaceDeclaration_IClientSummaryWatcher(
    use: TypeOnly<current.IClientSummaryWatcher>): void;
use_current_InterfaceDeclaration_IClientSummaryWatcher(
    get_old_InterfaceDeclaration_IClientSummaryWatcher());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IClientSummaryWatcher": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IClientSummaryWatcher():
    TypeOnly<current.IClientSummaryWatcher>;
declare function use_old_InterfaceDeclaration_IClientSummaryWatcher(
    use: TypeOnly<old.IClientSummaryWatcher>): void;
use_old_InterfaceDeclaration_IClientSummaryWatcher(
    get_current_InterfaceDeclaration_IClientSummaryWatcher());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICompressionRuntimeOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ICompressionRuntimeOptions():
    TypeOnly<old.ICompressionRuntimeOptions>;
declare function use_current_InterfaceDeclaration_ICompressionRuntimeOptions(
    use: TypeOnly<current.ICompressionRuntimeOptions>): void;
use_current_InterfaceDeclaration_ICompressionRuntimeOptions(
    get_old_InterfaceDeclaration_ICompressionRuntimeOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICompressionRuntimeOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ICompressionRuntimeOptions():
    TypeOnly<current.ICompressionRuntimeOptions>;
declare function use_old_InterfaceDeclaration_ICompressionRuntimeOptions(
    use: TypeOnly<old.ICompressionRuntimeOptions>): void;
use_old_InterfaceDeclaration_ICompressionRuntimeOptions(
    get_current_InterfaceDeclaration_ICompressionRuntimeOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConnectableRuntime": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IConnectableRuntime():
    TypeOnly<old.IConnectableRuntime>;
declare function use_current_InterfaceDeclaration_IConnectableRuntime(
    use: TypeOnly<current.IConnectableRuntime>): void;
use_current_InterfaceDeclaration_IConnectableRuntime(
    get_old_InterfaceDeclaration_IConnectableRuntime());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConnectableRuntime": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IConnectableRuntime():
    TypeOnly<current.IConnectableRuntime>;
declare function use_old_InterfaceDeclaration_IConnectableRuntime(
    use: TypeOnly<old.IConnectableRuntime>): void;
use_old_InterfaceDeclaration_IConnectableRuntime(
    get_current_InterfaceDeclaration_IConnectableRuntime());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerRuntimeMessageCompatDetails": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails():
    TypeOnly<old.IContainerRuntimeMessageCompatDetails>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails(
    use: TypeOnly<current.IContainerRuntimeMessageCompatDetails>): void;
use_current_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails(
    get_old_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerRuntimeMessageCompatDetails": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails():
    TypeOnly<current.IContainerRuntimeMessageCompatDetails>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails(
    use: TypeOnly<old.IContainerRuntimeMessageCompatDetails>): void;
use_old_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails(
    get_current_InterfaceDeclaration_IContainerRuntimeMessageCompatDetails());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerRuntimeMetadata": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IContainerRuntimeMetadata():
    TypeOnly<old.IContainerRuntimeMetadata>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeMetadata(
    use: TypeOnly<current.IContainerRuntimeMetadata>): void;
use_current_InterfaceDeclaration_IContainerRuntimeMetadata(
    get_old_InterfaceDeclaration_IContainerRuntimeMetadata());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerRuntimeMetadata": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IContainerRuntimeMetadata():
    TypeOnly<current.IContainerRuntimeMetadata>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeMetadata(
    use: TypeOnly<old.IContainerRuntimeMetadata>): void;
use_old_InterfaceDeclaration_IContainerRuntimeMetadata(
    get_current_InterfaceDeclaration_IContainerRuntimeMetadata());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerRuntimeOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IContainerRuntimeOptions():
    TypeOnly<old.IContainerRuntimeOptions>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeOptions(
    use: TypeOnly<current.IContainerRuntimeOptions>): void;
use_current_InterfaceDeclaration_IContainerRuntimeOptions(
    get_old_InterfaceDeclaration_IContainerRuntimeOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerRuntimeOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IContainerRuntimeOptions():
    TypeOnly<current.IContainerRuntimeOptions>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeOptions(
    use: TypeOnly<old.IContainerRuntimeOptions>): void;
use_old_InterfaceDeclaration_IContainerRuntimeOptions(
    get_current_InterfaceDeclaration_IContainerRuntimeOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICreateContainerMetadata": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ICreateContainerMetadata():
    TypeOnly<old.ICreateContainerMetadata>;
declare function use_current_InterfaceDeclaration_ICreateContainerMetadata(
    use: TypeOnly<current.ICreateContainerMetadata>): void;
use_current_InterfaceDeclaration_ICreateContainerMetadata(
    get_old_InterfaceDeclaration_ICreateContainerMetadata());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICreateContainerMetadata": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ICreateContainerMetadata():
    TypeOnly<current.ICreateContainerMetadata>;
declare function use_old_InterfaceDeclaration_ICreateContainerMetadata(
    use: TypeOnly<old.ICreateContainerMetadata>): void;
use_old_InterfaceDeclaration_ICreateContainerMetadata(
    get_current_InterfaceDeclaration_ICreateContainerMetadata());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentSchema": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentSchema():
    TypeOnly<old.IDocumentSchema>;
declare function use_current_InterfaceDeclaration_IDocumentSchema(
    use: TypeOnly<current.IDocumentSchema>): void;
use_current_InterfaceDeclaration_IDocumentSchema(
    get_old_InterfaceDeclaration_IDocumentSchema());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentSchema": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentSchema():
    TypeOnly<current.IDocumentSchema>;
declare function use_old_InterfaceDeclaration_IDocumentSchema(
    use: TypeOnly<old.IDocumentSchema>): void;
use_old_InterfaceDeclaration_IDocumentSchema(
    get_current_InterfaceDeclaration_IDocumentSchema());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IDocumentSchemaChangeMessage": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IDocumentSchemaChangeMessage():
    TypeOnly<old.IDocumentSchemaChangeMessage>;
declare function use_current_TypeAliasDeclaration_IDocumentSchemaChangeMessage(
    use: TypeOnly<current.IDocumentSchemaChangeMessage>): void;
use_current_TypeAliasDeclaration_IDocumentSchemaChangeMessage(
    get_old_TypeAliasDeclaration_IDocumentSchemaChangeMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IDocumentSchemaChangeMessage": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IDocumentSchemaChangeMessage():
    TypeOnly<current.IDocumentSchemaChangeMessage>;
declare function use_old_TypeAliasDeclaration_IDocumentSchemaChangeMessage(
    use: TypeOnly<old.IDocumentSchemaChangeMessage>): void;
use_old_TypeAliasDeclaration_IDocumentSchemaChangeMessage(
    get_current_TypeAliasDeclaration_IDocumentSchemaChangeMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IDocumentSchemaCurrent": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IDocumentSchemaCurrent():
    TypeOnly<old.IDocumentSchemaCurrent>;
declare function use_current_TypeAliasDeclaration_IDocumentSchemaCurrent(
    use: TypeOnly<current.IDocumentSchemaCurrent>): void;
use_current_TypeAliasDeclaration_IDocumentSchemaCurrent(
    get_old_TypeAliasDeclaration_IDocumentSchemaCurrent());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IDocumentSchemaCurrent": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IDocumentSchemaCurrent():
    TypeOnly<current.IDocumentSchemaCurrent>;
declare function use_old_TypeAliasDeclaration_IDocumentSchemaCurrent(
    use: TypeOnly<old.IDocumentSchemaCurrent>): void;
use_old_TypeAliasDeclaration_IDocumentSchemaCurrent(
    get_current_TypeAliasDeclaration_IDocumentSchemaCurrent());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentSchemaFeatures": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentSchemaFeatures():
    TypeOnly<old.IDocumentSchemaFeatures>;
declare function use_current_InterfaceDeclaration_IDocumentSchemaFeatures(
    use: TypeOnly<current.IDocumentSchemaFeatures>): void;
use_current_InterfaceDeclaration_IDocumentSchemaFeatures(
    get_old_InterfaceDeclaration_IDocumentSchemaFeatures());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentSchemaFeatures": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentSchemaFeatures():
    TypeOnly<current.IDocumentSchemaFeatures>;
declare function use_old_InterfaceDeclaration_IDocumentSchemaFeatures(
    use: TypeOnly<old.IDocumentSchemaFeatures>): void;
use_old_InterfaceDeclaration_IDocumentSchemaFeatures(
    get_current_InterfaceDeclaration_IDocumentSchemaFeatures());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEnqueueSummarizeOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IEnqueueSummarizeOptions():
    TypeOnly<old.IEnqueueSummarizeOptions>;
declare function use_current_InterfaceDeclaration_IEnqueueSummarizeOptions(
    use: TypeOnly<current.IEnqueueSummarizeOptions>): void;
use_current_InterfaceDeclaration_IEnqueueSummarizeOptions(
    get_old_InterfaceDeclaration_IEnqueueSummarizeOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEnqueueSummarizeOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IEnqueueSummarizeOptions():
    TypeOnly<current.IEnqueueSummarizeOptions>;
declare function use_old_InterfaceDeclaration_IEnqueueSummarizeOptions(
    use: TypeOnly<old.IEnqueueSummarizeOptions>): void;
use_old_InterfaceDeclaration_IEnqueueSummarizeOptions(
    get_current_InterfaceDeclaration_IEnqueueSummarizeOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreAttributes0": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidDataStoreAttributes0():
    TypeOnly<old.IFluidDataStoreAttributes0>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreAttributes0(
    use: TypeOnly<current.IFluidDataStoreAttributes0>): void;
use_current_InterfaceDeclaration_IFluidDataStoreAttributes0(
    get_old_InterfaceDeclaration_IFluidDataStoreAttributes0());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreAttributes0": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidDataStoreAttributes0():
    TypeOnly<current.IFluidDataStoreAttributes0>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreAttributes0(
    use: TypeOnly<old.IFluidDataStoreAttributes0>): void;
use_old_InterfaceDeclaration_IFluidDataStoreAttributes0(
    get_current_InterfaceDeclaration_IFluidDataStoreAttributes0());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreAttributes1": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidDataStoreAttributes1():
    TypeOnly<old.IFluidDataStoreAttributes1>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreAttributes1(
    use: TypeOnly<current.IFluidDataStoreAttributes1>): void;
use_current_InterfaceDeclaration_IFluidDataStoreAttributes1(
    get_old_InterfaceDeclaration_IFluidDataStoreAttributes1());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreAttributes1": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidDataStoreAttributes1():
    TypeOnly<current.IFluidDataStoreAttributes1>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreAttributes1(
    use: TypeOnly<old.IFluidDataStoreAttributes1>): void;
use_old_InterfaceDeclaration_IFluidDataStoreAttributes1(
    get_current_InterfaceDeclaration_IFluidDataStoreAttributes1());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreAttributes2": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidDataStoreAttributes2():
    TypeOnly<old.IFluidDataStoreAttributes2>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreAttributes2(
    use: TypeOnly<current.IFluidDataStoreAttributes2>): void;
use_current_InterfaceDeclaration_IFluidDataStoreAttributes2(
    get_old_InterfaceDeclaration_IFluidDataStoreAttributes2());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreAttributes2": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidDataStoreAttributes2():
    TypeOnly<current.IFluidDataStoreAttributes2>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreAttributes2(
    use: TypeOnly<old.IFluidDataStoreAttributes2>): void;
use_old_InterfaceDeclaration_IFluidDataStoreAttributes2(
    get_current_InterfaceDeclaration_IFluidDataStoreAttributes2());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreContextEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidDataStoreContextEvents():
    TypeOnly<old.IFluidDataStoreContextEvents>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreContextEvents(
    use: TypeOnly<current.IFluidDataStoreContextEvents>): void;
use_current_InterfaceDeclaration_IFluidDataStoreContextEvents(
    get_old_InterfaceDeclaration_IFluidDataStoreContextEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreContextEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidDataStoreContextEvents():
    TypeOnly<current.IFluidDataStoreContextEvents>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreContextEvents(
    use: TypeOnly<old.IFluidDataStoreContextEvents>): void;
use_old_InterfaceDeclaration_IFluidDataStoreContextEvents(
    get_current_InterfaceDeclaration_IFluidDataStoreContextEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreContextInternal": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidDataStoreContextInternal():
    TypeOnly<old.IFluidDataStoreContextInternal>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreContextInternal(
    use: TypeOnly<current.IFluidDataStoreContextInternal>): void;
use_current_InterfaceDeclaration_IFluidDataStoreContextInternal(
    get_old_InterfaceDeclaration_IFluidDataStoreContextInternal());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreContextInternal": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidDataStoreContextInternal():
    TypeOnly<current.IFluidDataStoreContextInternal>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreContextInternal(
    use: TypeOnly<old.IFluidDataStoreContextInternal>): void;
use_old_InterfaceDeclaration_IFluidDataStoreContextInternal(
    get_current_InterfaceDeclaration_IFluidDataStoreContextInternal());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreContextProps": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidDataStoreContextProps():
    TypeOnly<old.IFluidDataStoreContextProps>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreContextProps(
    use: TypeOnly<current.IFluidDataStoreContextProps>): void;
use_current_InterfaceDeclaration_IFluidDataStoreContextProps(
    get_old_InterfaceDeclaration_IFluidDataStoreContextProps());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreContextProps": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidDataStoreContextProps():
    TypeOnly<current.IFluidDataStoreContextProps>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreContextProps(
    use: TypeOnly<old.IFluidDataStoreContextProps>): void;
use_old_InterfaceDeclaration_IFluidDataStoreContextProps(
    get_current_InterfaceDeclaration_IFluidDataStoreContextProps());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGCMetadata": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IGCMetadata():
    TypeOnly<old.IGCMetadata>;
declare function use_current_InterfaceDeclaration_IGCMetadata(
    use: TypeOnly<current.IGCMetadata>): void;
use_current_InterfaceDeclaration_IGCMetadata(
    get_old_InterfaceDeclaration_IGCMetadata());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGCMetadata": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IGCMetadata():
    TypeOnly<current.IGCMetadata>;
declare function use_old_InterfaceDeclaration_IGCMetadata(
    use: TypeOnly<old.IGCMetadata>): void;
use_old_InterfaceDeclaration_IGCMetadata(
    get_current_InterfaceDeclaration_IGCMetadata());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGCNodeUpdatedProps": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IGCNodeUpdatedProps():
    TypeOnly<old.IGCNodeUpdatedProps>;
declare function use_current_InterfaceDeclaration_IGCNodeUpdatedProps(
    use: TypeOnly<current.IGCNodeUpdatedProps>): void;
use_current_InterfaceDeclaration_IGCNodeUpdatedProps(
    get_old_InterfaceDeclaration_IGCNodeUpdatedProps());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGCNodeUpdatedProps": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IGCNodeUpdatedProps():
    TypeOnly<current.IGCNodeUpdatedProps>;
declare function use_old_InterfaceDeclaration_IGCNodeUpdatedProps(
    use: TypeOnly<old.IGCNodeUpdatedProps>): void;
use_old_InterfaceDeclaration_IGCNodeUpdatedProps(
    get_current_InterfaceDeclaration_IGCNodeUpdatedProps());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGCRuntimeOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IGCRuntimeOptions():
    TypeOnly<old.IGCRuntimeOptions>;
declare function use_current_InterfaceDeclaration_IGCRuntimeOptions(
    use: TypeOnly<current.IGCRuntimeOptions>): void;
use_current_InterfaceDeclaration_IGCRuntimeOptions(
    get_old_InterfaceDeclaration_IGCRuntimeOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGCRuntimeOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IGCRuntimeOptions():
    TypeOnly<current.IGCRuntimeOptions>;
declare function use_old_InterfaceDeclaration_IGCRuntimeOptions(
    use: TypeOnly<old.IGCRuntimeOptions>): void;
use_old_InterfaceDeclaration_IGCRuntimeOptions(
    get_current_InterfaceDeclaration_IGCRuntimeOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGCStats": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IGCStats():
    TypeOnly<old.IGCStats>;
declare function use_current_InterfaceDeclaration_IGCStats(
    use: TypeOnly<current.IGCStats>): void;
use_current_InterfaceDeclaration_IGCStats(
    get_old_InterfaceDeclaration_IGCStats());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGCStats": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IGCStats():
    TypeOnly<current.IGCStats>;
declare function use_old_InterfaceDeclaration_IGCStats(
    use: TypeOnly<old.IGCStats>): void;
use_old_InterfaceDeclaration_IGCStats(
    get_current_InterfaceDeclaration_IGCStats());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGenerateSummaryTreeResult": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IGenerateSummaryTreeResult():
    TypeOnly<old.IGenerateSummaryTreeResult>;
declare function use_current_InterfaceDeclaration_IGenerateSummaryTreeResult(
    use: TypeOnly<current.IGenerateSummaryTreeResult>): void;
use_current_InterfaceDeclaration_IGenerateSummaryTreeResult(
    get_old_InterfaceDeclaration_IGenerateSummaryTreeResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGenerateSummaryTreeResult": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IGenerateSummaryTreeResult():
    TypeOnly<current.IGenerateSummaryTreeResult>;
declare function use_old_InterfaceDeclaration_IGenerateSummaryTreeResult(
    use: TypeOnly<old.IGenerateSummaryTreeResult>): void;
use_old_InterfaceDeclaration_IGenerateSummaryTreeResult(
    get_current_InterfaceDeclaration_IGenerateSummaryTreeResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGeneratedSummaryStats": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IGeneratedSummaryStats():
    TypeOnly<old.IGeneratedSummaryStats>;
declare function use_current_InterfaceDeclaration_IGeneratedSummaryStats(
    use: TypeOnly<current.IGeneratedSummaryStats>): void;
use_current_InterfaceDeclaration_IGeneratedSummaryStats(
    get_old_InterfaceDeclaration_IGeneratedSummaryStats());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGeneratedSummaryStats": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IGeneratedSummaryStats():
    TypeOnly<current.IGeneratedSummaryStats>;
declare function use_old_InterfaceDeclaration_IGeneratedSummaryStats(
    use: TypeOnly<old.IGeneratedSummaryStats>): void;
use_old_InterfaceDeclaration_IGeneratedSummaryStats(
    get_current_InterfaceDeclaration_IGeneratedSummaryStats());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ILocalDetachedFluidDataStoreContextProps": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ILocalDetachedFluidDataStoreContextProps():
    TypeOnly<old.ILocalDetachedFluidDataStoreContextProps>;
declare function use_current_InterfaceDeclaration_ILocalDetachedFluidDataStoreContextProps(
    use: TypeOnly<current.ILocalDetachedFluidDataStoreContextProps>): void;
use_current_InterfaceDeclaration_ILocalDetachedFluidDataStoreContextProps(
    get_old_InterfaceDeclaration_ILocalDetachedFluidDataStoreContextProps());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ILocalDetachedFluidDataStoreContextProps": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ILocalDetachedFluidDataStoreContextProps():
    TypeOnly<current.ILocalDetachedFluidDataStoreContextProps>;
declare function use_old_InterfaceDeclaration_ILocalDetachedFluidDataStoreContextProps(
    use: TypeOnly<old.ILocalDetachedFluidDataStoreContextProps>): void;
use_old_InterfaceDeclaration_ILocalDetachedFluidDataStoreContextProps(
    get_current_InterfaceDeclaration_ILocalDetachedFluidDataStoreContextProps());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ILocalFluidDataStoreContextProps": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ILocalFluidDataStoreContextProps():
    TypeOnly<old.ILocalFluidDataStoreContextProps>;
declare function use_current_InterfaceDeclaration_ILocalFluidDataStoreContextProps(
    use: TypeOnly<current.ILocalFluidDataStoreContextProps>): void;
use_current_InterfaceDeclaration_ILocalFluidDataStoreContextProps(
    get_old_InterfaceDeclaration_ILocalFluidDataStoreContextProps());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ILocalFluidDataStoreContextProps": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ILocalFluidDataStoreContextProps():
    TypeOnly<current.ILocalFluidDataStoreContextProps>;
declare function use_old_InterfaceDeclaration_ILocalFluidDataStoreContextProps(
    use: TypeOnly<old.ILocalFluidDataStoreContextProps>): void;
use_old_InterfaceDeclaration_ILocalFluidDataStoreContextProps(
    get_current_InterfaceDeclaration_ILocalFluidDataStoreContextProps());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMarkPhaseStats": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMarkPhaseStats():
    TypeOnly<old.IMarkPhaseStats>;
declare function use_current_InterfaceDeclaration_IMarkPhaseStats(
    use: TypeOnly<current.IMarkPhaseStats>): void;
use_current_InterfaceDeclaration_IMarkPhaseStats(
    get_old_InterfaceDeclaration_IMarkPhaseStats());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMarkPhaseStats": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMarkPhaseStats():
    TypeOnly<current.IMarkPhaseStats>;
declare function use_old_InterfaceDeclaration_IMarkPhaseStats(
    use: TypeOnly<old.IMarkPhaseStats>): void;
use_old_InterfaceDeclaration_IMarkPhaseStats(
    get_current_InterfaceDeclaration_IMarkPhaseStats());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_INackSummaryResult": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_INackSummaryResult():
    TypeOnly<old.INackSummaryResult>;
declare function use_current_InterfaceDeclaration_INackSummaryResult(
    use: TypeOnly<current.INackSummaryResult>): void;
use_current_InterfaceDeclaration_INackSummaryResult(
    get_old_InterfaceDeclaration_INackSummaryResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_INackSummaryResult": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_INackSummaryResult():
    TypeOnly<current.INackSummaryResult>;
declare function use_old_InterfaceDeclaration_INackSummaryResult(
    use: TypeOnly<old.INackSummaryResult>): void;
use_old_InterfaceDeclaration_INackSummaryResult(
    get_current_InterfaceDeclaration_INackSummaryResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOnDemandSummarizeOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IOnDemandSummarizeOptions():
    TypeOnly<old.IOnDemandSummarizeOptions>;
declare function use_current_InterfaceDeclaration_IOnDemandSummarizeOptions(
    use: TypeOnly<current.IOnDemandSummarizeOptions>): void;
use_current_InterfaceDeclaration_IOnDemandSummarizeOptions(
    get_old_InterfaceDeclaration_IOnDemandSummarizeOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOnDemandSummarizeOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IOnDemandSummarizeOptions():
    TypeOnly<current.IOnDemandSummarizeOptions>;
declare function use_old_InterfaceDeclaration_IOnDemandSummarizeOptions(
    use: TypeOnly<old.IOnDemandSummarizeOptions>): void;
use_old_InterfaceDeclaration_IOnDemandSummarizeOptions(
    get_current_InterfaceDeclaration_IOnDemandSummarizeOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRefreshSummaryAckOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IRefreshSummaryAckOptions():
    TypeOnly<old.IRefreshSummaryAckOptions>;
declare function use_current_InterfaceDeclaration_IRefreshSummaryAckOptions(
    use: TypeOnly<current.IRefreshSummaryAckOptions>): void;
use_current_InterfaceDeclaration_IRefreshSummaryAckOptions(
    get_old_InterfaceDeclaration_IRefreshSummaryAckOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRefreshSummaryAckOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IRefreshSummaryAckOptions():
    TypeOnly<current.IRefreshSummaryAckOptions>;
declare function use_old_InterfaceDeclaration_IRefreshSummaryAckOptions(
    use: TypeOnly<old.IRefreshSummaryAckOptions>): void;
use_old_InterfaceDeclaration_IRefreshSummaryAckOptions(
    get_current_InterfaceDeclaration_IRefreshSummaryAckOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRetriableFailureError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IRetriableFailureError():
    TypeOnly<old.IRetriableFailureError>;
declare function use_current_InterfaceDeclaration_IRetriableFailureError(
    use: TypeOnly<current.IRetriableFailureError>): void;
use_current_InterfaceDeclaration_IRetriableFailureError(
    get_old_InterfaceDeclaration_IRetriableFailureError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRetriableFailureError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IRetriableFailureError():
    TypeOnly<current.IRetriableFailureError>;
declare function use_old_InterfaceDeclaration_IRetriableFailureError(
    use: TypeOnly<old.IRetriableFailureError>): void;
use_old_InterfaceDeclaration_IRetriableFailureError(
    get_current_InterfaceDeclaration_IRetriableFailureError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISerializedElection": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISerializedElection():
    TypeOnly<old.ISerializedElection>;
declare function use_current_InterfaceDeclaration_ISerializedElection(
    use: TypeOnly<current.ISerializedElection>): void;
use_current_InterfaceDeclaration_ISerializedElection(
    get_old_InterfaceDeclaration_ISerializedElection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISerializedElection": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISerializedElection():
    TypeOnly<current.ISerializedElection>;
declare function use_old_InterfaceDeclaration_ISerializedElection(
    use: TypeOnly<old.ISerializedElection>): void;
use_old_InterfaceDeclaration_ISerializedElection(
    get_current_InterfaceDeclaration_ISerializedElection());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISnapshotDetails": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISnapshotDetails():
    TypeOnly<old.ISnapshotDetails>;
declare function use_current_InterfaceDeclaration_ISnapshotDetails(
    use: TypeOnly<current.ISnapshotDetails>): void;
use_current_InterfaceDeclaration_ISnapshotDetails(
    get_old_InterfaceDeclaration_ISnapshotDetails());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISnapshotDetails": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISnapshotDetails():
    TypeOnly<current.ISnapshotDetails>;
declare function use_old_InterfaceDeclaration_ISnapshotDetails(
    use: TypeOnly<old.ISnapshotDetails>): void;
use_old_InterfaceDeclaration_ISnapshotDetails(
    get_current_InterfaceDeclaration_ISnapshotDetails());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISubmitSummaryOpResult": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISubmitSummaryOpResult():
    TypeOnly<old.ISubmitSummaryOpResult>;
declare function use_current_InterfaceDeclaration_ISubmitSummaryOpResult(
    use: TypeOnly<current.ISubmitSummaryOpResult>): void;
use_current_InterfaceDeclaration_ISubmitSummaryOpResult(
    get_old_InterfaceDeclaration_ISubmitSummaryOpResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISubmitSummaryOpResult": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISubmitSummaryOpResult():
    TypeOnly<current.ISubmitSummaryOpResult>;
declare function use_old_InterfaceDeclaration_ISubmitSummaryOpResult(
    use: TypeOnly<old.ISubmitSummaryOpResult>): void;
use_old_InterfaceDeclaration_ISubmitSummaryOpResult(
    get_current_InterfaceDeclaration_ISubmitSummaryOpResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISubmitSummaryOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISubmitSummaryOptions():
    TypeOnly<old.ISubmitSummaryOptions>;
declare function use_current_InterfaceDeclaration_ISubmitSummaryOptions(
    use: TypeOnly<current.ISubmitSummaryOptions>): void;
use_current_InterfaceDeclaration_ISubmitSummaryOptions(
    get_old_InterfaceDeclaration_ISubmitSummaryOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISubmitSummaryOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISubmitSummaryOptions():
    TypeOnly<current.ISubmitSummaryOptions>;
declare function use_old_InterfaceDeclaration_ISubmitSummaryOptions(
    use: TypeOnly<old.ISubmitSummaryOptions>): void;
use_old_InterfaceDeclaration_ISubmitSummaryOptions(
    get_current_InterfaceDeclaration_ISubmitSummaryOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizeEventProps": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummarizeEventProps():
    TypeOnly<old.ISummarizeEventProps>;
declare function use_current_InterfaceDeclaration_ISummarizeEventProps(
    use: TypeOnly<current.ISummarizeEventProps>): void;
use_current_InterfaceDeclaration_ISummarizeEventProps(
    get_old_InterfaceDeclaration_ISummarizeEventProps());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizeEventProps": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummarizeEventProps():
    TypeOnly<current.ISummarizeEventProps>;
declare function use_old_InterfaceDeclaration_ISummarizeEventProps(
    use: TypeOnly<old.ISummarizeEventProps>): void;
use_old_InterfaceDeclaration_ISummarizeEventProps(
    get_current_InterfaceDeclaration_ISummarizeEventProps());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizeOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummarizeOptions():
    TypeOnly<old.ISummarizeOptions>;
declare function use_current_InterfaceDeclaration_ISummarizeOptions(
    use: TypeOnly<current.ISummarizeOptions>): void;
use_current_InterfaceDeclaration_ISummarizeOptions(
    get_old_InterfaceDeclaration_ISummarizeOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizeOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummarizeOptions():
    TypeOnly<current.ISummarizeOptions>;
declare function use_old_InterfaceDeclaration_ISummarizeOptions(
    use: TypeOnly<old.ISummarizeOptions>): void;
use_old_InterfaceDeclaration_ISummarizeOptions(
    get_current_InterfaceDeclaration_ISummarizeOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizeResults": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummarizeResults():
    TypeOnly<old.ISummarizeResults>;
declare function use_current_InterfaceDeclaration_ISummarizeResults(
    use: TypeOnly<current.ISummarizeResults>): void;
use_current_InterfaceDeclaration_ISummarizeResults(
    get_old_InterfaceDeclaration_ISummarizeResults());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizeResults": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummarizeResults():
    TypeOnly<current.ISummarizeResults>;
declare function use_old_InterfaceDeclaration_ISummarizeResults(
    use: TypeOnly<old.ISummarizeResults>): void;
use_old_InterfaceDeclaration_ISummarizeResults(
    get_current_InterfaceDeclaration_ISummarizeResults());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizer": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummarizer():
    TypeOnly<old.ISummarizer>;
declare function use_current_InterfaceDeclaration_ISummarizer(
    use: TypeOnly<current.ISummarizer>): void;
use_current_InterfaceDeclaration_ISummarizer(
    get_old_InterfaceDeclaration_ISummarizer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizer": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummarizer():
    TypeOnly<current.ISummarizer>;
declare function use_old_InterfaceDeclaration_ISummarizer(
    use: TypeOnly<old.ISummarizer>): void;
use_old_InterfaceDeclaration_ISummarizer(
    get_current_InterfaceDeclaration_ISummarizer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizerEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummarizerEvents():
    TypeOnly<old.ISummarizerEvents>;
declare function use_current_InterfaceDeclaration_ISummarizerEvents(
    use: TypeOnly<current.ISummarizerEvents>): void;
use_current_InterfaceDeclaration_ISummarizerEvents(
    get_old_InterfaceDeclaration_ISummarizerEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizerEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummarizerEvents():
    TypeOnly<current.ISummarizerEvents>;
declare function use_old_InterfaceDeclaration_ISummarizerEvents(
    use: TypeOnly<old.ISummarizerEvents>): void;
use_old_InterfaceDeclaration_ISummarizerEvents(
    get_current_InterfaceDeclaration_ISummarizerEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizerInternalsProvider": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummarizerInternalsProvider():
    TypeOnly<old.ISummarizerInternalsProvider>;
declare function use_current_InterfaceDeclaration_ISummarizerInternalsProvider(
    use: TypeOnly<current.ISummarizerInternalsProvider>): void;
use_current_InterfaceDeclaration_ISummarizerInternalsProvider(
    get_old_InterfaceDeclaration_ISummarizerInternalsProvider());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizerInternalsProvider": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummarizerInternalsProvider():
    TypeOnly<current.ISummarizerInternalsProvider>;
declare function use_old_InterfaceDeclaration_ISummarizerInternalsProvider(
    use: TypeOnly<old.ISummarizerInternalsProvider>): void;
use_old_InterfaceDeclaration_ISummarizerInternalsProvider(
    get_current_InterfaceDeclaration_ISummarizerInternalsProvider());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizerRuntime": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummarizerRuntime():
    TypeOnly<old.ISummarizerRuntime>;
declare function use_current_InterfaceDeclaration_ISummarizerRuntime(
    use: TypeOnly<current.ISummarizerRuntime>): void;
use_current_InterfaceDeclaration_ISummarizerRuntime(
    get_old_InterfaceDeclaration_ISummarizerRuntime());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizerRuntime": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummarizerRuntime():
    TypeOnly<current.ISummarizerRuntime>;
declare function use_old_InterfaceDeclaration_ISummarizerRuntime(
    use: TypeOnly<old.ISummarizerRuntime>): void;
use_old_InterfaceDeclaration_ISummarizerRuntime(
    get_current_InterfaceDeclaration_ISummarizerRuntime());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizingWarning": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummarizingWarning():
    TypeOnly<old.ISummarizingWarning>;
declare function use_current_InterfaceDeclaration_ISummarizingWarning(
    use: TypeOnly<current.ISummarizingWarning>): void;
use_current_InterfaceDeclaration_ISummarizingWarning(
    get_old_InterfaceDeclaration_ISummarizingWarning());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizingWarning": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummarizingWarning():
    TypeOnly<current.ISummarizingWarning>;
declare function use_old_InterfaceDeclaration_ISummarizingWarning(
    use: TypeOnly<old.ISummarizingWarning>): void;
use_old_InterfaceDeclaration_ISummarizingWarning(
    get_current_InterfaceDeclaration_ISummarizingWarning());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummary": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummary():
    TypeOnly<old.ISummary>;
declare function use_current_InterfaceDeclaration_ISummary(
    use: TypeOnly<current.ISummary>): void;
use_current_InterfaceDeclaration_ISummary(
    get_old_InterfaceDeclaration_ISummary());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummary": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummary():
    TypeOnly<current.ISummary>;
declare function use_old_InterfaceDeclaration_ISummary(
    use: TypeOnly<old.ISummary>): void;
use_old_InterfaceDeclaration_ISummary(
    get_current_InterfaceDeclaration_ISummary());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryAckMessage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryAckMessage():
    TypeOnly<old.ISummaryAckMessage>;
declare function use_current_InterfaceDeclaration_ISummaryAckMessage(
    use: TypeOnly<current.ISummaryAckMessage>): void;
use_current_InterfaceDeclaration_ISummaryAckMessage(
    get_old_InterfaceDeclaration_ISummaryAckMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryAckMessage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryAckMessage():
    TypeOnly<current.ISummaryAckMessage>;
declare function use_old_InterfaceDeclaration_ISummaryAckMessage(
    use: TypeOnly<old.ISummaryAckMessage>): void;
use_old_InterfaceDeclaration_ISummaryAckMessage(
    get_current_InterfaceDeclaration_ISummaryAckMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryBaseConfiguration": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryBaseConfiguration():
    TypeOnly<old.ISummaryBaseConfiguration>;
declare function use_current_InterfaceDeclaration_ISummaryBaseConfiguration(
    use: TypeOnly<current.ISummaryBaseConfiguration>): void;
use_current_InterfaceDeclaration_ISummaryBaseConfiguration(
    get_old_InterfaceDeclaration_ISummaryBaseConfiguration());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryBaseConfiguration": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryBaseConfiguration():
    TypeOnly<current.ISummaryBaseConfiguration>;
declare function use_old_InterfaceDeclaration_ISummaryBaseConfiguration(
    use: TypeOnly<old.ISummaryBaseConfiguration>): void;
use_old_InterfaceDeclaration_ISummaryBaseConfiguration(
    get_current_InterfaceDeclaration_ISummaryBaseConfiguration());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ISummaryCancellationToken": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ISummaryCancellationToken():
    TypeOnly<old.ISummaryCancellationToken>;
declare function use_current_TypeAliasDeclaration_ISummaryCancellationToken(
    use: TypeOnly<current.ISummaryCancellationToken>): void;
use_current_TypeAliasDeclaration_ISummaryCancellationToken(
    get_old_TypeAliasDeclaration_ISummaryCancellationToken());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ISummaryCancellationToken": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ISummaryCancellationToken():
    TypeOnly<current.ISummaryCancellationToken>;
declare function use_old_TypeAliasDeclaration_ISummaryCancellationToken(
    use: TypeOnly<old.ISummaryCancellationToken>): void;
use_old_TypeAliasDeclaration_ISummaryCancellationToken(
    get_current_TypeAliasDeclaration_ISummaryCancellationToken());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryCollectionOpEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryCollectionOpEvents():
    TypeOnly<old.ISummaryCollectionOpEvents>;
declare function use_current_InterfaceDeclaration_ISummaryCollectionOpEvents(
    use: TypeOnly<current.ISummaryCollectionOpEvents>): void;
use_current_InterfaceDeclaration_ISummaryCollectionOpEvents(
    get_old_InterfaceDeclaration_ISummaryCollectionOpEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryCollectionOpEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryCollectionOpEvents():
    TypeOnly<current.ISummaryCollectionOpEvents>;
declare function use_old_InterfaceDeclaration_ISummaryCollectionOpEvents(
    use: TypeOnly<old.ISummaryCollectionOpEvents>): void;
use_old_InterfaceDeclaration_ISummaryCollectionOpEvents(
    get_current_InterfaceDeclaration_ISummaryCollectionOpEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ISummaryConfiguration": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ISummaryConfiguration():
    TypeOnly<old.ISummaryConfiguration>;
declare function use_current_TypeAliasDeclaration_ISummaryConfiguration(
    use: TypeOnly<current.ISummaryConfiguration>): void;
use_current_TypeAliasDeclaration_ISummaryConfiguration(
    get_old_TypeAliasDeclaration_ISummaryConfiguration());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ISummaryConfiguration": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ISummaryConfiguration():
    TypeOnly<current.ISummaryConfiguration>;
declare function use_old_TypeAliasDeclaration_ISummaryConfiguration(
    use: TypeOnly<old.ISummaryConfiguration>): void;
use_old_TypeAliasDeclaration_ISummaryConfiguration(
    get_current_TypeAliasDeclaration_ISummaryConfiguration());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryConfigurationDisableHeuristics": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics():
    TypeOnly<old.ISummaryConfigurationDisableHeuristics>;
declare function use_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    use: TypeOnly<current.ISummaryConfigurationDisableHeuristics>): void;
use_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    get_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryConfigurationDisableHeuristics": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics():
    TypeOnly<current.ISummaryConfigurationDisableHeuristics>;
declare function use_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    use: TypeOnly<old.ISummaryConfigurationDisableHeuristics>): void;
use_old_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics(
    get_current_InterfaceDeclaration_ISummaryConfigurationDisableHeuristics());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryConfigurationDisableSummarizer": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer():
    TypeOnly<old.ISummaryConfigurationDisableSummarizer>;
declare function use_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    use: TypeOnly<current.ISummaryConfigurationDisableSummarizer>): void;
use_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    get_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryConfigurationDisableSummarizer": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer():
    TypeOnly<current.ISummaryConfigurationDisableSummarizer>;
declare function use_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    use: TypeOnly<old.ISummaryConfigurationDisableSummarizer>): void;
use_old_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer(
    get_current_InterfaceDeclaration_ISummaryConfigurationDisableSummarizer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryConfigurationHeuristics": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryConfigurationHeuristics():
    TypeOnly<old.ISummaryConfigurationHeuristics>;
declare function use_current_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    use: TypeOnly<current.ISummaryConfigurationHeuristics>): void;
use_current_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    get_old_InterfaceDeclaration_ISummaryConfigurationHeuristics());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryConfigurationHeuristics": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryConfigurationHeuristics():
    TypeOnly<current.ISummaryConfigurationHeuristics>;
declare function use_old_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    use: TypeOnly<old.ISummaryConfigurationHeuristics>): void;
use_old_InterfaceDeclaration_ISummaryConfigurationHeuristics(
    get_current_InterfaceDeclaration_ISummaryConfigurationHeuristics());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ISummaryMetadataMessage": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ISummaryMetadataMessage():
    TypeOnly<old.ISummaryMetadataMessage>;
declare function use_current_TypeAliasDeclaration_ISummaryMetadataMessage(
    use: TypeOnly<current.ISummaryMetadataMessage>): void;
use_current_TypeAliasDeclaration_ISummaryMetadataMessage(
    get_old_TypeAliasDeclaration_ISummaryMetadataMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ISummaryMetadataMessage": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ISummaryMetadataMessage():
    TypeOnly<current.ISummaryMetadataMessage>;
declare function use_old_TypeAliasDeclaration_ISummaryMetadataMessage(
    use: TypeOnly<old.ISummaryMetadataMessage>): void;
use_old_TypeAliasDeclaration_ISummaryMetadataMessage(
    get_current_TypeAliasDeclaration_ISummaryMetadataMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryNackMessage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryNackMessage():
    TypeOnly<old.ISummaryNackMessage>;
declare function use_current_InterfaceDeclaration_ISummaryNackMessage(
    use: TypeOnly<current.ISummaryNackMessage>): void;
use_current_InterfaceDeclaration_ISummaryNackMessage(
    get_old_InterfaceDeclaration_ISummaryNackMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryNackMessage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryNackMessage():
    TypeOnly<current.ISummaryNackMessage>;
declare function use_old_InterfaceDeclaration_ISummaryNackMessage(
    use: TypeOnly<old.ISummaryNackMessage>): void;
use_old_InterfaceDeclaration_ISummaryNackMessage(
    get_current_InterfaceDeclaration_ISummaryNackMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryOpMessage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryOpMessage():
    TypeOnly<old.ISummaryOpMessage>;
declare function use_current_InterfaceDeclaration_ISummaryOpMessage(
    use: TypeOnly<current.ISummaryOpMessage>): void;
use_current_InterfaceDeclaration_ISummaryOpMessage(
    get_old_InterfaceDeclaration_ISummaryOpMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryOpMessage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryOpMessage():
    TypeOnly<current.ISummaryOpMessage>;
declare function use_old_InterfaceDeclaration_ISummaryOpMessage(
    use: TypeOnly<old.ISummaryOpMessage>): void;
use_old_InterfaceDeclaration_ISummaryOpMessage(
    get_current_InterfaceDeclaration_ISummaryOpMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryRuntimeOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryRuntimeOptions():
    TypeOnly<old.ISummaryRuntimeOptions>;
declare function use_current_InterfaceDeclaration_ISummaryRuntimeOptions(
    use: TypeOnly<current.ISummaryRuntimeOptions>): void;
use_current_InterfaceDeclaration_ISummaryRuntimeOptions(
    get_old_InterfaceDeclaration_ISummaryRuntimeOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryRuntimeOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryRuntimeOptions():
    TypeOnly<current.ISummaryRuntimeOptions>;
declare function use_old_InterfaceDeclaration_ISummaryRuntimeOptions(
    use: TypeOnly<old.ISummaryRuntimeOptions>): void;
use_old_InterfaceDeclaration_ISummaryRuntimeOptions(
    get_current_InterfaceDeclaration_ISummaryRuntimeOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISweepPhaseStats": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISweepPhaseStats():
    TypeOnly<old.ISweepPhaseStats>;
declare function use_current_InterfaceDeclaration_ISweepPhaseStats(
    use: TypeOnly<current.ISweepPhaseStats>): void;
use_current_InterfaceDeclaration_ISweepPhaseStats(
    get_old_InterfaceDeclaration_ISweepPhaseStats());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISweepPhaseStats": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISweepPhaseStats():
    TypeOnly<current.ISweepPhaseStats>;
declare function use_old_InterfaceDeclaration_ISweepPhaseStats(
    use: TypeOnly<old.ISweepPhaseStats>): void;
use_old_InterfaceDeclaration_ISweepPhaseStats(
    get_current_InterfaceDeclaration_ISweepPhaseStats());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IUploadSummaryResult": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IUploadSummaryResult():
    TypeOnly<old.IUploadSummaryResult>;
declare function use_current_InterfaceDeclaration_IUploadSummaryResult(
    use: TypeOnly<current.IUploadSummaryResult>): void;
use_current_InterfaceDeclaration_IUploadSummaryResult(
    get_old_InterfaceDeclaration_IUploadSummaryResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IUploadSummaryResult": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IUploadSummaryResult():
    TypeOnly<current.IUploadSummaryResult>;
declare function use_old_InterfaceDeclaration_IUploadSummaryResult(
    use: TypeOnly<old.IUploadSummaryResult>): void;
use_old_InterfaceDeclaration_IUploadSummaryResult(
    get_current_InterfaceDeclaration_IUploadSummaryResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IdCompressorMode": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IdCompressorMode():
    TypeOnly<old.IdCompressorMode>;
declare function use_current_TypeAliasDeclaration_IdCompressorMode(
    use: TypeOnly<current.IdCompressorMode>): void;
use_current_TypeAliasDeclaration_IdCompressorMode(
    get_old_TypeAliasDeclaration_IdCompressorMode());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IdCompressorMode": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IdCompressorMode():
    TypeOnly<current.IdCompressorMode>;
declare function use_old_TypeAliasDeclaration_IdCompressorMode(
    use: TypeOnly<old.IdCompressorMode>): void;
use_old_TypeAliasDeclaration_IdCompressorMode(
    get_current_TypeAliasDeclaration_IdCompressorMode());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_InactiveResponseHeaderKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_InactiveResponseHeaderKey():
    TypeOnly<typeof old.InactiveResponseHeaderKey>;
declare function use_current_VariableDeclaration_InactiveResponseHeaderKey(
    use: TypeOnly<typeof current.InactiveResponseHeaderKey>): void;
use_current_VariableDeclaration_InactiveResponseHeaderKey(
    get_old_VariableDeclaration_InactiveResponseHeaderKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_InactiveResponseHeaderKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_InactiveResponseHeaderKey():
    TypeOnly<typeof current.InactiveResponseHeaderKey>;
declare function use_old_VariableDeclaration_InactiveResponseHeaderKey(
    use: TypeOnly<typeof old.InactiveResponseHeaderKey>): void;
use_old_VariableDeclaration_InactiveResponseHeaderKey(
    get_current_VariableDeclaration_InactiveResponseHeaderKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LocalFluidDataStoreContext": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_LocalFluidDataStoreContext():
    TypeOnly<old.LocalFluidDataStoreContext>;
declare function use_current_ClassDeclaration_LocalFluidDataStoreContext(
    use: TypeOnly<current.LocalFluidDataStoreContext>): void;
use_current_ClassDeclaration_LocalFluidDataStoreContext(
    get_old_ClassDeclaration_LocalFluidDataStoreContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LocalFluidDataStoreContext": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_LocalFluidDataStoreContext():
    TypeOnly<current.LocalFluidDataStoreContext>;
declare function use_old_ClassDeclaration_LocalFluidDataStoreContext(
    use: TypeOnly<old.LocalFluidDataStoreContext>): void;
use_old_ClassDeclaration_LocalFluidDataStoreContext(
    get_current_ClassDeclaration_LocalFluidDataStoreContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LocalFluidDataStoreContextBase": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_LocalFluidDataStoreContextBase():
    TypeOnly<old.LocalFluidDataStoreContextBase>;
declare function use_current_ClassDeclaration_LocalFluidDataStoreContextBase(
    use: TypeOnly<current.LocalFluidDataStoreContextBase>): void;
use_current_ClassDeclaration_LocalFluidDataStoreContextBase(
    get_old_ClassDeclaration_LocalFluidDataStoreContextBase());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LocalFluidDataStoreContextBase": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_LocalFluidDataStoreContextBase():
    TypeOnly<current.LocalFluidDataStoreContextBase>;
declare function use_old_ClassDeclaration_LocalFluidDataStoreContextBase(
    use: TypeOnly<old.LocalFluidDataStoreContextBase>): void;
use_old_ClassDeclaration_LocalFluidDataStoreContextBase(
    get_current_ClassDeclaration_LocalFluidDataStoreContextBase());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_OmitAttributesVersions": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_OmitAttributesVersions():
    TypeOnly<old.OmitAttributesVersions<any>>;
declare function use_current_TypeAliasDeclaration_OmitAttributesVersions(
    use: TypeOnly<current.OmitAttributesVersions<any>>): void;
use_current_TypeAliasDeclaration_OmitAttributesVersions(
    get_old_TypeAliasDeclaration_OmitAttributesVersions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_OmitAttributesVersions": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_OmitAttributesVersions():
    TypeOnly<current.OmitAttributesVersions<any>>;
declare function use_old_TypeAliasDeclaration_OmitAttributesVersions(
    use: TypeOnly<old.OmitAttributesVersions<any>>): void;
use_old_TypeAliasDeclaration_OmitAttributesVersions(
    get_current_TypeAliasDeclaration_OmitAttributesVersions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_OpActionEventListener": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_OpActionEventListener():
    TypeOnly<old.OpActionEventListener>;
declare function use_current_TypeAliasDeclaration_OpActionEventListener(
    use: TypeOnly<current.OpActionEventListener>): void;
use_current_TypeAliasDeclaration_OpActionEventListener(
    get_old_TypeAliasDeclaration_OpActionEventListener());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_OpActionEventListener": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_OpActionEventListener():
    TypeOnly<current.OpActionEventListener>;
declare function use_old_TypeAliasDeclaration_OpActionEventListener(
    use: TypeOnly<old.OpActionEventListener>): void;
use_old_TypeAliasDeclaration_OpActionEventListener(
    get_current_TypeAliasDeclaration_OpActionEventListener());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_OpActionEventName": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_OpActionEventName():
    TypeOnly<old.OpActionEventName>;
declare function use_current_TypeAliasDeclaration_OpActionEventName(
    use: TypeOnly<current.OpActionEventName>): void;
use_current_TypeAliasDeclaration_OpActionEventName(
    get_old_TypeAliasDeclaration_OpActionEventName());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_OpActionEventName": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_OpActionEventName():
    TypeOnly<current.OpActionEventName>;
declare function use_old_TypeAliasDeclaration_OpActionEventName(
    use: TypeOnly<old.OpActionEventName>): void;
use_old_TypeAliasDeclaration_OpActionEventName(
    get_current_TypeAliasDeclaration_OpActionEventName());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ReadFluidDataStoreAttributes": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ReadFluidDataStoreAttributes():
    TypeOnly<old.ReadFluidDataStoreAttributes>;
declare function use_current_TypeAliasDeclaration_ReadFluidDataStoreAttributes(
    use: TypeOnly<current.ReadFluidDataStoreAttributes>): void;
use_current_TypeAliasDeclaration_ReadFluidDataStoreAttributes(
    get_old_TypeAliasDeclaration_ReadFluidDataStoreAttributes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ReadFluidDataStoreAttributes": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ReadFluidDataStoreAttributes():
    TypeOnly<current.ReadFluidDataStoreAttributes>;
declare function use_old_TypeAliasDeclaration_ReadFluidDataStoreAttributes(
    use: TypeOnly<old.ReadFluidDataStoreAttributes>): void;
use_old_TypeAliasDeclaration_ReadFluidDataStoreAttributes(
    get_current_TypeAliasDeclaration_ReadFluidDataStoreAttributes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails():
    TypeOnly<old.RecentlyAddedContainerRuntimeMessageDetails>;
declare function use_current_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails(
    use: TypeOnly<current.RecentlyAddedContainerRuntimeMessageDetails>): void;
use_current_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails(
    get_old_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails():
    TypeOnly<current.RecentlyAddedContainerRuntimeMessageDetails>;
declare function use_old_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails(
    use: TypeOnly<old.RecentlyAddedContainerRuntimeMessageDetails>): void;
use_old_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails(
    get_current_InterfaceDeclaration_RecentlyAddedContainerRuntimeMessageDetails());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_RuntimeHeaderData": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_RuntimeHeaderData():
    TypeOnly<old.RuntimeHeaderData>;
declare function use_current_InterfaceDeclaration_RuntimeHeaderData(
    use: TypeOnly<current.RuntimeHeaderData>): void;
use_current_InterfaceDeclaration_RuntimeHeaderData(
    get_old_InterfaceDeclaration_RuntimeHeaderData());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_RuntimeHeaderData": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_RuntimeHeaderData():
    TypeOnly<current.RuntimeHeaderData>;
declare function use_old_InterfaceDeclaration_RuntimeHeaderData(
    use: TypeOnly<old.RuntimeHeaderData>): void;
use_old_InterfaceDeclaration_RuntimeHeaderData(
    get_current_InterfaceDeclaration_RuntimeHeaderData());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_RuntimeHeaders": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_RuntimeHeaders():
    TypeOnly<old.RuntimeHeaders>;
declare function use_current_EnumDeclaration_RuntimeHeaders(
    use: TypeOnly<current.RuntimeHeaders>): void;
use_current_EnumDeclaration_RuntimeHeaders(
    get_old_EnumDeclaration_RuntimeHeaders());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_RuntimeHeaders": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_RuntimeHeaders():
    TypeOnly<current.RuntimeHeaders>;
declare function use_old_EnumDeclaration_RuntimeHeaders(
    use: TypeOnly<old.RuntimeHeaders>): void;
use_old_EnumDeclaration_RuntimeHeaders(
    get_current_EnumDeclaration_RuntimeHeaders());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SubmitSummaryFailureData": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SubmitSummaryFailureData():
    TypeOnly<old.SubmitSummaryFailureData>;
declare function use_current_InterfaceDeclaration_SubmitSummaryFailureData(
    use: TypeOnly<current.SubmitSummaryFailureData>): void;
use_current_InterfaceDeclaration_SubmitSummaryFailureData(
    get_old_InterfaceDeclaration_SubmitSummaryFailureData());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SubmitSummaryFailureData": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SubmitSummaryFailureData():
    TypeOnly<current.SubmitSummaryFailureData>;
declare function use_old_InterfaceDeclaration_SubmitSummaryFailureData(
    use: TypeOnly<old.SubmitSummaryFailureData>): void;
use_old_InterfaceDeclaration_SubmitSummaryFailureData(
    get_current_InterfaceDeclaration_SubmitSummaryFailureData());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SubmitSummaryResult": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SubmitSummaryResult():
    TypeOnly<old.SubmitSummaryResult>;
declare function use_current_TypeAliasDeclaration_SubmitSummaryResult(
    use: TypeOnly<current.SubmitSummaryResult>): void;
use_current_TypeAliasDeclaration_SubmitSummaryResult(
    get_old_TypeAliasDeclaration_SubmitSummaryResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SubmitSummaryResult": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SubmitSummaryResult():
    TypeOnly<current.SubmitSummaryResult>;
declare function use_old_TypeAliasDeclaration_SubmitSummaryResult(
    use: TypeOnly<old.SubmitSummaryResult>): void;
use_old_TypeAliasDeclaration_SubmitSummaryResult(
    get_current_TypeAliasDeclaration_SubmitSummaryResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummarizeResultPart": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SummarizeResultPart():
    TypeOnly<old.SummarizeResultPart<any>>;
declare function use_current_TypeAliasDeclaration_SummarizeResultPart(
    use: TypeOnly<current.SummarizeResultPart<any>>): void;
use_current_TypeAliasDeclaration_SummarizeResultPart(
    get_old_TypeAliasDeclaration_SummarizeResultPart());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummarizeResultPart": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SummarizeResultPart():
    TypeOnly<current.SummarizeResultPart<any>>;
declare function use_old_TypeAliasDeclaration_SummarizeResultPart(
    use: TypeOnly<old.SummarizeResultPart<any>>): void;
use_old_TypeAliasDeclaration_SummarizeResultPart(
    get_current_TypeAliasDeclaration_SummarizeResultPart());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Summarizer": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_Summarizer():
    TypeOnly<old.Summarizer>;
declare function use_current_ClassDeclaration_Summarizer(
    use: TypeOnly<current.Summarizer>): void;
use_current_ClassDeclaration_Summarizer(
    get_old_ClassDeclaration_Summarizer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Summarizer": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_Summarizer():
    TypeOnly<current.Summarizer>;
declare function use_old_ClassDeclaration_Summarizer(
    use: TypeOnly<old.Summarizer>): void;
use_old_ClassDeclaration_Summarizer(
    get_current_ClassDeclaration_Summarizer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummarizerStopReason": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SummarizerStopReason():
    TypeOnly<old.SummarizerStopReason>;
declare function use_current_TypeAliasDeclaration_SummarizerStopReason(
    use: TypeOnly<current.SummarizerStopReason>): void;
use_current_TypeAliasDeclaration_SummarizerStopReason(
    get_old_TypeAliasDeclaration_SummarizerStopReason());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummarizerStopReason": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SummarizerStopReason():
    TypeOnly<current.SummarizerStopReason>;
declare function use_old_TypeAliasDeclaration_SummarizerStopReason(
    use: TypeOnly<old.SummarizerStopReason>): void;
use_old_TypeAliasDeclaration_SummarizerStopReason(
    get_current_TypeAliasDeclaration_SummarizerStopReason());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SummaryCollection": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SummaryCollection():
    TypeOnly<old.SummaryCollection>;
declare function use_current_ClassDeclaration_SummaryCollection(
    use: TypeOnly<current.SummaryCollection>): void;
use_current_ClassDeclaration_SummaryCollection(
    get_old_ClassDeclaration_SummaryCollection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SummaryCollection": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SummaryCollection():
    TypeOnly<current.SummaryCollection>;
declare function use_old_ClassDeclaration_SummaryCollection(
    use: TypeOnly<old.SummaryCollection>): void;
use_old_ClassDeclaration_SummaryCollection(
    get_current_ClassDeclaration_SummaryCollection());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummaryStage": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SummaryStage():
    TypeOnly<old.SummaryStage>;
declare function use_current_TypeAliasDeclaration_SummaryStage(
    use: TypeOnly<current.SummaryStage>): void;
use_current_TypeAliasDeclaration_SummaryStage(
    get_old_TypeAliasDeclaration_SummaryStage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummaryStage": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SummaryStage():
    TypeOnly<current.SummaryStage>;
declare function use_old_TypeAliasDeclaration_SummaryStage(
    use: TypeOnly<old.SummaryStage>): void;
use_old_TypeAliasDeclaration_SummaryStage(
    get_current_TypeAliasDeclaration_SummaryStage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_TombstoneResponseHeaderKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_TombstoneResponseHeaderKey():
    TypeOnly<typeof old.TombstoneResponseHeaderKey>;
declare function use_current_VariableDeclaration_TombstoneResponseHeaderKey(
    use: TypeOnly<typeof current.TombstoneResponseHeaderKey>): void;
use_current_VariableDeclaration_TombstoneResponseHeaderKey(
    get_old_VariableDeclaration_TombstoneResponseHeaderKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_TombstoneResponseHeaderKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_TombstoneResponseHeaderKey():
    TypeOnly<typeof current.TombstoneResponseHeaderKey>;
declare function use_old_VariableDeclaration_TombstoneResponseHeaderKey(
    use: TypeOnly<typeof old.TombstoneResponseHeaderKey>): void;
use_old_VariableDeclaration_TombstoneResponseHeaderKey(
    get_current_VariableDeclaration_TombstoneResponseHeaderKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_UnknownContainerRuntimeMessage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_UnknownContainerRuntimeMessage():
    TypeOnly<old.UnknownContainerRuntimeMessage>;
declare function use_current_InterfaceDeclaration_UnknownContainerRuntimeMessage(
    use: TypeOnly<current.UnknownContainerRuntimeMessage>): void;
use_current_InterfaceDeclaration_UnknownContainerRuntimeMessage(
    get_old_InterfaceDeclaration_UnknownContainerRuntimeMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_UnknownContainerRuntimeMessage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_UnknownContainerRuntimeMessage():
    TypeOnly<current.UnknownContainerRuntimeMessage>;
declare function use_old_InterfaceDeclaration_UnknownContainerRuntimeMessage(
    use: TypeOnly<old.UnknownContainerRuntimeMessage>): void;
use_old_InterfaceDeclaration_UnknownContainerRuntimeMessage(
    get_current_InterfaceDeclaration_UnknownContainerRuntimeMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_agentSchedulerId": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_agentSchedulerId():
    TypeOnly<typeof old.agentSchedulerId>;
declare function use_current_VariableDeclaration_agentSchedulerId(
    use: TypeOnly<typeof current.agentSchedulerId>): void;
use_current_VariableDeclaration_agentSchedulerId(
    get_old_VariableDeclaration_agentSchedulerId());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_agentSchedulerId": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_agentSchedulerId():
    TypeOnly<typeof current.agentSchedulerId>;
declare function use_old_VariableDeclaration_agentSchedulerId(
    use: TypeOnly<typeof old.agentSchedulerId>): void;
use_old_VariableDeclaration_agentSchedulerId(
    get_current_VariableDeclaration_agentSchedulerId());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_currentDocumentVersionSchema": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_currentDocumentVersionSchema():
    TypeOnly<typeof old.currentDocumentVersionSchema>;
declare function use_current_VariableDeclaration_currentDocumentVersionSchema(
    use: TypeOnly<typeof current.currentDocumentVersionSchema>): void;
use_current_VariableDeclaration_currentDocumentVersionSchema(
    get_old_VariableDeclaration_currentDocumentVersionSchema());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_currentDocumentVersionSchema": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_currentDocumentVersionSchema():
    TypeOnly<typeof current.currentDocumentVersionSchema>;
declare function use_old_VariableDeclaration_currentDocumentVersionSchema(
    use: TypeOnly<typeof old.currentDocumentVersionSchema>): void;
use_old_VariableDeclaration_currentDocumentVersionSchema(
    get_current_VariableDeclaration_currentDocumentVersionSchema());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_detectOutboundReferences": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_detectOutboundReferences():
    TypeOnly<typeof old.detectOutboundReferences>;
declare function use_current_FunctionDeclaration_detectOutboundReferences(
    use: TypeOnly<typeof current.detectOutboundReferences>): void;
use_current_FunctionDeclaration_detectOutboundReferences(
    get_old_FunctionDeclaration_detectOutboundReferences());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_detectOutboundReferences": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_detectOutboundReferences():
    TypeOnly<typeof current.detectOutboundReferences>;
declare function use_old_FunctionDeclaration_detectOutboundReferences(
    use: TypeOnly<typeof old.detectOutboundReferences>): void;
use_old_FunctionDeclaration_detectOutboundReferences(
    get_current_FunctionDeclaration_detectOutboundReferences());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_disabledCompressionConfig": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_disabledCompressionConfig():
    TypeOnly<typeof old.disabledCompressionConfig>;
declare function use_current_VariableDeclaration_disabledCompressionConfig(
    use: TypeOnly<typeof current.disabledCompressionConfig>): void;
use_current_VariableDeclaration_disabledCompressionConfig(
    get_old_VariableDeclaration_disabledCompressionConfig());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_disabledCompressionConfig": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_disabledCompressionConfig():
    TypeOnly<typeof current.disabledCompressionConfig>;
declare function use_old_VariableDeclaration_disabledCompressionConfig(
    use: TypeOnly<typeof old.disabledCompressionConfig>): void;
use_old_VariableDeclaration_disabledCompressionConfig(
    get_current_VariableDeclaration_disabledCompressionConfig());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isRuntimeMessage": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_isRuntimeMessage():
    TypeOnly<typeof old.isRuntimeMessage>;
declare function use_current_FunctionDeclaration_isRuntimeMessage(
    use: TypeOnly<typeof current.isRuntimeMessage>): void;
use_current_FunctionDeclaration_isRuntimeMessage(
    get_old_FunctionDeclaration_isRuntimeMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isRuntimeMessage": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_isRuntimeMessage():
    TypeOnly<typeof current.isRuntimeMessage>;
declare function use_old_FunctionDeclaration_isRuntimeMessage(
    use: TypeOnly<typeof old.isRuntimeMessage>): void;
use_old_FunctionDeclaration_isRuntimeMessage(
    get_current_FunctionDeclaration_isRuntimeMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_neverCancelledSummaryToken": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_neverCancelledSummaryToken():
    TypeOnly<typeof old.neverCancelledSummaryToken>;
declare function use_current_VariableDeclaration_neverCancelledSummaryToken(
    use: TypeOnly<typeof current.neverCancelledSummaryToken>): void;
use_current_VariableDeclaration_neverCancelledSummaryToken(
    get_old_VariableDeclaration_neverCancelledSummaryToken());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_neverCancelledSummaryToken": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_neverCancelledSummaryToken():
    TypeOnly<typeof current.neverCancelledSummaryToken>;
declare function use_old_VariableDeclaration_neverCancelledSummaryToken(
    use: TypeOnly<typeof old.neverCancelledSummaryToken>): void;
use_old_VariableDeclaration_neverCancelledSummaryToken(
    get_current_VariableDeclaration_neverCancelledSummaryToken());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_unpackRuntimeMessage": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_unpackRuntimeMessage():
    TypeOnly<typeof old.unpackRuntimeMessage>;
declare function use_current_FunctionDeclaration_unpackRuntimeMessage(
    use: TypeOnly<typeof current.unpackRuntimeMessage>): void;
use_current_FunctionDeclaration_unpackRuntimeMessage(
    get_old_FunctionDeclaration_unpackRuntimeMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_unpackRuntimeMessage": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_unpackRuntimeMessage():
    TypeOnly<typeof current.unpackRuntimeMessage>;
declare function use_old_FunctionDeclaration_unpackRuntimeMessage(
    use: TypeOnly<typeof old.unpackRuntimeMessage>): void;
use_old_FunctionDeclaration_unpackRuntimeMessage(
    get_current_FunctionDeclaration_unpackRuntimeMessage());
