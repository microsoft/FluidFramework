/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { ITelemetryGenericEvent } from "@fluidframework/core-interfaces";
import { IGarbageCollectionData } from "@fluidframework/runtime-definitions";
import {
	generateStack,
	ITelemetryLoggerExt,
	MonitoringContext,
	tagCodeArtifacts,
} from "@fluidframework/telemetry-utils";
import { RuntimeHeaderData } from "../containerRuntime";
import { ICreateContainerMetadata } from "../summary";
import {
	GCNodeType,
	UnreferencedState,
	IGarbageCollectorConfigs,
	disableTombstoneKey,
	throwOnTombstoneUsageKey,
	throwOnTombstoneLoadOverrideKey,
	runSweepKey,
	GCFeatureMatrix,
} from "./gcDefinitions";
import { UnreferencedStateTracker } from "./gcUnreferencedStateTracker";

type NodeUsageType = "Changed" | "Loaded" | "Revived";

/** Properties that are common to IUnreferencedEventProps and INodeUsageProps */
interface ICommonProps {
	usageType: NodeUsageType;
	completedGCRuns: number;
	isTombstoned: boolean;
	lastSummaryTime?: number;
	headers?: RuntimeHeaderData;
}

/** The event that is logged when unreferenced node is used after a certain time. */
interface IUnreferencedEventProps extends ICreateContainerMetadata, ICommonProps {
	state: UnreferencedState;
	id: {
		value: string;
		tag: string;
	};
	type: GCNodeType;
	unrefTime: number;
	age: number;
	// Expanding GC feature matrix. Without doing this, the configs cannot be logged in telemetry directly.
	gcConfigs: Omit<IGarbageCollectorConfigs, "persistedGcFeatureMatrix"> & {
		[K in keyof GCFeatureMatrix]: GCFeatureMatrix[K];
	};
	timeout?: number;
	fromId?: {
		value: string;
		tag: string;
	};
}

/** Properties passed to nodeUsed function when a node is used. */
interface INodeUsageProps extends ICommonProps {
	id: string;
	currentReferenceTimestampMs: number | undefined;
	packagePath: readonly string[] | undefined;
	fromId?: string;
}

/**
 * Encapsulates the logic that tracks the various telemetry logged by the Garbage Collector. There are 4 types of
 * telemetry logged:
 * 1. inactiveObject telemetry - When an inactive node is used - A node that has been unreferenced for inactiveTimeoutMs.
 * 2. sweepReadyObject telemetry - When a sweep ready node is used - A node that has been unreferenced for sweepTimeoutMs.
 * 3. Tombstone telemetry - When a tombstoned node is used - A node that that has been marked as tombstone.
 * 4. Sweep / deleted telemetry - When a node is detected as sweep ready in the sweep phase.
 * 5. Unknown outbound reference telemetry - When a node is referenced but GC is not explicitly notified of it.
 */
export class GCTelemetryTracker {
	// Keeps track of unreferenced events that are logged for a node. This is used to limit the log generation to one
	// per event per node.
	private readonly loggedUnreferencedEvents: Set<string> = new Set();
	// Queue for unreferenced events that should be logged the next time GC runs.
	private pendingEventsQueue: IUnreferencedEventProps[] = [];

	constructor(
		private readonly mc: MonitoringContext,
		private readonly configs: IGarbageCollectorConfigs,
		private readonly isSummarizerClient: boolean,
		private readonly createContainerMetadata: ICreateContainerMetadata,
		private readonly getNodeType: (nodeId: string) => GCNodeType,
		private readonly getNodeStateTracker: (
			nodeId: string,
		) => UnreferencedStateTracker | undefined,
		private readonly getNodePackagePath: (
			nodePath: string,
		) => Promise<readonly string[] | undefined>,
	) {}

	/**
	 * Returns whether an event should be logged for a node that isn't active anymore. This does not apply to
	 * tombstoned nodes for which an event is always logged. Some scenarios where we won't log:
	 * 1. When a DDS is changed. The corresponding data store's event will be logged instead.
	 * 2. An event is logged only once per container instance per event per node.
	 */
	private shouldLogNonActiveEvent(
		nodeType: GCNodeType,
		usageType: NodeUsageType,
		nodeStateTracker: UnreferencedStateTracker,
		uniqueEventId: string,
	) {
		if (nodeStateTracker.state === UnreferencedState.Active) {
			return false;
		}

		if (nodeType === GCNodeType.Other) {
			return false;
		}

		// For sub data store (DDS) nodes, if they are changed, its data store will also be changed,
		// so skip logging to make the telemetry less noisy.
		if (nodeType === GCNodeType.SubDataStore && usageType === "Changed") {
			return false;
		}

		// Non-tombstone events are logged once per event per node. A unique id is generated by joining
		// node state (inactive / sweep ready), node's id and usage (loaded / changed / revived).
		if (this.loggedUnreferencedEvents.has(uniqueEventId)) {
			return false;
		}
		return true;
	}

	/**
	 * Called when a node is used. If the node is not active or tombstoned, log telemetry indicating object is used
	 * when it should not have been.
	 */
	public nodeUsed(nodeUsageProps: INodeUsageProps) {
		// If there is no reference timestamp to work with, no ops have been processed after creation. If so, skip
		// logging as nothing interesting would have happened worth logging.
		if (nodeUsageProps.currentReferenceTimestampMs === undefined) {
			return;
		}

		const nodeStateTracker = this.getNodeStateTracker(nodeUsageProps.id);
		const nodeType = this.getNodeType(nodeUsageProps.id);
		const timeout = (() => {
			switch (nodeStateTracker?.state) {
				case UnreferencedState.Inactive:
					return this.configs.inactiveTimeoutMs;
				case UnreferencedState.TombstoneReady:
					return this.configs.sweepTimeoutMs;
				case UnreferencedState.SweepReady:
					return (
						this.configs.sweepTimeoutMs &&
						this.configs.sweepTimeoutMs + this.configs.sweepGracePeriodMs
					);
				default:
					return undefined;
			}
		})();
		const {
			usageType,
			currentReferenceTimestampMs,
			packagePath,
			id: untaggedId,
			fromId: untaggedFromId,
			...propsToLog
		} = nodeUsageProps;
		const { persistedGcFeatureMatrix, ...configs } = this.configs;
		const unrefEventProps: Omit<IUnreferencedEventProps, "state" | "usageType"> = {
			type: nodeType,
			unrefTime: nodeStateTracker?.unreferencedTimestampMs ?? -1,
			age:
				nodeStateTracker !== undefined
					? nodeUsageProps.currentReferenceTimestampMs -
					  nodeStateTracker.unreferencedTimestampMs
					: -1,
			timeout,
			...tagCodeArtifacts({ id: untaggedId, fromId: untaggedFromId }),
			...propsToLog,
			...this.createContainerMetadata,
			gcConfigs: { ...configs, ...persistedGcFeatureMatrix },
		};

		// If the node that is used is tombstoned, log a tombstone telemetry.
		// Note that this is done before checking if "nodeStateTracker" is undefined below because unreferenced
		// tracking may not have yet been enabled. That happens only after the client transitions to write mode.
		if (nodeUsageProps.isTombstoned) {
			this.logTombstoneUsageTelemetry(nodeUsageProps, unrefEventProps, nodeType, usageType);
		}

		// After logging tombstone telemetry, if the node's unreferenced state is not tracked, there is nothing
		// else to log.
		if (nodeStateTracker === undefined) {
			return;
		}

		const state = nodeStateTracker.state;
		const uniqueEventId = `${state}-${nodeUsageProps.id}-${nodeUsageProps.usageType}`;

		if (
			!this.shouldLogNonActiveEvent(
				nodeType,
				nodeUsageProps.usageType,
				nodeStateTracker,
				uniqueEventId,
			)
		) {
			return;
		}

		// Add the unique event id so that we don't generate a log for this event again in this session.
		this.loggedUnreferencedEvents.add(uniqueEventId);

		// For summarizer client, queue the event so it is logged the next time GC runs if the event is still valid.
		// For non-summarizer client, log the event now since GC won't run on it. This may result in false positives
		// but it's a good signal nonetheless and we can consume it with a grain of salt.
		// Inactive errors are usages of Objects that are unreferenced for at least a period of 7 days.
		// SweepReady errors are usages of Objects that will be deleted by GC Sweep!
		if (this.isSummarizerClient) {
			this.pendingEventsQueue.push({
				...unrefEventProps,
				usageType: nodeUsageProps.usageType,
				state,
			});
		} else {
			// For non-summarizer clients, only log "Loaded" type events since these objects may not be loaded in the
			// summarizer clients if they are based off of user actions (such as scrolling to content for these objects)
			// Events generated:
			// InactiveObject_Loaded, SweepReadyObject_Loaded
			if (nodeUsageProps.usageType === "Loaded") {
				const { id, fromId, headers, gcConfigs, ...detailedProps } = unrefEventProps;
				const event = {
					eventName: `${state}Object_${nodeUsageProps.usageType}`,
					...tagCodeArtifacts({ pkg: nodeUsageProps.packagePath?.join("/") }),
					stack: generateStack(),
					id,
					fromId,
					headers: { ...headers },
					details: detailedProps,
					gcConfigs,
				};

				// These are logged as generic events and not errors because there can be false positives. The Tombstone
				// and Delete errors are separately logged and are reliable.
				this.mc.logger.sendTelemetryEvent(event);
			}
		}
	}

	/**
	 * Logs telemetry when a tombstoned object is changed, revived or loaded.
	 */
	private logTombstoneUsageTelemetry(
		nodeUsageProps: INodeUsageProps,
		unrefEventProps: Omit<IUnreferencedEventProps, "state" | "usageType">,
		nodeType: GCNodeType,
		usageType: NodeUsageType,
	) {
		// This will log the following events:
		// GC_Tombstone_DataStore_Requested, GC_Tombstone_DataStore_Changed, GC_Tombstone_DataStore_Revived
		// GC_Tombstone_SubDataStore_Requested, GC_Tombstone_SubDataStore_Changed, GC_Tombstone_SubDataStore_Revived
		// GC_Tombstone_Blob_Requested, GC_Tombstone_Blob_Changed, GC_Tombstone_Blob_Revived
		const { id, fromId, headers, gcConfigs, ...detailedProps } = unrefEventProps;
		const eventUsageName = usageType === "Loaded" ? "Requested" : usageType;
		const event = {
			eventName: `GC_Tombstone_${nodeType}_${eventUsageName}`,
			pkg: tagCodeArtifacts({ pkg: nodeUsageProps.packagePath?.join("/") }).pkg,
			stack: generateStack(),
			id,
			fromId,
			headers: { ...headers },
			details: detailedProps,
			gcConfigs,
			tombstoneFlags: {
				DisableTombstone: this.mc.config.getBoolean(disableTombstoneKey),
				ThrowOnTombstoneUsage: this.mc.config.getBoolean(throwOnTombstoneUsageKey),
				ThrowOnTombstoneLoad: this.mc.config.getBoolean(throwOnTombstoneLoadOverrideKey),
			},
			sweepFlags: {
				EnableSweepFlag: this.mc.config.getBoolean(runSweepKey),
			},
		};

		if (
			(usageType === "Loaded" &&
				this.configs.throwOnTombstoneLoad &&
				!headers?.allowTombstone) ||
			(usageType === "Changed" && this.configs.throwOnTombstoneUsage)
		) {
			this.mc.logger.sendErrorEvent(event);
		} else {
			this.mc.logger.sendTelemetryEvent(event);
		}
	}

	/**
	 * Log all new references or outbound routes in the current graph that haven't been explicitly notified to GC.
	 * The principle is that every new reference or outbound route must be notified to GC via the
	 * addedOutboundReference method. It it hasn't, its a bug and we want to identify these scenarios.
	 *
	 * In more simple terms:
	 * Missing Explicit References = Current References - Previous References - Explicitly Added References;
	 *
	 * @param currentGCData - The GC data (reference graph) from the current GC run.
	 * @param previousGCData - The GC data (reference graph) from the previous GC run.
	 * @param explicitReferences - New references added explicity between the previous and the current run.
	 */
	public logIfMissingExplicitReferences(
		currentGCData: IGarbageCollectionData,
		previousGCData: IGarbageCollectionData,
		explicitReferences: Map<string, string[]>,
		logger: ITelemetryLoggerExt,
	) {
		for (const [nodeId, currentOutboundRoutes] of Object.entries(currentGCData.gcNodes)) {
			const previousRoutes = previousGCData.gcNodes[nodeId] ?? [];
			const explicitRoutes = explicitReferences.get(nodeId) ?? [];

			/**
			 * 1. For routes in the current GC data, routes that were not present in previous GC data and did not have
			 * explicit references should be added to missing explicit routes list.
			 * 2. Only include data store and blob routes since GC only works for these two.
			 * Note: Due to a bug with de-duped blobs, only adding data store routes for now.
			 * 3. Ignore DDS routes to their parent datastores since those were added implicitly. So, there won't be
			 * explicit routes to them.
			 */
			const missingExplicitRoutes: string[] = [];
			for (const route of currentOutboundRoutes) {
				const nodeType = this.getNodeType(route);
				if (
					(nodeType === GCNodeType.DataStore || nodeType === GCNodeType.Blob) &&
					!nodeId.startsWith(route) &&
					!previousRoutes.includes(route) &&
					!explicitRoutes.includes(route)
				) {
					missingExplicitRoutes.push(route);
				}
			}

			if (missingExplicitRoutes.length > 0) {
				logger.sendErrorEvent({
					eventName: "gcUnknownOutboundReferences",
					...tagCodeArtifacts({
						id: nodeId,
						routes: JSON.stringify(missingExplicitRoutes),
					}),
				});
			}
		}
	}

	/**
	 * Log events that are pending in pendingEventsQueue. This is called after GC runs in the summarizer client
	 * so that the state of an unreferenced node is updated.
	 */
	public async logPendingEvents(logger: ITelemetryLoggerExt) {
		// Events sent come only from the summarizer client. In between summaries, events are pushed to a queue and at
		// summary time they are then logged.
		// Events generated:
		// InactiveObject_Loaded, InactiveObject_Changed, InactiveObject_Revived
		// SweepReadyObject_Loaded, SweepReadyObject_Changed, SweepReadyObject_Revived
		for (const eventProps of this.pendingEventsQueue) {
			// const { usageType, state, id, fromId, ...propsToLog } = eventProps;
			const { usageType, state, id, fromId, headers, gcConfigs, ...detailedProps } =
				eventProps;
			/**
			 * Revived event is logged only if the node is active. If the node is not active, the reference to it was
			 * from another unreferenced node and this scenario is not interesting to log.
			 * Loaded and Changed events are logged only if the node is not active. If the node is active, it was
			 * revived and a Revived event will be logged for it.
			 */
			const nodeStateTracker = this.getNodeStateTracker(eventProps.id.value);
			const active =
				nodeStateTracker === undefined ||
				nodeStateTracker.state === UnreferencedState.Active;
			if ((usageType === "Revived") === active) {
				const pkg = await this.getNodePackagePath(eventProps.id.value);
				const fromPkg = eventProps.fromId
					? await this.getNodePackagePath(eventProps.fromId.value)
					: undefined;
				const event = {
					eventName: `${state}Object_${usageType}`,
					id,
					fromId,
					headers: { ...headers },
					details: detailedProps,
					gcConfigs,
					...tagCodeArtifacts({
						pkg: pkg?.join("/"),
						fromPkg: fromPkg?.join("/"),
					}),
				};
				logger.sendTelemetryEvent(event);
			}
		}
		this.pendingEventsQueue = [];
	}
}

/**
 * Consolidates info / logic for logging when we encounter unexpected usage of GC'd objects. For example, when a
 * tombstoned or deleted object is loaded.
 */
export function sendGCUnexpectedUsageEvent(
	mc: MonitoringContext,
	event: ITelemetryGenericEvent & {
		category: "error" | "generic";
		gcTombstoneEnforcementAllowed: boolean | undefined;
	},
	packagePath: readonly string[] | undefined,
	error?: unknown,
) {
	event.pkg = tagCodeArtifacts({ pkg: packagePath?.join("/") })?.pkg;
	event.tombstoneFlags = JSON.stringify({
		DisableTombstone: mc.config.getBoolean(disableTombstoneKey),
		ThrowOnTombstoneUsage: mc.config.getBoolean(throwOnTombstoneUsageKey),
		ThrowOnTombstoneLoad: mc.config.getBoolean(throwOnTombstoneLoadOverrideKey),
	});
	event.sweepFlags = JSON.stringify({
		EnableSweepFlag: mc.config.getBoolean(runSweepKey),
	});

	mc.logger.sendTelemetryEvent(event, error);
}
