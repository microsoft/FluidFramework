/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import {
	IDeltaManager,
	IDeltaManagerEvents,
	IDeltaQueue,
	IDeltaSender,
	ReadOnlyInfo,
} from "@fluidframework/container-definitions";
import { EventForwarder } from "@fluidframework/common-utils";
import {
	IClientConfiguration,
	IClientDetails,
	IDocumentMessage,
	ISequencedDocumentMessage,
	ISignalMessage,
} from "@fluidframework/protocol-definitions";
import { summarizerClientType } from "./summary";

/**
 * Proxy to the real IDeltaManager for the container runtime. It is used to restrict certain access to the runtime and
 * layers below it.
 */
export class DeltaManagerRuntimeProxy
	extends EventForwarder<IDeltaManagerEvents>
	implements IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>
{
	public get IDeltaSender(): IDeltaSender {
		return this;
	}

	public get inbound(): IDeltaQueue<ISequencedDocumentMessage> {
		return this.deltaManager.inbound;
	}

	public get outbound(): IDeltaQueue<IDocumentMessage[]> {
		return this.deltaManager.outbound;
	}

	public get inboundSignal(): IDeltaQueue<ISignalMessage> {
		return this.deltaManager.inboundSignal;
	}

	public get minimumSequenceNumber(): number {
		return this.deltaManager.minimumSequenceNumber;
	}

	public get lastSequenceNumber(): number {
		return this.deltaManager.lastSequenceNumber;
	}

	public get lastMessage() {
		return this.deltaManager.lastMessage;
	}

	public get lastKnownSeqNumber() {
		return this.deltaManager.lastKnownSeqNumber;
	}

	public get initialSequenceNumber(): number {
		return this.deltaManager.initialSequenceNumber;
	}

	public get hasCheckpointSequenceNumber() {
		return this.deltaManager.hasCheckpointSequenceNumber;
	}

	public get clientDetails(): IClientDetails {
		return this.deltaManager.clientDetails;
	}

	public get version(): string {
		return this.deltaManager.version;
	}

	public get maxMessageSize(): number {
		return this.deltaManager.maxMessageSize;
	}

	public get serviceConfiguration(): IClientConfiguration | undefined {
		return this.deltaManager.serviceConfiguration;
	}

	public get active(): boolean {
		// Summarize clients should not be active. There shouldn't be any local changes (writes) in the summarizer
		// except for the SummarizeOp which is generated by the runtime.
		return this.isSummarizerClient ? false : this.deltaManager.active;
	}

	public get readOnlyInfo(): ReadOnlyInfo {
		// Summarizer clients should be read-only as far as the runtime and layers below are concerned. There shouldn't
		// be any local changes (writes) in the summarizer except for the SummarizeOp which is generated by the runtime.
		if (this.isSummarizerClient) {
			return {
				readonly: true,
				forced: false,
				permissions: true,
				storageOnly: true,
			};
		}
		return this.deltaManager.readOnlyInfo;
	}

	private readonly isSummarizerClient: boolean;

	constructor(
		private readonly deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>,
	) {
		super(deltaManager);
		this.isSummarizerClient = this.deltaManager.clientDetails.type === summarizerClientType;
	}

	public dispose(): void {
		super.dispose();
	}

	public submitSignal(content: any): void {
		return this.deltaManager.submitSignal(content);
	}

	public flush(): void {
		return this.deltaManager.flush();
	}
}
