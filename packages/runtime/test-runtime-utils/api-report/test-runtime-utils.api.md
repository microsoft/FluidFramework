## API Report File for "@fluidframework/test-runtime-utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AttachState } from '@fluidframework/container-definitions';
import { CreateChildSummarizerNodeFn } from '@fluidframework/runtime-definitions';
import { CreateChildSummarizerNodeParam } from '@fluidframework/runtime-definitions';
import { EventEmitter } from '@fluid-internal/client-utils';
import { FluidObject } from '@fluidframework/core-interfaces';
import { FlushMode } from '@fluidframework/runtime-definitions';
import { IAudience } from '@fluidframework/container-definitions';
import { IChannel } from '@fluidframework/datastore-definitions';
import { IChannelServices } from '@fluidframework/datastore-definitions';
import { IChannelStorageService } from '@fluidframework/datastore-definitions';
import { IClientConfiguration } from '@fluidframework/protocol-definitions';
import { IClientDetails } from '@fluidframework/protocol-definitions';
import { IContainerRuntimeBase } from '@fluidframework/runtime-definitions';
import type { IContainerRuntimeEvents } from '@fluidframework/container-runtime-definitions';
import { IdCreationRange } from '@fluidframework/id-compressor';
import { IDeltaConnection } from '@fluidframework/datastore-definitions';
import { IDeltaHandler } from '@fluidframework/datastore-definitions';
import { IDeltaManager } from '@fluidframework/container-definitions';
import { IDeltaManagerEvents } from '@fluidframework/container-definitions';
import { IDeltaQueue } from '@fluidframework/container-definitions';
import { IDocumentMessage } from '@fluidframework/protocol-definitions';
import { IDocumentStorageService } from '@fluidframework/driver-definitions';
import { IFluidDataStoreChannel } from '@fluidframework/runtime-definitions';
import { IFluidDataStoreContext } from '@fluidframework/runtime-definitions';
import { IFluidDataStoreRegistry } from '@fluidframework/runtime-definitions';
import { IFluidDataStoreRuntime } from '@fluidframework/datastore-definitions';
import { IFluidHandle } from '@fluidframework/core-interfaces';
import { IFluidHandleContext } from '@fluidframework/core-interfaces';
import { IGarbageCollectionData } from '@fluidframework/runtime-definitions';
import { IGarbageCollectionDetailsBase } from '@fluidframework/runtime-definitions';
import { IIdCompressor } from '@fluidframework/id-compressor';
import { IIdCompressorCore } from '@fluidframework/id-compressor';
import { ILoader } from '@fluidframework/container-definitions';
import { IQuorumClients } from '@fluidframework/protocol-definitions';
import { IRequest } from '@fluidframework/core-interfaces';
import { IResponse } from '@fluidframework/core-interfaces';
import { ISequencedClient } from '@fluidframework/protocol-definitions';
import { ISequencedDocumentMessage } from '@fluidframework/protocol-definitions';
import { ISignalMessage } from '@fluidframework/protocol-definitions';
import { ISnapshotTree } from '@fluidframework/protocol-definitions';
import { ISummaryTree } from '@fluidframework/protocol-definitions';
import { ISummaryTreeWithStats } from '@fluidframework/runtime-definitions';
import { ITelemetryBaseLogger } from '@fluidframework/core-interfaces';
import { ITelemetryLoggerExt } from '@fluidframework/telemetry-utils';
import { ITokenProvider } from '@fluidframework/routerlicious-driver';
import { ITokenResponse } from '@fluidframework/routerlicious-driver';
import { ITree } from '@fluidframework/protocol-definitions';
import { ITreeEntry } from '@fluidframework/protocol-definitions';
import { IUser } from '@fluidframework/protocol-definitions';
import { MessageType } from '@fluidframework/protocol-definitions';
import { ReadOnlyInfo } from '@fluidframework/container-definitions';
import { ScopeType } from '@fluidframework/protocol-definitions';
import { TypedEventEmitter } from '@fluid-internal/client-utils';
import { VisibilityState } from '@fluidframework/runtime-definitions';

// @internal
export interface IInsecureUser extends IUser {
    name: string;
}

// @alpha
export interface IMockContainerRuntimeOptions {
    readonly enableGroupedBatching?: boolean;
    readonly flushMode?: FlushMode;
}

// @alpha (undocumented)
export interface IMockContainerRuntimePendingMessage {
    // (undocumented)
    clientSequenceNumber: number;
    // (undocumented)
    content: any;
    // (undocumented)
    localOpMetadata: unknown;
    // (undocumented)
    referenceSequenceNumber: number;
}

// @internal
export class InsecureTokenProvider implements ITokenProvider {
    constructor(
    tenantKey: string,
    user: IInsecureUser,
    scopes?: ScopeType[] | undefined);
    fetchOrdererToken(tenantId: string, documentId?: string): Promise<ITokenResponse>;
    fetchStorageToken(tenantId: string, documentId: string): Promise<ITokenResponse>;
}

// @alpha
export class MockContainerRuntime extends TypedEventEmitter<IContainerRuntimeEvents> {
    constructor(dataStoreRuntime: MockFluidDataStoreRuntime, factory: MockContainerRuntimeFactory, mockContainerRuntimeOptions?: IMockContainerRuntimeOptions, overrides?: {
        minimumSequenceNumber?: number | undefined;
    } | undefined);
    // (undocumented)
    protected addPendingMessage(content: any, localOpMetadata: unknown, clientSequenceNumber: number): void;
    // (undocumented)
    clientId: string;
    // (undocumented)
    protected clientSequenceNumber: number;
    // @deprecated (undocumented)
    createDeltaConnection(): MockDeltaConnection;
    // (undocumented)
    protected readonly dataStoreRuntime: MockFluidDataStoreRuntime;
    // @deprecated (undocumented)
    protected readonly deltaConnections: MockDeltaConnection[];
    // (undocumented)
    readonly deltaManager: MockDeltaManager;
    // (undocumented)
    dirty(): void;
    // (undocumented)
    protected readonly factory: MockContainerRuntimeFactory;
    // (undocumented)
    finalizeIdRange(range: IdCreationRange): void;
    flush(): void;
    // (undocumented)
    get isDirty(): boolean;
    // (undocumented)
    protected readonly overrides?: {
        minimumSequenceNumber?: number | undefined;
    } | undefined;
    // (undocumented)
    protected readonly pendingMessages: IMockContainerRuntimePendingMessage[];
    // (undocumented)
    process(message: ISequencedDocumentMessage): void;
    rebase(): void;
    protected get referenceSequenceNumber(): number;
    // (undocumented)
    protected reSubmitMessages(messagesToResubmit: {
        content: any;
        localOpMetadata: unknown;
    }[]): void;
    // (undocumented)
    submit(messageContent: any, localOpMetadata: unknown): number;
}

// @alpha
export class MockContainerRuntimeFactory {
    constructor(mockContainerRuntimeOptions?: IMockContainerRuntimeOptions);
    // (undocumented)
    createContainerRuntime(dataStoreRuntime: MockFluidDataStoreRuntime): MockContainerRuntime;
    // (undocumented)
    getMinSeq(): number;
    protected messages: ISequencedDocumentMessage[];
    // (undocumented)
    minSeq: Map<string, number>;
    // (undocumented)
    get outstandingMessageCount(): number;
    processAllMessages(): void;
    processOneMessage(): void;
    processSomeMessages(count: number): void;
    // (undocumented)
    pushMessage(msg: Partial<ISequencedDocumentMessage>): void;
    // (undocumented)
    readonly quorum: MockQuorumClients;
    // (undocumented)
    removeContainerRuntime(containerRuntime: MockContainerRuntime): void;
    protected readonly runtimeOptions: Required<IMockContainerRuntimeOptions>;
    // (undocumented)
    protected readonly runtimes: Set<MockContainerRuntime>;
    // (undocumented)
    sequenceNumber: number;
}

// @alpha
export class MockContainerRuntimeFactoryForReconnection extends MockContainerRuntimeFactory {
    // (undocumented)
    clearOutstandingClientMessages(clientId: string): void;
    // (undocumented)
    createContainerRuntime(dataStoreRuntime: MockFluidDataStoreRuntime, overrides?: {
        minimumSequenceNumber?: number;
        trackRemoteOps?: boolean;
    }): MockContainerRuntimeForReconnection;
}

// @alpha
export class MockContainerRuntimeForReconnection extends MockContainerRuntime {
    constructor(dataStoreRuntime: MockFluidDataStoreRuntime, factory: MockContainerRuntimeFactoryForReconnection, runtimeOptions?: IMockContainerRuntimeOptions, overrides?: {
        minimumSequenceNumber?: number;
        trackRemoteOps?: boolean;
    });
    // (undocumented)
    get connected(): boolean;
    set connected(connected: boolean);
    // (undocumented)
    protected readonly factory: MockContainerRuntimeFactoryForReconnection;
    // (undocumented)
    initializeWithStashedOps(fromContainerRuntime: MockContainerRuntimeForReconnection): Promise<void>;
    // (undocumented)
    process(message: ISequencedDocumentMessage): void;
    // (undocumented)
    protected setConnectedState(connected: boolean): void;
    // (undocumented)
    submit(messageContent: any, localOpMetadata: unknown): number;
}

// @alpha
export class MockDeltaConnection implements IDeltaConnection {
    constructor(submitFn: (messageContent: any, localOpMetadata: unknown) => number, dirtyFn: () => void);
    // (undocumented)
    applyStashedOp(content: any): unknown;
    // (undocumented)
    attach(handler: IDeltaHandler): void;
    // (undocumented)
    get connected(): boolean;
    // (undocumented)
    dirty(): void;
    // (undocumented)
    handler: IDeltaHandler | undefined;
    // (undocumented)
    process(message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown): void;
    // (undocumented)
    reSubmit(content: any, localOpMetadata: unknown): void;
    // (undocumented)
    setConnectionState(connected: boolean): void;
    // (undocumented)
    submit(messageContent: any, localOpMetadata: unknown): number;
}

// @alpha
export class MockDeltaManager extends TypedEventEmitter<IDeltaManagerEvents> implements IDeltaManager<ISequencedDocumentMessage, IDocumentMessage> {
    constructor();
    // (undocumented)
    readonly active: boolean;
    // (undocumented)
    readonly clientDetails: IClientDetails;
    // (undocumented)
    readonly clientType: string;
    // (undocumented)
    close(): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): any;
    // (undocumented)
    flush(): void;
    // (undocumented)
    hasCheckpointSequenceNumber: boolean;
    // (undocumented)
    get IDeltaSender(): this;
    // (undocumented)
    get inbound(): MockDeltaQueue<ISequencedDocumentMessage>;
    // (undocumented)
    get inboundSignal(): MockDeltaQueue<ISignalMessage>;
    // (undocumented)
    initialSequenceNumber: number;
    // (undocumented)
    readonly lastKnownSeqNumber = 0;
    // (undocumented)
    lastMessage: ISequencedDocumentMessage | undefined;
    // (undocumented)
    lastSequenceNumber: number;
    // (undocumented)
    readonly maxMessageSize: number;
    // (undocumented)
    minimumSequenceNumber: number;
    // (undocumented)
    get outbound(): MockDeltaQueue<IDocumentMessage[]>;
    // (undocumented)
    prepareInboundResponse(type: MessageType, contents: any): void;
    // (undocumented)
    readOnlyInfo: ReadOnlyInfo;
    // (undocumented)
    get serviceConfiguration(): IClientConfiguration;
    // (undocumented)
    submit(type: MessageType, contents: any, batch: boolean | undefined, localOpMetadata: any): number;
    // (undocumented)
    submitSignal(content: any): void;
    // (undocumented)
    get version(): string;
}

// @alpha
export class MockDeltaQueue<T> extends EventEmitter implements IDeltaQueue<T> {
    constructor();
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): any;
    // (undocumented)
    get idle(): boolean;
    // (undocumented)
    get length(): number;
    // (undocumented)
    pause(): Promise<void>;
    // (undocumented)
    protected pauseCount: number;
    // (undocumented)
    get paused(): boolean;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    protected process(): void;
    // (undocumented)
    processCallback: (el: T) => void;
    // (undocumented)
    push(el: T): void;
    // (undocumented)
    protected readonly queue: T[];
    // (undocumented)
    resume(): void;
    // (undocumented)
    toArray(): T[];
    // (undocumented)
    waitTillProcessingDone(): Promise<{
        count: number;
        duration: number;
    }>;
}

// @internal
export class MockEmptyDeltaConnection implements IDeltaConnection {
    // (undocumented)
    attach(handler: any): void;
    // (undocumented)
    connected: boolean;
    // (undocumented)
    dirty(): void;
    // (undocumented)
    submit(messageContent: any): number;
}

// @alpha (undocumented)
export class MockFluidDataStoreContext implements IFluidDataStoreContext {
    constructor(id?: string, existing?: boolean, logger?: ITelemetryLoggerExt, interactive?: boolean);
    attachState: AttachState;
    // (undocumented)
    baseSnapshot: ISnapshotTree | undefined;
    // (undocumented)
    clientDetails: IClientDetails;
    // (undocumented)
    clientId: string | undefined;
    // (undocumented)
    connected: boolean;
    // (undocumented)
    containerRuntime: IContainerRuntimeBase;
    // @deprecated (undocumented)
    createProps?: any;
    // (undocumented)
    deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;
    // (undocumented)
    ensureNoDataModelChanges<T>(callback: () => T): T;
    // (undocumented)
    readonly existing: boolean;
    // (undocumented)
    getAbsoluteUrl(relativeUrl: string): Promise<string | undefined>;
    // (undocumented)
    getAudience(): IAudience;
    // (undocumented)
    getBaseGCDetails(): Promise<IGarbageCollectionDetailsBase>;
    // (undocumented)
    getCreateChildSummarizerNodeFn(id: string, createParam: CreateChildSummarizerNodeParam): CreateChildSummarizerNodeFn;
    // (undocumented)
    getQuorum(): IQuorumClients;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    idCompressor: IIdCompressorCore & IIdCompressor;
    // (undocumented)
    IFluidDataStoreRegistry: IFluidDataStoreRegistry;
    // (undocumented)
    IFluidHandleContext: IFluidHandleContext;
    // (undocumented)
    isLocalDataStore: boolean;
    // (undocumented)
    readonly logger: ITelemetryLoggerExt;
    // (undocumented)
    makeLocallyVisible(): void;
    // (undocumented)
    off(event: string | symbol, listener: (...args: any[]) => void): this;
    // (undocumented)
    on(event: string | symbol, listener: (...args: any[]) => void): this;
    // (undocumented)
    once(event: string | symbol, listener: (...args: any[]) => void): this;
    // (undocumented)
    options: Record<string | number, any>;
    // (undocumented)
    packagePath: readonly string[];
    // (undocumented)
    scope: FluidObject;
    // (undocumented)
    setChannelDirty(address: string): void;
    // (undocumented)
    storage: IDocumentStorageService;
    // (undocumented)
    submitMessage(type: string, content: any, localOpMetadata: unknown): void;
    // (undocumented)
    submitSignal(type: string, content: any): void;
    // (undocumented)
    uploadBlob(blob: ArrayBufferLike): Promise<IFluidHandle<ArrayBufferLike>>;
}

// @alpha
export class MockFluidDataStoreRuntime extends EventEmitter implements IFluidDataStoreRuntime, IFluidDataStoreChannel, IFluidHandleContext {
    constructor(overrides?: {
        clientId?: string;
        entryPoint?: IFluidHandle<FluidObject>;
        id?: string;
        logger?: ITelemetryBaseLogger;
        idCompressor?: IIdCompressor & IIdCompressorCore;
        attachState?: AttachState;
    });
    // (undocumented)
    get absolutePath(): string;
    // @deprecated (undocumented)
    addedGCOutboundReference(srcHandle: IFluidHandle, outboundHandle: IFluidHandle): void;
    // (undocumented)
    applyStashedOp(content: any): Promise<unknown>;
    // (undocumented)
    attachGraph(): void;
    // (undocumented)
    get attachState(): AttachState;
    // (undocumented)
    bind(handle: IFluidHandle): void;
    // (undocumented)
    bindChannel(channel: IChannel): void;
    // (undocumented)
    get channelsRoutingContext(): IFluidHandleContext;
    // (undocumented)
    clientId: string;
    // (undocumented)
    close(): Promise<void>;
    // (undocumented)
    readonly connected = true;
    // (undocumented)
    containerRuntime?: MockContainerRuntime;
    // (undocumented)
    createChannel(id: string, type: string): IChannel;
    // (undocumented)
    createDeltaConnection(): MockDeltaConnection;
    // (undocumented)
    deltaManager: MockDeltaManager;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    // (undocumented)
    readonly documentId: string;
    // (undocumented)
    ensureNoDataModelChanges<T>(callback: () => T): T;
    // (undocumented)
    readonly entryPoint: IFluidHandle<FluidObject>;
    // (undocumented)
    readonly existing: boolean;
    // (undocumented)
    getAttachSnapshot(): ITreeEntry[];
    // (undocumented)
    getAttachSummary(): ISummaryTreeWithStats;
    // (undocumented)
    getAudience(): IAudience;
    // (undocumented)
    getBlob(blobId: string): Promise<any>;
    // (undocumented)
    getChannel(id: string): Promise<IChannel>;
    // (undocumented)
    getGCData(): Promise<IGarbageCollectionData>;
    // (undocumented)
    getQuorum(): IQuorumClients;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    idCompressor?: IIdCompressor & IIdCompressorCore;
    // (undocumented)
    get IFluidHandleContext(): IFluidHandleContext;
    // (undocumented)
    get isAttached(): boolean;
    // (undocumented)
    readonly loader: ILoader;
    // @deprecated (undocumented)
    get local(): boolean;
    set local(local: boolean);
    // (undocumented)
    readonly logger: ITelemetryBaseLogger;
    // (undocumented)
    makeVisibleAndAttachGraph(): void;
    // (undocumented)
    get objectsRoutingContext(): IFluidHandleContext;
    // (undocumented)
    options: Record<string | number, any>;
    // (undocumented)
    readonly path = "";
    // (undocumented)
    process(message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown): void;
    // (undocumented)
    processSignal(message: any, local: boolean): void;
    // (undocumented)
    quorum: MockQuorumClients;
    // (undocumented)
    request(request: IRequest): Promise<IResponse>;
    // (undocumented)
    requestDataStore(request: IRequest): Promise<IResponse>;
    // (undocumented)
    resolveHandle(request: IRequest): Promise<IResponse>;
    // (undocumented)
    reSubmit(content: any, localOpMetadata: unknown): void;
    // (undocumented)
    rollback?(message: any, localOpMetadata: unknown): void;
    // (undocumented)
    get rootRoutingContext(): IFluidHandleContext;
    // (undocumented)
    save(message: string): void;
    // (undocumented)
    setAttachState(attachState: AttachState.Attaching | AttachState.Attached): void;
    // (undocumented)
    setConnectionState(connected: boolean, clientId?: string): void;
    // (undocumented)
    submitMessage(type: MessageType, content: any): null;
    // (undocumented)
    submitSignal(type: string, content: any): null;
    // (undocumented)
    summarize(fullTree?: boolean, trackState?: boolean): Promise<ISummaryTreeWithStats>;
    // (undocumented)
    updateMinSequenceNumber(value: number): void;
    // (undocumented)
    updateUsedRoutes(usedRoutes: string[]): void;
    // (undocumented)
    uploadBlob(blob: ArrayBufferLike): Promise<IFluidHandle<ArrayBufferLike>>;
    // (undocumented)
    get visibilityState(): VisibilityState;
    // (undocumented)
    waitAttached(): Promise<void>;
}

// @alpha
export class MockHandle<T> implements IFluidHandle {
    constructor(value: T, path?: string, absolutePath?: string);
    // (undocumented)
    readonly absolutePath: string;
    // (undocumented)
    attachGraph(): void;
    // (undocumented)
    bind(): void;
    // (undocumented)
    get(): Promise<any>;
    // (undocumented)
    get IFluidHandle(): IFluidHandle;
    // (undocumented)
    get isAttached(): boolean;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    protected readonly value: T;
}

// @alpha
export class MockObjectStorageService implements IChannelStorageService {
    constructor(contents: {
        [key: string]: string;
    });
    // (undocumented)
    contains(path: string): Promise<boolean>;
    // (undocumented)
    list(path: string): Promise<string[]>;
    // (undocumented)
    readBlob(path: string): Promise<ArrayBufferLike>;
}

// @alpha (undocumented)
export class MockQuorumClients implements IQuorumClients, EventEmitter {
    constructor(...members: [string, Partial<ISequencedClient>][]);
    // (undocumented)
    addListener(event: string | number, listener: (...args: any[]) => void): this;
    // (undocumented)
    addMember(id: string, client: Partial<ISequencedClient>): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    disposed: boolean;
    // (undocumented)
    emit(event: string | number, ...args: any[]): boolean;
    // (undocumented)
    eventNames(): (string | number)[];
    // (undocumented)
    getMaxListeners(): number;
    // (undocumented)
    getMember(clientId: string): ISequencedClient | undefined;
    // (undocumented)
    getMembers(): Map<string, ISequencedClient>;
    // (undocumented)
    listenerCount(type: string | number): number;
    // (undocumented)
    listeners(event: string | number): ReturnType<EventEmitter["listeners"]>;
    // (undocumented)
    off(event: string | number, listener: (...args: any[]) => void): this;
    // (undocumented)
    on(event: string | number, listener: (...args: any[]) => void): this;
    // (undocumented)
    once(event: string | number, listener: (...args: any[]) => void): this;
    // (undocumented)
    prependListener(event: string | number, listener: (...args: any[]) => void): this;
    // (undocumented)
    prependOnceListener(event: string | number, listener: (...args: any[]) => void): this;
    // (undocumented)
    rawListeners(event: string | number): ReturnType<EventEmitter["rawListeners"]>;
    // (undocumented)
    removeAllListeners(event?: string | number | undefined): this;
    // (undocumented)
    removeListener(event: string | number, listener: (...args: any[]) => void): this;
    // (undocumented)
    removeMember(id: string): void;
    // (undocumented)
    setMaxListeners(n: number): this;
}

// @alpha
export class MockSharedObjectServices implements IChannelServices {
    constructor(contents: {
        [key: string]: string;
    });
    // (undocumented)
    static createFromSummary(summaryTree: ISummaryTree): MockSharedObjectServices;
    // (undocumented)
    deltaConnection: IDeltaConnection;
    // (undocumented)
    objectStorage: MockObjectStorageService;
}

// @alpha
export class MockStorage implements IChannelStorageService {
    constructor(tree?: ITree | undefined);
    // (undocumented)
    contains(path: string): Promise<boolean>;
    // (undocumented)
    static createFromSummary(summaryTree: ISummaryTree): MockStorage;
    // (undocumented)
    list(path: string): Promise<string[]>;
    // (undocumented)
    readBlob(path: string): Promise<ArrayBufferLike>;
    // (undocumented)
    protected tree?: ITree | undefined;
}

// @internal
export function validateAssertionError(error: Error, expectedErrorMsg: string | RegExp): boolean;

// (No @packageDocumentation comment for this package)

```
