# @fluidframework/test-runtime-utils

Test utilities for the Fluid Framework Runtime. Include mock implementation of various runtime interfaces, as well as a mock logger for validating a particular log sequence.

## Writing unit test for a DDS

Unit tests for DDS fall under three broad categories. The following sections explain how to write a unit test for these categories using the mocks in this package.

### Local unit tests

These are tests that do not require a remote DDS and so doesn't need the DDS to be connected. For example, testing that DDS APIs work correctly, local events are correctly fired, summary is generated and loaded correctly, etc.
To write a unit test for these scenarios, follow these steps:

-   Create a `MockFluidDataStoreRuntime`. The MockFluidDataStoreRuntime doesn't really do anything and is just used to create the DDS.
-   Set the `MockFluidDataStoreRuntime`'s `local` property to `true`. This will make sure that the ops generated by the DDS are not sent out.
-   Use the `MockFluidDataStoreRuntime` to create the DDS.

Examples - [map](../map/src/test/map.spec.ts), [directory](../map/src/test/directory.spec.ts), [matrix](../matrix/test/matrix.spec.ts).

### Remote unit tests

These are tests that require a remote DDS and need the DDS to be connected. For example, testing that the op is correctly applied on a remote client, local op is correctly ack'd, remote events are correctly fired, etc.
To write a unit test for these scenarios, follow these steps:

-   Create a `MockFluidDataStoreRuntime`.
-   Use the `MockFluidDataStoreRuntime` to create the DDS.
-   We need the ability to process messages from multiple DDSes / clients. Create a `MockContainerRuntimeFactory` which stores messages from multiple clients and processes them when required.
-   Create a `MockContainerRuntime` by calling `createContainerRuntime` on the `MockContainerRuntimeFactory`. `MockContainerRuntime` keeps track of the message and localOpMetadata until it is ack'd.
-   We need to connect and attach the DDS to an IDeltaConnection so it can submit and process messages. Create a `MockDeltaConnection` by calling `createDeltaConnection` on the `MockContainerRuntime`.
-   Use the `MockDeltaConnection` to connect the DDS.

Examples - [sequenceHandler](..//../framework/undo-redo/src/test/sequenceHandler.spec.ts), [snapshotVersion](../sequence/src/test/snapshotVersion.spec.ts).

### Reconnection unit tests

These are remote unit tests and in addition they need the capability to disconnect and reconnect the client. For example, testing that on reconnection - DDSes resubmits ops correctly, remote clients receive ops correctly, local clients ack the ops correctly, etc.
To write a unit test for these scenarios, follow these steps:

-   Follow all the steps from scenario 2 above with these changes:
    -   Create `MockContainerRuntimeFactoryForReconnection` instead of `MockContainerRuntimeFactory`.
    -   Create `MockContainerRuntimeForReconnection` instead of `MockContainerRuntime`.
-   To disconnect the client, set `connected = false` on the `MockContainerRuntimeForReconnection`. This will trigger a delete of outstanding messages for this client on the `MockContainerRuntimeFactoryForReconnection`.
-   To reconnect the client, set `connection = true` on the `MockContainerRuntimeForReconnection`. This will trigger a `reSubmit` call on the DDS to resubmit unack'd / unsent ops.

Examples - [sharedString](../sequence/src/test/sharedString.spec.ts), [consensusOrderedCollection](../consensus-ordered-collection/src/test/consensusOrderedCollection.spec.ts), [consensusRegisterCollection](../consensus-register-collection/src/test/consensusRegisterCollection.spec.ts).
