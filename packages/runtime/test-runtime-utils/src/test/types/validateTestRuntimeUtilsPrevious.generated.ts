/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/test-runtime-utils-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IInsecureUser": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IInsecureUser = requireAssignableTo<TypeOnly<old.IInsecureUser>, TypeOnly<current.IInsecureUser>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IInsecureUser": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IInsecureUser = requireAssignableTo<TypeOnly<current.IInsecureUser>, TypeOnly<old.IInsecureUser>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IInternalMockRuntimeMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IInternalMockRuntimeMessage = requireAssignableTo<TypeOnly<old.IInternalMockRuntimeMessage>, TypeOnly<current.IInternalMockRuntimeMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IInternalMockRuntimeMessage": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IInternalMockRuntimeMessage = requireAssignableTo<TypeOnly<current.IInternalMockRuntimeMessage>, TypeOnly<old.IInternalMockRuntimeMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMockContainerRuntimeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMockContainerRuntimeOptions = requireAssignableTo<TypeOnly<old.IMockContainerRuntimeOptions>, TypeOnly<current.IMockContainerRuntimeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMockContainerRuntimeOptions": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMockContainerRuntimeOptions = requireAssignableTo<TypeOnly<current.IMockContainerRuntimeOptions>, TypeOnly<old.IMockContainerRuntimeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMockContainerRuntimePendingMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMockContainerRuntimePendingMessage = requireAssignableTo<TypeOnly<old.IMockContainerRuntimePendingMessage>, TypeOnly<current.IMockContainerRuntimePendingMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMockContainerRuntimePendingMessage": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMockContainerRuntimePendingMessage = requireAssignableTo<TypeOnly<current.IMockContainerRuntimePendingMessage>, TypeOnly<old.IMockContainerRuntimePendingMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_InsecureTokenProvider": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_InsecureTokenProvider = requireAssignableTo<TypeOnly<old.InsecureTokenProvider>, TypeOnly<current.InsecureTokenProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_InsecureTokenProvider": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_InsecureTokenProvider = requireAssignableTo<TypeOnly<current.InsecureTokenProvider>, TypeOnly<old.InsecureTokenProvider>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockAudience": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockAudience = requireAssignableTo<TypeOnly<old.MockAudience>, TypeOnly<current.MockAudience>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockAudience": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockAudience = requireAssignableTo<TypeOnly<current.MockAudience>, TypeOnly<old.MockAudience>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockContainerRuntime": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockContainerRuntime = requireAssignableTo<TypeOnly<old.MockContainerRuntime>, TypeOnly<current.MockContainerRuntime>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockContainerRuntime": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockContainerRuntime = requireAssignableTo<TypeOnly<current.MockContainerRuntime>, TypeOnly<old.MockContainerRuntime>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockContainerRuntimeFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockContainerRuntimeFactory = requireAssignableTo<TypeOnly<old.MockContainerRuntimeFactory>, TypeOnly<current.MockContainerRuntimeFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockContainerRuntimeFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockContainerRuntimeFactory = requireAssignableTo<TypeOnly<current.MockContainerRuntimeFactory>, TypeOnly<old.MockContainerRuntimeFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockContainerRuntimeFactoryForReconnection": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockContainerRuntimeFactoryForReconnection = requireAssignableTo<TypeOnly<old.MockContainerRuntimeFactoryForReconnection>, TypeOnly<current.MockContainerRuntimeFactoryForReconnection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockContainerRuntimeFactoryForReconnection": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockContainerRuntimeFactoryForReconnection = requireAssignableTo<TypeOnly<current.MockContainerRuntimeFactoryForReconnection>, TypeOnly<old.MockContainerRuntimeFactoryForReconnection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockContainerRuntimeForReconnection": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockContainerRuntimeForReconnection = requireAssignableTo<TypeOnly<old.MockContainerRuntimeForReconnection>, TypeOnly<current.MockContainerRuntimeForReconnection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockContainerRuntimeForReconnection": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockContainerRuntimeForReconnection = requireAssignableTo<TypeOnly<current.MockContainerRuntimeForReconnection>, TypeOnly<old.MockContainerRuntimeForReconnection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockDeltaConnection": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockDeltaConnection = requireAssignableTo<TypeOnly<old.MockDeltaConnection>, TypeOnly<current.MockDeltaConnection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockDeltaConnection": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockDeltaConnection = requireAssignableTo<TypeOnly<current.MockDeltaConnection>, TypeOnly<old.MockDeltaConnection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockDeltaManager": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockDeltaManager = requireAssignableTo<TypeOnly<old.MockDeltaManager>, TypeOnly<current.MockDeltaManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockDeltaManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockDeltaManager = requireAssignableTo<TypeOnly<current.MockDeltaManager>, TypeOnly<old.MockDeltaManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockDeltaQueue": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockDeltaQueue = requireAssignableTo<TypeOnly<old.MockDeltaQueue<any>>, TypeOnly<current.MockDeltaQueue<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockDeltaQueue": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockDeltaQueue = requireAssignableTo<TypeOnly<current.MockDeltaQueue<any>>, TypeOnly<old.MockDeltaQueue<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockEmptyDeltaConnection": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockEmptyDeltaConnection = requireAssignableTo<TypeOnly<old.MockEmptyDeltaConnection>, TypeOnly<current.MockEmptyDeltaConnection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockEmptyDeltaConnection": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockEmptyDeltaConnection = requireAssignableTo<TypeOnly<current.MockEmptyDeltaConnection>, TypeOnly<old.MockEmptyDeltaConnection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockFluidDataStoreContext": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockFluidDataStoreContext = requireAssignableTo<TypeOnly<old.MockFluidDataStoreContext>, TypeOnly<current.MockFluidDataStoreContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockFluidDataStoreContext": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockFluidDataStoreContext = requireAssignableTo<TypeOnly<current.MockFluidDataStoreContext>, TypeOnly<old.MockFluidDataStoreContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockFluidDataStoreRuntime": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockFluidDataStoreRuntime = requireAssignableTo<TypeOnly<old.MockFluidDataStoreRuntime>, TypeOnly<current.MockFluidDataStoreRuntime>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockFluidDataStoreRuntime": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockFluidDataStoreRuntime = requireAssignableTo<TypeOnly<current.MockFluidDataStoreRuntime>, TypeOnly<old.MockFluidDataStoreRuntime>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockHandle": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockHandle = requireAssignableTo<TypeOnly<old.MockHandle<any>>, TypeOnly<current.MockHandle<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockHandle": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockHandle = requireAssignableTo<TypeOnly<current.MockHandle<any>>, TypeOnly<old.MockHandle<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockObjectStorageService": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockObjectStorageService = requireAssignableTo<TypeOnly<old.MockObjectStorageService>, TypeOnly<current.MockObjectStorageService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockObjectStorageService": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockObjectStorageService = requireAssignableTo<TypeOnly<current.MockObjectStorageService>, TypeOnly<old.MockObjectStorageService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockQuorumClients": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockQuorumClients = requireAssignableTo<TypeOnly<old.MockQuorumClients>, TypeOnly<current.MockQuorumClients>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockQuorumClients": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockQuorumClients = requireAssignableTo<TypeOnly<current.MockQuorumClients>, TypeOnly<old.MockQuorumClients>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockSharedObjectServices": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockSharedObjectServices = requireAssignableTo<TypeOnly<old.MockSharedObjectServices>, TypeOnly<current.MockSharedObjectServices>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockSharedObjectServices": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockSharedObjectServices = requireAssignableTo<TypeOnly<current.MockSharedObjectServices>, TypeOnly<old.MockSharedObjectServices>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockStorage": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MockStorage = requireAssignableTo<TypeOnly<old.MockStorage>, TypeOnly<current.MockStorage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MockStorage": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MockStorage = requireAssignableTo<TypeOnly<current.MockStorage>, TypeOnly<old.MockStorage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_deepFreeze": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_deepFreeze = requireAssignableTo<TypeOnly<typeof old.deepFreeze>, TypeOnly<typeof current.deepFreeze>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_deepFreeze": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_deepFreeze = requireAssignableTo<TypeOnly<typeof current.deepFreeze>, TypeOnly<typeof old.deepFreeze>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_validateAssertionError": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_validateAssertionError = requireAssignableTo<TypeOnly<typeof old.validateAssertionError>, TypeOnly<typeof current.validateAssertionError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_validateAssertionError": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_validateAssertionError = requireAssignableTo<TypeOnly<typeof current.validateAssertionError>, TypeOnly<typeof old.validateAssertionError>>
