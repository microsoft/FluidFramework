/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { bufferToString, stringToBuffer } from "@fluid-internal/client-utils";
import type { ITelemetryBaseLogger } from "@fluidframework/core-interfaces";
import { assert } from "@fluidframework/core-utils/internal";
import {
	type ITelemetryLoggerExt,
	LoggingError,
	createChildLogger,
} from "@fluidframework/telemetry-utils/internal";

import { FinalSpace } from "./finalSpace.js";
import {
	type FinalCompressedId,
	type LocalCompressedId,
	type NumericUuid,
	isFinalId,
} from "./identifiers.js";
import {
	type Index,
	readBoolean,
	readNumber,
	readNumericUuid,
	writeBoolean,
	writeNumber,
	writeNumericUuid,
} from "./persistanceUtilities.js";
import { SessionSpaceNormalizer } from "./sessionSpaceNormalizer.js";
import {
	type IdCluster,
	Session,
	Sessions,
	getAlignedFinal,
	getAlignedLocal,
	lastFinalizedFinal,
	lastFinalizedLocal,
} from "./sessions.js";
import type {
	CompressorShardId,
	IIdCompressor,
	IIdCompressorCore,
	IdCreationRange,
	OpSpaceCompressedId,
	SerializedIdCompressor,
	SerializedIdCompressorWithNoSession,
	SerializedIdCompressorWithOngoingSession,
	SessionId,
	SessionSpaceCompressedId,
	StableId,
} from "./types/index.js";
import { SerializationVersion } from "./types/index.js";
import {
	createSessionId,
	genCountFromLocalId,
	localIdFromGenCount,
	numericUuidFromStableId,
	offsetNumericUuid,
	stableIdFromNumericUuid,
	subtractNumericUuids,
} from "./utilities.js";

function rangeFinalizationError(expectedStart: number, actualStart: number): LoggingError {
	return new LoggingError("Ranges finalized out of order", {
		expectedStart,
		actualStart,
	});
}

/**
 * See {@link IIdCompressor} and {@link IIdCompressorCore}
 */
export class IdCompressor implements IIdCompressor, IIdCompressorCore {
	/**
	 * Max allowed initial cluster size.
	 */
	public static readonly maxClusterSize = 2 ** 20;

	// #region Local state

	public readonly localSessionId: SessionId;
	private readonly localSession: Session;
	private readonly normalizer = new SessionSpaceNormalizer();
	// The number of IDs generated by the local session
	private localGenCount = 0;

	// #endregion

	// #region Final state

	// The gen count to be annotated on the range returned by the next call to `takeNextCreationRange`.
	// This is updated to be equal to `strideFillCount` + 1 each time it is called.
	private nextRangeBaseGenCount = 1;
	private readonly sessions = new Sessions();
	private readonly finalSpace = new FinalSpace();

	// #endregion

	// #region Ephemeral state

	/**
	 * Roughly equates to a minimum of 1M sessions before we start allocating 64 bit IDs.
	 * Eventually, this can be adjusted dynamically to have cluster reservation policies that
	 * optimize the number of eager finals.
	 * It is not readonly as it is accessed by tests for clear-box testing.
	 */
	// eslint-disable-next-line @typescript-eslint/prefer-readonly
	private nextRequestedClusterSize: number = 512;
	// The number of local IDs generated since the last telemetry was sent.
	private telemetryLocalIdCount = 0;
	// The number of eager final IDs generated since the last telemetry was sent.
	private telemetryEagerFinalIdCount = 0;
	// The ongoing ghost session, if one exists.
	private ongoingGhostSession?: { cluster?: IdCluster; ghostSessionId: SessionId } | undefined;
	/**
	 * The sharding state of this compressor, if it has been sharded or is a shard itself.
	 * When defined, this compressor operates in "sharding mode" where:
	 * - IDs are generated using stride-based allocation (no eager finals)
	 * - The normalizer backfills all IDs in each stride cycle
	 * - Normal operation resumes when activeChildCount reaches 0
	 */
	private shardingState?:
		| {
				/**
				 * Total number of shards in the current stride pattern (the stride)
				 */
				stride: number;
				/**
				 * This compressor's offset in the stride pattern (0 to stride-1)
				 */
				shardOffset: number;
				/**
				 * Counter of how many child shards are still active
				 */
				activeChildCount: number;
				/**
				 * Highest genCount that has been backfilled in the normalizer during sharding.
				 * Used to avoid duplicate backfilling in recursive sharding scenarios.
				 */
				highestBackfilledGenCount: number;
		  }
		| undefined;

	// #endregion

	/**
	 * The version of the document this compressor was created from or deserialized from.
	 * This version determines what features are available and what format will be used for serialization.
	 * Documents with version less than 3 cannot use sharding.
	 */
	private readonly writeVersion: SerializationVersion;

	public constructor(
		localSessionIdOrDeserialized: SessionId | Sessions,
		private readonly logger: ITelemetryLoggerExt | undefined,
		writeVersion: SerializationVersion,
	) {
		if (typeof localSessionIdOrDeserialized === "string") {
			this.localSessionId = localSessionIdOrDeserialized;
			this.localSession = this.sessions.getOrCreate(localSessionIdOrDeserialized);
			this.writeVersion = writeVersion;
		} else {
			// Deserialize case
			this.sessions = localSessionIdOrDeserialized;
			// As policy, the first session is always the local session. Preserve this invariant
			// during deserialization.
			const firstSession = localSessionIdOrDeserialized.sessions().next();
			assert(!firstSession.done, 0x754 /* First session must be present. */);
			this.localSession = firstSession.value;
			this.localSessionId = stableIdFromNumericUuid(
				this.localSession.sessionUuid,
			) as SessionId;
			// Deserialized documents must specify their version
			assert(
				writeVersion !== undefined,
				"Document version must be specified when deserializing",
			);
			this.writeVersion = writeVersion;
		}
	}

	public generateCompressedId(): SessionSpaceCompressedId {
		// This ghost session code inside this block should not be changed without a version bump (it is performed at a consensus point)
		if (this.ongoingGhostSession) {
			if (this.ongoingGhostSession.cluster === undefined) {
				this.ongoingGhostSession.cluster = this.addEmptyCluster(
					this.sessions.getOrCreate(this.ongoingGhostSession.ghostSessionId),
					1,
				);
			} else {
				this.ongoingGhostSession.cluster.capacity++;
			}
			this.ongoingGhostSession.cluster.count++;
			return lastFinalizedFinal(
				this.ongoingGhostSession.cluster,
			) as unknown as SessionSpaceCompressedId;
		}

		// In sharding mode, always generate local IDs with stride-based allocation
		// Never use eager finals to maintain consistency across shards
		if (this.shardingState !== undefined) {
			this.telemetryLocalIdCount++;
			return this.generateNextLocalIdWithStride();
		}

		// Normal ID generation
		this.localGenCount++;
		const lastCluster = this.localSession.getLastCluster();
		if (lastCluster === undefined) {
			this.telemetryLocalIdCount++;
			return this.generateNextLocalId();
		}

		// If there exists a cluster of final IDs already claimed by the local session that still has room in it,
		// it is known prior to range sequencing what a local ID's corresponding final ID will be.
		// In this case, it is safe to return the final ID immediately. This is guaranteed to be safe because
		// any op that the local session sends that contains one of those final IDs are guaranteed to arrive to
		// collaborators *after* the one containing the creation range.
		const clusterOffset = this.localGenCount - genCountFromLocalId(lastCluster.baseLocalId);
		if (lastCluster.capacity > clusterOffset) {
			this.telemetryEagerFinalIdCount++;
			// Space in the cluster: eager final
			return ((lastCluster.baseFinalId as number) + clusterOffset) as SessionSpaceCompressedId;
		}
		// No space in the cluster, return next local
		this.telemetryLocalIdCount++;
		return this.generateNextLocalId();
	}

	public generateDocumentUniqueId():
		| (SessionSpaceCompressedId & OpSpaceCompressedId)
		| StableId {
		const id = this.generateCompressedId();
		return isFinalId(id) ? id : this.decompress(id);
	}

	/**
	 * Starts a ghost session. Only exposed for test purposes (this class is not exported from the package).
	 * @param ghostSessionId - The session ID to start the ghost session with.
	 */
	public startGhostSession(ghostSessionId: SessionId): void {
		assert(!this.ongoingGhostSession, 0x8fe /* Ghost session already in progress. */);
		this.ongoingGhostSession = { ghostSessionId };
	}

	/**
	 * {@inheritdoc IIdCompressorCore.beginGhostSession}
	 */
	public beginGhostSession(ghostSessionId: SessionId, ghostSessionCallback: () => void): void {
		this.startGhostSession(ghostSessionId);
		try {
			ghostSessionCallback();
		} finally {
			this.ongoingGhostSession = undefined;
		}
	}

	/**
	 * {@inheritdoc IIdCompressorCore.shard}
	 */
	public shard(newShardCount: number): SerializedIdCompressorWithOngoingSession[] {
		if (newShardCount <= 0) {
			throw new Error("Shard count must be positive");
		}
		if (newShardCount > 1000) {
			throw new Error("Shard count too large - recommend < 1000 shards");
		}
		if (this.ongoingGhostSession) {
			throw new Error("Cannot shard during ghost session");
		}
		if (this.writeVersion < SerializationVersion.V3) {
			throw new Error(
				`Sharding requires document version ${SerializationVersion.V3} or higher, but this document is version ${this.writeVersion}`,
			);
		}

		// Determine current sharding state
		const currentStride = this.shardingState?.stride ?? 1;
		const currentOffset = this.shardingState?.shardOffset ?? 0;
		const currentActiveCount = this.shardingState?.activeChildCount ?? 0;

		// Calculate new stride: parent and all children share this stride
		const newTotalShards = currentStride * (newShardCount + 1);

		// Store parent's localGenCount before creating shards
		const parentLocalGenCountBeforeShard = this.localGenCount;

		// Update parent compressor's sharding state
		const previousHighestBackfilled =
			this.shardingState?.highestBackfilledGenCount ?? parentLocalGenCountBeforeShard;
		this.shardingState = {
			stride: newTotalShards,
			shardOffset: currentOffset, // Parent keeps its offset
			activeChildCount: currentActiveCount + newShardCount,
			// Preserve the highest backfilled genCount from previous sharding, or use current localGenCount if first shard
			highestBackfilledGenCount: previousHighestBackfilled,
		};

		// Create serialized shards for each child
		// Children use the parent's ORIGINAL localGenCount (before recalculation) to determine their own
		const shards: SerializedIdCompressorWithOngoingSession[] = [];

		for (let i = 1; i <= newShardCount; i++) {
			const childOffset = currentOffset + i * currentStride;

			// Create a child shard with the correct sharding state
			// Pass the original parent localGenCount so child can calculate correctly
			const childShard = this.createChildShard(
				newTotalShards,
				childOffset,
				parentLocalGenCountBeforeShard,
			);
			shards.push(childShard);
		}

		// Update parent's localGenCount to reflect the stride-based view
		// Parent now only "owns" its stride's genCounts, so recalculate how many of those it has generated
		const completedCycles = Math.floor(parentLocalGenCountBeforeShard / newTotalShards);
		const idsInIncompleteCycle = parentLocalGenCountBeforeShard % newTotalShards;
		this.localGenCount = completedCycles + (currentOffset < idsInIncompleteCycle ? 1 : 0);

		return shards;
	}

	/**
	 * Helper method to create a child shard with specific sharding state.
	 * Creates a serialized compressor that has:
	 * - Same finalized state (clusters, sessions) as parent
	 * - Same normalizer as parent (child is a fork and recognizes pre-shard IDs)
	 * - Calculated localGenCount based on parent's count and child's offset
	 * - Specified sharding state
	 */
	private createChildShard(
		stride: number,
		shardOffset: number,
		parentLocalGenCountBeforeShard: number,
	): SerializedIdCompressorWithOngoingSession {
		// Temporarily store parent's sharding state
		const parentShardingState = this.shardingState;
		const parentOriginalLocalGenCount = this.localGenCount;

		// Calculate child's starting localGenCount
		// The child "inherits" responsibility for its stride's genCounts that were generated pre-shard
		// For example, if parent generated genCounts 1,2,3 and we shard with stride=3:
		//   - Offset 0 owns genCounts {1,4,7,...}, has generated 1, so localGenCount=1
		//   - Offset 1 owns genCounts {2,5,8,...}, has generated 1, so localGenCount=1
		//   - Offset 2 owns genCounts {3,6,9,...}, has generated 1, so localGenCount=1
		const parentHighestBackfilled =
			parentShardingState?.highestBackfilledGenCount ?? parentLocalGenCountBeforeShard;

		// Set child's sharding state
		this.shardingState = {
			stride,
			shardOffset,
			activeChildCount: 0, // Child has no children initially
			// Inherit parent's highest backfilled genCount to avoid re-backfilling
			highestBackfilledGenCount: parentHighestBackfilled,
		};
		const completedCycles = Math.floor(parentLocalGenCountBeforeShard / stride);
		const idsInIncompleteCycle = parentLocalGenCountBeforeShard % stride;
		const childLocalGenCount = completedCycles + (shardOffset < idsInIncompleteCycle ? 1 : 0);

		// Temporarily set to child's localGenCount for serialization
		this.localGenCount = childLocalGenCount;

		// Serialize with the child's state
		// Child inherits parent's normalizer (they share the same session and need to recognize pre-shard IDs)
		const childSerialized = this.serialize(true);

		// Restore parent's state
		this.localGenCount = parentOriginalLocalGenCount;
		this.shardingState = parentShardingState;

		return childSerialized;
	}

	/**
	 * {@inheritdoc IIdCompressorCore.unshard}
	 */
	public unshard(shardId: CompressorShardId): void {
		if (this.writeVersion < SerializationVersion.V3) {
			throw new Error(
				`Sharding requires document version ${SerializationVersion.V3} or higher, but this document is version ${this.writeVersion}`,
			);
		}
		if (shardId.sessionId !== this.localSessionId) {
			throw new Error("Shard must belong to this session");
		}
		if (this.shardingState === undefined) {
			throw new Error("Must be in sharding mode");
		}
		if (this.shardingState.activeChildCount <= 0) {
			throw new Error("No active shards to unshard");
		}

		// Calculate the highest genCount that needs to be covered by the child's generation
		const highestGenCount = shardId.strideFillCount * this.shardingState.stride;

		// Backfill normalizer for any genCounts not yet covered
		this.backfillNormalizerToGenCount(highestGenCount);

		// Advance localGenCount to cover all IDs generated by any shard up to the child's highest
		this.localGenCount = Math.max(this.localGenCount, highestGenCount);

		// Decrement active shard counter
		this.shardingState.activeChildCount--;

		// Exit sharding mode if all shards have been returned
		if (this.shardingState.activeChildCount === 0) {
			this.shardingState = undefined;
			// Future generateCompressedId() calls will check for eager finals again
		}
	}

	/**
	 * {@inheritdoc IIdCompressorCore.shardId}
	 */
	public shardId(): CompressorShardId | undefined {
		if (this.writeVersion < SerializationVersion.V3) {
			throw new Error(
				`Sharding requires document version ${SerializationVersion.V3} or higher, but this document is version ${this.writeVersion}`,
			);
		}
		if (this.shardingState === undefined) {
			return undefined;
		}

		return {
			sessionId: this.localSessionId,
			shardId: this.shardingState.shardOffset,
			strideFillCount: this.localGenCount,
		};
	}

	private generateNextLocalId(): LocalCompressedId {
		// Must tell the normalizer that we generated a local ID
		this.normalizer.addLocalRange(this.localGenCount, 1);
		return localIdFromGenCount(this.localGenCount);
	}

	/**
	 * Backfills the normalizer with genCounts up to the target, avoiding duplicates.
	 * Used during sharding to ensure the normalizer knows about all IDs in a stride cycle.
	 * @param targetGenCount - The highest genCount to backfill up to (inclusive)
	 */
	private backfillNormalizerToGenCount(targetGenCount: number): void {
		assert(this.shardingState !== undefined, "Must be in sharding mode");

		if (targetGenCount > this.shardingState.highestBackfilledGenCount) {
			const startGenCount = Math.max(this.shardingState.highestBackfilledGenCount + 1, 1);
			const countToAdd = targetGenCount - startGenCount + 1;
			if (countToAdd > 0) {
				this.normalizer.addLocalRange(startGenCount, countToAdd);
				this.shardingState.highestBackfilledGenCount = targetGenCount;
			}
		}
	}

	/**
	 * Generates the next local ID using stride-based allocation for sharding mode.
	 * This method:
	 * 1. Calculates the genCount for the ID based on the shard's offset and stride
	 * 2. Backfills the normalizer with ALL IDs in the current stride cycle
	 * 3. Increments localGenCount
	 * 4. Returns the local ID
	 */
	private generateNextLocalIdWithStride(): LocalCompressedId {
		assert(this.shardingState !== undefined, "Must be in sharding mode");

		const { stride, shardOffset } = this.shardingState;

		// Calculate the genCount for the ID we're about to generate
		// Formula: offset + 1 + (count * stride)
		// Example: offset=0, stride=3, count=0 → genCount=1 (ID -1)
		//          offset=1, stride=3, count=0 → genCount=2 (ID -2)
		const genCount = shardOffset + 1 + this.localGenCount * stride;

		// Backfill normalizer with ALL IDs in this stride cycle
		// This ensures the normalizer knows about IDs generated by other shards in this cycle
		// Example: stride=3, count=0 → add range [1, 3] covering genCounts 1-3 (IDs -1,-2,-3)
		const cycleEndGenCount = (this.localGenCount + 1) * stride;
		this.backfillNormalizerToGenCount(cycleEndGenCount);

		this.localGenCount++;

		// Convert genCount to local ID
		return localIdFromGenCount(genCount);
	}

	public takeNextCreationRange(): IdCreationRange {
		assert(
			!this.ongoingGhostSession,
			0x8a6 /* IdCompressor should not be operated normally when in a ghost session */,
		);
		const count = this.localGenCount - (this.nextRangeBaseGenCount - 1);
		if (count === 0) {
			return {
				sessionId: this.localSessionId,
			};
		}
		const range: IdCreationRange = {
			sessionId: this.localSessionId,
			ids: {
				firstGenCount: this.nextRangeBaseGenCount,
				count,
				requestedClusterSize: this.nextRequestedClusterSize,
				localIdRanges: this.normalizer.getRangesBetween(
					this.nextRangeBaseGenCount,
					this.localGenCount,
				),
			},
		};
		return this.updateToRange(range);
	}

	public takeUnfinalizedCreationRange(): IdCreationRange {
		const lastLocalCluster = this.localSession.getLastCluster();
		let count: number;
		let firstGenCount: number;
		if (lastLocalCluster === undefined) {
			firstGenCount = 1;
			count = this.localGenCount;
		} else {
			firstGenCount = genCountFromLocalId(
				(lastLocalCluster.baseLocalId - lastLocalCluster.count) as LocalCompressedId,
			);
			count = this.localGenCount - firstGenCount + 1;
		}

		if (count === 0) {
			return {
				sessionId: this.localSessionId,
			};
		}

		const range: IdCreationRange = {
			ids: {
				count,
				firstGenCount,
				localIdRanges: this.normalizer.getRangesBetween(firstGenCount, this.localGenCount),
				requestedClusterSize: this.nextRequestedClusterSize,
			},
			sessionId: this.localSessionId,
		};
		return this.updateToRange(range);
	}

	private updateToRange(range: IdCreationRange): IdCreationRange {
		this.nextRangeBaseGenCount = this.localGenCount + 1;
		return IdCompressor.assertValidRange(range);
	}

	private static assertValidRange(range: IdCreationRange): IdCreationRange {
		if (range.ids === undefined) {
			return range;
		}
		const { count, requestedClusterSize } = range.ids;
		assert(count > 0, 0x755 /* Malformed ID Range. */);
		assert(requestedClusterSize > 0, 0x876 /* Clusters must have a positive capacity. */);
		assert(
			requestedClusterSize <= IdCompressor.maxClusterSize,
			0x877 /* Clusters must not exceed max cluster size. */,
		);
		return range;
	}

	public finalizeCreationRange(range: IdCreationRange): void {
		assert(
			!this.ongoingGhostSession,
			0x8a7 /* IdCompressor should not be operated normally when in a ghost session */,
		);
		// Check if the range has IDs
		if (range.ids === undefined) {
			return;
		}

		IdCompressor.assertValidRange(range);
		const { sessionId, ids } = range;
		const { count, firstGenCount, requestedClusterSize } = ids;
		const session = this.sessions.getOrCreate(sessionId);
		const isLocal = session === this.localSession;
		const rangeBaseLocal = localIdFromGenCount(firstGenCount);
		let lastCluster = session.getLastCluster();
		if (lastCluster === undefined) {
			// This is the first cluster in the session space
			if (rangeBaseLocal !== -1) {
				throw rangeFinalizationError(-1, rangeBaseLocal);
			}
			lastCluster = this.addEmptyCluster(session, requestedClusterSize + count);
			if (isLocal) {
				this.logger?.sendTelemetryEvent({
					eventName: "RuntimeIdCompressor:FirstCluster",
					sessionId: this.localSessionId,
				});
			}
		}

		const remainingCapacity = lastCluster.capacity - lastCluster.count;
		if (lastCluster.baseLocalId - lastCluster.count !== rangeBaseLocal) {
			throw rangeFinalizationError(
				lastCluster.baseLocalId - lastCluster.count,
				rangeBaseLocal,
			);
		}

		if (remainingCapacity >= count) {
			// The current range fits in the existing cluster
			lastCluster.count += count;
		} else {
			const overflow = count - remainingCapacity;
			const newClaimedFinalCount = overflow + requestedClusterSize;
			if (lastCluster === this.finalSpace.getLastCluster()) {
				// The last cluster in the sessions chain is the last cluster globally, so it can be expanded.
				lastCluster.capacity += newClaimedFinalCount;
				lastCluster.count += count;
				assert(
					!this.sessions.clusterCollides(lastCluster),
					0x756 /* Cluster collision detected. */,
				);
				if (isLocal) {
					this.logger?.sendTelemetryEvent({
						eventName: "RuntimeIdCompressor:ClusterExpansion",
						sessionId: this.localSessionId,
						previousCapacity: lastCluster.capacity - newClaimedFinalCount,
						newCapacity: lastCluster.capacity,
						overflow,
					});
				}
			} else {
				// The last cluster in the sessions chain is *not* the last cluster globally. Fill and overflow to new.
				lastCluster.count = lastCluster.capacity;
				const newCluster = this.addEmptyCluster(session, newClaimedFinalCount);
				newCluster.count += overflow;
				if (isLocal) {
					this.logger?.sendTelemetryEvent({
						eventName: "RuntimeIdCompressor:NewCluster",
						sessionId: this.localSessionId,
					});
				}
			}
		}

		if (isLocal) {
			this.logger?.sendTelemetryEvent({
				eventName: "RuntimeIdCompressor:IdCompressorStatus",
				eagerFinalIdCount: this.telemetryEagerFinalIdCount,
				localIdCount: this.telemetryLocalIdCount,
				sessionId: this.localSessionId,
			});
			this.telemetryEagerFinalIdCount = 0;
			this.telemetryLocalIdCount = 0;
		}

		assert(!session.isEmpty(), 0x757 /* Empty sessions should not be created. */);
	}

	private addEmptyCluster(session: Session, capacity: number): IdCluster {
		assert(
			!this.ongoingGhostSession?.cluster,
			0x8a8 /* IdCompressor should not be operated normally when in a ghost session */,
		);
		const newCluster = session.addNewCluster(
			this.finalSpace.getAllocatedIdLimit(),
			capacity,
			0,
		);
		assert(
			!this.sessions.clusterCollides(newCluster),
			0x758 /* Cluster collision detected. */,
		);
		this.finalSpace.addCluster(newCluster);
		return newCluster;
	}

	public normalizeToOpSpace(id: SessionSpaceCompressedId): OpSpaceCompressedId {
		if (isFinalId(id)) {
			return id;
		} else {
			const local = id as unknown as LocalCompressedId;
			if (!this.normalizer.contains(local)) {
				throw new Error("Invalid ID to normalize.");
			}
			const finalForm = this.localSession.tryConvertToFinal(local, true);
			return finalForm === undefined
				? (local as unknown as OpSpaceCompressedId)
				: (finalForm as OpSpaceCompressedId);
		}
	}

	public normalizeToSessionSpace(
		id: OpSpaceCompressedId,
		originSessionId: SessionId,
	): SessionSpaceCompressedId {
		if (isFinalId(id)) {
			const containingCluster = this.localSession.getClusterByAllocatedFinal(id);
			if (containingCluster === undefined) {
				// Does not exist in local cluster chain
				if (id >= this.finalSpace.getFinalizedIdLimit()) {
					throw new Error("Unknown op space ID.");
				}
				return id as unknown as SessionSpaceCompressedId;
			} else {
				const alignedLocal = getAlignedLocal(containingCluster, id);
				if (this.normalizer.contains(alignedLocal)) {
					return alignedLocal;
				} else {
					if (genCountFromLocalId(alignedLocal) > this.localGenCount) {
						throw new Error("Unknown op space ID.");
					}
					return id as unknown as SessionSpaceCompressedId;
				}
			}
		} else {
			const localToNormalize = id as unknown as LocalCompressedId;
			if (originSessionId === this.localSessionId) {
				if (this.normalizer.contains(localToNormalize)) {
					return localToNormalize;
				} else {
					// We never generated this local ID, so fail
					throw new Error("Unknown op space ID.");
				}
			} else {
				// LocalId from a remote session
				const remoteSession = this.sessions.get(originSessionId);
				if (remoteSession === undefined) {
					throw new Error("No IDs have ever been finalized by the supplied session.");
				}
				const correspondingFinal = remoteSession.tryConvertToFinal(localToNormalize, false);
				if (correspondingFinal === undefined) {
					throw new Error("Unknown op space ID.");
				}
				return correspondingFinal as unknown as SessionSpaceCompressedId;
			}
		}
	}

	public decompress(id: SessionSpaceCompressedId): StableId {
		if (isFinalId(id)) {
			const containingCluster = Session.getContainingCluster(id, this.finalSpace.clusters);
			if (containingCluster === undefined) {
				throw new Error("Unknown ID");
			}
			const alignedLocal = getAlignedLocal(containingCluster, id);
			const alignedGenCount = genCountFromLocalId(alignedLocal);
			const lastFinalizedGenCount = genCountFromLocalId(lastFinalizedLocal(containingCluster));
			if (alignedGenCount > lastFinalizedGenCount) {
				// should be an eager final id generated by the local session
				if (containingCluster.session === this.localSession) {
					assert(!this.normalizer.contains(alignedLocal), 0x759 /* Normalizer out of sync. */);
				} else {
					throw new Error("Unknown ID");
				}
			}

			return stableIdFromNumericUuid(
				offsetNumericUuid(containingCluster.session.sessionUuid, alignedGenCount - 1),
			);
		} else {
			const localToDecompress = id as unknown as LocalCompressedId;
			if (!this.normalizer.contains(localToDecompress)) {
				throw new Error("Unknown ID");
			}
			return stableIdFromNumericUuid(
				offsetNumericUuid(
					this.localSession.sessionUuid,
					genCountFromLocalId(localToDecompress) - 1,
				),
			);
		}
	}

	public recompress(uncompressed: StableId): SessionSpaceCompressedId {
		const recompressed = this.tryRecompress(uncompressed);
		if (recompressed === undefined) {
			throw new Error("Could not recompress.");
		}
		return recompressed;
	}

	public tryRecompress(uncompressed: StableId): SessionSpaceCompressedId | undefined {
		const match = this.sessions.getContainingCluster(uncompressed);
		if (match === undefined) {
			const numericUncompressed = numericUuidFromStableId(uncompressed);
			const offset = subtractNumericUuids(numericUncompressed, this.localSession.sessionUuid);
			if (offset < Number.MAX_SAFE_INTEGER) {
				const genCountEquivalent = Number(offset) + 1;
				const localEquivalent = localIdFromGenCount(genCountEquivalent);
				if (this.normalizer.contains(localEquivalent)) {
					return localEquivalent;
				}
			}
			return undefined;
		} else {
			const [containingCluster, alignedLocal] = match;
			if (containingCluster.session === this.localSession) {
				// Local session
				if (this.normalizer.contains(alignedLocal)) {
					return alignedLocal;
				} else {
					assert(
						genCountFromLocalId(alignedLocal) <= this.localGenCount,
						0x75a /* Clusters out of sync. */,
					);
					// Id is an eager final
					return getAlignedFinal(containingCluster, alignedLocal) as
						| SessionSpaceCompressedId
						| undefined;
				}
			} else {
				// Not the local session
				return genCountFromLocalId(alignedLocal) >= lastFinalizedLocal(containingCluster)
					? (getAlignedFinal(containingCluster, alignedLocal) as
							| SessionSpaceCompressedId
							| undefined)
					: undefined;
			}
		}
	}

	public serialize(withSession: true): SerializedIdCompressorWithOngoingSession;
	public serialize(withSession: false): SerializedIdCompressorWithNoSession;
	public serialize(hasLocalState: boolean): SerializedIdCompressor {
		assert(
			!this.ongoingGhostSession,
			0x8a9 /* IdCompressor should not be operated normally when in a ghost session */,
		);
		const { normalizer, finalSpace, sessions, localGenCount, logger, nextRangeBaseGenCount } =
			this;
		const sessionIndexMap = new Map<Session, number>();
		let sessionIndex = 0;
		for (const session of sessions.sessions()) {
			// Filter empty sessions to prevent them accumulating in the serialized state
			if (!session.isEmpty() || hasLocalState) {
				sessionIndexMap.set(session, sessionIndex);
				sessionIndex++;
			}
		}
		const shardingStateSize =
			hasLocalState && this.writeVersion >= SerializationVersion.V3
				? this.shardingState === undefined
					? 1 // just the boolean indicating no sharding state
					: 1 + // has sharding state boolean
						4 // stride, shardOffset, activeChildCount, highestBackfilledGenCount
				: 0;
		const localStateSize = hasLocalState
			? 1 + // generated ID count
				1 + // next range base genCount
				1 + // count of normalizer pairs
				normalizer.idRanges.size * 2 + // pairs
				shardingStateSize // sharding state if present
			: 0;
		// Layout size, in 8 byte increments
		const totalSize =
			1 + // version
			1 + // hasLocalState
			1 + // session count
			1 + // cluster count
			sessionIndexMap.size * 2 + // session IDs
			finalSpace.clusters.length * 3 + // clusters: (sessionIndex, capacity, count)[]
			localStateSize; // local state, if present

		const serializedFloat = new Float64Array(totalSize);
		const serializedUint = new BigUint64Array(serializedFloat.buffer);
		let index = 0;
		index = writeNumber(serializedFloat, index, this.writeVersion);
		index = writeBoolean(serializedFloat, index, hasLocalState);
		index = writeNumber(serializedFloat, index, sessionIndexMap.size);
		index = writeNumber(serializedFloat, index, finalSpace.clusters.length);

		for (const [session] of sessionIndexMap.entries()) {
			index = writeNumericUuid(serializedUint, index, session.sessionUuid);
		}

		for (const cluster of finalSpace.clusters) {
			index = writeNumber(
				serializedFloat,
				index,
				sessionIndexMap.get(cluster.session) as number,
			);
			index = writeNumber(serializedFloat, index, cluster.capacity);
			index = writeNumber(serializedFloat, index, cluster.count);
		}

		if (hasLocalState) {
			index = writeNumber(serializedFloat, index, localGenCount);
			index = writeNumber(serializedFloat, index, nextRangeBaseGenCount);
			index = writeNumber(serializedFloat, index, normalizer.idRanges.size);
			for (const [leadingGenCount, count] of normalizer.idRanges.entries()) {
				index = writeNumber(serializedFloat, index, leadingGenCount);
				index = writeNumber(serializedFloat, index, count);
			}

			// Write sharding state (version 3+)
			if (this.writeVersion >= SerializationVersion.V3) {
				index = writeBoolean(serializedFloat, index, this.shardingState !== undefined);
				if (this.shardingState !== undefined) {
					index = writeNumber(serializedFloat, index, this.shardingState.stride);
					index = writeNumber(serializedFloat, index, this.shardingState.shardOffset);
					index = writeNumber(serializedFloat, index, this.shardingState.activeChildCount);
					index = writeNumber(
						serializedFloat,
						index,
						this.shardingState.highestBackfilledGenCount,
					);
				}
			}
		}

		assert(index === totalSize, 0x75b /* Serialized size was incorrectly calculated. */);
		logger?.sendTelemetryEvent({
			eventName: "RuntimeIdCompressor:SerializedIdCompressorSize",
			size: serializedFloat.byteLength,
			clusterCount: finalSpace.clusters.length,
			sessionCount: sessionIndexMap.size,
		});

		return bufferToString(serializedFloat.buffer, "base64") as SerializedIdCompressor;
	}

	public static deserialize(
		params:
			| {
					serialized: SerializedIdCompressorWithOngoingSession;
					requestedWriteVersion: SerializationVersion;
					logger?: ITelemetryLoggerExt | undefined;
					newSessionId?: never;
			  }
			| {
					serialized: SerializedIdCompressorWithNoSession;
					newSessionId: SessionId;
					requestedWriteVersion: SerializationVersion;
					logger?: ITelemetryLoggerExt | undefined;
			  },
	): IdCompressor {
		const { serialized, newSessionId, logger, requestedWriteVersion } = params;
		const buffer = stringToBuffer(serialized, "base64");
		const index: Index = {
			index: 0,
			bufferFloat: new Float64Array(buffer),
			bufferUint: new BigUint64Array(buffer),
		};
		const serializedVersion = readNumber(index);
		// If requested version is < the serialized version, we must write the version serialized
		// to avoid losing data.
		const writeVersion = Math.max(requestedWriteVersion, serializedVersion) as SerializationVersion;
		switch (serializedVersion) {
			case 1: {
				throw new Error("IdCompressor version 1.0 is no longer supported.");
			}
			case 2: {
				return IdCompressor.deserialize2_0(index, newSessionId, logger, writeVersion);
			}
			case 3: {
				return IdCompressor.deserialize3_0(index, newSessionId, logger, writeVersion);
			}
			default: {
				throw new Error("Unknown IdCompressor serialized version.");
			}
		}
	}

	/**
	 * Common deserialization logic shared between version 2.0 and 3.0.
	 * Version 3.0 adds optional sharding state to the local state section.
	 */
	private static deserializeCommon(
		index: Index,
		sessionId: SessionId | undefined,
		logger: ITelemetryLoggerExt | undefined,
		version: SerializationVersion,
	): IdCompressor {
		const hasLocalState = readBoolean(index);
		const sessionCount = readNumber(index);
		const clusterCount = readNumber(index);

		// Sessions
		let sessionOffset = 0;
		const sessions: [NumericUuid, Session][] = [];
		if (hasLocalState) {
			assert(
				sessionId === undefined,
				0x75e /* Local state should not exist in serialized form. */,
			);
		} else {
			// If !hasLocalState, there won't be a serialized local session ID so insert one at the beginning
			assert(sessionId !== undefined, 0x75d /* Local session ID is undefined. */);
			const localSessionNumeric = numericUuidFromStableId(sessionId);
			sessions.push([localSessionNumeric, new Session(localSessionNumeric)]);
			sessionOffset = 1;
		}

		for (let i = 0; i < sessionCount; i++) {
			const numeric = readNumericUuid(index);
			sessions.push([numeric, new Session(numeric)]);
		}

		const compressor = new IdCompressor(new Sessions(sessions), logger, version);

		// Clusters
		let baseFinalId = 0;
		for (let i = 0; i < clusterCount; i++) {
			const sessionIndex = readNumber(index);
			const sessionArray = sessions[sessionIndex + sessionOffset];
			assert(
				sessionArray !== undefined,
				0x9d8 /* sessionArray is undefined in IdCompressor.deserialize2_0 */,
			);
			const session = sessionArray[1];
			const capacity = readNumber(index);
			const count = readNumber(index);
			const cluster = session.addNewCluster(baseFinalId as FinalCompressedId, capacity, count);
			compressor.finalSpace.addCluster(cluster);
			baseFinalId += capacity;
		}

		// Local state
		if (hasLocalState) {
			compressor.localGenCount = readNumber(index);
			compressor.nextRangeBaseGenCount = readNumber(index);
			const normalizerCount = readNumber(index);
			for (let i = 0; i < normalizerCount; i++) {
				compressor.normalizer.addLocalRange(readNumber(index), readNumber(index));
			}

			// Sharding state (version 3+)
			if (version >= 3) {
				const hasShardingState = readBoolean(index);
				if (hasShardingState) {
					compressor.shardingState = {
						stride: readNumber(index),
						shardOffset: readNumber(index),
						activeChildCount: readNumber(index),
						highestBackfilledGenCount: readNumber(index),
					};
				}
			}
		}

		assert(
			index.index === index.bufferFloat.length,
			0x75f /* Failed to read entire serialized compressor. */,
		);
		return compressor;
	}

	/**
	 * Deserializes version 2.0 format (no sharding state).
	 */
	private static deserialize2_0(
		index: Index,
		sessionId: SessionId | undefined,
		logger: ITelemetryLoggerExt | undefined,
		writeVersion: SerializationVersion,
	): IdCompressor {
		return IdCompressor.deserializeCommon(index, sessionId, logger, writeVersion);
	}

	/**
	 * Deserializes version 3.0 format which includes optional sharding state.
	 */
	private static deserialize3_0(
		index: Index,
		sessionId: SessionId | undefined,
		logger: ITelemetryLoggerExt | undefined,
		writeVersion: SerializationVersion,
	): IdCompressor {
		return IdCompressor.deserializeCommon(index, sessionId, logger, writeVersion);
	}

	public equals(other: IdCompressor, includeLocalState: boolean): boolean {
		if (
			includeLocalState &&
			(this.localSessionId !== other.localSessionId ||
				!this.localSession.equals(other.localSession) ||
				!this.normalizer.equals(other.normalizer) ||
				this.nextRangeBaseGenCount !== other.nextRangeBaseGenCount ||
				this.localGenCount !== other.localGenCount)
		) {
			return false;
		}
		return (
			this.sessions.equals(other.sessions, includeLocalState) &&
			this.finalSpace.equals(other.finalSpace)
		);
	}
}

/**
 * Create a new {@link IIdCompressor}.
 * @param writeVersion - The version the compressor will write when serializing. Use SerializationVersion.V2 for base format, or SerializationVersion.V3 for sharding support.
 * @param logger - Optional telemetry logger.
 * @internal
 */
export function createIdCompressor(
	writeVersion: SerializationVersion,
	logger?: ITelemetryBaseLogger,
): IIdCompressor & IIdCompressorCore;
/**
 * Create a new {@link IIdCompressor}.
 * @param sessionId - The seed ID for the compressor.
 * @param writeVersion - The version the compressor will write when serializing. Use SerializationVersion.V2 for base format, or SerializationVersion.V3 for sharding support.
 * @param logger - Optional telemetry logger.
 * @internal
 */
export function createIdCompressor(
	sessionId: SessionId,
	writeVersion: SerializationVersion,
	logger?: ITelemetryBaseLogger,
): IIdCompressor & IIdCompressorCore;
export function createIdCompressor(
	sessionIdOrDocumentVersion: SessionId | SerializationVersion,
	writeVersionOrLogger?: SerializationVersion | ITelemetryBaseLogger,
	loggerOrUndefined?: ITelemetryBaseLogger,
): IIdCompressor & IIdCompressorCore {
	let localSessionId: SessionId;
	let writeVersion: SerializationVersion;
	let logger: ITelemetryBaseLogger | undefined;

	if (typeof sessionIdOrDocumentVersion === "string") {
		// Called with sessionId, writeVersion, logger?
		localSessionId = sessionIdOrDocumentVersion;
		writeVersion = writeVersionOrLogger as SerializationVersion;
		logger = loggerOrUndefined;
	} else {
		// Called with writeVersion, logger?
		localSessionId = createSessionId();
		writeVersion = sessionIdOrDocumentVersion;
		logger = writeVersionOrLogger as ITelemetryBaseLogger | undefined;
	}

	const compressor = new IdCompressor(
		localSessionId,
		logger === undefined ? undefined : createChildLogger({ logger }),
		writeVersion,
	);
	return compressor;
}

/**
 * Deserializes the supplied state into an ID compressor.
 * @param serialized - The serialized compressor state with an ongoing session.
 * @param writeVersion - The version the compressor will write when serializing. This determines what features are available (e.g., V3 enables sharding support).
 * @param logger - Optional telemetry logger.
 * @internal
 */
export function deserializeIdCompressor(
	serialized: SerializedIdCompressorWithOngoingSession,
	writeVersion: SerializationVersion,
	logger?: ITelemetryLoggerExt,
): IIdCompressor & IIdCompressorCore;
/**
 * Deserializes the supplied state into an ID compressor.
 * @param serialized - The serialized compressor state without a session.
 * @param newSessionId - The session ID to use for the deserialized compressor.
 * @param writeVersion - The version the compressor will write when serializing. This determines what features are available (e.g., V3 enables sharding support).
 * @param logger - Optional telemetry logger.
 * @internal
 */
export function deserializeIdCompressor(
	serialized: SerializedIdCompressorWithNoSession,
	newSessionId: SessionId,
	writeVersion: SerializationVersion,
	logger?: ITelemetryLoggerExt,
): IIdCompressor & IIdCompressorCore;
export function deserializeIdCompressor(
	serialized: SerializedIdCompressor | SerializedIdCompressorWithNoSession,
	sessionIdOrDocumentVersion: SessionId | SerializationVersion,
	writeVersionOrLogger?: SerializationVersion | ITelemetryLoggerExt,
	loggerOrUndefined?: ITelemetryLoggerExt,
): IIdCompressor & IIdCompressorCore {
	if (typeof sessionIdOrDocumentVersion === "string") {
		// Called with (serialized, sessionId, writeVersion, logger?)
		return IdCompressor.deserialize({
			serialized: serialized as SerializedIdCompressorWithNoSession,
			logger: loggerOrUndefined,
			newSessionId: sessionIdOrDocumentVersion,
			requestedWriteVersion: writeVersionOrLogger as SerializationVersion,
		});
	}

	assert(
		loggerOrUndefined === undefined,
		0xc2d /* logger would be in sessionIdOrLogger in this codepath */,
	);
	// Called with (serialized, writeVersion, logger?)
	return IdCompressor.deserialize({
		serialized: serialized as SerializedIdCompressorWithOngoingSession,
		logger: writeVersionOrLogger as ITelemetryLoggerExt | undefined,
		requestedWriteVersion: sessionIdOrDocumentVersion,
	});
}
