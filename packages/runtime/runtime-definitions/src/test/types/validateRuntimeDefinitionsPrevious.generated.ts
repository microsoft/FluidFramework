/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/runtime-definitions-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_CreateSummarizerNodeSource": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_CreateSummarizerNodeSource = requireAssignableTo<TypeOnly<old.CreateSummarizerNodeSource>, TypeOnly<current.CreateSummarizerNodeSource>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_CreateSummarizerNodeSource": {"backCompat": false}
 */
declare type current_as_old_for_Enum_CreateSummarizerNodeSource = requireAssignableTo<TypeOnly<current.CreateSummarizerNodeSource>, TypeOnly<old.CreateSummarizerNodeSource>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_FlushMode": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_FlushMode = requireAssignableTo<TypeOnly<old.FlushMode>, TypeOnly<current.FlushMode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_FlushMode": {"backCompat": false}
 */
declare type current_as_old_for_Enum_FlushMode = requireAssignableTo<TypeOnly<current.FlushMode>, TypeOnly<old.FlushMode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_AttributionInfo": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_AttributionInfo = requireAssignableTo<TypeOnly<old.AttributionInfo>, TypeOnly<current.AttributionInfo>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_AttributionInfo": {"backCompat": false}
 */
declare type current_as_old_for_Interface_AttributionInfo = requireAssignableTo<TypeOnly<current.AttributionInfo>, TypeOnly<old.AttributionInfo>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_DetachedAttributionKey": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_DetachedAttributionKey = requireAssignableTo<TypeOnly<old.DetachedAttributionKey>, TypeOnly<current.DetachedAttributionKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_DetachedAttributionKey": {"backCompat": false}
 */
declare type current_as_old_for_Interface_DetachedAttributionKey = requireAssignableTo<TypeOnly<current.DetachedAttributionKey>, TypeOnly<old.DetachedAttributionKey>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAttachMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IAttachMessage = requireAssignableTo<TypeOnly<old.IAttachMessage>, TypeOnly<current.IAttachMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAttachMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IAttachMessage = requireAssignableTo<TypeOnly<current.IAttachMessage>, TypeOnly<old.IAttachMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContainerRuntimeBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IContainerRuntimeBase = requireAssignableTo<TypeOnly<current.IContainerRuntimeBase>, TypeOnly<old.IContainerRuntimeBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContainerRuntimeBaseEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IContainerRuntimeBaseEvents = requireAssignableTo<TypeOnly<current.IContainerRuntimeBaseEvents>, TypeOnly<old.IContainerRuntimeBaseEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDataStore": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDataStore = requireAssignableTo<TypeOnly<old.IDataStore>, TypeOnly<current.IDataStore>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDataStore": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDataStore = requireAssignableTo<TypeOnly<current.IDataStore>, TypeOnly<old.IDataStore>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEnvelope": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IEnvelope = requireAssignableTo<TypeOnly<old.IEnvelope>, TypeOnly<current.IEnvelope>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEnvelope": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IEnvelope = requireAssignableTo<TypeOnly<current.IEnvelope>, TypeOnly<old.IEnvelope>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IExperimentalIncrementalSummaryContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IExperimentalIncrementalSummaryContext = requireAssignableTo<TypeOnly<old.IExperimentalIncrementalSummaryContext>, TypeOnly<current.IExperimentalIncrementalSummaryContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IExperimentalIncrementalSummaryContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IExperimentalIncrementalSummaryContext = requireAssignableTo<TypeOnly<current.IExperimentalIncrementalSummaryContext>, TypeOnly<old.IExperimentalIncrementalSummaryContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreChannel": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDataStoreChannel = requireAssignableTo<TypeOnly<old.IFluidDataStoreChannel>, TypeOnly<current.IFluidDataStoreChannel>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreChannel": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDataStoreChannel = requireAssignableTo<TypeOnly<current.IFluidDataStoreChannel>, TypeOnly<old.IFluidDataStoreChannel>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDataStoreContext = requireAssignableTo<TypeOnly<old.IFluidDataStoreContext>, TypeOnly<current.IFluidDataStoreContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDataStoreContext = requireAssignableTo<TypeOnly<current.IFluidDataStoreContext>, TypeOnly<old.IFluidDataStoreContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreContextDetached": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDataStoreContextDetached = requireAssignableTo<TypeOnly<old.IFluidDataStoreContextDetached>, TypeOnly<current.IFluidDataStoreContextDetached>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreContextDetached": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDataStoreContextDetached = requireAssignableTo<TypeOnly<current.IFluidDataStoreContextDetached>, TypeOnly<old.IFluidDataStoreContextDetached>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDataStoreFactory = requireAssignableTo<TypeOnly<old.IFluidDataStoreFactory>, TypeOnly<current.IFluidDataStoreFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreFactory": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDataStoreFactory = requireAssignableTo<TypeOnly<current.IFluidDataStoreFactory>, TypeOnly<old.IFluidDataStoreFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreRegistry": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDataStoreRegistry = requireAssignableTo<TypeOnly<old.IFluidDataStoreRegistry>, TypeOnly<current.IFluidDataStoreRegistry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreRegistry": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDataStoreRegistry = requireAssignableTo<TypeOnly<current.IFluidDataStoreRegistry>, TypeOnly<old.IFluidDataStoreRegistry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidParentContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidParentContext = requireAssignableTo<TypeOnly<old.IFluidParentContext>, TypeOnly<current.IFluidParentContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidParentContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidParentContext = requireAssignableTo<TypeOnly<current.IFluidParentContext>, TypeOnly<old.IFluidParentContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGarbageCollectionData": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGarbageCollectionData = requireAssignableTo<TypeOnly<old.IGarbageCollectionData>, TypeOnly<current.IGarbageCollectionData>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGarbageCollectionData": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGarbageCollectionData = requireAssignableTo<TypeOnly<current.IGarbageCollectionData>, TypeOnly<old.IGarbageCollectionData>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGarbageCollectionDetailsBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGarbageCollectionDetailsBase = requireAssignableTo<TypeOnly<old.IGarbageCollectionDetailsBase>, TypeOnly<current.IGarbageCollectionDetailsBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGarbageCollectionDetailsBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGarbageCollectionDetailsBase = requireAssignableTo<TypeOnly<current.IGarbageCollectionDetailsBase>, TypeOnly<old.IGarbageCollectionDetailsBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IInboundSignalMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IInboundSignalMessage = requireAssignableTo<TypeOnly<old.IInboundSignalMessage>, TypeOnly<current.IInboundSignalMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IInboundSignalMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IInboundSignalMessage = requireAssignableTo<TypeOnly<current.IInboundSignalMessage>, TypeOnly<old.IInboundSignalMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidDataStoreFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProvideFluidDataStoreFactory = requireAssignableTo<TypeOnly<old.IProvideFluidDataStoreFactory>, TypeOnly<current.IProvideFluidDataStoreFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidDataStoreFactory": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProvideFluidDataStoreFactory = requireAssignableTo<TypeOnly<current.IProvideFluidDataStoreFactory>, TypeOnly<old.IProvideFluidDataStoreFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidDataStoreRegistry": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProvideFluidDataStoreRegistry = requireAssignableTo<TypeOnly<old.IProvideFluidDataStoreRegistry>, TypeOnly<current.IProvideFluidDataStoreRegistry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidDataStoreRegistry": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProvideFluidDataStoreRegistry = requireAssignableTo<TypeOnly<current.IProvideFluidDataStoreRegistry>, TypeOnly<old.IProvideFluidDataStoreRegistry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRuntimeMessageCollection": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRuntimeMessageCollection = requireAssignableTo<TypeOnly<current.IRuntimeMessageCollection>, TypeOnly<old.IRuntimeMessageCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRuntimeMessagesContent": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRuntimeMessagesContent = requireAssignableTo<TypeOnly<current.IRuntimeMessagesContent>, TypeOnly<old.IRuntimeMessagesContent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeInternalResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizeInternalResult = requireAssignableTo<TypeOnly<old.ISummarizeInternalResult>, TypeOnly<current.ISummarizeInternalResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeInternalResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizeInternalResult = requireAssignableTo<TypeOnly<current.ISummarizeInternalResult>, TypeOnly<old.ISummarizeInternalResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizeResult = requireAssignableTo<TypeOnly<old.ISummarizeResult>, TypeOnly<current.ISummarizeResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizeResult = requireAssignableTo<TypeOnly<current.ISummarizeResult>, TypeOnly<old.ISummarizeResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizerNode = requireAssignableTo<TypeOnly<old.ISummarizerNode>, TypeOnly<current.ISummarizerNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizerNode = requireAssignableTo<TypeOnly<current.ISummarizerNode>, TypeOnly<old.ISummarizerNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNodeConfig": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizerNodeConfig = requireAssignableTo<TypeOnly<old.ISummarizerNodeConfig>, TypeOnly<current.ISummarizerNodeConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNodeConfig": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizerNodeConfig = requireAssignableTo<TypeOnly<current.ISummarizerNodeConfig>, TypeOnly<old.ISummarizerNodeConfig>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNodeConfigWithGC": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizerNodeConfigWithGC = requireAssignableTo<TypeOnly<old.ISummarizerNodeConfigWithGC>, TypeOnly<current.ISummarizerNodeConfigWithGC>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNodeConfigWithGC": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizerNodeConfigWithGC = requireAssignableTo<TypeOnly<current.ISummarizerNodeConfigWithGC>, TypeOnly<old.ISummarizerNodeConfigWithGC>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNodeWithGC": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizerNodeWithGC = requireAssignableTo<TypeOnly<old.ISummarizerNodeWithGC>, TypeOnly<current.ISummarizerNodeWithGC>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNodeWithGC": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizerNodeWithGC = requireAssignableTo<TypeOnly<current.ISummarizerNodeWithGC>, TypeOnly<old.ISummarizerNodeWithGC>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryStats": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryStats = requireAssignableTo<TypeOnly<old.ISummaryStats>, TypeOnly<current.ISummaryStats>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryStats": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryStats = requireAssignableTo<TypeOnly<current.ISummaryStats>, TypeOnly<old.ISummaryStats>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryTreeWithStats": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryTreeWithStats = requireAssignableTo<TypeOnly<old.ISummaryTreeWithStats>, TypeOnly<current.ISummaryTreeWithStats>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryTreeWithStats": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryTreeWithStats = requireAssignableTo<TypeOnly<current.ISummaryTreeWithStats>, TypeOnly<old.ISummaryTreeWithStats>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITelemetryContext = requireAssignableTo<TypeOnly<old.ITelemetryContext>, TypeOnly<current.ITelemetryContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryContext = requireAssignableTo<TypeOnly<current.ITelemetryContext>, TypeOnly<old.ITelemetryContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_LocalAttributionKey": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_LocalAttributionKey = requireAssignableTo<TypeOnly<old.LocalAttributionKey>, TypeOnly<current.LocalAttributionKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_LocalAttributionKey": {"backCompat": false}
 */
declare type current_as_old_for_Interface_LocalAttributionKey = requireAssignableTo<TypeOnly<current.LocalAttributionKey>, TypeOnly<old.LocalAttributionKey>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_OpAttributionKey": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_OpAttributionKey = requireAssignableTo<TypeOnly<old.OpAttributionKey>, TypeOnly<current.OpAttributionKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_OpAttributionKey": {"backCompat": false}
 */
declare type current_as_old_for_Interface_OpAttributionKey = requireAssignableTo<TypeOnly<current.OpAttributionKey>, TypeOnly<old.OpAttributionKey>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_AliasResult": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_AliasResult = requireAssignableTo<TypeOnly<old.AliasResult>, TypeOnly<current.AliasResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_AliasResult": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_AliasResult = requireAssignableTo<TypeOnly<current.AliasResult>, TypeOnly<old.AliasResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_AttributionKey": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_AttributionKey = requireAssignableTo<TypeOnly<old.AttributionKey>, TypeOnly<current.AttributionKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_AttributionKey": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_AttributionKey = requireAssignableTo<TypeOnly<current.AttributionKey>, TypeOnly<old.AttributionKey>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_CreateChildSummarizerNodeFn": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_CreateChildSummarizerNodeFn = requireAssignableTo<TypeOnly<old.CreateChildSummarizerNodeFn>, TypeOnly<current.CreateChildSummarizerNodeFn>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_CreateChildSummarizerNodeFn": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_CreateChildSummarizerNodeFn = requireAssignableTo<TypeOnly<current.CreateChildSummarizerNodeFn>, TypeOnly<old.CreateChildSummarizerNodeFn>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_CreateChildSummarizerNodeParam": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_CreateChildSummarizerNodeParam = requireAssignableTo<TypeOnly<old.CreateChildSummarizerNodeParam>, TypeOnly<current.CreateChildSummarizerNodeParam>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_CreateChildSummarizerNodeParam": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_CreateChildSummarizerNodeParam = requireAssignableTo<TypeOnly<current.CreateChildSummarizerNodeParam>, TypeOnly<old.CreateChildSummarizerNodeParam>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidDataStoreRegistryEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_FluidDataStoreRegistryEntry = requireAssignableTo<TypeOnly<old.FluidDataStoreRegistryEntry>, TypeOnly<current.FluidDataStoreRegistryEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidDataStoreRegistryEntry": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_FluidDataStoreRegistryEntry = requireAssignableTo<TypeOnly<current.FluidDataStoreRegistryEntry>, TypeOnly<old.FluidDataStoreRegistryEntry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InboundAttachMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InboundAttachMessage = requireAssignableTo<TypeOnly<old.InboundAttachMessage>, TypeOnly<current.InboundAttachMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InboundAttachMessage": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InboundAttachMessage = requireAssignableTo<TypeOnly<current.InboundAttachMessage>, TypeOnly<old.InboundAttachMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISequencedMessageEnvelope": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ISequencedMessageEnvelope = requireAssignableTo<TypeOnly<old.ISequencedMessageEnvelope>, TypeOnly<current.ISequencedMessageEnvelope>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ISequencedMessageEnvelope": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ISequencedMessageEnvelope = requireAssignableTo<TypeOnly<current.ISequencedMessageEnvelope>, TypeOnly<old.ISequencedMessageEnvelope>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_NamedFluidDataStoreRegistryEntries": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_NamedFluidDataStoreRegistryEntries = requireAssignableTo<TypeOnly<old.NamedFluidDataStoreRegistryEntries>, TypeOnly<current.NamedFluidDataStoreRegistryEntries>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_NamedFluidDataStoreRegistryEntries": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_NamedFluidDataStoreRegistryEntries = requireAssignableTo<TypeOnly<current.NamedFluidDataStoreRegistryEntries>, TypeOnly<old.NamedFluidDataStoreRegistryEntries>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_NamedFluidDataStoreRegistryEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_NamedFluidDataStoreRegistryEntry = requireAssignableTo<TypeOnly<old.NamedFluidDataStoreRegistryEntry>, TypeOnly<current.NamedFluidDataStoreRegistryEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_NamedFluidDataStoreRegistryEntry": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_NamedFluidDataStoreRegistryEntry = requireAssignableTo<TypeOnly<current.NamedFluidDataStoreRegistryEntry>, TypeOnly<old.NamedFluidDataStoreRegistryEntry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_NamedFluidDataStoreRegistryEntry2": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_NamedFluidDataStoreRegistryEntry2 = requireAssignableTo<TypeOnly<old.NamedFluidDataStoreRegistryEntry2>, TypeOnly<current.NamedFluidDataStoreRegistryEntry2>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_NamedFluidDataStoreRegistryEntry2": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_NamedFluidDataStoreRegistryEntry2 = requireAssignableTo<TypeOnly<current.NamedFluidDataStoreRegistryEntry2>, TypeOnly<old.NamedFluidDataStoreRegistryEntry2>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummarizeInternalFn": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SummarizeInternalFn = requireAssignableTo<TypeOnly<old.SummarizeInternalFn>, TypeOnly<current.SummarizeInternalFn>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummarizeInternalFn": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SummarizeInternalFn = requireAssignableTo<TypeOnly<current.SummarizeInternalFn>, TypeOnly<old.SummarizeInternalFn>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_VisibilityState": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_VisibilityState = requireAssignableTo<TypeOnly<old.VisibilityState>, TypeOnly<current.VisibilityState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_VisibilityState": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_VisibilityState = requireAssignableTo<TypeOnly<current.VisibilityState>, TypeOnly<old.VisibilityState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IFluidDataStoreFactory": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IFluidDataStoreFactory = requireAssignableTo<TypeOnly<typeof current.IFluidDataStoreFactory>, TypeOnly<typeof old.IFluidDataStoreFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IFluidDataStoreRegistry": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IFluidDataStoreRegistry = requireAssignableTo<TypeOnly<typeof current.IFluidDataStoreRegistry>, TypeOnly<typeof old.IFluidDataStoreRegistry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_VisibilityState": {"backCompat": false}
 */
declare type current_as_old_for_Variable_VisibilityState = requireAssignableTo<TypeOnly<typeof current.VisibilityState>, TypeOnly<typeof old.VisibilityState>>
