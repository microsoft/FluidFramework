/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/runtime-definitions-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_AliasResult": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_AliasResult():
    TypeOnly<old.AliasResult>;
declare function use_current_TypeAliasDeclaration_AliasResult(
    use: TypeOnly<current.AliasResult>): void;
use_current_TypeAliasDeclaration_AliasResult(
    get_old_TypeAliasDeclaration_AliasResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_AliasResult": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_AliasResult():
    TypeOnly<current.AliasResult>;
declare function use_old_TypeAliasDeclaration_AliasResult(
    use: TypeOnly<old.AliasResult>): void;
use_old_TypeAliasDeclaration_AliasResult(
    get_current_TypeAliasDeclaration_AliasResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_AttributionInfo": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_AttributionInfo():
    TypeOnly<old.AttributionInfo>;
declare function use_current_InterfaceDeclaration_AttributionInfo(
    use: TypeOnly<current.AttributionInfo>): void;
use_current_InterfaceDeclaration_AttributionInfo(
    get_old_InterfaceDeclaration_AttributionInfo());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_AttributionInfo": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_AttributionInfo():
    TypeOnly<current.AttributionInfo>;
declare function use_old_InterfaceDeclaration_AttributionInfo(
    use: TypeOnly<old.AttributionInfo>): void;
use_old_InterfaceDeclaration_AttributionInfo(
    get_current_InterfaceDeclaration_AttributionInfo());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_AttributionKey": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_AttributionKey():
    TypeOnly<old.AttributionKey>;
declare function use_current_TypeAliasDeclaration_AttributionKey(
    use: TypeOnly<current.AttributionKey>): void;
use_current_TypeAliasDeclaration_AttributionKey(
    get_old_TypeAliasDeclaration_AttributionKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_AttributionKey": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_AttributionKey():
    TypeOnly<current.AttributionKey>;
declare function use_old_TypeAliasDeclaration_AttributionKey(
    use: TypeOnly<old.AttributionKey>): void;
use_old_TypeAliasDeclaration_AttributionKey(
    get_current_TypeAliasDeclaration_AttributionKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_CreateChildSummarizerNodeFn": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_CreateChildSummarizerNodeFn():
    TypeOnly<old.CreateChildSummarizerNodeFn>;
declare function use_current_TypeAliasDeclaration_CreateChildSummarizerNodeFn(
    use: TypeOnly<current.CreateChildSummarizerNodeFn>): void;
use_current_TypeAliasDeclaration_CreateChildSummarizerNodeFn(
    get_old_TypeAliasDeclaration_CreateChildSummarizerNodeFn());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_CreateChildSummarizerNodeFn": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_CreateChildSummarizerNodeFn():
    TypeOnly<current.CreateChildSummarizerNodeFn>;
declare function use_old_TypeAliasDeclaration_CreateChildSummarizerNodeFn(
    use: TypeOnly<old.CreateChildSummarizerNodeFn>): void;
use_old_TypeAliasDeclaration_CreateChildSummarizerNodeFn(
    get_current_TypeAliasDeclaration_CreateChildSummarizerNodeFn());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_CreateChildSummarizerNodeParam": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_CreateChildSummarizerNodeParam():
    TypeOnly<old.CreateChildSummarizerNodeParam>;
declare function use_current_TypeAliasDeclaration_CreateChildSummarizerNodeParam(
    use: TypeOnly<current.CreateChildSummarizerNodeParam>): void;
use_current_TypeAliasDeclaration_CreateChildSummarizerNodeParam(
    get_old_TypeAliasDeclaration_CreateChildSummarizerNodeParam());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_CreateChildSummarizerNodeParam": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_CreateChildSummarizerNodeParam():
    TypeOnly<current.CreateChildSummarizerNodeParam>;
declare function use_old_TypeAliasDeclaration_CreateChildSummarizerNodeParam(
    use: TypeOnly<old.CreateChildSummarizerNodeParam>): void;
use_old_TypeAliasDeclaration_CreateChildSummarizerNodeParam(
    get_current_TypeAliasDeclaration_CreateChildSummarizerNodeParam());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_CreateSummarizerNodeSource": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_CreateSummarizerNodeSource():
    TypeOnly<old.CreateSummarizerNodeSource>;
declare function use_current_EnumDeclaration_CreateSummarizerNodeSource(
    use: TypeOnly<current.CreateSummarizerNodeSource>): void;
use_current_EnumDeclaration_CreateSummarizerNodeSource(
    get_old_EnumDeclaration_CreateSummarizerNodeSource());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_CreateSummarizerNodeSource": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_CreateSummarizerNodeSource():
    TypeOnly<current.CreateSummarizerNodeSource>;
declare function use_old_EnumDeclaration_CreateSummarizerNodeSource(
    use: TypeOnly<old.CreateSummarizerNodeSource>): void;
use_old_EnumDeclaration_CreateSummarizerNodeSource(
    get_current_EnumDeclaration_CreateSummarizerNodeSource());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_DetachedAttributionKey": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_DetachedAttributionKey():
    TypeOnly<old.DetachedAttributionKey>;
declare function use_current_InterfaceDeclaration_DetachedAttributionKey(
    use: TypeOnly<current.DetachedAttributionKey>): void;
use_current_InterfaceDeclaration_DetachedAttributionKey(
    get_old_InterfaceDeclaration_DetachedAttributionKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_DetachedAttributionKey": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_DetachedAttributionKey():
    TypeOnly<current.DetachedAttributionKey>;
declare function use_old_InterfaceDeclaration_DetachedAttributionKey(
    use: TypeOnly<old.DetachedAttributionKey>): void;
use_old_InterfaceDeclaration_DetachedAttributionKey(
    get_current_InterfaceDeclaration_DetachedAttributionKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_FluidDataStoreRegistryEntry": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_FluidDataStoreRegistryEntry():
    TypeOnly<old.FluidDataStoreRegistryEntry>;
declare function use_current_TypeAliasDeclaration_FluidDataStoreRegistryEntry(
    use: TypeOnly<current.FluidDataStoreRegistryEntry>): void;
use_current_TypeAliasDeclaration_FluidDataStoreRegistryEntry(
    get_old_TypeAliasDeclaration_FluidDataStoreRegistryEntry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_FluidDataStoreRegistryEntry": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_FluidDataStoreRegistryEntry():
    TypeOnly<current.FluidDataStoreRegistryEntry>;
declare function use_old_TypeAliasDeclaration_FluidDataStoreRegistryEntry(
    use: TypeOnly<old.FluidDataStoreRegistryEntry>): void;
use_old_TypeAliasDeclaration_FluidDataStoreRegistryEntry(
    get_current_TypeAliasDeclaration_FluidDataStoreRegistryEntry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_FlushMode": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_FlushMode():
    TypeOnly<old.FlushMode>;
declare function use_current_EnumDeclaration_FlushMode(
    use: TypeOnly<current.FlushMode>): void;
use_current_EnumDeclaration_FlushMode(
    get_old_EnumDeclaration_FlushMode());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_FlushMode": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_FlushMode():
    TypeOnly<current.FlushMode>;
declare function use_old_EnumDeclaration_FlushMode(
    use: TypeOnly<old.FlushMode>): void;
use_old_EnumDeclaration_FlushMode(
    get_current_EnumDeclaration_FlushMode());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_FlushModeExperimental": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_FlushModeExperimental():
    TypeOnly<old.FlushModeExperimental>;
declare function use_current_EnumDeclaration_FlushModeExperimental(
    use: TypeOnly<current.FlushModeExperimental>): void;
use_current_EnumDeclaration_FlushModeExperimental(
    get_old_EnumDeclaration_FlushModeExperimental());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_FlushModeExperimental": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_FlushModeExperimental():
    TypeOnly<current.FlushModeExperimental>;
declare function use_old_EnumDeclaration_FlushModeExperimental(
    use: TypeOnly<old.FlushModeExperimental>): void;
use_old_EnumDeclaration_FlushModeExperimental(
    get_current_EnumDeclaration_FlushModeExperimental());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAttachMessage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IAttachMessage():
    TypeOnly<old.IAttachMessage>;
declare function use_current_InterfaceDeclaration_IAttachMessage(
    use: TypeOnly<current.IAttachMessage>): void;
use_current_InterfaceDeclaration_IAttachMessage(
    get_old_InterfaceDeclaration_IAttachMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAttachMessage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IAttachMessage():
    TypeOnly<current.IAttachMessage>;
declare function use_old_InterfaceDeclaration_IAttachMessage(
    use: TypeOnly<old.IAttachMessage>): void;
use_old_InterfaceDeclaration_IAttachMessage(
    get_current_InterfaceDeclaration_IAttachMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerRuntimeBase": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IContainerRuntimeBase():
    TypeOnly<old.IContainerRuntimeBase>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeBase(
    use: TypeOnly<current.IContainerRuntimeBase>): void;
use_current_InterfaceDeclaration_IContainerRuntimeBase(
    get_old_InterfaceDeclaration_IContainerRuntimeBase());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerRuntimeBase": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IContainerRuntimeBase():
    TypeOnly<current.IContainerRuntimeBase>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeBase(
    use: TypeOnly<old.IContainerRuntimeBase>): void;
use_old_InterfaceDeclaration_IContainerRuntimeBase(
    get_current_InterfaceDeclaration_IContainerRuntimeBase());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerRuntimeBaseEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IContainerRuntimeBaseEvents():
    TypeOnly<old.IContainerRuntimeBaseEvents>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeBaseEvents(
    use: TypeOnly<current.IContainerRuntimeBaseEvents>): void;
use_current_InterfaceDeclaration_IContainerRuntimeBaseEvents(
    get_old_InterfaceDeclaration_IContainerRuntimeBaseEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IContainerRuntimeBaseEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IContainerRuntimeBaseEvents():
    TypeOnly<current.IContainerRuntimeBaseEvents>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeBaseEvents(
    use: TypeOnly<old.IContainerRuntimeBaseEvents>): void;
use_old_InterfaceDeclaration_IContainerRuntimeBaseEvents(
    get_current_InterfaceDeclaration_IContainerRuntimeBaseEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDataStore": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDataStore():
    TypeOnly<old.IDataStore>;
declare function use_current_InterfaceDeclaration_IDataStore(
    use: TypeOnly<current.IDataStore>): void;
use_current_InterfaceDeclaration_IDataStore(
    get_old_InterfaceDeclaration_IDataStore());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDataStore": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDataStore():
    TypeOnly<current.IDataStore>;
declare function use_old_InterfaceDeclaration_IDataStore(
    use: TypeOnly<old.IDataStore>): void;
use_old_InterfaceDeclaration_IDataStore(
    get_current_InterfaceDeclaration_IDataStore());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEnvelope": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IEnvelope():
    TypeOnly<old.IEnvelope>;
declare function use_current_InterfaceDeclaration_IEnvelope(
    use: TypeOnly<current.IEnvelope>): void;
use_current_InterfaceDeclaration_IEnvelope(
    get_old_InterfaceDeclaration_IEnvelope());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEnvelope": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IEnvelope():
    TypeOnly<current.IEnvelope>;
declare function use_old_InterfaceDeclaration_IEnvelope(
    use: TypeOnly<old.IEnvelope>): void;
use_old_InterfaceDeclaration_IEnvelope(
    get_current_InterfaceDeclaration_IEnvelope());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IExperimentalIncrementalSummaryContext": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IExperimentalIncrementalSummaryContext():
    TypeOnly<old.IExperimentalIncrementalSummaryContext>;
declare function use_current_InterfaceDeclaration_IExperimentalIncrementalSummaryContext(
    use: TypeOnly<current.IExperimentalIncrementalSummaryContext>): void;
use_current_InterfaceDeclaration_IExperimentalIncrementalSummaryContext(
    get_old_InterfaceDeclaration_IExperimentalIncrementalSummaryContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IExperimentalIncrementalSummaryContext": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IExperimentalIncrementalSummaryContext():
    TypeOnly<current.IExperimentalIncrementalSummaryContext>;
declare function use_old_InterfaceDeclaration_IExperimentalIncrementalSummaryContext(
    use: TypeOnly<old.IExperimentalIncrementalSummaryContext>): void;
use_old_InterfaceDeclaration_IExperimentalIncrementalSummaryContext(
    get_current_InterfaceDeclaration_IExperimentalIncrementalSummaryContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreChannel": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidDataStoreChannel():
    TypeOnly<old.IFluidDataStoreChannel>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreChannel(
    use: TypeOnly<current.IFluidDataStoreChannel>): void;
use_current_InterfaceDeclaration_IFluidDataStoreChannel(
    get_old_InterfaceDeclaration_IFluidDataStoreChannel());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreChannel": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidDataStoreChannel():
    TypeOnly<current.IFluidDataStoreChannel>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreChannel(
    use: TypeOnly<old.IFluidDataStoreChannel>): void;
use_old_InterfaceDeclaration_IFluidDataStoreChannel(
    get_current_InterfaceDeclaration_IFluidDataStoreChannel());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreContext": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidDataStoreContext():
    TypeOnly<old.IFluidDataStoreContext>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreContext(
    use: TypeOnly<current.IFluidDataStoreContext>): void;
use_current_InterfaceDeclaration_IFluidDataStoreContext(
    get_old_InterfaceDeclaration_IFluidDataStoreContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreContext": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidDataStoreContext():
    TypeOnly<current.IFluidDataStoreContext>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreContext(
    use: TypeOnly<old.IFluidDataStoreContext>): void;
use_old_InterfaceDeclaration_IFluidDataStoreContext(
    get_current_InterfaceDeclaration_IFluidDataStoreContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreContextDetached": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidDataStoreContextDetached():
    TypeOnly<old.IFluidDataStoreContextDetached>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreContextDetached(
    use: TypeOnly<current.IFluidDataStoreContextDetached>): void;
use_current_InterfaceDeclaration_IFluidDataStoreContextDetached(
    get_old_InterfaceDeclaration_IFluidDataStoreContextDetached());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreContextDetached": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidDataStoreContextDetached():
    TypeOnly<current.IFluidDataStoreContextDetached>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreContextDetached(
    use: TypeOnly<old.IFluidDataStoreContextDetached>): void;
use_old_InterfaceDeclaration_IFluidDataStoreContextDetached(
    get_current_InterfaceDeclaration_IFluidDataStoreContextDetached());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IFluidDataStoreFactory": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_IFluidDataStoreFactory():
    TypeOnly<typeof old.IFluidDataStoreFactory>;
declare function use_current_VariableDeclaration_IFluidDataStoreFactory(
    use: TypeOnly<typeof current.IFluidDataStoreFactory>): void;
use_current_VariableDeclaration_IFluidDataStoreFactory(
    get_old_VariableDeclaration_IFluidDataStoreFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IFluidDataStoreFactory": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_IFluidDataStoreFactory():
    TypeOnly<typeof current.IFluidDataStoreFactory>;
declare function use_old_VariableDeclaration_IFluidDataStoreFactory(
    use: TypeOnly<typeof old.IFluidDataStoreFactory>): void;
use_old_VariableDeclaration_IFluidDataStoreFactory(
    get_current_VariableDeclaration_IFluidDataStoreFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreFactory": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidDataStoreFactory():
    TypeOnly<old.IFluidDataStoreFactory>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreFactory(
    use: TypeOnly<current.IFluidDataStoreFactory>): void;
use_current_InterfaceDeclaration_IFluidDataStoreFactory(
    get_old_InterfaceDeclaration_IFluidDataStoreFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreFactory": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidDataStoreFactory():
    TypeOnly<current.IFluidDataStoreFactory>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreFactory(
    use: TypeOnly<old.IFluidDataStoreFactory>): void;
use_old_InterfaceDeclaration_IFluidDataStoreFactory(
    get_current_InterfaceDeclaration_IFluidDataStoreFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IFluidDataStoreRegistry": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_IFluidDataStoreRegistry():
    TypeOnly<typeof old.IFluidDataStoreRegistry>;
declare function use_current_VariableDeclaration_IFluidDataStoreRegistry(
    use: TypeOnly<typeof current.IFluidDataStoreRegistry>): void;
use_current_VariableDeclaration_IFluidDataStoreRegistry(
    get_old_VariableDeclaration_IFluidDataStoreRegistry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IFluidDataStoreRegistry": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_IFluidDataStoreRegistry():
    TypeOnly<typeof current.IFluidDataStoreRegistry>;
declare function use_old_VariableDeclaration_IFluidDataStoreRegistry(
    use: TypeOnly<typeof old.IFluidDataStoreRegistry>): void;
use_old_VariableDeclaration_IFluidDataStoreRegistry(
    get_current_VariableDeclaration_IFluidDataStoreRegistry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreRegistry": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidDataStoreRegistry():
    TypeOnly<old.IFluidDataStoreRegistry>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreRegistry(
    use: TypeOnly<current.IFluidDataStoreRegistry>): void;
use_current_InterfaceDeclaration_IFluidDataStoreRegistry(
    get_old_InterfaceDeclaration_IFluidDataStoreRegistry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidDataStoreRegistry": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidDataStoreRegistry():
    TypeOnly<current.IFluidDataStoreRegistry>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreRegistry(
    use: TypeOnly<old.IFluidDataStoreRegistry>): void;
use_old_InterfaceDeclaration_IFluidDataStoreRegistry(
    get_current_InterfaceDeclaration_IFluidDataStoreRegistry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidParentContext": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidParentContext():
    TypeOnly<old.IFluidParentContext>;
declare function use_current_InterfaceDeclaration_IFluidParentContext(
    use: TypeOnly<current.IFluidParentContext>): void;
use_current_InterfaceDeclaration_IFluidParentContext(
    get_old_InterfaceDeclaration_IFluidParentContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidParentContext": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidParentContext():
    TypeOnly<current.IFluidParentContext>;
declare function use_old_InterfaceDeclaration_IFluidParentContext(
    use: TypeOnly<old.IFluidParentContext>): void;
use_old_InterfaceDeclaration_IFluidParentContext(
    get_current_InterfaceDeclaration_IFluidParentContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGarbageCollectionData": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IGarbageCollectionData():
    TypeOnly<old.IGarbageCollectionData>;
declare function use_current_InterfaceDeclaration_IGarbageCollectionData(
    use: TypeOnly<current.IGarbageCollectionData>): void;
use_current_InterfaceDeclaration_IGarbageCollectionData(
    get_old_InterfaceDeclaration_IGarbageCollectionData());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGarbageCollectionData": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IGarbageCollectionData():
    TypeOnly<current.IGarbageCollectionData>;
declare function use_old_InterfaceDeclaration_IGarbageCollectionData(
    use: TypeOnly<old.IGarbageCollectionData>): void;
use_old_InterfaceDeclaration_IGarbageCollectionData(
    get_current_InterfaceDeclaration_IGarbageCollectionData());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGarbageCollectionDetailsBase": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IGarbageCollectionDetailsBase():
    TypeOnly<old.IGarbageCollectionDetailsBase>;
declare function use_current_InterfaceDeclaration_IGarbageCollectionDetailsBase(
    use: TypeOnly<current.IGarbageCollectionDetailsBase>): void;
use_current_InterfaceDeclaration_IGarbageCollectionDetailsBase(
    get_old_InterfaceDeclaration_IGarbageCollectionDetailsBase());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IGarbageCollectionDetailsBase": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IGarbageCollectionDetailsBase():
    TypeOnly<current.IGarbageCollectionDetailsBase>;
declare function use_old_InterfaceDeclaration_IGarbageCollectionDetailsBase(
    use: TypeOnly<old.IGarbageCollectionDetailsBase>): void;
use_old_InterfaceDeclaration_IGarbageCollectionDetailsBase(
    get_current_InterfaceDeclaration_IGarbageCollectionDetailsBase());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IInboundSignalMessage": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IInboundSignalMessage():
    TypeOnly<old.IInboundSignalMessage>;
declare function use_current_InterfaceDeclaration_IInboundSignalMessage(
    use: TypeOnly<current.IInboundSignalMessage>): void;
use_current_InterfaceDeclaration_IInboundSignalMessage(
    get_old_InterfaceDeclaration_IInboundSignalMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IInboundSignalMessage": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IInboundSignalMessage():
    TypeOnly<current.IInboundSignalMessage>;
declare function use_old_InterfaceDeclaration_IInboundSignalMessage(
    use: TypeOnly<old.IInboundSignalMessage>): void;
use_old_InterfaceDeclaration_IInboundSignalMessage(
    get_current_InterfaceDeclaration_IInboundSignalMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideFluidDataStoreFactory": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProvideFluidDataStoreFactory():
    TypeOnly<old.IProvideFluidDataStoreFactory>;
declare function use_current_InterfaceDeclaration_IProvideFluidDataStoreFactory(
    use: TypeOnly<current.IProvideFluidDataStoreFactory>): void;
use_current_InterfaceDeclaration_IProvideFluidDataStoreFactory(
    get_old_InterfaceDeclaration_IProvideFluidDataStoreFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideFluidDataStoreFactory": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProvideFluidDataStoreFactory():
    TypeOnly<current.IProvideFluidDataStoreFactory>;
declare function use_old_InterfaceDeclaration_IProvideFluidDataStoreFactory(
    use: TypeOnly<old.IProvideFluidDataStoreFactory>): void;
use_old_InterfaceDeclaration_IProvideFluidDataStoreFactory(
    get_current_InterfaceDeclaration_IProvideFluidDataStoreFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideFluidDataStoreRegistry": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProvideFluidDataStoreRegistry():
    TypeOnly<old.IProvideFluidDataStoreRegistry>;
declare function use_current_InterfaceDeclaration_IProvideFluidDataStoreRegistry(
    use: TypeOnly<current.IProvideFluidDataStoreRegistry>): void;
use_current_InterfaceDeclaration_IProvideFluidDataStoreRegistry(
    get_old_InterfaceDeclaration_IProvideFluidDataStoreRegistry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideFluidDataStoreRegistry": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProvideFluidDataStoreRegistry():
    TypeOnly<current.IProvideFluidDataStoreRegistry>;
declare function use_old_InterfaceDeclaration_IProvideFluidDataStoreRegistry(
    use: TypeOnly<old.IProvideFluidDataStoreRegistry>): void;
use_old_InterfaceDeclaration_IProvideFluidDataStoreRegistry(
    get_current_InterfaceDeclaration_IProvideFluidDataStoreRegistry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISignalEnvelope": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISignalEnvelope():
    TypeOnly<old.ISignalEnvelope>;
declare function use_current_InterfaceDeclaration_ISignalEnvelope(
    use: TypeOnly<current.ISignalEnvelope>): void;
use_current_InterfaceDeclaration_ISignalEnvelope(
    get_old_InterfaceDeclaration_ISignalEnvelope());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISignalEnvelope": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISignalEnvelope():
    TypeOnly<current.ISignalEnvelope>;
declare function use_old_InterfaceDeclaration_ISignalEnvelope(
    use: TypeOnly<old.ISignalEnvelope>): void;
use_old_InterfaceDeclaration_ISignalEnvelope(
    get_current_InterfaceDeclaration_ISignalEnvelope());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizeInternalResult": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummarizeInternalResult():
    TypeOnly<old.ISummarizeInternalResult>;
declare function use_current_InterfaceDeclaration_ISummarizeInternalResult(
    use: TypeOnly<current.ISummarizeInternalResult>): void;
use_current_InterfaceDeclaration_ISummarizeInternalResult(
    get_old_InterfaceDeclaration_ISummarizeInternalResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizeInternalResult": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummarizeInternalResult():
    TypeOnly<current.ISummarizeInternalResult>;
declare function use_old_InterfaceDeclaration_ISummarizeInternalResult(
    use: TypeOnly<old.ISummarizeInternalResult>): void;
use_old_InterfaceDeclaration_ISummarizeInternalResult(
    get_current_InterfaceDeclaration_ISummarizeInternalResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizeResult": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummarizeResult():
    TypeOnly<old.ISummarizeResult>;
declare function use_current_InterfaceDeclaration_ISummarizeResult(
    use: TypeOnly<current.ISummarizeResult>): void;
use_current_InterfaceDeclaration_ISummarizeResult(
    get_old_InterfaceDeclaration_ISummarizeResult());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizeResult": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummarizeResult():
    TypeOnly<current.ISummarizeResult>;
declare function use_old_InterfaceDeclaration_ISummarizeResult(
    use: TypeOnly<old.ISummarizeResult>): void;
use_old_InterfaceDeclaration_ISummarizeResult(
    get_current_InterfaceDeclaration_ISummarizeResult());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizerNode": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummarizerNode():
    TypeOnly<old.ISummarizerNode>;
declare function use_current_InterfaceDeclaration_ISummarizerNode(
    use: TypeOnly<current.ISummarizerNode>): void;
use_current_InterfaceDeclaration_ISummarizerNode(
    get_old_InterfaceDeclaration_ISummarizerNode());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizerNode": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummarizerNode():
    TypeOnly<current.ISummarizerNode>;
declare function use_old_InterfaceDeclaration_ISummarizerNode(
    use: TypeOnly<old.ISummarizerNode>): void;
use_old_InterfaceDeclaration_ISummarizerNode(
    get_current_InterfaceDeclaration_ISummarizerNode());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizerNodeConfig": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummarizerNodeConfig():
    TypeOnly<old.ISummarizerNodeConfig>;
declare function use_current_InterfaceDeclaration_ISummarizerNodeConfig(
    use: TypeOnly<current.ISummarizerNodeConfig>): void;
use_current_InterfaceDeclaration_ISummarizerNodeConfig(
    get_old_InterfaceDeclaration_ISummarizerNodeConfig());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizerNodeConfig": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummarizerNodeConfig():
    TypeOnly<current.ISummarizerNodeConfig>;
declare function use_old_InterfaceDeclaration_ISummarizerNodeConfig(
    use: TypeOnly<old.ISummarizerNodeConfig>): void;
use_old_InterfaceDeclaration_ISummarizerNodeConfig(
    get_current_InterfaceDeclaration_ISummarizerNodeConfig());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizerNodeConfigWithGC": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummarizerNodeConfigWithGC():
    TypeOnly<old.ISummarizerNodeConfigWithGC>;
declare function use_current_InterfaceDeclaration_ISummarizerNodeConfigWithGC(
    use: TypeOnly<current.ISummarizerNodeConfigWithGC>): void;
use_current_InterfaceDeclaration_ISummarizerNodeConfigWithGC(
    get_old_InterfaceDeclaration_ISummarizerNodeConfigWithGC());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizerNodeConfigWithGC": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummarizerNodeConfigWithGC():
    TypeOnly<current.ISummarizerNodeConfigWithGC>;
declare function use_old_InterfaceDeclaration_ISummarizerNodeConfigWithGC(
    use: TypeOnly<old.ISummarizerNodeConfigWithGC>): void;
use_old_InterfaceDeclaration_ISummarizerNodeConfigWithGC(
    get_current_InterfaceDeclaration_ISummarizerNodeConfigWithGC());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizerNodeWithGC": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummarizerNodeWithGC():
    TypeOnly<old.ISummarizerNodeWithGC>;
declare function use_current_InterfaceDeclaration_ISummarizerNodeWithGC(
    use: TypeOnly<current.ISummarizerNodeWithGC>): void;
use_current_InterfaceDeclaration_ISummarizerNodeWithGC(
    get_old_InterfaceDeclaration_ISummarizerNodeWithGC());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummarizerNodeWithGC": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummarizerNodeWithGC():
    TypeOnly<current.ISummarizerNodeWithGC>;
declare function use_old_InterfaceDeclaration_ISummarizerNodeWithGC(
    use: TypeOnly<old.ISummarizerNodeWithGC>): void;
use_old_InterfaceDeclaration_ISummarizerNodeWithGC(
    get_current_InterfaceDeclaration_ISummarizerNodeWithGC());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryStats": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryStats():
    TypeOnly<old.ISummaryStats>;
declare function use_current_InterfaceDeclaration_ISummaryStats(
    use: TypeOnly<current.ISummaryStats>): void;
use_current_InterfaceDeclaration_ISummaryStats(
    get_old_InterfaceDeclaration_ISummaryStats());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryStats": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryStats():
    TypeOnly<current.ISummaryStats>;
declare function use_old_InterfaceDeclaration_ISummaryStats(
    use: TypeOnly<old.ISummaryStats>): void;
use_old_InterfaceDeclaration_ISummaryStats(
    get_current_InterfaceDeclaration_ISummaryStats());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryTreeWithStats": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISummaryTreeWithStats():
    TypeOnly<old.ISummaryTreeWithStats>;
declare function use_current_InterfaceDeclaration_ISummaryTreeWithStats(
    use: TypeOnly<current.ISummaryTreeWithStats>): void;
use_current_InterfaceDeclaration_ISummaryTreeWithStats(
    get_old_InterfaceDeclaration_ISummaryTreeWithStats());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISummaryTreeWithStats": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISummaryTreeWithStats():
    TypeOnly<current.ISummaryTreeWithStats>;
declare function use_old_InterfaceDeclaration_ISummaryTreeWithStats(
    use: TypeOnly<old.ISummaryTreeWithStats>): void;
use_old_InterfaceDeclaration_ISummaryTreeWithStats(
    get_current_InterfaceDeclaration_ISummaryTreeWithStats());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryContext": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITelemetryContext():
    TypeOnly<old.ITelemetryContext>;
declare function use_current_InterfaceDeclaration_ITelemetryContext(
    use: TypeOnly<current.ITelemetryContext>): void;
use_current_InterfaceDeclaration_ITelemetryContext(
    get_old_InterfaceDeclaration_ITelemetryContext());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryContext": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITelemetryContext():
    TypeOnly<current.ITelemetryContext>;
declare function use_old_InterfaceDeclaration_ITelemetryContext(
    use: TypeOnly<old.ITelemetryContext>): void;
use_old_InterfaceDeclaration_ITelemetryContext(
    get_current_InterfaceDeclaration_ITelemetryContext());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryContextExt": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITelemetryContextExt():
    TypeOnly<old.ITelemetryContextExt>;
declare function use_current_InterfaceDeclaration_ITelemetryContextExt(
    use: TypeOnly<current.ITelemetryContextExt>): void;
use_current_InterfaceDeclaration_ITelemetryContextExt(
    get_old_InterfaceDeclaration_ITelemetryContextExt());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITelemetryContextExt": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITelemetryContextExt():
    TypeOnly<current.ITelemetryContextExt>;
declare function use_old_InterfaceDeclaration_ITelemetryContextExt(
    use: TypeOnly<old.ITelemetryContextExt>): void;
use_old_InterfaceDeclaration_ITelemetryContextExt(
    get_current_InterfaceDeclaration_ITelemetryContextExt());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_InboundAttachMessage": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_InboundAttachMessage():
    TypeOnly<old.InboundAttachMessage>;
declare function use_current_TypeAliasDeclaration_InboundAttachMessage(
    use: TypeOnly<current.InboundAttachMessage>): void;
use_current_TypeAliasDeclaration_InboundAttachMessage(
    get_old_TypeAliasDeclaration_InboundAttachMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_InboundAttachMessage": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_InboundAttachMessage():
    TypeOnly<current.InboundAttachMessage>;
declare function use_old_TypeAliasDeclaration_InboundAttachMessage(
    use: TypeOnly<old.InboundAttachMessage>): void;
use_old_TypeAliasDeclaration_InboundAttachMessage(
    get_current_TypeAliasDeclaration_InboundAttachMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_LocalAttributionKey": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_LocalAttributionKey():
    TypeOnly<old.LocalAttributionKey>;
declare function use_current_InterfaceDeclaration_LocalAttributionKey(
    use: TypeOnly<current.LocalAttributionKey>): void;
use_current_InterfaceDeclaration_LocalAttributionKey(
    get_old_InterfaceDeclaration_LocalAttributionKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_LocalAttributionKey": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_LocalAttributionKey():
    TypeOnly<current.LocalAttributionKey>;
declare function use_old_InterfaceDeclaration_LocalAttributionKey(
    use: TypeOnly<old.LocalAttributionKey>): void;
use_old_InterfaceDeclaration_LocalAttributionKey(
    get_current_InterfaceDeclaration_LocalAttributionKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries():
    TypeOnly<old.NamedFluidDataStoreRegistryEntries>;
declare function use_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries(
    use: TypeOnly<current.NamedFluidDataStoreRegistryEntries>): void;
use_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries(
    get_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries():
    TypeOnly<current.NamedFluidDataStoreRegistryEntries>;
declare function use_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries(
    use: TypeOnly<old.NamedFluidDataStoreRegistryEntries>): void;
use_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries(
    get_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry():
    TypeOnly<old.NamedFluidDataStoreRegistryEntry>;
declare function use_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry(
    use: TypeOnly<current.NamedFluidDataStoreRegistryEntry>): void;
use_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry(
    get_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry():
    TypeOnly<current.NamedFluidDataStoreRegistryEntry>;
declare function use_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry(
    use: TypeOnly<old.NamedFluidDataStoreRegistryEntry>): void;
use_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry(
    get_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_OpAttributionKey": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_OpAttributionKey():
    TypeOnly<old.OpAttributionKey>;
declare function use_current_InterfaceDeclaration_OpAttributionKey(
    use: TypeOnly<current.OpAttributionKey>): void;
use_current_InterfaceDeclaration_OpAttributionKey(
    get_old_InterfaceDeclaration_OpAttributionKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_OpAttributionKey": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_OpAttributionKey():
    TypeOnly<current.OpAttributionKey>;
declare function use_old_InterfaceDeclaration_OpAttributionKey(
    use: TypeOnly<old.OpAttributionKey>): void;
use_old_InterfaceDeclaration_OpAttributionKey(
    get_current_InterfaceDeclaration_OpAttributionKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummarizeInternalFn": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SummarizeInternalFn():
    TypeOnly<old.SummarizeInternalFn>;
declare function use_current_TypeAliasDeclaration_SummarizeInternalFn(
    use: TypeOnly<current.SummarizeInternalFn>): void;
use_current_TypeAliasDeclaration_SummarizeInternalFn(
    get_old_TypeAliasDeclaration_SummarizeInternalFn());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SummarizeInternalFn": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SummarizeInternalFn():
    TypeOnly<current.SummarizeInternalFn>;
declare function use_old_TypeAliasDeclaration_SummarizeInternalFn(
    use: TypeOnly<old.SummarizeInternalFn>): void;
use_old_TypeAliasDeclaration_SummarizeInternalFn(
    get_current_TypeAliasDeclaration_SummarizeInternalFn());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_VisibilityState": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_VisibilityState():
    TypeOnly<typeof old.VisibilityState>;
declare function use_current_VariableDeclaration_VisibilityState(
    use: TypeOnly<typeof current.VisibilityState>): void;
use_current_VariableDeclaration_VisibilityState(
    get_old_VariableDeclaration_VisibilityState());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_VisibilityState": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_VisibilityState():
    TypeOnly<typeof current.VisibilityState>;
declare function use_old_VariableDeclaration_VisibilityState(
    use: TypeOnly<typeof old.VisibilityState>): void;
use_old_VariableDeclaration_VisibilityState(
    get_current_VariableDeclaration_VisibilityState());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_VisibilityState": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_VisibilityState():
    TypeOnly<old.VisibilityState>;
declare function use_current_TypeAliasDeclaration_VisibilityState(
    use: TypeOnly<current.VisibilityState>): void;
use_current_TypeAliasDeclaration_VisibilityState(
    get_old_TypeAliasDeclaration_VisibilityState());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_VisibilityState": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_VisibilityState():
    TypeOnly<current.VisibilityState>;
declare function use_old_TypeAliasDeclaration_VisibilityState(
    use: TypeOnly<old.VisibilityState>): void;
use_old_TypeAliasDeclaration_VisibilityState(
    get_current_TypeAliasDeclaration_VisibilityState());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_blobCountPropertyName": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_blobCountPropertyName():
    TypeOnly<typeof old.blobCountPropertyName>;
declare function use_current_VariableDeclaration_blobCountPropertyName(
    use: TypeOnly<typeof current.blobCountPropertyName>): void;
use_current_VariableDeclaration_blobCountPropertyName(
    get_old_VariableDeclaration_blobCountPropertyName());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_blobCountPropertyName": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_blobCountPropertyName():
    TypeOnly<typeof current.blobCountPropertyName>;
declare function use_old_VariableDeclaration_blobCountPropertyName(
    use: TypeOnly<typeof old.blobCountPropertyName>): void;
use_old_VariableDeclaration_blobCountPropertyName(
    get_current_VariableDeclaration_blobCountPropertyName());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_channelsTreeName": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_channelsTreeName():
    TypeOnly<typeof old.channelsTreeName>;
declare function use_current_VariableDeclaration_channelsTreeName(
    use: TypeOnly<typeof current.channelsTreeName>): void;
use_current_VariableDeclaration_channelsTreeName(
    get_old_VariableDeclaration_channelsTreeName());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_channelsTreeName": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_channelsTreeName():
    TypeOnly<typeof current.channelsTreeName>;
declare function use_old_VariableDeclaration_channelsTreeName(
    use: TypeOnly<typeof old.channelsTreeName>): void;
use_old_VariableDeclaration_channelsTreeName(
    get_current_VariableDeclaration_channelsTreeName());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_gcBlobPrefix": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_gcBlobPrefix():
    TypeOnly<typeof old.gcBlobPrefix>;
declare function use_current_VariableDeclaration_gcBlobPrefix(
    use: TypeOnly<typeof current.gcBlobPrefix>): void;
use_current_VariableDeclaration_gcBlobPrefix(
    get_old_VariableDeclaration_gcBlobPrefix());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_gcBlobPrefix": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_gcBlobPrefix():
    TypeOnly<typeof current.gcBlobPrefix>;
declare function use_old_VariableDeclaration_gcBlobPrefix(
    use: TypeOnly<typeof old.gcBlobPrefix>): void;
use_old_VariableDeclaration_gcBlobPrefix(
    get_current_VariableDeclaration_gcBlobPrefix());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_gcDataBlobKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_gcDataBlobKey():
    TypeOnly<typeof old.gcDataBlobKey>;
declare function use_current_VariableDeclaration_gcDataBlobKey(
    use: TypeOnly<typeof current.gcDataBlobKey>): void;
use_current_VariableDeclaration_gcDataBlobKey(
    get_old_VariableDeclaration_gcDataBlobKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_gcDataBlobKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_gcDataBlobKey():
    TypeOnly<typeof current.gcDataBlobKey>;
declare function use_old_VariableDeclaration_gcDataBlobKey(
    use: TypeOnly<typeof old.gcDataBlobKey>): void;
use_old_VariableDeclaration_gcDataBlobKey(
    get_current_VariableDeclaration_gcDataBlobKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_gcDeletedBlobKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_gcDeletedBlobKey():
    TypeOnly<typeof old.gcDeletedBlobKey>;
declare function use_current_VariableDeclaration_gcDeletedBlobKey(
    use: TypeOnly<typeof current.gcDeletedBlobKey>): void;
use_current_VariableDeclaration_gcDeletedBlobKey(
    get_old_VariableDeclaration_gcDeletedBlobKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_gcDeletedBlobKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_gcDeletedBlobKey():
    TypeOnly<typeof current.gcDeletedBlobKey>;
declare function use_old_VariableDeclaration_gcDeletedBlobKey(
    use: TypeOnly<typeof old.gcDeletedBlobKey>): void;
use_old_VariableDeclaration_gcDeletedBlobKey(
    get_current_VariableDeclaration_gcDeletedBlobKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_gcTombstoneBlobKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_gcTombstoneBlobKey():
    TypeOnly<typeof old.gcTombstoneBlobKey>;
declare function use_current_VariableDeclaration_gcTombstoneBlobKey(
    use: TypeOnly<typeof current.gcTombstoneBlobKey>): void;
use_current_VariableDeclaration_gcTombstoneBlobKey(
    get_old_VariableDeclaration_gcTombstoneBlobKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_gcTombstoneBlobKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_gcTombstoneBlobKey():
    TypeOnly<typeof current.gcTombstoneBlobKey>;
declare function use_old_VariableDeclaration_gcTombstoneBlobKey(
    use: TypeOnly<typeof old.gcTombstoneBlobKey>): void;
use_old_VariableDeclaration_gcTombstoneBlobKey(
    get_current_VariableDeclaration_gcTombstoneBlobKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_gcTreeKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_gcTreeKey():
    TypeOnly<typeof old.gcTreeKey>;
declare function use_current_VariableDeclaration_gcTreeKey(
    use: TypeOnly<typeof current.gcTreeKey>): void;
use_current_VariableDeclaration_gcTreeKey(
    get_old_VariableDeclaration_gcTreeKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_gcTreeKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_gcTreeKey():
    TypeOnly<typeof current.gcTreeKey>;
declare function use_old_VariableDeclaration_gcTreeKey(
    use: TypeOnly<typeof old.gcTreeKey>): void;
use_old_VariableDeclaration_gcTreeKey(
    get_current_VariableDeclaration_gcTreeKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_totalBlobSizePropertyName": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_totalBlobSizePropertyName():
    TypeOnly<typeof old.totalBlobSizePropertyName>;
declare function use_current_VariableDeclaration_totalBlobSizePropertyName(
    use: TypeOnly<typeof current.totalBlobSizePropertyName>): void;
use_current_VariableDeclaration_totalBlobSizePropertyName(
    get_old_VariableDeclaration_totalBlobSizePropertyName());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_totalBlobSizePropertyName": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_totalBlobSizePropertyName():
    TypeOnly<typeof current.totalBlobSizePropertyName>;
declare function use_old_VariableDeclaration_totalBlobSizePropertyName(
    use: TypeOnly<typeof old.totalBlobSizePropertyName>): void;
use_old_VariableDeclaration_totalBlobSizePropertyName(
    get_current_VariableDeclaration_totalBlobSizePropertyName());
