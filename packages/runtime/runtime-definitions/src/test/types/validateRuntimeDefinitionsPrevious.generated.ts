/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */

import type * as old from "@fluidframework/runtime-definitions-previous";
import type * as current from "../../index.js";


// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_AliasResult": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_AliasResult():
    TypeOnly<old.AliasResult>;
declare function use_current_TypeAliasDeclaration_AliasResult(
    use: TypeOnly<current.AliasResult>): void;
use_current_TypeAliasDeclaration_AliasResult(
    get_old_TypeAliasDeclaration_AliasResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_AliasResult": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_AliasResult():
    TypeOnly<current.AliasResult>;
declare function use_old_TypeAliasDeclaration_AliasResult(
    use: TypeOnly<old.AliasResult>): void;
use_old_TypeAliasDeclaration_AliasResult(
    get_current_TypeAliasDeclaration_AliasResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_AttributionInfo": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_AttributionInfo():
    TypeOnly<old.AttributionInfo>;
declare function use_current_InterfaceDeclaration_AttributionInfo(
    use: TypeOnly<current.AttributionInfo>): void;
use_current_InterfaceDeclaration_AttributionInfo(
    get_old_InterfaceDeclaration_AttributionInfo());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_AttributionInfo": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_AttributionInfo():
    TypeOnly<current.AttributionInfo>;
declare function use_old_InterfaceDeclaration_AttributionInfo(
    use: TypeOnly<old.AttributionInfo>): void;
use_old_InterfaceDeclaration_AttributionInfo(
    get_current_InterfaceDeclaration_AttributionInfo());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_AttributionKey": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_AttributionKey():
    TypeOnly<old.AttributionKey>;
declare function use_current_TypeAliasDeclaration_AttributionKey(
    use: TypeOnly<current.AttributionKey>): void;
use_current_TypeAliasDeclaration_AttributionKey(
    get_old_TypeAliasDeclaration_AttributionKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_AttributionKey": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_AttributionKey():
    TypeOnly<current.AttributionKey>;
declare function use_old_TypeAliasDeclaration_AttributionKey(
    use: TypeOnly<old.AttributionKey>): void;
use_old_TypeAliasDeclaration_AttributionKey(
    get_current_TypeAliasDeclaration_AttributionKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CreateChildSummarizerNodeFn": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_CreateChildSummarizerNodeFn():
    TypeOnly<old.CreateChildSummarizerNodeFn>;
declare function use_current_TypeAliasDeclaration_CreateChildSummarizerNodeFn(
    use: TypeOnly<current.CreateChildSummarizerNodeFn>): void;
use_current_TypeAliasDeclaration_CreateChildSummarizerNodeFn(
    get_old_TypeAliasDeclaration_CreateChildSummarizerNodeFn());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CreateChildSummarizerNodeFn": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_CreateChildSummarizerNodeFn():
    TypeOnly<current.CreateChildSummarizerNodeFn>;
declare function use_old_TypeAliasDeclaration_CreateChildSummarizerNodeFn(
    use: TypeOnly<old.CreateChildSummarizerNodeFn>): void;
use_old_TypeAliasDeclaration_CreateChildSummarizerNodeFn(
    get_current_TypeAliasDeclaration_CreateChildSummarizerNodeFn());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CreateChildSummarizerNodeParam": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_CreateChildSummarizerNodeParam():
    TypeOnly<old.CreateChildSummarizerNodeParam>;
declare function use_current_TypeAliasDeclaration_CreateChildSummarizerNodeParam(
    use: TypeOnly<current.CreateChildSummarizerNodeParam>): void;
use_current_TypeAliasDeclaration_CreateChildSummarizerNodeParam(
    get_old_TypeAliasDeclaration_CreateChildSummarizerNodeParam());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CreateChildSummarizerNodeParam": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_CreateChildSummarizerNodeParam():
    TypeOnly<current.CreateChildSummarizerNodeParam>;
declare function use_old_TypeAliasDeclaration_CreateChildSummarizerNodeParam(
    use: TypeOnly<old.CreateChildSummarizerNodeParam>): void;
use_old_TypeAliasDeclaration_CreateChildSummarizerNodeParam(
    get_current_TypeAliasDeclaration_CreateChildSummarizerNodeParam());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_CreateSummarizerNodeSource": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_CreateSummarizerNodeSource():
    TypeOnly<old.CreateSummarizerNodeSource>;
declare function use_current_EnumDeclaration_CreateSummarizerNodeSource(
    use: TypeOnly<current.CreateSummarizerNodeSource>): void;
use_current_EnumDeclaration_CreateSummarizerNodeSource(
    get_old_EnumDeclaration_CreateSummarizerNodeSource());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_CreateSummarizerNodeSource": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_CreateSummarizerNodeSource():
    TypeOnly<current.CreateSummarizerNodeSource>;
declare function use_old_EnumDeclaration_CreateSummarizerNodeSource(
    use: TypeOnly<old.CreateSummarizerNodeSource>): void;
use_old_EnumDeclaration_CreateSummarizerNodeSource(
    get_current_EnumDeclaration_CreateSummarizerNodeSource());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DetachedAttributionKey": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_DetachedAttributionKey():
    TypeOnly<old.DetachedAttributionKey>;
declare function use_current_InterfaceDeclaration_DetachedAttributionKey(
    use: TypeOnly<current.DetachedAttributionKey>): void;
use_current_InterfaceDeclaration_DetachedAttributionKey(
    get_old_InterfaceDeclaration_DetachedAttributionKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_DetachedAttributionKey": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_DetachedAttributionKey():
    TypeOnly<current.DetachedAttributionKey>;
declare function use_old_InterfaceDeclaration_DetachedAttributionKey(
    use: TypeOnly<old.DetachedAttributionKey>): void;
use_old_InterfaceDeclaration_DetachedAttributionKey(
    get_current_InterfaceDeclaration_DetachedAttributionKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidDataStoreRegistryEntry": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_FluidDataStoreRegistryEntry():
    TypeOnly<old.FluidDataStoreRegistryEntry>;
declare function use_current_TypeAliasDeclaration_FluidDataStoreRegistryEntry(
    use: TypeOnly<current.FluidDataStoreRegistryEntry>): void;
use_current_TypeAliasDeclaration_FluidDataStoreRegistryEntry(
    get_old_TypeAliasDeclaration_FluidDataStoreRegistryEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidDataStoreRegistryEntry": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_FluidDataStoreRegistryEntry():
    TypeOnly<current.FluidDataStoreRegistryEntry>;
declare function use_old_TypeAliasDeclaration_FluidDataStoreRegistryEntry(
    use: TypeOnly<old.FluidDataStoreRegistryEntry>): void;
use_old_TypeAliasDeclaration_FluidDataStoreRegistryEntry(
    get_current_TypeAliasDeclaration_FluidDataStoreRegistryEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_FlushMode": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_FlushMode():
    TypeOnly<old.FlushMode>;
declare function use_current_EnumDeclaration_FlushMode(
    use: TypeOnly<current.FlushMode>): void;
use_current_EnumDeclaration_FlushMode(
    get_old_EnumDeclaration_FlushMode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_FlushMode": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_FlushMode():
    TypeOnly<current.FlushMode>;
declare function use_old_EnumDeclaration_FlushMode(
    use: TypeOnly<old.FlushMode>): void;
use_old_EnumDeclaration_FlushMode(
    get_current_EnumDeclaration_FlushMode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_FlushModeExperimental": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_FlushModeExperimental():
    TypeOnly<old.FlushModeExperimental>;
declare function use_current_EnumDeclaration_FlushModeExperimental(
    use: TypeOnly<current.FlushModeExperimental>): void;
use_current_EnumDeclaration_FlushModeExperimental(
    get_old_EnumDeclaration_FlushModeExperimental());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_FlushModeExperimental": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_FlushModeExperimental():
    TypeOnly<current.FlushModeExperimental>;
declare function use_old_EnumDeclaration_FlushModeExperimental(
    use: TypeOnly<old.FlushModeExperimental>): void;
use_old_EnumDeclaration_FlushModeExperimental(
    get_current_EnumDeclaration_FlushModeExperimental());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAttachMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAttachMessage():
    TypeOnly<old.IAttachMessage>;
declare function use_current_InterfaceDeclaration_IAttachMessage(
    use: TypeOnly<current.IAttachMessage>): void;
use_current_InterfaceDeclaration_IAttachMessage(
    get_old_InterfaceDeclaration_IAttachMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAttachMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAttachMessage():
    TypeOnly<current.IAttachMessage>;
declare function use_old_InterfaceDeclaration_IAttachMessage(
    use: TypeOnly<old.IAttachMessage>): void;
use_old_InterfaceDeclaration_IAttachMessage(
    get_current_InterfaceDeclaration_IAttachMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerRuntimeBase():
    TypeOnly<old.IContainerRuntimeBase>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeBase(
    use: TypeOnly<current.IContainerRuntimeBase>): void;
use_current_InterfaceDeclaration_IContainerRuntimeBase(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IContainerRuntimeBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerRuntimeBase():
    TypeOnly<current.IContainerRuntimeBase>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeBase(
    use: TypeOnly<old.IContainerRuntimeBase>): void;
use_old_InterfaceDeclaration_IContainerRuntimeBase(
    get_current_InterfaceDeclaration_IContainerRuntimeBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeBaseEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerRuntimeBaseEvents():
    TypeOnly<old.IContainerRuntimeBaseEvents>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeBaseEvents(
    use: TypeOnly<current.IContainerRuntimeBaseEvents>): void;
use_current_InterfaceDeclaration_IContainerRuntimeBaseEvents(
    get_old_InterfaceDeclaration_IContainerRuntimeBaseEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeBaseEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerRuntimeBaseEvents():
    TypeOnly<current.IContainerRuntimeBaseEvents>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeBaseEvents(
    use: TypeOnly<old.IContainerRuntimeBaseEvents>): void;
use_old_InterfaceDeclaration_IContainerRuntimeBaseEvents(
    get_current_InterfaceDeclaration_IContainerRuntimeBaseEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDataStore": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDataStore():
    TypeOnly<old.IDataStore>;
declare function use_current_InterfaceDeclaration_IDataStore(
    use: TypeOnly<current.IDataStore>): void;
use_current_InterfaceDeclaration_IDataStore(
    get_old_InterfaceDeclaration_IDataStore());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDataStore": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDataStore():
    TypeOnly<current.IDataStore>;
declare function use_old_InterfaceDeclaration_IDataStore(
    use: TypeOnly<old.IDataStore>): void;
use_old_InterfaceDeclaration_IDataStore(
    get_current_InterfaceDeclaration_IDataStore());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEnvelope": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IEnvelope():
    TypeOnly<old.IEnvelope>;
declare function use_current_InterfaceDeclaration_IEnvelope(
    use: TypeOnly<current.IEnvelope>): void;
use_current_InterfaceDeclaration_IEnvelope(
    get_old_InterfaceDeclaration_IEnvelope());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEnvelope": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IEnvelope():
    TypeOnly<current.IEnvelope>;
declare function use_old_InterfaceDeclaration_IEnvelope(
    use: TypeOnly<old.IEnvelope>): void;
use_old_InterfaceDeclaration_IEnvelope(
    get_current_InterfaceDeclaration_IEnvelope());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IExperimentalIncrementalSummaryContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IExperimentalIncrementalSummaryContext():
    TypeOnly<old.IExperimentalIncrementalSummaryContext>;
declare function use_current_InterfaceDeclaration_IExperimentalIncrementalSummaryContext(
    use: TypeOnly<current.IExperimentalIncrementalSummaryContext>): void;
use_current_InterfaceDeclaration_IExperimentalIncrementalSummaryContext(
    get_old_InterfaceDeclaration_IExperimentalIncrementalSummaryContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IExperimentalIncrementalSummaryContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IExperimentalIncrementalSummaryContext():
    TypeOnly<current.IExperimentalIncrementalSummaryContext>;
declare function use_old_InterfaceDeclaration_IExperimentalIncrementalSummaryContext(
    use: TypeOnly<old.IExperimentalIncrementalSummaryContext>): void;
use_old_InterfaceDeclaration_IExperimentalIncrementalSummaryContext(
    get_current_InterfaceDeclaration_IExperimentalIncrementalSummaryContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreChannel": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidDataStoreChannel():
    TypeOnly<old.IFluidDataStoreChannel>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreChannel(
    use: TypeOnly<current.IFluidDataStoreChannel>): void;
use_current_InterfaceDeclaration_IFluidDataStoreChannel(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IFluidDataStoreChannel());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreChannel": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidDataStoreChannel():
    TypeOnly<current.IFluidDataStoreChannel>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreChannel(
    use: TypeOnly<old.IFluidDataStoreChannel>): void;
use_old_InterfaceDeclaration_IFluidDataStoreChannel(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IFluidDataStoreChannel());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidDataStoreContext():
    TypeOnly<old.IFluidDataStoreContext>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreContext(
    use: TypeOnly<current.IFluidDataStoreContext>): void;
use_current_InterfaceDeclaration_IFluidDataStoreContext(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IFluidDataStoreContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidDataStoreContext():
    TypeOnly<current.IFluidDataStoreContext>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreContext(
    use: TypeOnly<old.IFluidDataStoreContext>): void;
use_old_InterfaceDeclaration_IFluidDataStoreContext(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IFluidDataStoreContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreContextDetached": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidDataStoreContextDetached():
    TypeOnly<old.IFluidDataStoreContextDetached>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreContextDetached(
    use: TypeOnly<current.IFluidDataStoreContextDetached>): void;
use_current_InterfaceDeclaration_IFluidDataStoreContextDetached(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IFluidDataStoreContextDetached());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreContextDetached": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidDataStoreContextDetached():
    TypeOnly<current.IFluidDataStoreContextDetached>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreContextDetached(
    use: TypeOnly<old.IFluidDataStoreContextDetached>): void;
use_old_InterfaceDeclaration_IFluidDataStoreContextDetached(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IFluidDataStoreContextDetached());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedInterfaceDeclaration_IFluidDataStoreContextEvents": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedInterfaceDeclaration_IFluidDataStoreContextEvents": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidDataStoreFactory": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidDataStoreFactory():
    TypeOnly<typeof old.IFluidDataStoreFactory>;
declare function use_current_VariableDeclaration_IFluidDataStoreFactory(
    use: TypeOnly<typeof current.IFluidDataStoreFactory>): void;
use_current_VariableDeclaration_IFluidDataStoreFactory(
    get_old_VariableDeclaration_IFluidDataStoreFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidDataStoreFactory": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidDataStoreFactory():
    TypeOnly<typeof current.IFluidDataStoreFactory>;
declare function use_old_VariableDeclaration_IFluidDataStoreFactory(
    use: TypeOnly<typeof old.IFluidDataStoreFactory>): void;
use_old_VariableDeclaration_IFluidDataStoreFactory(
    get_current_VariableDeclaration_IFluidDataStoreFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidDataStoreFactory():
    TypeOnly<old.IFluidDataStoreFactory>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreFactory(
    use: TypeOnly<current.IFluidDataStoreFactory>): void;
use_current_InterfaceDeclaration_IFluidDataStoreFactory(
    get_old_InterfaceDeclaration_IFluidDataStoreFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidDataStoreFactory():
    TypeOnly<current.IFluidDataStoreFactory>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreFactory(
    use: TypeOnly<old.IFluidDataStoreFactory>): void;
use_old_InterfaceDeclaration_IFluidDataStoreFactory(
    get_current_InterfaceDeclaration_IFluidDataStoreFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidDataStoreRegistry": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidDataStoreRegistry():
    TypeOnly<typeof old.IFluidDataStoreRegistry>;
declare function use_current_VariableDeclaration_IFluidDataStoreRegistry(
    use: TypeOnly<typeof current.IFluidDataStoreRegistry>): void;
use_current_VariableDeclaration_IFluidDataStoreRegistry(
    get_old_VariableDeclaration_IFluidDataStoreRegistry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidDataStoreRegistry": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidDataStoreRegistry():
    TypeOnly<typeof current.IFluidDataStoreRegistry>;
declare function use_old_VariableDeclaration_IFluidDataStoreRegistry(
    use: TypeOnly<typeof old.IFluidDataStoreRegistry>): void;
use_old_VariableDeclaration_IFluidDataStoreRegistry(
    get_current_VariableDeclaration_IFluidDataStoreRegistry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreRegistry": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidDataStoreRegistry():
    TypeOnly<old.IFluidDataStoreRegistry>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreRegistry(
    use: TypeOnly<current.IFluidDataStoreRegistry>): void;
use_current_InterfaceDeclaration_IFluidDataStoreRegistry(
    get_old_InterfaceDeclaration_IFluidDataStoreRegistry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreRegistry": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidDataStoreRegistry():
    TypeOnly<current.IFluidDataStoreRegistry>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreRegistry(
    use: TypeOnly<old.IFluidDataStoreRegistry>): void;
use_old_InterfaceDeclaration_IFluidDataStoreRegistry(
    get_current_InterfaceDeclaration_IFluidDataStoreRegistry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGarbageCollectionData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGarbageCollectionData():
    TypeOnly<old.IGarbageCollectionData>;
declare function use_current_InterfaceDeclaration_IGarbageCollectionData(
    use: TypeOnly<current.IGarbageCollectionData>): void;
use_current_InterfaceDeclaration_IGarbageCollectionData(
    get_old_InterfaceDeclaration_IGarbageCollectionData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGarbageCollectionData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGarbageCollectionData():
    TypeOnly<current.IGarbageCollectionData>;
declare function use_old_InterfaceDeclaration_IGarbageCollectionData(
    use: TypeOnly<old.IGarbageCollectionData>): void;
use_old_InterfaceDeclaration_IGarbageCollectionData(
    get_current_InterfaceDeclaration_IGarbageCollectionData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGarbageCollectionDetailsBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGarbageCollectionDetailsBase():
    TypeOnly<old.IGarbageCollectionDetailsBase>;
declare function use_current_InterfaceDeclaration_IGarbageCollectionDetailsBase(
    use: TypeOnly<current.IGarbageCollectionDetailsBase>): void;
use_current_InterfaceDeclaration_IGarbageCollectionDetailsBase(
    get_old_InterfaceDeclaration_IGarbageCollectionDetailsBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGarbageCollectionDetailsBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGarbageCollectionDetailsBase():
    TypeOnly<current.IGarbageCollectionDetailsBase>;
declare function use_old_InterfaceDeclaration_IGarbageCollectionDetailsBase(
    use: TypeOnly<old.IGarbageCollectionDetailsBase>): void;
use_old_InterfaceDeclaration_IGarbageCollectionDetailsBase(
    get_current_InterfaceDeclaration_IGarbageCollectionDetailsBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInboundSignalMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInboundSignalMessage():
    TypeOnly<old.IInboundSignalMessage>;
declare function use_current_InterfaceDeclaration_IInboundSignalMessage(
    use: TypeOnly<current.IInboundSignalMessage>): void;
use_current_InterfaceDeclaration_IInboundSignalMessage(
    get_old_InterfaceDeclaration_IInboundSignalMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInboundSignalMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInboundSignalMessage():
    TypeOnly<current.IInboundSignalMessage>;
declare function use_old_InterfaceDeclaration_IInboundSignalMessage(
    use: TypeOnly<old.IInboundSignalMessage>): void;
use_old_InterfaceDeclaration_IInboundSignalMessage(
    get_current_InterfaceDeclaration_IInboundSignalMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidDataStoreFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidDataStoreFactory():
    TypeOnly<old.IProvideFluidDataStoreFactory>;
declare function use_current_InterfaceDeclaration_IProvideFluidDataStoreFactory(
    use: TypeOnly<current.IProvideFluidDataStoreFactory>): void;
use_current_InterfaceDeclaration_IProvideFluidDataStoreFactory(
    get_old_InterfaceDeclaration_IProvideFluidDataStoreFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidDataStoreFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidDataStoreFactory():
    TypeOnly<current.IProvideFluidDataStoreFactory>;
declare function use_old_InterfaceDeclaration_IProvideFluidDataStoreFactory(
    use: TypeOnly<old.IProvideFluidDataStoreFactory>): void;
use_old_InterfaceDeclaration_IProvideFluidDataStoreFactory(
    get_current_InterfaceDeclaration_IProvideFluidDataStoreFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidDataStoreRegistry": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidDataStoreRegistry():
    TypeOnly<old.IProvideFluidDataStoreRegistry>;
declare function use_current_InterfaceDeclaration_IProvideFluidDataStoreRegistry(
    use: TypeOnly<current.IProvideFluidDataStoreRegistry>): void;
use_current_InterfaceDeclaration_IProvideFluidDataStoreRegistry(
    get_old_InterfaceDeclaration_IProvideFluidDataStoreRegistry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidDataStoreRegistry": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidDataStoreRegistry():
    TypeOnly<current.IProvideFluidDataStoreRegistry>;
declare function use_old_InterfaceDeclaration_IProvideFluidDataStoreRegistry(
    use: TypeOnly<old.IProvideFluidDataStoreRegistry>): void;
use_old_InterfaceDeclaration_IProvideFluidDataStoreRegistry(
    get_current_InterfaceDeclaration_IProvideFluidDataStoreRegistry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISignalEnvelope": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISignalEnvelope():
    TypeOnly<old.ISignalEnvelope>;
declare function use_current_InterfaceDeclaration_ISignalEnvelope(
    use: TypeOnly<current.ISignalEnvelope>): void;
use_current_InterfaceDeclaration_ISignalEnvelope(
    get_old_InterfaceDeclaration_ISignalEnvelope());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISignalEnvelope": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISignalEnvelope():
    TypeOnly<current.ISignalEnvelope>;
declare function use_old_InterfaceDeclaration_ISignalEnvelope(
    use: TypeOnly<old.ISignalEnvelope>): void;
use_old_InterfaceDeclaration_ISignalEnvelope(
    get_current_InterfaceDeclaration_ISignalEnvelope());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeInternalResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizeInternalResult():
    TypeOnly<old.ISummarizeInternalResult>;
declare function use_current_InterfaceDeclaration_ISummarizeInternalResult(
    use: TypeOnly<current.ISummarizeInternalResult>): void;
use_current_InterfaceDeclaration_ISummarizeInternalResult(
    get_old_InterfaceDeclaration_ISummarizeInternalResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeInternalResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizeInternalResult():
    TypeOnly<current.ISummarizeInternalResult>;
declare function use_old_InterfaceDeclaration_ISummarizeInternalResult(
    use: TypeOnly<old.ISummarizeInternalResult>): void;
use_old_InterfaceDeclaration_ISummarizeInternalResult(
    get_current_InterfaceDeclaration_ISummarizeInternalResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizeResult():
    TypeOnly<old.ISummarizeResult>;
declare function use_current_InterfaceDeclaration_ISummarizeResult(
    use: TypeOnly<current.ISummarizeResult>): void;
use_current_InterfaceDeclaration_ISummarizeResult(
    get_old_InterfaceDeclaration_ISummarizeResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizeResult():
    TypeOnly<current.ISummarizeResult>;
declare function use_old_InterfaceDeclaration_ISummarizeResult(
    use: TypeOnly<old.ISummarizeResult>): void;
use_old_InterfaceDeclaration_ISummarizeResult(
    get_current_InterfaceDeclaration_ISummarizeResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerNode():
    TypeOnly<old.ISummarizerNode>;
declare function use_current_InterfaceDeclaration_ISummarizerNode(
    use: TypeOnly<current.ISummarizerNode>): void;
use_current_InterfaceDeclaration_ISummarizerNode(
    get_old_InterfaceDeclaration_ISummarizerNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerNode():
    TypeOnly<current.ISummarizerNode>;
declare function use_old_InterfaceDeclaration_ISummarizerNode(
    use: TypeOnly<old.ISummarizerNode>): void;
use_old_InterfaceDeclaration_ISummarizerNode(
    get_current_InterfaceDeclaration_ISummarizerNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNodeConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerNodeConfig():
    TypeOnly<old.ISummarizerNodeConfig>;
declare function use_current_InterfaceDeclaration_ISummarizerNodeConfig(
    use: TypeOnly<current.ISummarizerNodeConfig>): void;
use_current_InterfaceDeclaration_ISummarizerNodeConfig(
    get_old_InterfaceDeclaration_ISummarizerNodeConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNodeConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerNodeConfig():
    TypeOnly<current.ISummarizerNodeConfig>;
declare function use_old_InterfaceDeclaration_ISummarizerNodeConfig(
    use: TypeOnly<old.ISummarizerNodeConfig>): void;
use_old_InterfaceDeclaration_ISummarizerNodeConfig(
    get_current_InterfaceDeclaration_ISummarizerNodeConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNodeConfigWithGC": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerNodeConfigWithGC():
    TypeOnly<old.ISummarizerNodeConfigWithGC>;
declare function use_current_InterfaceDeclaration_ISummarizerNodeConfigWithGC(
    use: TypeOnly<current.ISummarizerNodeConfigWithGC>): void;
use_current_InterfaceDeclaration_ISummarizerNodeConfigWithGC(
    get_old_InterfaceDeclaration_ISummarizerNodeConfigWithGC());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNodeConfigWithGC": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerNodeConfigWithGC():
    TypeOnly<current.ISummarizerNodeConfigWithGC>;
declare function use_old_InterfaceDeclaration_ISummarizerNodeConfigWithGC(
    use: TypeOnly<old.ISummarizerNodeConfigWithGC>): void;
use_old_InterfaceDeclaration_ISummarizerNodeConfigWithGC(
    get_current_InterfaceDeclaration_ISummarizerNodeConfigWithGC());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNodeWithGC": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerNodeWithGC():
    TypeOnly<old.ISummarizerNodeWithGC>;
declare function use_current_InterfaceDeclaration_ISummarizerNodeWithGC(
    use: TypeOnly<current.ISummarizerNodeWithGC>): void;
use_current_InterfaceDeclaration_ISummarizerNodeWithGC(
    get_old_InterfaceDeclaration_ISummarizerNodeWithGC());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNodeWithGC": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerNodeWithGC():
    TypeOnly<current.ISummarizerNodeWithGC>;
declare function use_old_InterfaceDeclaration_ISummarizerNodeWithGC(
    use: TypeOnly<old.ISummarizerNodeWithGC>): void;
use_old_InterfaceDeclaration_ISummarizerNodeWithGC(
    get_current_InterfaceDeclaration_ISummarizerNodeWithGC());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryStats": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryStats():
    TypeOnly<old.ISummaryStats>;
declare function use_current_InterfaceDeclaration_ISummaryStats(
    use: TypeOnly<current.ISummaryStats>): void;
use_current_InterfaceDeclaration_ISummaryStats(
    get_old_InterfaceDeclaration_ISummaryStats());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryStats": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryStats():
    TypeOnly<current.ISummaryStats>;
declare function use_old_InterfaceDeclaration_ISummaryStats(
    use: TypeOnly<old.ISummaryStats>): void;
use_old_InterfaceDeclaration_ISummaryStats(
    get_current_InterfaceDeclaration_ISummaryStats());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryTreeWithStats": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryTreeWithStats():
    TypeOnly<old.ISummaryTreeWithStats>;
declare function use_current_InterfaceDeclaration_ISummaryTreeWithStats(
    use: TypeOnly<current.ISummaryTreeWithStats>): void;
use_current_InterfaceDeclaration_ISummaryTreeWithStats(
    get_old_InterfaceDeclaration_ISummaryTreeWithStats());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryTreeWithStats": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryTreeWithStats():
    TypeOnly<current.ISummaryTreeWithStats>;
declare function use_old_InterfaceDeclaration_ISummaryTreeWithStats(
    use: TypeOnly<old.ISummaryTreeWithStats>): void;
use_old_InterfaceDeclaration_ISummaryTreeWithStats(
    get_current_InterfaceDeclaration_ISummaryTreeWithStats());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryContext():
    TypeOnly<old.ITelemetryContext>;
declare function use_current_InterfaceDeclaration_ITelemetryContext(
    use: TypeOnly<current.ITelemetryContext>): void;
use_current_InterfaceDeclaration_ITelemetryContext(
    get_old_InterfaceDeclaration_ITelemetryContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryContext():
    TypeOnly<current.ITelemetryContext>;
declare function use_old_InterfaceDeclaration_ITelemetryContext(
    use: TypeOnly<old.ITelemetryContext>): void;
use_old_InterfaceDeclaration_ITelemetryContext(
    get_current_InterfaceDeclaration_ITelemetryContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_InboundAttachMessage": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_InboundAttachMessage():
    TypeOnly<old.InboundAttachMessage>;
declare function use_current_TypeAliasDeclaration_InboundAttachMessage(
    use: TypeOnly<current.InboundAttachMessage>): void;
use_current_TypeAliasDeclaration_InboundAttachMessage(
    get_old_TypeAliasDeclaration_InboundAttachMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_InboundAttachMessage": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_InboundAttachMessage():
    TypeOnly<current.InboundAttachMessage>;
declare function use_old_TypeAliasDeclaration_InboundAttachMessage(
    use: TypeOnly<old.InboundAttachMessage>): void;
use_old_TypeAliasDeclaration_InboundAttachMessage(
    get_current_TypeAliasDeclaration_InboundAttachMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_LocalAttributionKey": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_LocalAttributionKey():
    TypeOnly<old.LocalAttributionKey>;
declare function use_current_InterfaceDeclaration_LocalAttributionKey(
    use: TypeOnly<current.LocalAttributionKey>): void;
use_current_InterfaceDeclaration_LocalAttributionKey(
    get_old_InterfaceDeclaration_LocalAttributionKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_LocalAttributionKey": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_LocalAttributionKey():
    TypeOnly<current.LocalAttributionKey>;
declare function use_old_InterfaceDeclaration_LocalAttributionKey(
    use: TypeOnly<old.LocalAttributionKey>): void;
use_old_InterfaceDeclaration_LocalAttributionKey(
    get_current_InterfaceDeclaration_LocalAttributionKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries():
    TypeOnly<old.NamedFluidDataStoreRegistryEntries>;
declare function use_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries(
    use: TypeOnly<current.NamedFluidDataStoreRegistryEntries>): void;
use_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries(
    get_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries():
    TypeOnly<current.NamedFluidDataStoreRegistryEntries>;
declare function use_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries(
    use: TypeOnly<old.NamedFluidDataStoreRegistryEntries>): void;
use_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries(
    get_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry():
    TypeOnly<old.NamedFluidDataStoreRegistryEntry>;
declare function use_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry(
    use: TypeOnly<current.NamedFluidDataStoreRegistryEntry>): void;
use_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry(
    get_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry():
    TypeOnly<current.NamedFluidDataStoreRegistryEntry>;
declare function use_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry(
    use: TypeOnly<old.NamedFluidDataStoreRegistryEntry>): void;
use_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry(
    get_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_OpAttributionKey": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_OpAttributionKey():
    TypeOnly<old.OpAttributionKey>;
declare function use_current_InterfaceDeclaration_OpAttributionKey(
    use: TypeOnly<current.OpAttributionKey>): void;
use_current_InterfaceDeclaration_OpAttributionKey(
    get_old_InterfaceDeclaration_OpAttributionKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_OpAttributionKey": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_OpAttributionKey():
    TypeOnly<current.OpAttributionKey>;
declare function use_old_InterfaceDeclaration_OpAttributionKey(
    use: TypeOnly<old.OpAttributionKey>): void;
use_old_InterfaceDeclaration_OpAttributionKey(
    get_current_InterfaceDeclaration_OpAttributionKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizeInternalFn": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummarizeInternalFn():
    TypeOnly<old.SummarizeInternalFn>;
declare function use_current_TypeAliasDeclaration_SummarizeInternalFn(
    use: TypeOnly<current.SummarizeInternalFn>): void;
use_current_TypeAliasDeclaration_SummarizeInternalFn(
    get_old_TypeAliasDeclaration_SummarizeInternalFn());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizeInternalFn": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummarizeInternalFn():
    TypeOnly<current.SummarizeInternalFn>;
declare function use_old_TypeAliasDeclaration_SummarizeInternalFn(
    use: TypeOnly<old.SummarizeInternalFn>): void;
use_old_TypeAliasDeclaration_SummarizeInternalFn(
    get_current_TypeAliasDeclaration_SummarizeInternalFn());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_VisibilityState": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_VisibilityState():
    TypeOnly<typeof old.VisibilityState>;
declare function use_current_VariableDeclaration_VisibilityState(
    use: TypeOnly<typeof current.VisibilityState>): void;
use_current_VariableDeclaration_VisibilityState(
    get_old_VariableDeclaration_VisibilityState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_VisibilityState": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_VisibilityState():
    TypeOnly<typeof current.VisibilityState>;
declare function use_old_VariableDeclaration_VisibilityState(
    use: TypeOnly<typeof old.VisibilityState>): void;
use_old_VariableDeclaration_VisibilityState(
    get_current_VariableDeclaration_VisibilityState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_VisibilityState": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_VisibilityState():
    TypeOnly<old.VisibilityState>;
declare function use_current_TypeAliasDeclaration_VisibilityState(
    use: TypeOnly<current.VisibilityState>): void;
use_current_TypeAliasDeclaration_VisibilityState(
    get_old_TypeAliasDeclaration_VisibilityState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_VisibilityState": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_VisibilityState():
    TypeOnly<current.VisibilityState>;
declare function use_old_TypeAliasDeclaration_VisibilityState(
    use: TypeOnly<old.VisibilityState>): void;
use_old_TypeAliasDeclaration_VisibilityState(
    get_current_TypeAliasDeclaration_VisibilityState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_blobCountPropertyName": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_blobCountPropertyName():
    TypeOnly<typeof old.blobCountPropertyName>;
declare function use_current_VariableDeclaration_blobCountPropertyName(
    use: TypeOnly<typeof current.blobCountPropertyName>): void;
use_current_VariableDeclaration_blobCountPropertyName(
    get_old_VariableDeclaration_blobCountPropertyName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_blobCountPropertyName": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_blobCountPropertyName():
    TypeOnly<typeof current.blobCountPropertyName>;
declare function use_old_VariableDeclaration_blobCountPropertyName(
    use: TypeOnly<typeof old.blobCountPropertyName>): void;
use_old_VariableDeclaration_blobCountPropertyName(
    get_current_VariableDeclaration_blobCountPropertyName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_channelsTreeName": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_channelsTreeName():
    TypeOnly<typeof old.channelsTreeName>;
declare function use_current_VariableDeclaration_channelsTreeName(
    use: TypeOnly<typeof current.channelsTreeName>): void;
use_current_VariableDeclaration_channelsTreeName(
    get_old_VariableDeclaration_channelsTreeName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_channelsTreeName": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_channelsTreeName():
    TypeOnly<typeof current.channelsTreeName>;
declare function use_old_VariableDeclaration_channelsTreeName(
    use: TypeOnly<typeof old.channelsTreeName>): void;
use_old_VariableDeclaration_channelsTreeName(
    get_current_VariableDeclaration_channelsTreeName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_gcBlobPrefix": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_gcBlobPrefix():
    TypeOnly<typeof old.gcBlobPrefix>;
declare function use_current_VariableDeclaration_gcBlobPrefix(
    use: TypeOnly<typeof current.gcBlobPrefix>): void;
use_current_VariableDeclaration_gcBlobPrefix(
    get_old_VariableDeclaration_gcBlobPrefix());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_gcBlobPrefix": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_gcBlobPrefix():
    TypeOnly<typeof current.gcBlobPrefix>;
declare function use_old_VariableDeclaration_gcBlobPrefix(
    use: TypeOnly<typeof old.gcBlobPrefix>): void;
use_old_VariableDeclaration_gcBlobPrefix(
    get_current_VariableDeclaration_gcBlobPrefix());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_gcDeletedBlobKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_gcDeletedBlobKey():
    TypeOnly<typeof old.gcDeletedBlobKey>;
declare function use_current_VariableDeclaration_gcDeletedBlobKey(
    use: TypeOnly<typeof current.gcDeletedBlobKey>): void;
use_current_VariableDeclaration_gcDeletedBlobKey(
    get_old_VariableDeclaration_gcDeletedBlobKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_gcDeletedBlobKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_gcDeletedBlobKey():
    TypeOnly<typeof current.gcDeletedBlobKey>;
declare function use_old_VariableDeclaration_gcDeletedBlobKey(
    use: TypeOnly<typeof old.gcDeletedBlobKey>): void;
use_old_VariableDeclaration_gcDeletedBlobKey(
    get_current_VariableDeclaration_gcDeletedBlobKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_gcTombstoneBlobKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_gcTombstoneBlobKey():
    TypeOnly<typeof old.gcTombstoneBlobKey>;
declare function use_current_VariableDeclaration_gcTombstoneBlobKey(
    use: TypeOnly<typeof current.gcTombstoneBlobKey>): void;
use_current_VariableDeclaration_gcTombstoneBlobKey(
    get_old_VariableDeclaration_gcTombstoneBlobKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_gcTombstoneBlobKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_gcTombstoneBlobKey():
    TypeOnly<typeof current.gcTombstoneBlobKey>;
declare function use_old_VariableDeclaration_gcTombstoneBlobKey(
    use: TypeOnly<typeof old.gcTombstoneBlobKey>): void;
use_old_VariableDeclaration_gcTombstoneBlobKey(
    get_current_VariableDeclaration_gcTombstoneBlobKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_gcTreeKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_gcTreeKey():
    TypeOnly<typeof old.gcTreeKey>;
declare function use_current_VariableDeclaration_gcTreeKey(
    use: TypeOnly<typeof current.gcTreeKey>): void;
use_current_VariableDeclaration_gcTreeKey(
    get_old_VariableDeclaration_gcTreeKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_gcTreeKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_gcTreeKey():
    TypeOnly<typeof current.gcTreeKey>;
declare function use_old_VariableDeclaration_gcTreeKey(
    use: TypeOnly<typeof old.gcTreeKey>): void;
use_old_VariableDeclaration_gcTreeKey(
    get_current_VariableDeclaration_gcTreeKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_totalBlobSizePropertyName": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_totalBlobSizePropertyName():
    TypeOnly<typeof old.totalBlobSizePropertyName>;
declare function use_current_VariableDeclaration_totalBlobSizePropertyName(
    use: TypeOnly<typeof current.totalBlobSizePropertyName>): void;
use_current_VariableDeclaration_totalBlobSizePropertyName(
    get_old_VariableDeclaration_totalBlobSizePropertyName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_totalBlobSizePropertyName": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_totalBlobSizePropertyName():
    TypeOnly<typeof current.totalBlobSizePropertyName>;
declare function use_old_VariableDeclaration_totalBlobSizePropertyName(
    use: TypeOnly<typeof old.totalBlobSizePropertyName>): void;
use_old_VariableDeclaration_totalBlobSizePropertyName(
    get_current_VariableDeclaration_totalBlobSizePropertyName());
