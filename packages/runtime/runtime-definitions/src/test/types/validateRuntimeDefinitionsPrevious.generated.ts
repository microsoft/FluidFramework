/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/runtime-definitions-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_CreateSummarizerNodeSource": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_CreateSummarizerNodeSource = requireAssignableTo<TypeOnly<old.CreateSummarizerNodeSource>, TypeOnly<current.CreateSummarizerNodeSource>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_CreateSummarizerNodeSource": {"backCompat": false}
 */
declare type current_as_old_for_Enum_CreateSummarizerNodeSource = requireAssignableTo<TypeOnly<current.CreateSummarizerNodeSource>, TypeOnly<old.CreateSummarizerNodeSource>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_FlushMode": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_FlushMode = requireAssignableTo<TypeOnly<old.FlushMode>, TypeOnly<current.FlushMode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_FlushMode": {"backCompat": false}
 */
declare type current_as_old_for_Enum_FlushMode = requireAssignableTo<TypeOnly<current.FlushMode>, TypeOnly<old.FlushMode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAttachMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IAttachMessage = requireAssignableTo<TypeOnly<old.IAttachMessage>, TypeOnly<current.IAttachMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAttachMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IAttachMessage = requireAssignableTo<TypeOnly<current.IAttachMessage>, TypeOnly<old.IAttachMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContainerRuntimeBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IContainerRuntimeBase = requireAssignableTo<TypeOnly<old.IContainerRuntimeBase>, TypeOnly<current.IContainerRuntimeBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContainerRuntimeBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IContainerRuntimeBase = requireAssignableTo<TypeOnly<current.IContainerRuntimeBase>, TypeOnly<old.IContainerRuntimeBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContainerRuntimeBaseEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IContainerRuntimeBaseEvents = requireAssignableTo<TypeOnly<old.IContainerRuntimeBaseEvents>, TypeOnly<current.IContainerRuntimeBaseEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContainerRuntimeBaseEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IContainerRuntimeBaseEvents = requireAssignableTo<TypeOnly<current.IContainerRuntimeBaseEvents>, TypeOnly<old.IContainerRuntimeBaseEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDataStore": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDataStore = requireAssignableTo<TypeOnly<old.IDataStore>, TypeOnly<current.IDataStore>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDataStore": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDataStore = requireAssignableTo<TypeOnly<current.IDataStore>, TypeOnly<old.IDataStore>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEnvelope": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IEnvelope = requireAssignableTo<TypeOnly<old.IEnvelope>, TypeOnly<current.IEnvelope>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEnvelope": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IEnvelope = requireAssignableTo<TypeOnly<current.IEnvelope>, TypeOnly<old.IEnvelope>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreChannel": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDataStoreChannel = requireAssignableTo<TypeOnly<old.IFluidDataStoreChannel>, TypeOnly<current.IFluidDataStoreChannel>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreChannel": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDataStoreChannel = requireAssignableTo<TypeOnly<current.IFluidDataStoreChannel>, TypeOnly<old.IFluidDataStoreChannel>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDataStoreContext = requireAssignableTo<TypeOnly<old.IFluidDataStoreContext>, TypeOnly<current.IFluidDataStoreContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDataStoreContext = requireAssignableTo<TypeOnly<current.IFluidDataStoreContext>, TypeOnly<old.IFluidDataStoreContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreContextDetached": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDataStoreContextDetached = requireAssignableTo<TypeOnly<old.IFluidDataStoreContextDetached>, TypeOnly<current.IFluidDataStoreContextDetached>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreContextDetached": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDataStoreContextDetached = requireAssignableTo<TypeOnly<current.IFluidDataStoreContextDetached>, TypeOnly<old.IFluidDataStoreContextDetached>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreContextEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDataStoreContextEvents = requireAssignableTo<TypeOnly<old.IFluidDataStoreContextEvents>, TypeOnly<current.IFluidDataStoreContextEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreContextEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDataStoreContextEvents = requireAssignableTo<TypeOnly<current.IFluidDataStoreContextEvents>, TypeOnly<old.IFluidDataStoreContextEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDataStoreFactory = requireAssignableTo<TypeOnly<old.IFluidDataStoreFactory>, TypeOnly<current.IFluidDataStoreFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreFactory": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDataStoreFactory = requireAssignableTo<TypeOnly<current.IFluidDataStoreFactory>, TypeOnly<old.IFluidDataStoreFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreRegistry": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidDataStoreRegistry = requireAssignableTo<TypeOnly<old.IFluidDataStoreRegistry>, TypeOnly<current.IFluidDataStoreRegistry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidDataStoreRegistry": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidDataStoreRegistry = requireAssignableTo<TypeOnly<current.IFluidDataStoreRegistry>, TypeOnly<old.IFluidDataStoreRegistry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGarbageCollectionData": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGarbageCollectionData = requireAssignableTo<TypeOnly<old.IGarbageCollectionData>, TypeOnly<current.IGarbageCollectionData>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGarbageCollectionData": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGarbageCollectionData = requireAssignableTo<TypeOnly<current.IGarbageCollectionData>, TypeOnly<old.IGarbageCollectionData>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGarbageCollectionDetailsBase": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGarbageCollectionDetailsBase = requireAssignableTo<TypeOnly<old.IGarbageCollectionDetailsBase>, TypeOnly<current.IGarbageCollectionDetailsBase>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGarbageCollectionDetailsBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGarbageCollectionDetailsBase = requireAssignableTo<TypeOnly<current.IGarbageCollectionDetailsBase>, TypeOnly<old.IGarbageCollectionDetailsBase>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGarbageCollectionNodeData": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGarbageCollectionNodeData = requireAssignableTo<TypeOnly<old.IGarbageCollectionNodeData>, TypeOnly<current.IGarbageCollectionNodeData>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGarbageCollectionNodeData": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGarbageCollectionNodeData = requireAssignableTo<TypeOnly<current.IGarbageCollectionNodeData>, TypeOnly<old.IGarbageCollectionNodeData>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGarbageCollectionState": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGarbageCollectionState = requireAssignableTo<TypeOnly<old.IGarbageCollectionState>, TypeOnly<current.IGarbageCollectionState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGarbageCollectionState": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGarbageCollectionState = requireAssignableTo<TypeOnly<current.IGarbageCollectionState>, TypeOnly<old.IGarbageCollectionState>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IInboundSignalMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IInboundSignalMessage = requireAssignableTo<TypeOnly<old.IInboundSignalMessage>, TypeOnly<current.IInboundSignalMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IInboundSignalMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IInboundSignalMessage = requireAssignableTo<TypeOnly<current.IInboundSignalMessage>, TypeOnly<old.IInboundSignalMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidDataStoreFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProvideFluidDataStoreFactory = requireAssignableTo<TypeOnly<old.IProvideFluidDataStoreFactory>, TypeOnly<current.IProvideFluidDataStoreFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidDataStoreFactory": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProvideFluidDataStoreFactory = requireAssignableTo<TypeOnly<current.IProvideFluidDataStoreFactory>, TypeOnly<old.IProvideFluidDataStoreFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidDataStoreRegistry": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProvideFluidDataStoreRegistry = requireAssignableTo<TypeOnly<old.IProvideFluidDataStoreRegistry>, TypeOnly<current.IProvideFluidDataStoreRegistry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProvideFluidDataStoreRegistry": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProvideFluidDataStoreRegistry = requireAssignableTo<TypeOnly<current.IProvideFluidDataStoreRegistry>, TypeOnly<old.IProvideFluidDataStoreRegistry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISignalEnvelope": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISignalEnvelope = requireAssignableTo<TypeOnly<old.ISignalEnvelope>, TypeOnly<current.ISignalEnvelope>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISignalEnvelope": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISignalEnvelope = requireAssignableTo<TypeOnly<current.ISignalEnvelope>, TypeOnly<old.ISignalEnvelope>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeInternalResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizeInternalResult = requireAssignableTo<TypeOnly<old.ISummarizeInternalResult>, TypeOnly<current.ISummarizeInternalResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeInternalResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizeInternalResult = requireAssignableTo<TypeOnly<current.ISummarizeInternalResult>, TypeOnly<old.ISummarizeInternalResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizeResult = requireAssignableTo<TypeOnly<old.ISummarizeResult>, TypeOnly<current.ISummarizeResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizeResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizeResult = requireAssignableTo<TypeOnly<current.ISummarizeResult>, TypeOnly<old.ISummarizeResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizerNode = requireAssignableTo<TypeOnly<old.ISummarizerNode>, TypeOnly<current.ISummarizerNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizerNode = requireAssignableTo<TypeOnly<current.ISummarizerNode>, TypeOnly<old.ISummarizerNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNodeConfig": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizerNodeConfig = requireAssignableTo<TypeOnly<old.ISummarizerNodeConfig>, TypeOnly<current.ISummarizerNodeConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNodeConfig": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizerNodeConfig = requireAssignableTo<TypeOnly<current.ISummarizerNodeConfig>, TypeOnly<old.ISummarizerNodeConfig>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNodeConfigWithGC": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizerNodeConfigWithGC = requireAssignableTo<TypeOnly<old.ISummarizerNodeConfigWithGC>, TypeOnly<current.ISummarizerNodeConfigWithGC>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNodeConfigWithGC": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizerNodeConfigWithGC = requireAssignableTo<TypeOnly<current.ISummarizerNodeConfigWithGC>, TypeOnly<old.ISummarizerNodeConfigWithGC>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNodeWithGC": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummarizerNodeWithGC = requireAssignableTo<TypeOnly<old.ISummarizerNodeWithGC>, TypeOnly<current.ISummarizerNodeWithGC>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummarizerNodeWithGC": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummarizerNodeWithGC = requireAssignableTo<TypeOnly<current.ISummarizerNodeWithGC>, TypeOnly<old.ISummarizerNodeWithGC>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryStats": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryStats = requireAssignableTo<TypeOnly<old.ISummaryStats>, TypeOnly<current.ISummaryStats>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryStats": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryStats = requireAssignableTo<TypeOnly<current.ISummaryStats>, TypeOnly<old.ISummaryStats>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryTreeWithStats": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryTreeWithStats = requireAssignableTo<TypeOnly<old.ISummaryTreeWithStats>, TypeOnly<current.ISummaryTreeWithStats>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryTreeWithStats": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryTreeWithStats = requireAssignableTo<TypeOnly<current.ISummaryTreeWithStats>, TypeOnly<old.ISummaryTreeWithStats>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITelemetryContext = requireAssignableTo<TypeOnly<old.ITelemetryContext>, TypeOnly<current.ITelemetryContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryContext = requireAssignableTo<TypeOnly<current.ITelemetryContext>, TypeOnly<old.ITelemetryContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_AliasResult": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_AliasResult = requireAssignableTo<TypeOnly<old.AliasResult>, TypeOnly<current.AliasResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_AliasResult": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_AliasResult = requireAssignableTo<TypeOnly<current.AliasResult>, TypeOnly<old.AliasResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_CreateChildSummarizerNodeFn": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_CreateChildSummarizerNodeFn = requireAssignableTo<TypeOnly<old.CreateChildSummarizerNodeFn>, TypeOnly<current.CreateChildSummarizerNodeFn>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_CreateChildSummarizerNodeFn": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_CreateChildSummarizerNodeFn = requireAssignableTo<TypeOnly<current.CreateChildSummarizerNodeFn>, TypeOnly<old.CreateChildSummarizerNodeFn>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_CreateChildSummarizerNodeParam": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_CreateChildSummarizerNodeParam = requireAssignableTo<TypeOnly<old.CreateChildSummarizerNodeParam>, TypeOnly<current.CreateChildSummarizerNodeParam>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_CreateChildSummarizerNodeParam": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_CreateChildSummarizerNodeParam = requireAssignableTo<TypeOnly<current.CreateChildSummarizerNodeParam>, TypeOnly<old.CreateChildSummarizerNodeParam>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidDataStoreRegistryEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_FluidDataStoreRegistryEntry = requireAssignableTo<TypeOnly<old.FluidDataStoreRegistryEntry>, TypeOnly<current.FluidDataStoreRegistryEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_FluidDataStoreRegistryEntry": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_FluidDataStoreRegistryEntry = requireAssignableTo<TypeOnly<current.FluidDataStoreRegistryEntry>, TypeOnly<old.FluidDataStoreRegistryEntry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IGarbageCollectionSummaryDetails": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IGarbageCollectionSummaryDetails = requireAssignableTo<TypeOnly<old.IGarbageCollectionSummaryDetails>, TypeOnly<current.IGarbageCollectionSummaryDetails>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IGarbageCollectionSummaryDetails": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IGarbageCollectionSummaryDetails = requireAssignableTo<TypeOnly<current.IGarbageCollectionSummaryDetails>, TypeOnly<old.IGarbageCollectionSummaryDetails>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InboundAttachMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InboundAttachMessage = requireAssignableTo<TypeOnly<old.InboundAttachMessage>, TypeOnly<current.InboundAttachMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InboundAttachMessage": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InboundAttachMessage = requireAssignableTo<TypeOnly<current.InboundAttachMessage>, TypeOnly<old.InboundAttachMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_NamedFluidDataStoreRegistryEntries": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_NamedFluidDataStoreRegistryEntries = requireAssignableTo<TypeOnly<old.NamedFluidDataStoreRegistryEntries>, TypeOnly<current.NamedFluidDataStoreRegistryEntries>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_NamedFluidDataStoreRegistryEntries": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_NamedFluidDataStoreRegistryEntries = requireAssignableTo<TypeOnly<current.NamedFluidDataStoreRegistryEntries>, TypeOnly<old.NamedFluidDataStoreRegistryEntries>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_NamedFluidDataStoreRegistryEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_NamedFluidDataStoreRegistryEntry = requireAssignableTo<TypeOnly<old.NamedFluidDataStoreRegistryEntry>, TypeOnly<current.NamedFluidDataStoreRegistryEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_NamedFluidDataStoreRegistryEntry": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_NamedFluidDataStoreRegistryEntry = requireAssignableTo<TypeOnly<current.NamedFluidDataStoreRegistryEntry>, TypeOnly<old.NamedFluidDataStoreRegistryEntry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummarizeInternalFn": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SummarizeInternalFn = requireAssignableTo<TypeOnly<old.SummarizeInternalFn>, TypeOnly<current.SummarizeInternalFn>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SummarizeInternalFn": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SummarizeInternalFn = requireAssignableTo<TypeOnly<current.SummarizeInternalFn>, TypeOnly<old.SummarizeInternalFn>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_VisibilityState": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_VisibilityState = requireAssignableTo<TypeOnly<old.VisibilityState>, TypeOnly<current.VisibilityState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_VisibilityState": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_VisibilityState = requireAssignableTo<TypeOnly<current.VisibilityState>, TypeOnly<old.VisibilityState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_blobCountPropertyName": {"backCompat": false}
 */
declare type current_as_old_for_Variable_blobCountPropertyName = requireAssignableTo<TypeOnly<typeof current.blobCountPropertyName>, TypeOnly<typeof old.blobCountPropertyName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_channelsTreeName": {"backCompat": false}
 */
declare type current_as_old_for_Variable_channelsTreeName = requireAssignableTo<TypeOnly<typeof current.channelsTreeName>, TypeOnly<typeof old.channelsTreeName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_gcBlobKey": {"backCompat": false}
 */
declare type current_as_old_for_Variable_gcBlobKey = requireAssignableTo<TypeOnly<typeof current.gcBlobKey>, TypeOnly<typeof old.gcBlobKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IFluidDataStoreFactory": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IFluidDataStoreFactory = requireAssignableTo<TypeOnly<typeof current.IFluidDataStoreFactory>, TypeOnly<typeof old.IFluidDataStoreFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IFluidDataStoreRegistry": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IFluidDataStoreRegistry = requireAssignableTo<TypeOnly<typeof current.IFluidDataStoreRegistry>, TypeOnly<typeof old.IFluidDataStoreRegistry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_totalBlobSizePropertyName": {"backCompat": false}
 */
declare type current_as_old_for_Variable_totalBlobSizePropertyName = requireAssignableTo<TypeOnly<typeof current.totalBlobSizePropertyName>, TypeOnly<typeof old.totalBlobSizePropertyName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_VisibilityState": {"backCompat": false}
 */
declare type current_as_old_for_Variable_VisibilityState = requireAssignableTo<TypeOnly<typeof current.VisibilityState>, TypeOnly<typeof old.VisibilityState>>
