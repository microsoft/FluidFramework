/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "@fluidframework/runtime-definitions-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_AliasResult": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_AliasResult():
    TypeOnly<old.AliasResult>;
declare function use_current_TypeAliasDeclaration_AliasResult(
    use: TypeOnly<current.AliasResult>);
use_current_TypeAliasDeclaration_AliasResult(
    // @ts-expect-error compatibility expected to be broken
    get_old_TypeAliasDeclaration_AliasResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_AliasResult": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_AliasResult():
    TypeOnly<current.AliasResult>;
declare function use_old_TypeAliasDeclaration_AliasResult(
    use: TypeOnly<old.AliasResult>);
use_old_TypeAliasDeclaration_AliasResult(
    get_current_TypeAliasDeclaration_AliasResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_blobCountPropertyName": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_blobCountPropertyName():
    TypeOnly<typeof old.blobCountPropertyName>;
declare function use_current_VariableDeclaration_blobCountPropertyName(
    use: TypeOnly<typeof current.blobCountPropertyName>);
use_current_VariableDeclaration_blobCountPropertyName(
    get_old_VariableDeclaration_blobCountPropertyName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_blobCountPropertyName": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_blobCountPropertyName():
    TypeOnly<typeof current.blobCountPropertyName>;
declare function use_old_VariableDeclaration_blobCountPropertyName(
    use: TypeOnly<typeof old.blobCountPropertyName>);
use_old_VariableDeclaration_blobCountPropertyName(
    get_current_VariableDeclaration_blobCountPropertyName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_channelsTreeName": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_channelsTreeName():
    TypeOnly<typeof old.channelsTreeName>;
declare function use_current_VariableDeclaration_channelsTreeName(
    use: TypeOnly<typeof current.channelsTreeName>);
use_current_VariableDeclaration_channelsTreeName(
    get_old_VariableDeclaration_channelsTreeName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_channelsTreeName": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_channelsTreeName():
    TypeOnly<typeof current.channelsTreeName>;
declare function use_old_VariableDeclaration_channelsTreeName(
    use: TypeOnly<typeof old.channelsTreeName>);
use_old_VariableDeclaration_channelsTreeName(
    get_current_VariableDeclaration_channelsTreeName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CreateChildSummarizerNodeFn": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_CreateChildSummarizerNodeFn():
    TypeOnly<old.CreateChildSummarizerNodeFn>;
declare function use_current_TypeAliasDeclaration_CreateChildSummarizerNodeFn(
    use: TypeOnly<current.CreateChildSummarizerNodeFn>);
use_current_TypeAliasDeclaration_CreateChildSummarizerNodeFn(
    get_old_TypeAliasDeclaration_CreateChildSummarizerNodeFn());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CreateChildSummarizerNodeFn": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_CreateChildSummarizerNodeFn():
    TypeOnly<current.CreateChildSummarizerNodeFn>;
declare function use_old_TypeAliasDeclaration_CreateChildSummarizerNodeFn(
    use: TypeOnly<old.CreateChildSummarizerNodeFn>);
use_old_TypeAliasDeclaration_CreateChildSummarizerNodeFn(
    get_current_TypeAliasDeclaration_CreateChildSummarizerNodeFn());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CreateChildSummarizerNodeParam": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_CreateChildSummarizerNodeParam():
    TypeOnly<old.CreateChildSummarizerNodeParam>;
declare function use_current_TypeAliasDeclaration_CreateChildSummarizerNodeParam(
    use: TypeOnly<current.CreateChildSummarizerNodeParam>);
use_current_TypeAliasDeclaration_CreateChildSummarizerNodeParam(
    get_old_TypeAliasDeclaration_CreateChildSummarizerNodeParam());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CreateChildSummarizerNodeParam": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_CreateChildSummarizerNodeParam():
    TypeOnly<current.CreateChildSummarizerNodeParam>;
declare function use_old_TypeAliasDeclaration_CreateChildSummarizerNodeParam(
    use: TypeOnly<old.CreateChildSummarizerNodeParam>);
use_old_TypeAliasDeclaration_CreateChildSummarizerNodeParam(
    get_current_TypeAliasDeclaration_CreateChildSummarizerNodeParam());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_CreateSummarizerNodeSource": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_CreateSummarizerNodeSource():
    TypeOnly<old.CreateSummarizerNodeSource>;
declare function use_current_EnumDeclaration_CreateSummarizerNodeSource(
    use: TypeOnly<current.CreateSummarizerNodeSource>);
use_current_EnumDeclaration_CreateSummarizerNodeSource(
    get_old_EnumDeclaration_CreateSummarizerNodeSource());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_CreateSummarizerNodeSource": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_CreateSummarizerNodeSource():
    TypeOnly<current.CreateSummarizerNodeSource>;
declare function use_old_EnumDeclaration_CreateSummarizerNodeSource(
    use: TypeOnly<old.CreateSummarizerNodeSource>);
use_old_EnumDeclaration_CreateSummarizerNodeSource(
    get_current_EnumDeclaration_CreateSummarizerNodeSource());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidDataStoreRegistryEntry": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_FluidDataStoreRegistryEntry():
    TypeOnly<old.FluidDataStoreRegistryEntry>;
declare function use_current_TypeAliasDeclaration_FluidDataStoreRegistryEntry(
    use: TypeOnly<current.FluidDataStoreRegistryEntry>);
use_current_TypeAliasDeclaration_FluidDataStoreRegistryEntry(
    get_old_TypeAliasDeclaration_FluidDataStoreRegistryEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_FluidDataStoreRegistryEntry": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_FluidDataStoreRegistryEntry():
    TypeOnly<current.FluidDataStoreRegistryEntry>;
declare function use_old_TypeAliasDeclaration_FluidDataStoreRegistryEntry(
    use: TypeOnly<old.FluidDataStoreRegistryEntry>);
use_old_TypeAliasDeclaration_FluidDataStoreRegistryEntry(
    get_current_TypeAliasDeclaration_FluidDataStoreRegistryEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_FlushMode": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_FlushMode():
    TypeOnly<old.FlushMode>;
declare function use_current_EnumDeclaration_FlushMode(
    use: TypeOnly<current.FlushMode>);
use_current_EnumDeclaration_FlushMode(
    get_old_EnumDeclaration_FlushMode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_FlushMode": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_FlushMode():
    TypeOnly<current.FlushMode>;
declare function use_old_EnumDeclaration_FlushMode(
    use: TypeOnly<old.FlushMode>);
use_old_EnumDeclaration_FlushMode(
    get_current_EnumDeclaration_FlushMode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_gcBlobKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_gcBlobKey():
    TypeOnly<typeof old.gcBlobKey>;
declare function use_current_VariableDeclaration_gcBlobKey(
    use: TypeOnly<typeof current.gcBlobKey>);
use_current_VariableDeclaration_gcBlobKey(
    get_old_VariableDeclaration_gcBlobKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_gcBlobKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_gcBlobKey():
    TypeOnly<typeof current.gcBlobKey>;
declare function use_old_VariableDeclaration_gcBlobKey(
    use: TypeOnly<typeof old.gcBlobKey>);
use_old_VariableDeclaration_gcBlobKey(
    get_current_VariableDeclaration_gcBlobKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAttachMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAttachMessage():
    TypeOnly<old.IAttachMessage>;
declare function use_current_InterfaceDeclaration_IAttachMessage(
    use: TypeOnly<current.IAttachMessage>);
use_current_InterfaceDeclaration_IAttachMessage(
    get_old_InterfaceDeclaration_IAttachMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAttachMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAttachMessage():
    TypeOnly<current.IAttachMessage>;
declare function use_old_InterfaceDeclaration_IAttachMessage(
    use: TypeOnly<old.IAttachMessage>);
use_old_InterfaceDeclaration_IAttachMessage(
    get_current_InterfaceDeclaration_IAttachMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerRuntimeBase():
    TypeOnly<old.IContainerRuntimeBase>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeBase(
    use: TypeOnly<current.IContainerRuntimeBase>);
use_current_InterfaceDeclaration_IContainerRuntimeBase(
    get_old_InterfaceDeclaration_IContainerRuntimeBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerRuntimeBase():
    TypeOnly<current.IContainerRuntimeBase>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeBase(
    use: TypeOnly<old.IContainerRuntimeBase>);
use_old_InterfaceDeclaration_IContainerRuntimeBase(
    get_current_InterfaceDeclaration_IContainerRuntimeBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeBaseEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContainerRuntimeBaseEvents():
    TypeOnly<old.IContainerRuntimeBaseEvents>;
declare function use_current_InterfaceDeclaration_IContainerRuntimeBaseEvents(
    use: TypeOnly<current.IContainerRuntimeBaseEvents>);
use_current_InterfaceDeclaration_IContainerRuntimeBaseEvents(
    get_old_InterfaceDeclaration_IContainerRuntimeBaseEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContainerRuntimeBaseEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContainerRuntimeBaseEvents():
    TypeOnly<current.IContainerRuntimeBaseEvents>;
declare function use_old_InterfaceDeclaration_IContainerRuntimeBaseEvents(
    use: TypeOnly<old.IContainerRuntimeBaseEvents>);
use_old_InterfaceDeclaration_IContainerRuntimeBaseEvents(
    get_current_InterfaceDeclaration_IContainerRuntimeBaseEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDataStore": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDataStore():
    TypeOnly<old.IDataStore>;
declare function use_current_InterfaceDeclaration_IDataStore(
    use: TypeOnly<current.IDataStore>);
use_current_InterfaceDeclaration_IDataStore(
    get_old_InterfaceDeclaration_IDataStore());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDataStore": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDataStore():
    TypeOnly<current.IDataStore>;
declare function use_old_InterfaceDeclaration_IDataStore(
    use: TypeOnly<old.IDataStore>);
use_old_InterfaceDeclaration_IDataStore(
    get_current_InterfaceDeclaration_IDataStore());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEnvelope": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IEnvelope():
    TypeOnly<old.IEnvelope>;
declare function use_current_InterfaceDeclaration_IEnvelope(
    use: TypeOnly<current.IEnvelope>);
use_current_InterfaceDeclaration_IEnvelope(
    get_old_InterfaceDeclaration_IEnvelope());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEnvelope": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IEnvelope():
    TypeOnly<current.IEnvelope>;
declare function use_old_InterfaceDeclaration_IEnvelope(
    use: TypeOnly<old.IEnvelope>);
use_old_InterfaceDeclaration_IEnvelope(
    get_current_InterfaceDeclaration_IEnvelope());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreChannel": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidDataStoreChannel():
    TypeOnly<old.IFluidDataStoreChannel>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreChannel(
    use: TypeOnly<current.IFluidDataStoreChannel>);
use_current_InterfaceDeclaration_IFluidDataStoreChannel(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IFluidDataStoreChannel());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreChannel": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidDataStoreChannel():
    TypeOnly<current.IFluidDataStoreChannel>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreChannel(
    use: TypeOnly<old.IFluidDataStoreChannel>);
use_old_InterfaceDeclaration_IFluidDataStoreChannel(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IFluidDataStoreChannel());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidDataStoreContext():
    TypeOnly<old.IFluidDataStoreContext>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreContext(
    use: TypeOnly<current.IFluidDataStoreContext>);
use_current_InterfaceDeclaration_IFluidDataStoreContext(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IFluidDataStoreContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidDataStoreContext():
    TypeOnly<current.IFluidDataStoreContext>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreContext(
    use: TypeOnly<old.IFluidDataStoreContext>);
use_old_InterfaceDeclaration_IFluidDataStoreContext(
    get_current_InterfaceDeclaration_IFluidDataStoreContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreContextDetached": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidDataStoreContextDetached():
    TypeOnly<old.IFluidDataStoreContextDetached>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreContextDetached(
    use: TypeOnly<current.IFluidDataStoreContextDetached>);
use_current_InterfaceDeclaration_IFluidDataStoreContextDetached(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IFluidDataStoreContextDetached());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreContextDetached": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidDataStoreContextDetached():
    TypeOnly<current.IFluidDataStoreContextDetached>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreContextDetached(
    use: TypeOnly<old.IFluidDataStoreContextDetached>);
use_old_InterfaceDeclaration_IFluidDataStoreContextDetached(
    get_current_InterfaceDeclaration_IFluidDataStoreContextDetached());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreContextEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidDataStoreContextEvents():
    TypeOnly<old.IFluidDataStoreContextEvents>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreContextEvents(
    use: TypeOnly<current.IFluidDataStoreContextEvents>);
use_current_InterfaceDeclaration_IFluidDataStoreContextEvents(
    get_old_InterfaceDeclaration_IFluidDataStoreContextEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreContextEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidDataStoreContextEvents():
    TypeOnly<current.IFluidDataStoreContextEvents>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreContextEvents(
    use: TypeOnly<old.IFluidDataStoreContextEvents>);
use_old_InterfaceDeclaration_IFluidDataStoreContextEvents(
    get_current_InterfaceDeclaration_IFluidDataStoreContextEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidDataStoreFactory": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidDataStoreFactory():
    TypeOnly<typeof old.IFluidDataStoreFactory>;
declare function use_current_VariableDeclaration_IFluidDataStoreFactory(
    use: TypeOnly<typeof current.IFluidDataStoreFactory>);
use_current_VariableDeclaration_IFluidDataStoreFactory(
    get_old_VariableDeclaration_IFluidDataStoreFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidDataStoreFactory": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidDataStoreFactory():
    TypeOnly<typeof current.IFluidDataStoreFactory>;
declare function use_old_VariableDeclaration_IFluidDataStoreFactory(
    use: TypeOnly<typeof old.IFluidDataStoreFactory>);
use_old_VariableDeclaration_IFluidDataStoreFactory(
    get_current_VariableDeclaration_IFluidDataStoreFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidDataStoreFactory():
    TypeOnly<old.IFluidDataStoreFactory>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreFactory(
    use: TypeOnly<current.IFluidDataStoreFactory>);
use_current_InterfaceDeclaration_IFluidDataStoreFactory(
    get_old_InterfaceDeclaration_IFluidDataStoreFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidDataStoreFactory():
    TypeOnly<current.IFluidDataStoreFactory>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreFactory(
    use: TypeOnly<old.IFluidDataStoreFactory>);
use_old_InterfaceDeclaration_IFluidDataStoreFactory(
    get_current_InterfaceDeclaration_IFluidDataStoreFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidDataStoreRegistry": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_IFluidDataStoreRegistry():
    TypeOnly<typeof old.IFluidDataStoreRegistry>;
declare function use_current_VariableDeclaration_IFluidDataStoreRegistry(
    use: TypeOnly<typeof current.IFluidDataStoreRegistry>);
use_current_VariableDeclaration_IFluidDataStoreRegistry(
    get_old_VariableDeclaration_IFluidDataStoreRegistry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_IFluidDataStoreRegistry": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_IFluidDataStoreRegistry():
    TypeOnly<typeof current.IFluidDataStoreRegistry>;
declare function use_old_VariableDeclaration_IFluidDataStoreRegistry(
    use: TypeOnly<typeof old.IFluidDataStoreRegistry>);
use_old_VariableDeclaration_IFluidDataStoreRegistry(
    get_current_VariableDeclaration_IFluidDataStoreRegistry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreRegistry": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidDataStoreRegistry():
    TypeOnly<old.IFluidDataStoreRegistry>;
declare function use_current_InterfaceDeclaration_IFluidDataStoreRegistry(
    use: TypeOnly<current.IFluidDataStoreRegistry>);
use_current_InterfaceDeclaration_IFluidDataStoreRegistry(
    get_old_InterfaceDeclaration_IFluidDataStoreRegistry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidDataStoreRegistry": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidDataStoreRegistry():
    TypeOnly<current.IFluidDataStoreRegistry>;
declare function use_old_InterfaceDeclaration_IFluidDataStoreRegistry(
    use: TypeOnly<old.IFluidDataStoreRegistry>);
use_old_InterfaceDeclaration_IFluidDataStoreRegistry(
    get_current_InterfaceDeclaration_IFluidDataStoreRegistry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGarbageCollectionData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGarbageCollectionData():
    TypeOnly<old.IGarbageCollectionData>;
declare function use_current_InterfaceDeclaration_IGarbageCollectionData(
    use: TypeOnly<current.IGarbageCollectionData>);
use_current_InterfaceDeclaration_IGarbageCollectionData(
    get_old_InterfaceDeclaration_IGarbageCollectionData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGarbageCollectionData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGarbageCollectionData():
    TypeOnly<current.IGarbageCollectionData>;
declare function use_old_InterfaceDeclaration_IGarbageCollectionData(
    use: TypeOnly<old.IGarbageCollectionData>);
use_old_InterfaceDeclaration_IGarbageCollectionData(
    get_current_InterfaceDeclaration_IGarbageCollectionData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGarbageCollectionDetailsBase": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGarbageCollectionDetailsBase():
    TypeOnly<old.IGarbageCollectionDetailsBase>;
declare function use_current_InterfaceDeclaration_IGarbageCollectionDetailsBase(
    use: TypeOnly<current.IGarbageCollectionDetailsBase>);
use_current_InterfaceDeclaration_IGarbageCollectionDetailsBase(
    get_old_InterfaceDeclaration_IGarbageCollectionDetailsBase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGarbageCollectionDetailsBase": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGarbageCollectionDetailsBase():
    TypeOnly<current.IGarbageCollectionDetailsBase>;
declare function use_old_InterfaceDeclaration_IGarbageCollectionDetailsBase(
    use: TypeOnly<old.IGarbageCollectionDetailsBase>);
use_old_InterfaceDeclaration_IGarbageCollectionDetailsBase(
    get_current_InterfaceDeclaration_IGarbageCollectionDetailsBase());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGarbageCollectionNodeData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGarbageCollectionNodeData():
    TypeOnly<old.IGarbageCollectionNodeData>;
declare function use_current_InterfaceDeclaration_IGarbageCollectionNodeData(
    use: TypeOnly<current.IGarbageCollectionNodeData>);
use_current_InterfaceDeclaration_IGarbageCollectionNodeData(
    get_old_InterfaceDeclaration_IGarbageCollectionNodeData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGarbageCollectionNodeData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGarbageCollectionNodeData():
    TypeOnly<current.IGarbageCollectionNodeData>;
declare function use_old_InterfaceDeclaration_IGarbageCollectionNodeData(
    use: TypeOnly<old.IGarbageCollectionNodeData>);
use_old_InterfaceDeclaration_IGarbageCollectionNodeData(
    get_current_InterfaceDeclaration_IGarbageCollectionNodeData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGarbageCollectionState": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGarbageCollectionState():
    TypeOnly<old.IGarbageCollectionState>;
declare function use_current_InterfaceDeclaration_IGarbageCollectionState(
    use: TypeOnly<current.IGarbageCollectionState>);
use_current_InterfaceDeclaration_IGarbageCollectionState(
    get_old_InterfaceDeclaration_IGarbageCollectionState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGarbageCollectionState": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGarbageCollectionState():
    TypeOnly<current.IGarbageCollectionState>;
declare function use_old_InterfaceDeclaration_IGarbageCollectionState(
    use: TypeOnly<old.IGarbageCollectionState>);
use_old_InterfaceDeclaration_IGarbageCollectionState(
    get_current_InterfaceDeclaration_IGarbageCollectionState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IGarbageCollectionSummaryDetails": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IGarbageCollectionSummaryDetails():
    TypeOnly<old.IGarbageCollectionSummaryDetails>;
declare function use_current_TypeAliasDeclaration_IGarbageCollectionSummaryDetails(
    use: TypeOnly<current.IGarbageCollectionSummaryDetails>);
use_current_TypeAliasDeclaration_IGarbageCollectionSummaryDetails(
    get_old_TypeAliasDeclaration_IGarbageCollectionSummaryDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IGarbageCollectionSummaryDetails": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IGarbageCollectionSummaryDetails():
    TypeOnly<current.IGarbageCollectionSummaryDetails>;
declare function use_old_TypeAliasDeclaration_IGarbageCollectionSummaryDetails(
    use: TypeOnly<old.IGarbageCollectionSummaryDetails>);
use_old_TypeAliasDeclaration_IGarbageCollectionSummaryDetails(
    get_current_TypeAliasDeclaration_IGarbageCollectionSummaryDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInboundSignalMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInboundSignalMessage():
    TypeOnly<old.IInboundSignalMessage>;
declare function use_current_InterfaceDeclaration_IInboundSignalMessage(
    use: TypeOnly<current.IInboundSignalMessage>);
use_current_InterfaceDeclaration_IInboundSignalMessage(
    get_old_InterfaceDeclaration_IInboundSignalMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInboundSignalMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInboundSignalMessage():
    TypeOnly<current.IInboundSignalMessage>;
declare function use_old_InterfaceDeclaration_IInboundSignalMessage(
    use: TypeOnly<old.IInboundSignalMessage>);
use_old_InterfaceDeclaration_IInboundSignalMessage(
    get_current_InterfaceDeclaration_IInboundSignalMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_InboundAttachMessage": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_InboundAttachMessage():
    TypeOnly<old.InboundAttachMessage>;
declare function use_current_TypeAliasDeclaration_InboundAttachMessage(
    use: TypeOnly<current.InboundAttachMessage>);
use_current_TypeAliasDeclaration_InboundAttachMessage(
    get_old_TypeAliasDeclaration_InboundAttachMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_InboundAttachMessage": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_InboundAttachMessage():
    TypeOnly<current.InboundAttachMessage>;
declare function use_old_TypeAliasDeclaration_InboundAttachMessage(
    use: TypeOnly<old.InboundAttachMessage>);
use_old_TypeAliasDeclaration_InboundAttachMessage(
    get_current_TypeAliasDeclaration_InboundAttachMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidDataStoreFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidDataStoreFactory():
    TypeOnly<old.IProvideFluidDataStoreFactory>;
declare function use_current_InterfaceDeclaration_IProvideFluidDataStoreFactory(
    use: TypeOnly<current.IProvideFluidDataStoreFactory>);
use_current_InterfaceDeclaration_IProvideFluidDataStoreFactory(
    get_old_InterfaceDeclaration_IProvideFluidDataStoreFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidDataStoreFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidDataStoreFactory():
    TypeOnly<current.IProvideFluidDataStoreFactory>;
declare function use_old_InterfaceDeclaration_IProvideFluidDataStoreFactory(
    use: TypeOnly<old.IProvideFluidDataStoreFactory>);
use_old_InterfaceDeclaration_IProvideFluidDataStoreFactory(
    get_current_InterfaceDeclaration_IProvideFluidDataStoreFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidDataStoreRegistry": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideFluidDataStoreRegistry():
    TypeOnly<old.IProvideFluidDataStoreRegistry>;
declare function use_current_InterfaceDeclaration_IProvideFluidDataStoreRegistry(
    use: TypeOnly<current.IProvideFluidDataStoreRegistry>);
use_current_InterfaceDeclaration_IProvideFluidDataStoreRegistry(
    get_old_InterfaceDeclaration_IProvideFluidDataStoreRegistry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideFluidDataStoreRegistry": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideFluidDataStoreRegistry():
    TypeOnly<current.IProvideFluidDataStoreRegistry>;
declare function use_old_InterfaceDeclaration_IProvideFluidDataStoreRegistry(
    use: TypeOnly<old.IProvideFluidDataStoreRegistry>);
use_old_InterfaceDeclaration_IProvideFluidDataStoreRegistry(
    get_current_InterfaceDeclaration_IProvideFluidDataStoreRegistry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISignalEnvelope": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISignalEnvelope():
    TypeOnly<old.ISignalEnvelope>;
declare function use_current_InterfaceDeclaration_ISignalEnvelope(
    use: TypeOnly<current.ISignalEnvelope>);
use_current_InterfaceDeclaration_ISignalEnvelope(
    get_old_InterfaceDeclaration_ISignalEnvelope());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISignalEnvelope": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISignalEnvelope():
    TypeOnly<current.ISignalEnvelope>;
declare function use_old_InterfaceDeclaration_ISignalEnvelope(
    use: TypeOnly<old.ISignalEnvelope>);
use_old_InterfaceDeclaration_ISignalEnvelope(
    get_current_InterfaceDeclaration_ISignalEnvelope());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeInternalResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizeInternalResult():
    TypeOnly<old.ISummarizeInternalResult>;
declare function use_current_InterfaceDeclaration_ISummarizeInternalResult(
    use: TypeOnly<current.ISummarizeInternalResult>);
use_current_InterfaceDeclaration_ISummarizeInternalResult(
    get_old_InterfaceDeclaration_ISummarizeInternalResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeInternalResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizeInternalResult():
    TypeOnly<current.ISummarizeInternalResult>;
declare function use_old_InterfaceDeclaration_ISummarizeInternalResult(
    use: TypeOnly<old.ISummarizeInternalResult>);
use_old_InterfaceDeclaration_ISummarizeInternalResult(
    get_current_InterfaceDeclaration_ISummarizeInternalResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizeResult():
    TypeOnly<old.ISummarizeResult>;
declare function use_current_InterfaceDeclaration_ISummarizeResult(
    use: TypeOnly<current.ISummarizeResult>);
use_current_InterfaceDeclaration_ISummarizeResult(
    get_old_InterfaceDeclaration_ISummarizeResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizeResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizeResult():
    TypeOnly<current.ISummarizeResult>;
declare function use_old_InterfaceDeclaration_ISummarizeResult(
    use: TypeOnly<old.ISummarizeResult>);
use_old_InterfaceDeclaration_ISummarizeResult(
    get_current_InterfaceDeclaration_ISummarizeResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerNode():
    TypeOnly<old.ISummarizerNode>;
declare function use_current_InterfaceDeclaration_ISummarizerNode(
    use: TypeOnly<current.ISummarizerNode>);
use_current_InterfaceDeclaration_ISummarizerNode(
    get_old_InterfaceDeclaration_ISummarizerNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerNode():
    TypeOnly<current.ISummarizerNode>;
declare function use_old_InterfaceDeclaration_ISummarizerNode(
    use: TypeOnly<old.ISummarizerNode>);
use_old_InterfaceDeclaration_ISummarizerNode(
    get_current_InterfaceDeclaration_ISummarizerNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNodeConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerNodeConfig():
    TypeOnly<old.ISummarizerNodeConfig>;
declare function use_current_InterfaceDeclaration_ISummarizerNodeConfig(
    use: TypeOnly<current.ISummarizerNodeConfig>);
use_current_InterfaceDeclaration_ISummarizerNodeConfig(
    get_old_InterfaceDeclaration_ISummarizerNodeConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNodeConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerNodeConfig():
    TypeOnly<current.ISummarizerNodeConfig>;
declare function use_old_InterfaceDeclaration_ISummarizerNodeConfig(
    use: TypeOnly<old.ISummarizerNodeConfig>);
use_old_InterfaceDeclaration_ISummarizerNodeConfig(
    get_current_InterfaceDeclaration_ISummarizerNodeConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNodeConfigWithGC": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerNodeConfigWithGC():
    TypeOnly<old.ISummarizerNodeConfigWithGC>;
declare function use_current_InterfaceDeclaration_ISummarizerNodeConfigWithGC(
    use: TypeOnly<current.ISummarizerNodeConfigWithGC>);
use_current_InterfaceDeclaration_ISummarizerNodeConfigWithGC(
    get_old_InterfaceDeclaration_ISummarizerNodeConfigWithGC());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNodeConfigWithGC": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerNodeConfigWithGC():
    TypeOnly<current.ISummarizerNodeConfigWithGC>;
declare function use_old_InterfaceDeclaration_ISummarizerNodeConfigWithGC(
    use: TypeOnly<old.ISummarizerNodeConfigWithGC>);
use_old_InterfaceDeclaration_ISummarizerNodeConfigWithGC(
    get_current_InterfaceDeclaration_ISummarizerNodeConfigWithGC());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNodeWithGC": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummarizerNodeWithGC():
    TypeOnly<old.ISummarizerNodeWithGC>;
declare function use_current_InterfaceDeclaration_ISummarizerNodeWithGC(
    use: TypeOnly<current.ISummarizerNodeWithGC>);
use_current_InterfaceDeclaration_ISummarizerNodeWithGC(
    get_old_InterfaceDeclaration_ISummarizerNodeWithGC());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummarizerNodeWithGC": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummarizerNodeWithGC():
    TypeOnly<current.ISummarizerNodeWithGC>;
declare function use_old_InterfaceDeclaration_ISummarizerNodeWithGC(
    use: TypeOnly<old.ISummarizerNodeWithGC>);
use_old_InterfaceDeclaration_ISummarizerNodeWithGC(
    get_current_InterfaceDeclaration_ISummarizerNodeWithGC());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryStats": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryStats():
    TypeOnly<old.ISummaryStats>;
declare function use_current_InterfaceDeclaration_ISummaryStats(
    use: TypeOnly<current.ISummaryStats>);
use_current_InterfaceDeclaration_ISummaryStats(
    get_old_InterfaceDeclaration_ISummaryStats());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryStats": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryStats():
    TypeOnly<current.ISummaryStats>;
declare function use_old_InterfaceDeclaration_ISummaryStats(
    use: TypeOnly<old.ISummaryStats>);
use_old_InterfaceDeclaration_ISummaryStats(
    get_current_InterfaceDeclaration_ISummaryStats());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryTreeWithStats": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryTreeWithStats():
    TypeOnly<old.ISummaryTreeWithStats>;
declare function use_current_InterfaceDeclaration_ISummaryTreeWithStats(
    use: TypeOnly<current.ISummaryTreeWithStats>);
use_current_InterfaceDeclaration_ISummaryTreeWithStats(
    get_old_InterfaceDeclaration_ISummaryTreeWithStats());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryTreeWithStats": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryTreeWithStats():
    TypeOnly<current.ISummaryTreeWithStats>;
declare function use_old_InterfaceDeclaration_ISummaryTreeWithStats(
    use: TypeOnly<old.ISummaryTreeWithStats>);
use_old_InterfaceDeclaration_ISummaryTreeWithStats(
    get_current_InterfaceDeclaration_ISummaryTreeWithStats());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITelemetryContext():
    TypeOnly<old.ITelemetryContext>;
declare function use_current_InterfaceDeclaration_ITelemetryContext(
    use: TypeOnly<current.ITelemetryContext>);
use_current_InterfaceDeclaration_ITelemetryContext(
    get_old_InterfaceDeclaration_ITelemetryContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITelemetryContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITelemetryContext():
    TypeOnly<current.ITelemetryContext>;
declare function use_old_InterfaceDeclaration_ITelemetryContext(
    use: TypeOnly<old.ITelemetryContext>);
use_old_InterfaceDeclaration_ITelemetryContext(
    get_current_InterfaceDeclaration_ITelemetryContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries():
    TypeOnly<old.NamedFluidDataStoreRegistryEntries>;
declare function use_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries(
    use: TypeOnly<current.NamedFluidDataStoreRegistryEntries>);
use_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries(
    get_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries():
    TypeOnly<current.NamedFluidDataStoreRegistryEntries>;
declare function use_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries(
    use: TypeOnly<old.NamedFluidDataStoreRegistryEntries>);
use_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries(
    get_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntries());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry():
    TypeOnly<old.NamedFluidDataStoreRegistryEntry>;
declare function use_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry(
    use: TypeOnly<current.NamedFluidDataStoreRegistryEntry>);
use_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry(
    get_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry():
    TypeOnly<current.NamedFluidDataStoreRegistryEntry>;
declare function use_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry(
    use: TypeOnly<old.NamedFluidDataStoreRegistryEntry>);
use_old_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry(
    get_current_TypeAliasDeclaration_NamedFluidDataStoreRegistryEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizeInternalFn": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SummarizeInternalFn():
    TypeOnly<old.SummarizeInternalFn>;
declare function use_current_TypeAliasDeclaration_SummarizeInternalFn(
    use: TypeOnly<current.SummarizeInternalFn>);
use_current_TypeAliasDeclaration_SummarizeInternalFn(
    get_old_TypeAliasDeclaration_SummarizeInternalFn());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SummarizeInternalFn": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SummarizeInternalFn():
    TypeOnly<current.SummarizeInternalFn>;
declare function use_old_TypeAliasDeclaration_SummarizeInternalFn(
    use: TypeOnly<old.SummarizeInternalFn>);
use_old_TypeAliasDeclaration_SummarizeInternalFn(
    get_current_TypeAliasDeclaration_SummarizeInternalFn());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_totalBlobSizePropertyName": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_totalBlobSizePropertyName():
    TypeOnly<typeof old.totalBlobSizePropertyName>;
declare function use_current_VariableDeclaration_totalBlobSizePropertyName(
    use: TypeOnly<typeof current.totalBlobSizePropertyName>);
use_current_VariableDeclaration_totalBlobSizePropertyName(
    get_old_VariableDeclaration_totalBlobSizePropertyName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_totalBlobSizePropertyName": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_totalBlobSizePropertyName():
    TypeOnly<typeof current.totalBlobSizePropertyName>;
declare function use_old_VariableDeclaration_totalBlobSizePropertyName(
    use: TypeOnly<typeof old.totalBlobSizePropertyName>);
use_old_VariableDeclaration_totalBlobSizePropertyName(
    get_current_VariableDeclaration_totalBlobSizePropertyName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_VisibilityState": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_VisibilityState():
    TypeOnly<typeof old.VisibilityState>;
declare function use_current_VariableDeclaration_VisibilityState(
    use: TypeOnly<typeof current.VisibilityState>);
use_current_VariableDeclaration_VisibilityState(
    get_old_VariableDeclaration_VisibilityState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_VisibilityState": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_VisibilityState():
    TypeOnly<typeof current.VisibilityState>;
declare function use_old_VariableDeclaration_VisibilityState(
    use: TypeOnly<typeof old.VisibilityState>);
use_old_VariableDeclaration_VisibilityState(
    get_current_VariableDeclaration_VisibilityState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_VisibilityState": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_VisibilityState():
    TypeOnly<old.VisibilityState>;
declare function use_current_TypeAliasDeclaration_VisibilityState(
    use: TypeOnly<current.VisibilityState>);
use_current_TypeAliasDeclaration_VisibilityState(
    get_old_TypeAliasDeclaration_VisibilityState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_VisibilityState": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_VisibilityState():
    TypeOnly<current.VisibilityState>;
declare function use_old_TypeAliasDeclaration_VisibilityState(
    use: TypeOnly<old.VisibilityState>);
use_old_TypeAliasDeclaration_VisibilityState(
    get_current_TypeAliasDeclaration_VisibilityState());
