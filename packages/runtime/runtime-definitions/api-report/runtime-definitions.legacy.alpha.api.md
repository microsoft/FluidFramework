## Alpha API Report File for "@fluidframework/runtime-definitions"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @alpha
export type AliasResult = "Success" | "Conflict" | "AlreadyAliased";

// @alpha
export interface AttributionInfo {
    timestamp: number;
    user: IUser;
}

// @alpha
export type AttributionKey = OpAttributionKey | DetachedAttributionKey | LocalAttributionKey;

// @alpha (undocumented)
export type CreateChildSummarizerNodeFn = (summarizeInternal: SummarizeInternalFn, getGCDataFn: (fullGC?: boolean) => Promise<IGarbageCollectionData>,
getBaseGCDetailsFn?: () => Promise<IGarbageCollectionDetailsBase>) => ISummarizerNodeWithGC;

// @alpha (undocumented)
export type CreateChildSummarizerNodeParam = {
    type: CreateSummarizerNodeSource.FromSummary;
} | {
    type: CreateSummarizerNodeSource.FromAttach;
    sequenceNumber: number;
    snapshot: ITree;
} | {
    type: CreateSummarizerNodeSource.Local;
};

// @alpha (undocumented)
export enum CreateSummarizerNodeSource {
    // (undocumented)
    FromAttach = 1,
    // (undocumented)
    FromSummary = 0,
    // (undocumented)
    Local = 2
}

// @alpha
export interface DetachedAttributionKey {
    id: 0;
    // (undocumented)
    type: "detached";
}

// @alpha
export type FluidDataStoreRegistryEntry = Readonly<Partial<IProvideFluidDataStoreRegistry & IProvideFluidDataStoreFactory>>;

// @alpha
export enum FlushMode {
    // @deprecated
    Immediate = 0,
    TurnBased = 1
}

// @alpha
export interface IAttachMessage {
    id: string;
    snapshot: ITree;
    type: string;
}

// @alpha
export interface IContainerRuntimeBase extends IEventProvider<IContainerRuntimeBaseEvents> {
    // (undocumented)
    readonly baseLogger: ITelemetryBaseLogger;
    // (undocumented)
    readonly clientDetails: IClientDetails;
    createDataStore(pkg: Readonly<string | string[]>, loadingGroupId?: string): Promise<IDataStore>;
    // @deprecated (undocumented)
    _createDataStoreWithProps(pkg: Readonly<string | string[]>, props?: any, id?: string): Promise<IDataStore>;
    createDetachedDataStore(pkg: Readonly<string[]>, loadingGroupId?: string): IFluidDataStoreContextDetached;
    // (undocumented)
    readonly disposed: boolean;
    generateDocumentUniqueId(): number | string;
    getAbsoluteUrl(relativeUrl: string): Promise<string | undefined>;
    getAudience(): IAudience;
    getQuorum(): IQuorumClients;
    getSnapshotForLoadingGroupId(loadingGroupIds: string[], pathParts: string[]): Promise<{
        snapshotTree: ISnapshotTree;
        sequenceNumber: number;
    }>;
    orderSequentially(callback: () => void): void;
    submitSignal: (type: string, content: unknown, targetClientId?: string) => void;
    // (undocumented)
    uploadBlob(blob: ArrayBufferLike, signal?: AbortSignal): Promise<IFluidHandle<ArrayBufferLike>>;
}

// @alpha (undocumented)
export interface IContainerRuntimeBaseEvents extends IEvent {
    // (undocumented)
    (event: "batchBegin", listener: (op: ISequencedDocumentMessage) => void): any;
    // (undocumented)
    (event: "op", listener: (op: ISequencedDocumentMessage, runtimeMessage?: boolean) => void): any;
    // (undocumented)
    (event: "batchEnd", listener: (error: any, op: ISequencedDocumentMessage) => void): any;
    // (undocumented)
    (event: "signal", listener: (message: IInboundSignalMessage, local: boolean) => void): any;
    // (undocumented)
    (event: "dispose", listener: () => void): any;
}

// @alpha
export interface IDataStore {
    readonly entryPoint: IFluidHandleInternal<FluidObject>;
    trySetAlias(alias: string): Promise<AliasResult>;
}

// @alpha
export interface IEnvelope {
    address: string;
    contents: any;
}

// @alpha
export interface IExperimentalIncrementalSummaryContext {
    latestSummarySequenceNumber: number;
    summaryPath: string;
    summarySequenceNumber: number;
}

// @alpha
export interface IFluidDataStoreChannel extends IDisposable {
    // (undocumented)
    applyStashedOp(content: any): Promise<unknown>;
    readonly entryPoint: IFluidHandleInternal<FluidObject>;
    getAttachGCData(telemetryContext?: ITelemetryContext): IGarbageCollectionData;
    getAttachSummary(telemetryContext?: ITelemetryContext): ISummaryTreeWithStats;
    getGCData(fullGC?: boolean): Promise<IGarbageCollectionData>;
    makeVisibleAndAttachGraph(): void;
    process(message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown): void;
    processSignal(message: IInboundSignalMessage, local: boolean): void;
    // (undocumented)
    request(request: IRequest): Promise<IResponse>;
    reSubmit(type: string, content: any, localOpMetadata: unknown): any;
    rollback?(type: string, content: any, localOpMetadata: unknown): void;
    // (undocumented)
    setAttachState(attachState: AttachState.Attaching | AttachState.Attached): void;
    setConnectionState(connected: boolean, clientId?: string): any;
    summarize(fullTree?: boolean, trackState?: boolean, telemetryContext?: ITelemetryContext): Promise<ISummaryTreeWithStats>;
    updateUsedRoutes(usedRoutes: string[]): void;
}

// @alpha
export interface IFluidDataStoreContext extends IFluidParentContext {
    // (undocumented)
    readonly baseSnapshot: ISnapshotTree | undefined;
    // @deprecated (undocumented)
    readonly createProps?: any;
    // @deprecated (undocumented)
    getBaseGCDetails(): Promise<IGarbageCollectionDetailsBase>;
    // (undocumented)
    readonly id: string;
    readonly isLocalDataStore: boolean;
    readonly packagePath: readonly string[];
}

// @alpha (undocumented)
export interface IFluidDataStoreContextDetached extends IFluidDataStoreContext {
    attachRuntime(factory: IProvideFluidDataStoreFactory, dataStoreRuntime: IFluidDataStoreChannel): Promise<IDataStore>;
}

// @alpha (undocumented)
export const IFluidDataStoreFactory: keyof IProvideFluidDataStoreFactory;

// @alpha
export interface IFluidDataStoreFactory extends IProvideFluidDataStoreFactory {
    instantiateDataStore(context: IFluidDataStoreContext, existing: boolean): Promise<IFluidDataStoreChannel>;
    type: string;
}

// @alpha (undocumented)
export const IFluidDataStoreRegistry: keyof IProvideFluidDataStoreRegistry;

// @alpha
export interface IFluidDataStoreRegistry extends IProvideFluidDataStoreRegistry {
    // (undocumented)
    get(name: string): Promise<FluidDataStoreRegistryEntry | undefined>;
}

// @alpha
export interface IFluidParentContext extends IProvideFluidHandleContext, Partial<IProvideFluidDataStoreRegistry> {
    addedGCOutboundRoute(fromPath: string, toPath: string, messageTimestampMs?: number): void;
    readonly attachState: AttachState;
    // (undocumented)
    readonly baseLogger: ITelemetryBaseLogger;
    // (undocumented)
    readonly clientDetails: IClientDetails;
    // (undocumented)
    readonly clientId: string | undefined;
    // (undocumented)
    readonly connected: boolean;
    // (undocumented)
    readonly containerRuntime: IContainerRuntimeBase;
    // (undocumented)
    deleteChildSummarizerNode(id: string): void;
    // (undocumented)
    readonly deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;
    // @deprecated
    ensureNoDataModelChanges<T>(callback: () => T): T;
    // (undocumented)
    readonly gcThrowOnTombstoneUsage: boolean;
    // (undocumented)
    readonly gcTombstoneEnforcementAllowed: boolean;
    getAbsoluteUrl(relativeUrl: string): Promise<string | undefined>;
    getAudience(): IAudience;
    // (undocumented)
    getCreateChildSummarizerNodeFn(
    id: string,
    createParam: CreateChildSummarizerNodeParam): CreateChildSummarizerNodeFn;
    getQuorum(): IQuorumClients;
    // (undocumented)
    readonly idCompressor?: IIdCompressor;
    readonly loadingGroupId?: string;
    makeLocallyVisible(): void;
    // (undocumented)
    readonly options: Record<string | number, any>;
    readonly scope: FluidObject;
    setChannelDirty(address: string): void;
    // (undocumented)
    readonly storage: IDocumentStorageService;
    submitMessage(type: string, content: any, localOpMetadata: unknown): void;
    submitSignal: (type: string, content: unknown, targetClientId?: string) => void;
    // (undocumented)
    uploadBlob(blob: ArrayBufferLike, signal?: AbortSignal): Promise<IFluidHandleInternal<ArrayBufferLike>>;
}

// @alpha
export interface IGarbageCollectionData {
    gcNodes: {
        [id: string]: string[];
    };
}

// @alpha
export interface IGarbageCollectionDetailsBase {
    gcData?: IGarbageCollectionData;
    usedRoutes?: string[];
}

// @alpha
export interface IInboundSignalMessage extends ISignalMessage {
    // (undocumented)
    readonly type: string;
}

// @alpha
export type InboundAttachMessage = Omit<IAttachMessage, "snapshot"> & {
    snapshot: IAttachMessage["snapshot"] | null;
};

// @alpha (undocumented)
export interface IProvideFluidDataStoreFactory {
    // (undocumented)
    readonly IFluidDataStoreFactory: IFluidDataStoreFactory;
}

// @alpha (undocumented)
export interface IProvideFluidDataStoreRegistry {
    // (undocumented)
    readonly IFluidDataStoreRegistry: IFluidDataStoreRegistry;
}

// @alpha
export interface ISummarizeInternalResult extends ISummarizeResult {
    // (undocumented)
    id: string;
    pathPartsForChildren?: string[];
}

// @alpha
export interface ISummarizeResult {
    // (undocumented)
    stats: ISummaryStats;
    // (undocumented)
    summary: SummaryTree;
}

// @alpha (undocumented)
export interface ISummarizerNode {
    // (undocumented)
    createChild(
    summarizeInternalFn: SummarizeInternalFn,
    id: string,
    createParam: CreateChildSummarizerNodeParam,
    config?: ISummarizerNodeConfig): ISummarizerNode;
    // (undocumented)
    getChild(id: string): ISummarizerNode | undefined;
    invalidate(sequenceNumber: number): void;
    isSummaryInProgress?(): boolean;
    recordChange(op: ISequencedDocumentMessage): void;
    readonly referenceSequenceNumber: number;
    summarize(fullTree: boolean, trackState?: boolean, telemetryContext?: ITelemetryContext): Promise<ISummarizeResult>;
    updateBaseSummaryState(snapshot: ISnapshotTree): void;
}

// @alpha (undocumented)
export interface ISummarizerNodeConfig {
    readonly canReuseHandle?: boolean;
}

// @alpha (undocumented)
export interface ISummarizerNodeConfigWithGC extends ISummarizerNodeConfig {
    readonly gcDisabled?: boolean;
}

// @alpha
export interface ISummarizerNodeWithGC extends ISummarizerNode {
    // (undocumented)
    createChild(
    summarizeInternalFn: SummarizeInternalFn,
    id: string,
    createParam: CreateChildSummarizerNodeParam,
    config?: ISummarizerNodeConfigWithGC, getGCDataFn?: (fullGC?: boolean) => Promise<IGarbageCollectionData>,
    getBaseGCDetailsFn?: () => Promise<IGarbageCollectionDetailsBase>): ISummarizerNodeWithGC;
    deleteChild(id: string): void;
    // (undocumented)
    getChild(id: string): ISummarizerNodeWithGC | undefined;
    getGCData(fullGC?: boolean): Promise<IGarbageCollectionData>;
    isReferenced(): boolean;
    updateUsedRoutes(usedRoutes: string[]): void;
}

// @alpha
export interface ISummaryStats {
    // (undocumented)
    blobNodeCount: number;
    // (undocumented)
    handleNodeCount: number;
    // (undocumented)
    totalBlobSize: number;
    // (undocumented)
    treeNodeCount: number;
    // (undocumented)
    unreferencedBlobSize: number;
}

// @alpha
export interface ISummaryTreeWithStats {
    stats: ISummaryStats;
    summary: ISummaryTree;
}

// @alpha
export interface ITelemetryContext {
    set(prefix: string, property: string, value: TelemetryBaseEventPropertyType): void;
    setMultiple(prefix: string, property: string, values: Record<string, TelemetryBaseEventPropertyType>): void;
}

// @alpha
export interface LocalAttributionKey {
    // (undocumented)
    type: "local";
}

// @alpha
export type NamedFluidDataStoreRegistryEntries = Iterable<NamedFluidDataStoreRegistryEntry>;

// @alpha
export type NamedFluidDataStoreRegistryEntry = [string, Promise<FluidDataStoreRegistryEntry>];

// @alpha
export interface OpAttributionKey {
    seq: number;
    type: "op";
}

// @alpha (undocumented)
export type SummarizeInternalFn = (fullTree: boolean, trackState: boolean, telemetryContext?: ITelemetryContext, incrementalSummaryContext?: IExperimentalIncrementalSummaryContext) => Promise<ISummarizeInternalResult>;

// @alpha
export const VisibilityState: {
    NotVisible: string;
    LocallyVisible: string;
    GloballyVisible: string;
};

// @alpha (undocumented)
export type VisibilityState = (typeof VisibilityState)[keyof typeof VisibilityState];

// (No @packageDocumentation comment for this package)

```
