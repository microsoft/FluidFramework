/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

import { strict as assert } from "assert";
import { ITelemetryErrorEvent, ITelemetryLogger } from "@fluidframework/common-definitions";
import { IGraphNode } from "@fluidframework/runtime-definitions";
import { runGarbageCollection } from "../garbageCollector";
import { IGCResult } from "../interfaces";

describe("Garbage Collector", () => {
    let logger: ITelemetryLogger;
    let errorEvents: ITelemetryErrorEvent[];

    beforeEach(() => {
        logger = {
            sendErrorEvent: (event: ITelemetryErrorEvent) => errorEvents.push(event),
        } as unknown as ITelemetryLogger;
    });

    afterEach(() => {
        errorEvents = [];
    });

    function runGCAndValidateResults(referenceGraph: IGraphNode[], startingIds: string[], deletedNodes: IGraphNode[]) {
        // Referenced nodes are all nodes in the referenceGraph that are not in deletedNodes.
        const referencedNodes: IGraphNode[] = referenceGraph.filter((node) => !deletedNodes.includes(node));

        const gcResult: IGCResult = runGarbageCollection(referenceGraph, startingIds, logger);
        assert.deepStrictEqual(
            gcResult.referencedNodes.sort(),
            referencedNodes.sort(),
            "Referenced nodes generated by GC are incorrect");
        assert.deepStrictEqual(
            gcResult.deletedNodes.sort(),
            deletedNodes.sort(),
            "Deleted nodes generated by GC are incorrect");
    }

    it("should not collect nodes when all nodes are referenced", () => {
        const gcNode1: IGraphNode = { id: "/", outboundRoutes: [ "/ds1" ] };
        const gcNode2: IGraphNode = { id: "/ds1", outboundRoutes: [ "/ds1/dds1" ] };
        const gcNode3: IGraphNode = { id: "/ds2", outboundRoutes: [] };
        const gcNode4: IGraphNode = { id: "/ds1/dds1", outboundRoutes: [ "/ds2" ] };

        const referenceGraph = [ gcNode1, gcNode2, gcNode3, gcNode4 ];
        const deletedNodes = [];

        runGCAndValidateResults(referenceGraph, [ "/" ], deletedNodes);
    });

    it("should collect nodes that are not referenced", () => {
        const gcNode1: IGraphNode = { id: "/", outboundRoutes: [ "/ds1" ] };
        const gcNode2: IGraphNode = { id: "/ds1", outboundRoutes: [ "/ds1/dds1" ] };
        const gcNode3: IGraphNode = { id: "/ds1/dds1", outboundRoutes: [] };
        // The following nodes are not referenced by any of the nodes above.
        const gcNode4: IGraphNode = { id: "/ds2", outboundRoutes: [ "/ds2/dds1" ] };
        const gcNode5: IGraphNode = { id: "/ds2/dds1", outboundRoutes: [] };

        const referenceGraph = [ gcNode1, gcNode2, gcNode3, gcNode4, gcNode5 ];
        const deletedNodes = [ gcNode4, gcNode5 ];

        runGCAndValidateResults(referenceGraph, [ "/" ], deletedNodes);
    });

    it("should collect nodes with cycles in the graph", () => {
        const gcNode1: IGraphNode = { id: "/", outboundRoutes: [ "/ds1" ] };
        const gcNode2: IGraphNode = { id: "/ds1", outboundRoutes: [ "/ds1/dds1" ] };
        const gcNode3: IGraphNode = { id: "/ds2", outboundRoutes: [ "/ds2/dds1" ] };
        const gcNode4: IGraphNode = { id: "/ds1/dds1", outboundRoutes: [ "/ds2", "/ds1" ] };
        const gcNode5: IGraphNode = { id: "/ds2/dds1", outboundRoutes: [ "/ds1", "/ds2"] };
        // The following node is not referenced by any of the nodes above.
        const gcNode6: IGraphNode = { id: "/ds3", outboundRoutes: [] };

        const referenceGraph = [ gcNode1, gcNode2, gcNode3, gcNode4, gcNode5, gcNode6 ];
        const deletedNodes = [ gcNode6 ];

        runGCAndValidateResults(referenceGraph, [ "/" ], deletedNodes);
    });

    it("should collect nodes with multiple starting ids", () => {
        const gcNode1: IGraphNode = { id: "/", outboundRoutes: [ "/ds1" ] };
        const gcNode2: IGraphNode = { id: "/ds1", outboundRoutes: [ "/ds1/dds1" ] };
        const gcNode3: IGraphNode = { id: "/ds1/dds1", outboundRoutes: [] };
        // The following node is not referenced by any of the nodes above. But its id will be given as starting id to
        // GC, so it will be referenced.
        const gcNode4: IGraphNode = { id: "/ds2", outboundRoutes: [ "/ds2/dds1" ] };
        const gcNode5: IGraphNode = { id: "/ds2/dds1", outboundRoutes: [] };
        // The following node is not referenced by any of the nodes above.
        const gcNode6: IGraphNode = { id: "/ds3", outboundRoutes: [] };

        const referenceGraph = [ gcNode1, gcNode2, gcNode3, gcNode4, gcNode5, gcNode6 ];
        const deletedNodes = [ gcNode6 ];

        runGCAndValidateResults(referenceGraph, [ "/", "/ds2" ], deletedNodes);
    });

    it("should log error when a referenced node is missing from the graph", () => {
        const gcNode1: IGraphNode = { id: "/", outboundRoutes: [ "/ds1" ] };
        const gcNode2: IGraphNode = { id: "/ds1", outboundRoutes: [ "/ds1/dds1" ] };
        const gcNode3: IGraphNode = { id: "/ds2", outboundRoutes: [] };
        const gcNode4: IGraphNode = { id: "/ds1/dds1", outboundRoutes: [ "/ds2", "/ds3" ] };
        // The following node is not referenced by any of the nodes above.
        const gcNode5: IGraphNode = { id: "/ds2/dds1", outboundRoutes: [] };

        const referenceGraph = [ gcNode1, gcNode2, gcNode3, gcNode4, gcNode5 ];
        const deletedNodes = [ gcNode5 ];

        runGCAndValidateResults(referenceGraph, [ "/" ], deletedNodes);

        const errorEvent = { eventName: "MissingGCNode", missingNodeId: "/ds3" };
        assert.deepStrictEqual(errorEvents, [ errorEvent ], "Error events not generated by GC is incorrect");
    });
});
