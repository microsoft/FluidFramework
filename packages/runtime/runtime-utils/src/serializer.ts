/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/* THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. */

/* eslint-disable @typescript-eslint/no-unsafe-return */

import {
    IFluidHandle,
    IFluidHandleContext,
    IFluidSerializer,
} from "@fluidframework/core-interfaces";
import { RemoteFluidObjectHandle } from "./remoteObjectHandle";
import { generateHandleContextPath } from "./dataStoreHandleContextUtils";
import { isSerializedHandle } from "./utils";

/**
 * Data Store serializer implementation
 */
export class FluidSerializer implements IFluidSerializer {
    private readonly root: IFluidHandleContext;

    public constructor(private readonly context: IFluidHandleContext) {
        this.root = this.context;
        while (this.root.routeContext !== undefined) {
            this.root = this.root.routeContext;
        }
    }

    public get IFluidSerializer() { return this; }

    public replaceHandles(
        input: any,
        bind: IFluidHandle,
    ) {
        // If the given 'input' cannot contain handles, return it immediately.  Otherwise,
        // return the result of 'recursivelyEncode()'.
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return !!input && typeof input === "object"
            ? this.recursivelyEncode(input, bind)
            : input;
    }

    // TODO: The below proof-of-concept implementation of 'decode()' will be enabled with tests
    //       and benchmarks once the refactoring to use EJS codegen lands.
    /*
    public decode(
        input: any,
    ) {
        // If the given 'input' cannot contain handles, return it immediately.  Otherwise,
        // return the result of 'recursivelyDecode()'.
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return !!input && typeof input === "object"
            ? this.recursivelyDecode(input)
            : input;
    }
    */

    public stringify(input: any, bind: IFluidHandle) {
        return JSON.stringify(input, (key, value) => {
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (value) {
                // If 'value' is an IFluidHandle return its serialized form.
                const handle = value.IFluidHandle;
                if (handle !== undefined) {
                    return this.serializeHandle(handle, bind);
                }
            }
            return value;
        });
    }

    // Parses the serialized data - context must match the context with which the JSON was stringified
    public parse(input: string) {
        return JSON.parse(
            input,
            (key, value) => {
                // If 'value' is a serialized IFluidHandle return the deserialized result.
                if (isSerializedHandle(value)) {
                    // Old documents may have handles with relative path in their summaries. Convert these to absolute
                    // paths. This will ensure that future summaries will have absolute paths for these handles.
                    const absolutePath = value.url.startsWith("/")
                        ? value.url
                        : generateHandleContextPath(value.url, this.context);

                    return new RemoteFluidObjectHandle(absolutePath, this.root);
                }
                return value;
            });
    }

    // Invoked for non-null objects to recursively encode references to IFluidHandles.
    // Clones as-needed to avoid mutating the 'input' object.  If no IFluidHandes are present,
    // returns the original 'input'.
    private recursivelyEncode(input: any, bind: IFluidHandle) {
        // Note: Caller is responsible for ensuring that 'input' is a non-null object.

        // If 'input' is an IFluidHandle return its serialized form.
        const handle = input.IFluidHandle;
        if (handle !== undefined) {
            return this.serializeHandle(handle, bind);
        }

        // Otherwise descend into the object graph looking for IFluidHandle instances.
        // eslint-disable-next-line @typescript-eslint/ban-types
        let clone: object | undefined;
        for (const key of Object.keys(input)) {
            const value = input[key];
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (!!value && typeof value === "object") {
                // Note: Except for IFluidHandle, 'input' must not contain circular references (as object must
                //       be JSON serializable.)  Therefore, guarding against infinite recursion here would only
                //       lead to a later error when attempting to stringify().
                const replaced = this.recursivelyEncode(value, bind);

                // If the 'replaced' object is different than the original 'value' then the subgraph contained one
                // or more handles.  If this happens, we need to return a clone of the 'input' object where the
                // current property is replaced by the 'replaced' value.
                if (replaced !== value) {
                    // Lazily create a shallow clone of the 'input' object if we haven't done so already.
                    clone = clone ?? (Array.isArray(input)
                        ? [...input]
                        : { ...input });

                    // Overwrite the current property 'key' in the clone with the 'replaced' value.
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    clone![key] = replaced;
                }
            }
        }
        return clone ?? input;
    }

// TODO: The below proof-of-concept implementation of 'recursivelyDecode()' will be enabled
//       once the refactoring to use EJS codegen lands.
/*
    // Invoked for non-null objects to recursively decode references to IFluidHandles.
    // Clones as-needed to avoid mutating the 'input' object.  If no IFluidHandes are present,
    // returns the original 'input'.
    private recursivelyDecode(input: any) {
        // Note: Caller is responsible for ensuring that 'input' is a non-null object.

        // If 'input' is a serialized IFluidHandle return the deserialized result.
        if (isSerializedHandle(input)) {
            // Old documents may have handles with relative path in their summaries. Convert these to absolute
            // paths. This will ensure that future summaries will have absolute paths for these handles.
            const absolutePath = input.url.startsWith("/")
                ? input.url
                : generateHandleContextPath(input.url, this.context);

            return new RemoteFluidObjectHandle(absolutePath, this.root);
        }

        // Otherwise descend into the object graph looking for IFluidHandle instances.
        // eslint-disable-next-line @typescript-eslint/ban-types
        let clone: object | undefined;
        for (const key of Object.keys(input)) {
            const value = input[key];
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (!!value && typeof value === "object") {
                // Note: Except for IFluidHandle, 'input' must not contain circular references (as object must
                //       be JSON serializable.)  Therefore, guarding against infinite recursion here would only
                //       lead to a later error when attempting to stringify().
                const replaced = this.recursivelyDecode(value);

                // If the 'replaced' object is different than the original 'value' then the subgraph contained one
                // or more handles.  If this happens, we need to return a clone of the 'input' object where the
                // current property is replaced by the 'replaced' value.
                if (replaced !== value) {
                    // Lazily create a shallow clone of the 'input' object if we haven't done so already.
                    clone = clone ?? (Array.isArray(input)
                        ? [...input]
                        : { ...input });

                    // Overwrite the current property 'key' in the clone with the 'replaced' value.
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    clone![key] = replaced;
                }
            }
        }
        return clone ?? input;
    }
*/

    protected serializeHandle(handle: IFluidHandle, bind: IFluidHandle) {
        bind.bind(handle);
        return {
            type: "__fluid_handle__",
            url: handle.absolutePath,
        };
    }
}
