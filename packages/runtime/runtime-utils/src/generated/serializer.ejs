/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
<%_
    // Perf: The motivation for this EJS template is share common code between 'recursivelyEncode()'
    //       and 'recursivelyDecode()' without introducing a ~0.5x performance loss due to introducing
    //       a callback (node 12 x64).

    /** Returns true if the given string contains all whitespace. */
    function isEmpty(line) { return line.trim().length === 0; }

    /** Returns the number of whitespace characters at the beginning of the string. */
    function countLeadingWhiteSpace(line) { return line.match(/^(\s*)/)[1].length; }

    /**
     * Given a string, removes all leading and trailing blank lines, then unindents all lines by
     * the number of whitespace characters at the beginning of the first non-blank line.
     *
     * Before: "\n\n    foo() {\n        bar();\n    }\n"
     * After:  "foo() {\n    bar();\n    }"
     *
     * This prepares the given string for the 'indent()' function below.
     */
    function trim(s) {
        let lines = s.split("\n");

        // Remove leading and trailing blank lines.
        let leadingBlanks = 0;
        for (; leadingBlanks < lines.length && isEmpty(lines[leadingBlanks]); leadingBlanks++);

        let trailingBlanks = lines.length - 1;
        for (; trailingBlanks >= 0 && isEmpty(lines[trailingBlanks]); trailingBlanks--);

        lines = lines.slice(leadingBlanks, trailingBlanks + 1);

        // Unindent all lines by the number of whitespace characters at the beginning of the
        // first line.
        const firstLineIndent = countLeadingWhiteSpace(lines[0]);
        lines = lines.map((line) => {
            const leadingWhiteSpace = countLeadingWhiteSpace(line);
            if (leadingWhiteSpace < firstLineIndent && !isEmpty(line)) {
                throw new Error(`Inconsistent indentation '${line}' (expected ${firstLineIndent}, but got ${leadingWhiteSpace})`);
            }

            return line.slice(firstLineIndent);
        })

        return lines.join(`\n`);
    }

    /**
     * Apply 'count' indentations to each line in the given string.  One indentation = 4 spaces.
     */
    function indent(s, count) {
        const spaces = " ".repeat(count * 4);

        return s.split(`\n`)
            .map(line => line.length > 0
                ? `${spaces}${line}`
                : line)
            .join("\n");
    }

    /**
     * Emits the code for encoding a value.  Used by 'stringify()' and 'encodeRecursively()'.
     */
    function encodeValue(varName) {
        return trim(`
            // If '${varName}' is an IFluidHandle return its serialized form.
            const handle = ${varName}.IFluidHandle;
            if (handle !== undefined) {
                return this.serializeHandle(handle, bind);
            }
        `);
    }

    /**
     * Emits the code for decoding a value.  Used by 'parse()' and 'decodeRecursively()'.
     */
    function decodeValue(varName) {
        return trim(`
            // If '${varName}' is a serialized IFluidHandle return the deserialized result.
            if (isSerializedHandle(${varName})) {
                // Old documents may have handles with relative path in their summaries. Convert these to absolute
                // paths. This will ensure that future summaries will have absolute paths for these handles.
                const absolutePath = ${varName}.url.startsWith("/")
                    ? ${varName}.url
                    : generateHandleContextPath(${varName}.url, this.context);

                return new RemoteFluidObjectHandle(absolutePath, this.root);
            }
        `);
    }

    /**
     * Emits 'recursivelyEncode()' and 'recursivelyDecode()'.
     */
    function recursively(name, fn, args) {
        const callArgs = ["input: any", ...args].join(", ");
        const recurArgs = ["value", ...(args.map(arg => arg.split(":")[0]))].join(", ");
        const fnName = name.split("recursively")[1].toLowerCase();

        return trim(`
            // Invoked for non-null objects to recursively ${fnName} references to IFluidHandles.
            // Clones as-needed to avoid mutating the 'input' object.  If no IFluidHandes are present,
            // returns the original 'input'.
            private ${name}(${callArgs}) {
                // Note: Caller is responsible for ensuring that 'input' is a non-null object.

${indent(fn, 4)}

                // Otherwise descend into the object graph looking for IFluidHandle instances.
                // eslint-disable-next-line @typescript-eslint/ban-types
                let clone: object | undefined;
                for (const key of Object.keys(input)) {
                    const value = input[key];
                    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                    if (!!value && typeof value === "object") {
                        // Note: Except for IFluidHandle, 'input' must not contain circular references (as object must
                        //       be JSON serializable.)  Therefore, guarding against infinite recursion here would only
                        //       lead to a later error when attempting to stringify().
                        const replaced = this.${name}(${recurArgs});

                        // If the 'replaced' object is different than the original 'value' then the subgraph contained one
                        // or more handles.  If this happens, we need to return a clone of the 'input' object where the
                        // current property is replaced by the 'replaced' value.
                        if (replaced !== value) {
                            // Lazily create a shallow clone of the 'input' object if we haven't done so already.
                            clone = clone ?? (Array.isArray(input)
                                ? [...input]
                                : { ...input });

                            // Overwrite the current property 'key' in the clone with the 'replaced' value.
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            clone![key] = replaced;
                        }
                    }
                }
                return clone ?? input;
            }
        `);
    }
_%>

/* THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. */

/* eslint-disable @typescript-eslint/no-unsafe-return */

import {
    IFluidHandle,
    IFluidHandleContext,
    IFluidSerializer,
} from "@fluidframework/core-interfaces";
import { RemoteFluidObjectHandle } from "./remoteObjectHandle";
import { generateHandleContextPath } from "./dataStoreHandleContextUtils";
import { isSerializedHandle } from "./utils";

/**
 * Data Store serializer implementation
 */
export class FluidSerializer implements IFluidSerializer {
    private readonly root: IFluidHandleContext;

    public constructor(private readonly context: IFluidHandleContext) {
        this.root = this.context;
        while (this.root.routeContext !== undefined) {
            this.root = this.root.routeContext;
        }
    }

    public get IFluidSerializer() { return this; }

    public replaceHandles(
        input: any,
        bind: IFluidHandle,
    ) {
        // If the given 'input' cannot contain handles, return it immediately.  Otherwise,
        // return the result of 'recursivelyEncode()'.
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return !!input && typeof input === "object"
            ? this.recursivelyEncode(input, bind)
            : input;
    }

    // TODO: The below proof-of-concept implementation of 'decode()' will be enabled with tests
    //       and benchmarks once the refactoring to use EJS codegen lands.
    /*
    public decode(
        input: any,
    ) {
        // If the given 'input' cannot contain handles, return it immediately.  Otherwise,
        // return the result of 'recursivelyDecode()'.
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return !!input && typeof input === "object"
            ? this.recursivelyDecode(input)
            : input;
    }
    */

    public stringify(input: any, bind: IFluidHandle) {
        return JSON.stringify(input, (key, value) => {
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (value) {
<%- indent(encodeValue("value"), 4) -%>

            }
            return value;
        });
    }

    // Parses the serialized data - context must match the context with which the JSON was stringified
    public parse(input: string) {
        return JSON.parse(
            input,
            (key, value) => {
<%- indent(decodeValue("value"), 4) -%>

                return value;
            });
    }

<%- indent(recursively("recursivelyEncode", /* fn: */ encodeValue("input"), /* args: */ ["bind: IFluidHandle"]), 1) %>

// TODO: The below proof-of-concept implementation of 'recursivelyDecode()' will be enabled
//       once the refactoring to use EJS codegen lands.
/*
<%- indent(recursively("recursivelyDecode", /* fn: */ decodeValue("input"), /* args: */ []), 1) %>
*/

    protected serializeHandle(handle: IFluidHandle, bind: IFluidHandle) {
        bind.bind(handle);
        return {
            type: "__fluid_handle__",
            url: handle.absolutePath,
        };
    }
}
