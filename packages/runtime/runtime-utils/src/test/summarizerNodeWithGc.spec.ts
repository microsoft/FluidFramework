/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { strict as assert } from "assert";
import { cloneGCData, GCDataBuilder } from "@fluidframework/garbage-collector";
import { SummaryType } from "@fluidframework/protocol-definitions";
import {
    CreateSummarizerNodeSource,
    IGarbageCollectionData,
    IGarbageCollectionDetailsBase,
    ISummarizeInternalResult,
    ISummarizerNodeWithGC,
    SummarizeInternalFn,
} from "@fluidframework/runtime-definitions";
import { MockLogger, TelemetryNullLogger } from "@fluidframework/telemetry-utils";
// eslint-disable-next-line import/no-internal-modules
import { createRootSummarizerNodeWithGC, IRootSummarizerNodeWithGC } from "../summarizerNode/summarizerNodeWithGc";
import { mergeStats } from "../summaryUtils";

describe("SummarizerNodeWithGC Tests", () => {
    const summarizerNodeId = "testNode";
    const node1Id = "/gcNode1";
    const node2Id = "/gcNode2";
    const subNode1Id = "/gcNode1/subNode";
    const subNode2Id = "/gcNode2/subNode";

    let rootSummarizerNode: IRootSummarizerNodeWithGC;
    let summarizerNode: ISummarizerNodeWithGC;
    // The base GC details of the root summarizer node. The child base GC details from this is passed on to the child
    // summarizer node during its creation.
    let rootBaseGCDetails: IGarbageCollectionDetailsBase;
    // The GC data returned by the getGCData() API of the child summarizer node.
    let childInternalGCData: IGarbageCollectionData;
    let mockLogger: MockLogger;

    const getRootBaseGCDetails = async (): Promise<IGarbageCollectionDetailsBase> => rootBaseGCDetails;
    const getChildInternalGCData = async (): Promise<IGarbageCollectionData> => childInternalGCData;

    beforeEach(async () => {
        mockLogger = new MockLogger();
        rootSummarizerNode = createRootSummarizerNodeWithGC(
            mockLogger,
            (() => undefined) as unknown as SummarizeInternalFn,
            0,
            0,
            undefined,
            undefined,
            getRootBaseGCDetails,
        );
        rootSummarizerNode.startSummary(0, new TelemetryNullLogger());

        summarizerNode = rootSummarizerNode.createChild(
            summarizeInternal,
            summarizerNodeId,
            { type: CreateSummarizerNodeSource.FromSummary },
            undefined,
            getChildInternalGCData,
        );

        // Initialize the values to be returned by the child node's getGCData.
        childInternalGCData = {
            gcNodes: {
                "/": [node1Id, node2Id],
                [node1Id]: [subNode1Id],
            },
        };

        // Initialize the values to be returned by the getBaseGCDetails() API of the root summarizer node.
        rootBaseGCDetails = {
            usedRoutes: [],
        };
    });

    async function summarizeInternal(fullTree: boolean, trackState: boolean): Promise<ISummarizeInternalResult> {
        const stats = mergeStats();
        stats.treeNodeCount++;
        return {
            summary: {
                type: SummaryType.Tree,
                tree: {},
            },
            stats,
            id: summarizerNodeId,
        };
    }

    /**
     * Given the GC data of a child, build the GC data of the root (parent) node.
     */
    function buildRootGCData(childGCData: IGarbageCollectionData, childId: string) {
        const builder = new GCDataBuilder();
        builder.prefixAndAddNodes(childId, childGCData.gcNodes);
        return builder.getGCData();
    }

    describe("getGCData API", () => {
        it("fails when function to get GC data is not provided", async () => {
            // Root summarizer node does not have the function to get GC data. Trying to get GC data from it should
            // fail.
            let failed = false;
            try {
                await rootSummarizerNode.getGCData();
            } catch {
                failed = true;
            }
            assert(failed, "Getting GC data should have failed");
        });

        it("can return GC data when data has changed since last summary", async () => {
            // Invalidate the summarizer node to force it to generate GC data and not use cached value.
            summarizerNode.invalidate(10);

            const gcData = await summarizerNode.getGCData();
            assert.deepStrictEqual(gcData, childInternalGCData, "GC data should be generated by calling getChildInternalGCData");
        });

        it("can return base GC data when nothing has changed since last summary", async () => {
            // The base GC data of the child summarizer node.
            const childBaseGCData: IGarbageCollectionData = {
                gcNodes: {
                    "/": [node1Id],
                    [node1Id]: ["/"],
                    [node2Id]: [subNode1Id, subNode2Id],
                },
            };
            // Set the root base GC details to include the child node's base GC data.
            rootBaseGCDetails = {
                usedRoutes: [""],
                gcData: buildRootGCData(childBaseGCData, summarizerNodeId),
            };

            // We did not invalidate the summarizer node, so it will get the base GC data because nothing changed
            // since last summary.
            const gcData = await summarizerNode.getGCData();
            assert.deepStrictEqual(gcData, childBaseGCData, "Base GC data should have been returned");
        });

        it("can return GC data when base GC data is not available", async () => {
            // The base GC data of the child summarizer node is undefined by default. So, the node will generate GC
            // data even though nothing changed since last summary.
            const gcData = await summarizerNode.getGCData();
            assert.deepStrictEqual(gcData, childInternalGCData, "GC data should be generated by calling getChildInternalGCData");
        });

        it("can return cached GC data", async () => {
            // The base GC data of the child summarizer node is undefined by default. So, the node will generate GC
            // data even though nothing changed since last summary.
            let gcData = await summarizerNode.getGCData();
            assert.deepStrictEqual(gcData, childInternalGCData, "GC data should be generated by calling getChildInternalGCData");

            // Make a clone of the GC data returned above because we are about to change it.
            const cachedGCData = cloneGCData(gcData);

            // Add a new node to the GC data returned by getChildInternalGCData to make it different from cachedGCData above.
            // This will validate that the data returned by getGCData is not childInternalGCData.
            childInternalGCData.gcNodes[subNode1Id] = ["/", subNode2Id];

            // Since nothing changed since last summary, summarizer node should return the data from the previous run.
            gcData = await summarizerNode.getGCData();
            assert.deepStrictEqual(gcData, cachedGCData, "GC data from previous run should be returned");
        });

        it("can generate GC data when nothing changed but fullGC flag is true", async () => {
            let gcData = await summarizerNode.getGCData();
            assert.deepStrictEqual(gcData, childInternalGCData, "GC data should be generated by calling getChildInternalGCData");

            // Add a new node to the GC data returned by getChildInternalGCData to make it different from before.
            // This will validate that the data returned by getGCData is the new childInternalGCData.
            childInternalGCData.gcNodes[subNode1Id] = ["/", subNode2Id];

            // Call getGCData() with fullGC = true. Even though nothing changed since last summary, this will force the
            // summarizer node to generate GC data by calling getChildInternalGCData.
            gcData = await summarizerNode.getGCData(true /* fullGC */);
            assert.deepStrictEqual(gcData, childInternalGCData, "GC data should be generated by calling getChildInternalGCData");
        });
    });

    describe("summarize API", () => {
        it("should not allow summarizing without running GC first", async () => {
            // Since GC is enabled, calling summarize without running GC (updating used routes) should result in
            // an assert being thrown.
            await assert.rejects(
                summarizerNode.summarize(true /* fullTree */),
                "summarize should have thrown since GC was run");
        });

        it("should allow summarizing after running GC", async () => {
            // Update the used routes which emulates running GC.
            summarizerNode.updateUsedRoutes([""]);
            // Summarize should not throw since GC was run before.
            await assert.doesNotReject(
                summarizerNode.summarize(true /* fullTree */),
                "summarize should not have thrown an error since GC was run",
            );
        });
    });
});
