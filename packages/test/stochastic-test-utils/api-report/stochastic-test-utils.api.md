## API Report File for "@fluid-private/stochastic-test-utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="mocha" />

import { Random } from 'best-random';

// @internal (undocumented)
export type AcceptanceCondition<TState> = (state: TState) => boolean;

// @internal
type AsyncGenerator_2<TOut, TState> = (state: TState) => Promise<TOut | typeof done>;
export { AsyncGenerator_2 as AsyncGenerator }

// @internal (undocumented)
export function asyncGeneratorFromArray<T, TAdditionalState>(contents: T[]): AsyncGenerator_2<T, TAdditionalState>;

// @internal
export type AsyncReducer<TOp, TState> = (state: TState, operation: TOp) => Promise<TState | void>;

// @internal
export type AsyncWeights<TOp, TState> = [
TOp | AsyncGenerator_2<TOp, TState>,
number,
AcceptanceCondition<TState>?
][];

// @internal (undocumented)
export interface BaseFuzzTestState {
    // (undocumented)
    random: IRandom;
}

// @internal
export function chain<T, TState>(...generators: Generator_2<T, TState>[]): Generator_2<T, TState>;

// @internal
export function chainAsync<T, TState>(...generators: AsyncGenerator_2<T, TState>[]): AsyncGenerator_2<T, TState>;

// @internal
export function chainAsyncIterables<T, TState>(generators: AsyncGenerator_2<AsyncGenerator_2<T, TState>, void>): AsyncGenerator_2<T, TState>;

// @internal
export function chainIterables<T, TState>(generators: Generator_2<Generator_2<T, TState>, void>): Generator_2<T, TState>;

// @internal (undocumented)
export function combineReducers<TOperation extends {
    type: string | number;
}, TState extends BaseFuzzTestState>(reducerMap: {
    [K in TOperation["type"]]: Reducer<Extract<TOperation, {
        type: K;
    }>, TState>;
}): Reducer<TOperation, TState>;

// @internal (undocumented)
export function combineReducersAsync<TOperation extends {
    type: string | number;
}, TState extends BaseFuzzTestState>(reducerMap: {
    [K in TOperation["type"]]: AsyncReducer<Extract<TOperation, {
        type: K;
    }>, TState>;
}): AsyncReducer<TOperation, TState>;

// @internal (undocumented)
export function createFuzzDescribe(optionsArg?: FuzzDescribeOptions): DescribeFuzz;

// @internal (undocumented)
export type CreateMochaSuite<TArgs> = (name: string, createTests: (this: Mocha.Suite, args: TArgs) => void) => Mocha.Suite | void;

// @internal
export function createWeightedAsyncGenerator<T, TState extends BaseFuzzTestState>(weights: AsyncWeights<T, TState>): AsyncGenerator_2<T, TState>;

// @internal
export function createWeightedGenerator<T, TState extends BaseFuzzTestState>(weights: Weights<T, TState>): Generator_2<T, TState>;

// @internal (undocumented)
export const defaultOptions: Required<FuzzDescribeOptions>;

// @internal (undocumented)
export type DescribeFuzz = MochaSuiteWithArguments<FuzzSuiteArguments>;

// @internal
export const describeFuzz: DescribeFuzz;

// @internal (undocumented)
export type DescribeStress = MochaSuiteWithArguments<StressSuiteArguments>;

// @internal
export const describeStress: DescribeStress;

// @internal (undocumented)
export const done: unique symbol;

// @internal
export enum ExitBehavior {
    // (undocumented)
    OnBothExhausted = 0,
    // (undocumented)
    OnEitherExhausted = 1
}

// @internal (undocumented)
export interface FuzzDescribeOptions {
    // (undocumented)
    defaultTestCount?: number;
}

// @internal (undocumented)
export interface FuzzSuiteArguments extends StressSuiteArguments {
    testCount: number;
}

// @internal
type Generator_2<TOut, TState> = (state: TState) => TOut | typeof done;
export { Generator_2 as Generator }

// @internal (undocumented)
export function generatorFromArray<T, TAdditionalState>(contents: T[]): Generator_2<T, TAdditionalState>;

// @internal
export function interleave<T, TState>(generator1: Generator_2<T, TState>, generator2: Generator_2<T, TState>, numOps1?: number, numOps2?: number, exitBehavior?: ExitBehavior): Generator_2<T, TState>;

// @internal
export function interleaveAsync<T, TState>(generator1: AsyncGenerator_2<T, TState>, generator2: AsyncGenerator_2<T, TState>, numOps1?: number, numOps2?: number, exitBehavior?: ExitBehavior): AsyncGenerator_2<T, TState>;

// @internal (undocumented)
export interface IRandom {
    bool(probability?: number): boolean;
    integer(min: number, max: number): number;
    normal(mean?: number, standardDeviation?: number): number;
    pick<T>(items: T[]): T;
    real(min?: number, max?: number): number;
    shuffle<T>(items: T[]): any;
    string(length: number, alphabet?: string): string;
    uuid4(): string;
}

// @internal
export function makeRandom(...seed: [] | [number] | [number, number] | [number, number, number] | [number, number, number, number]): IRandom;

// @internal (undocumented)
export abstract class MarkovChain<PredictionPointType, OutputType> {
    // (undocumented)
    protected static assumeWordLanguageWordSpacing(word: string): WordSpacing;
    // (undocumented)
    abstract generateData(...args: any): OutputType;
    // (undocumented)
    protected static getCharacaterWordSpacing(character: string): WordSpacing;
    // (undocumented)
    abstract initialize(predicitionPoints: PredictionPointType[][]): void;
    // (undocumented)
    static readonly MARKOV_SENTENCE_BEGIN_KEY = "MARKOV_SENTENCE_BEGIN_KEY_01$#@%^#";
    // (undocumented)
    static readonly MARKOV_SENTENCE_END_KEY = "MARKOV_SENTENCE_END_KEY_01$#@%^#";
}

// @internal
export type MochaSuiteWithArguments<TArgs> = CreateMochaSuite<TArgs> & Record<"skip" | "only", CreateMochaSuite<TArgs>>;

// @internal (undocumented)
export class PerformanceWordMarkovChain extends MarkovChain<string, string> {
    constructor(random?: IRandom, chain?: Record<string, string[]>);
    // (undocumented)
    readonly chain: Record<string, string[]>;
    generateData(maxLength: number): string;
    initialize(sentences: string[][]): Record<string, string[]>;
    // (undocumented)
    readonly random: IRandom;
}

// @internal
export function performFuzzActions<TOperation extends {
    type: string | number;
}, TState extends BaseFuzzTestState>(generator: Generator_2<TOperation, TState>, reducer: Reducer<TOperation, TState>, initialState: TState, saveInfo?: SaveInfo): TState;

// @internal
export function performFuzzActions<TOperation extends {
    type: string | number;
}, TState extends BaseFuzzTestState>(generator: Generator_2<TOperation, TState>, reducerMap: {
    [K in TOperation["type"]]: Reducer<Extract<TOperation, {
        type: K;
    }>, TState>;
}, initialState: TState, saveInfo?: SaveInfo): TState;

// @internal
export function performFuzzActionsAsync<TOperation extends {
    type: string | number;
}, TState extends BaseFuzzTestState>(generator: AsyncGenerator_2<TOperation, TState>, reducer: AsyncReducer<TOperation, TState>, initialState: TState, saveInfo?: SaveInfo): Promise<TState>;

// @internal
export function performFuzzActionsAsync<TOperation extends {
    type: string | number;
}, TState extends BaseFuzzTestState>(generator: AsyncGenerator_2<TOperation, TState>, reducerMap: {
    [K in TOperation["type"]]: AsyncReducer<Extract<TOperation, {
        type: K;
    }>, TState>;
}, initialState: TState, saveInfo?: SaveInfo): Promise<TState>;

// @internal
export type Reducer<TOp, TState> = (state: TState, operation: TOp) => TState | void;

// @internal
export function repeat<T, TState = void>(t: T): Generator_2<T, TState>;

// @internal
export function repeatAsync<T, TState = void>(t: T): AsyncGenerator_2<T, TState>;

// @internal (undocumented)
export interface SaveInfo {
    filepath: string;
    // (undocumented)
    saveOnFailure: boolean;
    // (undocumented)
    saveOnSuccess?: boolean;
}

// @internal
export function saveOpsToFile(filepath: string, operations: {
    type: string | number;
}[]): Promise<void>;

// @internal (undocumented)
export class SpaceEfficientWordMarkovChain extends MarkovChain<string, string> {
    constructor(random?: IRandom, chain?: Record<string, [string, number][]>);
    // (undocumented)
    chain: Record<string, [string, number][]>;
    generateData(maxLength: number): string;
    initialize(sentences: string[][]): void;
    // (undocumented)
    readonly random: IRandom;
}

// @internal (undocumented)
export interface StressSuiteArguments {
    isStress: boolean;
}

// @internal
export function take<T, TState>(n: number, generator: Generator_2<T, TState>): Generator_2<T, TState>;

// @internal
export function takeAsync<T, TState>(n: number, generator: AsyncGenerator_2<T, TState>): AsyncGenerator_2<T, TState>;

// @internal
export type Weights<TOp, TState> = [
TOp | Generator_2<TOp, TState>,
number,
AcceptanceCondition<TState>?
][];

// @internal (undocumented)
export enum WordSpacing {
    // (undocumented)
    Spaced = 0,
    // (undocumented)
    Unknown = 2,
    // (undocumented)
    Unspaced = 1
}

// @internal
export const XSadd: XSaddCtor;

// @internal
export type XSaddCtor = new (seed0?: number, seed1?: number, seed2?: number, seed3?: number) => Random;

// (No @packageDocumentation comment for this package)

```
