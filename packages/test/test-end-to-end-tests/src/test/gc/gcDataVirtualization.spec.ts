/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { strict as assert } from "assert";
import {
	createTestConfigProvider,
	createSummarizer,
	ITestContainerConfig,
	ITestObjectProvider,
	summarizeNow,
	waitForContainerConnection,
} from "@fluidframework/test-utils";
import {
	describeCompat,
	ITestDataObject,
	TestDataObjectType,
} from "@fluid-private/test-version-utils";
import { IGCRuntimeOptions } from "@fluidframework/container-runtime";
import { ISummaryTree } from "@fluidframework/protocol-definitions";
import { IContainer, LoaderHeader } from "@fluidframework/container-definitions";
import { getGCStateFromSummary } from "./gcTestSummaryUtils.js";

/**
 * Validates that an unreferenced datastore goes through all the GC phases without overlapping.
 */
describeCompat("GC unreference phases", "NoCompat", (getTestObjectProvider) => {
	// Since these tests depend on these timing windows, they should not be run against drivers talking over the network
	// (see this.skip() call below)
	const tombstoneTimeoutMs = 200; // Tombstone at 200ms
	const sweepGracePeriodMs = 200; // Sweep at 400ms

	const configProvider = createTestConfigProvider();
	const gcOptions: IGCRuntimeOptions = {
		inactiveTimeoutMs: tombstoneTimeoutMs / 2, // Required to avoid an error
		enableGCSweep: true,
		sweepGracePeriodMs,
	};
	const testContainerConfig: ITestContainerConfig = {
		runtimeOptions: {
			summaryOptions: {
				summaryConfigOverrides: {
					state: "disabled",
				},
			},
			gcOptions,
		},
		loaderProps: { configProvider },
	};

	let provider: ITestObjectProvider;

	const loadSummarizer = async (container: IContainer, summaryVersion?: string) => {
		return createSummarizer(
			provider,
			container,
			{
				runtimeOptions: { gcOptions },
				loaderProps: { configProvider },
			},
			summaryVersion,
		);
	};

	async function isDataStoreInSummaryTree(summaryTree: ISummaryTree, dataStoreId: string) {
		const channelsTree =
			(summaryTree.tree[".channels"] as ISummaryTree)?.tree ?? summaryTree.tree;
		return dataStoreId in channelsTree;
	}

	beforeEach("setup", async function () {
		provider = getTestObjectProvider({ syncSummarizer: true });

		// These tests validate the GC state in summary generated by the container runtime. They do not care
		// about the snapshot that is downloaded from the server. So, it doesn't need to run against real services.
		// Additionally, they depend on tight timing windows. So, they should not be run against drivers talking over the network.
		if (provider.driver.type !== "local") {
			this.skip();
		}

		configProvider.set("Fluid.GarbageCollection.ThrowOnTombstoneUsage", true);
		configProvider.set(
			"Fluid.GarbageCollection.TestOverride.TombstoneTimeoutMs",
			tombstoneTimeoutMs,
		);
		configProvider.set("Fluid.Container.UseLoadingGroupIdForSnapshotFetch", true);
	});

	afterEach(() => {
		configProvider.clear();
	});

	it("Unreferenced objects follow the sequence [unreferenced, tombstoned, deleted]", async () => {
		const mainContainer = await provider.makeTestContainer(testContainerConfig);
		const mainDataStore = (await mainContainer.getEntryPoint()) as ITestDataObject;
		await waitForContainerConnection(mainContainer);

		const { container, summarizer } = await loadSummarizer(mainContainer);

		// create datastore
		const dataStore = await mainDataStore._context.containerRuntime.createDataStore(
			TestDataObjectType,
			"group",
		);
		const dataStoreHandle = dataStore.entryPoint;
		assert(dataStoreHandle !== undefined, "Expected a handle when creating a datastore");
		const dataObject = (await dataStoreHandle.get()) as ITestDataObject;
		const dataStoreId = dataObject._context.id;

		// store datastore handles
		mainDataStore._root.set("dataStore", dataStoreHandle);

		// unreference datastore handles
		mainDataStore._root.delete("dataStore");

		// Stage 1 - Referenced -> unreferenced //

		// Summarize and verify datastore are unreferenced and not tombstoned
		await provider.ensureSynchronized();
		const { summaryTree, summaryVersion } = await summarizeNow(summarizer);
		const gcState = getGCStateFromSummary(summaryTree);
		assert(gcState !== undefined, "Expected GC state to be generated");
		assert(
			gcState.gcNodes[dataStoreHandle.absolutePath] !== undefined,
			"Data Store should exist on gc graph",
		);
		const unreferencedTimestampMs =
			gcState.gcNodes[dataStoreHandle.absolutePath].unreferencedTimestampMs;
		assert(unreferencedTimestampMs !== undefined, "Data Store should be unreferenced");
		// Summary check
		assert(
			await isDataStoreInSummaryTree(summaryTree, dataStoreId),
			"Data Store should be in the summary!",
		);

		const container2 = await provider.loadTestContainer(testContainerConfig, {
			[LoaderHeader.version]: summaryVersion,
		});
		const mainDataStore2 = (await container2.getEntryPoint()) as ITestDataObject;
		const { summarizer: summarizer2 } = await loadSummarizer(container2, summaryVersion);
		summarizer.close();
		container.close();
		mainContainer.close();
		mainDataStore2._root.set("some", "op");
		await provider.ensureSynchronized();
		const { summaryTree: summaryTree2 } = await summarizeNow(summarizer2);

		const gcState2 = getGCStateFromSummary(summaryTree2);
		assert(gcState2 !== undefined, "Expected GC state to be generated");
		assert(
			gcState2.gcNodes[dataStoreHandle.absolutePath] !== undefined,
			"Data Store should exist on gc graph",
		);
		assert(
			gcState2.gcNodes[dataStoreHandle.absolutePath].unreferencedTimestampMs !==
				unreferencedTimestampMs,
			"Data Store should be unreferenced the same",
		);
		// Summary check
		assert(
			await isDataStoreInSummaryTree(summaryTree2, dataStoreId),
			"Data Store should be in the summary!",
		);
	});
});
