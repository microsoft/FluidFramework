/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { strict as assert } from "assert";
import {
	createSummarizer,
	ITestContainerConfig,
	ITestObjectProvider,
	mockConfigProvider,
	summarizeNow,
	waitForContainerConnection,
} from "@fluidframework/test-utils";
import {
	describeNoCompat,
	ITestDataObject,
	TestDataObjectType,
} from "@fluid-private/test-version-utils";
import { IGCRuntimeOptions } from "@fluidframework/container-runtime";
import { delay } from "@fluidframework/core-utils";
import { gcTreeKey } from "@fluidframework/runtime-definitions";
import { ISummaryTree, SummaryType } from "@fluidframework/protocol-definitions";
import { IContainer, LoaderHeader } from "@fluidframework/container-definitions";
import {
	getGCStateFromSummary,
	getGCDeletedStateFromSummary,
	getGCTombstoneStateFromSummary,
} from "./gcTestSummaryUtils.js";

/**
 * Validates that an unreferenced datastore goes through all the GC phases without overlapping.
 */
//* ONLY
//* ONLY
//* ONLY
//* ONLY
//* ONLY
//* ONLY
//* ONLY
//* ONLY
//* ONLY
//* ONLY
describeNoCompat.only("GC unreference phases", (getTestObjectProvider) => {
	//* TODO: Add asserts before each delay that the time hasn't already elapsed

	const inactiveTimeoutMs = 100;
	const sweepTimeoutMs = 200;
	const tombstoneSweepDelayMs = 100; // So sweep at 300

	const settings = {};
	const gcOptions: IGCRuntimeOptions = { inactiveTimeoutMs };
	const testContainerConfig: ITestContainerConfig = {
		runtimeOptions: {
			summaryOptions: {
				summaryConfigOverrides: {
					state: "disabled",
				},
			},
			gcOptions,
		},
		loaderProps: { configProvider: mockConfigProvider(settings) },
	};

	let provider: ITestObjectProvider;

	const loadSummarizer = async (container: IContainer, summaryVersion?: string) => {
		return createSummarizer(
			provider,
			container,
			{
				runtimeOptions: { gcOptions },
				loaderProps: { configProvider: mockConfigProvider(settings) },
			},
			summaryVersion,
		);
	};

	async function isDataStoreInSummaryTree(summaryTree: ISummaryTree, dataStoreId: string) {
		const channelsTree =
			(summaryTree.tree[".channels"] as ISummaryTree)?.tree ?? summaryTree.tree;
		return dataStoreId in channelsTree;
	}

	beforeEach(async function () {
		provider = getTestObjectProvider({ syncSummarizer: true });
		// These tests validate the GC state in summary generated by the container runtime. They do not care
		// about the snapshot that is downloaded from the server. So, it doesn't need to run against real services.
		if (provider.driver.type !== "local") {
			this.skip();
		}

		settings["Fluid.GarbageCollection.DisableAttachmentBlobSweep"] = true; // Only sweep DataStores
		settings["Fluid.GarbageCollection.RunSweep"] = true;
		settings["Fluid.GarbageCollection.ThrowOnTombstoneUsage"] = true;
		settings["Fluid.GarbageCollection.TestOverride.SweepTimeoutMs"] = sweepTimeoutMs;
	});

	it("GC nodes follow the sequence [referenced, unreferenced, inactive, tombstoned, deleted]", async () => {
		const mainContainer = await provider.makeTestContainer(testContainerConfig);
		const mainDataStore = (await mainContainer.getEntryPoint()) as ITestDataObject;
		await waitForContainerConnection(mainContainer);

		const { container, summarizer } = await loadSummarizer(mainContainer);

		// create datastore
		const dataStore =
			await mainDataStore._context.containerRuntime.createDataStore(TestDataObjectType);
		const dataStoreHandle = dataStore.entryPoint;
		assert(dataStoreHandle !== undefined, "Expected a handle when creating a datastore");
		const dataObject = (await dataStoreHandle.get()) as ITestDataObject;
		const dataStoreId = dataObject._context.id;
		const ddsHandle = dataObject._root.handle;

		// store datastore handles
		mainDataStore._root.set("dataStore", dataStoreHandle);

		// unreference datastore handles
		mainDataStore._root.delete("dataStore");

		// Summarize and verify datastore are unreferenced and not tombstoned
		await provider.ensureSynchronized();
		let summaryTree = (await summarizeNow(summarizer)).summaryTree;
		const gcState = getGCStateFromSummary(summaryTree);
		assert(gcState !== undefined, "Expected GC state to be generated");
		assert(
			gcState.gcNodes[dataStoreHandle.absolutePath] !== undefined,
			"Data Store should exist on gc graph",
		);
		assert(
			gcState.gcNodes[dataStoreHandle.absolutePath].unreferencedTimestampMs !== undefined,
			"Data Store should be unreferenced",
		);
		let tombstoneState = getGCTombstoneStateFromSummary(summaryTree);
		assert(tombstoneState === undefined, "Nothing should be tombstoned");
		let deletedState = getGCDeletedStateFromSummary(summaryTree);
		assert(deletedState === undefined, "Nothing should be swept");
		// Summary check
		assert(
			await isDataStoreInSummaryTree(summaryTree, dataStoreId),
			"Data Store should be in the summary!",
		);

		//* TODO: Maybe use mockLogger to check for inactive logs?  Probably not
		// Wait inactive timeout
		await delay(inactiveTimeoutMs);
		// Summarize and verify datastore is unreferenced and not tombstoned
		// Functionally being inactive should have no effect on datastores
		mainDataStore._root.set("send", "op");
		await provider.ensureSynchronized();
		summaryTree = (await summarizeNow(summarizer)).summaryTree;
		// GC state is a handle meaning it is the same as before, meaning nothing is tombstoned.
		assert.equal(
			summaryTree.tree[gcTreeKey].type,
			SummaryType.Handle,
			"GC tree should not have changed (indicated by incremental summary using the SummaryType.Handle)",
		);

		// Wait the remainder of sweepTimeoutMs, trigger Tombstone
		await delay(sweepTimeoutMs - inactiveTimeoutMs + 50);
		mainDataStore._root.set("send", "op2");
		await provider.ensureSynchronized();
		summaryTree = (await summarizeNow(summarizer)).summaryTree;

		const rootGCTree = summaryTree.tree[gcTreeKey];
		assert.equal(rootGCTree?.type, SummaryType.Tree, `GC data should be a tree`);
		tombstoneState = getGCTombstoneStateFromSummary(summaryTree);
		// After sweepTimeoutMs the object should be tombstoned.
		assert(tombstoneState !== undefined, "Should have tombstone state");
		assert(
			tombstoneState.includes(dataStoreHandle.absolutePath),
			"Datastore should be tombstoned",
		);

		// Wait tombstoneSweepDelayMs to trigger Sweep
		await delay(tombstoneSweepDelayMs);
		mainDataStore._root.set("send", "op2");
		await provider.ensureSynchronized();
		const summaryWithObjectDeleted = await summarizeNow(summarizer);
		summaryTree = summaryWithObjectDeleted.summaryTree;
		// GC graph check
		const gcState3 = getGCStateFromSummary(summaryTree);
		assert(gcState3 !== undefined, "Expected GC state to be generated");
		assert(
			!(dataStoreHandle.absolutePath in gcState3.gcNodes),
			"Data Store should not exist on gc graph",
		);
		// GC Tombstone check
		tombstoneState = getGCTombstoneStateFromSummary(summaryTree);
		assert(tombstoneState === undefined, "Nothing should be tombstoned");
		// GC Sweep check
		deletedState = getGCDeletedStateFromSummary(summaryTree);
		assert(deletedState !== undefined, "Should have sweep state");
		assert(deletedState.includes(dataStoreHandle.absolutePath), "Data Store should be swept");
		assert(deletedState.includes(ddsHandle.absolutePath), "DDS should be swept");
		assert(deletedState.length === 2, "Nothing else should have been swept");
		// Summary check
		assert(
			!(await isDataStoreInSummaryTree(summaryTree, dataStoreId)),
			"Data Store should not be in the summary!",
		);

		//* QUESTION: What about the return value IContainer of this load...?
		await provider.loadTestContainer(testContainerConfig, {
			[LoaderHeader.version]: summaryWithObjectDeleted.summaryVersion,
		});
		container.close(); // The Summarizer Container

		const { summarizer: remoteSummarizer } = await loadSummarizer(
			mainContainer,
			summaryWithObjectDeleted.summaryVersion,
		);
		summaryTree = (await summarizeNow(remoteSummarizer)).summaryTree;
		assert(
			!(await isDataStoreInSummaryTree(summaryTree, dataStoreId)),
			"Data Store should not be in the summary!",
		);
	});
});
