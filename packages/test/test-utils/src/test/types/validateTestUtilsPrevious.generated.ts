/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/test-utils-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ChannelFactoryRegistry": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_ChannelFactoryRegistry = requireAssignableTo<TypeOnly<old.ChannelFactoryRegistry>, TypeOnly<current.ChannelFactoryRegistry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ChannelFactoryRegistry": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_ChannelFactoryRegistry = requireAssignableTo<TypeOnly<current.ChannelFactoryRegistry>, TypeOnly<old.ChannelFactoryRegistry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_DataObjectFactoryType": {"forwardCompat": false}
 */
declare type old_as_current_for_EnumDeclaration_DataObjectFactoryType = requireAssignableTo<TypeOnly<old.DataObjectFactoryType>, TypeOnly<current.DataObjectFactoryType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_DataObjectFactoryType": {"backCompat": false}
 */
declare type current_as_old_for_EnumDeclaration_DataObjectFactoryType = requireAssignableTo<TypeOnly<current.DataObjectFactoryType>, TypeOnly<old.DataObjectFactoryType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_EventAndErrorTrackingLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_EventAndErrorTrackingLogger = requireAssignableTo<TypeOnly<old.EventAndErrorTrackingLogger>, TypeOnly<current.EventAndErrorTrackingLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_EventAndErrorTrackingLogger": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_EventAndErrorTrackingLogger = requireAssignableTo<TypeOnly<current.EventAndErrorTrackingLogger>, TypeOnly<old.EventAndErrorTrackingLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentIdStrategy": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IDocumentIdStrategy = requireAssignableTo<TypeOnly<old.IDocumentIdStrategy>, TypeOnly<current.IDocumentIdStrategy>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentIdStrategy": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IDocumentIdStrategy = requireAssignableTo<TypeOnly<current.IDocumentIdStrategy>, TypeOnly<old.IDocumentIdStrategy>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEventAndErrorTrackingLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IEventAndErrorTrackingLogger = requireAssignableTo<TypeOnly<old.IEventAndErrorTrackingLogger>, TypeOnly<current.IEventAndErrorTrackingLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEventAndErrorTrackingLogger": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IEventAndErrorTrackingLogger = requireAssignableTo<TypeOnly<current.IEventAndErrorTrackingLogger>, TypeOnly<old.IEventAndErrorTrackingLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOpProcessingController": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IOpProcessingController = requireAssignableTo<TypeOnly<old.IOpProcessingController>, TypeOnly<current.IOpProcessingController>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOpProcessingController": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IOpProcessingController = requireAssignableTo<TypeOnly<current.IOpProcessingController>, TypeOnly<old.IOpProcessingController>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideTestFluidObject": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IProvideTestFluidObject = requireAssignableTo<TypeOnly<old.IProvideTestFluidObject>, TypeOnly<current.IProvideTestFluidObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideTestFluidObject": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IProvideTestFluidObject = requireAssignableTo<TypeOnly<current.IProvideTestFluidObject>, TypeOnly<old.IProvideTestFluidObject>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestConfigProvider": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ITestConfigProvider = requireAssignableTo<TypeOnly<old.ITestConfigProvider>, TypeOnly<current.ITestConfigProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestConfigProvider": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ITestConfigProvider = requireAssignableTo<TypeOnly<current.ITestConfigProvider>, TypeOnly<old.ITestConfigProvider>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestContainerConfig": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ITestContainerConfig = requireAssignableTo<TypeOnly<old.ITestContainerConfig>, TypeOnly<current.ITestContainerConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestContainerConfig": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ITestContainerConfig = requireAssignableTo<TypeOnly<current.ITestContainerConfig>, TypeOnly<old.ITestContainerConfig>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestFluidObject": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ITestFluidObject = requireAssignableTo<TypeOnly<old.ITestFluidObject>, TypeOnly<current.ITestFluidObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestFluidObject": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ITestFluidObject = requireAssignableTo<TypeOnly<current.ITestFluidObject>, TypeOnly<old.ITestFluidObject>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestObjectProvider": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ITestObjectProvider = requireAssignableTo<TypeOnly<old.ITestObjectProvider>, TypeOnly<current.ITestObjectProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestObjectProvider": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ITestObjectProvider = requireAssignableTo<TypeOnly<current.ITestObjectProvider>, TypeOnly<old.ITestObjectProvider>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LoaderContainerTracker": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_LoaderContainerTracker = requireAssignableTo<TypeOnly<old.LoaderContainerTracker>, TypeOnly<current.LoaderContainerTracker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LoaderContainerTracker": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_LoaderContainerTracker = requireAssignableTo<TypeOnly<current.LoaderContainerTracker>, TypeOnly<old.LoaderContainerTracker>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LocalCodeLoader": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_LocalCodeLoader = requireAssignableTo<TypeOnly<old.LocalCodeLoader>, TypeOnly<current.LocalCodeLoader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LocalCodeLoader": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_LocalCodeLoader = requireAssignableTo<TypeOnly<current.LocalCodeLoader>, TypeOnly<old.LocalCodeLoader>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SummaryInfo": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_SummaryInfo = requireAssignableTo<TypeOnly<old.SummaryInfo>, TypeOnly<current.SummaryInfo>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SummaryInfo": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_SummaryInfo = requireAssignableTo<TypeOnly<current.SummaryInfo>, TypeOnly<old.SummaryInfo>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SupportedExportInterfaces": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_SupportedExportInterfaces = requireAssignableTo<TypeOnly<old.SupportedExportInterfaces>, TypeOnly<current.SupportedExportInterfaces>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SupportedExportInterfaces": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_SupportedExportInterfaces = requireAssignableTo<TypeOnly<current.SupportedExportInterfaces>, TypeOnly<old.SupportedExportInterfaces>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_TestContainerRuntimeFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_TestContainerRuntimeFactory = requireAssignableTo<TypeOnly<typeof old.TestContainerRuntimeFactory>, TypeOnly<typeof current.TestContainerRuntimeFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_TestContainerRuntimeFactory": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_TestContainerRuntimeFactory = requireAssignableTo<TypeOnly<typeof current.TestContainerRuntimeFactory>, TypeOnly<typeof old.TestContainerRuntimeFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestFluidObject": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_TestFluidObject = requireAssignableTo<TypeOnly<old.TestFluidObject>, TypeOnly<current.TestFluidObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestFluidObject": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_TestFluidObject = requireAssignableTo<TypeOnly<current.TestFluidObject>, TypeOnly<old.TestFluidObject>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestFluidObjectFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_TestFluidObjectFactory = requireAssignableTo<TypeOnly<old.TestFluidObjectFactory>, TypeOnly<current.TestFluidObjectFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestFluidObjectFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_TestFluidObjectFactory = requireAssignableTo<TypeOnly<current.TestFluidObjectFactory>, TypeOnly<old.TestFluidObjectFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestObjectProvider": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_TestObjectProvider = requireAssignableTo<TypeOnly<old.TestObjectProvider>, TypeOnly<current.TestObjectProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestObjectProvider": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_TestObjectProvider = requireAssignableTo<TypeOnly<current.TestObjectProvider>, TypeOnly<old.TestObjectProvider>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestObjectProviderWithVersionedLoad": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_TestObjectProviderWithVersionedLoad = requireAssignableTo<TypeOnly<old.TestObjectProviderWithVersionedLoad>, TypeOnly<current.TestObjectProviderWithVersionedLoad>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestObjectProviderWithVersionedLoad": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_TestObjectProviderWithVersionedLoad = requireAssignableTo<TypeOnly<current.TestObjectProviderWithVersionedLoad>, TypeOnly<old.TestObjectProviderWithVersionedLoad>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_TimeoutWithError": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_TimeoutWithError = requireAssignableTo<TypeOnly<old.TimeoutWithError>, TypeOnly<current.TimeoutWithError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_TimeoutWithError": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_TimeoutWithError = requireAssignableTo<TypeOnly<current.TimeoutWithError>, TypeOnly<old.TimeoutWithError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_TimeoutWithValue": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_TimeoutWithValue = requireAssignableTo<TypeOnly<old.TimeoutWithValue>, TypeOnly<current.TimeoutWithValue>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_TimeoutWithValue": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_TimeoutWithValue = requireAssignableTo<TypeOnly<current.TimeoutWithValue>, TypeOnly<old.TimeoutWithValue>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createAndAttachContainer": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createAndAttachContainer = requireAssignableTo<TypeOnly<typeof old.createAndAttachContainer>, TypeOnly<typeof current.createAndAttachContainer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createAndAttachContainer": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createAndAttachContainer = requireAssignableTo<TypeOnly<typeof current.createAndAttachContainer>, TypeOnly<typeof old.createAndAttachContainer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore = requireAssignableTo<TypeOnly<typeof old.createContainerRuntimeFactoryWithDefaultDataStore>, TypeOnly<typeof current.createContainerRuntimeFactoryWithDefaultDataStore>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore = requireAssignableTo<TypeOnly<typeof current.createContainerRuntimeFactoryWithDefaultDataStore>, TypeOnly<typeof old.createContainerRuntimeFactoryWithDefaultDataStore>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createDocumentId": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_createDocumentId = requireAssignableTo<TypeOnly<typeof old.createDocumentId>, TypeOnly<typeof current.createDocumentId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createDocumentId": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_createDocumentId = requireAssignableTo<TypeOnly<typeof current.createDocumentId>, TypeOnly<typeof old.createDocumentId>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createLoader": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createLoader = requireAssignableTo<TypeOnly<typeof old.createLoader>, TypeOnly<typeof current.createLoader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createLoader": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createLoader = requireAssignableTo<TypeOnly<typeof current.createLoader>, TypeOnly<typeof old.createLoader>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSummarizer": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createSummarizer = requireAssignableTo<TypeOnly<typeof old.createSummarizer>, TypeOnly<typeof current.createSummarizer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSummarizer": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createSummarizer = requireAssignableTo<TypeOnly<typeof current.createSummarizer>, TypeOnly<typeof old.createSummarizer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSummarizerCore": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createSummarizerCore = requireAssignableTo<TypeOnly<typeof old.createSummarizerCore>, TypeOnly<typeof current.createSummarizerCore>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSummarizerCore": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createSummarizerCore = requireAssignableTo<TypeOnly<typeof current.createSummarizerCore>, TypeOnly<typeof old.createSummarizerCore>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSummarizerFromFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createSummarizerFromFactory = requireAssignableTo<TypeOnly<typeof old.createSummarizerFromFactory>, TypeOnly<typeof current.createSummarizerFromFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSummarizerFromFactory": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createSummarizerFromFactory = requireAssignableTo<TypeOnly<typeof current.createSummarizerFromFactory>, TypeOnly<typeof old.createSummarizerFromFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createTestConfigProvider": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_createTestConfigProvider = requireAssignableTo<TypeOnly<typeof old.createTestConfigProvider>, TypeOnly<typeof current.createTestConfigProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createTestConfigProvider": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_createTestConfigProvider = requireAssignableTo<TypeOnly<typeof current.createTestConfigProvider>, TypeOnly<typeof old.createTestConfigProvider>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createTestContainerRuntimeFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_createTestContainerRuntimeFactory = requireAssignableTo<TypeOnly<typeof old.createTestContainerRuntimeFactory>, TypeOnly<typeof current.createTestContainerRuntimeFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createTestContainerRuntimeFactory": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_createTestContainerRuntimeFactory = requireAssignableTo<TypeOnly<typeof current.createTestContainerRuntimeFactory>, TypeOnly<typeof old.createTestContainerRuntimeFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_defaultTimeoutDurationMs": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_defaultTimeoutDurationMs = requireAssignableTo<TypeOnly<typeof old.defaultTimeoutDurationMs>, TypeOnly<typeof current.defaultTimeoutDurationMs>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_defaultTimeoutDurationMs": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_defaultTimeoutDurationMs = requireAssignableTo<TypeOnly<typeof current.defaultTimeoutDurationMs>, TypeOnly<typeof old.defaultTimeoutDurationMs>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_fluidEntryPoint": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_fluidEntryPoint = requireAssignableTo<TypeOnly<old.fluidEntryPoint>, TypeOnly<current.fluidEntryPoint>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_fluidEntryPoint": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_fluidEntryPoint = requireAssignableTo<TypeOnly<current.fluidEntryPoint>, TypeOnly<old.fluidEntryPoint>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getContainerEntryPointBackCompat": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_getContainerEntryPointBackCompat = requireAssignableTo<TypeOnly<typeof old.getContainerEntryPointBackCompat>, TypeOnly<typeof current.getContainerEntryPointBackCompat>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getContainerEntryPointBackCompat": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_getContainerEntryPointBackCompat = requireAssignableTo<TypeOnly<typeof current.getContainerEntryPointBackCompat>, TypeOnly<typeof old.getContainerEntryPointBackCompat>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getDataStoreEntryPointBackCompat": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_getDataStoreEntryPointBackCompat = requireAssignableTo<TypeOnly<typeof old.getDataStoreEntryPointBackCompat>, TypeOnly<typeof current.getDataStoreEntryPointBackCompat>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getDataStoreEntryPointBackCompat": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_getDataStoreEntryPointBackCompat = requireAssignableTo<TypeOnly<typeof current.getDataStoreEntryPointBackCompat>, TypeOnly<typeof old.getDataStoreEntryPointBackCompat>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getUnexpectedLogErrorException": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_getUnexpectedLogErrorException = requireAssignableTo<TypeOnly<typeof old.getUnexpectedLogErrorException>, TypeOnly<typeof current.getUnexpectedLogErrorException>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getUnexpectedLogErrorException": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_getUnexpectedLogErrorException = requireAssignableTo<TypeOnly<typeof current.getUnexpectedLogErrorException>, TypeOnly<typeof old.getUnexpectedLogErrorException>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_retryWithEventualValue": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_retryWithEventualValue = requireAssignableTo<TypeOnly<typeof old.retryWithEventualValue>, TypeOnly<typeof current.retryWithEventualValue>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_retryWithEventualValue": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_retryWithEventualValue = requireAssignableTo<TypeOnly<typeof current.retryWithEventualValue>, TypeOnly<typeof old.retryWithEventualValue>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_summarizeNow": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_summarizeNow = requireAssignableTo<TypeOnly<typeof old.summarizeNow>, TypeOnly<typeof current.summarizeNow>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_summarizeNow": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_summarizeNow = requireAssignableTo<TypeOnly<typeof current.summarizeNow>, TypeOnly<typeof old.summarizeNow>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_timeoutAwait": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_timeoutAwait = requireAssignableTo<TypeOnly<typeof old.timeoutAwait>, TypeOnly<typeof current.timeoutAwait>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_timeoutAwait": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_timeoutAwait = requireAssignableTo<TypeOnly<typeof current.timeoutAwait>, TypeOnly<typeof old.timeoutAwait>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_timeoutPromise": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_timeoutPromise = requireAssignableTo<TypeOnly<typeof old.timeoutPromise>, TypeOnly<typeof current.timeoutPromise>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_timeoutPromise": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_timeoutPromise = requireAssignableTo<TypeOnly<typeof current.timeoutPromise>, TypeOnly<typeof old.timeoutPromise>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_waitForContainerConnection": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_waitForContainerConnection = requireAssignableTo<TypeOnly<typeof old.waitForContainerConnection>, TypeOnly<typeof current.waitForContainerConnection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_waitForContainerConnection": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_waitForContainerConnection = requireAssignableTo<TypeOnly<typeof current.waitForContainerConnection>, TypeOnly<typeof old.waitForContainerConnection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapDocumentService": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_wrapDocumentService = requireAssignableTo<TypeOnly<typeof old.wrapDocumentService>, TypeOnly<typeof current.wrapDocumentService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapDocumentService": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_wrapDocumentService = requireAssignableTo<TypeOnly<typeof current.wrapDocumentService>, TypeOnly<typeof old.wrapDocumentService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapDocumentServiceFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_wrapDocumentServiceFactory = requireAssignableTo<TypeOnly<typeof old.wrapDocumentServiceFactory>, TypeOnly<typeof current.wrapDocumentServiceFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapDocumentServiceFactory": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_wrapDocumentServiceFactory = requireAssignableTo<TypeOnly<typeof current.wrapDocumentServiceFactory>, TypeOnly<typeof old.wrapDocumentServiceFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapDocumentStorageService": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_wrapDocumentStorageService = requireAssignableTo<TypeOnly<typeof old.wrapDocumentStorageService>, TypeOnly<typeof current.wrapDocumentStorageService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapDocumentStorageService": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_wrapDocumentStorageService = requireAssignableTo<TypeOnly<typeof current.wrapDocumentStorageService>, TypeOnly<typeof old.wrapDocumentStorageService>>
