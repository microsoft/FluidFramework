/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */
import type * as old from "@fluidframework/test-utils-previous";
import type * as current from "../../index";


// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ChannelFactoryRegistry": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ChannelFactoryRegistry():
    TypeOnly<old.ChannelFactoryRegistry>;
declare function use_current_TypeAliasDeclaration_ChannelFactoryRegistry(
    use: TypeOnly<current.ChannelFactoryRegistry>): void;
use_current_TypeAliasDeclaration_ChannelFactoryRegistry(
    get_old_TypeAliasDeclaration_ChannelFactoryRegistry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ChannelFactoryRegistry": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ChannelFactoryRegistry():
    TypeOnly<current.ChannelFactoryRegistry>;
declare function use_old_TypeAliasDeclaration_ChannelFactoryRegistry(
    use: TypeOnly<old.ChannelFactoryRegistry>): void;
use_old_TypeAliasDeclaration_ChannelFactoryRegistry(
    get_current_TypeAliasDeclaration_ChannelFactoryRegistry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_DataObjectFactoryType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_DataObjectFactoryType():
    TypeOnly<old.DataObjectFactoryType>;
declare function use_current_EnumDeclaration_DataObjectFactoryType(
    use: TypeOnly<current.DataObjectFactoryType>): void;
use_current_EnumDeclaration_DataObjectFactoryType(
    get_old_EnumDeclaration_DataObjectFactoryType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_DataObjectFactoryType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_DataObjectFactoryType():
    TypeOnly<current.DataObjectFactoryType>;
declare function use_old_EnumDeclaration_DataObjectFactoryType(
    use: TypeOnly<old.DataObjectFactoryType>): void;
use_old_EnumDeclaration_DataObjectFactoryType(
    get_current_EnumDeclaration_DataObjectFactoryType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EventAndErrorTrackingLogger": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_EventAndErrorTrackingLogger():
    TypeOnly<old.EventAndErrorTrackingLogger>;
declare function use_current_ClassDeclaration_EventAndErrorTrackingLogger(
    use: TypeOnly<current.EventAndErrorTrackingLogger>): void;
use_current_ClassDeclaration_EventAndErrorTrackingLogger(
    get_old_ClassDeclaration_EventAndErrorTrackingLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EventAndErrorTrackingLogger": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_EventAndErrorTrackingLogger():
    TypeOnly<current.EventAndErrorTrackingLogger>;
declare function use_old_ClassDeclaration_EventAndErrorTrackingLogger(
    use: TypeOnly<old.EventAndErrorTrackingLogger>): void;
use_old_ClassDeclaration_EventAndErrorTrackingLogger(
    get_current_ClassDeclaration_EventAndErrorTrackingLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOpProcessingController": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOpProcessingController():
    TypeOnly<old.IOpProcessingController>;
declare function use_current_InterfaceDeclaration_IOpProcessingController(
    use: TypeOnly<current.IOpProcessingController>): void;
use_current_InterfaceDeclaration_IOpProcessingController(
    get_old_InterfaceDeclaration_IOpProcessingController());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOpProcessingController": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOpProcessingController():
    TypeOnly<current.IOpProcessingController>;
declare function use_old_InterfaceDeclaration_IOpProcessingController(
    use: TypeOnly<old.IOpProcessingController>): void;
use_old_InterfaceDeclaration_IOpProcessingController(
    get_current_InterfaceDeclaration_IOpProcessingController());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideTestFluidObject": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProvideTestFluidObject():
    TypeOnly<old.IProvideTestFluidObject>;
declare function use_current_InterfaceDeclaration_IProvideTestFluidObject(
    use: TypeOnly<current.IProvideTestFluidObject>): void;
use_current_InterfaceDeclaration_IProvideTestFluidObject(
    get_old_InterfaceDeclaration_IProvideTestFluidObject());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProvideTestFluidObject": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProvideTestFluidObject():
    TypeOnly<current.IProvideTestFluidObject>;
declare function use_old_InterfaceDeclaration_IProvideTestFluidObject(
    use: TypeOnly<old.IProvideTestFluidObject>): void;
use_old_InterfaceDeclaration_IProvideTestFluidObject(
    get_current_InterfaceDeclaration_IProvideTestFluidObject());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITestContainerConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITestContainerConfig():
    TypeOnly<old.ITestContainerConfig>;
declare function use_current_InterfaceDeclaration_ITestContainerConfig(
    use: TypeOnly<current.ITestContainerConfig>): void;
use_current_InterfaceDeclaration_ITestContainerConfig(
    get_old_InterfaceDeclaration_ITestContainerConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITestContainerConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITestContainerConfig():
    TypeOnly<current.ITestContainerConfig>;
declare function use_old_InterfaceDeclaration_ITestContainerConfig(
    use: TypeOnly<old.ITestContainerConfig>): void;
use_old_InterfaceDeclaration_ITestContainerConfig(
    get_current_InterfaceDeclaration_ITestContainerConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITestFluidObject": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITestFluidObject():
    TypeOnly<old.ITestFluidObject>;
declare function use_current_InterfaceDeclaration_ITestFluidObject(
    use: TypeOnly<current.ITestFluidObject>): void;
use_current_InterfaceDeclaration_ITestFluidObject(
    get_old_InterfaceDeclaration_ITestFluidObject());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITestFluidObject": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITestFluidObject():
    TypeOnly<current.ITestFluidObject>;
declare function use_old_InterfaceDeclaration_ITestFluidObject(
    use: TypeOnly<old.ITestFluidObject>): void;
use_old_InterfaceDeclaration_ITestFluidObject(
    get_current_InterfaceDeclaration_ITestFluidObject());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITestObjectProvider": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITestObjectProvider():
    TypeOnly<old.ITestObjectProvider>;
declare function use_current_InterfaceDeclaration_ITestObjectProvider(
    use: TypeOnly<current.ITestObjectProvider>): void;
use_current_InterfaceDeclaration_ITestObjectProvider(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_ITestObjectProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITestObjectProvider": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITestObjectProvider():
    TypeOnly<current.ITestObjectProvider>;
declare function use_old_InterfaceDeclaration_ITestObjectProvider(
    use: TypeOnly<old.ITestObjectProvider>): void;
use_old_InterfaceDeclaration_ITestObjectProvider(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_ITestObjectProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LoaderContainerTracker": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_LoaderContainerTracker():
    TypeOnly<old.LoaderContainerTracker>;
declare function use_current_ClassDeclaration_LoaderContainerTracker(
    use: TypeOnly<current.LoaderContainerTracker>): void;
use_current_ClassDeclaration_LoaderContainerTracker(
    get_old_ClassDeclaration_LoaderContainerTracker());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LoaderContainerTracker": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_LoaderContainerTracker():
    TypeOnly<current.LoaderContainerTracker>;
declare function use_old_ClassDeclaration_LoaderContainerTracker(
    use: TypeOnly<old.LoaderContainerTracker>): void;
use_old_ClassDeclaration_LoaderContainerTracker(
    get_current_ClassDeclaration_LoaderContainerTracker());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LocalCodeLoader": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_LocalCodeLoader():
    TypeOnly<old.LocalCodeLoader>;
declare function use_current_ClassDeclaration_LocalCodeLoader(
    use: TypeOnly<current.LocalCodeLoader>): void;
use_current_ClassDeclaration_LocalCodeLoader(
    get_old_ClassDeclaration_LocalCodeLoader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LocalCodeLoader": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_LocalCodeLoader():
    TypeOnly<current.LocalCodeLoader>;
declare function use_old_ClassDeclaration_LocalCodeLoader(
    use: TypeOnly<old.LocalCodeLoader>): void;
use_old_ClassDeclaration_LocalCodeLoader(
    get_current_ClassDeclaration_LocalCodeLoader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SupportedExportInterfaces": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SupportedExportInterfaces():
    TypeOnly<old.SupportedExportInterfaces>;
declare function use_current_TypeAliasDeclaration_SupportedExportInterfaces(
    use: TypeOnly<current.SupportedExportInterfaces>): void;
use_current_TypeAliasDeclaration_SupportedExportInterfaces(
    get_old_TypeAliasDeclaration_SupportedExportInterfaces());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SupportedExportInterfaces": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SupportedExportInterfaces():
    TypeOnly<current.SupportedExportInterfaces>;
declare function use_old_TypeAliasDeclaration_SupportedExportInterfaces(
    use: TypeOnly<old.SupportedExportInterfaces>): void;
use_old_TypeAliasDeclaration_SupportedExportInterfaces(
    get_current_TypeAliasDeclaration_SupportedExportInterfaces());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TestContainerRuntimeFactory": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_TestContainerRuntimeFactory():
    TypeOnly<typeof old.TestContainerRuntimeFactory>;
declare function use_current_VariableDeclaration_TestContainerRuntimeFactory(
    use: TypeOnly<typeof current.TestContainerRuntimeFactory>): void;
use_current_VariableDeclaration_TestContainerRuntimeFactory(
    get_old_VariableDeclaration_TestContainerRuntimeFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TestContainerRuntimeFactory": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_TestContainerRuntimeFactory():
    TypeOnly<typeof current.TestContainerRuntimeFactory>;
declare function use_old_VariableDeclaration_TestContainerRuntimeFactory(
    use: TypeOnly<typeof old.TestContainerRuntimeFactory>): void;
use_old_VariableDeclaration_TestContainerRuntimeFactory(
    get_current_VariableDeclaration_TestContainerRuntimeFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TestFluidObject": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TestFluidObject():
    TypeOnly<old.TestFluidObject>;
declare function use_current_ClassDeclaration_TestFluidObject(
    use: TypeOnly<current.TestFluidObject>): void;
use_current_ClassDeclaration_TestFluidObject(
    get_old_ClassDeclaration_TestFluidObject());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TestFluidObject": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TestFluidObject():
    TypeOnly<current.TestFluidObject>;
declare function use_old_ClassDeclaration_TestFluidObject(
    use: TypeOnly<old.TestFluidObject>): void;
use_old_ClassDeclaration_TestFluidObject(
    // @ts-expect-error compatibility expected to be broken
    get_current_ClassDeclaration_TestFluidObject());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TestFluidObjectFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TestFluidObjectFactory():
    TypeOnly<old.TestFluidObjectFactory>;
declare function use_current_ClassDeclaration_TestFluidObjectFactory(
    use: TypeOnly<current.TestFluidObjectFactory>): void;
use_current_ClassDeclaration_TestFluidObjectFactory(
    get_old_ClassDeclaration_TestFluidObjectFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TestFluidObjectFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TestFluidObjectFactory():
    TypeOnly<current.TestFluidObjectFactory>;
declare function use_old_ClassDeclaration_TestFluidObjectFactory(
    use: TypeOnly<old.TestFluidObjectFactory>): void;
use_old_ClassDeclaration_TestFluidObjectFactory(
    get_current_ClassDeclaration_TestFluidObjectFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TestObjectProvider": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TestObjectProvider():
    TypeOnly<old.TestObjectProvider>;
declare function use_current_ClassDeclaration_TestObjectProvider(
    use: TypeOnly<current.TestObjectProvider>): void;
use_current_ClassDeclaration_TestObjectProvider(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_TestObjectProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TestObjectProvider": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TestObjectProvider():
    TypeOnly<current.TestObjectProvider>;
declare function use_old_ClassDeclaration_TestObjectProvider(
    use: TypeOnly<old.TestObjectProvider>): void;
use_old_ClassDeclaration_TestObjectProvider(
    // @ts-expect-error compatibility expected to be broken
    get_current_ClassDeclaration_TestObjectProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TimeoutWithError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_TimeoutWithError():
    TypeOnly<old.TimeoutWithError>;
declare function use_current_InterfaceDeclaration_TimeoutWithError(
    use: TypeOnly<current.TimeoutWithError>): void;
use_current_InterfaceDeclaration_TimeoutWithError(
    get_old_InterfaceDeclaration_TimeoutWithError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TimeoutWithError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_TimeoutWithError():
    TypeOnly<current.TimeoutWithError>;
declare function use_old_InterfaceDeclaration_TimeoutWithError(
    use: TypeOnly<old.TimeoutWithError>): void;
use_old_InterfaceDeclaration_TimeoutWithError(
    get_current_InterfaceDeclaration_TimeoutWithError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TimeoutWithValue": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_TimeoutWithValue():
    TypeOnly<old.TimeoutWithValue>;
declare function use_current_InterfaceDeclaration_TimeoutWithValue(
    use: TypeOnly<current.TimeoutWithValue>): void;
use_current_InterfaceDeclaration_TimeoutWithValue(
    get_old_InterfaceDeclaration_TimeoutWithValue());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TimeoutWithValue": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_TimeoutWithValue():
    TypeOnly<current.TimeoutWithValue>;
declare function use_old_InterfaceDeclaration_TimeoutWithValue(
    use: TypeOnly<old.TimeoutWithValue>): void;
use_old_InterfaceDeclaration_TimeoutWithValue(
    get_current_InterfaceDeclaration_TimeoutWithValue());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createAndAttachContainer": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createAndAttachContainer():
    TypeOnly<typeof old.createAndAttachContainer>;
declare function use_current_FunctionDeclaration_createAndAttachContainer(
    use: TypeOnly<typeof current.createAndAttachContainer>): void;
use_current_FunctionDeclaration_createAndAttachContainer(
    get_old_FunctionDeclaration_createAndAttachContainer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createAndAttachContainer": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createAndAttachContainer():
    TypeOnly<typeof current.createAndAttachContainer>;
declare function use_old_FunctionDeclaration_createAndAttachContainer(
    use: TypeOnly<typeof old.createAndAttachContainer>): void;
use_old_FunctionDeclaration_createAndAttachContainer(
    get_current_FunctionDeclaration_createAndAttachContainer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore():
    TypeOnly<typeof old.createContainerRuntimeFactoryWithDefaultDataStore>;
declare function use_current_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore(
    use: TypeOnly<typeof current.createContainerRuntimeFactoryWithDefaultDataStore>): void;
use_current_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore(
    get_old_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore():
    TypeOnly<typeof current.createContainerRuntimeFactoryWithDefaultDataStore>;
declare function use_old_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore(
    use: TypeOnly<typeof old.createContainerRuntimeFactoryWithDefaultDataStore>): void;
use_old_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore(
    get_current_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createDocumentId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_createDocumentId():
    TypeOnly<typeof old.createDocumentId>;
declare function use_current_VariableDeclaration_createDocumentId(
    use: TypeOnly<typeof current.createDocumentId>): void;
use_current_VariableDeclaration_createDocumentId(
    get_old_VariableDeclaration_createDocumentId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createDocumentId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_createDocumentId():
    TypeOnly<typeof current.createDocumentId>;
declare function use_old_VariableDeclaration_createDocumentId(
    use: TypeOnly<typeof old.createDocumentId>): void;
use_old_VariableDeclaration_createDocumentId(
    get_current_VariableDeclaration_createDocumentId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createLoader": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createLoader():
    TypeOnly<typeof old.createLoader>;
declare function use_current_FunctionDeclaration_createLoader(
    use: TypeOnly<typeof current.createLoader>): void;
use_current_FunctionDeclaration_createLoader(
    get_old_FunctionDeclaration_createLoader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createLoader": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createLoader():
    TypeOnly<typeof current.createLoader>;
declare function use_old_FunctionDeclaration_createLoader(
    use: TypeOnly<typeof old.createLoader>): void;
use_old_FunctionDeclaration_createLoader(
    get_current_FunctionDeclaration_createLoader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createSummarizer": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createSummarizer():
    TypeOnly<typeof old.createSummarizer>;
declare function use_current_FunctionDeclaration_createSummarizer(
    use: TypeOnly<typeof current.createSummarizer>): void;
use_current_FunctionDeclaration_createSummarizer(
    get_old_FunctionDeclaration_createSummarizer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createSummarizer": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createSummarizer():
    TypeOnly<typeof current.createSummarizer>;
declare function use_old_FunctionDeclaration_createSummarizer(
    use: TypeOnly<typeof old.createSummarizer>): void;
use_old_FunctionDeclaration_createSummarizer(
    get_current_FunctionDeclaration_createSummarizer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createSummarizerFromFactory": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createSummarizerFromFactory():
    TypeOnly<typeof old.createSummarizerFromFactory>;
declare function use_current_FunctionDeclaration_createSummarizerFromFactory(
    use: TypeOnly<typeof current.createSummarizerFromFactory>): void;
use_current_FunctionDeclaration_createSummarizerFromFactory(
    get_old_FunctionDeclaration_createSummarizerFromFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createSummarizerFromFactory": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createSummarizerFromFactory():
    TypeOnly<typeof current.createSummarizerFromFactory>;
declare function use_old_FunctionDeclaration_createSummarizerFromFactory(
    use: TypeOnly<typeof old.createSummarizerFromFactory>): void;
use_old_FunctionDeclaration_createSummarizerFromFactory(
    get_current_FunctionDeclaration_createSummarizerFromFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createTestContainerRuntimeFactory": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_createTestContainerRuntimeFactory():
    TypeOnly<typeof old.createTestContainerRuntimeFactory>;
declare function use_current_VariableDeclaration_createTestContainerRuntimeFactory(
    use: TypeOnly<typeof current.createTestContainerRuntimeFactory>): void;
use_current_VariableDeclaration_createTestContainerRuntimeFactory(
    get_old_VariableDeclaration_createTestContainerRuntimeFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createTestContainerRuntimeFactory": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_createTestContainerRuntimeFactory():
    TypeOnly<typeof current.createTestContainerRuntimeFactory>;
declare function use_old_VariableDeclaration_createTestContainerRuntimeFactory(
    use: TypeOnly<typeof old.createTestContainerRuntimeFactory>): void;
use_old_VariableDeclaration_createTestContainerRuntimeFactory(
    get_current_VariableDeclaration_createTestContainerRuntimeFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultTimeoutDurationMs": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_defaultTimeoutDurationMs():
    TypeOnly<typeof old.defaultTimeoutDurationMs>;
declare function use_current_VariableDeclaration_defaultTimeoutDurationMs(
    use: TypeOnly<typeof current.defaultTimeoutDurationMs>): void;
use_current_VariableDeclaration_defaultTimeoutDurationMs(
    get_old_VariableDeclaration_defaultTimeoutDurationMs());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultTimeoutDurationMs": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_defaultTimeoutDurationMs():
    TypeOnly<typeof current.defaultTimeoutDurationMs>;
declare function use_old_VariableDeclaration_defaultTimeoutDurationMs(
    use: TypeOnly<typeof old.defaultTimeoutDurationMs>): void;
use_old_VariableDeclaration_defaultTimeoutDurationMs(
    get_current_VariableDeclaration_defaultTimeoutDurationMs());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_fluidEntryPoint": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_fluidEntryPoint():
    TypeOnly<old.fluidEntryPoint>;
declare function use_current_TypeAliasDeclaration_fluidEntryPoint(
    use: TypeOnly<current.fluidEntryPoint>): void;
use_current_TypeAliasDeclaration_fluidEntryPoint(
    get_old_TypeAliasDeclaration_fluidEntryPoint());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_fluidEntryPoint": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_fluidEntryPoint():
    TypeOnly<current.fluidEntryPoint>;
declare function use_old_TypeAliasDeclaration_fluidEntryPoint(
    use: TypeOnly<old.fluidEntryPoint>): void;
use_old_TypeAliasDeclaration_fluidEntryPoint(
    get_current_TypeAliasDeclaration_fluidEntryPoint());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getUnexpectedLogErrorException": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getUnexpectedLogErrorException():
    TypeOnly<typeof old.getUnexpectedLogErrorException>;
declare function use_current_FunctionDeclaration_getUnexpectedLogErrorException(
    use: TypeOnly<typeof current.getUnexpectedLogErrorException>): void;
use_current_FunctionDeclaration_getUnexpectedLogErrorException(
    get_old_FunctionDeclaration_getUnexpectedLogErrorException());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getUnexpectedLogErrorException": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getUnexpectedLogErrorException():
    TypeOnly<typeof current.getUnexpectedLogErrorException>;
declare function use_old_FunctionDeclaration_getUnexpectedLogErrorException(
    use: TypeOnly<typeof old.getUnexpectedLogErrorException>): void;
use_old_FunctionDeclaration_getUnexpectedLogErrorException(
    get_current_FunctionDeclaration_getUnexpectedLogErrorException());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_mockConfigProvider": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_mockConfigProvider():
    TypeOnly<typeof old.mockConfigProvider>;
declare function use_current_VariableDeclaration_mockConfigProvider(
    use: TypeOnly<typeof current.mockConfigProvider>): void;
use_current_VariableDeclaration_mockConfigProvider(
    get_old_VariableDeclaration_mockConfigProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_mockConfigProvider": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_mockConfigProvider():
    TypeOnly<typeof current.mockConfigProvider>;
declare function use_old_VariableDeclaration_mockConfigProvider(
    use: TypeOnly<typeof old.mockConfigProvider>): void;
use_old_VariableDeclaration_mockConfigProvider(
    get_current_VariableDeclaration_mockConfigProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_retryWithEventualValue": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_retryWithEventualValue():
    TypeOnly<typeof old.retryWithEventualValue>;
declare function use_current_VariableDeclaration_retryWithEventualValue(
    use: TypeOnly<typeof current.retryWithEventualValue>): void;
use_current_VariableDeclaration_retryWithEventualValue(
    get_old_VariableDeclaration_retryWithEventualValue());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_retryWithEventualValue": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_retryWithEventualValue():
    TypeOnly<typeof current.retryWithEventualValue>;
declare function use_old_VariableDeclaration_retryWithEventualValue(
    use: TypeOnly<typeof old.retryWithEventualValue>): void;
use_old_VariableDeclaration_retryWithEventualValue(
    get_current_VariableDeclaration_retryWithEventualValue());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_summarizeNow": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_summarizeNow():
    TypeOnly<typeof old.summarizeNow>;
declare function use_current_FunctionDeclaration_summarizeNow(
    use: TypeOnly<typeof current.summarizeNow>): void;
use_current_FunctionDeclaration_summarizeNow(
    get_old_FunctionDeclaration_summarizeNow());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_summarizeNow": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_summarizeNow():
    TypeOnly<typeof current.summarizeNow>;
declare function use_old_FunctionDeclaration_summarizeNow(
    use: TypeOnly<typeof old.summarizeNow>): void;
use_old_FunctionDeclaration_summarizeNow(
    get_current_FunctionDeclaration_summarizeNow());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_timeoutAwait": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_timeoutAwait():
    TypeOnly<typeof old.timeoutAwait>;
declare function use_current_FunctionDeclaration_timeoutAwait(
    use: TypeOnly<typeof current.timeoutAwait>): void;
use_current_FunctionDeclaration_timeoutAwait(
    get_old_FunctionDeclaration_timeoutAwait());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_timeoutAwait": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_timeoutAwait():
    TypeOnly<typeof current.timeoutAwait>;
declare function use_old_FunctionDeclaration_timeoutAwait(
    use: TypeOnly<typeof old.timeoutAwait>): void;
use_old_FunctionDeclaration_timeoutAwait(
    get_current_FunctionDeclaration_timeoutAwait());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_timeoutPromise": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_timeoutPromise():
    TypeOnly<typeof old.timeoutPromise>;
declare function use_current_FunctionDeclaration_timeoutPromise(
    use: TypeOnly<typeof current.timeoutPromise>): void;
use_current_FunctionDeclaration_timeoutPromise(
    get_old_FunctionDeclaration_timeoutPromise());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_timeoutPromise": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_timeoutPromise():
    TypeOnly<typeof current.timeoutPromise>;
declare function use_old_FunctionDeclaration_timeoutPromise(
    use: TypeOnly<typeof old.timeoutPromise>): void;
use_old_FunctionDeclaration_timeoutPromise(
    get_current_FunctionDeclaration_timeoutPromise());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_waitForContainerConnection": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_waitForContainerConnection():
    TypeOnly<typeof old.waitForContainerConnection>;
declare function use_current_FunctionDeclaration_waitForContainerConnection(
    use: TypeOnly<typeof current.waitForContainerConnection>): void;
use_current_FunctionDeclaration_waitForContainerConnection(
    get_old_FunctionDeclaration_waitForContainerConnection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_waitForContainerConnection": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_waitForContainerConnection():
    TypeOnly<typeof current.waitForContainerConnection>;
declare function use_old_FunctionDeclaration_waitForContainerConnection(
    use: TypeOnly<typeof old.waitForContainerConnection>): void;
use_old_FunctionDeclaration_waitForContainerConnection(
    get_current_FunctionDeclaration_waitForContainerConnection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_wrapDocumentService": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_wrapDocumentService():
    TypeOnly<typeof old.wrapDocumentService>;
declare function use_current_FunctionDeclaration_wrapDocumentService(
    use: TypeOnly<typeof current.wrapDocumentService>): void;
use_current_FunctionDeclaration_wrapDocumentService(
    get_old_FunctionDeclaration_wrapDocumentService());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_wrapDocumentService": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_wrapDocumentService():
    TypeOnly<typeof current.wrapDocumentService>;
declare function use_old_FunctionDeclaration_wrapDocumentService(
    use: TypeOnly<typeof old.wrapDocumentService>): void;
use_old_FunctionDeclaration_wrapDocumentService(
    get_current_FunctionDeclaration_wrapDocumentService());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_wrapDocumentServiceFactory": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_wrapDocumentServiceFactory():
    TypeOnly<typeof old.wrapDocumentServiceFactory>;
declare function use_current_FunctionDeclaration_wrapDocumentServiceFactory(
    use: TypeOnly<typeof current.wrapDocumentServiceFactory>): void;
use_current_FunctionDeclaration_wrapDocumentServiceFactory(
    get_old_FunctionDeclaration_wrapDocumentServiceFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_wrapDocumentServiceFactory": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_wrapDocumentServiceFactory():
    TypeOnly<typeof current.wrapDocumentServiceFactory>;
declare function use_old_FunctionDeclaration_wrapDocumentServiceFactory(
    use: TypeOnly<typeof old.wrapDocumentServiceFactory>): void;
use_old_FunctionDeclaration_wrapDocumentServiceFactory(
    get_current_FunctionDeclaration_wrapDocumentServiceFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_wrapDocumentStorageService": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_wrapDocumentStorageService():
    TypeOnly<typeof old.wrapDocumentStorageService>;
declare function use_current_FunctionDeclaration_wrapDocumentStorageService(
    use: TypeOnly<typeof current.wrapDocumentStorageService>): void;
use_current_FunctionDeclaration_wrapDocumentStorageService(
    get_old_FunctionDeclaration_wrapDocumentStorageService());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_wrapDocumentStorageService": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_wrapDocumentStorageService():
    TypeOnly<typeof current.wrapDocumentStorageService>;
declare function use_old_FunctionDeclaration_wrapDocumentStorageService(
    use: TypeOnly<typeof old.wrapDocumentStorageService>): void;
use_old_FunctionDeclaration_wrapDocumentStorageService(
    get_current_FunctionDeclaration_wrapDocumentStorageService());
