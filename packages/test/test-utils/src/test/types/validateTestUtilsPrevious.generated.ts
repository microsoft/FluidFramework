/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/test-utils-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ChannelFactoryRegistry": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ChannelFactoryRegistry():
    TypeOnly<old.ChannelFactoryRegistry>;
declare function use_current_TypeAliasDeclaration_ChannelFactoryRegistry(
    use: TypeOnly<current.ChannelFactoryRegistry>): void;
use_current_TypeAliasDeclaration_ChannelFactoryRegistry(
    get_old_TypeAliasDeclaration_ChannelFactoryRegistry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ChannelFactoryRegistry": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ChannelFactoryRegistry():
    TypeOnly<current.ChannelFactoryRegistry>;
declare function use_old_TypeAliasDeclaration_ChannelFactoryRegistry(
    use: TypeOnly<old.ChannelFactoryRegistry>): void;
use_old_TypeAliasDeclaration_ChannelFactoryRegistry(
    get_current_TypeAliasDeclaration_ChannelFactoryRegistry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_DataObjectFactoryType": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_DataObjectFactoryType():
    TypeOnly<old.DataObjectFactoryType>;
declare function use_current_EnumDeclaration_DataObjectFactoryType(
    use: TypeOnly<current.DataObjectFactoryType>): void;
use_current_EnumDeclaration_DataObjectFactoryType(
    get_old_EnumDeclaration_DataObjectFactoryType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_DataObjectFactoryType": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_DataObjectFactoryType():
    TypeOnly<current.DataObjectFactoryType>;
declare function use_old_EnumDeclaration_DataObjectFactoryType(
    use: TypeOnly<old.DataObjectFactoryType>): void;
use_old_EnumDeclaration_DataObjectFactoryType(
    get_current_EnumDeclaration_DataObjectFactoryType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_EventAndErrorTrackingLogger": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_EventAndErrorTrackingLogger():
    TypeOnly<old.EventAndErrorTrackingLogger>;
declare function use_current_ClassDeclaration_EventAndErrorTrackingLogger(
    use: TypeOnly<current.EventAndErrorTrackingLogger>): void;
use_current_ClassDeclaration_EventAndErrorTrackingLogger(
    get_old_ClassDeclaration_EventAndErrorTrackingLogger());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_EventAndErrorTrackingLogger": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_EventAndErrorTrackingLogger():
    TypeOnly<current.EventAndErrorTrackingLogger>;
declare function use_old_ClassDeclaration_EventAndErrorTrackingLogger(
    use: TypeOnly<old.EventAndErrorTrackingLogger>): void;
use_old_ClassDeclaration_EventAndErrorTrackingLogger(
    get_current_ClassDeclaration_EventAndErrorTrackingLogger());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentIdStrategy": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IDocumentIdStrategy():
    TypeOnly<old.IDocumentIdStrategy>;
declare function use_current_InterfaceDeclaration_IDocumentIdStrategy(
    use: TypeOnly<current.IDocumentIdStrategy>): void;
use_current_InterfaceDeclaration_IDocumentIdStrategy(
    get_old_InterfaceDeclaration_IDocumentIdStrategy());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IDocumentIdStrategy": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IDocumentIdStrategy():
    TypeOnly<current.IDocumentIdStrategy>;
declare function use_old_InterfaceDeclaration_IDocumentIdStrategy(
    use: TypeOnly<old.IDocumentIdStrategy>): void;
use_old_InterfaceDeclaration_IDocumentIdStrategy(
    get_current_InterfaceDeclaration_IDocumentIdStrategy());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEventAndErrorTrackingLogger": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IEventAndErrorTrackingLogger():
    TypeOnly<old.IEventAndErrorTrackingLogger>;
declare function use_current_InterfaceDeclaration_IEventAndErrorTrackingLogger(
    use: TypeOnly<current.IEventAndErrorTrackingLogger>): void;
use_current_InterfaceDeclaration_IEventAndErrorTrackingLogger(
    get_old_InterfaceDeclaration_IEventAndErrorTrackingLogger());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEventAndErrorTrackingLogger": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IEventAndErrorTrackingLogger():
    TypeOnly<current.IEventAndErrorTrackingLogger>;
declare function use_old_InterfaceDeclaration_IEventAndErrorTrackingLogger(
    use: TypeOnly<old.IEventAndErrorTrackingLogger>): void;
use_old_InterfaceDeclaration_IEventAndErrorTrackingLogger(
    get_current_InterfaceDeclaration_IEventAndErrorTrackingLogger());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOpProcessingController": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IOpProcessingController():
    TypeOnly<old.IOpProcessingController>;
declare function use_current_InterfaceDeclaration_IOpProcessingController(
    use: TypeOnly<current.IOpProcessingController>): void;
use_current_InterfaceDeclaration_IOpProcessingController(
    get_old_InterfaceDeclaration_IOpProcessingController());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOpProcessingController": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IOpProcessingController():
    TypeOnly<current.IOpProcessingController>;
declare function use_old_InterfaceDeclaration_IOpProcessingController(
    use: TypeOnly<old.IOpProcessingController>): void;
use_old_InterfaceDeclaration_IOpProcessingController(
    get_current_InterfaceDeclaration_IOpProcessingController());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideTestFluidObject": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProvideTestFluidObject():
    TypeOnly<old.IProvideTestFluidObject>;
declare function use_current_InterfaceDeclaration_IProvideTestFluidObject(
    use: TypeOnly<current.IProvideTestFluidObject>): void;
use_current_InterfaceDeclaration_IProvideTestFluidObject(
    get_old_InterfaceDeclaration_IProvideTestFluidObject());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideTestFluidObject": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProvideTestFluidObject():
    TypeOnly<current.IProvideTestFluidObject>;
declare function use_old_InterfaceDeclaration_IProvideTestFluidObject(
    use: TypeOnly<old.IProvideTestFluidObject>): void;
use_old_InterfaceDeclaration_IProvideTestFluidObject(
    get_current_InterfaceDeclaration_IProvideTestFluidObject());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestConfigProvider": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITestConfigProvider():
    TypeOnly<old.ITestConfigProvider>;
declare function use_current_InterfaceDeclaration_ITestConfigProvider(
    use: TypeOnly<current.ITestConfigProvider>): void;
use_current_InterfaceDeclaration_ITestConfigProvider(
    get_old_InterfaceDeclaration_ITestConfigProvider());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestConfigProvider": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITestConfigProvider():
    TypeOnly<current.ITestConfigProvider>;
declare function use_old_InterfaceDeclaration_ITestConfigProvider(
    use: TypeOnly<old.ITestConfigProvider>): void;
use_old_InterfaceDeclaration_ITestConfigProvider(
    get_current_InterfaceDeclaration_ITestConfigProvider());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestContainerConfig": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITestContainerConfig():
    TypeOnly<old.ITestContainerConfig>;
declare function use_current_InterfaceDeclaration_ITestContainerConfig(
    use: TypeOnly<current.ITestContainerConfig>): void;
use_current_InterfaceDeclaration_ITestContainerConfig(
    get_old_InterfaceDeclaration_ITestContainerConfig());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestContainerConfig": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITestContainerConfig():
    TypeOnly<current.ITestContainerConfig>;
declare function use_old_InterfaceDeclaration_ITestContainerConfig(
    use: TypeOnly<old.ITestContainerConfig>): void;
use_old_InterfaceDeclaration_ITestContainerConfig(
    get_current_InterfaceDeclaration_ITestContainerConfig());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestFluidObject": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITestFluidObject():
    TypeOnly<old.ITestFluidObject>;
declare function use_current_InterfaceDeclaration_ITestFluidObject(
    use: TypeOnly<current.ITestFluidObject>): void;
use_current_InterfaceDeclaration_ITestFluidObject(
    get_old_InterfaceDeclaration_ITestFluidObject());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestFluidObject": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITestFluidObject():
    TypeOnly<current.ITestFluidObject>;
declare function use_old_InterfaceDeclaration_ITestFluidObject(
    use: TypeOnly<old.ITestFluidObject>): void;
use_old_InterfaceDeclaration_ITestFluidObject(
    get_current_InterfaceDeclaration_ITestFluidObject());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestObjectProvider": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITestObjectProvider():
    TypeOnly<old.ITestObjectProvider>;
declare function use_current_InterfaceDeclaration_ITestObjectProvider(
    use: TypeOnly<current.ITestObjectProvider>): void;
use_current_InterfaceDeclaration_ITestObjectProvider(
    get_old_InterfaceDeclaration_ITestObjectProvider());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITestObjectProvider": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITestObjectProvider():
    TypeOnly<current.ITestObjectProvider>;
declare function use_old_InterfaceDeclaration_ITestObjectProvider(
    use: TypeOnly<old.ITestObjectProvider>): void;
use_old_InterfaceDeclaration_ITestObjectProvider(
    get_current_InterfaceDeclaration_ITestObjectProvider());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LoaderContainerTracker": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_LoaderContainerTracker():
    TypeOnly<old.LoaderContainerTracker>;
declare function use_current_ClassDeclaration_LoaderContainerTracker(
    use: TypeOnly<current.LoaderContainerTracker>): void;
use_current_ClassDeclaration_LoaderContainerTracker(
    get_old_ClassDeclaration_LoaderContainerTracker());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LoaderContainerTracker": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_LoaderContainerTracker():
    TypeOnly<current.LoaderContainerTracker>;
declare function use_old_ClassDeclaration_LoaderContainerTracker(
    use: TypeOnly<old.LoaderContainerTracker>): void;
use_old_ClassDeclaration_LoaderContainerTracker(
    get_current_ClassDeclaration_LoaderContainerTracker());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LocalCodeLoader": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_LocalCodeLoader():
    TypeOnly<old.LocalCodeLoader>;
declare function use_current_ClassDeclaration_LocalCodeLoader(
    use: TypeOnly<current.LocalCodeLoader>): void;
use_current_ClassDeclaration_LocalCodeLoader(
    get_old_ClassDeclaration_LocalCodeLoader());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LocalCodeLoader": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_LocalCodeLoader():
    TypeOnly<current.LocalCodeLoader>;
declare function use_old_ClassDeclaration_LocalCodeLoader(
    use: TypeOnly<old.LocalCodeLoader>): void;
use_old_ClassDeclaration_LocalCodeLoader(
    get_current_ClassDeclaration_LocalCodeLoader());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SummaryInfo": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SummaryInfo():
    TypeOnly<old.SummaryInfo>;
declare function use_current_InterfaceDeclaration_SummaryInfo(
    use: TypeOnly<current.SummaryInfo>): void;
use_current_InterfaceDeclaration_SummaryInfo(
    get_old_InterfaceDeclaration_SummaryInfo());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SummaryInfo": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SummaryInfo():
    TypeOnly<current.SummaryInfo>;
declare function use_old_InterfaceDeclaration_SummaryInfo(
    use: TypeOnly<old.SummaryInfo>): void;
use_old_InterfaceDeclaration_SummaryInfo(
    get_current_InterfaceDeclaration_SummaryInfo());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SupportedExportInterfaces": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SupportedExportInterfaces():
    TypeOnly<old.SupportedExportInterfaces>;
declare function use_current_TypeAliasDeclaration_SupportedExportInterfaces(
    use: TypeOnly<current.SupportedExportInterfaces>): void;
use_current_TypeAliasDeclaration_SupportedExportInterfaces(
    get_old_TypeAliasDeclaration_SupportedExportInterfaces());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SupportedExportInterfaces": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SupportedExportInterfaces():
    TypeOnly<current.SupportedExportInterfaces>;
declare function use_old_TypeAliasDeclaration_SupportedExportInterfaces(
    use: TypeOnly<old.SupportedExportInterfaces>): void;
use_old_TypeAliasDeclaration_SupportedExportInterfaces(
    get_current_TypeAliasDeclaration_SupportedExportInterfaces());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_TestContainerRuntimeFactory": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_TestContainerRuntimeFactory():
    TypeOnly<typeof old.TestContainerRuntimeFactory>;
declare function use_current_VariableDeclaration_TestContainerRuntimeFactory(
    use: TypeOnly<typeof current.TestContainerRuntimeFactory>): void;
use_current_VariableDeclaration_TestContainerRuntimeFactory(
    get_old_VariableDeclaration_TestContainerRuntimeFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_TestContainerRuntimeFactory": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_TestContainerRuntimeFactory():
    TypeOnly<typeof current.TestContainerRuntimeFactory>;
declare function use_old_VariableDeclaration_TestContainerRuntimeFactory(
    use: TypeOnly<typeof old.TestContainerRuntimeFactory>): void;
use_old_VariableDeclaration_TestContainerRuntimeFactory(
    get_current_VariableDeclaration_TestContainerRuntimeFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestFluidObject": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TestFluidObject():
    TypeOnly<old.TestFluidObject>;
declare function use_current_ClassDeclaration_TestFluidObject(
    use: TypeOnly<current.TestFluidObject>): void;
use_current_ClassDeclaration_TestFluidObject(
    get_old_ClassDeclaration_TestFluidObject());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestFluidObject": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TestFluidObject():
    TypeOnly<current.TestFluidObject>;
declare function use_old_ClassDeclaration_TestFluidObject(
    use: TypeOnly<old.TestFluidObject>): void;
use_old_ClassDeclaration_TestFluidObject(
    get_current_ClassDeclaration_TestFluidObject());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestFluidObjectFactory": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TestFluidObjectFactory():
    TypeOnly<old.TestFluidObjectFactory>;
declare function use_current_ClassDeclaration_TestFluidObjectFactory(
    use: TypeOnly<current.TestFluidObjectFactory>): void;
use_current_ClassDeclaration_TestFluidObjectFactory(
    get_old_ClassDeclaration_TestFluidObjectFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestFluidObjectFactory": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TestFluidObjectFactory():
    TypeOnly<current.TestFluidObjectFactory>;
declare function use_old_ClassDeclaration_TestFluidObjectFactory(
    use: TypeOnly<old.TestFluidObjectFactory>): void;
use_old_ClassDeclaration_TestFluidObjectFactory(
    get_current_ClassDeclaration_TestFluidObjectFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestObjectProvider": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TestObjectProvider():
    TypeOnly<old.TestObjectProvider>;
declare function use_current_ClassDeclaration_TestObjectProvider(
    use: TypeOnly<current.TestObjectProvider>): void;
use_current_ClassDeclaration_TestObjectProvider(
    get_old_ClassDeclaration_TestObjectProvider());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestObjectProvider": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TestObjectProvider():
    TypeOnly<current.TestObjectProvider>;
declare function use_old_ClassDeclaration_TestObjectProvider(
    use: TypeOnly<old.TestObjectProvider>): void;
use_old_ClassDeclaration_TestObjectProvider(
    get_current_ClassDeclaration_TestObjectProvider());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestObjectProviderWithVersionedLoad": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TestObjectProviderWithVersionedLoad():
    TypeOnly<old.TestObjectProviderWithVersionedLoad>;
declare function use_current_ClassDeclaration_TestObjectProviderWithVersionedLoad(
    use: TypeOnly<current.TestObjectProviderWithVersionedLoad>): void;
use_current_ClassDeclaration_TestObjectProviderWithVersionedLoad(
    get_old_ClassDeclaration_TestObjectProviderWithVersionedLoad());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TestObjectProviderWithVersionedLoad": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TestObjectProviderWithVersionedLoad():
    TypeOnly<current.TestObjectProviderWithVersionedLoad>;
declare function use_old_ClassDeclaration_TestObjectProviderWithVersionedLoad(
    use: TypeOnly<old.TestObjectProviderWithVersionedLoad>): void;
use_old_ClassDeclaration_TestObjectProviderWithVersionedLoad(
    get_current_ClassDeclaration_TestObjectProviderWithVersionedLoad());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_TimeoutWithError": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TimeoutWithError():
    TypeOnly<old.TimeoutWithError>;
declare function use_current_InterfaceDeclaration_TimeoutWithError(
    use: TypeOnly<current.TimeoutWithError>): void;
use_current_InterfaceDeclaration_TimeoutWithError(
    get_old_InterfaceDeclaration_TimeoutWithError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_TimeoutWithError": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TimeoutWithError():
    TypeOnly<current.TimeoutWithError>;
declare function use_old_InterfaceDeclaration_TimeoutWithError(
    use: TypeOnly<old.TimeoutWithError>): void;
use_old_InterfaceDeclaration_TimeoutWithError(
    get_current_InterfaceDeclaration_TimeoutWithError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_TimeoutWithValue": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TimeoutWithValue():
    TypeOnly<old.TimeoutWithValue>;
declare function use_current_InterfaceDeclaration_TimeoutWithValue(
    use: TypeOnly<current.TimeoutWithValue>): void;
use_current_InterfaceDeclaration_TimeoutWithValue(
    get_old_InterfaceDeclaration_TimeoutWithValue());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_TimeoutWithValue": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TimeoutWithValue():
    TypeOnly<current.TimeoutWithValue>;
declare function use_old_InterfaceDeclaration_TimeoutWithValue(
    use: TypeOnly<old.TimeoutWithValue>): void;
use_old_InterfaceDeclaration_TimeoutWithValue(
    get_current_InterfaceDeclaration_TimeoutWithValue());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createAndAttachContainer": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createAndAttachContainer():
    TypeOnly<typeof old.createAndAttachContainer>;
declare function use_current_FunctionDeclaration_createAndAttachContainer(
    use: TypeOnly<typeof current.createAndAttachContainer>): void;
use_current_FunctionDeclaration_createAndAttachContainer(
    get_old_FunctionDeclaration_createAndAttachContainer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createAndAttachContainer": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createAndAttachContainer():
    TypeOnly<typeof current.createAndAttachContainer>;
declare function use_old_FunctionDeclaration_createAndAttachContainer(
    use: TypeOnly<typeof old.createAndAttachContainer>): void;
use_old_FunctionDeclaration_createAndAttachContainer(
    get_current_FunctionDeclaration_createAndAttachContainer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore():
    TypeOnly<typeof old.createContainerRuntimeFactoryWithDefaultDataStore>;
declare function use_current_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore(
    use: TypeOnly<typeof current.createContainerRuntimeFactoryWithDefaultDataStore>): void;
use_current_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore(
    get_old_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore():
    TypeOnly<typeof current.createContainerRuntimeFactoryWithDefaultDataStore>;
declare function use_old_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore(
    use: TypeOnly<typeof old.createContainerRuntimeFactoryWithDefaultDataStore>): void;
use_old_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore(
    get_current_VariableDeclaration_createContainerRuntimeFactoryWithDefaultDataStore());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createDocumentId": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_createDocumentId():
    TypeOnly<typeof old.createDocumentId>;
declare function use_current_VariableDeclaration_createDocumentId(
    use: TypeOnly<typeof current.createDocumentId>): void;
use_current_VariableDeclaration_createDocumentId(
    get_old_VariableDeclaration_createDocumentId());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createDocumentId": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_createDocumentId():
    TypeOnly<typeof current.createDocumentId>;
declare function use_old_VariableDeclaration_createDocumentId(
    use: TypeOnly<typeof old.createDocumentId>): void;
use_old_VariableDeclaration_createDocumentId(
    get_current_VariableDeclaration_createDocumentId());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createLoader": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createLoader():
    TypeOnly<typeof old.createLoader>;
declare function use_current_FunctionDeclaration_createLoader(
    use: TypeOnly<typeof current.createLoader>): void;
use_current_FunctionDeclaration_createLoader(
    get_old_FunctionDeclaration_createLoader());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createLoader": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createLoader():
    TypeOnly<typeof current.createLoader>;
declare function use_old_FunctionDeclaration_createLoader(
    use: TypeOnly<typeof old.createLoader>): void;
use_old_FunctionDeclaration_createLoader(
    get_current_FunctionDeclaration_createLoader());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSummarizer": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createSummarizer():
    TypeOnly<typeof old.createSummarizer>;
declare function use_current_FunctionDeclaration_createSummarizer(
    use: TypeOnly<typeof current.createSummarizer>): void;
use_current_FunctionDeclaration_createSummarizer(
    get_old_FunctionDeclaration_createSummarizer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSummarizer": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createSummarizer():
    TypeOnly<typeof current.createSummarizer>;
declare function use_old_FunctionDeclaration_createSummarizer(
    use: TypeOnly<typeof old.createSummarizer>): void;
use_old_FunctionDeclaration_createSummarizer(
    get_current_FunctionDeclaration_createSummarizer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSummarizerCore": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createSummarizerCore():
    TypeOnly<typeof old.createSummarizerCore>;
declare function use_current_FunctionDeclaration_createSummarizerCore(
    use: TypeOnly<typeof current.createSummarizerCore>): void;
use_current_FunctionDeclaration_createSummarizerCore(
    get_old_FunctionDeclaration_createSummarizerCore());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSummarizerCore": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createSummarizerCore():
    TypeOnly<typeof current.createSummarizerCore>;
declare function use_old_FunctionDeclaration_createSummarizerCore(
    use: TypeOnly<typeof old.createSummarizerCore>): void;
use_old_FunctionDeclaration_createSummarizerCore(
    get_current_FunctionDeclaration_createSummarizerCore());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSummarizerFromFactory": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createSummarizerFromFactory():
    TypeOnly<typeof old.createSummarizerFromFactory>;
declare function use_current_FunctionDeclaration_createSummarizerFromFactory(
    use: TypeOnly<typeof current.createSummarizerFromFactory>): void;
use_current_FunctionDeclaration_createSummarizerFromFactory(
    get_old_FunctionDeclaration_createSummarizerFromFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createSummarizerFromFactory": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createSummarizerFromFactory():
    TypeOnly<typeof current.createSummarizerFromFactory>;
declare function use_old_FunctionDeclaration_createSummarizerFromFactory(
    use: TypeOnly<typeof old.createSummarizerFromFactory>): void;
use_old_FunctionDeclaration_createSummarizerFromFactory(
    get_current_FunctionDeclaration_createSummarizerFromFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createTestConfigProvider": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_createTestConfigProvider():
    TypeOnly<typeof old.createTestConfigProvider>;
declare function use_current_VariableDeclaration_createTestConfigProvider(
    use: TypeOnly<typeof current.createTestConfigProvider>): void;
use_current_VariableDeclaration_createTestConfigProvider(
    get_old_VariableDeclaration_createTestConfigProvider());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createTestConfigProvider": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_createTestConfigProvider():
    TypeOnly<typeof current.createTestConfigProvider>;
declare function use_old_VariableDeclaration_createTestConfigProvider(
    use: TypeOnly<typeof old.createTestConfigProvider>): void;
use_old_VariableDeclaration_createTestConfigProvider(
    get_current_VariableDeclaration_createTestConfigProvider());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createTestContainerRuntimeFactory": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_createTestContainerRuntimeFactory():
    TypeOnly<typeof old.createTestContainerRuntimeFactory>;
declare function use_current_VariableDeclaration_createTestContainerRuntimeFactory(
    use: TypeOnly<typeof current.createTestContainerRuntimeFactory>): void;
use_current_VariableDeclaration_createTestContainerRuntimeFactory(
    get_old_VariableDeclaration_createTestContainerRuntimeFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createTestContainerRuntimeFactory": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_createTestContainerRuntimeFactory():
    TypeOnly<typeof current.createTestContainerRuntimeFactory>;
declare function use_old_VariableDeclaration_createTestContainerRuntimeFactory(
    use: TypeOnly<typeof old.createTestContainerRuntimeFactory>): void;
use_old_VariableDeclaration_createTestContainerRuntimeFactory(
    get_current_VariableDeclaration_createTestContainerRuntimeFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_defaultTimeoutDurationMs": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_defaultTimeoutDurationMs():
    TypeOnly<typeof old.defaultTimeoutDurationMs>;
declare function use_current_VariableDeclaration_defaultTimeoutDurationMs(
    use: TypeOnly<typeof current.defaultTimeoutDurationMs>): void;
use_current_VariableDeclaration_defaultTimeoutDurationMs(
    get_old_VariableDeclaration_defaultTimeoutDurationMs());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_defaultTimeoutDurationMs": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_defaultTimeoutDurationMs():
    TypeOnly<typeof current.defaultTimeoutDurationMs>;
declare function use_old_VariableDeclaration_defaultTimeoutDurationMs(
    use: TypeOnly<typeof old.defaultTimeoutDurationMs>): void;
use_old_VariableDeclaration_defaultTimeoutDurationMs(
    get_current_VariableDeclaration_defaultTimeoutDurationMs());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_fluidEntryPoint": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_fluidEntryPoint():
    TypeOnly<old.fluidEntryPoint>;
declare function use_current_TypeAliasDeclaration_fluidEntryPoint(
    use: TypeOnly<current.fluidEntryPoint>): void;
use_current_TypeAliasDeclaration_fluidEntryPoint(
    get_old_TypeAliasDeclaration_fluidEntryPoint());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_fluidEntryPoint": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_fluidEntryPoint():
    TypeOnly<current.fluidEntryPoint>;
declare function use_old_TypeAliasDeclaration_fluidEntryPoint(
    use: TypeOnly<old.fluidEntryPoint>): void;
use_old_TypeAliasDeclaration_fluidEntryPoint(
    get_current_TypeAliasDeclaration_fluidEntryPoint());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getContainerEntryPointBackCompat": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getContainerEntryPointBackCompat():
    TypeOnly<typeof old.getContainerEntryPointBackCompat>;
declare function use_current_FunctionDeclaration_getContainerEntryPointBackCompat(
    use: TypeOnly<typeof current.getContainerEntryPointBackCompat>): void;
use_current_FunctionDeclaration_getContainerEntryPointBackCompat(
    get_old_FunctionDeclaration_getContainerEntryPointBackCompat());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getContainerEntryPointBackCompat": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getContainerEntryPointBackCompat():
    TypeOnly<typeof current.getContainerEntryPointBackCompat>;
declare function use_old_FunctionDeclaration_getContainerEntryPointBackCompat(
    use: TypeOnly<typeof old.getContainerEntryPointBackCompat>): void;
use_old_FunctionDeclaration_getContainerEntryPointBackCompat(
    get_current_FunctionDeclaration_getContainerEntryPointBackCompat());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getDataStoreEntryPointBackCompat": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getDataStoreEntryPointBackCompat():
    TypeOnly<typeof old.getDataStoreEntryPointBackCompat>;
declare function use_current_FunctionDeclaration_getDataStoreEntryPointBackCompat(
    use: TypeOnly<typeof current.getDataStoreEntryPointBackCompat>): void;
use_current_FunctionDeclaration_getDataStoreEntryPointBackCompat(
    get_old_FunctionDeclaration_getDataStoreEntryPointBackCompat());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getDataStoreEntryPointBackCompat": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getDataStoreEntryPointBackCompat():
    TypeOnly<typeof current.getDataStoreEntryPointBackCompat>;
declare function use_old_FunctionDeclaration_getDataStoreEntryPointBackCompat(
    use: TypeOnly<typeof old.getDataStoreEntryPointBackCompat>): void;
use_old_FunctionDeclaration_getDataStoreEntryPointBackCompat(
    get_current_FunctionDeclaration_getDataStoreEntryPointBackCompat());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getUnexpectedLogErrorException": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getUnexpectedLogErrorException():
    TypeOnly<typeof old.getUnexpectedLogErrorException>;
declare function use_current_FunctionDeclaration_getUnexpectedLogErrorException(
    use: TypeOnly<typeof current.getUnexpectedLogErrorException>): void;
use_current_FunctionDeclaration_getUnexpectedLogErrorException(
    get_old_FunctionDeclaration_getUnexpectedLogErrorException());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getUnexpectedLogErrorException": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getUnexpectedLogErrorException():
    TypeOnly<typeof current.getUnexpectedLogErrorException>;
declare function use_old_FunctionDeclaration_getUnexpectedLogErrorException(
    use: TypeOnly<typeof old.getUnexpectedLogErrorException>): void;
use_old_FunctionDeclaration_getUnexpectedLogErrorException(
    get_current_FunctionDeclaration_getUnexpectedLogErrorException());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_retryWithEventualValue": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_retryWithEventualValue():
    TypeOnly<typeof old.retryWithEventualValue>;
declare function use_current_VariableDeclaration_retryWithEventualValue(
    use: TypeOnly<typeof current.retryWithEventualValue>): void;
use_current_VariableDeclaration_retryWithEventualValue(
    get_old_VariableDeclaration_retryWithEventualValue());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_retryWithEventualValue": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_retryWithEventualValue():
    TypeOnly<typeof current.retryWithEventualValue>;
declare function use_old_VariableDeclaration_retryWithEventualValue(
    use: TypeOnly<typeof old.retryWithEventualValue>): void;
use_old_VariableDeclaration_retryWithEventualValue(
    get_current_VariableDeclaration_retryWithEventualValue());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_summarizeNow": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_summarizeNow():
    TypeOnly<typeof old.summarizeNow>;
declare function use_current_FunctionDeclaration_summarizeNow(
    use: TypeOnly<typeof current.summarizeNow>): void;
use_current_FunctionDeclaration_summarizeNow(
    get_old_FunctionDeclaration_summarizeNow());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_summarizeNow": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_summarizeNow():
    TypeOnly<typeof current.summarizeNow>;
declare function use_old_FunctionDeclaration_summarizeNow(
    use: TypeOnly<typeof old.summarizeNow>): void;
use_old_FunctionDeclaration_summarizeNow(
    get_current_FunctionDeclaration_summarizeNow());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_timeoutAwait": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_timeoutAwait():
    TypeOnly<typeof old.timeoutAwait>;
declare function use_current_FunctionDeclaration_timeoutAwait(
    use: TypeOnly<typeof current.timeoutAwait>): void;
use_current_FunctionDeclaration_timeoutAwait(
    get_old_FunctionDeclaration_timeoutAwait());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_timeoutAwait": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_timeoutAwait():
    TypeOnly<typeof current.timeoutAwait>;
declare function use_old_FunctionDeclaration_timeoutAwait(
    use: TypeOnly<typeof old.timeoutAwait>): void;
use_old_FunctionDeclaration_timeoutAwait(
    get_current_FunctionDeclaration_timeoutAwait());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_timeoutPromise": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_timeoutPromise():
    TypeOnly<typeof old.timeoutPromise>;
declare function use_current_FunctionDeclaration_timeoutPromise(
    use: TypeOnly<typeof current.timeoutPromise>): void;
use_current_FunctionDeclaration_timeoutPromise(
    get_old_FunctionDeclaration_timeoutPromise());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_timeoutPromise": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_timeoutPromise():
    TypeOnly<typeof current.timeoutPromise>;
declare function use_old_FunctionDeclaration_timeoutPromise(
    use: TypeOnly<typeof old.timeoutPromise>): void;
use_old_FunctionDeclaration_timeoutPromise(
    get_current_FunctionDeclaration_timeoutPromise());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_waitForContainerConnection": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_waitForContainerConnection():
    TypeOnly<typeof old.waitForContainerConnection>;
declare function use_current_FunctionDeclaration_waitForContainerConnection(
    use: TypeOnly<typeof current.waitForContainerConnection>): void;
use_current_FunctionDeclaration_waitForContainerConnection(
    get_old_FunctionDeclaration_waitForContainerConnection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_waitForContainerConnection": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_waitForContainerConnection():
    TypeOnly<typeof current.waitForContainerConnection>;
declare function use_old_FunctionDeclaration_waitForContainerConnection(
    use: TypeOnly<typeof old.waitForContainerConnection>): void;
use_old_FunctionDeclaration_waitForContainerConnection(
    get_current_FunctionDeclaration_waitForContainerConnection());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapDocumentService": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_wrapDocumentService():
    TypeOnly<typeof old.wrapDocumentService>;
declare function use_current_FunctionDeclaration_wrapDocumentService(
    use: TypeOnly<typeof current.wrapDocumentService>): void;
use_current_FunctionDeclaration_wrapDocumentService(
    get_old_FunctionDeclaration_wrapDocumentService());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapDocumentService": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_wrapDocumentService():
    TypeOnly<typeof current.wrapDocumentService>;
declare function use_old_FunctionDeclaration_wrapDocumentService(
    use: TypeOnly<typeof old.wrapDocumentService>): void;
use_old_FunctionDeclaration_wrapDocumentService(
    get_current_FunctionDeclaration_wrapDocumentService());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapDocumentServiceFactory": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_wrapDocumentServiceFactory():
    TypeOnly<typeof old.wrapDocumentServiceFactory>;
declare function use_current_FunctionDeclaration_wrapDocumentServiceFactory(
    use: TypeOnly<typeof current.wrapDocumentServiceFactory>): void;
use_current_FunctionDeclaration_wrapDocumentServiceFactory(
    get_old_FunctionDeclaration_wrapDocumentServiceFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapDocumentServiceFactory": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_wrapDocumentServiceFactory():
    TypeOnly<typeof current.wrapDocumentServiceFactory>;
declare function use_old_FunctionDeclaration_wrapDocumentServiceFactory(
    use: TypeOnly<typeof old.wrapDocumentServiceFactory>): void;
use_old_FunctionDeclaration_wrapDocumentServiceFactory(
    get_current_FunctionDeclaration_wrapDocumentServiceFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapDocumentStorageService": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_wrapDocumentStorageService():
    TypeOnly<typeof old.wrapDocumentStorageService>;
declare function use_current_FunctionDeclaration_wrapDocumentStorageService(
    use: TypeOnly<typeof current.wrapDocumentStorageService>): void;
use_current_FunctionDeclaration_wrapDocumentStorageService(
    get_old_FunctionDeclaration_wrapDocumentStorageService());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_wrapDocumentStorageService": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_wrapDocumentStorageService():
    TypeOnly<typeof current.wrapDocumentStorageService>;
declare function use_old_FunctionDeclaration_wrapDocumentStorageService(
    use: TypeOnly<typeof old.wrapDocumentStorageService>): void;
use_old_FunctionDeclaration_wrapDocumentStorageService(
    get_current_FunctionDeclaration_wrapDocumentStorageService());
