{"version":3,"file":"loadTestDataStore.js","sourceRoot":"","sources":["../src/loadTestDataStore.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,EACH,2CAA2C,EAC3C,UAAU,EACV,iBAAiB,GACpB,MAAM,0BAA0B,CAAC;AAYlC,MAAM,IAAI,GAAG,KAAK,EAAE,MAAc,EAAE,EAAE,CAAC,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,CAAC;AAE7F,MAAM,iBAAkB,SAAQ,UAAU;IAA1C;;QAEY,YAAO,GAAG,CAAC,CAAC;QACZ,cAAS,GAAG,CAAC,CAAC;QACd,UAAK,GAAW,aAAa,CAAC;IA8F1C,CAAC;IA7Fa,KAAK,CAAC,cAAc;QAC1B,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE;YACpB,IAAI,CAAC,OAAO,EAAE,CAAC;QACnB,CAAC,CAAC,CAAC;IACP,CAAC;IAEM,KAAK,CAAC,KAAK,CAAC,MAAc;QAC7B,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC;QACtB,MAAM,IAAI,CAAC,MAAM,CAAC,CAAC;QACnB,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;QACvB,OAAO,IAAI,CAAC,GAAG,EAAE,GAAG,WAAW,CAAC;IACpC,CAAC;IAEO,WAAW,CAAC,MAAkB,EAAE,WAAmB,EAAE,kBAA0B;QACnF,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,MAAM,QAAQ,GAAG,CAAC,GAAG,GAAG,WAAW,CAAC,GAAG,KAAK,CAAC;QAC7C,MAAM,UAAU,GAAG,CAAC,GAAG,GAAG,kBAAkB,CAAC,GAAG,KAAK,CAAC;QACtD,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC,CAAC;QACnD,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,CAAC;QACzD,OAAO,CAAC,GAAG,CACP,GAAG,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG;YACzC,UAAU,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ;YACvF,UAAU,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,QAAQ,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ;YAC3F,cAAc,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,EAChE,gBAAgB,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,CACnE,CAAC;IACN,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAAkB;QAC/B,+BAA+B;QAC/B,OAAO,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;QAC/D,MAAM,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE;YAChC,IAAI,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC,UAAU,EAAE,CAAC,IAAI,CAAC;YAC7D,IAAI,WAAW,IAAI,MAAM,CAAC,UAAU,CAAC,UAAU,EAAE;gBAAE,OAAO,EAAE,CAAC;aAAE;YAC/D,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC,EAAE,CAAC,WAAW,EAAE,GAAG,EAAE;gBAC1C,WAAW,EAAE,CAAC;gBACd,IAAI,WAAW,IAAI,MAAM,CAAC,UAAU,CAAC,UAAU,EAAE;oBAAE,OAAO,EAAE,CAAC;iBAAE;YACnE,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;QACH,OAAO,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QAE7D,wFAAwF;QACxF,yCAAyC;QACzC,gGAAgG;QAChG,oBAAoB;QAEpB,MAAM,OAAO,GAAG,MAAM,CAAC,UAAU,CAAC,gBAAgB,CAAC;QAEnD,oFAAoF;QACpF,0CAA0C;QAC1C,MAAM,gBAAgB,GAAG,OAAO,GAAG,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC,UAAU,CAAC;QAEpE,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC/B,IAAI,kBAAkB,GAAG,WAAW,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,GAAG,gBAAgB,CAAC,CAAC;QAEzF,OAAO,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;QAE/D,IAAI,CAAiB,CAAC;QACtB,MAAM,aAAa,GAAG,GAAG,EAAE;YACvB,IAAI,IAAI,CAAC,KAAK,KAAK,QAAQ,EAAE;gBACzB,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,WAAW,EAAE,kBAAkB,CAAC,CAAC;aAC7D;YACD,CAAC,GAAG,UAAU,CAAC,aAAa,EAAE,MAAM,CAAC,UAAU,CAAC,kBAAkB,CAAC,CAAC;QACxE,CAAC,CAAC;QACF,CAAC,GAAG,UAAU,CAAC,aAAa,EAAE,MAAM,CAAC,UAAU,CAAC,kBAAkB,CAAC,CAAC;QAEpE,MAAM,eAAe,GAAG,MAAM,CAAC,UAAU,CAAC,cAAc,GAAG,MAAM,CAAC,UAAU,CAAC,UAAU,CAAC;QACxF,MAAM,WAAW,GAAG,MAAM,CAAC,UAAU,CAAC,YAAY,GAAG,OAAO,GAAG,KAAK,CAAC;QACrE,MAAM,QAAQ,GAAG,OAAO,GAAG,WAAW,CAAC;QACvC,OAAO,IAAI,CAAC,SAAS,GAAG,eAAe,EAAE;YACrC,MAAM,IAAI,CAAC,OAAO,EAAE,CAAC;YACrB,0BAA0B;YAC1B,IAAI,IAAI,CAAC,SAAS,GAAG,WAAW,KAAK,CAAC,EAAE;gBACpC,0CAA0C;gBAC1C,kBAAkB,IAAI,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;aACnD;iBAAM;gBACH,sCAAsC;gBACtC,MAAM,IAAI,CAAC,QAAQ,GAAG,QAAQ,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;aAC3D;SACJ;QAED,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;QACvB,YAAY,CAAC,CAAC,CAAC,CAAC;QAEhB,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,WAAW,EAAE,kBAAkB,CAAC,CAAC;QAC1D,OAAO,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC;IACpE,CAAC;IAEM,KAAK,CAAC,OAAO;QAChB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;QACxE,IAAI,CAAC,SAAS,EAAE,CAAC;IACrB,CAAC;;AAhGa,+BAAa,GAAG,qBAAqB,CAAC;AAmGxD,MAAM,qCAAqC,GAAG,IAAI,iBAAiB,CAC/D,iBAAiB,CAAC,aAAa,EAC/B,iBAAiB,EACjB,EAAE,EACF,EAAE,CACL,CAAC;AAEF,MAAM,CAAC,MAAM,WAAW,GAAG,IAAI,2CAA2C,CACtE,qCAAqC,EACrC,IAAI,GAAG,CAAC,CAAC,CAAC,iBAAiB,CAAC,aAAa,EAAE,OAAO,CAAC,OAAO,CAAC,qCAAqC,CAAC,CAAC,CAAC,CAAC,CACvG,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    ContainerRuntimeFactoryWithDefaultDataStore,\n    DataObject,\n    DataObjectFactory,\n} from \"@fluidframework/aqueduct\";\nimport { ILoadTestConfig } from \"./testConfigFile\";\n\nexport interface IRunConfig {\n    runId: number,\n    testConfig: ILoadTestConfig\n}\n\nexport interface ILoadTest {\n    run(config: IRunConfig): Promise<void>;\n}\n\nconst wait = async (timeMs: number) => new Promise((resolve) => setTimeout(resolve, timeMs));\n\nclass LoadTestDataStore extends DataObject implements ILoadTest {\n    public static DataStoreName = \"StressTestDataStore\";\n    private opCount = 0;\n    private sentCount = 0;\n    private state: string = \"not started\";\n    protected async hasInitialized() {\n        this.root.on(\"op\", () => {\n            this.opCount++;\n        });\n    }\n\n    public async pause(timeMs: number) {\n        const startTimeMs = Date.now();\n        this.state = \"paused\";\n        await wait(timeMs);\n        this.state = \"running\";\n        return Date.now() - startTimeMs;\n    }\n\n    private printStatus(config: IRunConfig, startTimeMs: number, runningStartTimeMs: number) {\n        const now = Date.now();\n        const totalMin = (now - startTimeMs) / 60000;\n        const runningMin = (now - runningStartTimeMs) / 60000;\n        const opRate = Math.floor(this.opCount / totalMin);\n        const sendRate = Math.floor(this.sentCount / runningMin);\n        console.log(\n            `${config.runId.toString().padStart(3)}>` +\n            ` seen: ${this.opCount.toString().padStart(8)} (${opRate.toString().padStart(4)}/min),` +\n            ` sent: ${this.sentCount.toString().padStart(8)} (${sendRate.toString().padStart(2)}/min),` +\n            ` run time: ${runningMin.toFixed(2).toString().padStart(5)} min`,\n            ` total time: ${totalMin.toFixed(2).toString().padStart(5)} min`,\n        );\n    }\n\n    public async run(config: IRunConfig) {\n        // Wait for all runners to join\n        console.log(`${config.runId.toString().padStart(3)}> waiting`);\n        await new Promise<void>((resolve) => {\n            let memberCount = this.context.getQuorum().getMembers().size;\n            if (memberCount >= config.testConfig.numClients) { resolve(); }\n            this.context.getQuorum().on(\"addMember\", () => {\n                memberCount++;\n                if (memberCount >= config.testConfig.numClients) { resolve(); }\n            });\n        });\n        console.log(`${config.runId.toString().padStart(3)}> begin`);\n\n        // At every moment, we want half the client to be concurrent writers, and start and stop\n        // in a rotation fashion for every cycle.\n        // To set that up we start each client in a staggered way, each will independently go thru write\n        // and listen cycles\n\n        const cycleMs = config.testConfig.readWriteCycleMs;\n\n        // the time gap to start each client over two cycles  (or one full read/write cycle)\n        // to get half the client active at a time\n        const clientStartGapMs = cycleMs * 2 / config.testConfig.numClients;\n\n        const startTimeMs = Date.now();\n        let runningStartTimeMs = startTimeMs + await this.pause(config.runId * clientStartGapMs);\n\n        console.log(`${config.runId.toString().padStart(3)}> started`);\n\n        let t: NodeJS.Timeout;\n        const printProgress = () => {\n            if (this.state !== \"paused\") {\n                this.printStatus(config, startTimeMs, runningStartTimeMs);\n            }\n            t = setTimeout(printProgress, config.testConfig.progressIntervalMs);\n        };\n        t = setTimeout(printProgress, config.testConfig.progressIntervalMs);\n\n        const clientSendCount = config.testConfig.totalSendCount / config.testConfig.numClients;\n        const opsPerCycle = config.testConfig.opRatePerMin * cycleMs / 60000;\n        const opsGapMs = cycleMs / opsPerCycle;\n        while (this.sentCount < clientSendCount) {\n            await this.runStep();\n            // Send cycle worth of Ops\n            if (this.sentCount % opsPerCycle === 0) {\n                // Pause writing for cycle before resuming\n                runningStartTimeMs += await this.pause(cycleMs);\n            } else {\n                // Random jitter of +- 50% of opWaitMs\n                await wait(opsGapMs + opsGapMs * (Math.random() - 0.5));\n            }\n        }\n\n        this.state = \"stopped\";\n        clearTimeout(t);\n\n        this.printStatus(config, startTimeMs, runningStartTimeMs);\n        console.log(`${config.runId.toString().padStart(3)}> finished`);\n    }\n\n    public async runStep() {\n        this.root.set(Math.floor(Math.random() * 32).toString(), Math.random());\n        this.sentCount++;\n    }\n}\n\nconst LoadTestDataStoreInstantiationFactory = new DataObjectFactory(\n    LoadTestDataStore.DataStoreName,\n    LoadTestDataStore,\n    [],\n    {},\n);\n\nexport const fluidExport = new ContainerRuntimeFactoryWithDefaultDataStore(\n    LoadTestDataStoreInstantiationFactory,\n    new Map([[LoadTestDataStore.DataStoreName, Promise.resolve(LoadTestDataStoreInstantiationFactory)]]),\n);\n"]}