/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "@fluidframework/merge-tree-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_addProperties": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_addProperties():
    TypeOnly<typeof old.addProperties>;
declare function use_current_FunctionDeclaration_addProperties(
    use: TypeOnly<typeof current.addProperties>);
use_current_FunctionDeclaration_addProperties(
    get_old_FunctionDeclaration_addProperties());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_addProperties": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_addProperties():
    TypeOnly<typeof current.addProperties>;
declare function use_old_FunctionDeclaration_addProperties(
    use: TypeOnly<typeof old.addProperties>);
use_old_FunctionDeclaration_addProperties(
    get_current_FunctionDeclaration_addProperties());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_AugmentedIntervalNode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_AugmentedIntervalNode():
    TypeOnly<old.AugmentedIntervalNode>;
declare function use_current_InterfaceDeclaration_AugmentedIntervalNode(
    use: TypeOnly<current.AugmentedIntervalNode>);
use_current_InterfaceDeclaration_AugmentedIntervalNode(
    get_old_InterfaceDeclaration_AugmentedIntervalNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_AugmentedIntervalNode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_AugmentedIntervalNode():
    TypeOnly<current.AugmentedIntervalNode>;
declare function use_old_InterfaceDeclaration_AugmentedIntervalNode(
    use: TypeOnly<old.AugmentedIntervalNode>);
use_old_InterfaceDeclaration_AugmentedIntervalNode(
    get_current_InterfaceDeclaration_AugmentedIntervalNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BaseSegment": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_BaseSegment():
    TypeOnly<old.BaseSegment>;
declare function use_current_ClassDeclaration_BaseSegment(
    use: TypeOnly<current.BaseSegment>);
use_current_ClassDeclaration_BaseSegment(
    get_old_ClassDeclaration_BaseSegment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BaseSegment": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_BaseSegment():
    TypeOnly<current.BaseSegment>;
declare function use_old_ClassDeclaration_BaseSegment(
    use: TypeOnly<old.BaseSegment>);
use_old_ClassDeclaration_BaseSegment(
    get_current_ClassDeclaration_BaseSegment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_BlockAction": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_BlockAction():
    TypeOnly<old.BlockAction<any>>;
declare function use_current_InterfaceDeclaration_BlockAction(
    use: TypeOnly<current.BlockAction<any>>);
use_current_InterfaceDeclaration_BlockAction(
    get_old_InterfaceDeclaration_BlockAction());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_BlockAction": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_BlockAction():
    TypeOnly<current.BlockAction<any>>;
declare function use_old_InterfaceDeclaration_BlockAction(
    use: TypeOnly<old.BlockAction<any>>);
use_old_InterfaceDeclaration_BlockAction(
    get_current_InterfaceDeclaration_BlockAction());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_BlockUpdateActions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_BlockUpdateActions():
    TypeOnly<old.BlockUpdateActions>;
declare function use_current_InterfaceDeclaration_BlockUpdateActions(
    use: TypeOnly<current.BlockUpdateActions>);
use_current_InterfaceDeclaration_BlockUpdateActions(
    get_old_InterfaceDeclaration_BlockUpdateActions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_BlockUpdateActions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_BlockUpdateActions():
    TypeOnly<current.BlockUpdateActions>;
declare function use_old_InterfaceDeclaration_BlockUpdateActions(
    use: TypeOnly<old.BlockUpdateActions>);
use_old_InterfaceDeclaration_BlockUpdateActions(
    get_current_InterfaceDeclaration_BlockUpdateActions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Client": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Client():
    TypeOnly<old.Client>;
declare function use_current_ClassDeclaration_Client(
    use: TypeOnly<current.Client>);
use_current_ClassDeclaration_Client(
    get_old_ClassDeclaration_Client());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Client": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Client():
    TypeOnly<current.Client>;
declare function use_old_ClassDeclaration_Client(
    use: TypeOnly<old.Client>);
use_old_ClassDeclaration_Client(
    get_current_ClassDeclaration_Client());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ClientSeq": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ClientSeq():
    TypeOnly<old.ClientSeq>;
declare function use_current_InterfaceDeclaration_ClientSeq(
    use: TypeOnly<current.ClientSeq>);
use_current_InterfaceDeclaration_ClientSeq(
    get_old_InterfaceDeclaration_ClientSeq());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ClientSeq": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ClientSeq():
    TypeOnly<current.ClientSeq>;
declare function use_old_InterfaceDeclaration_ClientSeq(
    use: TypeOnly<old.ClientSeq>);
use_old_InterfaceDeclaration_ClientSeq(
    get_current_InterfaceDeclaration_ClientSeq());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_clientSeqComparer": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_clientSeqComparer():
    TypeOnly<typeof old.clientSeqComparer>;
declare function use_current_VariableDeclaration_clientSeqComparer(
    use: TypeOnly<typeof current.clientSeqComparer>);
use_current_VariableDeclaration_clientSeqComparer(
    get_old_VariableDeclaration_clientSeqComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_clientSeqComparer": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_clientSeqComparer():
    TypeOnly<typeof current.clientSeqComparer>;
declare function use_old_VariableDeclaration_clientSeqComparer(
    use: TypeOnly<typeof old.clientSeqComparer>);
use_old_VariableDeclaration_clientSeqComparer(
    get_current_VariableDeclaration_clientSeqComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_clone": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_clone():
    TypeOnly<typeof old.clone>;
declare function use_current_FunctionDeclaration_clone(
    use: TypeOnly<typeof current.clone>);
use_current_FunctionDeclaration_clone(
    get_old_FunctionDeclaration_clone());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_clone": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_clone():
    TypeOnly<typeof current.clone>;
declare function use_old_FunctionDeclaration_clone(
    use: TypeOnly<typeof old.clone>);
use_old_FunctionDeclaration_clone(
    get_current_FunctionDeclaration_clone());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CollaborationWindow": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_CollaborationWindow():
    TypeOnly<old.CollaborationWindow>;
declare function use_current_ClassDeclaration_CollaborationWindow(
    use: TypeOnly<current.CollaborationWindow>);
use_current_ClassDeclaration_CollaborationWindow(
    get_old_ClassDeclaration_CollaborationWindow());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CollaborationWindow": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_CollaborationWindow():
    TypeOnly<current.CollaborationWindow>;
declare function use_old_ClassDeclaration_CollaborationWindow(
    use: TypeOnly<old.CollaborationWindow>);
use_old_ClassDeclaration_CollaborationWindow(
    get_current_ClassDeclaration_CollaborationWindow());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_combine": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_combine():
    TypeOnly<typeof old.combine>;
declare function use_current_FunctionDeclaration_combine(
    use: TypeOnly<typeof current.combine>);
use_current_FunctionDeclaration_combine(
    get_old_FunctionDeclaration_combine());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_combine": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_combine():
    TypeOnly<typeof current.combine>;
declare function use_old_FunctionDeclaration_combine(
    use: TypeOnly<typeof old.combine>);
use_old_FunctionDeclaration_combine(
    get_current_FunctionDeclaration_combine());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_compareNumbers": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_compareNumbers():
    TypeOnly<typeof old.compareNumbers>;
declare function use_current_VariableDeclaration_compareNumbers(
    use: TypeOnly<typeof current.compareNumbers>);
use_current_VariableDeclaration_compareNumbers(
    get_old_VariableDeclaration_compareNumbers());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_compareNumbers": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_compareNumbers():
    TypeOnly<typeof current.compareNumbers>;
declare function use_old_VariableDeclaration_compareNumbers(
    use: TypeOnly<typeof old.compareNumbers>);
use_old_VariableDeclaration_compareNumbers(
    get_current_VariableDeclaration_compareNumbers());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_Comparer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_Comparer():
    TypeOnly<old.Comparer<any>>;
declare function use_current_InterfaceDeclaration_Comparer(
    use: TypeOnly<current.Comparer<any>>);
use_current_InterfaceDeclaration_Comparer(
    get_old_InterfaceDeclaration_Comparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_Comparer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_Comparer():
    TypeOnly<current.Comparer<any>>;
declare function use_old_InterfaceDeclaration_Comparer(
    use: TypeOnly<old.Comparer<any>>);
use_old_InterfaceDeclaration_Comparer(
    get_current_InterfaceDeclaration_Comparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_compareReferencePositions": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_compareReferencePositions():
    TypeOnly<typeof old.compareReferencePositions>;
declare function use_current_FunctionDeclaration_compareReferencePositions(
    use: TypeOnly<typeof current.compareReferencePositions>);
use_current_FunctionDeclaration_compareReferencePositions(
    get_old_FunctionDeclaration_compareReferencePositions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_compareReferencePositions": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_compareReferencePositions():
    TypeOnly<typeof current.compareReferencePositions>;
declare function use_old_FunctionDeclaration_compareReferencePositions(
    use: TypeOnly<typeof old.compareReferencePositions>);
use_old_FunctionDeclaration_compareReferencePositions(
    get_current_FunctionDeclaration_compareReferencePositions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_compareStrings": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_compareStrings():
    TypeOnly<typeof old.compareStrings>;
declare function use_current_VariableDeclaration_compareStrings(
    use: TypeOnly<typeof current.compareStrings>);
use_current_VariableDeclaration_compareStrings(
    get_old_VariableDeclaration_compareStrings());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_compareStrings": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_compareStrings():
    TypeOnly<typeof current.compareStrings>;
declare function use_old_VariableDeclaration_compareStrings(
    use: TypeOnly<typeof old.compareStrings>);
use_old_VariableDeclaration_compareStrings(
    get_current_VariableDeclaration_compareStrings());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConflictAction": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ConflictAction():
    TypeOnly<old.ConflictAction<any,any>>;
declare function use_current_TypeAliasDeclaration_ConflictAction(
    use: TypeOnly<current.ConflictAction<any,any>>);
use_current_TypeAliasDeclaration_ConflictAction(
    get_old_TypeAliasDeclaration_ConflictAction());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ConflictAction": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ConflictAction():
    TypeOnly<current.ConflictAction<any,any>>;
declare function use_old_TypeAliasDeclaration_ConflictAction(
    use: TypeOnly<old.ConflictAction<any,any>>);
use_old_TypeAliasDeclaration_ConflictAction(
    get_current_TypeAliasDeclaration_ConflictAction());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createAnnotateMarkerOp": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createAnnotateMarkerOp():
    TypeOnly<typeof old.createAnnotateMarkerOp>;
declare function use_current_FunctionDeclaration_createAnnotateMarkerOp(
    use: TypeOnly<typeof current.createAnnotateMarkerOp>);
use_current_FunctionDeclaration_createAnnotateMarkerOp(
    get_old_FunctionDeclaration_createAnnotateMarkerOp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createAnnotateMarkerOp": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createAnnotateMarkerOp():
    TypeOnly<typeof current.createAnnotateMarkerOp>;
declare function use_old_FunctionDeclaration_createAnnotateMarkerOp(
    use: TypeOnly<typeof old.createAnnotateMarkerOp>);
use_old_FunctionDeclaration_createAnnotateMarkerOp(
    get_current_FunctionDeclaration_createAnnotateMarkerOp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createAnnotateRangeOp": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createAnnotateRangeOp():
    TypeOnly<typeof old.createAnnotateRangeOp>;
declare function use_current_FunctionDeclaration_createAnnotateRangeOp(
    use: TypeOnly<typeof current.createAnnotateRangeOp>);
use_current_FunctionDeclaration_createAnnotateRangeOp(
    get_old_FunctionDeclaration_createAnnotateRangeOp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createAnnotateRangeOp": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createAnnotateRangeOp():
    TypeOnly<typeof current.createAnnotateRangeOp>;
declare function use_old_FunctionDeclaration_createAnnotateRangeOp(
    use: TypeOnly<typeof old.createAnnotateRangeOp>);
use_old_FunctionDeclaration_createAnnotateRangeOp(
    get_current_FunctionDeclaration_createAnnotateRangeOp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createGroupOp": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createGroupOp():
    TypeOnly<typeof old.createGroupOp>;
declare function use_current_FunctionDeclaration_createGroupOp(
    use: TypeOnly<typeof current.createGroupOp>);
use_current_FunctionDeclaration_createGroupOp(
    get_old_FunctionDeclaration_createGroupOp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createGroupOp": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createGroupOp():
    TypeOnly<typeof current.createGroupOp>;
declare function use_old_FunctionDeclaration_createGroupOp(
    use: TypeOnly<typeof old.createGroupOp>);
use_old_FunctionDeclaration_createGroupOp(
    get_current_FunctionDeclaration_createGroupOp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createInsertOp": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createInsertOp():
    TypeOnly<typeof old.createInsertOp>;
declare function use_current_FunctionDeclaration_createInsertOp(
    use: TypeOnly<typeof current.createInsertOp>);
use_current_FunctionDeclaration_createInsertOp(
    get_old_FunctionDeclaration_createInsertOp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createInsertOp": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createInsertOp():
    TypeOnly<typeof current.createInsertOp>;
declare function use_old_FunctionDeclaration_createInsertOp(
    use: TypeOnly<typeof old.createInsertOp>);
use_old_FunctionDeclaration_createInsertOp(
    get_current_FunctionDeclaration_createInsertOp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createInsertSegmentOp": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createInsertSegmentOp():
    TypeOnly<typeof old.createInsertSegmentOp>;
declare function use_current_FunctionDeclaration_createInsertSegmentOp(
    use: TypeOnly<typeof current.createInsertSegmentOp>);
use_current_FunctionDeclaration_createInsertSegmentOp(
    get_old_FunctionDeclaration_createInsertSegmentOp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createInsertSegmentOp": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createInsertSegmentOp():
    TypeOnly<typeof current.createInsertSegmentOp>;
declare function use_old_FunctionDeclaration_createInsertSegmentOp(
    use: TypeOnly<typeof old.createInsertSegmentOp>);
use_old_FunctionDeclaration_createInsertSegmentOp(
    get_current_FunctionDeclaration_createInsertSegmentOp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createMap": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createMap():
    TypeOnly<typeof old.createMap>;
declare function use_current_FunctionDeclaration_createMap(
    use: TypeOnly<typeof current.createMap>);
use_current_FunctionDeclaration_createMap(
    get_old_FunctionDeclaration_createMap());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createMap": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createMap():
    TypeOnly<typeof current.createMap>;
declare function use_old_FunctionDeclaration_createMap(
    use: TypeOnly<typeof old.createMap>);
use_old_FunctionDeclaration_createMap(
    get_current_FunctionDeclaration_createMap());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createRemoveRangeOp": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createRemoveRangeOp():
    TypeOnly<typeof old.createRemoveRangeOp>;
declare function use_current_FunctionDeclaration_createRemoveRangeOp(
    use: TypeOnly<typeof current.createRemoveRangeOp>);
use_current_FunctionDeclaration_createRemoveRangeOp(
    get_old_FunctionDeclaration_createRemoveRangeOp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createRemoveRangeOp": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createRemoveRangeOp():
    TypeOnly<typeof current.createRemoveRangeOp>;
declare function use_old_FunctionDeclaration_createRemoveRangeOp(
    use: TypeOnly<typeof old.createRemoveRangeOp>);
use_old_FunctionDeclaration_createRemoveRangeOp(
    get_current_FunctionDeclaration_createRemoveRangeOp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DetachedReferencePosition": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_DetachedReferencePosition():
    TypeOnly<typeof old.DetachedReferencePosition>;
declare function use_current_VariableDeclaration_DetachedReferencePosition(
    use: TypeOnly<typeof current.DetachedReferencePosition>);
use_current_VariableDeclaration_DetachedReferencePosition(
    get_old_VariableDeclaration_DetachedReferencePosition());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DetachedReferencePosition": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_DetachedReferencePosition():
    TypeOnly<typeof current.DetachedReferencePosition>;
declare function use_old_VariableDeclaration_DetachedReferencePosition(
    use: TypeOnly<typeof old.DetachedReferencePosition>);
use_old_VariableDeclaration_DetachedReferencePosition(
    get_current_VariableDeclaration_DetachedReferencePosition());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_Dictionary": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_Dictionary():
    TypeOnly<old.Dictionary<any,any>>;
declare function use_current_InterfaceDeclaration_Dictionary(
    use: TypeOnly<current.Dictionary<any,any>>);
use_current_InterfaceDeclaration_Dictionary(
    get_old_InterfaceDeclaration_Dictionary());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_Dictionary": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_Dictionary():
    TypeOnly<current.Dictionary<any,any>>;
declare function use_old_InterfaceDeclaration_Dictionary(
    use: TypeOnly<old.Dictionary<any,any>>);
use_old_InterfaceDeclaration_Dictionary(
    get_current_InterfaceDeclaration_Dictionary());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_extend": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_extend():
    TypeOnly<typeof old.extend>;
declare function use_current_FunctionDeclaration_extend(
    use: TypeOnly<typeof current.extend>);
use_current_FunctionDeclaration_extend(
    get_old_FunctionDeclaration_extend());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_extend": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_extend():
    TypeOnly<typeof current.extend>;
declare function use_old_FunctionDeclaration_extend(
    use: TypeOnly<typeof old.extend>);
use_old_FunctionDeclaration_extend(
    get_current_FunctionDeclaration_extend());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_extendIfUndefined": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_extendIfUndefined():
    TypeOnly<typeof old.extendIfUndefined>;
declare function use_current_FunctionDeclaration_extendIfUndefined(
    use: TypeOnly<typeof current.extendIfUndefined>);
use_current_FunctionDeclaration_extendIfUndefined(
    get_old_FunctionDeclaration_extendIfUndefined());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_extendIfUndefined": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_extendIfUndefined():
    TypeOnly<typeof current.extendIfUndefined>;
declare function use_old_FunctionDeclaration_extendIfUndefined(
    use: TypeOnly<typeof old.extendIfUndefined>);
use_old_FunctionDeclaration_extendIfUndefined(
    get_current_FunctionDeclaration_extendIfUndefined());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Heap": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Heap():
    TypeOnly<old.Heap<any>>;
declare function use_current_ClassDeclaration_Heap(
    use: TypeOnly<current.Heap<any>>);
use_current_ClassDeclaration_Heap(
    get_old_ClassDeclaration_Heap());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Heap": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Heap():
    TypeOnly<current.Heap<any>>;
declare function use_old_ClassDeclaration_Heap(
    use: TypeOnly<old.Heap<any>>);
use_old_ClassDeclaration_Heap(
    get_current_ClassDeclaration_Heap());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICombiningOp": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICombiningOp():
    TypeOnly<old.ICombiningOp>;
declare function use_current_InterfaceDeclaration_ICombiningOp(
    use: TypeOnly<current.ICombiningOp>);
use_current_InterfaceDeclaration_ICombiningOp(
    get_old_InterfaceDeclaration_ICombiningOp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICombiningOp": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICombiningOp():
    TypeOnly<current.ICombiningOp>;
declare function use_old_InterfaceDeclaration_ICombiningOp(
    use: TypeOnly<old.ICombiningOp>);
use_old_InterfaceDeclaration_ICombiningOp(
    get_current_InterfaceDeclaration_ICombiningOp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConsensusInfo": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConsensusInfo():
    TypeOnly<old.IConsensusInfo>;
declare function use_current_InterfaceDeclaration_IConsensusInfo(
    use: TypeOnly<current.IConsensusInfo>);
use_current_InterfaceDeclaration_IConsensusInfo(
    get_old_InterfaceDeclaration_IConsensusInfo());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConsensusInfo": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConsensusInfo():
    TypeOnly<current.IConsensusInfo>;
declare function use_old_InterfaceDeclaration_IConsensusInfo(
    use: TypeOnly<old.IConsensusInfo>);
use_old_InterfaceDeclaration_IConsensusInfo(
    get_current_InterfaceDeclaration_IConsensusInfo());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConsensusValue": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConsensusValue():
    TypeOnly<old.IConsensusValue>;
declare function use_current_InterfaceDeclaration_IConsensusValue(
    use: TypeOnly<current.IConsensusValue>);
use_current_InterfaceDeclaration_IConsensusValue(
    get_old_InterfaceDeclaration_IConsensusValue());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConsensusValue": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConsensusValue():
    TypeOnly<current.IConsensusValue>;
declare function use_old_InterfaceDeclaration_IConsensusValue(
    use: TypeOnly<old.IConsensusValue>);
use_old_InterfaceDeclaration_IConsensusValue(
    get_current_InterfaceDeclaration_IConsensusValue());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHierBlock": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IHierBlock():
    TypeOnly<old.IHierBlock>;
declare function use_current_InterfaceDeclaration_IHierBlock(
    use: TypeOnly<current.IHierBlock>);
use_current_InterfaceDeclaration_IHierBlock(
    get_old_InterfaceDeclaration_IHierBlock());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHierBlock": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IHierBlock():
    TypeOnly<current.IHierBlock>;
declare function use_old_InterfaceDeclaration_IHierBlock(
    use: TypeOnly<old.IHierBlock>);
use_old_InterfaceDeclaration_IHierBlock(
    get_current_InterfaceDeclaration_IHierBlock());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IIntegerRange": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IIntegerRange():
    TypeOnly<old.IIntegerRange>;
declare function use_current_InterfaceDeclaration_IIntegerRange(
    use: TypeOnly<current.IIntegerRange>);
use_current_InterfaceDeclaration_IIntegerRange(
    get_old_InterfaceDeclaration_IIntegerRange());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IIntegerRange": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IIntegerRange():
    TypeOnly<current.IIntegerRange>;
declare function use_old_InterfaceDeclaration_IIntegerRange(
    use: TypeOnly<old.IIntegerRange>);
use_old_InterfaceDeclaration_IIntegerRange(
    get_current_InterfaceDeclaration_IIntegerRange());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInterval": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInterval():
    TypeOnly<old.IInterval>;
declare function use_current_InterfaceDeclaration_IInterval(
    use: TypeOnly<current.IInterval>);
use_current_InterfaceDeclaration_IInterval(
    get_old_InterfaceDeclaration_IInterval());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInterval": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInterval():
    TypeOnly<current.IInterval>;
declare function use_old_InterfaceDeclaration_IInterval(
    use: TypeOnly<old.IInterval>);
use_old_InterfaceDeclaration_IInterval(
    get_current_InterfaceDeclaration_IInterval());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IJSONMarkerSegment": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IJSONMarkerSegment():
    TypeOnly<old.IJSONMarkerSegment>;
declare function use_current_InterfaceDeclaration_IJSONMarkerSegment(
    use: TypeOnly<current.IJSONMarkerSegment>);
use_current_InterfaceDeclaration_IJSONMarkerSegment(
    get_old_InterfaceDeclaration_IJSONMarkerSegment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IJSONMarkerSegment": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IJSONMarkerSegment():
    TypeOnly<current.IJSONMarkerSegment>;
declare function use_old_InterfaceDeclaration_IJSONMarkerSegment(
    use: TypeOnly<old.IJSONMarkerSegment>);
use_old_InterfaceDeclaration_IJSONMarkerSegment(
    get_current_InterfaceDeclaration_IJSONMarkerSegment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IJSONSegment": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IJSONSegment():
    TypeOnly<old.IJSONSegment>;
declare function use_current_InterfaceDeclaration_IJSONSegment(
    use: TypeOnly<current.IJSONSegment>);
use_current_InterfaceDeclaration_IJSONSegment(
    get_old_InterfaceDeclaration_IJSONSegment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IJSONSegment": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IJSONSegment():
    TypeOnly<current.IJSONSegment>;
declare function use_old_InterfaceDeclaration_IJSONSegment(
    use: TypeOnly<old.IJSONSegment>);
use_old_InterfaceDeclaration_IJSONSegment(
    get_current_InterfaceDeclaration_IJSONSegment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IJSONTextSegment": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IJSONTextSegment():
    TypeOnly<old.IJSONTextSegment>;
declare function use_current_InterfaceDeclaration_IJSONTextSegment(
    use: TypeOnly<current.IJSONTextSegment>);
use_current_InterfaceDeclaration_IJSONTextSegment(
    get_old_InterfaceDeclaration_IJSONTextSegment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IJSONTextSegment": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IJSONTextSegment():
    TypeOnly<current.IJSONTextSegment>;
declare function use_old_InterfaceDeclaration_IJSONTextSegment(
    use: TypeOnly<old.IJSONTextSegment>);
use_old_InterfaceDeclaration_IJSONTextSegment(
    get_current_InterfaceDeclaration_IJSONTextSegment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMarkerDef": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMarkerDef():
    TypeOnly<old.IMarkerDef>;
declare function use_current_InterfaceDeclaration_IMarkerDef(
    use: TypeOnly<current.IMarkerDef>);
use_current_InterfaceDeclaration_IMarkerDef(
    get_old_InterfaceDeclaration_IMarkerDef());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMarkerDef": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMarkerDef():
    TypeOnly<current.IMarkerDef>;
declare function use_old_InterfaceDeclaration_IMarkerDef(
    use: TypeOnly<old.IMarkerDef>);
use_old_InterfaceDeclaration_IMarkerDef(
    get_current_InterfaceDeclaration_IMarkerDef());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMarkerModifiedAction": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMarkerModifiedAction():
    TypeOnly<old.IMarkerModifiedAction>;
declare function use_current_InterfaceDeclaration_IMarkerModifiedAction(
    use: TypeOnly<current.IMarkerModifiedAction>);
use_current_InterfaceDeclaration_IMarkerModifiedAction(
    get_old_InterfaceDeclaration_IMarkerModifiedAction());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMarkerModifiedAction": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMarkerModifiedAction():
    TypeOnly<current.IMarkerModifiedAction>;
declare function use_old_InterfaceDeclaration_IMarkerModifiedAction(
    use: TypeOnly<old.IMarkerModifiedAction>);
use_old_InterfaceDeclaration_IMarkerModifiedAction(
    get_current_InterfaceDeclaration_IMarkerModifiedAction());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeBlock": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMergeBlock():
    TypeOnly<old.IMergeBlock>;
declare function use_current_InterfaceDeclaration_IMergeBlock(
    use: TypeOnly<current.IMergeBlock>);
use_current_InterfaceDeclaration_IMergeBlock(
    get_old_InterfaceDeclaration_IMergeBlock());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeBlock": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMergeBlock():
    TypeOnly<current.IMergeBlock>;
declare function use_old_InterfaceDeclaration_IMergeBlock(
    use: TypeOnly<old.IMergeBlock>);
use_old_InterfaceDeclaration_IMergeBlock(
    get_current_InterfaceDeclaration_IMergeBlock());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IMergeNode": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IMergeNode():
    TypeOnly<old.IMergeNode>;
declare function use_current_TypeAliasDeclaration_IMergeNode(
    use: TypeOnly<current.IMergeNode>);
use_current_TypeAliasDeclaration_IMergeNode(
    get_old_TypeAliasDeclaration_IMergeNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IMergeNode": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IMergeNode():
    TypeOnly<current.IMergeNode>;
declare function use_old_TypeAliasDeclaration_IMergeNode(
    use: TypeOnly<old.IMergeNode>);
use_old_TypeAliasDeclaration_IMergeNode(
    get_current_TypeAliasDeclaration_IMergeNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeNodeCommon": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMergeNodeCommon():
    TypeOnly<old.IMergeNodeCommon>;
declare function use_current_InterfaceDeclaration_IMergeNodeCommon(
    use: TypeOnly<current.IMergeNodeCommon>);
use_current_InterfaceDeclaration_IMergeNodeCommon(
    get_old_InterfaceDeclaration_IMergeNodeCommon());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeNodeCommon": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMergeNodeCommon():
    TypeOnly<current.IMergeNodeCommon>;
declare function use_old_InterfaceDeclaration_IMergeNodeCommon(
    use: TypeOnly<old.IMergeNodeCommon>);
use_old_InterfaceDeclaration_IMergeNodeCommon(
    get_current_InterfaceDeclaration_IMergeNodeCommon());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeAnnotateMsg": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMergeTreeAnnotateMsg():
    TypeOnly<old.IMergeTreeAnnotateMsg>;
declare function use_current_InterfaceDeclaration_IMergeTreeAnnotateMsg(
    use: TypeOnly<current.IMergeTreeAnnotateMsg>);
use_current_InterfaceDeclaration_IMergeTreeAnnotateMsg(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IMergeTreeAnnotateMsg());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeAnnotateMsg": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMergeTreeAnnotateMsg():
    TypeOnly<current.IMergeTreeAnnotateMsg>;
declare function use_old_InterfaceDeclaration_IMergeTreeAnnotateMsg(
    use: TypeOnly<old.IMergeTreeAnnotateMsg>);
use_old_InterfaceDeclaration_IMergeTreeAnnotateMsg(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IMergeTreeAnnotateMsg());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeClientSequenceArgs": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMergeTreeClientSequenceArgs():
    TypeOnly<old.IMergeTreeClientSequenceArgs>;
declare function use_current_InterfaceDeclaration_IMergeTreeClientSequenceArgs(
    use: TypeOnly<current.IMergeTreeClientSequenceArgs>);
use_current_InterfaceDeclaration_IMergeTreeClientSequenceArgs(
    get_old_InterfaceDeclaration_IMergeTreeClientSequenceArgs());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeClientSequenceArgs": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMergeTreeClientSequenceArgs():
    TypeOnly<current.IMergeTreeClientSequenceArgs>;
declare function use_old_InterfaceDeclaration_IMergeTreeClientSequenceArgs(
    use: TypeOnly<old.IMergeTreeClientSequenceArgs>);
use_old_InterfaceDeclaration_IMergeTreeClientSequenceArgs(
    get_current_InterfaceDeclaration_IMergeTreeClientSequenceArgs());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeDelta": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMergeTreeDelta():
    TypeOnly<old.IMergeTreeDelta>;
declare function use_current_InterfaceDeclaration_IMergeTreeDelta(
    use: TypeOnly<current.IMergeTreeDelta>);
use_current_InterfaceDeclaration_IMergeTreeDelta(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IMergeTreeDelta());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeDelta": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMergeTreeDelta():
    TypeOnly<current.IMergeTreeDelta>;
declare function use_old_InterfaceDeclaration_IMergeTreeDelta(
    use: TypeOnly<old.IMergeTreeDelta>);
use_old_InterfaceDeclaration_IMergeTreeDelta(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IMergeTreeDelta());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeDeltaCallbackArgs": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs():
    TypeOnly<old.IMergeTreeDeltaCallbackArgs>;
declare function use_current_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs(
    use: TypeOnly<current.IMergeTreeDeltaCallbackArgs>);
use_current_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeDeltaCallbackArgs": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs():
    TypeOnly<current.IMergeTreeDeltaCallbackArgs>;
declare function use_old_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs(
    use: TypeOnly<old.IMergeTreeDeltaCallbackArgs>);
use_old_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IMergeTreeDeltaOp": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IMergeTreeDeltaOp():
    TypeOnly<old.IMergeTreeDeltaOp>;
declare function use_current_TypeAliasDeclaration_IMergeTreeDeltaOp(
    use: TypeOnly<current.IMergeTreeDeltaOp>);
use_current_TypeAliasDeclaration_IMergeTreeDeltaOp(
    // @ts-expect-error compatibility expected to be broken
    get_old_TypeAliasDeclaration_IMergeTreeDeltaOp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IMergeTreeDeltaOp": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IMergeTreeDeltaOp():
    TypeOnly<current.IMergeTreeDeltaOp>;
declare function use_old_TypeAliasDeclaration_IMergeTreeDeltaOp(
    use: TypeOnly<old.IMergeTreeDeltaOp>);
use_old_TypeAliasDeclaration_IMergeTreeDeltaOp(
    // @ts-expect-error compatibility expected to be broken
    get_current_TypeAliasDeclaration_IMergeTreeDeltaOp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeDeltaOpArgs": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMergeTreeDeltaOpArgs():
    TypeOnly<old.IMergeTreeDeltaOpArgs>;
declare function use_current_InterfaceDeclaration_IMergeTreeDeltaOpArgs(
    use: TypeOnly<current.IMergeTreeDeltaOpArgs>);
use_current_InterfaceDeclaration_IMergeTreeDeltaOpArgs(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IMergeTreeDeltaOpArgs());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeDeltaOpArgs": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMergeTreeDeltaOpArgs():
    TypeOnly<current.IMergeTreeDeltaOpArgs>;
declare function use_old_InterfaceDeclaration_IMergeTreeDeltaOpArgs(
    use: TypeOnly<old.IMergeTreeDeltaOpArgs>);
use_old_InterfaceDeclaration_IMergeTreeDeltaOpArgs(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IMergeTreeDeltaOpArgs());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeGroupMsg": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMergeTreeGroupMsg():
    TypeOnly<old.IMergeTreeGroupMsg>;
declare function use_current_InterfaceDeclaration_IMergeTreeGroupMsg(
    use: TypeOnly<current.IMergeTreeGroupMsg>);
use_current_InterfaceDeclaration_IMergeTreeGroupMsg(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IMergeTreeGroupMsg());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeGroupMsg": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMergeTreeGroupMsg():
    TypeOnly<current.IMergeTreeGroupMsg>;
declare function use_old_InterfaceDeclaration_IMergeTreeGroupMsg(
    use: TypeOnly<old.IMergeTreeGroupMsg>);
use_old_InterfaceDeclaration_IMergeTreeGroupMsg(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IMergeTreeGroupMsg());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeInsertMsg": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMergeTreeInsertMsg():
    TypeOnly<old.IMergeTreeInsertMsg>;
declare function use_current_InterfaceDeclaration_IMergeTreeInsertMsg(
    use: TypeOnly<current.IMergeTreeInsertMsg>);
use_current_InterfaceDeclaration_IMergeTreeInsertMsg(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IMergeTreeInsertMsg());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeInsertMsg": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMergeTreeInsertMsg():
    TypeOnly<current.IMergeTreeInsertMsg>;
declare function use_old_InterfaceDeclaration_IMergeTreeInsertMsg(
    use: TypeOnly<old.IMergeTreeInsertMsg>);
use_old_InterfaceDeclaration_IMergeTreeInsertMsg(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IMergeTreeInsertMsg());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs():
    TypeOnly<old.IMergeTreeMaintenanceCallbackArgs>;
declare function use_current_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs(
    use: TypeOnly<current.IMergeTreeMaintenanceCallbackArgs>);
use_current_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs():
    TypeOnly<current.IMergeTreeMaintenanceCallbackArgs>;
declare function use_old_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs(
    use: TypeOnly<old.IMergeTreeMaintenanceCallbackArgs>);
use_old_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IMergeTreeOp": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IMergeTreeOp():
    TypeOnly<old.IMergeTreeOp>;
declare function use_current_TypeAliasDeclaration_IMergeTreeOp(
    use: TypeOnly<current.IMergeTreeOp>);
use_current_TypeAliasDeclaration_IMergeTreeOp(
    // @ts-expect-error compatibility expected to be broken
    get_old_TypeAliasDeclaration_IMergeTreeOp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IMergeTreeOp": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IMergeTreeOp():
    TypeOnly<current.IMergeTreeOp>;
declare function use_old_TypeAliasDeclaration_IMergeTreeOp(
    use: TypeOnly<old.IMergeTreeOp>);
use_old_TypeAliasDeclaration_IMergeTreeOp(
    // @ts-expect-error compatibility expected to be broken
    get_current_TypeAliasDeclaration_IMergeTreeOp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeRemoveMsg": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMergeTreeRemoveMsg():
    TypeOnly<old.IMergeTreeRemoveMsg>;
declare function use_current_InterfaceDeclaration_IMergeTreeRemoveMsg(
    use: TypeOnly<current.IMergeTreeRemoveMsg>);
use_current_InterfaceDeclaration_IMergeTreeRemoveMsg(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IMergeTreeRemoveMsg());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeRemoveMsg": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMergeTreeRemoveMsg():
    TypeOnly<current.IMergeTreeRemoveMsg>;
declare function use_old_InterfaceDeclaration_IMergeTreeRemoveMsg(
    use: TypeOnly<old.IMergeTreeRemoveMsg>);
use_old_InterfaceDeclaration_IMergeTreeRemoveMsg(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IMergeTreeRemoveMsg());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeSegmentDelta": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMergeTreeSegmentDelta():
    TypeOnly<old.IMergeTreeSegmentDelta>;
declare function use_current_InterfaceDeclaration_IMergeTreeSegmentDelta(
    use: TypeOnly<current.IMergeTreeSegmentDelta>);
use_current_InterfaceDeclaration_IMergeTreeSegmentDelta(
    get_old_InterfaceDeclaration_IMergeTreeSegmentDelta());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMergeTreeSegmentDelta": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMergeTreeSegmentDelta():
    TypeOnly<current.IMergeTreeSegmentDelta>;
declare function use_old_InterfaceDeclaration_IMergeTreeSegmentDelta(
    use: TypeOnly<old.IMergeTreeSegmentDelta>);
use_old_InterfaceDeclaration_IMergeTreeSegmentDelta(
    get_current_InterfaceDeclaration_IMergeTreeSegmentDelta());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IncrementalBlockAction": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IncrementalBlockAction():
    TypeOnly<old.IncrementalBlockAction<any>>;
declare function use_current_InterfaceDeclaration_IncrementalBlockAction(
    use: TypeOnly<current.IncrementalBlockAction<any>>);
use_current_InterfaceDeclaration_IncrementalBlockAction(
    get_old_InterfaceDeclaration_IncrementalBlockAction());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IncrementalBlockAction": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IncrementalBlockAction():
    TypeOnly<current.IncrementalBlockAction<any>>;
declare function use_old_InterfaceDeclaration_IncrementalBlockAction(
    use: TypeOnly<old.IncrementalBlockAction<any>>);
use_old_InterfaceDeclaration_IncrementalBlockAction(
    get_current_InterfaceDeclaration_IncrementalBlockAction());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_IncrementalExecOp": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_IncrementalExecOp():
    TypeOnly<old.IncrementalExecOp>;
declare function use_current_EnumDeclaration_IncrementalExecOp(
    use: TypeOnly<current.IncrementalExecOp>);
use_current_EnumDeclaration_IncrementalExecOp(
    get_old_EnumDeclaration_IncrementalExecOp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_IncrementalExecOp": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_IncrementalExecOp():
    TypeOnly<current.IncrementalExecOp>;
declare function use_old_EnumDeclaration_IncrementalExecOp(
    use: TypeOnly<old.IncrementalExecOp>);
use_old_EnumDeclaration_IncrementalExecOp(
    get_current_EnumDeclaration_IncrementalExecOp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_IncrementalMapState": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_IncrementalMapState():
    TypeOnly<old.IncrementalMapState<any>>;
declare function use_current_ClassDeclaration_IncrementalMapState(
    use: TypeOnly<current.IncrementalMapState<any>>);
use_current_ClassDeclaration_IncrementalMapState(
    get_old_ClassDeclaration_IncrementalMapState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_IncrementalMapState": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_IncrementalMapState():
    TypeOnly<current.IncrementalMapState<any>>;
declare function use_old_ClassDeclaration_IncrementalMapState(
    use: TypeOnly<old.IncrementalMapState<any>>);
use_old_ClassDeclaration_IncrementalMapState(
    get_current_ClassDeclaration_IncrementalMapState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IncrementalSegmentAction": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IncrementalSegmentAction():
    TypeOnly<old.IncrementalSegmentAction<any>>;
declare function use_current_InterfaceDeclaration_IncrementalSegmentAction(
    use: TypeOnly<current.IncrementalSegmentAction<any>>);
use_current_InterfaceDeclaration_IncrementalSegmentAction(
    get_old_InterfaceDeclaration_IncrementalSegmentAction());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IncrementalSegmentAction": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IncrementalSegmentAction():
    TypeOnly<current.IncrementalSegmentAction<any>>;
declare function use_old_InterfaceDeclaration_IncrementalSegmentAction(
    use: TypeOnly<old.IncrementalSegmentAction<any>>);
use_old_InterfaceDeclaration_IncrementalSegmentAction(
    get_current_InterfaceDeclaration_IncrementalSegmentAction());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IncrementalSegmentActions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IncrementalSegmentActions():
    TypeOnly<old.IncrementalSegmentActions<any>>;
declare function use_current_InterfaceDeclaration_IncrementalSegmentActions(
    use: TypeOnly<current.IncrementalSegmentActions<any>>);
use_current_InterfaceDeclaration_IncrementalSegmentActions(
    get_old_InterfaceDeclaration_IncrementalSegmentActions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IncrementalSegmentActions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IncrementalSegmentActions():
    TypeOnly<current.IncrementalSegmentActions<any>>;
declare function use_old_InterfaceDeclaration_IncrementalSegmentActions(
    use: TypeOnly<old.IncrementalSegmentActions<any>>);
use_old_InterfaceDeclaration_IncrementalSegmentActions(
    get_current_InterfaceDeclaration_IncrementalSegmentActions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_InsertContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_InsertContext():
    TypeOnly<old.InsertContext>;
declare function use_current_InterfaceDeclaration_InsertContext(
    use: TypeOnly<current.InsertContext>);
use_current_InterfaceDeclaration_InsertContext(
    get_old_InterfaceDeclaration_InsertContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_InsertContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_InsertContext():
    TypeOnly<current.InsertContext>;
declare function use_old_InterfaceDeclaration_InsertContext(
    use: TypeOnly<old.InsertContext>);
use_old_InterfaceDeclaration_InsertContext(
    get_current_InterfaceDeclaration_InsertContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_integerRangeToString": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_integerRangeToString():
    TypeOnly<typeof old.integerRangeToString>;
declare function use_current_VariableDeclaration_integerRangeToString(
    use: TypeOnly<typeof current.integerRangeToString>);
use_current_VariableDeclaration_integerRangeToString(
    get_old_VariableDeclaration_integerRangeToString());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_integerRangeToString": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_integerRangeToString():
    TypeOnly<typeof current.integerRangeToString>;
declare function use_old_VariableDeclaration_integerRangeToString(
    use: TypeOnly<typeof old.integerRangeToString>);
use_old_VariableDeclaration_integerRangeToString(
    get_current_VariableDeclaration_integerRangeToString());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_internedSpaces": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_internedSpaces():
    TypeOnly<typeof old.internedSpaces>;
declare function use_current_FunctionDeclaration_internedSpaces(
    use: TypeOnly<typeof current.internedSpaces>);
use_current_FunctionDeclaration_internedSpaces(
    get_old_FunctionDeclaration_internedSpaces());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_internedSpaces": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_internedSpaces():
    TypeOnly<typeof current.internedSpaces>;
declare function use_old_FunctionDeclaration_internedSpaces(
    use: TypeOnly<typeof old.internedSpaces>);
use_old_FunctionDeclaration_internedSpaces(
    get_current_FunctionDeclaration_internedSpaces());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IntervalConflictResolver": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IntervalConflictResolver():
    TypeOnly<old.IntervalConflictResolver<any>>;
declare function use_current_TypeAliasDeclaration_IntervalConflictResolver(
    use: TypeOnly<current.IntervalConflictResolver<any>>);
use_current_TypeAliasDeclaration_IntervalConflictResolver(
    get_old_TypeAliasDeclaration_IntervalConflictResolver());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IntervalConflictResolver": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IntervalConflictResolver():
    TypeOnly<current.IntervalConflictResolver<any>>;
declare function use_old_TypeAliasDeclaration_IntervalConflictResolver(
    use: TypeOnly<old.IntervalConflictResolver<any>>);
use_old_TypeAliasDeclaration_IntervalConflictResolver(
    get_current_TypeAliasDeclaration_IntervalConflictResolver());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IntervalNode": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IntervalNode():
    TypeOnly<old.IntervalNode<any>>;
declare function use_current_TypeAliasDeclaration_IntervalNode(
    use: TypeOnly<current.IntervalNode<any>>);
use_current_TypeAliasDeclaration_IntervalNode(
    // @ts-expect-error compatibility expected to be broken
    get_old_TypeAliasDeclaration_IntervalNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IntervalNode": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IntervalNode():
    TypeOnly<current.IntervalNode<any>>;
declare function use_old_TypeAliasDeclaration_IntervalNode(
    use: TypeOnly<old.IntervalNode<any>>);
use_old_TypeAliasDeclaration_IntervalNode(
    // @ts-expect-error compatibility expected to be broken
    get_current_TypeAliasDeclaration_IntervalNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_IntervalTree": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_IntervalTree():
    TypeOnly<old.IntervalTree<any>>;
declare function use_current_ClassDeclaration_IntervalTree(
    use: TypeOnly<current.IntervalTree<any>>);
use_current_ClassDeclaration_IntervalTree(
    get_old_ClassDeclaration_IntervalTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_IntervalTree": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_IntervalTree():
    TypeOnly<current.IntervalTree<any>>;
declare function use_old_ClassDeclaration_IntervalTree(
    use: TypeOnly<old.IntervalTree<any>>);
use_old_ClassDeclaration_IntervalTree(
    get_current_ClassDeclaration_IntervalTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRBAugmentation": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRBAugmentation():
    TypeOnly<old.IRBAugmentation<any,any>>;
declare function use_current_InterfaceDeclaration_IRBAugmentation(
    use: TypeOnly<current.IRBAugmentation<any,any>>);
use_current_InterfaceDeclaration_IRBAugmentation(
    get_old_InterfaceDeclaration_IRBAugmentation());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRBAugmentation": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRBAugmentation():
    TypeOnly<current.IRBAugmentation<any,any>>;
declare function use_old_InterfaceDeclaration_IRBAugmentation(
    use: TypeOnly<old.IRBAugmentation<any,any>>);
use_old_InterfaceDeclaration_IRBAugmentation(
    get_current_InterfaceDeclaration_IRBAugmentation());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRBMatcher": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRBMatcher():
    TypeOnly<old.IRBMatcher<any,any>>;
declare function use_current_InterfaceDeclaration_IRBMatcher(
    use: TypeOnly<current.IRBMatcher<any,any>>);
use_current_InterfaceDeclaration_IRBMatcher(
    get_old_InterfaceDeclaration_IRBMatcher());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRBMatcher": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRBMatcher():
    TypeOnly<current.IRBMatcher<any,any>>;
declare function use_old_InterfaceDeclaration_IRBMatcher(
    use: TypeOnly<old.IRBMatcher<any,any>>);
use_old_InterfaceDeclaration_IRBMatcher(
    get_current_InterfaceDeclaration_IRBMatcher());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRelativePosition": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRelativePosition():
    TypeOnly<old.IRelativePosition>;
declare function use_current_InterfaceDeclaration_IRelativePosition(
    use: TypeOnly<current.IRelativePosition>);
use_current_InterfaceDeclaration_IRelativePosition(
    get_old_InterfaceDeclaration_IRelativePosition());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRelativePosition": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRelativePosition():
    TypeOnly<current.IRelativePosition>;
declare function use_old_InterfaceDeclaration_IRelativePosition(
    use: TypeOnly<old.IRelativePosition>);
use_old_InterfaceDeclaration_IRelativePosition(
    get_current_InterfaceDeclaration_IRelativePosition());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRemovalInfo": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRemovalInfo():
    TypeOnly<old.IRemovalInfo>;
declare function use_current_InterfaceDeclaration_IRemovalInfo(
    use: TypeOnly<current.IRemovalInfo>);
use_current_InterfaceDeclaration_IRemovalInfo(
    get_old_InterfaceDeclaration_IRemovalInfo());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRemovalInfo": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRemovalInfo():
    TypeOnly<current.IRemovalInfo>;
declare function use_old_InterfaceDeclaration_IRemovalInfo(
    use: TypeOnly<old.IRemovalInfo>);
use_old_InterfaceDeclaration_IRemovalInfo(
    get_current_InterfaceDeclaration_IRemovalInfo());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISegment": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISegment():
    TypeOnly<old.ISegment>;
declare function use_current_InterfaceDeclaration_ISegment(
    use: TypeOnly<current.ISegment>);
use_current_InterfaceDeclaration_ISegment(
    get_old_InterfaceDeclaration_ISegment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISegment": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISegment():
    TypeOnly<current.ISegment>;
declare function use_old_InterfaceDeclaration_ISegment(
    use: TypeOnly<old.ISegment>);
use_old_InterfaceDeclaration_ISegment(
    get_current_InterfaceDeclaration_ISegment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISegmentAction": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISegmentAction():
    TypeOnly<old.ISegmentAction<any>>;
declare function use_current_InterfaceDeclaration_ISegmentAction(
    use: TypeOnly<current.ISegmentAction<any>>);
use_current_InterfaceDeclaration_ISegmentAction(
    get_old_InterfaceDeclaration_ISegmentAction());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISegmentAction": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISegmentAction():
    TypeOnly<current.ISegmentAction<any>>;
declare function use_old_InterfaceDeclaration_ISegmentAction(
    use: TypeOnly<old.ISegmentAction<any>>);
use_old_InterfaceDeclaration_ISegmentAction(
    get_current_InterfaceDeclaration_ISegmentAction());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISegmentChanges": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISegmentChanges():
    TypeOnly<old.ISegmentChanges>;
declare function use_current_InterfaceDeclaration_ISegmentChanges(
    use: TypeOnly<current.ISegmentChanges>);
use_current_InterfaceDeclaration_ISegmentChanges(
    get_old_InterfaceDeclaration_ISegmentChanges());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISegmentChanges": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISegmentChanges():
    TypeOnly<current.ISegmentChanges>;
declare function use_old_InterfaceDeclaration_ISegmentChanges(
    use: TypeOnly<old.ISegmentChanges>);
use_old_InterfaceDeclaration_ISegmentChanges(
    get_current_InterfaceDeclaration_ISegmentChanges());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_KeyComparer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_KeyComparer():
    TypeOnly<old.KeyComparer<any>>;
declare function use_current_InterfaceDeclaration_KeyComparer(
    use: TypeOnly<current.KeyComparer<any>>);
use_current_InterfaceDeclaration_KeyComparer(
    get_old_InterfaceDeclaration_KeyComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_KeyComparer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_KeyComparer():
    TypeOnly<current.KeyComparer<any>>;
declare function use_old_InterfaceDeclaration_KeyComparer(
    use: TypeOnly<old.KeyComparer<any>>);
use_old_InterfaceDeclaration_KeyComparer(
    get_current_InterfaceDeclaration_KeyComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_List": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_List():
    TypeOnly<old.List<any>>;
declare function use_current_ClassDeclaration_List(
    use: TypeOnly<current.List<any>>);
use_current_ClassDeclaration_List(
    get_old_ClassDeclaration_List());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_List": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_List():
    TypeOnly<current.List<any>>;
declare function use_old_ClassDeclaration_List(
    use: TypeOnly<old.List<any>>);
use_old_ClassDeclaration_List(
    get_current_ClassDeclaration_List());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ListMakeHead": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_ListMakeHead():
    TypeOnly<typeof old.ListMakeHead>;
declare function use_current_FunctionDeclaration_ListMakeHead(
    use: TypeOnly<typeof current.ListMakeHead>);
use_current_FunctionDeclaration_ListMakeHead(
    get_old_FunctionDeclaration_ListMakeHead());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ListMakeHead": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_ListMakeHead():
    TypeOnly<typeof current.ListMakeHead>;
declare function use_old_FunctionDeclaration_ListMakeHead(
    use: TypeOnly<typeof old.ListMakeHead>);
use_old_FunctionDeclaration_ListMakeHead(
    get_current_FunctionDeclaration_ListMakeHead());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ListRemoveEntry": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_ListRemoveEntry():
    TypeOnly<typeof old.ListRemoveEntry>;
declare function use_current_FunctionDeclaration_ListRemoveEntry(
    use: TypeOnly<typeof current.ListRemoveEntry>);
use_current_FunctionDeclaration_ListRemoveEntry(
    get_old_FunctionDeclaration_ListRemoveEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ListRemoveEntry": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_ListRemoveEntry():
    TypeOnly<typeof current.ListRemoveEntry>;
declare function use_old_FunctionDeclaration_ListRemoveEntry(
    use: TypeOnly<typeof old.ListRemoveEntry>);
use_old_FunctionDeclaration_ListRemoveEntry(
    get_current_FunctionDeclaration_ListRemoveEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_LocalClientId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_LocalClientId():
    TypeOnly<typeof old.LocalClientId>;
declare function use_current_VariableDeclaration_LocalClientId(
    use: TypeOnly<typeof current.LocalClientId>);
use_current_VariableDeclaration_LocalClientId(
    get_old_VariableDeclaration_LocalClientId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_LocalClientId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_LocalClientId():
    TypeOnly<typeof current.LocalClientId>;
declare function use_old_VariableDeclaration_LocalClientId(
    use: TypeOnly<typeof old.LocalClientId>);
use_old_VariableDeclaration_LocalClientId(
    get_current_VariableDeclaration_LocalClientId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LocalReference": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_LocalReference():
    TypeOnly<old.LocalReference>;
declare function use_current_ClassDeclaration_LocalReference(
    use: TypeOnly<current.LocalReference>);
use_current_ClassDeclaration_LocalReference(
    get_old_ClassDeclaration_LocalReference());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LocalReference": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_LocalReference():
    TypeOnly<current.LocalReference>;
declare function use_old_ClassDeclaration_LocalReference(
    use: TypeOnly<old.LocalReference>);
use_old_ClassDeclaration_LocalReference(
    get_current_ClassDeclaration_LocalReference());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LocalReferenceCollection": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_LocalReferenceCollection():
    TypeOnly<old.LocalReferenceCollection>;
declare function use_current_ClassDeclaration_LocalReferenceCollection(
    use: TypeOnly<current.LocalReferenceCollection>);
use_current_ClassDeclaration_LocalReferenceCollection(
    get_old_ClassDeclaration_LocalReferenceCollection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LocalReferenceCollection": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_LocalReferenceCollection():
    TypeOnly<current.LocalReferenceCollection>;
declare function use_old_ClassDeclaration_LocalReferenceCollection(
    use: TypeOnly<old.LocalReferenceCollection>);
use_old_ClassDeclaration_LocalReferenceCollection(
    get_current_ClassDeclaration_LocalReferenceCollection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_LocalReferenceMapper": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_LocalReferenceMapper():
    TypeOnly<old.LocalReferenceMapper>;
declare function use_current_TypeAliasDeclaration_LocalReferenceMapper(
    use: TypeOnly<current.LocalReferenceMapper>);
use_current_TypeAliasDeclaration_LocalReferenceMapper(
    get_old_TypeAliasDeclaration_LocalReferenceMapper());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_LocalReferenceMapper": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_LocalReferenceMapper():
    TypeOnly<current.LocalReferenceMapper>;
declare function use_old_TypeAliasDeclaration_LocalReferenceMapper(
    use: TypeOnly<old.LocalReferenceMapper>);
use_old_TypeAliasDeclaration_LocalReferenceMapper(
    get_current_TypeAliasDeclaration_LocalReferenceMapper());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_LRUSegment": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_LRUSegment():
    TypeOnly<old.LRUSegment>;
declare function use_current_InterfaceDeclaration_LRUSegment(
    use: TypeOnly<current.LRUSegment>);
use_current_InterfaceDeclaration_LRUSegment(
    get_old_InterfaceDeclaration_LRUSegment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_LRUSegment": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_LRUSegment():
    TypeOnly<current.LRUSegment>;
declare function use_old_InterfaceDeclaration_LRUSegment(
    use: TypeOnly<old.LRUSegment>);
use_old_InterfaceDeclaration_LRUSegment(
    get_current_InterfaceDeclaration_LRUSegment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_MapLike": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_MapLike():
    TypeOnly<old.MapLike<any>>;
declare function use_current_InterfaceDeclaration_MapLike(
    use: TypeOnly<current.MapLike<any>>);
use_current_InterfaceDeclaration_MapLike(
    get_old_InterfaceDeclaration_MapLike());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_MapLike": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_MapLike():
    TypeOnly<current.MapLike<any>>;
declare function use_old_InterfaceDeclaration_MapLike(
    use: TypeOnly<old.MapLike<any>>);
use_old_InterfaceDeclaration_MapLike(
    get_current_InterfaceDeclaration_MapLike());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Marker": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Marker():
    TypeOnly<old.Marker>;
declare function use_current_ClassDeclaration_Marker(
    use: TypeOnly<current.Marker>);
use_current_ClassDeclaration_Marker(
    get_old_ClassDeclaration_Marker());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Marker": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Marker():
    TypeOnly<current.Marker>;
declare function use_old_ClassDeclaration_Marker(
    use: TypeOnly<old.Marker>);
use_old_ClassDeclaration_Marker(
    get_current_ClassDeclaration_Marker());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_matchProperties": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_matchProperties():
    TypeOnly<typeof old.matchProperties>;
declare function use_current_FunctionDeclaration_matchProperties(
    use: TypeOnly<typeof current.matchProperties>);
use_current_FunctionDeclaration_matchProperties(
    get_old_FunctionDeclaration_matchProperties());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_matchProperties": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_matchProperties():
    TypeOnly<typeof current.matchProperties>;
declare function use_old_FunctionDeclaration_matchProperties(
    use: TypeOnly<typeof old.matchProperties>);
use_old_FunctionDeclaration_matchProperties(
    get_current_FunctionDeclaration_matchProperties());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_MaxNodesInBlock": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_MaxNodesInBlock():
    TypeOnly<typeof old.MaxNodesInBlock>;
declare function use_current_VariableDeclaration_MaxNodesInBlock(
    use: TypeOnly<typeof current.MaxNodesInBlock>);
use_current_VariableDeclaration_MaxNodesInBlock(
    get_old_VariableDeclaration_MaxNodesInBlock());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_MaxNodesInBlock": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_MaxNodesInBlock():
    TypeOnly<typeof current.MaxNodesInBlock>;
declare function use_old_VariableDeclaration_MaxNodesInBlock(
    use: TypeOnly<typeof old.MaxNodesInBlock>);
use_old_VariableDeclaration_MaxNodesInBlock(
    get_current_VariableDeclaration_MaxNodesInBlock());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_maxReferencePosition": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_maxReferencePosition():
    TypeOnly<typeof old.maxReferencePosition>;
declare function use_current_FunctionDeclaration_maxReferencePosition(
    use: TypeOnly<typeof current.maxReferencePosition>);
use_current_FunctionDeclaration_maxReferencePosition(
    get_old_FunctionDeclaration_maxReferencePosition());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_maxReferencePosition": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_maxReferencePosition():
    TypeOnly<typeof current.maxReferencePosition>;
declare function use_old_FunctionDeclaration_maxReferencePosition(
    use: TypeOnly<typeof old.maxReferencePosition>);
use_old_FunctionDeclaration_maxReferencePosition(
    get_current_FunctionDeclaration_maxReferencePosition());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MergeBlock": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MergeBlock():
    TypeOnly<old.MergeBlock>;
declare function use_current_ClassDeclaration_MergeBlock(
    use: TypeOnly<current.MergeBlock>);
use_current_ClassDeclaration_MergeBlock(
    get_old_ClassDeclaration_MergeBlock());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MergeBlock": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MergeBlock():
    TypeOnly<current.MergeBlock>;
declare function use_old_ClassDeclaration_MergeBlock(
    use: TypeOnly<old.MergeBlock>);
use_old_ClassDeclaration_MergeBlock(
    get_current_ClassDeclaration_MergeBlock());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MergeNode": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MergeNode():
    TypeOnly<old.MergeNode>;
declare function use_current_ClassDeclaration_MergeNode(
    use: TypeOnly<current.MergeNode>);
use_current_ClassDeclaration_MergeNode(
    get_old_ClassDeclaration_MergeNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MergeNode": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MergeNode():
    TypeOnly<current.MergeNode>;
declare function use_old_ClassDeclaration_MergeNode(
    use: TypeOnly<old.MergeNode>);
use_old_ClassDeclaration_MergeNode(
    get_current_ClassDeclaration_MergeNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MergeTree": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MergeTree():
    TypeOnly<old.MergeTree>;
declare function use_current_ClassDeclaration_MergeTree(
    use: TypeOnly<current.MergeTree>);
use_current_ClassDeclaration_MergeTree(
    get_old_ClassDeclaration_MergeTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MergeTree": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MergeTree():
    TypeOnly<current.MergeTree>;
declare function use_old_ClassDeclaration_MergeTree(
    use: TypeOnly<old.MergeTree>);
use_old_ClassDeclaration_MergeTree(
    get_current_ClassDeclaration_MergeTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_MergeTreeDeltaCallback": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_MergeTreeDeltaCallback():
    TypeOnly<old.MergeTreeDeltaCallback>;
declare function use_current_TypeAliasDeclaration_MergeTreeDeltaCallback(
    use: TypeOnly<current.MergeTreeDeltaCallback>);
use_current_TypeAliasDeclaration_MergeTreeDeltaCallback(
    get_old_TypeAliasDeclaration_MergeTreeDeltaCallback());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_MergeTreeDeltaCallback": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_MergeTreeDeltaCallback():
    TypeOnly<current.MergeTreeDeltaCallback>;
declare function use_old_TypeAliasDeclaration_MergeTreeDeltaCallback(
    use: TypeOnly<old.MergeTreeDeltaCallback>);
use_old_TypeAliasDeclaration_MergeTreeDeltaCallback(
    get_current_TypeAliasDeclaration_MergeTreeDeltaCallback());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_MergeTreeDeltaOperationType": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_MergeTreeDeltaOperationType():
    TypeOnly<old.MergeTreeDeltaOperationType>;
declare function use_current_TypeAliasDeclaration_MergeTreeDeltaOperationType(
    use: TypeOnly<current.MergeTreeDeltaOperationType>);
use_current_TypeAliasDeclaration_MergeTreeDeltaOperationType(
    // @ts-expect-error compatibility expected to be broken
    get_old_TypeAliasDeclaration_MergeTreeDeltaOperationType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_MergeTreeDeltaOperationType": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_MergeTreeDeltaOperationType():
    TypeOnly<current.MergeTreeDeltaOperationType>;
declare function use_old_TypeAliasDeclaration_MergeTreeDeltaOperationType(
    use: TypeOnly<old.MergeTreeDeltaOperationType>);
use_old_TypeAliasDeclaration_MergeTreeDeltaOperationType(
    // @ts-expect-error compatibility expected to be broken
    get_current_TypeAliasDeclaration_MergeTreeDeltaOperationType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_MergeTreeDeltaOperationTypes": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_MergeTreeDeltaOperationTypes():
    TypeOnly<old.MergeTreeDeltaOperationTypes>;
declare function use_current_TypeAliasDeclaration_MergeTreeDeltaOperationTypes(
    use: TypeOnly<current.MergeTreeDeltaOperationTypes>);
use_current_TypeAliasDeclaration_MergeTreeDeltaOperationTypes(
    // @ts-expect-error compatibility expected to be broken
    get_old_TypeAliasDeclaration_MergeTreeDeltaOperationTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_MergeTreeDeltaOperationTypes": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_MergeTreeDeltaOperationTypes():
    TypeOnly<current.MergeTreeDeltaOperationTypes>;
declare function use_old_TypeAliasDeclaration_MergeTreeDeltaOperationTypes(
    use: TypeOnly<old.MergeTreeDeltaOperationTypes>);
use_old_TypeAliasDeclaration_MergeTreeDeltaOperationTypes(
    // @ts-expect-error compatibility expected to be broken
    get_current_TypeAliasDeclaration_MergeTreeDeltaOperationTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_MergeTreeDeltaType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_MergeTreeDeltaType():
    TypeOnly<old.MergeTreeDeltaType>;
declare function use_current_EnumDeclaration_MergeTreeDeltaType(
    use: TypeOnly<current.MergeTreeDeltaType>);
use_current_EnumDeclaration_MergeTreeDeltaType(
    // @ts-expect-error compatibility expected to be broken
    get_old_EnumDeclaration_MergeTreeDeltaType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_MergeTreeDeltaType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_MergeTreeDeltaType():
    TypeOnly<current.MergeTreeDeltaType>;
declare function use_old_EnumDeclaration_MergeTreeDeltaType(
    use: TypeOnly<old.MergeTreeDeltaType>);
use_old_EnumDeclaration_MergeTreeDeltaType(
    // @ts-expect-error compatibility expected to be broken
    get_current_EnumDeclaration_MergeTreeDeltaType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_MergeTreeMaintenanceCallback": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_MergeTreeMaintenanceCallback():
    TypeOnly<old.MergeTreeMaintenanceCallback>;
declare function use_current_TypeAliasDeclaration_MergeTreeMaintenanceCallback(
    use: TypeOnly<current.MergeTreeMaintenanceCallback>);
use_current_TypeAliasDeclaration_MergeTreeMaintenanceCallback(
    get_old_TypeAliasDeclaration_MergeTreeMaintenanceCallback());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_MergeTreeMaintenanceCallback": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_MergeTreeMaintenanceCallback():
    TypeOnly<current.MergeTreeMaintenanceCallback>;
declare function use_old_TypeAliasDeclaration_MergeTreeMaintenanceCallback(
    use: TypeOnly<old.MergeTreeMaintenanceCallback>);
use_old_TypeAliasDeclaration_MergeTreeMaintenanceCallback(
    get_current_TypeAliasDeclaration_MergeTreeMaintenanceCallback());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_MergeTreeMaintenanceType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_MergeTreeMaintenanceType():
    TypeOnly<old.MergeTreeMaintenanceType>;
declare function use_current_EnumDeclaration_MergeTreeMaintenanceType(
    use: TypeOnly<current.MergeTreeMaintenanceType>);
use_current_EnumDeclaration_MergeTreeMaintenanceType(
    // @ts-expect-error compatibility expected to be broken
    get_old_EnumDeclaration_MergeTreeMaintenanceType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_MergeTreeMaintenanceType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_MergeTreeMaintenanceType():
    TypeOnly<current.MergeTreeMaintenanceType>;
declare function use_old_EnumDeclaration_MergeTreeMaintenanceType(
    use: TypeOnly<old.MergeTreeMaintenanceType>);
use_old_EnumDeclaration_MergeTreeMaintenanceType(
    // @ts-expect-error compatibility expected to be broken
    get_current_EnumDeclaration_MergeTreeMaintenanceType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_MergeTreeStats": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_MergeTreeStats():
    TypeOnly<old.MergeTreeStats>;
declare function use_current_InterfaceDeclaration_MergeTreeStats(
    use: TypeOnly<current.MergeTreeStats>);
use_current_InterfaceDeclaration_MergeTreeStats(
    get_old_InterfaceDeclaration_MergeTreeStats());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_MergeTreeStats": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_MergeTreeStats():
    TypeOnly<current.MergeTreeStats>;
declare function use_old_InterfaceDeclaration_MergeTreeStats(
    use: TypeOnly<old.MergeTreeStats>);
use_old_InterfaceDeclaration_MergeTreeStats(
    get_current_InterfaceDeclaration_MergeTreeStats());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MergeTreeTextHelper": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MergeTreeTextHelper():
    TypeOnly<old.MergeTreeTextHelper>;
declare function use_current_ClassDeclaration_MergeTreeTextHelper(
    use: TypeOnly<current.MergeTreeTextHelper>);
use_current_ClassDeclaration_MergeTreeTextHelper(
    get_old_ClassDeclaration_MergeTreeTextHelper());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MergeTreeTextHelper": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MergeTreeTextHelper():
    TypeOnly<current.MergeTreeTextHelper>;
declare function use_old_ClassDeclaration_MergeTreeTextHelper(
    use: TypeOnly<old.MergeTreeTextHelper>);
use_old_ClassDeclaration_MergeTreeTextHelper(
    get_current_ClassDeclaration_MergeTreeTextHelper());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_MinListener": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_MinListener():
    TypeOnly<old.MinListener>;
declare function use_current_InterfaceDeclaration_MinListener(
    use: TypeOnly<current.MinListener>);
use_current_InterfaceDeclaration_MinListener(
    get_old_InterfaceDeclaration_MinListener());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_MinListener": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_MinListener():
    TypeOnly<current.MinListener>;
declare function use_old_InterfaceDeclaration_MinListener(
    use: TypeOnly<old.MinListener>);
use_old_InterfaceDeclaration_MinListener(
    get_current_InterfaceDeclaration_MinListener());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_minReferencePosition": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_minReferencePosition():
    TypeOnly<typeof old.minReferencePosition>;
declare function use_current_FunctionDeclaration_minReferencePosition(
    use: TypeOnly<typeof current.minReferencePosition>);
use_current_FunctionDeclaration_minReferencePosition(
    get_old_FunctionDeclaration_minReferencePosition());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_minReferencePosition": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_minReferencePosition():
    TypeOnly<typeof current.minReferencePosition>;
declare function use_old_FunctionDeclaration_minReferencePosition(
    use: TypeOnly<typeof old.minReferencePosition>);
use_old_FunctionDeclaration_minReferencePosition(
    get_current_FunctionDeclaration_minReferencePosition());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_NodeAction": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_NodeAction():
    TypeOnly<old.NodeAction<any>>;
declare function use_current_InterfaceDeclaration_NodeAction(
    use: TypeOnly<current.NodeAction<any>>);
use_current_InterfaceDeclaration_NodeAction(
    get_old_InterfaceDeclaration_NodeAction());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_NodeAction": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_NodeAction():
    TypeOnly<current.NodeAction<any>>;
declare function use_old_InterfaceDeclaration_NodeAction(
    use: TypeOnly<old.NodeAction<any>>);
use_old_InterfaceDeclaration_NodeAction(
    get_current_InterfaceDeclaration_NodeAction());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_NonCollabClient": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_NonCollabClient():
    TypeOnly<typeof old.NonCollabClient>;
declare function use_current_VariableDeclaration_NonCollabClient(
    use: TypeOnly<typeof current.NonCollabClient>);
use_current_VariableDeclaration_NonCollabClient(
    get_old_VariableDeclaration_NonCollabClient());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_NonCollabClient": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_NonCollabClient():
    TypeOnly<typeof current.NonCollabClient>;
declare function use_old_VariableDeclaration_NonCollabClient(
    use: TypeOnly<typeof old.NonCollabClient>);
use_old_VariableDeclaration_NonCollabClient(
    get_current_VariableDeclaration_NonCollabClient());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ordinalToArray": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_ordinalToArray():
    TypeOnly<typeof old.ordinalToArray>;
declare function use_current_FunctionDeclaration_ordinalToArray(
    use: TypeOnly<typeof current.ordinalToArray>);
use_current_FunctionDeclaration_ordinalToArray(
    get_old_FunctionDeclaration_ordinalToArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ordinalToArray": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_ordinalToArray():
    TypeOnly<typeof current.ordinalToArray>;
declare function use_old_FunctionDeclaration_ordinalToArray(
    use: TypeOnly<typeof old.ordinalToArray>);
use_old_FunctionDeclaration_ordinalToArray(
    get_current_FunctionDeclaration_ordinalToArray());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PropertiesManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_PropertiesManager():
    TypeOnly<old.PropertiesManager>;
declare function use_current_ClassDeclaration_PropertiesManager(
    use: TypeOnly<current.PropertiesManager>);
use_current_ClassDeclaration_PropertiesManager(
    get_old_ClassDeclaration_PropertiesManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PropertiesManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_PropertiesManager():
    TypeOnly<current.PropertiesManager>;
declare function use_old_ClassDeclaration_PropertiesManager(
    use: TypeOnly<old.PropertiesManager>);
use_old_ClassDeclaration_PropertiesManager(
    get_current_ClassDeclaration_PropertiesManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_Property": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_Property():
    TypeOnly<old.Property<any,any>>;
declare function use_current_InterfaceDeclaration_Property(
    use: TypeOnly<current.Property<any,any>>);
use_current_InterfaceDeclaration_Property(
    get_old_InterfaceDeclaration_Property());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_Property": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_Property():
    TypeOnly<current.Property<any,any>>;
declare function use_old_InterfaceDeclaration_Property(
    use: TypeOnly<old.Property<any,any>>);
use_old_InterfaceDeclaration_Property(
    get_current_InterfaceDeclaration_Property());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_PropertyAction": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_PropertyAction():
    TypeOnly<old.PropertyAction<any,any>>;
declare function use_current_InterfaceDeclaration_PropertyAction(
    use: TypeOnly<current.PropertyAction<any,any>>);
use_current_InterfaceDeclaration_PropertyAction(
    get_old_InterfaceDeclaration_PropertyAction());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_PropertyAction": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_PropertyAction():
    TypeOnly<current.PropertyAction<any,any>>;
declare function use_old_InterfaceDeclaration_PropertyAction(
    use: TypeOnly<old.PropertyAction<any,any>>);
use_old_InterfaceDeclaration_PropertyAction(
    get_current_InterfaceDeclaration_PropertyAction());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_PropertySet": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_PropertySet():
    TypeOnly<old.PropertySet>;
declare function use_current_TypeAliasDeclaration_PropertySet(
    use: TypeOnly<current.PropertySet>);
use_current_TypeAliasDeclaration_PropertySet(
    get_old_TypeAliasDeclaration_PropertySet());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_PropertySet": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_PropertySet():
    TypeOnly<current.PropertySet>;
declare function use_old_TypeAliasDeclaration_PropertySet(
    use: TypeOnly<old.PropertySet>);
use_old_TypeAliasDeclaration_PropertySet(
    get_current_TypeAliasDeclaration_PropertySet());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ProxString": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ProxString():
    TypeOnly<old.ProxString<any>>;
declare function use_current_InterfaceDeclaration_ProxString(
    use: TypeOnly<current.ProxString<any>>);
use_current_InterfaceDeclaration_ProxString(
    get_old_InterfaceDeclaration_ProxString());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ProxString": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ProxString():
    TypeOnly<current.ProxString<any>>;
declare function use_old_InterfaceDeclaration_ProxString(
    use: TypeOnly<old.ProxString<any>>);
use_old_InterfaceDeclaration_ProxString(
    get_current_InterfaceDeclaration_ProxString());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_QProperty": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_QProperty():
    TypeOnly<old.QProperty<any,any>>;
declare function use_current_InterfaceDeclaration_QProperty(
    use: TypeOnly<current.QProperty<any,any>>);
use_current_InterfaceDeclaration_QProperty(
    get_old_InterfaceDeclaration_QProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_QProperty": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_QProperty():
    TypeOnly<current.QProperty<any,any>>;
declare function use_old_InterfaceDeclaration_QProperty(
    use: TypeOnly<old.QProperty<any,any>>);
use_old_InterfaceDeclaration_QProperty(
    get_current_InterfaceDeclaration_QProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_RangeStackMap": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_RangeStackMap():
    TypeOnly<old.RangeStackMap>;
declare function use_current_TypeAliasDeclaration_RangeStackMap(
    use: TypeOnly<current.RangeStackMap>);
use_current_TypeAliasDeclaration_RangeStackMap(
    get_old_TypeAliasDeclaration_RangeStackMap());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_RangeStackMap": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_RangeStackMap():
    TypeOnly<current.RangeStackMap>;
declare function use_old_TypeAliasDeclaration_RangeStackMap(
    use: TypeOnly<old.RangeStackMap>);
use_old_TypeAliasDeclaration_RangeStackMap(
    get_current_TypeAliasDeclaration_RangeStackMap());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RBColor": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_RBColor():
    TypeOnly<old.RBColor>;
declare function use_current_EnumDeclaration_RBColor(
    use: TypeOnly<current.RBColor>);
use_current_EnumDeclaration_RBColor(
    // @ts-expect-error compatibility expected to be broken
    get_old_EnumDeclaration_RBColor());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RBColor": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_RBColor():
    TypeOnly<current.RBColor>;
declare function use_old_EnumDeclaration_RBColor(
    use: TypeOnly<old.RBColor>);
use_old_EnumDeclaration_RBColor(
    // @ts-expect-error compatibility expected to be broken
    get_current_EnumDeclaration_RBColor());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_RBNode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_RBNode():
    TypeOnly<old.RBNode<any,any>>;
declare function use_current_InterfaceDeclaration_RBNode(
    use: TypeOnly<current.RBNode<any,any>>);
use_current_InterfaceDeclaration_RBNode(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_RBNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_RBNode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_RBNode():
    TypeOnly<current.RBNode<any,any>>;
declare function use_old_InterfaceDeclaration_RBNode(
    use: TypeOnly<old.RBNode<any,any>>);
use_old_InterfaceDeclaration_RBNode(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_RBNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_RBNodeActions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_RBNodeActions():
    TypeOnly<old.RBNodeActions<any,any>>;
declare function use_current_InterfaceDeclaration_RBNodeActions(
    use: TypeOnly<current.RBNodeActions<any,any>>);
use_current_InterfaceDeclaration_RBNodeActions(
    get_old_InterfaceDeclaration_RBNodeActions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_RBNodeActions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_RBNodeActions():
    TypeOnly<current.RBNodeActions<any,any>>;
declare function use_old_InterfaceDeclaration_RBNodeActions(
    use: TypeOnly<old.RBNodeActions<any,any>>);
use_old_InterfaceDeclaration_RBNodeActions(
    get_current_InterfaceDeclaration_RBNodeActions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RedBlackTree": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_RedBlackTree():
    TypeOnly<old.RedBlackTree<any,any>>;
declare function use_current_ClassDeclaration_RedBlackTree(
    use: TypeOnly<current.RedBlackTree<any,any>>);
use_current_ClassDeclaration_RedBlackTree(
    get_old_ClassDeclaration_RedBlackTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RedBlackTree": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_RedBlackTree():
    TypeOnly<current.RedBlackTree<any,any>>;
declare function use_old_ClassDeclaration_RedBlackTree(
    use: TypeOnly<old.RedBlackTree<any,any>>);
use_old_ClassDeclaration_RedBlackTree(
    get_current_ClassDeclaration_RedBlackTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ReferencePosition": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ReferencePosition():
    TypeOnly<old.ReferencePosition>;
declare function use_current_InterfaceDeclaration_ReferencePosition(
    use: TypeOnly<current.ReferencePosition>);
use_current_InterfaceDeclaration_ReferencePosition(
    get_old_InterfaceDeclaration_ReferencePosition());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ReferencePosition": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ReferencePosition():
    TypeOnly<current.ReferencePosition>;
declare function use_old_InterfaceDeclaration_ReferencePosition(
    use: TypeOnly<old.ReferencePosition>);
use_old_InterfaceDeclaration_ReferencePosition(
    get_current_InterfaceDeclaration_ReferencePosition());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ReferenceType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_ReferenceType():
    TypeOnly<old.ReferenceType>;
declare function use_current_EnumDeclaration_ReferenceType(
    use: TypeOnly<current.ReferenceType>);
use_current_EnumDeclaration_ReferenceType(
    get_old_EnumDeclaration_ReferenceType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ReferenceType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_ReferenceType():
    TypeOnly<current.ReferenceType>;
declare function use_old_EnumDeclaration_ReferenceType(
    use: TypeOnly<old.ReferenceType>);
use_old_EnumDeclaration_ReferenceType(
    get_current_EnumDeclaration_ReferenceType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_refGetRangeLabels": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_refGetRangeLabels():
    TypeOnly<typeof old.refGetRangeLabels>;
declare function use_current_VariableDeclaration_refGetRangeLabels(
    use: TypeOnly<typeof current.refGetRangeLabels>);
use_current_VariableDeclaration_refGetRangeLabels(
    get_old_VariableDeclaration_refGetRangeLabels());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_refGetRangeLabels": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_refGetRangeLabels():
    TypeOnly<typeof current.refGetRangeLabels>;
declare function use_old_VariableDeclaration_refGetRangeLabels(
    use: TypeOnly<typeof old.refGetRangeLabels>);
use_old_VariableDeclaration_refGetRangeLabels(
    get_current_VariableDeclaration_refGetRangeLabels());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_refGetTileLabels": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_refGetTileLabels():
    TypeOnly<typeof old.refGetTileLabels>;
declare function use_current_VariableDeclaration_refGetTileLabels(
    use: TypeOnly<typeof current.refGetTileLabels>);
use_current_VariableDeclaration_refGetTileLabels(
    get_old_VariableDeclaration_refGetTileLabels());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_refGetTileLabels": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_refGetTileLabels():
    TypeOnly<typeof current.refGetTileLabels>;
declare function use_old_VariableDeclaration_refGetTileLabels(
    use: TypeOnly<typeof old.refGetTileLabels>);
use_old_VariableDeclaration_refGetTileLabels(
    get_current_VariableDeclaration_refGetTileLabels());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_refHasRangeLabel": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_refHasRangeLabel():
    TypeOnly<typeof old.refHasRangeLabel>;
declare function use_current_FunctionDeclaration_refHasRangeLabel(
    use: TypeOnly<typeof current.refHasRangeLabel>);
use_current_FunctionDeclaration_refHasRangeLabel(
    get_old_FunctionDeclaration_refHasRangeLabel());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_refHasRangeLabel": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_refHasRangeLabel():
    TypeOnly<typeof current.refHasRangeLabel>;
declare function use_old_FunctionDeclaration_refHasRangeLabel(
    use: TypeOnly<typeof old.refHasRangeLabel>);
use_old_FunctionDeclaration_refHasRangeLabel(
    get_current_FunctionDeclaration_refHasRangeLabel());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_refHasRangeLabels": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_refHasRangeLabels():
    TypeOnly<typeof old.refHasRangeLabels>;
declare function use_current_FunctionDeclaration_refHasRangeLabels(
    use: TypeOnly<typeof current.refHasRangeLabels>);
use_current_FunctionDeclaration_refHasRangeLabels(
    get_old_FunctionDeclaration_refHasRangeLabels());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_refHasRangeLabels": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_refHasRangeLabels():
    TypeOnly<typeof current.refHasRangeLabels>;
declare function use_old_FunctionDeclaration_refHasRangeLabels(
    use: TypeOnly<typeof old.refHasRangeLabels>);
use_old_FunctionDeclaration_refHasRangeLabels(
    get_current_FunctionDeclaration_refHasRangeLabels());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_refHasTileLabel": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_refHasTileLabel():
    TypeOnly<typeof old.refHasTileLabel>;
declare function use_current_FunctionDeclaration_refHasTileLabel(
    use: TypeOnly<typeof current.refHasTileLabel>);
use_current_FunctionDeclaration_refHasTileLabel(
    get_old_FunctionDeclaration_refHasTileLabel());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_refHasTileLabel": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_refHasTileLabel():
    TypeOnly<typeof current.refHasTileLabel>;
declare function use_old_FunctionDeclaration_refHasTileLabel(
    use: TypeOnly<typeof old.refHasTileLabel>);
use_old_FunctionDeclaration_refHasTileLabel(
    get_current_FunctionDeclaration_refHasTileLabel());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_refHasTileLabels": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_refHasTileLabels():
    TypeOnly<typeof old.refHasTileLabels>;
declare function use_current_FunctionDeclaration_refHasTileLabels(
    use: TypeOnly<typeof current.refHasTileLabels>);
use_current_FunctionDeclaration_refHasTileLabels(
    get_old_FunctionDeclaration_refHasTileLabels());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_refHasTileLabels": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_refHasTileLabels():
    TypeOnly<typeof current.refHasTileLabels>;
declare function use_old_FunctionDeclaration_refHasTileLabels(
    use: TypeOnly<typeof old.refHasTileLabels>);
use_old_FunctionDeclaration_refHasTileLabels(
    get_current_FunctionDeclaration_refHasTileLabels());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_refTypeIncludesFlag": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_refTypeIncludesFlag():
    TypeOnly<typeof old.refTypeIncludesFlag>;
declare function use_current_FunctionDeclaration_refTypeIncludesFlag(
    use: TypeOnly<typeof current.refTypeIncludesFlag>);
use_current_FunctionDeclaration_refTypeIncludesFlag(
    get_old_FunctionDeclaration_refTypeIncludesFlag());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_refTypeIncludesFlag": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_refTypeIncludesFlag():
    TypeOnly<typeof current.refTypeIncludesFlag>;
declare function use_old_FunctionDeclaration_refTypeIncludesFlag(
    use: TypeOnly<typeof old.refTypeIncludesFlag>);
use_old_FunctionDeclaration_refTypeIncludesFlag(
    get_current_FunctionDeclaration_refTypeIncludesFlag());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_reservedMarkerIdKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_reservedMarkerIdKey():
    TypeOnly<typeof old.reservedMarkerIdKey>;
declare function use_current_VariableDeclaration_reservedMarkerIdKey(
    use: TypeOnly<typeof current.reservedMarkerIdKey>);
use_current_VariableDeclaration_reservedMarkerIdKey(
    get_old_VariableDeclaration_reservedMarkerIdKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_reservedMarkerIdKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_reservedMarkerIdKey():
    TypeOnly<typeof current.reservedMarkerIdKey>;
declare function use_old_VariableDeclaration_reservedMarkerIdKey(
    use: TypeOnly<typeof old.reservedMarkerIdKey>);
use_old_VariableDeclaration_reservedMarkerIdKey(
    get_current_VariableDeclaration_reservedMarkerIdKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_reservedMarkerSimpleTypeKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_reservedMarkerSimpleTypeKey():
    TypeOnly<typeof old.reservedMarkerSimpleTypeKey>;
declare function use_current_VariableDeclaration_reservedMarkerSimpleTypeKey(
    use: TypeOnly<typeof current.reservedMarkerSimpleTypeKey>);
use_current_VariableDeclaration_reservedMarkerSimpleTypeKey(
    get_old_VariableDeclaration_reservedMarkerSimpleTypeKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_reservedMarkerSimpleTypeKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_reservedMarkerSimpleTypeKey():
    TypeOnly<typeof current.reservedMarkerSimpleTypeKey>;
declare function use_old_VariableDeclaration_reservedMarkerSimpleTypeKey(
    use: TypeOnly<typeof old.reservedMarkerSimpleTypeKey>);
use_old_VariableDeclaration_reservedMarkerSimpleTypeKey(
    get_current_VariableDeclaration_reservedMarkerSimpleTypeKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_reservedRangeLabelsKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_reservedRangeLabelsKey():
    TypeOnly<typeof old.reservedRangeLabelsKey>;
declare function use_current_VariableDeclaration_reservedRangeLabelsKey(
    use: TypeOnly<typeof current.reservedRangeLabelsKey>);
use_current_VariableDeclaration_reservedRangeLabelsKey(
    get_old_VariableDeclaration_reservedRangeLabelsKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_reservedRangeLabelsKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_reservedRangeLabelsKey():
    TypeOnly<typeof current.reservedRangeLabelsKey>;
declare function use_old_VariableDeclaration_reservedRangeLabelsKey(
    use: TypeOnly<typeof old.reservedRangeLabelsKey>);
use_old_VariableDeclaration_reservedRangeLabelsKey(
    get_current_VariableDeclaration_reservedRangeLabelsKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_reservedTileLabelsKey": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_reservedTileLabelsKey():
    TypeOnly<typeof old.reservedTileLabelsKey>;
declare function use_current_VariableDeclaration_reservedTileLabelsKey(
    use: TypeOnly<typeof current.reservedTileLabelsKey>);
use_current_VariableDeclaration_reservedTileLabelsKey(
    get_old_VariableDeclaration_reservedTileLabelsKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_reservedTileLabelsKey": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_reservedTileLabelsKey():
    TypeOnly<typeof current.reservedTileLabelsKey>;
declare function use_old_VariableDeclaration_reservedTileLabelsKey(
    use: TypeOnly<typeof old.reservedTileLabelsKey>);
use_old_VariableDeclaration_reservedTileLabelsKey(
    get_current_VariableDeclaration_reservedTileLabelsKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SearchResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_SearchResult():
    TypeOnly<old.SearchResult>;
declare function use_current_InterfaceDeclaration_SearchResult(
    use: TypeOnly<current.SearchResult>);
use_current_InterfaceDeclaration_SearchResult(
    get_old_InterfaceDeclaration_SearchResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SearchResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_SearchResult():
    TypeOnly<current.SearchResult>;
declare function use_old_InterfaceDeclaration_SearchResult(
    use: TypeOnly<old.SearchResult>);
use_old_InterfaceDeclaration_SearchResult(
    get_current_InterfaceDeclaration_SearchResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SegmentAccumulator": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_SegmentAccumulator():
    TypeOnly<old.SegmentAccumulator>;
declare function use_current_InterfaceDeclaration_SegmentAccumulator(
    use: TypeOnly<current.SegmentAccumulator>);
use_current_InterfaceDeclaration_SegmentAccumulator(
    get_old_InterfaceDeclaration_SegmentAccumulator());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SegmentAccumulator": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_SegmentAccumulator():
    TypeOnly<current.SegmentAccumulator>;
declare function use_old_InterfaceDeclaration_SegmentAccumulator(
    use: TypeOnly<old.SegmentAccumulator>);
use_old_InterfaceDeclaration_SegmentAccumulator(
    get_current_InterfaceDeclaration_SegmentAccumulator());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SegmentActions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_SegmentActions():
    TypeOnly<old.SegmentActions<any>>;
declare function use_current_InterfaceDeclaration_SegmentActions(
    use: TypeOnly<current.SegmentActions<any>>);
use_current_InterfaceDeclaration_SegmentActions(
    get_old_InterfaceDeclaration_SegmentActions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SegmentActions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_SegmentActions():
    TypeOnly<current.SegmentActions<any>>;
declare function use_old_InterfaceDeclaration_SegmentActions(
    use: TypeOnly<old.SegmentActions<any>>);
use_old_InterfaceDeclaration_SegmentActions(
    get_current_InterfaceDeclaration_SegmentActions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SegmentGroup": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_SegmentGroup():
    TypeOnly<old.SegmentGroup>;
declare function use_current_InterfaceDeclaration_SegmentGroup(
    use: TypeOnly<current.SegmentGroup>);
use_current_InterfaceDeclaration_SegmentGroup(
    get_old_InterfaceDeclaration_SegmentGroup());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SegmentGroup": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_SegmentGroup():
    TypeOnly<current.SegmentGroup>;
declare function use_old_InterfaceDeclaration_SegmentGroup(
    use: TypeOnly<old.SegmentGroup>);
use_old_InterfaceDeclaration_SegmentGroup(
    get_current_InterfaceDeclaration_SegmentGroup());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SegmentGroupCollection": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SegmentGroupCollection():
    TypeOnly<old.SegmentGroupCollection>;
declare function use_current_ClassDeclaration_SegmentGroupCollection(
    use: TypeOnly<current.SegmentGroupCollection>);
use_current_ClassDeclaration_SegmentGroupCollection(
    get_old_ClassDeclaration_SegmentGroupCollection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SegmentGroupCollection": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SegmentGroupCollection():
    TypeOnly<current.SegmentGroupCollection>;
declare function use_old_ClassDeclaration_SegmentGroupCollection(
    use: TypeOnly<old.SegmentGroupCollection>);
use_old_ClassDeclaration_SegmentGroupCollection(
    get_current_ClassDeclaration_SegmentGroupCollection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SnapshotLegacy": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SnapshotLegacy():
    TypeOnly<old.SnapshotLegacy>;
declare function use_current_ClassDeclaration_SnapshotLegacy(
    use: TypeOnly<current.SnapshotLegacy>);
use_current_ClassDeclaration_SnapshotLegacy(
    get_old_ClassDeclaration_SnapshotLegacy());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SnapshotLegacy": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SnapshotLegacy():
    TypeOnly<current.SnapshotLegacy>;
declare function use_old_ClassDeclaration_SnapshotLegacy(
    use: TypeOnly<old.SnapshotLegacy>);
use_old_ClassDeclaration_SnapshotLegacy(
    get_current_ClassDeclaration_SnapshotLegacy());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SortedDictionary": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_SortedDictionary():
    TypeOnly<old.SortedDictionary<any,any>>;
declare function use_current_InterfaceDeclaration_SortedDictionary(
    use: TypeOnly<current.SortedDictionary<any,any>>);
use_current_InterfaceDeclaration_SortedDictionary(
    get_old_InterfaceDeclaration_SortedDictionary());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SortedDictionary": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_SortedDictionary():
    TypeOnly<current.SortedDictionary<any,any>>;
declare function use_old_InterfaceDeclaration_SortedDictionary(
    use: TypeOnly<old.SortedDictionary<any,any>>);
use_old_InterfaceDeclaration_SortedDictionary(
    get_current_InterfaceDeclaration_SortedDictionary());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SortedSegmentSet": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SortedSegmentSet():
    TypeOnly<old.SortedSegmentSet>;
declare function use_current_ClassDeclaration_SortedSegmentSet(
    use: TypeOnly<current.SortedSegmentSet>);
use_current_ClassDeclaration_SortedSegmentSet(
    get_old_ClassDeclaration_SortedSegmentSet());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SortedSegmentSet": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SortedSegmentSet():
    TypeOnly<current.SortedSegmentSet>;
declare function use_old_ClassDeclaration_SortedSegmentSet(
    use: TypeOnly<old.SortedSegmentSet>);
use_old_ClassDeclaration_SortedSegmentSet(
    get_current_ClassDeclaration_SortedSegmentSet());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Stack": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Stack():
    TypeOnly<old.Stack<any>>;
declare function use_current_ClassDeclaration_Stack(
    use: TypeOnly<current.Stack<any>>);
use_current_ClassDeclaration_Stack(
    get_old_ClassDeclaration_Stack());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Stack": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Stack():
    TypeOnly<current.Stack<any>>;
declare function use_old_ClassDeclaration_Stack(
    use: TypeOnly<old.Stack<any>>);
use_old_ClassDeclaration_Stack(
    get_current_ClassDeclaration_Stack());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TextSegment": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TextSegment():
    TypeOnly<old.TextSegment>;
declare function use_current_ClassDeclaration_TextSegment(
    use: TypeOnly<current.TextSegment>);
use_current_ClassDeclaration_TextSegment(
    get_old_ClassDeclaration_TextSegment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TextSegment": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TextSegment():
    TypeOnly<current.TextSegment>;
declare function use_old_ClassDeclaration_TextSegment(
    use: TypeOnly<old.TextSegment>);
use_old_ClassDeclaration_TextSegment(
    get_current_ClassDeclaration_TextSegment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_toRemovalInfo": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_toRemovalInfo():
    TypeOnly<typeof old.toRemovalInfo>;
declare function use_current_FunctionDeclaration_toRemovalInfo(
    use: TypeOnly<typeof current.toRemovalInfo>);
use_current_FunctionDeclaration_toRemovalInfo(
    get_old_FunctionDeclaration_toRemovalInfo());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_toRemovalInfo": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_toRemovalInfo():
    TypeOnly<typeof current.toRemovalInfo>;
declare function use_old_FunctionDeclaration_toRemovalInfo(
    use: TypeOnly<typeof old.toRemovalInfo>);
use_old_FunctionDeclaration_toRemovalInfo(
    get_current_FunctionDeclaration_toRemovalInfo());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TrackingGroup": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TrackingGroup():
    TypeOnly<old.TrackingGroup>;
declare function use_current_ClassDeclaration_TrackingGroup(
    use: TypeOnly<current.TrackingGroup>);
use_current_ClassDeclaration_TrackingGroup(
    get_old_ClassDeclaration_TrackingGroup());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TrackingGroup": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TrackingGroup():
    TypeOnly<current.TrackingGroup>;
declare function use_old_ClassDeclaration_TrackingGroup(
    use: TypeOnly<old.TrackingGroup>);
use_old_ClassDeclaration_TrackingGroup(
    get_current_ClassDeclaration_TrackingGroup());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TrackingGroupCollection": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TrackingGroupCollection():
    TypeOnly<old.TrackingGroupCollection>;
declare function use_current_ClassDeclaration_TrackingGroupCollection(
    use: TypeOnly<current.TrackingGroupCollection>);
use_current_ClassDeclaration_TrackingGroupCollection(
    get_old_ClassDeclaration_TrackingGroupCollection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TrackingGroupCollection": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TrackingGroupCollection():
    TypeOnly<current.TrackingGroupCollection>;
declare function use_old_ClassDeclaration_TrackingGroupCollection(
    use: TypeOnly<old.TrackingGroupCollection>);
use_old_ClassDeclaration_TrackingGroupCollection(
    get_current_ClassDeclaration_TrackingGroupCollection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TreeMaintenanceSequenceNumber": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_TreeMaintenanceSequenceNumber():
    TypeOnly<typeof old.TreeMaintenanceSequenceNumber>;
declare function use_current_VariableDeclaration_TreeMaintenanceSequenceNumber(
    use: TypeOnly<typeof current.TreeMaintenanceSequenceNumber>);
use_current_VariableDeclaration_TreeMaintenanceSequenceNumber(
    get_old_VariableDeclaration_TreeMaintenanceSequenceNumber());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TreeMaintenanceSequenceNumber": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_TreeMaintenanceSequenceNumber():
    TypeOnly<typeof current.TreeMaintenanceSequenceNumber>;
declare function use_old_VariableDeclaration_TreeMaintenanceSequenceNumber(
    use: TypeOnly<typeof old.TreeMaintenanceSequenceNumber>);
use_old_VariableDeclaration_TreeMaintenanceSequenceNumber(
    get_current_VariableDeclaration_TreeMaintenanceSequenceNumber());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TST": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TST():
    TypeOnly<old.TST<any>>;
declare function use_current_ClassDeclaration_TST(
    use: TypeOnly<current.TST<any>>);
use_current_ClassDeclaration_TST(
    get_old_ClassDeclaration_TST());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TST": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TST():
    TypeOnly<current.TST<any>>;
declare function use_old_ClassDeclaration_TST(
    use: TypeOnly<old.TST<any>>);
use_old_ClassDeclaration_TST(
    get_current_ClassDeclaration_TST());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TSTNode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_TSTNode():
    TypeOnly<old.TSTNode<any>>;
declare function use_current_InterfaceDeclaration_TSTNode(
    use: TypeOnly<current.TSTNode<any>>);
use_current_InterfaceDeclaration_TSTNode(
    get_old_InterfaceDeclaration_TSTNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TSTNode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_TSTNode():
    TypeOnly<current.TSTNode<any>>;
declare function use_old_InterfaceDeclaration_TSTNode(
    use: TypeOnly<old.TSTNode<any>>);
use_old_InterfaceDeclaration_TSTNode(
    get_current_InterfaceDeclaration_TSTNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TSTResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_TSTResult():
    TypeOnly<old.TSTResult<any>>;
declare function use_current_InterfaceDeclaration_TSTResult(
    use: TypeOnly<current.TSTResult<any>>);
use_current_InterfaceDeclaration_TSTResult(
    get_old_InterfaceDeclaration_TSTResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_TSTResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_TSTResult():
    TypeOnly<current.TSTResult<any>>;
declare function use_old_InterfaceDeclaration_TSTResult(
    use: TypeOnly<old.TSTResult<any>>);
use_old_InterfaceDeclaration_TSTResult(
    get_current_InterfaceDeclaration_TSTResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_UnassignedSequenceNumber": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_UnassignedSequenceNumber():
    TypeOnly<typeof old.UnassignedSequenceNumber>;
declare function use_current_VariableDeclaration_UnassignedSequenceNumber(
    use: TypeOnly<typeof current.UnassignedSequenceNumber>);
use_current_VariableDeclaration_UnassignedSequenceNumber(
    get_old_VariableDeclaration_UnassignedSequenceNumber());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_UnassignedSequenceNumber": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_UnassignedSequenceNumber():
    TypeOnly<typeof current.UnassignedSequenceNumber>;
declare function use_old_VariableDeclaration_UnassignedSequenceNumber(
    use: TypeOnly<typeof old.UnassignedSequenceNumber>);
use_old_VariableDeclaration_UnassignedSequenceNumber(
    get_current_VariableDeclaration_UnassignedSequenceNumber());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_UniversalSequenceNumber": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_UniversalSequenceNumber():
    TypeOnly<typeof old.UniversalSequenceNumber>;
declare function use_current_VariableDeclaration_UniversalSequenceNumber(
    use: TypeOnly<typeof current.UniversalSequenceNumber>);
use_current_VariableDeclaration_UniversalSequenceNumber(
    get_old_VariableDeclaration_UniversalSequenceNumber());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_UniversalSequenceNumber": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_UniversalSequenceNumber():
    TypeOnly<typeof current.UniversalSequenceNumber>;
declare function use_old_VariableDeclaration_UniversalSequenceNumber(
    use: TypeOnly<typeof old.UniversalSequenceNumber>);
use_old_VariableDeclaration_UniversalSequenceNumber(
    get_current_VariableDeclaration_UniversalSequenceNumber());
