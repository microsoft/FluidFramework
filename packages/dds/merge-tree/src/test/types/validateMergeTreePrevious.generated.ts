/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/merge-tree-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current;

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_AttributionPolicy": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_AttributionPolicy():
    TypeOnly<current.AttributionPolicy>;
declare function use_old_InterfaceDeclaration_AttributionPolicy(
    use: TypeOnly<old.AttributionPolicy>): void;
use_old_InterfaceDeclaration_AttributionPolicy(
    get_current_InterfaceDeclaration_AttributionPolicy());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_BaseSegment": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_BaseSegment():
    TypeOnly<old.BaseSegment>;
declare function use_current_ClassDeclaration_BaseSegment(
    use: TypeOnly<current.BaseSegment>): void;
use_current_ClassDeclaration_BaseSegment(
    get_old_ClassDeclaration_BaseSegment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_BaseSegment": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_BaseSegment():
    TypeOnly<current.BaseSegment>;
declare function use_old_ClassDeclaration_BaseSegment(
    use: TypeOnly<old.BaseSegment>): void;
use_old_ClassDeclaration_BaseSegment(
    get_current_ClassDeclaration_BaseSegment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Client": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_Client():
    TypeOnly<old.Client>;
declare function use_current_ClassDeclaration_Client(
    use: TypeOnly<current.Client>): void;
use_current_ClassDeclaration_Client(
    get_old_ClassDeclaration_Client());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Client": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_Client():
    TypeOnly<current.Client>;
declare function use_old_ClassDeclaration_Client(
    use: TypeOnly<old.Client>): void;
use_old_ClassDeclaration_Client(
    get_current_ClassDeclaration_Client());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_CollaborationWindow": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_CollaborationWindow():
    TypeOnly<old.CollaborationWindow>;
declare function use_current_ClassDeclaration_CollaborationWindow(
    use: TypeOnly<current.CollaborationWindow>): void;
use_current_ClassDeclaration_CollaborationWindow(
    get_old_ClassDeclaration_CollaborationWindow());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_CollaborationWindow": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_CollaborationWindow():
    TypeOnly<current.CollaborationWindow>;
declare function use_old_ClassDeclaration_CollaborationWindow(
    use: TypeOnly<old.CollaborationWindow>): void;
use_old_ClassDeclaration_CollaborationWindow(
    get_current_ClassDeclaration_CollaborationWindow());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ConflictAction": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ConflictAction():
    TypeOnly<old.ConflictAction<any,any>>;
declare function use_current_TypeAliasDeclaration_ConflictAction(
    use: TypeOnly<current.ConflictAction<any,any>>): void;
use_current_TypeAliasDeclaration_ConflictAction(
    get_old_TypeAliasDeclaration_ConflictAction());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ConflictAction": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ConflictAction():
    TypeOnly<current.ConflictAction<any,any>>;
declare function use_old_TypeAliasDeclaration_ConflictAction(
    use: TypeOnly<old.ConflictAction<any,any>>): void;
use_old_TypeAliasDeclaration_ConflictAction(
    get_current_TypeAliasDeclaration_ConflictAction());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_DetachedReferencePosition": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_DetachedReferencePosition():
    TypeOnly<typeof old.DetachedReferencePosition>;
declare function use_current_VariableDeclaration_DetachedReferencePosition(
    use: TypeOnly<typeof current.DetachedReferencePosition>): void;
use_current_VariableDeclaration_DetachedReferencePosition(
    get_old_VariableDeclaration_DetachedReferencePosition());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_DetachedReferencePosition": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_DetachedReferencePosition():
    TypeOnly<typeof current.DetachedReferencePosition>;
declare function use_old_VariableDeclaration_DetachedReferencePosition(
    use: TypeOnly<typeof old.DetachedReferencePosition>): void;
use_old_VariableDeclaration_DetachedReferencePosition(
    get_current_VariableDeclaration_DetachedReferencePosition());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_Dictionary": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_Dictionary():
    TypeOnly<old.Dictionary<any,any>>;
declare function use_current_InterfaceDeclaration_Dictionary(
    use: TypeOnly<current.Dictionary<any,any>>): void;
use_current_InterfaceDeclaration_Dictionary(
    get_old_InterfaceDeclaration_Dictionary());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_Dictionary": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_Dictionary():
    TypeOnly<current.Dictionary<any,any>>;
declare function use_old_InterfaceDeclaration_Dictionary(
    use: TypeOnly<old.Dictionary<any,any>>): void;
use_old_InterfaceDeclaration_Dictionary(
    get_current_InterfaceDeclaration_Dictionary());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAttributionCollection": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IAttributionCollection():
    TypeOnly<old.IAttributionCollection<any>>;
declare function use_current_InterfaceDeclaration_IAttributionCollection(
    use: TypeOnly<current.IAttributionCollection<any>>): void;
use_current_InterfaceDeclaration_IAttributionCollection(
    get_old_InterfaceDeclaration_IAttributionCollection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAttributionCollection": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IAttributionCollection():
    TypeOnly<current.IAttributionCollection<any>>;
declare function use_old_InterfaceDeclaration_IAttributionCollection(
    use: TypeOnly<old.IAttributionCollection<any>>): void;
use_old_InterfaceDeclaration_IAttributionCollection(
    get_current_InterfaceDeclaration_IAttributionCollection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAttributionCollectionSerializer": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IAttributionCollectionSerializer():
    TypeOnly<current.IAttributionCollectionSerializer>;
declare function use_old_InterfaceDeclaration_IAttributionCollectionSerializer(
    use: TypeOnly<old.IAttributionCollectionSerializer>): void;
use_old_InterfaceDeclaration_IAttributionCollectionSerializer(
    get_current_InterfaceDeclaration_IAttributionCollectionSerializer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAttributionCollectionSpec": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IAttributionCollectionSpec():
    TypeOnly<old.IAttributionCollectionSpec<any>>;
declare function use_current_InterfaceDeclaration_IAttributionCollectionSpec(
    use: TypeOnly<current.IAttributionCollectionSpec<any>>): void;
use_current_InterfaceDeclaration_IAttributionCollectionSpec(
    get_old_InterfaceDeclaration_IAttributionCollectionSpec());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAttributionCollectionSpec": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IAttributionCollectionSpec():
    TypeOnly<current.IAttributionCollectionSpec<any>>;
declare function use_old_InterfaceDeclaration_IAttributionCollectionSpec(
    use: TypeOnly<old.IAttributionCollectionSpec<any>>): void;
use_old_InterfaceDeclaration_IAttributionCollectionSpec(
    get_current_InterfaceDeclaration_IAttributionCollectionSpec());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IClientEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IClientEvents():
    TypeOnly<old.IClientEvents>;
declare function use_current_InterfaceDeclaration_IClientEvents(
    use: TypeOnly<current.IClientEvents>): void;
use_current_InterfaceDeclaration_IClientEvents(
    get_old_InterfaceDeclaration_IClientEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IClientEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IClientEvents():
    TypeOnly<current.IClientEvents>;
declare function use_old_InterfaceDeclaration_IClientEvents(
    use: TypeOnly<old.IClientEvents>): void;
use_old_InterfaceDeclaration_IClientEvents(
    get_current_InterfaceDeclaration_IClientEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONMarkerSegment": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IJSONMarkerSegment():
    TypeOnly<old.IJSONMarkerSegment>;
declare function use_current_InterfaceDeclaration_IJSONMarkerSegment(
    use: TypeOnly<current.IJSONMarkerSegment>): void;
use_current_InterfaceDeclaration_IJSONMarkerSegment(
    get_old_InterfaceDeclaration_IJSONMarkerSegment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONMarkerSegment": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IJSONMarkerSegment():
    TypeOnly<current.IJSONMarkerSegment>;
declare function use_old_InterfaceDeclaration_IJSONMarkerSegment(
    use: TypeOnly<old.IJSONMarkerSegment>): void;
use_old_InterfaceDeclaration_IJSONMarkerSegment(
    get_current_InterfaceDeclaration_IJSONMarkerSegment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONSegment": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IJSONSegment():
    TypeOnly<old.IJSONSegment>;
declare function use_current_InterfaceDeclaration_IJSONSegment(
    use: TypeOnly<current.IJSONSegment>): void;
use_current_InterfaceDeclaration_IJSONSegment(
    get_old_InterfaceDeclaration_IJSONSegment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONSegment": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IJSONSegment():
    TypeOnly<current.IJSONSegment>;
declare function use_old_InterfaceDeclaration_IJSONSegment(
    use: TypeOnly<old.IJSONSegment>): void;
use_old_InterfaceDeclaration_IJSONSegment(
    get_current_InterfaceDeclaration_IJSONSegment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONTextSegment": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IJSONTextSegment():
    TypeOnly<old.IJSONTextSegment>;
declare function use_current_InterfaceDeclaration_IJSONTextSegment(
    use: TypeOnly<current.IJSONTextSegment>): void;
use_current_InterfaceDeclaration_IJSONTextSegment(
    get_old_InterfaceDeclaration_IJSONTextSegment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONTextSegment": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IJSONTextSegment():
    TypeOnly<current.IJSONTextSegment>;
declare function use_old_InterfaceDeclaration_IJSONTextSegment(
    use: TypeOnly<old.IJSONTextSegment>): void;
use_old_InterfaceDeclaration_IJSONTextSegment(
    get_current_InterfaceDeclaration_IJSONTextSegment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMarkerDef": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMarkerDef():
    TypeOnly<old.IMarkerDef>;
declare function use_current_InterfaceDeclaration_IMarkerDef(
    use: TypeOnly<current.IMarkerDef>): void;
use_current_InterfaceDeclaration_IMarkerDef(
    get_old_InterfaceDeclaration_IMarkerDef());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMarkerDef": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMarkerDef():
    TypeOnly<current.IMarkerDef>;
declare function use_old_InterfaceDeclaration_IMarkerDef(
    use: TypeOnly<old.IMarkerDef>): void;
use_old_InterfaceDeclaration_IMarkerDef(
    get_current_InterfaceDeclaration_IMarkerDef());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeNodeCommon": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeNodeCommon():
    TypeOnly<old.IMergeNodeCommon>;
declare function use_current_InterfaceDeclaration_IMergeNodeCommon(
    use: TypeOnly<current.IMergeNodeCommon>): void;
use_current_InterfaceDeclaration_IMergeNodeCommon(
    get_old_InterfaceDeclaration_IMergeNodeCommon());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeNodeCommon": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeNodeCommon():
    TypeOnly<current.IMergeNodeCommon>;
declare function use_old_InterfaceDeclaration_IMergeNodeCommon(
    use: TypeOnly<old.IMergeNodeCommon>): void;
use_old_InterfaceDeclaration_IMergeNodeCommon(
    get_current_InterfaceDeclaration_IMergeNodeCommon());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeAnnotateMsg": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeTreeAnnotateMsg():
    TypeOnly<old.IMergeTreeAnnotateMsg>;
declare function use_current_InterfaceDeclaration_IMergeTreeAnnotateMsg(
    use: TypeOnly<current.IMergeTreeAnnotateMsg>): void;
use_current_InterfaceDeclaration_IMergeTreeAnnotateMsg(
    get_old_InterfaceDeclaration_IMergeTreeAnnotateMsg());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeAnnotateMsg": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeTreeAnnotateMsg():
    TypeOnly<current.IMergeTreeAnnotateMsg>;
declare function use_old_InterfaceDeclaration_IMergeTreeAnnotateMsg(
    use: TypeOnly<old.IMergeTreeAnnotateMsg>): void;
use_old_InterfaceDeclaration_IMergeTreeAnnotateMsg(
    get_current_InterfaceDeclaration_IMergeTreeAnnotateMsg());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeAttributionOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeTreeAttributionOptions():
    TypeOnly<old.IMergeTreeAttributionOptions>;
declare function use_current_InterfaceDeclaration_IMergeTreeAttributionOptions(
    use: TypeOnly<current.IMergeTreeAttributionOptions>): void;
use_current_InterfaceDeclaration_IMergeTreeAttributionOptions(
    get_old_InterfaceDeclaration_IMergeTreeAttributionOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeAttributionOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeTreeAttributionOptions():
    TypeOnly<current.IMergeTreeAttributionOptions>;
declare function use_old_InterfaceDeclaration_IMergeTreeAttributionOptions(
    use: TypeOnly<old.IMergeTreeAttributionOptions>): void;
use_old_InterfaceDeclaration_IMergeTreeAttributionOptions(
    get_current_InterfaceDeclaration_IMergeTreeAttributionOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeClientSequenceArgs": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeTreeClientSequenceArgs():
    TypeOnly<old.IMergeTreeClientSequenceArgs>;
declare function use_current_InterfaceDeclaration_IMergeTreeClientSequenceArgs(
    use: TypeOnly<current.IMergeTreeClientSequenceArgs>): void;
use_current_InterfaceDeclaration_IMergeTreeClientSequenceArgs(
    get_old_InterfaceDeclaration_IMergeTreeClientSequenceArgs());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeClientSequenceArgs": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeTreeClientSequenceArgs():
    TypeOnly<current.IMergeTreeClientSequenceArgs>;
declare function use_old_InterfaceDeclaration_IMergeTreeClientSequenceArgs(
    use: TypeOnly<old.IMergeTreeClientSequenceArgs>): void;
use_old_InterfaceDeclaration_IMergeTreeClientSequenceArgs(
    get_current_InterfaceDeclaration_IMergeTreeClientSequenceArgs());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeDelta": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeTreeDelta():
    TypeOnly<old.IMergeTreeDelta>;
declare function use_current_InterfaceDeclaration_IMergeTreeDelta(
    use: TypeOnly<current.IMergeTreeDelta>): void;
use_current_InterfaceDeclaration_IMergeTreeDelta(
    get_old_InterfaceDeclaration_IMergeTreeDelta());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeDelta": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeTreeDelta():
    TypeOnly<current.IMergeTreeDelta>;
declare function use_old_InterfaceDeclaration_IMergeTreeDelta(
    use: TypeOnly<old.IMergeTreeDelta>): void;
use_old_InterfaceDeclaration_IMergeTreeDelta(
    get_current_InterfaceDeclaration_IMergeTreeDelta());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeDeltaCallbackArgs": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs():
    TypeOnly<old.IMergeTreeDeltaCallbackArgs>;
declare function use_current_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs(
    use: TypeOnly<current.IMergeTreeDeltaCallbackArgs>): void;
use_current_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs(
    get_old_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeDeltaCallbackArgs": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs():
    TypeOnly<current.IMergeTreeDeltaCallbackArgs>;
declare function use_old_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs(
    use: TypeOnly<old.IMergeTreeDeltaCallbackArgs>): void;
use_old_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs(
    get_current_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IMergeTreeDeltaOp": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IMergeTreeDeltaOp():
    TypeOnly<old.IMergeTreeDeltaOp>;
declare function use_current_TypeAliasDeclaration_IMergeTreeDeltaOp(
    use: TypeOnly<current.IMergeTreeDeltaOp>): void;
use_current_TypeAliasDeclaration_IMergeTreeDeltaOp(
    get_old_TypeAliasDeclaration_IMergeTreeDeltaOp());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IMergeTreeDeltaOp": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IMergeTreeDeltaOp():
    TypeOnly<current.IMergeTreeDeltaOp>;
declare function use_old_TypeAliasDeclaration_IMergeTreeDeltaOp(
    use: TypeOnly<old.IMergeTreeDeltaOp>): void;
use_old_TypeAliasDeclaration_IMergeTreeDeltaOp(
    get_current_TypeAliasDeclaration_IMergeTreeDeltaOp());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeDeltaOpArgs": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeTreeDeltaOpArgs():
    TypeOnly<old.IMergeTreeDeltaOpArgs>;
declare function use_current_InterfaceDeclaration_IMergeTreeDeltaOpArgs(
    use: TypeOnly<current.IMergeTreeDeltaOpArgs>): void;
use_current_InterfaceDeclaration_IMergeTreeDeltaOpArgs(
    get_old_InterfaceDeclaration_IMergeTreeDeltaOpArgs());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeDeltaOpArgs": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeTreeDeltaOpArgs():
    TypeOnly<current.IMergeTreeDeltaOpArgs>;
declare function use_old_InterfaceDeclaration_IMergeTreeDeltaOpArgs(
    use: TypeOnly<old.IMergeTreeDeltaOpArgs>): void;
use_old_InterfaceDeclaration_IMergeTreeDeltaOpArgs(
    get_current_InterfaceDeclaration_IMergeTreeDeltaOpArgs());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeGroupMsg": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeTreeGroupMsg():
    TypeOnly<old.IMergeTreeGroupMsg>;
declare function use_current_InterfaceDeclaration_IMergeTreeGroupMsg(
    use: TypeOnly<current.IMergeTreeGroupMsg>): void;
use_current_InterfaceDeclaration_IMergeTreeGroupMsg(
    get_old_InterfaceDeclaration_IMergeTreeGroupMsg());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeGroupMsg": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeTreeGroupMsg():
    TypeOnly<current.IMergeTreeGroupMsg>;
declare function use_old_InterfaceDeclaration_IMergeTreeGroupMsg(
    use: TypeOnly<old.IMergeTreeGroupMsg>): void;
use_old_InterfaceDeclaration_IMergeTreeGroupMsg(
    get_current_InterfaceDeclaration_IMergeTreeGroupMsg());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeInsertMsg": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeTreeInsertMsg():
    TypeOnly<old.IMergeTreeInsertMsg>;
declare function use_current_InterfaceDeclaration_IMergeTreeInsertMsg(
    use: TypeOnly<current.IMergeTreeInsertMsg>): void;
use_current_InterfaceDeclaration_IMergeTreeInsertMsg(
    get_old_InterfaceDeclaration_IMergeTreeInsertMsg());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeInsertMsg": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeTreeInsertMsg():
    TypeOnly<current.IMergeTreeInsertMsg>;
declare function use_old_InterfaceDeclaration_IMergeTreeInsertMsg(
    use: TypeOnly<old.IMergeTreeInsertMsg>): void;
use_old_InterfaceDeclaration_IMergeTreeInsertMsg(
    get_current_InterfaceDeclaration_IMergeTreeInsertMsg());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs():
    TypeOnly<old.IMergeTreeMaintenanceCallbackArgs>;
declare function use_current_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs(
    use: TypeOnly<current.IMergeTreeMaintenanceCallbackArgs>): void;
use_current_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs(
    get_old_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs():
    TypeOnly<current.IMergeTreeMaintenanceCallbackArgs>;
declare function use_old_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs(
    use: TypeOnly<old.IMergeTreeMaintenanceCallbackArgs>): void;
use_old_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs(
    get_current_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeObliterateMsg": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeTreeObliterateMsg():
    TypeOnly<old.IMergeTreeObliterateMsg>;
declare function use_current_InterfaceDeclaration_IMergeTreeObliterateMsg(
    use: TypeOnly<current.IMergeTreeObliterateMsg>): void;
use_current_InterfaceDeclaration_IMergeTreeObliterateMsg(
    get_old_InterfaceDeclaration_IMergeTreeObliterateMsg());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeObliterateMsg": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeTreeObliterateMsg():
    TypeOnly<current.IMergeTreeObliterateMsg>;
declare function use_old_InterfaceDeclaration_IMergeTreeObliterateMsg(
    use: TypeOnly<old.IMergeTreeObliterateMsg>): void;
use_old_InterfaceDeclaration_IMergeTreeObliterateMsg(
    get_current_InterfaceDeclaration_IMergeTreeObliterateMsg());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IMergeTreeOp": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IMergeTreeOp():
    TypeOnly<old.IMergeTreeOp>;
declare function use_current_TypeAliasDeclaration_IMergeTreeOp(
    use: TypeOnly<current.IMergeTreeOp>): void;
use_current_TypeAliasDeclaration_IMergeTreeOp(
    get_old_TypeAliasDeclaration_IMergeTreeOp());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IMergeTreeOp": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IMergeTreeOp():
    TypeOnly<current.IMergeTreeOp>;
declare function use_old_TypeAliasDeclaration_IMergeTreeOp(
    use: TypeOnly<old.IMergeTreeOp>): void;
use_old_TypeAliasDeclaration_IMergeTreeOp(
    get_current_TypeAliasDeclaration_IMergeTreeOp());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeTreeOptions():
    TypeOnly<old.IMergeTreeOptions>;
declare function use_current_InterfaceDeclaration_IMergeTreeOptions(
    use: TypeOnly<current.IMergeTreeOptions>): void;
use_current_InterfaceDeclaration_IMergeTreeOptions(
    get_old_InterfaceDeclaration_IMergeTreeOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeTreeOptions():
    TypeOnly<current.IMergeTreeOptions>;
declare function use_old_InterfaceDeclaration_IMergeTreeOptions(
    use: TypeOnly<old.IMergeTreeOptions>): void;
use_old_InterfaceDeclaration_IMergeTreeOptions(
    get_current_InterfaceDeclaration_IMergeTreeOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeRemoveMsg": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeTreeRemoveMsg():
    TypeOnly<old.IMergeTreeRemoveMsg>;
declare function use_current_InterfaceDeclaration_IMergeTreeRemoveMsg(
    use: TypeOnly<current.IMergeTreeRemoveMsg>): void;
use_current_InterfaceDeclaration_IMergeTreeRemoveMsg(
    get_old_InterfaceDeclaration_IMergeTreeRemoveMsg());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeRemoveMsg": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeTreeRemoveMsg():
    TypeOnly<current.IMergeTreeRemoveMsg>;
declare function use_old_InterfaceDeclaration_IMergeTreeRemoveMsg(
    use: TypeOnly<old.IMergeTreeRemoveMsg>): void;
use_old_InterfaceDeclaration_IMergeTreeRemoveMsg(
    get_current_InterfaceDeclaration_IMergeTreeRemoveMsg());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeSegmentDelta": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeTreeSegmentDelta():
    TypeOnly<old.IMergeTreeSegmentDelta>;
declare function use_current_InterfaceDeclaration_IMergeTreeSegmentDelta(
    use: TypeOnly<current.IMergeTreeSegmentDelta>): void;
use_current_InterfaceDeclaration_IMergeTreeSegmentDelta(
    get_old_InterfaceDeclaration_IMergeTreeSegmentDelta());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeSegmentDelta": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeTreeSegmentDelta():
    TypeOnly<current.IMergeTreeSegmentDelta>;
declare function use_old_InterfaceDeclaration_IMergeTreeSegmentDelta(
    use: TypeOnly<old.IMergeTreeSegmentDelta>): void;
use_old_InterfaceDeclaration_IMergeTreeSegmentDelta(
    get_current_InterfaceDeclaration_IMergeTreeSegmentDelta());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeTextHelper": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMergeTreeTextHelper():
    TypeOnly<old.IMergeTreeTextHelper>;
declare function use_current_InterfaceDeclaration_IMergeTreeTextHelper(
    use: TypeOnly<current.IMergeTreeTextHelper>): void;
use_current_InterfaceDeclaration_IMergeTreeTextHelper(
    get_old_InterfaceDeclaration_IMergeTreeTextHelper());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeTextHelper": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMergeTreeTextHelper():
    TypeOnly<current.IMergeTreeTextHelper>;
declare function use_old_InterfaceDeclaration_IMergeTreeTextHelper(
    use: TypeOnly<old.IMergeTreeTextHelper>): void;
use_old_InterfaceDeclaration_IMergeTreeTextHelper(
    get_current_InterfaceDeclaration_IMergeTreeTextHelper());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMoveInfo": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMoveInfo():
    TypeOnly<old.IMoveInfo>;
declare function use_current_InterfaceDeclaration_IMoveInfo(
    use: TypeOnly<current.IMoveInfo>): void;
use_current_InterfaceDeclaration_IMoveInfo(
    get_old_InterfaceDeclaration_IMoveInfo());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMoveInfo": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMoveInfo():
    TypeOnly<current.IMoveInfo>;
declare function use_old_InterfaceDeclaration_IMoveInfo(
    use: TypeOnly<old.IMoveInfo>): void;
use_old_InterfaceDeclaration_IMoveInfo(
    get_current_InterfaceDeclaration_IMoveInfo());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRBAugmentation": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IRBAugmentation():
    TypeOnly<old.IRBAugmentation<any,any>>;
declare function use_current_InterfaceDeclaration_IRBAugmentation(
    use: TypeOnly<current.IRBAugmentation<any,any>>): void;
use_current_InterfaceDeclaration_IRBAugmentation(
    get_old_InterfaceDeclaration_IRBAugmentation());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRBAugmentation": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IRBAugmentation():
    TypeOnly<current.IRBAugmentation<any,any>>;
declare function use_old_InterfaceDeclaration_IRBAugmentation(
    use: TypeOnly<old.IRBAugmentation<any,any>>): void;
use_old_InterfaceDeclaration_IRBAugmentation(
    get_current_InterfaceDeclaration_IRBAugmentation());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRBMatcher": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IRBMatcher():
    TypeOnly<old.IRBMatcher<any,any>>;
declare function use_current_InterfaceDeclaration_IRBMatcher(
    use: TypeOnly<current.IRBMatcher<any,any>>): void;
use_current_InterfaceDeclaration_IRBMatcher(
    get_old_InterfaceDeclaration_IRBMatcher());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRBMatcher": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IRBMatcher():
    TypeOnly<current.IRBMatcher<any,any>>;
declare function use_old_InterfaceDeclaration_IRBMatcher(
    use: TypeOnly<old.IRBMatcher<any,any>>): void;
use_old_InterfaceDeclaration_IRBMatcher(
    get_current_InterfaceDeclaration_IRBMatcher());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRelativePosition": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IRelativePosition():
    TypeOnly<old.IRelativePosition>;
declare function use_current_InterfaceDeclaration_IRelativePosition(
    use: TypeOnly<current.IRelativePosition>): void;
use_current_InterfaceDeclaration_IRelativePosition(
    get_old_InterfaceDeclaration_IRelativePosition());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRelativePosition": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IRelativePosition():
    TypeOnly<current.IRelativePosition>;
declare function use_old_InterfaceDeclaration_IRelativePosition(
    use: TypeOnly<old.IRelativePosition>): void;
use_old_InterfaceDeclaration_IRelativePosition(
    get_current_InterfaceDeclaration_IRelativePosition());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRemovalInfo": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IRemovalInfo():
    TypeOnly<old.IRemovalInfo>;
declare function use_current_InterfaceDeclaration_IRemovalInfo(
    use: TypeOnly<current.IRemovalInfo>): void;
use_current_InterfaceDeclaration_IRemovalInfo(
    get_old_InterfaceDeclaration_IRemovalInfo());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRemovalInfo": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IRemovalInfo():
    TypeOnly<current.IRemovalInfo>;
declare function use_old_InterfaceDeclaration_IRemovalInfo(
    use: TypeOnly<old.IRemovalInfo>): void;
use_old_InterfaceDeclaration_IRemovalInfo(
    get_current_InterfaceDeclaration_IRemovalInfo());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISegment": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISegment():
    TypeOnly<old.ISegment>;
declare function use_current_InterfaceDeclaration_ISegment(
    use: TypeOnly<current.ISegment>): void;
use_current_InterfaceDeclaration_ISegment(
    get_old_InterfaceDeclaration_ISegment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISegment": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISegment():
    TypeOnly<current.ISegment>;
declare function use_old_InterfaceDeclaration_ISegment(
    use: TypeOnly<old.ISegment>): void;
use_old_InterfaceDeclaration_ISegment(
    get_current_InterfaceDeclaration_ISegment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISegmentAction": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISegmentAction():
    TypeOnly<old.ISegmentAction<any>>;
declare function use_current_InterfaceDeclaration_ISegmentAction(
    use: TypeOnly<current.ISegmentAction<any>>): void;
use_current_InterfaceDeclaration_ISegmentAction(
    get_old_InterfaceDeclaration_ISegmentAction());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISegmentAction": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISegmentAction():
    TypeOnly<current.ISegmentAction<any>>;
declare function use_old_InterfaceDeclaration_ISegmentAction(
    use: TypeOnly<old.ISegmentAction<any>>): void;
use_old_InterfaceDeclaration_ISegmentAction(
    get_current_InterfaceDeclaration_ISegmentAction());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITrackingGroup": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ITrackingGroup():
    TypeOnly<old.ITrackingGroup>;
declare function use_current_InterfaceDeclaration_ITrackingGroup(
    use: TypeOnly<current.ITrackingGroup>): void;
use_current_InterfaceDeclaration_ITrackingGroup(
    get_old_InterfaceDeclaration_ITrackingGroup());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITrackingGroup": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ITrackingGroup():
    TypeOnly<current.ITrackingGroup>;
declare function use_old_InterfaceDeclaration_ITrackingGroup(
    use: TypeOnly<old.ITrackingGroup>): void;
use_old_InterfaceDeclaration_ITrackingGroup(
    get_current_InterfaceDeclaration_ITrackingGroup());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_KeyComparer": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_KeyComparer():
    TypeOnly<old.KeyComparer<any>>;
declare function use_current_InterfaceDeclaration_KeyComparer(
    use: TypeOnly<current.KeyComparer<any>>): void;
use_current_InterfaceDeclaration_KeyComparer(
    get_old_InterfaceDeclaration_KeyComparer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_KeyComparer": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_KeyComparer():
    TypeOnly<current.KeyComparer<any>>;
declare function use_old_InterfaceDeclaration_KeyComparer(
    use: TypeOnly<old.KeyComparer<any>>): void;
use_old_InterfaceDeclaration_KeyComparer(
    get_current_InterfaceDeclaration_KeyComparer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LocalReferenceCollection": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_LocalReferenceCollection():
    TypeOnly<current.LocalReferenceCollection>;
declare function use_old_ClassDeclaration_LocalReferenceCollection(
    use: TypeOnly<old.LocalReferenceCollection>): void;
use_old_ClassDeclaration_LocalReferenceCollection(
    get_current_ClassDeclaration_LocalReferenceCollection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_LocalReferencePosition": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_LocalReferencePosition():
    TypeOnly<current.LocalReferencePosition>;
declare function use_old_InterfaceDeclaration_LocalReferencePosition(
    use: TypeOnly<old.LocalReferencePosition>): void;
use_old_InterfaceDeclaration_LocalReferencePosition(
    get_current_InterfaceDeclaration_LocalReferencePosition());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MapLike": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_MapLike():
    TypeOnly<old.MapLike<any>>;
declare function use_current_InterfaceDeclaration_MapLike(
    use: TypeOnly<current.MapLike<any>>): void;
use_current_InterfaceDeclaration_MapLike(
    get_old_InterfaceDeclaration_MapLike());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MapLike": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_MapLike():
    TypeOnly<current.MapLike<any>>;
declare function use_old_InterfaceDeclaration_MapLike(
    use: TypeOnly<old.MapLike<any>>): void;
use_old_InterfaceDeclaration_MapLike(
    get_current_InterfaceDeclaration_MapLike());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Marker": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_Marker():
    TypeOnly<old.Marker>;
declare function use_current_ClassDeclaration_Marker(
    use: TypeOnly<current.Marker>): void;
use_current_ClassDeclaration_Marker(
    get_old_ClassDeclaration_Marker());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Marker": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_Marker():
    TypeOnly<current.Marker>;
declare function use_old_ClassDeclaration_Marker(
    use: TypeOnly<old.Marker>): void;
use_old_ClassDeclaration_Marker(
    get_current_ClassDeclaration_Marker());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MergeNode": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_MergeNode():
    TypeOnly<old.MergeNode>;
declare function use_current_ClassDeclaration_MergeNode(
    use: TypeOnly<current.MergeNode>): void;
use_current_ClassDeclaration_MergeNode(
    get_old_ClassDeclaration_MergeNode());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MergeNode": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_MergeNode():
    TypeOnly<current.MergeNode>;
declare function use_old_ClassDeclaration_MergeNode(
    use: TypeOnly<old.MergeNode>): void;
use_old_ClassDeclaration_MergeNode(
    get_current_ClassDeclaration_MergeNode());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaOperationType": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_MergeTreeDeltaOperationType():
    TypeOnly<old.MergeTreeDeltaOperationType>;
declare function use_current_TypeAliasDeclaration_MergeTreeDeltaOperationType(
    use: TypeOnly<current.MergeTreeDeltaOperationType>): void;
use_current_TypeAliasDeclaration_MergeTreeDeltaOperationType(
    get_old_TypeAliasDeclaration_MergeTreeDeltaOperationType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaOperationType": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_MergeTreeDeltaOperationType():
    TypeOnly<current.MergeTreeDeltaOperationType>;
declare function use_old_TypeAliasDeclaration_MergeTreeDeltaOperationType(
    use: TypeOnly<old.MergeTreeDeltaOperationType>): void;
use_old_TypeAliasDeclaration_MergeTreeDeltaOperationType(
    get_current_TypeAliasDeclaration_MergeTreeDeltaOperationType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaOperationTypes": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_MergeTreeDeltaOperationTypes():
    TypeOnly<old.MergeTreeDeltaOperationTypes>;
declare function use_current_TypeAliasDeclaration_MergeTreeDeltaOperationTypes(
    use: TypeOnly<current.MergeTreeDeltaOperationTypes>): void;
use_current_TypeAliasDeclaration_MergeTreeDeltaOperationTypes(
    get_old_TypeAliasDeclaration_MergeTreeDeltaOperationTypes());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaOperationTypes": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_MergeTreeDeltaOperationTypes():
    TypeOnly<current.MergeTreeDeltaOperationTypes>;
declare function use_old_TypeAliasDeclaration_MergeTreeDeltaOperationTypes(
    use: TypeOnly<old.MergeTreeDeltaOperationTypes>): void;
use_old_TypeAliasDeclaration_MergeTreeDeltaOperationTypes(
    get_current_TypeAliasDeclaration_MergeTreeDeltaOperationTypes());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaRevertible": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_MergeTreeDeltaRevertible():
    TypeOnly<old.MergeTreeDeltaRevertible>;
declare function use_current_TypeAliasDeclaration_MergeTreeDeltaRevertible(
    use: TypeOnly<current.MergeTreeDeltaRevertible>): void;
use_current_TypeAliasDeclaration_MergeTreeDeltaRevertible(
    get_old_TypeAliasDeclaration_MergeTreeDeltaRevertible());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaRevertible": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_MergeTreeDeltaRevertible():
    TypeOnly<current.MergeTreeDeltaRevertible>;
declare function use_old_TypeAliasDeclaration_MergeTreeDeltaRevertible(
    use: TypeOnly<old.MergeTreeDeltaRevertible>): void;
use_old_TypeAliasDeclaration_MergeTreeDeltaRevertible(
    get_current_TypeAliasDeclaration_MergeTreeDeltaRevertible());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_MergeTreeDeltaType": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_MergeTreeDeltaType():
    TypeOnly<typeof old.MergeTreeDeltaType>;
declare function use_current_VariableDeclaration_MergeTreeDeltaType(
    use: TypeOnly<typeof current.MergeTreeDeltaType>): void;
use_current_VariableDeclaration_MergeTreeDeltaType(
    get_old_VariableDeclaration_MergeTreeDeltaType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_MergeTreeDeltaType": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_MergeTreeDeltaType():
    TypeOnly<typeof current.MergeTreeDeltaType>;
declare function use_old_VariableDeclaration_MergeTreeDeltaType(
    use: TypeOnly<typeof old.MergeTreeDeltaType>): void;
use_old_VariableDeclaration_MergeTreeDeltaType(
    get_current_VariableDeclaration_MergeTreeDeltaType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaType": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_MergeTreeDeltaType():
    TypeOnly<old.MergeTreeDeltaType>;
declare function use_current_TypeAliasDeclaration_MergeTreeDeltaType(
    use: TypeOnly<current.MergeTreeDeltaType>): void;
use_current_TypeAliasDeclaration_MergeTreeDeltaType(
    get_old_TypeAliasDeclaration_MergeTreeDeltaType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaType": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_MergeTreeDeltaType():
    TypeOnly<current.MergeTreeDeltaType>;
declare function use_old_TypeAliasDeclaration_MergeTreeDeltaType(
    use: TypeOnly<old.MergeTreeDeltaType>): void;
use_old_TypeAliasDeclaration_MergeTreeDeltaType(
    get_current_TypeAliasDeclaration_MergeTreeDeltaType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_MergeTreeMaintenanceType": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_MergeTreeMaintenanceType():
    TypeOnly<typeof old.MergeTreeMaintenanceType>;
declare function use_current_VariableDeclaration_MergeTreeMaintenanceType(
    use: TypeOnly<typeof current.MergeTreeMaintenanceType>): void;
use_current_VariableDeclaration_MergeTreeMaintenanceType(
    get_old_VariableDeclaration_MergeTreeMaintenanceType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_MergeTreeMaintenanceType": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_MergeTreeMaintenanceType():
    TypeOnly<typeof current.MergeTreeMaintenanceType>;
declare function use_old_VariableDeclaration_MergeTreeMaintenanceType(
    use: TypeOnly<typeof old.MergeTreeMaintenanceType>): void;
use_old_VariableDeclaration_MergeTreeMaintenanceType(
    get_current_VariableDeclaration_MergeTreeMaintenanceType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeMaintenanceType": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_MergeTreeMaintenanceType():
    TypeOnly<old.MergeTreeMaintenanceType>;
declare function use_current_TypeAliasDeclaration_MergeTreeMaintenanceType(
    use: TypeOnly<current.MergeTreeMaintenanceType>): void;
use_current_TypeAliasDeclaration_MergeTreeMaintenanceType(
    get_old_TypeAliasDeclaration_MergeTreeMaintenanceType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeMaintenanceType": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_MergeTreeMaintenanceType():
    TypeOnly<current.MergeTreeMaintenanceType>;
declare function use_old_TypeAliasDeclaration_MergeTreeMaintenanceType(
    use: TypeOnly<old.MergeTreeMaintenanceType>): void;
use_old_TypeAliasDeclaration_MergeTreeMaintenanceType(
    get_current_TypeAliasDeclaration_MergeTreeMaintenanceType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MergeTreeRevertibleDriver": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_MergeTreeRevertibleDriver():
    TypeOnly<old.MergeTreeRevertibleDriver>;
declare function use_current_InterfaceDeclaration_MergeTreeRevertibleDriver(
    use: TypeOnly<current.MergeTreeRevertibleDriver>): void;
use_current_InterfaceDeclaration_MergeTreeRevertibleDriver(
    get_old_InterfaceDeclaration_MergeTreeRevertibleDriver());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MergeTreeRevertibleDriver": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_MergeTreeRevertibleDriver():
    TypeOnly<current.MergeTreeRevertibleDriver>;
declare function use_old_InterfaceDeclaration_MergeTreeRevertibleDriver(
    use: TypeOnly<old.MergeTreeRevertibleDriver>): void;
use_old_InterfaceDeclaration_MergeTreeRevertibleDriver(
    get_current_InterfaceDeclaration_MergeTreeRevertibleDriver());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_PropertiesManager": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_PropertiesManager():
    TypeOnly<old.PropertiesManager>;
declare function use_current_ClassDeclaration_PropertiesManager(
    use: TypeOnly<current.PropertiesManager>): void;
use_current_ClassDeclaration_PropertiesManager(
    get_old_ClassDeclaration_PropertiesManager());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_PropertiesManager": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_PropertiesManager():
    TypeOnly<current.PropertiesManager>;
declare function use_old_ClassDeclaration_PropertiesManager(
    use: TypeOnly<old.PropertiesManager>): void;
use_old_ClassDeclaration_PropertiesManager(
    get_current_ClassDeclaration_PropertiesManager());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_PropertiesRollback": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_PropertiesRollback():
    TypeOnly<old.PropertiesRollback>;
declare function use_current_EnumDeclaration_PropertiesRollback(
    use: TypeOnly<current.PropertiesRollback>): void;
use_current_EnumDeclaration_PropertiesRollback(
    get_old_EnumDeclaration_PropertiesRollback());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_PropertiesRollback": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_PropertiesRollback():
    TypeOnly<current.PropertiesRollback>;
declare function use_old_EnumDeclaration_PropertiesRollback(
    use: TypeOnly<old.PropertiesRollback>): void;
use_old_EnumDeclaration_PropertiesRollback(
    get_current_EnumDeclaration_PropertiesRollback());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_Property": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_Property():
    TypeOnly<old.Property<any,any>>;
declare function use_current_InterfaceDeclaration_Property(
    use: TypeOnly<current.Property<any,any>>): void;
use_current_InterfaceDeclaration_Property(
    get_old_InterfaceDeclaration_Property());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_Property": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_Property():
    TypeOnly<current.Property<any,any>>;
declare function use_old_InterfaceDeclaration_Property(
    use: TypeOnly<old.Property<any,any>>): void;
use_old_InterfaceDeclaration_Property(
    get_current_InterfaceDeclaration_Property());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_PropertyAction": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_PropertyAction():
    TypeOnly<old.PropertyAction<any,any>>;
declare function use_current_InterfaceDeclaration_PropertyAction(
    use: TypeOnly<current.PropertyAction<any,any>>): void;
use_current_InterfaceDeclaration_PropertyAction(
    get_old_InterfaceDeclaration_PropertyAction());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_PropertyAction": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_PropertyAction():
    TypeOnly<current.PropertyAction<any,any>>;
declare function use_old_InterfaceDeclaration_PropertyAction(
    use: TypeOnly<old.PropertyAction<any,any>>): void;
use_old_InterfaceDeclaration_PropertyAction(
    get_current_InterfaceDeclaration_PropertyAction());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_PropertySet": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_PropertySet():
    TypeOnly<old.PropertySet>;
declare function use_current_TypeAliasDeclaration_PropertySet(
    use: TypeOnly<current.PropertySet>): void;
use_current_TypeAliasDeclaration_PropertySet(
    get_old_TypeAliasDeclaration_PropertySet());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_PropertySet": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_PropertySet():
    TypeOnly<current.PropertySet>;
declare function use_old_TypeAliasDeclaration_PropertySet(
    use: TypeOnly<old.PropertySet>): void;
use_old_TypeAliasDeclaration_PropertySet(
    get_current_TypeAliasDeclaration_PropertySet());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_QProperty": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_QProperty():
    TypeOnly<old.QProperty<any,any>>;
declare function use_current_InterfaceDeclaration_QProperty(
    use: TypeOnly<current.QProperty<any,any>>): void;
use_current_InterfaceDeclaration_QProperty(
    get_old_InterfaceDeclaration_QProperty());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_QProperty": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_QProperty():
    TypeOnly<current.QProperty<any,any>>;
declare function use_old_InterfaceDeclaration_QProperty(
    use: TypeOnly<old.QProperty<any,any>>): void;
use_old_InterfaceDeclaration_QProperty(
    get_current_InterfaceDeclaration_QProperty());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_RBColor": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_RBColor():
    TypeOnly<typeof old.RBColor>;
declare function use_current_VariableDeclaration_RBColor(
    use: TypeOnly<typeof current.RBColor>): void;
use_current_VariableDeclaration_RBColor(
    get_old_VariableDeclaration_RBColor());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_RBColor": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_RBColor():
    TypeOnly<typeof current.RBColor>;
declare function use_old_VariableDeclaration_RBColor(
    use: TypeOnly<typeof old.RBColor>): void;
use_old_VariableDeclaration_RBColor(
    get_current_VariableDeclaration_RBColor());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_RBColor": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_RBColor():
    TypeOnly<old.RBColor>;
declare function use_current_TypeAliasDeclaration_RBColor(
    use: TypeOnly<current.RBColor>): void;
use_current_TypeAliasDeclaration_RBColor(
    get_old_TypeAliasDeclaration_RBColor());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_RBColor": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_RBColor():
    TypeOnly<current.RBColor>;
declare function use_old_TypeAliasDeclaration_RBColor(
    use: TypeOnly<old.RBColor>): void;
use_old_TypeAliasDeclaration_RBColor(
    get_current_TypeAliasDeclaration_RBColor());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_RBNode": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_RBNode():
    TypeOnly<old.RBNode<any,any>>;
declare function use_current_InterfaceDeclaration_RBNode(
    use: TypeOnly<current.RBNode<any,any>>): void;
use_current_InterfaceDeclaration_RBNode(
    get_old_InterfaceDeclaration_RBNode());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_RBNode": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_RBNode():
    TypeOnly<current.RBNode<any,any>>;
declare function use_old_InterfaceDeclaration_RBNode(
    use: TypeOnly<old.RBNode<any,any>>): void;
use_old_InterfaceDeclaration_RBNode(
    get_current_InterfaceDeclaration_RBNode());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_RBNodeActions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_RBNodeActions():
    TypeOnly<old.RBNodeActions<any,any>>;
declare function use_current_InterfaceDeclaration_RBNodeActions(
    use: TypeOnly<current.RBNodeActions<any,any>>): void;
use_current_InterfaceDeclaration_RBNodeActions(
    get_old_InterfaceDeclaration_RBNodeActions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_RBNodeActions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_RBNodeActions():
    TypeOnly<current.RBNodeActions<any,any>>;
declare function use_old_InterfaceDeclaration_RBNodeActions(
    use: TypeOnly<old.RBNodeActions<any,any>>): void;
use_old_InterfaceDeclaration_RBNodeActions(
    get_current_InterfaceDeclaration_RBNodeActions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_RedBlackTree": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_RedBlackTree():
    TypeOnly<old.RedBlackTree<any,any>>;
declare function use_current_ClassDeclaration_RedBlackTree(
    use: TypeOnly<current.RedBlackTree<any,any>>): void;
use_current_ClassDeclaration_RedBlackTree(
    get_old_ClassDeclaration_RedBlackTree());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_RedBlackTree": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_RedBlackTree():
    TypeOnly<current.RedBlackTree<any,any>>;
declare function use_old_ClassDeclaration_RedBlackTree(
    use: TypeOnly<old.RedBlackTree<any,any>>): void;
use_old_ClassDeclaration_RedBlackTree(
    get_current_ClassDeclaration_RedBlackTree());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ReferencePosition": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ReferencePosition():
    TypeOnly<old.ReferencePosition>;
declare function use_current_InterfaceDeclaration_ReferencePosition(
    use: TypeOnly<current.ReferencePosition>): void;
use_current_InterfaceDeclaration_ReferencePosition(
    get_old_InterfaceDeclaration_ReferencePosition());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ReferencePosition": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ReferencePosition():
    TypeOnly<current.ReferencePosition>;
declare function use_old_InterfaceDeclaration_ReferencePosition(
    use: TypeOnly<old.ReferencePosition>): void;
use_old_InterfaceDeclaration_ReferencePosition(
    get_current_InterfaceDeclaration_ReferencePosition());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_ReferenceType": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_ReferenceType():
    TypeOnly<old.ReferenceType>;
declare function use_current_EnumDeclaration_ReferenceType(
    use: TypeOnly<current.ReferenceType>): void;
use_current_EnumDeclaration_ReferenceType(
    get_old_EnumDeclaration_ReferenceType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_ReferenceType": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_ReferenceType():
    TypeOnly<current.ReferenceType>;
declare function use_old_EnumDeclaration_ReferenceType(
    use: TypeOnly<old.ReferenceType>): void;
use_old_EnumDeclaration_ReferenceType(
    get_current_EnumDeclaration_ReferenceType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SegmentGroup": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SegmentGroup():
    TypeOnly<old.SegmentGroup>;
declare function use_current_InterfaceDeclaration_SegmentGroup(
    use: TypeOnly<current.SegmentGroup>): void;
use_current_InterfaceDeclaration_SegmentGroup(
    get_old_InterfaceDeclaration_SegmentGroup());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SegmentGroup": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SegmentGroup():
    TypeOnly<current.SegmentGroup>;
declare function use_old_InterfaceDeclaration_SegmentGroup(
    use: TypeOnly<old.SegmentGroup>): void;
use_old_InterfaceDeclaration_SegmentGroup(
    get_current_InterfaceDeclaration_SegmentGroup());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SegmentGroupCollection": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SegmentGroupCollection():
    TypeOnly<old.SegmentGroupCollection>;
declare function use_current_ClassDeclaration_SegmentGroupCollection(
    use: TypeOnly<current.SegmentGroupCollection>): void;
use_current_ClassDeclaration_SegmentGroupCollection(
    get_old_ClassDeclaration_SegmentGroupCollection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SegmentGroupCollection": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SegmentGroupCollection():
    TypeOnly<current.SegmentGroupCollection>;
declare function use_old_ClassDeclaration_SegmentGroupCollection(
    use: TypeOnly<old.SegmentGroupCollection>): void;
use_old_ClassDeclaration_SegmentGroupCollection(
    get_current_ClassDeclaration_SegmentGroupCollection());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SequenceOffsets": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SequenceOffsets():
    TypeOnly<old.SequenceOffsets>;
declare function use_current_InterfaceDeclaration_SequenceOffsets(
    use: TypeOnly<current.SequenceOffsets>): void;
use_current_InterfaceDeclaration_SequenceOffsets(
    get_old_InterfaceDeclaration_SequenceOffsets());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SequenceOffsets": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SequenceOffsets():
    TypeOnly<current.SequenceOffsets>;
declare function use_old_InterfaceDeclaration_SequenceOffsets(
    use: TypeOnly<old.SequenceOffsets>): void;
use_old_InterfaceDeclaration_SequenceOffsets(
    get_current_InterfaceDeclaration_SequenceOffsets());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SerializedAttributionCollection": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SerializedAttributionCollection():
    TypeOnly<old.SerializedAttributionCollection>;
declare function use_current_InterfaceDeclaration_SerializedAttributionCollection(
    use: TypeOnly<current.SerializedAttributionCollection>): void;
use_current_InterfaceDeclaration_SerializedAttributionCollection(
    get_old_InterfaceDeclaration_SerializedAttributionCollection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SerializedAttributionCollection": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SerializedAttributionCollection():
    TypeOnly<current.SerializedAttributionCollection>;
declare function use_old_InterfaceDeclaration_SerializedAttributionCollection(
    use: TypeOnly<old.SerializedAttributionCollection>): void;
use_old_InterfaceDeclaration_SerializedAttributionCollection(
    get_current_InterfaceDeclaration_SerializedAttributionCollection());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_SlidingPreference": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_SlidingPreference():
    TypeOnly<typeof old.SlidingPreference>;
declare function use_current_VariableDeclaration_SlidingPreference(
    use: TypeOnly<typeof current.SlidingPreference>): void;
use_current_VariableDeclaration_SlidingPreference(
    get_old_VariableDeclaration_SlidingPreference());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_SlidingPreference": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_SlidingPreference():
    TypeOnly<typeof current.SlidingPreference>;
declare function use_old_VariableDeclaration_SlidingPreference(
    use: TypeOnly<typeof old.SlidingPreference>): void;
use_old_VariableDeclaration_SlidingPreference(
    get_current_VariableDeclaration_SlidingPreference());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SlidingPreference": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SlidingPreference():
    TypeOnly<old.SlidingPreference>;
declare function use_current_TypeAliasDeclaration_SlidingPreference(
    use: TypeOnly<current.SlidingPreference>): void;
use_current_TypeAliasDeclaration_SlidingPreference(
    get_old_TypeAliasDeclaration_SlidingPreference());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SlidingPreference": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SlidingPreference():
    TypeOnly<current.SlidingPreference>;
declare function use_old_TypeAliasDeclaration_SlidingPreference(
    use: TypeOnly<old.SlidingPreference>): void;
use_old_TypeAliasDeclaration_SlidingPreference(
    get_current_TypeAliasDeclaration_SlidingPreference());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SortedDictionary": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SortedDictionary():
    TypeOnly<old.SortedDictionary<any,any>>;
declare function use_current_InterfaceDeclaration_SortedDictionary(
    use: TypeOnly<current.SortedDictionary<any,any>>): void;
use_current_InterfaceDeclaration_SortedDictionary(
    get_old_InterfaceDeclaration_SortedDictionary());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SortedDictionary": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SortedDictionary():
    TypeOnly<current.SortedDictionary<any,any>>;
declare function use_old_InterfaceDeclaration_SortedDictionary(
    use: TypeOnly<old.SortedDictionary<any,any>>): void;
use_old_InterfaceDeclaration_SortedDictionary(
    get_current_InterfaceDeclaration_SortedDictionary());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SortedSegmentSet": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SortedSegmentSet():
    TypeOnly<old.SortedSegmentSet>;
declare function use_current_ClassDeclaration_SortedSegmentSet(
    use: TypeOnly<current.SortedSegmentSet>): void;
use_current_ClassDeclaration_SortedSegmentSet(
    get_old_ClassDeclaration_SortedSegmentSet());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SortedSegmentSet": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SortedSegmentSet():
    TypeOnly<current.SortedSegmentSet>;
declare function use_old_ClassDeclaration_SortedSegmentSet(
    use: TypeOnly<old.SortedSegmentSet>): void;
use_old_ClassDeclaration_SortedSegmentSet(
    get_current_ClassDeclaration_SortedSegmentSet());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SortedSegmentSetItem": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SortedSegmentSetItem():
    TypeOnly<old.SortedSegmentSetItem>;
declare function use_current_TypeAliasDeclaration_SortedSegmentSetItem(
    use: TypeOnly<current.SortedSegmentSetItem>): void;
use_current_TypeAliasDeclaration_SortedSegmentSetItem(
    get_old_TypeAliasDeclaration_SortedSegmentSetItem());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SortedSegmentSetItem": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SortedSegmentSetItem():
    TypeOnly<current.SortedSegmentSetItem>;
declare function use_old_TypeAliasDeclaration_SortedSegmentSetItem(
    use: TypeOnly<old.SortedSegmentSetItem>): void;
use_old_TypeAliasDeclaration_SortedSegmentSetItem(
    get_current_TypeAliasDeclaration_SortedSegmentSetItem());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SortedSet": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SortedSet():
    TypeOnly<old.SortedSet<any,any>>;
declare function use_current_ClassDeclaration_SortedSet(
    use: TypeOnly<current.SortedSet<any,any>>): void;
use_current_ClassDeclaration_SortedSet(
    get_old_ClassDeclaration_SortedSet());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SortedSet": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SortedSet():
    TypeOnly<current.SortedSet<any,any>>;
declare function use_old_ClassDeclaration_SortedSet(
    use: TypeOnly<old.SortedSet<any,any>>): void;
use_old_ClassDeclaration_SortedSet(
    get_current_ClassDeclaration_SortedSet());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TextSegment": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TextSegment():
    TypeOnly<old.TextSegment>;
declare function use_current_ClassDeclaration_TextSegment(
    use: TypeOnly<current.TextSegment>): void;
use_current_ClassDeclaration_TextSegment(
    get_old_ClassDeclaration_TextSegment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TextSegment": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TextSegment():
    TypeOnly<current.TextSegment>;
declare function use_old_ClassDeclaration_TextSegment(
    use: TypeOnly<old.TextSegment>): void;
use_old_ClassDeclaration_TextSegment(
    get_current_ClassDeclaration_TextSegment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_Trackable": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_Trackable():
    TypeOnly<old.Trackable>;
declare function use_current_TypeAliasDeclaration_Trackable(
    use: TypeOnly<current.Trackable>): void;
use_current_TypeAliasDeclaration_Trackable(
    get_old_TypeAliasDeclaration_Trackable());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_Trackable": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_Trackable():
    TypeOnly<current.Trackable>;
declare function use_old_TypeAliasDeclaration_Trackable(
    use: TypeOnly<old.Trackable>): void;
use_old_TypeAliasDeclaration_Trackable(
    get_current_TypeAliasDeclaration_Trackable());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TrackingGroup": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TrackingGroup():
    TypeOnly<old.TrackingGroup>;
declare function use_current_ClassDeclaration_TrackingGroup(
    use: TypeOnly<current.TrackingGroup>): void;
use_current_ClassDeclaration_TrackingGroup(
    get_old_ClassDeclaration_TrackingGroup());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TrackingGroup": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TrackingGroup():
    TypeOnly<current.TrackingGroup>;
declare function use_old_ClassDeclaration_TrackingGroup(
    use: TypeOnly<old.TrackingGroup>): void;
use_old_ClassDeclaration_TrackingGroup(
    get_current_ClassDeclaration_TrackingGroup());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TrackingGroupCollection": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TrackingGroupCollection():
    TypeOnly<old.TrackingGroupCollection>;
declare function use_current_ClassDeclaration_TrackingGroupCollection(
    use: TypeOnly<current.TrackingGroupCollection>): void;
use_current_ClassDeclaration_TrackingGroupCollection(
    get_old_ClassDeclaration_TrackingGroupCollection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TrackingGroupCollection": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TrackingGroupCollection():
    TypeOnly<current.TrackingGroupCollection>;
declare function use_old_ClassDeclaration_TrackingGroupCollection(
    use: TypeOnly<old.TrackingGroupCollection>): void;
use_old_ClassDeclaration_TrackingGroupCollection(
    get_current_ClassDeclaration_TrackingGroupCollection());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_UnassignedSequenceNumber": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_UnassignedSequenceNumber():
    TypeOnly<typeof old.UnassignedSequenceNumber>;
declare function use_current_VariableDeclaration_UnassignedSequenceNumber(
    use: TypeOnly<typeof current.UnassignedSequenceNumber>): void;
use_current_VariableDeclaration_UnassignedSequenceNumber(
    get_old_VariableDeclaration_UnassignedSequenceNumber());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_UnassignedSequenceNumber": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_UnassignedSequenceNumber():
    TypeOnly<typeof current.UnassignedSequenceNumber>;
declare function use_old_VariableDeclaration_UnassignedSequenceNumber(
    use: TypeOnly<typeof old.UnassignedSequenceNumber>): void;
use_old_VariableDeclaration_UnassignedSequenceNumber(
    get_current_VariableDeclaration_UnassignedSequenceNumber());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_UniversalSequenceNumber": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_UniversalSequenceNumber():
    TypeOnly<typeof old.UniversalSequenceNumber>;
declare function use_current_VariableDeclaration_UniversalSequenceNumber(
    use: TypeOnly<typeof current.UniversalSequenceNumber>): void;
use_current_VariableDeclaration_UniversalSequenceNumber(
    get_old_VariableDeclaration_UniversalSequenceNumber());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_UniversalSequenceNumber": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_UniversalSequenceNumber():
    TypeOnly<typeof current.UniversalSequenceNumber>;
declare function use_old_VariableDeclaration_UniversalSequenceNumber(
    use: TypeOnly<typeof old.UniversalSequenceNumber>): void;
use_old_VariableDeclaration_UniversalSequenceNumber(
    get_current_VariableDeclaration_UniversalSequenceNumber());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_addProperties": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_addProperties():
    TypeOnly<typeof old.addProperties>;
declare function use_current_FunctionDeclaration_addProperties(
    use: TypeOnly<typeof current.addProperties>): void;
use_current_FunctionDeclaration_addProperties(
    get_old_FunctionDeclaration_addProperties());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_addProperties": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_addProperties():
    TypeOnly<typeof current.addProperties>;
declare function use_old_FunctionDeclaration_addProperties(
    use: TypeOnly<typeof old.addProperties>): void;
use_old_FunctionDeclaration_addProperties(
    get_current_FunctionDeclaration_addProperties());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendToMergeTreeDeltaRevertibles": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_appendToMergeTreeDeltaRevertibles():
    TypeOnly<typeof old.appendToMergeTreeDeltaRevertibles>;
declare function use_current_FunctionDeclaration_appendToMergeTreeDeltaRevertibles(
    use: TypeOnly<typeof current.appendToMergeTreeDeltaRevertibles>): void;
use_current_FunctionDeclaration_appendToMergeTreeDeltaRevertibles(
    get_old_FunctionDeclaration_appendToMergeTreeDeltaRevertibles());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendToMergeTreeDeltaRevertibles": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_appendToMergeTreeDeltaRevertibles():
    TypeOnly<typeof current.appendToMergeTreeDeltaRevertibles>;
declare function use_old_FunctionDeclaration_appendToMergeTreeDeltaRevertibles(
    use: TypeOnly<typeof old.appendToMergeTreeDeltaRevertibles>): void;
use_old_FunctionDeclaration_appendToMergeTreeDeltaRevertibles(
    get_current_FunctionDeclaration_appendToMergeTreeDeltaRevertibles());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_compareReferencePositions": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_compareReferencePositions():
    TypeOnly<typeof old.compareReferencePositions>;
declare function use_current_FunctionDeclaration_compareReferencePositions(
    use: TypeOnly<typeof current.compareReferencePositions>): void;
use_current_FunctionDeclaration_compareReferencePositions(
    get_old_FunctionDeclaration_compareReferencePositions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_compareReferencePositions": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_compareReferencePositions():
    TypeOnly<typeof current.compareReferencePositions>;
declare function use_old_FunctionDeclaration_compareReferencePositions(
    use: TypeOnly<typeof old.compareReferencePositions>): void;
use_old_FunctionDeclaration_compareReferencePositions(
    get_current_FunctionDeclaration_compareReferencePositions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createAnnotateRangeOp": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createAnnotateRangeOp():
    TypeOnly<typeof old.createAnnotateRangeOp>;
declare function use_current_FunctionDeclaration_createAnnotateRangeOp(
    use: TypeOnly<typeof current.createAnnotateRangeOp>): void;
use_current_FunctionDeclaration_createAnnotateRangeOp(
    get_old_FunctionDeclaration_createAnnotateRangeOp());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createAnnotateRangeOp": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createAnnotateRangeOp():
    TypeOnly<typeof current.createAnnotateRangeOp>;
declare function use_old_FunctionDeclaration_createAnnotateRangeOp(
    use: TypeOnly<typeof old.createAnnotateRangeOp>): void;
use_old_FunctionDeclaration_createAnnotateRangeOp(
    get_current_FunctionDeclaration_createAnnotateRangeOp());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createDetachedLocalReferencePosition": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createDetachedLocalReferencePosition():
    TypeOnly<typeof old.createDetachedLocalReferencePosition>;
declare function use_current_FunctionDeclaration_createDetachedLocalReferencePosition(
    use: TypeOnly<typeof current.createDetachedLocalReferencePosition>): void;
use_current_FunctionDeclaration_createDetachedLocalReferencePosition(
    get_old_FunctionDeclaration_createDetachedLocalReferencePosition());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createDetachedLocalReferencePosition": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createDetachedLocalReferencePosition():
    TypeOnly<typeof current.createDetachedLocalReferencePosition>;
declare function use_old_FunctionDeclaration_createDetachedLocalReferencePosition(
    use: TypeOnly<typeof old.createDetachedLocalReferencePosition>): void;
use_old_FunctionDeclaration_createDetachedLocalReferencePosition(
    get_current_FunctionDeclaration_createDetachedLocalReferencePosition());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createGroupOp": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createGroupOp():
    TypeOnly<typeof old.createGroupOp>;
declare function use_current_FunctionDeclaration_createGroupOp(
    use: TypeOnly<typeof current.createGroupOp>): void;
use_current_FunctionDeclaration_createGroupOp(
    get_old_FunctionDeclaration_createGroupOp());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createGroupOp": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createGroupOp():
    TypeOnly<typeof current.createGroupOp>;
declare function use_old_FunctionDeclaration_createGroupOp(
    use: TypeOnly<typeof old.createGroupOp>): void;
use_old_FunctionDeclaration_createGroupOp(
    get_current_FunctionDeclaration_createGroupOp());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createInsertOnlyAttributionPolicy": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createInsertOnlyAttributionPolicy():
    TypeOnly<typeof old.createInsertOnlyAttributionPolicy>;
declare function use_current_FunctionDeclaration_createInsertOnlyAttributionPolicy(
    use: TypeOnly<typeof current.createInsertOnlyAttributionPolicy>): void;
use_current_FunctionDeclaration_createInsertOnlyAttributionPolicy(
    get_old_FunctionDeclaration_createInsertOnlyAttributionPolicy());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createInsertOnlyAttributionPolicy": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createInsertOnlyAttributionPolicy():
    TypeOnly<typeof current.createInsertOnlyAttributionPolicy>;
declare function use_old_FunctionDeclaration_createInsertOnlyAttributionPolicy(
    use: TypeOnly<typeof old.createInsertOnlyAttributionPolicy>): void;
use_old_FunctionDeclaration_createInsertOnlyAttributionPolicy(
    get_current_FunctionDeclaration_createInsertOnlyAttributionPolicy());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createInsertOp": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createInsertOp():
    TypeOnly<typeof old.createInsertOp>;
declare function use_current_FunctionDeclaration_createInsertOp(
    use: TypeOnly<typeof current.createInsertOp>): void;
use_current_FunctionDeclaration_createInsertOp(
    get_old_FunctionDeclaration_createInsertOp());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createInsertOp": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createInsertOp():
    TypeOnly<typeof current.createInsertOp>;
declare function use_old_FunctionDeclaration_createInsertOp(
    use: TypeOnly<typeof old.createInsertOp>): void;
use_old_FunctionDeclaration_createInsertOp(
    get_current_FunctionDeclaration_createInsertOp());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createInsertSegmentOp": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createInsertSegmentOp():
    TypeOnly<typeof old.createInsertSegmentOp>;
declare function use_current_FunctionDeclaration_createInsertSegmentOp(
    use: TypeOnly<typeof current.createInsertSegmentOp>): void;
use_current_FunctionDeclaration_createInsertSegmentOp(
    get_old_FunctionDeclaration_createInsertSegmentOp());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createInsertSegmentOp": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createInsertSegmentOp():
    TypeOnly<typeof current.createInsertSegmentOp>;
declare function use_old_FunctionDeclaration_createInsertSegmentOp(
    use: TypeOnly<typeof old.createInsertSegmentOp>): void;
use_old_FunctionDeclaration_createInsertSegmentOp(
    get_current_FunctionDeclaration_createInsertSegmentOp());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createMap": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createMap():
    TypeOnly<typeof old.createMap>;
declare function use_current_FunctionDeclaration_createMap(
    use: TypeOnly<typeof current.createMap>): void;
use_current_FunctionDeclaration_createMap(
    get_old_FunctionDeclaration_createMap());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createMap": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createMap():
    TypeOnly<typeof current.createMap>;
declare function use_old_FunctionDeclaration_createMap(
    use: TypeOnly<typeof old.createMap>): void;
use_old_FunctionDeclaration_createMap(
    get_current_FunctionDeclaration_createMap());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createObliterateRangeOp": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createObliterateRangeOp():
    TypeOnly<typeof old.createObliterateRangeOp>;
declare function use_current_FunctionDeclaration_createObliterateRangeOp(
    use: TypeOnly<typeof current.createObliterateRangeOp>): void;
use_current_FunctionDeclaration_createObliterateRangeOp(
    get_old_FunctionDeclaration_createObliterateRangeOp());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createObliterateRangeOp": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createObliterateRangeOp():
    TypeOnly<typeof current.createObliterateRangeOp>;
declare function use_old_FunctionDeclaration_createObliterateRangeOp(
    use: TypeOnly<typeof old.createObliterateRangeOp>): void;
use_old_FunctionDeclaration_createObliterateRangeOp(
    get_current_FunctionDeclaration_createObliterateRangeOp());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createPropertyTrackingAndInsertionAttributionPolicyFactory": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createPropertyTrackingAndInsertionAttributionPolicyFactory():
    TypeOnly<typeof old.createPropertyTrackingAndInsertionAttributionPolicyFactory>;
declare function use_current_FunctionDeclaration_createPropertyTrackingAndInsertionAttributionPolicyFactory(
    use: TypeOnly<typeof current.createPropertyTrackingAndInsertionAttributionPolicyFactory>): void;
use_current_FunctionDeclaration_createPropertyTrackingAndInsertionAttributionPolicyFactory(
    get_old_FunctionDeclaration_createPropertyTrackingAndInsertionAttributionPolicyFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createPropertyTrackingAndInsertionAttributionPolicyFactory": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createPropertyTrackingAndInsertionAttributionPolicyFactory():
    TypeOnly<typeof current.createPropertyTrackingAndInsertionAttributionPolicyFactory>;
declare function use_old_FunctionDeclaration_createPropertyTrackingAndInsertionAttributionPolicyFactory(
    use: TypeOnly<typeof old.createPropertyTrackingAndInsertionAttributionPolicyFactory>): void;
use_old_FunctionDeclaration_createPropertyTrackingAndInsertionAttributionPolicyFactory(
    get_current_FunctionDeclaration_createPropertyTrackingAndInsertionAttributionPolicyFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createPropertyTrackingAttributionPolicyFactory": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createPropertyTrackingAttributionPolicyFactory():
    TypeOnly<typeof old.createPropertyTrackingAttributionPolicyFactory>;
declare function use_current_FunctionDeclaration_createPropertyTrackingAttributionPolicyFactory(
    use: TypeOnly<typeof current.createPropertyTrackingAttributionPolicyFactory>): void;
use_current_FunctionDeclaration_createPropertyTrackingAttributionPolicyFactory(
    get_old_FunctionDeclaration_createPropertyTrackingAttributionPolicyFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createPropertyTrackingAttributionPolicyFactory": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createPropertyTrackingAttributionPolicyFactory():
    TypeOnly<typeof current.createPropertyTrackingAttributionPolicyFactory>;
declare function use_old_FunctionDeclaration_createPropertyTrackingAttributionPolicyFactory(
    use: TypeOnly<typeof old.createPropertyTrackingAttributionPolicyFactory>): void;
use_old_FunctionDeclaration_createPropertyTrackingAttributionPolicyFactory(
    get_current_FunctionDeclaration_createPropertyTrackingAttributionPolicyFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createRemoveRangeOp": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createRemoveRangeOp():
    TypeOnly<typeof old.createRemoveRangeOp>;
declare function use_current_FunctionDeclaration_createRemoveRangeOp(
    use: TypeOnly<typeof current.createRemoveRangeOp>): void;
use_current_FunctionDeclaration_createRemoveRangeOp(
    get_old_FunctionDeclaration_createRemoveRangeOp());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createRemoveRangeOp": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createRemoveRangeOp():
    TypeOnly<typeof current.createRemoveRangeOp>;
declare function use_old_FunctionDeclaration_createRemoveRangeOp(
    use: TypeOnly<typeof old.createRemoveRangeOp>): void;
use_old_FunctionDeclaration_createRemoveRangeOp(
    get_current_FunctionDeclaration_createRemoveRangeOp());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_debugMarkerToString": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_debugMarkerToString():
    TypeOnly<typeof old.debugMarkerToString>;
declare function use_current_FunctionDeclaration_debugMarkerToString(
    use: TypeOnly<typeof current.debugMarkerToString>): void;
use_current_FunctionDeclaration_debugMarkerToString(
    get_old_FunctionDeclaration_debugMarkerToString());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_debugMarkerToString": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_debugMarkerToString():
    TypeOnly<typeof current.debugMarkerToString>;
declare function use_old_FunctionDeclaration_debugMarkerToString(
    use: TypeOnly<typeof old.debugMarkerToString>): void;
use_old_FunctionDeclaration_debugMarkerToString(
    get_current_FunctionDeclaration_debugMarkerToString());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_discardMergeTreeDeltaRevertible": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_discardMergeTreeDeltaRevertible():
    TypeOnly<typeof old.discardMergeTreeDeltaRevertible>;
declare function use_current_FunctionDeclaration_discardMergeTreeDeltaRevertible(
    use: TypeOnly<typeof current.discardMergeTreeDeltaRevertible>): void;
use_current_FunctionDeclaration_discardMergeTreeDeltaRevertible(
    get_old_FunctionDeclaration_discardMergeTreeDeltaRevertible());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_discardMergeTreeDeltaRevertible": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_discardMergeTreeDeltaRevertible():
    TypeOnly<typeof current.discardMergeTreeDeltaRevertible>;
declare function use_old_FunctionDeclaration_discardMergeTreeDeltaRevertible(
    use: TypeOnly<typeof old.discardMergeTreeDeltaRevertible>): void;
use_old_FunctionDeclaration_discardMergeTreeDeltaRevertible(
    get_current_FunctionDeclaration_discardMergeTreeDeltaRevertible());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getSlideToSegoff": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getSlideToSegoff():
    TypeOnly<typeof old.getSlideToSegoff>;
declare function use_current_FunctionDeclaration_getSlideToSegoff(
    use: TypeOnly<typeof current.getSlideToSegoff>): void;
use_current_FunctionDeclaration_getSlideToSegoff(
    get_old_FunctionDeclaration_getSlideToSegoff());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getSlideToSegoff": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getSlideToSegoff():
    TypeOnly<typeof current.getSlideToSegoff>;
declare function use_old_FunctionDeclaration_getSlideToSegoff(
    use: TypeOnly<typeof old.getSlideToSegoff>): void;
use_old_FunctionDeclaration_getSlideToSegoff(
    get_current_FunctionDeclaration_getSlideToSegoff());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isMergeTreeDeltaRevertible": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_isMergeTreeDeltaRevertible():
    TypeOnly<typeof old.isMergeTreeDeltaRevertible>;
declare function use_current_FunctionDeclaration_isMergeTreeDeltaRevertible(
    use: TypeOnly<typeof current.isMergeTreeDeltaRevertible>): void;
use_current_FunctionDeclaration_isMergeTreeDeltaRevertible(
    get_old_FunctionDeclaration_isMergeTreeDeltaRevertible());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isMergeTreeDeltaRevertible": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_isMergeTreeDeltaRevertible():
    TypeOnly<typeof current.isMergeTreeDeltaRevertible>;
declare function use_old_FunctionDeclaration_isMergeTreeDeltaRevertible(
    use: TypeOnly<typeof old.isMergeTreeDeltaRevertible>): void;
use_old_FunctionDeclaration_isMergeTreeDeltaRevertible(
    get_current_FunctionDeclaration_isMergeTreeDeltaRevertible());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_matchProperties": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_matchProperties():
    TypeOnly<typeof old.matchProperties>;
declare function use_current_FunctionDeclaration_matchProperties(
    use: TypeOnly<typeof current.matchProperties>): void;
use_current_FunctionDeclaration_matchProperties(
    get_old_FunctionDeclaration_matchProperties());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_matchProperties": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_matchProperties():
    TypeOnly<typeof current.matchProperties>;
declare function use_old_FunctionDeclaration_matchProperties(
    use: TypeOnly<typeof old.matchProperties>): void;
use_old_FunctionDeclaration_matchProperties(
    get_current_FunctionDeclaration_matchProperties());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_maxReferencePosition": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_maxReferencePosition():
    TypeOnly<typeof old.maxReferencePosition>;
declare function use_current_FunctionDeclaration_maxReferencePosition(
    use: TypeOnly<typeof current.maxReferencePosition>): void;
use_current_FunctionDeclaration_maxReferencePosition(
    get_old_FunctionDeclaration_maxReferencePosition());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_maxReferencePosition": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_maxReferencePosition():
    TypeOnly<typeof current.maxReferencePosition>;
declare function use_old_FunctionDeclaration_maxReferencePosition(
    use: TypeOnly<typeof old.maxReferencePosition>): void;
use_old_FunctionDeclaration_maxReferencePosition(
    get_current_FunctionDeclaration_maxReferencePosition());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_minReferencePosition": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_minReferencePosition():
    TypeOnly<typeof old.minReferencePosition>;
declare function use_current_FunctionDeclaration_minReferencePosition(
    use: TypeOnly<typeof current.minReferencePosition>): void;
use_current_FunctionDeclaration_minReferencePosition(
    get_old_FunctionDeclaration_minReferencePosition());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_minReferencePosition": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_minReferencePosition():
    TypeOnly<typeof current.minReferencePosition>;
declare function use_old_FunctionDeclaration_minReferencePosition(
    use: TypeOnly<typeof old.minReferencePosition>): void;
use_old_FunctionDeclaration_minReferencePosition(
    get_current_FunctionDeclaration_minReferencePosition());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_refGetTileLabels": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_refGetTileLabels():
    TypeOnly<typeof old.refGetTileLabels>;
declare function use_current_VariableDeclaration_refGetTileLabels(
    use: TypeOnly<typeof current.refGetTileLabels>): void;
use_current_VariableDeclaration_refGetTileLabels(
    get_old_VariableDeclaration_refGetTileLabels());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_refGetTileLabels": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_refGetTileLabels():
    TypeOnly<typeof current.refGetTileLabels>;
declare function use_old_VariableDeclaration_refGetTileLabels(
    use: TypeOnly<typeof old.refGetTileLabels>): void;
use_old_VariableDeclaration_refGetTileLabels(
    get_current_VariableDeclaration_refGetTileLabels());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_refHasTileLabel": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_refHasTileLabel():
    TypeOnly<typeof old.refHasTileLabel>;
declare function use_current_FunctionDeclaration_refHasTileLabel(
    use: TypeOnly<typeof current.refHasTileLabel>): void;
use_current_FunctionDeclaration_refHasTileLabel(
    get_old_FunctionDeclaration_refHasTileLabel());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_refHasTileLabel": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_refHasTileLabel():
    TypeOnly<typeof current.refHasTileLabel>;
declare function use_old_FunctionDeclaration_refHasTileLabel(
    use: TypeOnly<typeof old.refHasTileLabel>): void;
use_old_FunctionDeclaration_refHasTileLabel(
    get_current_FunctionDeclaration_refHasTileLabel());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_refHasTileLabels": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_refHasTileLabels():
    TypeOnly<typeof old.refHasTileLabels>;
declare function use_current_FunctionDeclaration_refHasTileLabels(
    use: TypeOnly<typeof current.refHasTileLabels>): void;
use_current_FunctionDeclaration_refHasTileLabels(
    get_old_FunctionDeclaration_refHasTileLabels());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_refHasTileLabels": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_refHasTileLabels():
    TypeOnly<typeof current.refHasTileLabels>;
declare function use_old_FunctionDeclaration_refHasTileLabels(
    use: TypeOnly<typeof old.refHasTileLabels>): void;
use_old_FunctionDeclaration_refHasTileLabels(
    get_current_FunctionDeclaration_refHasTileLabels());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_refTypeIncludesFlag": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_refTypeIncludesFlag():
    TypeOnly<typeof old.refTypeIncludesFlag>;
declare function use_current_FunctionDeclaration_refTypeIncludesFlag(
    use: TypeOnly<typeof current.refTypeIncludesFlag>): void;
use_current_FunctionDeclaration_refTypeIncludesFlag(
    get_old_FunctionDeclaration_refTypeIncludesFlag());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_refTypeIncludesFlag": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_refTypeIncludesFlag():
    TypeOnly<typeof current.refTypeIncludesFlag>;
declare function use_old_FunctionDeclaration_refTypeIncludesFlag(
    use: TypeOnly<typeof old.refTypeIncludesFlag>): void;
use_old_FunctionDeclaration_refTypeIncludesFlag(
    get_current_FunctionDeclaration_refTypeIncludesFlag());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedMarkerIdKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_reservedMarkerIdKey():
    TypeOnly<typeof old.reservedMarkerIdKey>;
declare function use_current_VariableDeclaration_reservedMarkerIdKey(
    use: TypeOnly<typeof current.reservedMarkerIdKey>): void;
use_current_VariableDeclaration_reservedMarkerIdKey(
    get_old_VariableDeclaration_reservedMarkerIdKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedMarkerIdKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_reservedMarkerIdKey():
    TypeOnly<typeof current.reservedMarkerIdKey>;
declare function use_old_VariableDeclaration_reservedMarkerIdKey(
    use: TypeOnly<typeof old.reservedMarkerIdKey>): void;
use_old_VariableDeclaration_reservedMarkerIdKey(
    get_current_VariableDeclaration_reservedMarkerIdKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedMarkerSimpleTypeKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_reservedMarkerSimpleTypeKey():
    TypeOnly<typeof old.reservedMarkerSimpleTypeKey>;
declare function use_current_VariableDeclaration_reservedMarkerSimpleTypeKey(
    use: TypeOnly<typeof current.reservedMarkerSimpleTypeKey>): void;
use_current_VariableDeclaration_reservedMarkerSimpleTypeKey(
    get_old_VariableDeclaration_reservedMarkerSimpleTypeKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedMarkerSimpleTypeKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_reservedMarkerSimpleTypeKey():
    TypeOnly<typeof current.reservedMarkerSimpleTypeKey>;
declare function use_old_VariableDeclaration_reservedMarkerSimpleTypeKey(
    use: TypeOnly<typeof old.reservedMarkerSimpleTypeKey>): void;
use_old_VariableDeclaration_reservedMarkerSimpleTypeKey(
    get_current_VariableDeclaration_reservedMarkerSimpleTypeKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedRangeLabelsKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_reservedRangeLabelsKey():
    TypeOnly<typeof old.reservedRangeLabelsKey>;
declare function use_current_VariableDeclaration_reservedRangeLabelsKey(
    use: TypeOnly<typeof current.reservedRangeLabelsKey>): void;
use_current_VariableDeclaration_reservedRangeLabelsKey(
    get_old_VariableDeclaration_reservedRangeLabelsKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedRangeLabelsKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_reservedRangeLabelsKey():
    TypeOnly<typeof current.reservedRangeLabelsKey>;
declare function use_old_VariableDeclaration_reservedRangeLabelsKey(
    use: TypeOnly<typeof old.reservedRangeLabelsKey>): void;
use_old_VariableDeclaration_reservedRangeLabelsKey(
    get_current_VariableDeclaration_reservedRangeLabelsKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedTileLabelsKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_reservedTileLabelsKey():
    TypeOnly<typeof old.reservedTileLabelsKey>;
declare function use_current_VariableDeclaration_reservedTileLabelsKey(
    use: TypeOnly<typeof current.reservedTileLabelsKey>): void;
use_current_VariableDeclaration_reservedTileLabelsKey(
    get_old_VariableDeclaration_reservedTileLabelsKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedTileLabelsKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_reservedTileLabelsKey():
    TypeOnly<typeof current.reservedTileLabelsKey>;
declare function use_old_VariableDeclaration_reservedTileLabelsKey(
    use: TypeOnly<typeof old.reservedTileLabelsKey>): void;
use_old_VariableDeclaration_reservedTileLabelsKey(
    get_current_VariableDeclaration_reservedTileLabelsKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_revertMergeTreeDeltaRevertibles": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_revertMergeTreeDeltaRevertibles():
    TypeOnly<typeof old.revertMergeTreeDeltaRevertibles>;
declare function use_current_FunctionDeclaration_revertMergeTreeDeltaRevertibles(
    use: TypeOnly<typeof current.revertMergeTreeDeltaRevertibles>): void;
use_current_FunctionDeclaration_revertMergeTreeDeltaRevertibles(
    get_old_FunctionDeclaration_revertMergeTreeDeltaRevertibles());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_revertMergeTreeDeltaRevertibles": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_revertMergeTreeDeltaRevertibles():
    TypeOnly<typeof current.revertMergeTreeDeltaRevertibles>;
declare function use_old_FunctionDeclaration_revertMergeTreeDeltaRevertibles(
    use: TypeOnly<typeof old.revertMergeTreeDeltaRevertibles>): void;
use_old_FunctionDeclaration_revertMergeTreeDeltaRevertibles(
    get_current_FunctionDeclaration_revertMergeTreeDeltaRevertibles());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_toRemovalInfo": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_toRemovalInfo():
    TypeOnly<typeof old.toRemovalInfo>;
declare function use_current_FunctionDeclaration_toRemovalInfo(
    use: TypeOnly<typeof current.toRemovalInfo>): void;
use_current_FunctionDeclaration_toRemovalInfo(
    get_old_FunctionDeclaration_toRemovalInfo());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_toRemovalInfo": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_toRemovalInfo():
    TypeOnly<typeof current.toRemovalInfo>;
declare function use_old_FunctionDeclaration_toRemovalInfo(
    use: TypeOnly<typeof old.toRemovalInfo>): void;
use_old_FunctionDeclaration_toRemovalInfo(
    get_current_FunctionDeclaration_toRemovalInfo());
