/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/merge-tree-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_AttributionPolicy": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_AttributionPolicy = requireAssignableTo<TypeOnly<current.AttributionPolicy>, TypeOnly<old.AttributionPolicy>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_BaseSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_BaseSegment = requireAssignableTo<TypeOnly<old.BaseSegment>, TypeOnly<current.BaseSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_BaseSegment": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_BaseSegment = requireAssignableTo<TypeOnly<current.BaseSegment>, TypeOnly<old.BaseSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Client": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_Client = requireAssignableTo<TypeOnly<old.Client>, TypeOnly<current.Client>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Client": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_Client = requireAssignableTo<TypeOnly<current.Client>, TypeOnly<old.Client>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_CollaborationWindow": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_CollaborationWindow = requireAssignableTo<TypeOnly<old.CollaborationWindow>, TypeOnly<current.CollaborationWindow>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_CollaborationWindow": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_CollaborationWindow = requireAssignableTo<TypeOnly<current.CollaborationWindow>, TypeOnly<old.CollaborationWindow>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ConflictAction": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_ConflictAction = requireAssignableTo<TypeOnly<old.ConflictAction<any,any>>, TypeOnly<current.ConflictAction<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ConflictAction": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_ConflictAction = requireAssignableTo<TypeOnly<current.ConflictAction<any,any>>, TypeOnly<old.ConflictAction<any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_DetachedReferencePosition": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_DetachedReferencePosition = requireAssignableTo<TypeOnly<typeof old.DetachedReferencePosition>, TypeOnly<typeof current.DetachedReferencePosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_DetachedReferencePosition": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_DetachedReferencePosition = requireAssignableTo<TypeOnly<typeof current.DetachedReferencePosition>, TypeOnly<typeof old.DetachedReferencePosition>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_Dictionary": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_Dictionary = requireAssignableTo<TypeOnly<old.Dictionary<any,any>>, TypeOnly<current.Dictionary<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_Dictionary": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_Dictionary = requireAssignableTo<TypeOnly<current.Dictionary<any,any>>, TypeOnly<old.Dictionary<any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAttributionCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IAttributionCollection = requireAssignableTo<TypeOnly<old.IAttributionCollection<any>>, TypeOnly<current.IAttributionCollection<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAttributionCollection": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IAttributionCollection = requireAssignableTo<TypeOnly<current.IAttributionCollection<any>>, TypeOnly<old.IAttributionCollection<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAttributionCollectionSerializer": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IAttributionCollectionSerializer = requireAssignableTo<TypeOnly<current.IAttributionCollectionSerializer>, TypeOnly<old.IAttributionCollectionSerializer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAttributionCollectionSpec": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IAttributionCollectionSpec = requireAssignableTo<TypeOnly<old.IAttributionCollectionSpec<any>>, TypeOnly<current.IAttributionCollectionSpec<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IAttributionCollectionSpec": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IAttributionCollectionSpec = requireAssignableTo<TypeOnly<current.IAttributionCollectionSpec<any>>, TypeOnly<old.IAttributionCollectionSpec<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IClientEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IClientEvents = requireAssignableTo<TypeOnly<old.IClientEvents>, TypeOnly<current.IClientEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IClientEvents": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IClientEvents = requireAssignableTo<TypeOnly<current.IClientEvents>, TypeOnly<old.IClientEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONMarkerSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IJSONMarkerSegment = requireAssignableTo<TypeOnly<old.IJSONMarkerSegment>, TypeOnly<current.IJSONMarkerSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONMarkerSegment": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IJSONMarkerSegment = requireAssignableTo<TypeOnly<current.IJSONMarkerSegment>, TypeOnly<old.IJSONMarkerSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IJSONSegment = requireAssignableTo<TypeOnly<old.IJSONSegment>, TypeOnly<current.IJSONSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONSegment": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IJSONSegment = requireAssignableTo<TypeOnly<current.IJSONSegment>, TypeOnly<old.IJSONSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONTextSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IJSONTextSegment = requireAssignableTo<TypeOnly<old.IJSONTextSegment>, TypeOnly<current.IJSONTextSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONTextSegment": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IJSONTextSegment = requireAssignableTo<TypeOnly<current.IJSONTextSegment>, TypeOnly<old.IJSONTextSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMarkerDef": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMarkerDef = requireAssignableTo<TypeOnly<old.IMarkerDef>, TypeOnly<current.IMarkerDef>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMarkerDef": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMarkerDef = requireAssignableTo<TypeOnly<current.IMarkerDef>, TypeOnly<old.IMarkerDef>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeNodeCommon": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeNodeCommon = requireAssignableTo<TypeOnly<old.IMergeNodeCommon>, TypeOnly<current.IMergeNodeCommon>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeNodeCommon": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeNodeCommon = requireAssignableTo<TypeOnly<current.IMergeNodeCommon>, TypeOnly<old.IMergeNodeCommon>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeAnnotateMsg": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeTreeAnnotateMsg = requireAssignableTo<TypeOnly<old.IMergeTreeAnnotateMsg>, TypeOnly<current.IMergeTreeAnnotateMsg>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeAnnotateMsg": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeTreeAnnotateMsg = requireAssignableTo<TypeOnly<current.IMergeTreeAnnotateMsg>, TypeOnly<old.IMergeTreeAnnotateMsg>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeAttributionOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeTreeAttributionOptions = requireAssignableTo<TypeOnly<old.IMergeTreeAttributionOptions>, TypeOnly<current.IMergeTreeAttributionOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeAttributionOptions": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeTreeAttributionOptions = requireAssignableTo<TypeOnly<current.IMergeTreeAttributionOptions>, TypeOnly<old.IMergeTreeAttributionOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeClientSequenceArgs": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeTreeClientSequenceArgs = requireAssignableTo<TypeOnly<old.IMergeTreeClientSequenceArgs>, TypeOnly<current.IMergeTreeClientSequenceArgs>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeClientSequenceArgs": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeTreeClientSequenceArgs = requireAssignableTo<TypeOnly<current.IMergeTreeClientSequenceArgs>, TypeOnly<old.IMergeTreeClientSequenceArgs>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeDelta": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeTreeDelta = requireAssignableTo<TypeOnly<old.IMergeTreeDelta>, TypeOnly<current.IMergeTreeDelta>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeDelta": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeTreeDelta = requireAssignableTo<TypeOnly<current.IMergeTreeDelta>, TypeOnly<old.IMergeTreeDelta>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeDeltaCallbackArgs": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs = requireAssignableTo<TypeOnly<old.IMergeTreeDeltaCallbackArgs>, TypeOnly<current.IMergeTreeDeltaCallbackArgs>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeDeltaCallbackArgs": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeTreeDeltaCallbackArgs = requireAssignableTo<TypeOnly<current.IMergeTreeDeltaCallbackArgs>, TypeOnly<old.IMergeTreeDeltaCallbackArgs>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IMergeTreeDeltaOp": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_IMergeTreeDeltaOp = requireAssignableTo<TypeOnly<old.IMergeTreeDeltaOp>, TypeOnly<current.IMergeTreeDeltaOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IMergeTreeDeltaOp": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_IMergeTreeDeltaOp = requireAssignableTo<TypeOnly<current.IMergeTreeDeltaOp>, TypeOnly<old.IMergeTreeDeltaOp>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeDeltaOpArgs": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeTreeDeltaOpArgs = requireAssignableTo<TypeOnly<old.IMergeTreeDeltaOpArgs>, TypeOnly<current.IMergeTreeDeltaOpArgs>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeDeltaOpArgs": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeTreeDeltaOpArgs = requireAssignableTo<TypeOnly<current.IMergeTreeDeltaOpArgs>, TypeOnly<old.IMergeTreeDeltaOpArgs>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeGroupMsg": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeTreeGroupMsg = requireAssignableTo<TypeOnly<old.IMergeTreeGroupMsg>, TypeOnly<current.IMergeTreeGroupMsg>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeGroupMsg": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeTreeGroupMsg = requireAssignableTo<TypeOnly<current.IMergeTreeGroupMsg>, TypeOnly<old.IMergeTreeGroupMsg>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeInsertMsg": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeTreeInsertMsg = requireAssignableTo<TypeOnly<old.IMergeTreeInsertMsg>, TypeOnly<current.IMergeTreeInsertMsg>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeInsertMsg": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeTreeInsertMsg = requireAssignableTo<TypeOnly<current.IMergeTreeInsertMsg>, TypeOnly<old.IMergeTreeInsertMsg>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs = requireAssignableTo<TypeOnly<old.IMergeTreeMaintenanceCallbackArgs>, TypeOnly<current.IMergeTreeMaintenanceCallbackArgs>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeTreeMaintenanceCallbackArgs = requireAssignableTo<TypeOnly<current.IMergeTreeMaintenanceCallbackArgs>, TypeOnly<old.IMergeTreeMaintenanceCallbackArgs>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeObliterateMsg": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeTreeObliterateMsg = requireAssignableTo<TypeOnly<old.IMergeTreeObliterateMsg>, TypeOnly<current.IMergeTreeObliterateMsg>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeObliterateMsg": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeTreeObliterateMsg = requireAssignableTo<TypeOnly<current.IMergeTreeObliterateMsg>, TypeOnly<old.IMergeTreeObliterateMsg>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IMergeTreeOp": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_IMergeTreeOp = requireAssignableTo<TypeOnly<old.IMergeTreeOp>, TypeOnly<current.IMergeTreeOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IMergeTreeOp": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_IMergeTreeOp = requireAssignableTo<TypeOnly<current.IMergeTreeOp>, TypeOnly<old.IMergeTreeOp>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeTreeOptions = requireAssignableTo<TypeOnly<old.IMergeTreeOptions>, TypeOnly<current.IMergeTreeOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeOptions": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeTreeOptions = requireAssignableTo<TypeOnly<current.IMergeTreeOptions>, TypeOnly<old.IMergeTreeOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeRemoveMsg": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeTreeRemoveMsg = requireAssignableTo<TypeOnly<old.IMergeTreeRemoveMsg>, TypeOnly<current.IMergeTreeRemoveMsg>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeRemoveMsg": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeTreeRemoveMsg = requireAssignableTo<TypeOnly<current.IMergeTreeRemoveMsg>, TypeOnly<old.IMergeTreeRemoveMsg>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeSegmentDelta": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeTreeSegmentDelta = requireAssignableTo<TypeOnly<old.IMergeTreeSegmentDelta>, TypeOnly<current.IMergeTreeSegmentDelta>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeSegmentDelta": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeTreeSegmentDelta = requireAssignableTo<TypeOnly<current.IMergeTreeSegmentDelta>, TypeOnly<old.IMergeTreeSegmentDelta>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeTextHelper": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMergeTreeTextHelper = requireAssignableTo<TypeOnly<old.IMergeTreeTextHelper>, TypeOnly<current.IMergeTreeTextHelper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMergeTreeTextHelper": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMergeTreeTextHelper = requireAssignableTo<TypeOnly<current.IMergeTreeTextHelper>, TypeOnly<old.IMergeTreeTextHelper>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMoveInfo": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMoveInfo = requireAssignableTo<TypeOnly<old.IMoveInfo>, TypeOnly<current.IMoveInfo>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMoveInfo": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMoveInfo = requireAssignableTo<TypeOnly<current.IMoveInfo>, TypeOnly<old.IMoveInfo>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRBAugmentation": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IRBAugmentation = requireAssignableTo<TypeOnly<old.IRBAugmentation<any,any>>, TypeOnly<current.IRBAugmentation<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRBAugmentation": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IRBAugmentation = requireAssignableTo<TypeOnly<current.IRBAugmentation<any,any>>, TypeOnly<old.IRBAugmentation<any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRBMatcher": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IRBMatcher = requireAssignableTo<TypeOnly<old.IRBMatcher<any,any>>, TypeOnly<current.IRBMatcher<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRBMatcher": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IRBMatcher = requireAssignableTo<TypeOnly<current.IRBMatcher<any,any>>, TypeOnly<old.IRBMatcher<any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRelativePosition": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IRelativePosition = requireAssignableTo<TypeOnly<old.IRelativePosition>, TypeOnly<current.IRelativePosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRelativePosition": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IRelativePosition = requireAssignableTo<TypeOnly<current.IRelativePosition>, TypeOnly<old.IRelativePosition>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRemovalInfo": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IRemovalInfo = requireAssignableTo<TypeOnly<old.IRemovalInfo>, TypeOnly<current.IRemovalInfo>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRemovalInfo": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IRemovalInfo = requireAssignableTo<TypeOnly<current.IRemovalInfo>, TypeOnly<old.IRemovalInfo>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISegment": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ISegment = requireAssignableTo<TypeOnly<old.ISegment>, TypeOnly<current.ISegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISegment": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ISegment = requireAssignableTo<TypeOnly<current.ISegment>, TypeOnly<old.ISegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISegmentAction": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ISegmentAction = requireAssignableTo<TypeOnly<old.ISegmentAction<any>>, TypeOnly<current.ISegmentAction<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISegmentAction": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ISegmentAction = requireAssignableTo<TypeOnly<current.ISegmentAction<any>>, TypeOnly<old.ISegmentAction<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITrackingGroup": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ITrackingGroup = requireAssignableTo<TypeOnly<old.ITrackingGroup>, TypeOnly<current.ITrackingGroup>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ITrackingGroup": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ITrackingGroup = requireAssignableTo<TypeOnly<current.ITrackingGroup>, TypeOnly<old.ITrackingGroup>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_KeyComparer": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_KeyComparer = requireAssignableTo<TypeOnly<old.KeyComparer<any>>, TypeOnly<current.KeyComparer<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_KeyComparer": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_KeyComparer = requireAssignableTo<TypeOnly<current.KeyComparer<any>>, TypeOnly<old.KeyComparer<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LocalReferenceCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_LocalReferenceCollection = requireAssignableTo<TypeOnly<current.LocalReferenceCollection>, TypeOnly<old.LocalReferenceCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_LocalReferencePosition": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_LocalReferencePosition = requireAssignableTo<TypeOnly<current.LocalReferencePosition>, TypeOnly<old.LocalReferencePosition>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MapLike": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_MapLike = requireAssignableTo<TypeOnly<old.MapLike<any>>, TypeOnly<current.MapLike<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MapLike": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_MapLike = requireAssignableTo<TypeOnly<current.MapLike<any>>, TypeOnly<old.MapLike<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Marker": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_Marker = requireAssignableTo<TypeOnly<old.Marker>, TypeOnly<current.Marker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Marker": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_Marker = requireAssignableTo<TypeOnly<current.Marker>, TypeOnly<old.Marker>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MergeNode": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_MergeNode = requireAssignableTo<TypeOnly<old.MergeNode>, TypeOnly<current.MergeNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_MergeNode": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_MergeNode = requireAssignableTo<TypeOnly<current.MergeNode>, TypeOnly<old.MergeNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaOperationType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_MergeTreeDeltaOperationType = requireAssignableTo<TypeOnly<old.MergeTreeDeltaOperationType>, TypeOnly<current.MergeTreeDeltaOperationType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaOperationType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_MergeTreeDeltaOperationType = requireAssignableTo<TypeOnly<current.MergeTreeDeltaOperationType>, TypeOnly<old.MergeTreeDeltaOperationType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaOperationTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_MergeTreeDeltaOperationTypes = requireAssignableTo<TypeOnly<old.MergeTreeDeltaOperationTypes>, TypeOnly<current.MergeTreeDeltaOperationTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaOperationTypes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_MergeTreeDeltaOperationTypes = requireAssignableTo<TypeOnly<current.MergeTreeDeltaOperationTypes>, TypeOnly<old.MergeTreeDeltaOperationTypes>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaRevertible": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_MergeTreeDeltaRevertible = requireAssignableTo<TypeOnly<old.MergeTreeDeltaRevertible>, TypeOnly<current.MergeTreeDeltaRevertible>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaRevertible": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_MergeTreeDeltaRevertible = requireAssignableTo<TypeOnly<current.MergeTreeDeltaRevertible>, TypeOnly<old.MergeTreeDeltaRevertible>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_MergeTreeDeltaType": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_MergeTreeDeltaType = requireAssignableTo<TypeOnly<typeof old.MergeTreeDeltaType>, TypeOnly<typeof current.MergeTreeDeltaType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_MergeTreeDeltaType": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_MergeTreeDeltaType = requireAssignableTo<TypeOnly<typeof current.MergeTreeDeltaType>, TypeOnly<typeof old.MergeTreeDeltaType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_MergeTreeDeltaType = requireAssignableTo<TypeOnly<old.MergeTreeDeltaType>, TypeOnly<current.MergeTreeDeltaType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_MergeTreeDeltaType = requireAssignableTo<TypeOnly<current.MergeTreeDeltaType>, TypeOnly<old.MergeTreeDeltaType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_MergeTreeMaintenanceType": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_MergeTreeMaintenanceType = requireAssignableTo<TypeOnly<typeof old.MergeTreeMaintenanceType>, TypeOnly<typeof current.MergeTreeMaintenanceType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_MergeTreeMaintenanceType": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_MergeTreeMaintenanceType = requireAssignableTo<TypeOnly<typeof current.MergeTreeMaintenanceType>, TypeOnly<typeof old.MergeTreeMaintenanceType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeMaintenanceType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_MergeTreeMaintenanceType = requireAssignableTo<TypeOnly<old.MergeTreeMaintenanceType>, TypeOnly<current.MergeTreeMaintenanceType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeMaintenanceType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_MergeTreeMaintenanceType = requireAssignableTo<TypeOnly<current.MergeTreeMaintenanceType>, TypeOnly<old.MergeTreeMaintenanceType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MergeTreeRevertibleDriver": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_MergeTreeRevertibleDriver = requireAssignableTo<TypeOnly<old.MergeTreeRevertibleDriver>, TypeOnly<current.MergeTreeRevertibleDriver>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MergeTreeRevertibleDriver": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_MergeTreeRevertibleDriver = requireAssignableTo<TypeOnly<current.MergeTreeRevertibleDriver>, TypeOnly<old.MergeTreeRevertibleDriver>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_PropertiesManager": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_PropertiesManager = requireAssignableTo<TypeOnly<old.PropertiesManager>, TypeOnly<current.PropertiesManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_PropertiesManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_PropertiesManager = requireAssignableTo<TypeOnly<current.PropertiesManager>, TypeOnly<old.PropertiesManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_PropertiesRollback": {"forwardCompat": false}
 */
declare type old_as_current_for_EnumDeclaration_PropertiesRollback = requireAssignableTo<TypeOnly<old.PropertiesRollback>, TypeOnly<current.PropertiesRollback>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_PropertiesRollback": {"backCompat": false}
 */
declare type current_as_old_for_EnumDeclaration_PropertiesRollback = requireAssignableTo<TypeOnly<current.PropertiesRollback>, TypeOnly<old.PropertiesRollback>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_Property": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_Property = requireAssignableTo<TypeOnly<old.Property<any,any>>, TypeOnly<current.Property<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_Property": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_Property = requireAssignableTo<TypeOnly<current.Property<any,any>>, TypeOnly<old.Property<any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_PropertyAction": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_PropertyAction = requireAssignableTo<TypeOnly<old.PropertyAction<any,any>>, TypeOnly<current.PropertyAction<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_PropertyAction": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_PropertyAction = requireAssignableTo<TypeOnly<current.PropertyAction<any,any>>, TypeOnly<old.PropertyAction<any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_PropertySet": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_PropertySet = requireAssignableTo<TypeOnly<old.PropertySet>, TypeOnly<current.PropertySet>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_PropertySet": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_PropertySet = requireAssignableTo<TypeOnly<current.PropertySet>, TypeOnly<old.PropertySet>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_QProperty": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_QProperty = requireAssignableTo<TypeOnly<old.QProperty<any,any>>, TypeOnly<current.QProperty<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_QProperty": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_QProperty = requireAssignableTo<TypeOnly<current.QProperty<any,any>>, TypeOnly<old.QProperty<any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_RBColor": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_RBColor = requireAssignableTo<TypeOnly<typeof old.RBColor>, TypeOnly<typeof current.RBColor>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_RBColor": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_RBColor = requireAssignableTo<TypeOnly<typeof current.RBColor>, TypeOnly<typeof old.RBColor>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_RBColor": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_RBColor = requireAssignableTo<TypeOnly<old.RBColor>, TypeOnly<current.RBColor>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_RBColor": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_RBColor = requireAssignableTo<TypeOnly<current.RBColor>, TypeOnly<old.RBColor>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_RBNode": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_RBNode = requireAssignableTo<TypeOnly<old.RBNode<any,any>>, TypeOnly<current.RBNode<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_RBNode": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_RBNode = requireAssignableTo<TypeOnly<current.RBNode<any,any>>, TypeOnly<old.RBNode<any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_RBNodeActions": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_RBNodeActions = requireAssignableTo<TypeOnly<old.RBNodeActions<any,any>>, TypeOnly<current.RBNodeActions<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_RBNodeActions": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_RBNodeActions = requireAssignableTo<TypeOnly<current.RBNodeActions<any,any>>, TypeOnly<old.RBNodeActions<any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_RedBlackTree": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_RedBlackTree = requireAssignableTo<TypeOnly<old.RedBlackTree<any,any>>, TypeOnly<current.RedBlackTree<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_RedBlackTree": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_RedBlackTree = requireAssignableTo<TypeOnly<current.RedBlackTree<any,any>>, TypeOnly<old.RedBlackTree<any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ReferencePosition": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ReferencePosition = requireAssignableTo<TypeOnly<old.ReferencePosition>, TypeOnly<current.ReferencePosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ReferencePosition": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ReferencePosition = requireAssignableTo<TypeOnly<current.ReferencePosition>, TypeOnly<old.ReferencePosition>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_ReferenceType": {"forwardCompat": false}
 */
declare type old_as_current_for_EnumDeclaration_ReferenceType = requireAssignableTo<TypeOnly<old.ReferenceType>, TypeOnly<current.ReferenceType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_ReferenceType": {"backCompat": false}
 */
declare type current_as_old_for_EnumDeclaration_ReferenceType = requireAssignableTo<TypeOnly<current.ReferenceType>, TypeOnly<old.ReferenceType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SegmentGroup": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_SegmentGroup = requireAssignableTo<TypeOnly<old.SegmentGroup>, TypeOnly<current.SegmentGroup>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SegmentGroup": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_SegmentGroup = requireAssignableTo<TypeOnly<current.SegmentGroup>, TypeOnly<old.SegmentGroup>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SegmentGroupCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_SegmentGroupCollection = requireAssignableTo<TypeOnly<old.SegmentGroupCollection>, TypeOnly<current.SegmentGroupCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SegmentGroupCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_SegmentGroupCollection = requireAssignableTo<TypeOnly<current.SegmentGroupCollection>, TypeOnly<old.SegmentGroupCollection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SequenceOffsets": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_SequenceOffsets = requireAssignableTo<TypeOnly<old.SequenceOffsets>, TypeOnly<current.SequenceOffsets>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SequenceOffsets": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_SequenceOffsets = requireAssignableTo<TypeOnly<current.SequenceOffsets>, TypeOnly<old.SequenceOffsets>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SerializedAttributionCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_SerializedAttributionCollection = requireAssignableTo<TypeOnly<old.SerializedAttributionCollection>, TypeOnly<current.SerializedAttributionCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SerializedAttributionCollection": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_SerializedAttributionCollection = requireAssignableTo<TypeOnly<current.SerializedAttributionCollection>, TypeOnly<old.SerializedAttributionCollection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_SlidingPreference": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_SlidingPreference = requireAssignableTo<TypeOnly<typeof old.SlidingPreference>, TypeOnly<typeof current.SlidingPreference>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_SlidingPreference": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_SlidingPreference = requireAssignableTo<TypeOnly<typeof current.SlidingPreference>, TypeOnly<typeof old.SlidingPreference>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SlidingPreference": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_SlidingPreference = requireAssignableTo<TypeOnly<old.SlidingPreference>, TypeOnly<current.SlidingPreference>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SlidingPreference": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_SlidingPreference = requireAssignableTo<TypeOnly<current.SlidingPreference>, TypeOnly<old.SlidingPreference>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SortedDictionary": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_SortedDictionary = requireAssignableTo<TypeOnly<old.SortedDictionary<any,any>>, TypeOnly<current.SortedDictionary<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SortedDictionary": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_SortedDictionary = requireAssignableTo<TypeOnly<current.SortedDictionary<any,any>>, TypeOnly<old.SortedDictionary<any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SortedSegmentSet": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_SortedSegmentSet = requireAssignableTo<TypeOnly<old.SortedSegmentSet>, TypeOnly<current.SortedSegmentSet>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SortedSegmentSet": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_SortedSegmentSet = requireAssignableTo<TypeOnly<current.SortedSegmentSet>, TypeOnly<old.SortedSegmentSet>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SortedSegmentSetItem": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_SortedSegmentSetItem = requireAssignableTo<TypeOnly<old.SortedSegmentSetItem>, TypeOnly<current.SortedSegmentSetItem>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SortedSegmentSetItem": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_SortedSegmentSetItem = requireAssignableTo<TypeOnly<current.SortedSegmentSetItem>, TypeOnly<old.SortedSegmentSetItem>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SortedSet": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_SortedSet = requireAssignableTo<TypeOnly<old.SortedSet<any,any>>, TypeOnly<current.SortedSet<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SortedSet": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_SortedSet = requireAssignableTo<TypeOnly<current.SortedSet<any,any>>, TypeOnly<old.SortedSet<any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TextSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_TextSegment = requireAssignableTo<TypeOnly<old.TextSegment>, TypeOnly<current.TextSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TextSegment": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_TextSegment = requireAssignableTo<TypeOnly<current.TextSegment>, TypeOnly<old.TextSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_Trackable": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_Trackable = requireAssignableTo<TypeOnly<old.Trackable>, TypeOnly<current.Trackable>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_Trackable": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_Trackable = requireAssignableTo<TypeOnly<current.Trackable>, TypeOnly<old.Trackable>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TrackingGroup": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_TrackingGroup = requireAssignableTo<TypeOnly<old.TrackingGroup>, TypeOnly<current.TrackingGroup>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TrackingGroup": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_TrackingGroup = requireAssignableTo<TypeOnly<current.TrackingGroup>, TypeOnly<old.TrackingGroup>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TrackingGroupCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_TrackingGroupCollection = requireAssignableTo<TypeOnly<old.TrackingGroupCollection>, TypeOnly<current.TrackingGroupCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TrackingGroupCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_TrackingGroupCollection = requireAssignableTo<TypeOnly<current.TrackingGroupCollection>, TypeOnly<old.TrackingGroupCollection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_UnassignedSequenceNumber": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_UnassignedSequenceNumber = requireAssignableTo<TypeOnly<typeof old.UnassignedSequenceNumber>, TypeOnly<typeof current.UnassignedSequenceNumber>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_UnassignedSequenceNumber": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_UnassignedSequenceNumber = requireAssignableTo<TypeOnly<typeof current.UnassignedSequenceNumber>, TypeOnly<typeof old.UnassignedSequenceNumber>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_UniversalSequenceNumber": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_UniversalSequenceNumber = requireAssignableTo<TypeOnly<typeof old.UniversalSequenceNumber>, TypeOnly<typeof current.UniversalSequenceNumber>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_UniversalSequenceNumber": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_UniversalSequenceNumber = requireAssignableTo<TypeOnly<typeof current.UniversalSequenceNumber>, TypeOnly<typeof old.UniversalSequenceNumber>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_addProperties": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_addProperties = requireAssignableTo<TypeOnly<typeof old.addProperties>, TypeOnly<typeof current.addProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_addProperties": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_addProperties = requireAssignableTo<TypeOnly<typeof current.addProperties>, TypeOnly<typeof old.addProperties>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendToMergeTreeDeltaRevertibles": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_appendToMergeTreeDeltaRevertibles = requireAssignableTo<TypeOnly<typeof old.appendToMergeTreeDeltaRevertibles>, TypeOnly<typeof current.appendToMergeTreeDeltaRevertibles>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendToMergeTreeDeltaRevertibles": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_appendToMergeTreeDeltaRevertibles = requireAssignableTo<TypeOnly<typeof current.appendToMergeTreeDeltaRevertibles>, TypeOnly<typeof old.appendToMergeTreeDeltaRevertibles>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_compareReferencePositions": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_compareReferencePositions = requireAssignableTo<TypeOnly<typeof old.compareReferencePositions>, TypeOnly<typeof current.compareReferencePositions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_compareReferencePositions": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_compareReferencePositions = requireAssignableTo<TypeOnly<typeof current.compareReferencePositions>, TypeOnly<typeof old.compareReferencePositions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createAnnotateRangeOp": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createAnnotateRangeOp = requireAssignableTo<TypeOnly<typeof old.createAnnotateRangeOp>, TypeOnly<typeof current.createAnnotateRangeOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createAnnotateRangeOp": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createAnnotateRangeOp = requireAssignableTo<TypeOnly<typeof current.createAnnotateRangeOp>, TypeOnly<typeof old.createAnnotateRangeOp>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createDetachedLocalReferencePosition": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createDetachedLocalReferencePosition = requireAssignableTo<TypeOnly<typeof old.createDetachedLocalReferencePosition>, TypeOnly<typeof current.createDetachedLocalReferencePosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createDetachedLocalReferencePosition": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createDetachedLocalReferencePosition = requireAssignableTo<TypeOnly<typeof current.createDetachedLocalReferencePosition>, TypeOnly<typeof old.createDetachedLocalReferencePosition>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createGroupOp": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createGroupOp = requireAssignableTo<TypeOnly<typeof old.createGroupOp>, TypeOnly<typeof current.createGroupOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createGroupOp": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createGroupOp = requireAssignableTo<TypeOnly<typeof current.createGroupOp>, TypeOnly<typeof old.createGroupOp>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createInsertOnlyAttributionPolicy": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createInsertOnlyAttributionPolicy = requireAssignableTo<TypeOnly<typeof old.createInsertOnlyAttributionPolicy>, TypeOnly<typeof current.createInsertOnlyAttributionPolicy>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createInsertOnlyAttributionPolicy": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createInsertOnlyAttributionPolicy = requireAssignableTo<TypeOnly<typeof current.createInsertOnlyAttributionPolicy>, TypeOnly<typeof old.createInsertOnlyAttributionPolicy>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createInsertOp": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createInsertOp = requireAssignableTo<TypeOnly<typeof old.createInsertOp>, TypeOnly<typeof current.createInsertOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createInsertOp": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createInsertOp = requireAssignableTo<TypeOnly<typeof current.createInsertOp>, TypeOnly<typeof old.createInsertOp>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createInsertSegmentOp": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createInsertSegmentOp = requireAssignableTo<TypeOnly<typeof old.createInsertSegmentOp>, TypeOnly<typeof current.createInsertSegmentOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createInsertSegmentOp": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createInsertSegmentOp = requireAssignableTo<TypeOnly<typeof current.createInsertSegmentOp>, TypeOnly<typeof old.createInsertSegmentOp>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createMap": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createMap = requireAssignableTo<TypeOnly<typeof old.createMap>, TypeOnly<typeof current.createMap>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createMap": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createMap = requireAssignableTo<TypeOnly<typeof current.createMap>, TypeOnly<typeof old.createMap>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createObliterateRangeOp": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createObliterateRangeOp = requireAssignableTo<TypeOnly<typeof old.createObliterateRangeOp>, TypeOnly<typeof current.createObliterateRangeOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createObliterateRangeOp": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createObliterateRangeOp = requireAssignableTo<TypeOnly<typeof current.createObliterateRangeOp>, TypeOnly<typeof old.createObliterateRangeOp>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createPropertyTrackingAndInsertionAttributionPolicyFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createPropertyTrackingAndInsertionAttributionPolicyFactory = requireAssignableTo<TypeOnly<typeof old.createPropertyTrackingAndInsertionAttributionPolicyFactory>, TypeOnly<typeof current.createPropertyTrackingAndInsertionAttributionPolicyFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createPropertyTrackingAndInsertionAttributionPolicyFactory": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createPropertyTrackingAndInsertionAttributionPolicyFactory = requireAssignableTo<TypeOnly<typeof current.createPropertyTrackingAndInsertionAttributionPolicyFactory>, TypeOnly<typeof old.createPropertyTrackingAndInsertionAttributionPolicyFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createPropertyTrackingAttributionPolicyFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createPropertyTrackingAttributionPolicyFactory = requireAssignableTo<TypeOnly<typeof old.createPropertyTrackingAttributionPolicyFactory>, TypeOnly<typeof current.createPropertyTrackingAttributionPolicyFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createPropertyTrackingAttributionPolicyFactory": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createPropertyTrackingAttributionPolicyFactory = requireAssignableTo<TypeOnly<typeof current.createPropertyTrackingAttributionPolicyFactory>, TypeOnly<typeof old.createPropertyTrackingAttributionPolicyFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createRemoveRangeOp": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createRemoveRangeOp = requireAssignableTo<TypeOnly<typeof old.createRemoveRangeOp>, TypeOnly<typeof current.createRemoveRangeOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createRemoveRangeOp": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createRemoveRangeOp = requireAssignableTo<TypeOnly<typeof current.createRemoveRangeOp>, TypeOnly<typeof old.createRemoveRangeOp>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_debugMarkerToString": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_debugMarkerToString = requireAssignableTo<TypeOnly<typeof old.debugMarkerToString>, TypeOnly<typeof current.debugMarkerToString>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_debugMarkerToString": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_debugMarkerToString = requireAssignableTo<TypeOnly<typeof current.debugMarkerToString>, TypeOnly<typeof old.debugMarkerToString>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_discardMergeTreeDeltaRevertible": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_discardMergeTreeDeltaRevertible = requireAssignableTo<TypeOnly<typeof old.discardMergeTreeDeltaRevertible>, TypeOnly<typeof current.discardMergeTreeDeltaRevertible>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_discardMergeTreeDeltaRevertible": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_discardMergeTreeDeltaRevertible = requireAssignableTo<TypeOnly<typeof current.discardMergeTreeDeltaRevertible>, TypeOnly<typeof old.discardMergeTreeDeltaRevertible>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getSlideToSegoff": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_getSlideToSegoff = requireAssignableTo<TypeOnly<typeof old.getSlideToSegoff>, TypeOnly<typeof current.getSlideToSegoff>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getSlideToSegoff": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_getSlideToSegoff = requireAssignableTo<TypeOnly<typeof current.getSlideToSegoff>, TypeOnly<typeof old.getSlideToSegoff>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isMergeTreeDeltaRevertible": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_isMergeTreeDeltaRevertible = requireAssignableTo<TypeOnly<typeof old.isMergeTreeDeltaRevertible>, TypeOnly<typeof current.isMergeTreeDeltaRevertible>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isMergeTreeDeltaRevertible": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_isMergeTreeDeltaRevertible = requireAssignableTo<TypeOnly<typeof current.isMergeTreeDeltaRevertible>, TypeOnly<typeof old.isMergeTreeDeltaRevertible>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_matchProperties": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_matchProperties = requireAssignableTo<TypeOnly<typeof old.matchProperties>, TypeOnly<typeof current.matchProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_matchProperties": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_matchProperties = requireAssignableTo<TypeOnly<typeof current.matchProperties>, TypeOnly<typeof old.matchProperties>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_maxReferencePosition": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_maxReferencePosition = requireAssignableTo<TypeOnly<typeof old.maxReferencePosition>, TypeOnly<typeof current.maxReferencePosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_maxReferencePosition": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_maxReferencePosition = requireAssignableTo<TypeOnly<typeof current.maxReferencePosition>, TypeOnly<typeof old.maxReferencePosition>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_minReferencePosition": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_minReferencePosition = requireAssignableTo<TypeOnly<typeof old.minReferencePosition>, TypeOnly<typeof current.minReferencePosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_minReferencePosition": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_minReferencePosition = requireAssignableTo<TypeOnly<typeof current.minReferencePosition>, TypeOnly<typeof old.minReferencePosition>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_refGetTileLabels": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_refGetTileLabels = requireAssignableTo<TypeOnly<typeof old.refGetTileLabels>, TypeOnly<typeof current.refGetTileLabels>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_refGetTileLabels": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_refGetTileLabels = requireAssignableTo<TypeOnly<typeof current.refGetTileLabels>, TypeOnly<typeof old.refGetTileLabels>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_refHasTileLabel": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_refHasTileLabel = requireAssignableTo<TypeOnly<typeof old.refHasTileLabel>, TypeOnly<typeof current.refHasTileLabel>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_refHasTileLabel": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_refHasTileLabel = requireAssignableTo<TypeOnly<typeof current.refHasTileLabel>, TypeOnly<typeof old.refHasTileLabel>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_refHasTileLabels": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_refHasTileLabels = requireAssignableTo<TypeOnly<typeof old.refHasTileLabels>, TypeOnly<typeof current.refHasTileLabels>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_refHasTileLabels": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_refHasTileLabels = requireAssignableTo<TypeOnly<typeof current.refHasTileLabels>, TypeOnly<typeof old.refHasTileLabels>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_refTypeIncludesFlag": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_refTypeIncludesFlag = requireAssignableTo<TypeOnly<typeof old.refTypeIncludesFlag>, TypeOnly<typeof current.refTypeIncludesFlag>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_refTypeIncludesFlag": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_refTypeIncludesFlag = requireAssignableTo<TypeOnly<typeof current.refTypeIncludesFlag>, TypeOnly<typeof old.refTypeIncludesFlag>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedMarkerIdKey": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_reservedMarkerIdKey = requireAssignableTo<TypeOnly<typeof old.reservedMarkerIdKey>, TypeOnly<typeof current.reservedMarkerIdKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedMarkerIdKey": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_reservedMarkerIdKey = requireAssignableTo<TypeOnly<typeof current.reservedMarkerIdKey>, TypeOnly<typeof old.reservedMarkerIdKey>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedMarkerSimpleTypeKey": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_reservedMarkerSimpleTypeKey = requireAssignableTo<TypeOnly<typeof old.reservedMarkerSimpleTypeKey>, TypeOnly<typeof current.reservedMarkerSimpleTypeKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedMarkerSimpleTypeKey": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_reservedMarkerSimpleTypeKey = requireAssignableTo<TypeOnly<typeof current.reservedMarkerSimpleTypeKey>, TypeOnly<typeof old.reservedMarkerSimpleTypeKey>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedRangeLabelsKey": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_reservedRangeLabelsKey = requireAssignableTo<TypeOnly<typeof old.reservedRangeLabelsKey>, TypeOnly<typeof current.reservedRangeLabelsKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedRangeLabelsKey": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_reservedRangeLabelsKey = requireAssignableTo<TypeOnly<typeof current.reservedRangeLabelsKey>, TypeOnly<typeof old.reservedRangeLabelsKey>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedTileLabelsKey": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_reservedTileLabelsKey = requireAssignableTo<TypeOnly<typeof old.reservedTileLabelsKey>, TypeOnly<typeof current.reservedTileLabelsKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedTileLabelsKey": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_reservedTileLabelsKey = requireAssignableTo<TypeOnly<typeof current.reservedTileLabelsKey>, TypeOnly<typeof old.reservedTileLabelsKey>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_revertMergeTreeDeltaRevertibles": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_revertMergeTreeDeltaRevertibles = requireAssignableTo<TypeOnly<typeof old.revertMergeTreeDeltaRevertibles>, TypeOnly<typeof current.revertMergeTreeDeltaRevertibles>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_revertMergeTreeDeltaRevertibles": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_revertMergeTreeDeltaRevertibles = requireAssignableTo<TypeOnly<typeof current.revertMergeTreeDeltaRevertibles>, TypeOnly<typeof old.revertMergeTreeDeltaRevertibles>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_toRemovalInfo": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_toRemovalInfo = requireAssignableTo<TypeOnly<typeof old.toRemovalInfo>, TypeOnly<typeof current.toRemovalInfo>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_toRemovalInfo": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_toRemovalInfo = requireAssignableTo<TypeOnly<typeof current.toRemovalInfo>, TypeOnly<typeof old.toRemovalInfo>>
