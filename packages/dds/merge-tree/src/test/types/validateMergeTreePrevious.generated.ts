/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/merge-tree-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BaseSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_BaseSegment = requireAssignableTo<TypeOnly<old.BaseSegment>, TypeOnly<current.BaseSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BaseSegment": {"backCompat": false}
 */
declare type current_as_old_for_Class_BaseSegment = requireAssignableTo<TypeOnly<current.BaseSegment>, TypeOnly<old.BaseSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Client": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Client = requireAssignableTo<TypeOnly<old.Client>, TypeOnly<current.Client>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Client": {"backCompat": false}
 */
declare type current_as_old_for_Class_Client = requireAssignableTo<TypeOnly<current.Client>, TypeOnly<old.Client>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CollaborationWindow": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_CollaborationWindow = requireAssignableTo<TypeOnly<old.CollaborationWindow>, TypeOnly<current.CollaborationWindow>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CollaborationWindow": {"backCompat": false}
 */
declare type current_as_old_for_Class_CollaborationWindow = requireAssignableTo<TypeOnly<current.CollaborationWindow>, TypeOnly<old.CollaborationWindow>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Heap": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Heap = requireAssignableTo<TypeOnly<old.Heap<never>>, TypeOnly<current.Heap<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Heap": {"backCompat": false}
 */
declare type current_as_old_for_Class_Heap = requireAssignableTo<TypeOnly<current.Heap<never>>, TypeOnly<old.Heap<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_IncrementalMapState": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_IncrementalMapState = requireAssignableTo<TypeOnly<old.IncrementalMapState<never>>, TypeOnly<current.IncrementalMapState<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_IncrementalMapState": {"backCompat": false}
 */
declare type current_as_old_for_Class_IncrementalMapState = requireAssignableTo<TypeOnly<current.IncrementalMapState<never>>, TypeOnly<old.IncrementalMapState<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_IntervalTree": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_IntervalTree = requireAssignableTo<TypeOnly<old.IntervalTree<never>>, TypeOnly<current.IntervalTree<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_IntervalTree": {"backCompat": false}
 */
declare type current_as_old_for_Class_IntervalTree = requireAssignableTo<TypeOnly<current.IntervalTree<never>>, TypeOnly<old.IntervalTree<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_List": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_List = requireAssignableTo<TypeOnly<old.List<never>>, TypeOnly<current.List<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_List": {"backCompat": false}
 */
declare type current_as_old_for_Class_List = requireAssignableTo<TypeOnly<current.List<never>>, TypeOnly<old.List<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalReference": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_LocalReference = requireAssignableTo<TypeOnly<old.LocalReference>, TypeOnly<current.LocalReference>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalReference": {"backCompat": false}
 */
declare type current_as_old_for_Class_LocalReference = requireAssignableTo<TypeOnly<current.LocalReference>, TypeOnly<old.LocalReference>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalReferenceCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_LocalReferenceCollection = requireAssignableTo<TypeOnly<old.LocalReferenceCollection>, TypeOnly<current.LocalReferenceCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalReferenceCollection": {"backCompat": false}
 */
declare type current_as_old_for_Class_LocalReferenceCollection = requireAssignableTo<TypeOnly<current.LocalReferenceCollection>, TypeOnly<old.LocalReferenceCollection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Marker": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Marker = requireAssignableTo<TypeOnly<old.Marker>, TypeOnly<current.Marker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Marker": {"backCompat": false}
 */
declare type current_as_old_for_Class_Marker = requireAssignableTo<TypeOnly<current.Marker>, TypeOnly<old.Marker>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MergeBlock": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MergeBlock = requireAssignableTo<TypeOnly<old.MergeBlock>, TypeOnly<current.MergeBlock>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MergeBlock": {"backCompat": false}
 */
declare type current_as_old_for_Class_MergeBlock = requireAssignableTo<TypeOnly<current.MergeBlock>, TypeOnly<old.MergeBlock>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MergeNode": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MergeNode = requireAssignableTo<TypeOnly<old.MergeNode>, TypeOnly<current.MergeNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MergeNode": {"backCompat": false}
 */
declare type current_as_old_for_Class_MergeNode = requireAssignableTo<TypeOnly<current.MergeNode>, TypeOnly<old.MergeNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MergeTree": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MergeTree = requireAssignableTo<TypeOnly<old.MergeTree>, TypeOnly<current.MergeTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MergeTree": {"backCompat": false}
 */
declare type current_as_old_for_Class_MergeTree = requireAssignableTo<TypeOnly<current.MergeTree>, TypeOnly<old.MergeTree>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MergeTreeTextHelper": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MergeTreeTextHelper = requireAssignableTo<TypeOnly<old.MergeTreeTextHelper>, TypeOnly<current.MergeTreeTextHelper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MergeTreeTextHelper": {"backCompat": false}
 */
declare type current_as_old_for_Class_MergeTreeTextHelper = requireAssignableTo<TypeOnly<current.MergeTreeTextHelper>, TypeOnly<old.MergeTreeTextHelper>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PropertiesManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_PropertiesManager = requireAssignableTo<TypeOnly<old.PropertiesManager>, TypeOnly<current.PropertiesManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PropertiesManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_PropertiesManager = requireAssignableTo<TypeOnly<current.PropertiesManager>, TypeOnly<old.PropertiesManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RedBlackTree": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RedBlackTree = requireAssignableTo<TypeOnly<old.RedBlackTree<never,never>>, TypeOnly<current.RedBlackTree<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RedBlackTree": {"backCompat": false}
 */
declare type current_as_old_for_Class_RedBlackTree = requireAssignableTo<TypeOnly<current.RedBlackTree<never,never>>, TypeOnly<old.RedBlackTree<never,never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SegmentGroupCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SegmentGroupCollection = requireAssignableTo<TypeOnly<old.SegmentGroupCollection>, TypeOnly<current.SegmentGroupCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SegmentGroupCollection": {"backCompat": false}
 */
declare type current_as_old_for_Class_SegmentGroupCollection = requireAssignableTo<TypeOnly<current.SegmentGroupCollection>, TypeOnly<old.SegmentGroupCollection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SnapshotLegacy": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SnapshotLegacy = requireAssignableTo<TypeOnly<old.SnapshotLegacy>, TypeOnly<current.SnapshotLegacy>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SnapshotLegacy": {"backCompat": false}
 */
declare type current_as_old_for_Class_SnapshotLegacy = requireAssignableTo<TypeOnly<current.SnapshotLegacy>, TypeOnly<old.SnapshotLegacy>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SortedSegmentSet": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SortedSegmentSet = requireAssignableTo<TypeOnly<old.SortedSegmentSet>, TypeOnly<current.SortedSegmentSet>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SortedSegmentSet": {"backCompat": false}
 */
declare type current_as_old_for_Class_SortedSegmentSet = requireAssignableTo<TypeOnly<current.SortedSegmentSet>, TypeOnly<old.SortedSegmentSet>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Stack": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Stack = requireAssignableTo<TypeOnly<old.Stack<never>>, TypeOnly<current.Stack<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Stack": {"backCompat": false}
 */
declare type current_as_old_for_Class_Stack = requireAssignableTo<TypeOnly<current.Stack<never>>, TypeOnly<old.Stack<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TextSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TextSegment = requireAssignableTo<TypeOnly<old.TextSegment>, TypeOnly<current.TextSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TextSegment": {"backCompat": false}
 */
declare type current_as_old_for_Class_TextSegment = requireAssignableTo<TypeOnly<current.TextSegment>, TypeOnly<old.TextSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TrackingGroup": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TrackingGroup = requireAssignableTo<TypeOnly<old.TrackingGroup>, TypeOnly<current.TrackingGroup>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TrackingGroup": {"backCompat": false}
 */
declare type current_as_old_for_Class_TrackingGroup = requireAssignableTo<TypeOnly<current.TrackingGroup>, TypeOnly<old.TrackingGroup>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TrackingGroupCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TrackingGroupCollection = requireAssignableTo<TypeOnly<old.TrackingGroupCollection>, TypeOnly<current.TrackingGroupCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TrackingGroupCollection": {"backCompat": false}
 */
declare type current_as_old_for_Class_TrackingGroupCollection = requireAssignableTo<TypeOnly<current.TrackingGroupCollection>, TypeOnly<old.TrackingGroupCollection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TST": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TST = requireAssignableTo<TypeOnly<old.TST<never>>, TypeOnly<current.TST<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TST": {"backCompat": false}
 */
declare type current_as_old_for_Class_TST = requireAssignableTo<TypeOnly<current.TST<never>>, TypeOnly<old.TST<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_BaseSegment": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_BaseSegment = requireAssignableTo<TypeOnly<typeof current.BaseSegment>, TypeOnly<typeof old.BaseSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Client": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Client = requireAssignableTo<TypeOnly<typeof current.Client>, TypeOnly<typeof old.Client>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_CollaborationWindow": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_CollaborationWindow = requireAssignableTo<TypeOnly<typeof current.CollaborationWindow>, TypeOnly<typeof old.CollaborationWindow>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Heap": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Heap = requireAssignableTo<TypeOnly<typeof current.Heap>, TypeOnly<typeof old.Heap>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_IncrementalMapState": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_IncrementalMapState = requireAssignableTo<TypeOnly<typeof current.IncrementalMapState>, TypeOnly<typeof old.IncrementalMapState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_IntervalTree": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_IntervalTree = requireAssignableTo<TypeOnly<typeof current.IntervalTree>, TypeOnly<typeof old.IntervalTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_List": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_List = requireAssignableTo<TypeOnly<typeof current.List>, TypeOnly<typeof old.List>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_LocalReference": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_LocalReference = requireAssignableTo<TypeOnly<typeof current.LocalReference>, TypeOnly<typeof old.LocalReference>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_LocalReferenceCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_LocalReferenceCollection = requireAssignableTo<TypeOnly<typeof current.LocalReferenceCollection>, TypeOnly<typeof old.LocalReferenceCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Marker": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Marker = requireAssignableTo<TypeOnly<typeof current.Marker>, TypeOnly<typeof old.Marker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MergeBlock": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MergeBlock = requireAssignableTo<TypeOnly<typeof current.MergeBlock>, TypeOnly<typeof old.MergeBlock>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MergeNode": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MergeNode = requireAssignableTo<TypeOnly<typeof current.MergeNode>, TypeOnly<typeof old.MergeNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MergeTree": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MergeTree = requireAssignableTo<TypeOnly<typeof current.MergeTree>, TypeOnly<typeof old.MergeTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MergeTreeTextHelper": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MergeTreeTextHelper = requireAssignableTo<TypeOnly<typeof current.MergeTreeTextHelper>, TypeOnly<typeof old.MergeTreeTextHelper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_PropertiesManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_PropertiesManager = requireAssignableTo<TypeOnly<typeof current.PropertiesManager>, TypeOnly<typeof old.PropertiesManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RedBlackTree": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RedBlackTree = requireAssignableTo<TypeOnly<typeof current.RedBlackTree>, TypeOnly<typeof old.RedBlackTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SegmentGroupCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SegmentGroupCollection = requireAssignableTo<TypeOnly<typeof current.SegmentGroupCollection>, TypeOnly<typeof old.SegmentGroupCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SnapshotLegacy": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SnapshotLegacy = requireAssignableTo<TypeOnly<typeof current.SnapshotLegacy>, TypeOnly<typeof old.SnapshotLegacy>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SortedSegmentSet": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SortedSegmentSet = requireAssignableTo<TypeOnly<typeof current.SortedSegmentSet>, TypeOnly<typeof old.SortedSegmentSet>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Stack": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Stack = requireAssignableTo<TypeOnly<typeof current.Stack>, TypeOnly<typeof old.Stack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TextSegment": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TextSegment = requireAssignableTo<TypeOnly<typeof current.TextSegment>, TypeOnly<typeof old.TextSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TrackingGroup": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TrackingGroup = requireAssignableTo<TypeOnly<typeof current.TrackingGroup>, TypeOnly<typeof old.TrackingGroup>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TrackingGroupCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TrackingGroupCollection = requireAssignableTo<TypeOnly<typeof current.TrackingGroupCollection>, TypeOnly<typeof old.TrackingGroupCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TST": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TST = requireAssignableTo<TypeOnly<typeof current.TST>, TypeOnly<typeof old.TST>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_IncrementalExecOp": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_IncrementalExecOp = requireAssignableTo<TypeOnly<old.IncrementalExecOp>, TypeOnly<current.IncrementalExecOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_IncrementalExecOp": {"backCompat": false}
 */
declare type current_as_old_for_Enum_IncrementalExecOp = requireAssignableTo<TypeOnly<current.IncrementalExecOp>, TypeOnly<old.IncrementalExecOp>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ReferenceType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_ReferenceType = requireAssignableTo<TypeOnly<old.ReferenceType>, TypeOnly<current.ReferenceType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ReferenceType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_ReferenceType = requireAssignableTo<TypeOnly<current.ReferenceType>, TypeOnly<old.ReferenceType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_addProperties": {"backCompat": false}
 */
declare type current_as_old_for_Function_addProperties = requireAssignableTo<TypeOnly<typeof current.addProperties>, TypeOnly<typeof old.addProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_clone": {"backCompat": false}
 */
declare type current_as_old_for_Function_clone = requireAssignableTo<TypeOnly<typeof current.clone>, TypeOnly<typeof old.clone>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_combine": {"backCompat": false}
 */
declare type current_as_old_for_Function_combine = requireAssignableTo<TypeOnly<typeof current.combine>, TypeOnly<typeof old.combine>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_compareReferencePositions": {"backCompat": false}
 */
declare type current_as_old_for_Function_compareReferencePositions = requireAssignableTo<TypeOnly<typeof current.compareReferencePositions>, TypeOnly<typeof old.compareReferencePositions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createAnnotateMarkerOp": {"backCompat": false}
 */
declare type current_as_old_for_Function_createAnnotateMarkerOp = requireAssignableTo<TypeOnly<typeof current.createAnnotateMarkerOp>, TypeOnly<typeof old.createAnnotateMarkerOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createAnnotateRangeOp": {"backCompat": false}
 */
declare type current_as_old_for_Function_createAnnotateRangeOp = requireAssignableTo<TypeOnly<typeof current.createAnnotateRangeOp>, TypeOnly<typeof old.createAnnotateRangeOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createGroupOp": {"backCompat": false}
 */
declare type current_as_old_for_Function_createGroupOp = requireAssignableTo<TypeOnly<typeof current.createGroupOp>, TypeOnly<typeof old.createGroupOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createInsertOp": {"backCompat": false}
 */
declare type current_as_old_for_Function_createInsertOp = requireAssignableTo<TypeOnly<typeof current.createInsertOp>, TypeOnly<typeof old.createInsertOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createInsertSegmentOp": {"backCompat": false}
 */
declare type current_as_old_for_Function_createInsertSegmentOp = requireAssignableTo<TypeOnly<typeof current.createInsertSegmentOp>, TypeOnly<typeof old.createInsertSegmentOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createMap": {"backCompat": false}
 */
declare type current_as_old_for_Function_createMap = requireAssignableTo<TypeOnly<typeof current.createMap>, TypeOnly<typeof old.createMap>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createRemoveRangeOp": {"backCompat": false}
 */
declare type current_as_old_for_Function_createRemoveRangeOp = requireAssignableTo<TypeOnly<typeof current.createRemoveRangeOp>, TypeOnly<typeof old.createRemoveRangeOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_extend": {"backCompat": false}
 */
declare type current_as_old_for_Function_extend = requireAssignableTo<TypeOnly<typeof current.extend>, TypeOnly<typeof old.extend>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_extendIfUndefined": {"backCompat": false}
 */
declare type current_as_old_for_Function_extendIfUndefined = requireAssignableTo<TypeOnly<typeof current.extendIfUndefined>, TypeOnly<typeof old.extendIfUndefined>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_internedSpaces": {"backCompat": false}
 */
declare type current_as_old_for_Function_internedSpaces = requireAssignableTo<TypeOnly<typeof current.internedSpaces>, TypeOnly<typeof old.internedSpaces>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_ListMakeHead": {"backCompat": false}
 */
declare type current_as_old_for_Function_ListMakeHead = requireAssignableTo<TypeOnly<typeof current.ListMakeHead>, TypeOnly<typeof old.ListMakeHead>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_ListRemoveEntry": {"backCompat": false}
 */
declare type current_as_old_for_Function_ListRemoveEntry = requireAssignableTo<TypeOnly<typeof current.ListRemoveEntry>, TypeOnly<typeof old.ListRemoveEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_matchProperties": {"backCompat": false}
 */
declare type current_as_old_for_Function_matchProperties = requireAssignableTo<TypeOnly<typeof current.matchProperties>, TypeOnly<typeof old.matchProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_maxReferencePosition": {"backCompat": false}
 */
declare type current_as_old_for_Function_maxReferencePosition = requireAssignableTo<TypeOnly<typeof current.maxReferencePosition>, TypeOnly<typeof old.maxReferencePosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_minReferencePosition": {"backCompat": false}
 */
declare type current_as_old_for_Function_minReferencePosition = requireAssignableTo<TypeOnly<typeof current.minReferencePosition>, TypeOnly<typeof old.minReferencePosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_ordinalToArray": {"backCompat": false}
 */
declare type current_as_old_for_Function_ordinalToArray = requireAssignableTo<TypeOnly<typeof current.ordinalToArray>, TypeOnly<typeof old.ordinalToArray>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_refHasRangeLabel": {"backCompat": false}
 */
declare type current_as_old_for_Function_refHasRangeLabel = requireAssignableTo<TypeOnly<typeof current.refHasRangeLabel>, TypeOnly<typeof old.refHasRangeLabel>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_refHasRangeLabels": {"backCompat": false}
 */
declare type current_as_old_for_Function_refHasRangeLabels = requireAssignableTo<TypeOnly<typeof current.refHasRangeLabels>, TypeOnly<typeof old.refHasRangeLabels>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_refHasTileLabel": {"backCompat": false}
 */
declare type current_as_old_for_Function_refHasTileLabel = requireAssignableTo<TypeOnly<typeof current.refHasTileLabel>, TypeOnly<typeof old.refHasTileLabel>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_refHasTileLabels": {"backCompat": false}
 */
declare type current_as_old_for_Function_refHasTileLabels = requireAssignableTo<TypeOnly<typeof current.refHasTileLabels>, TypeOnly<typeof old.refHasTileLabels>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_refTypeIncludesFlag": {"backCompat": false}
 */
declare type current_as_old_for_Function_refTypeIncludesFlag = requireAssignableTo<TypeOnly<typeof current.refTypeIncludesFlag>, TypeOnly<typeof old.refTypeIncludesFlag>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_toRemovalInfo": {"backCompat": false}
 */
declare type current_as_old_for_Function_toRemovalInfo = requireAssignableTo<TypeOnly<typeof current.toRemovalInfo>, TypeOnly<typeof old.toRemovalInfo>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_AugmentedIntervalNode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_AugmentedIntervalNode = requireAssignableTo<TypeOnly<old.AugmentedIntervalNode>, TypeOnly<current.AugmentedIntervalNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_AugmentedIntervalNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_AugmentedIntervalNode = requireAssignableTo<TypeOnly<current.AugmentedIntervalNode>, TypeOnly<old.AugmentedIntervalNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_BlockAction": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_BlockAction = requireAssignableTo<TypeOnly<old.BlockAction<never>>, TypeOnly<current.BlockAction<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_BlockAction": {"backCompat": false}
 */
declare type current_as_old_for_Interface_BlockAction = requireAssignableTo<TypeOnly<current.BlockAction<never>>, TypeOnly<old.BlockAction<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_BlockUpdateActions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_BlockUpdateActions = requireAssignableTo<TypeOnly<old.BlockUpdateActions>, TypeOnly<current.BlockUpdateActions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_BlockUpdateActions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_BlockUpdateActions = requireAssignableTo<TypeOnly<current.BlockUpdateActions>, TypeOnly<old.BlockUpdateActions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ClientSeq": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ClientSeq = requireAssignableTo<TypeOnly<old.ClientSeq>, TypeOnly<current.ClientSeq>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ClientSeq": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ClientSeq = requireAssignableTo<TypeOnly<current.ClientSeq>, TypeOnly<old.ClientSeq>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_Comparer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_Comparer = requireAssignableTo<TypeOnly<old.Comparer<never>>, TypeOnly<current.Comparer<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_Comparer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_Comparer = requireAssignableTo<TypeOnly<current.Comparer<never>>, TypeOnly<old.Comparer<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_Dictionary": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_Dictionary = requireAssignableTo<TypeOnly<old.Dictionary<never,never>>, TypeOnly<current.Dictionary<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_Dictionary": {"backCompat": false}
 */
declare type current_as_old_for_Interface_Dictionary = requireAssignableTo<TypeOnly<current.Dictionary<never,never>>, TypeOnly<old.Dictionary<never,never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICombiningOp": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICombiningOp = requireAssignableTo<TypeOnly<old.ICombiningOp>, TypeOnly<current.ICombiningOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICombiningOp": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICombiningOp = requireAssignableTo<TypeOnly<current.ICombiningOp>, TypeOnly<old.ICombiningOp>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConsensusInfo": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConsensusInfo = requireAssignableTo<TypeOnly<old.IConsensusInfo>, TypeOnly<current.IConsensusInfo>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConsensusInfo": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConsensusInfo = requireAssignableTo<TypeOnly<current.IConsensusInfo>, TypeOnly<old.IConsensusInfo>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConsensusValue": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConsensusValue = requireAssignableTo<TypeOnly<old.IConsensusValue>, TypeOnly<current.IConsensusValue>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConsensusValue": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConsensusValue = requireAssignableTo<TypeOnly<current.IConsensusValue>, TypeOnly<old.IConsensusValue>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IHierBlock": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IHierBlock = requireAssignableTo<TypeOnly<old.IHierBlock>, TypeOnly<current.IHierBlock>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IHierBlock": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IHierBlock = requireAssignableTo<TypeOnly<current.IHierBlock>, TypeOnly<old.IHierBlock>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IIntegerRange": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IIntegerRange = requireAssignableTo<TypeOnly<old.IIntegerRange>, TypeOnly<current.IIntegerRange>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IIntegerRange": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IIntegerRange = requireAssignableTo<TypeOnly<current.IIntegerRange>, TypeOnly<old.IIntegerRange>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IInterval": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IInterval = requireAssignableTo<TypeOnly<old.IInterval>, TypeOnly<current.IInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IInterval": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IInterval = requireAssignableTo<TypeOnly<current.IInterval>, TypeOnly<old.IInterval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IJSONMarkerSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IJSONMarkerSegment = requireAssignableTo<TypeOnly<old.IJSONMarkerSegment>, TypeOnly<current.IJSONMarkerSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IJSONMarkerSegment": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IJSONMarkerSegment = requireAssignableTo<TypeOnly<current.IJSONMarkerSegment>, TypeOnly<old.IJSONMarkerSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IJSONSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IJSONSegment = requireAssignableTo<TypeOnly<old.IJSONSegment>, TypeOnly<current.IJSONSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IJSONSegment": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IJSONSegment = requireAssignableTo<TypeOnly<current.IJSONSegment>, TypeOnly<old.IJSONSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IJSONTextSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IJSONTextSegment = requireAssignableTo<TypeOnly<old.IJSONTextSegment>, TypeOnly<current.IJSONTextSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IJSONTextSegment": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IJSONTextSegment = requireAssignableTo<TypeOnly<current.IJSONTextSegment>, TypeOnly<old.IJSONTextSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMarkerDef": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMarkerDef = requireAssignableTo<TypeOnly<old.IMarkerDef>, TypeOnly<current.IMarkerDef>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMarkerDef": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMarkerDef = requireAssignableTo<TypeOnly<current.IMarkerDef>, TypeOnly<old.IMarkerDef>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMarkerModifiedAction": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMarkerModifiedAction = requireAssignableTo<TypeOnly<old.IMarkerModifiedAction>, TypeOnly<current.IMarkerModifiedAction>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMarkerModifiedAction": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMarkerModifiedAction = requireAssignableTo<TypeOnly<current.IMarkerModifiedAction>, TypeOnly<old.IMarkerModifiedAction>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeBlock": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMergeBlock = requireAssignableTo<TypeOnly<old.IMergeBlock>, TypeOnly<current.IMergeBlock>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeBlock": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMergeBlock = requireAssignableTo<TypeOnly<current.IMergeBlock>, TypeOnly<old.IMergeBlock>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeNodeCommon": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMergeNodeCommon = requireAssignableTo<TypeOnly<old.IMergeNodeCommon>, TypeOnly<current.IMergeNodeCommon>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeNodeCommon": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMergeNodeCommon = requireAssignableTo<TypeOnly<current.IMergeNodeCommon>, TypeOnly<old.IMergeNodeCommon>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeAnnotateMsg": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMergeTreeAnnotateMsg = requireAssignableTo<TypeOnly<old.IMergeTreeAnnotateMsg>, TypeOnly<current.IMergeTreeAnnotateMsg>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeAnnotateMsg": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMergeTreeAnnotateMsg = requireAssignableTo<TypeOnly<current.IMergeTreeAnnotateMsg>, TypeOnly<old.IMergeTreeAnnotateMsg>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeClientSequenceArgs": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMergeTreeClientSequenceArgs = requireAssignableTo<TypeOnly<old.IMergeTreeClientSequenceArgs>, TypeOnly<current.IMergeTreeClientSequenceArgs>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeClientSequenceArgs": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMergeTreeClientSequenceArgs = requireAssignableTo<TypeOnly<current.IMergeTreeClientSequenceArgs>, TypeOnly<old.IMergeTreeClientSequenceArgs>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeDelta": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMergeTreeDelta = requireAssignableTo<TypeOnly<old.IMergeTreeDelta>, TypeOnly<current.IMergeTreeDelta>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeDelta": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMergeTreeDelta = requireAssignableTo<TypeOnly<current.IMergeTreeDelta>, TypeOnly<old.IMergeTreeDelta>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeDeltaCallbackArgs": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMergeTreeDeltaCallbackArgs = requireAssignableTo<TypeOnly<old.IMergeTreeDeltaCallbackArgs>, TypeOnly<current.IMergeTreeDeltaCallbackArgs>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeDeltaCallbackArgs": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMergeTreeDeltaCallbackArgs = requireAssignableTo<TypeOnly<current.IMergeTreeDeltaCallbackArgs>, TypeOnly<old.IMergeTreeDeltaCallbackArgs>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeDeltaOpArgs": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMergeTreeDeltaOpArgs = requireAssignableTo<TypeOnly<old.IMergeTreeDeltaOpArgs>, TypeOnly<current.IMergeTreeDeltaOpArgs>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeDeltaOpArgs": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMergeTreeDeltaOpArgs = requireAssignableTo<TypeOnly<current.IMergeTreeDeltaOpArgs>, TypeOnly<old.IMergeTreeDeltaOpArgs>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeGroupMsg": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMergeTreeGroupMsg = requireAssignableTo<TypeOnly<old.IMergeTreeGroupMsg>, TypeOnly<current.IMergeTreeGroupMsg>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeGroupMsg": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMergeTreeGroupMsg = requireAssignableTo<TypeOnly<current.IMergeTreeGroupMsg>, TypeOnly<old.IMergeTreeGroupMsg>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeInsertMsg": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMergeTreeInsertMsg = requireAssignableTo<TypeOnly<old.IMergeTreeInsertMsg>, TypeOnly<current.IMergeTreeInsertMsg>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeInsertMsg": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMergeTreeInsertMsg = requireAssignableTo<TypeOnly<current.IMergeTreeInsertMsg>, TypeOnly<old.IMergeTreeInsertMsg>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeMaintenanceCallbackArgs": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMergeTreeMaintenanceCallbackArgs = requireAssignableTo<TypeOnly<old.IMergeTreeMaintenanceCallbackArgs>, TypeOnly<current.IMergeTreeMaintenanceCallbackArgs>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeMaintenanceCallbackArgs": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMergeTreeMaintenanceCallbackArgs = requireAssignableTo<TypeOnly<current.IMergeTreeMaintenanceCallbackArgs>, TypeOnly<old.IMergeTreeMaintenanceCallbackArgs>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeRemoveMsg": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMergeTreeRemoveMsg = requireAssignableTo<TypeOnly<old.IMergeTreeRemoveMsg>, TypeOnly<current.IMergeTreeRemoveMsg>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeRemoveMsg": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMergeTreeRemoveMsg = requireAssignableTo<TypeOnly<current.IMergeTreeRemoveMsg>, TypeOnly<old.IMergeTreeRemoveMsg>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeSegmentDelta": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMergeTreeSegmentDelta = requireAssignableTo<TypeOnly<old.IMergeTreeSegmentDelta>, TypeOnly<current.IMergeTreeSegmentDelta>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMergeTreeSegmentDelta": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMergeTreeSegmentDelta = requireAssignableTo<TypeOnly<current.IMergeTreeSegmentDelta>, TypeOnly<old.IMergeTreeSegmentDelta>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IncrementalBlockAction": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IncrementalBlockAction = requireAssignableTo<TypeOnly<old.IncrementalBlockAction<never>>, TypeOnly<current.IncrementalBlockAction<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IncrementalBlockAction": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IncrementalBlockAction = requireAssignableTo<TypeOnly<current.IncrementalBlockAction<never>>, TypeOnly<old.IncrementalBlockAction<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IncrementalSegmentAction": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IncrementalSegmentAction = requireAssignableTo<TypeOnly<old.IncrementalSegmentAction<never>>, TypeOnly<current.IncrementalSegmentAction<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IncrementalSegmentAction": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IncrementalSegmentAction = requireAssignableTo<TypeOnly<current.IncrementalSegmentAction<never>>, TypeOnly<old.IncrementalSegmentAction<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IncrementalSegmentActions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IncrementalSegmentActions = requireAssignableTo<TypeOnly<old.IncrementalSegmentActions<never>>, TypeOnly<current.IncrementalSegmentActions<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IncrementalSegmentActions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IncrementalSegmentActions = requireAssignableTo<TypeOnly<current.IncrementalSegmentActions<never>>, TypeOnly<old.IncrementalSegmentActions<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_InsertContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_InsertContext = requireAssignableTo<TypeOnly<old.InsertContext>, TypeOnly<current.InsertContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_InsertContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_InsertContext = requireAssignableTo<TypeOnly<current.InsertContext>, TypeOnly<old.InsertContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRBAugmentation": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRBAugmentation = requireAssignableTo<TypeOnly<old.IRBAugmentation<never,never>>, TypeOnly<current.IRBAugmentation<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRBAugmentation": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRBAugmentation = requireAssignableTo<TypeOnly<current.IRBAugmentation<never,never>>, TypeOnly<old.IRBAugmentation<never,never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRBMatcher": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRBMatcher = requireAssignableTo<TypeOnly<old.IRBMatcher<never,never>>, TypeOnly<current.IRBMatcher<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRBMatcher": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRBMatcher = requireAssignableTo<TypeOnly<current.IRBMatcher<never,never>>, TypeOnly<old.IRBMatcher<never,never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRelativePosition": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRelativePosition = requireAssignableTo<TypeOnly<old.IRelativePosition>, TypeOnly<current.IRelativePosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRelativePosition": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRelativePosition = requireAssignableTo<TypeOnly<current.IRelativePosition>, TypeOnly<old.IRelativePosition>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRemovalInfo": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRemovalInfo = requireAssignableTo<TypeOnly<old.IRemovalInfo>, TypeOnly<current.IRemovalInfo>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRemovalInfo": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRemovalInfo = requireAssignableTo<TypeOnly<current.IRemovalInfo>, TypeOnly<old.IRemovalInfo>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISegment": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISegment = requireAssignableTo<TypeOnly<old.ISegment>, TypeOnly<current.ISegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISegment": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISegment = requireAssignableTo<TypeOnly<current.ISegment>, TypeOnly<old.ISegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISegmentAction": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISegmentAction = requireAssignableTo<TypeOnly<old.ISegmentAction<never>>, TypeOnly<current.ISegmentAction<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISegmentAction": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISegmentAction = requireAssignableTo<TypeOnly<current.ISegmentAction<never>>, TypeOnly<old.ISegmentAction<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISegmentChanges": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISegmentChanges = requireAssignableTo<TypeOnly<old.ISegmentChanges>, TypeOnly<current.ISegmentChanges>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISegmentChanges": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISegmentChanges = requireAssignableTo<TypeOnly<current.ISegmentChanges>, TypeOnly<old.ISegmentChanges>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_KeyComparer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_KeyComparer = requireAssignableTo<TypeOnly<old.KeyComparer<never>>, TypeOnly<current.KeyComparer<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_KeyComparer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_KeyComparer = requireAssignableTo<TypeOnly<current.KeyComparer<never>>, TypeOnly<old.KeyComparer<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_LocalReferencePosition": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_LocalReferencePosition = requireAssignableTo<TypeOnly<old.LocalReferencePosition>, TypeOnly<current.LocalReferencePosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_LocalReferencePosition": {"backCompat": false}
 */
declare type current_as_old_for_Interface_LocalReferencePosition = requireAssignableTo<TypeOnly<current.LocalReferencePosition>, TypeOnly<old.LocalReferencePosition>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_LRUSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_LRUSegment = requireAssignableTo<TypeOnly<old.LRUSegment>, TypeOnly<current.LRUSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_LRUSegment": {"backCompat": false}
 */
declare type current_as_old_for_Interface_LRUSegment = requireAssignableTo<TypeOnly<current.LRUSegment>, TypeOnly<old.LRUSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MapLike": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_MapLike = requireAssignableTo<TypeOnly<old.MapLike<never>>, TypeOnly<current.MapLike<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MapLike": {"backCompat": false}
 */
declare type current_as_old_for_Interface_MapLike = requireAssignableTo<TypeOnly<current.MapLike<never>>, TypeOnly<old.MapLike<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MergeTreeStats": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_MergeTreeStats = requireAssignableTo<TypeOnly<old.MergeTreeStats>, TypeOnly<current.MergeTreeStats>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MergeTreeStats": {"backCompat": false}
 */
declare type current_as_old_for_Interface_MergeTreeStats = requireAssignableTo<TypeOnly<current.MergeTreeStats>, TypeOnly<old.MergeTreeStats>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MinListener": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_MinListener = requireAssignableTo<TypeOnly<old.MinListener>, TypeOnly<current.MinListener>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MinListener": {"backCompat": false}
 */
declare type current_as_old_for_Interface_MinListener = requireAssignableTo<TypeOnly<current.MinListener>, TypeOnly<old.MinListener>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_NodeAction": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_NodeAction = requireAssignableTo<TypeOnly<old.NodeAction<never>>, TypeOnly<current.NodeAction<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_NodeAction": {"backCompat": false}
 */
declare type current_as_old_for_Interface_NodeAction = requireAssignableTo<TypeOnly<current.NodeAction<never>>, TypeOnly<old.NodeAction<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_Property": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_Property = requireAssignableTo<TypeOnly<old.Property<never,never>>, TypeOnly<current.Property<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_Property": {"backCompat": false}
 */
declare type current_as_old_for_Interface_Property = requireAssignableTo<TypeOnly<current.Property<never,never>>, TypeOnly<old.Property<never,never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_PropertyAction": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_PropertyAction = requireAssignableTo<TypeOnly<old.PropertyAction<never,never>>, TypeOnly<current.PropertyAction<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_PropertyAction": {"backCompat": false}
 */
declare type current_as_old_for_Interface_PropertyAction = requireAssignableTo<TypeOnly<current.PropertyAction<never,never>>, TypeOnly<old.PropertyAction<never,never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ProxString": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ProxString = requireAssignableTo<TypeOnly<old.ProxString<never>>, TypeOnly<current.ProxString<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ProxString": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ProxString = requireAssignableTo<TypeOnly<current.ProxString<never>>, TypeOnly<old.ProxString<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_QProperty": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_QProperty = requireAssignableTo<TypeOnly<old.QProperty<never,never>>, TypeOnly<current.QProperty<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_QProperty": {"backCompat": false}
 */
declare type current_as_old_for_Interface_QProperty = requireAssignableTo<TypeOnly<current.QProperty<never,never>>, TypeOnly<old.QProperty<never,never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_RBNode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_RBNode = requireAssignableTo<TypeOnly<old.RBNode<never,never>>, TypeOnly<current.RBNode<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_RBNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_RBNode = requireAssignableTo<TypeOnly<current.RBNode<never,never>>, TypeOnly<old.RBNode<never,never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_RBNodeActions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_RBNodeActions = requireAssignableTo<TypeOnly<old.RBNodeActions<never,never>>, TypeOnly<current.RBNodeActions<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_RBNodeActions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_RBNodeActions = requireAssignableTo<TypeOnly<current.RBNodeActions<never,never>>, TypeOnly<old.RBNodeActions<never,never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ReferencePosition": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ReferencePosition = requireAssignableTo<TypeOnly<old.ReferencePosition>, TypeOnly<current.ReferencePosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ReferencePosition": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ReferencePosition = requireAssignableTo<TypeOnly<current.ReferencePosition>, TypeOnly<old.ReferencePosition>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SearchResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_SearchResult = requireAssignableTo<TypeOnly<old.SearchResult>, TypeOnly<current.SearchResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SearchResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_SearchResult = requireAssignableTo<TypeOnly<current.SearchResult>, TypeOnly<old.SearchResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SegmentAccumulator": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_SegmentAccumulator = requireAssignableTo<TypeOnly<old.SegmentAccumulator>, TypeOnly<current.SegmentAccumulator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SegmentAccumulator": {"backCompat": false}
 */
declare type current_as_old_for_Interface_SegmentAccumulator = requireAssignableTo<TypeOnly<current.SegmentAccumulator>, TypeOnly<old.SegmentAccumulator>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SegmentActions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_SegmentActions = requireAssignableTo<TypeOnly<old.SegmentActions<never>>, TypeOnly<current.SegmentActions<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SegmentActions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_SegmentActions = requireAssignableTo<TypeOnly<current.SegmentActions<never>>, TypeOnly<old.SegmentActions<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SegmentGroup": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_SegmentGroup = requireAssignableTo<TypeOnly<old.SegmentGroup>, TypeOnly<current.SegmentGroup>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SegmentGroup": {"backCompat": false}
 */
declare type current_as_old_for_Interface_SegmentGroup = requireAssignableTo<TypeOnly<current.SegmentGroup>, TypeOnly<old.SegmentGroup>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SortedDictionary": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_SortedDictionary = requireAssignableTo<TypeOnly<old.SortedDictionary<never,never>>, TypeOnly<current.SortedDictionary<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SortedDictionary": {"backCompat": false}
 */
declare type current_as_old_for_Interface_SortedDictionary = requireAssignableTo<TypeOnly<current.SortedDictionary<never,never>>, TypeOnly<old.SortedDictionary<never,never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TSTNode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_TSTNode = requireAssignableTo<TypeOnly<old.TSTNode<never>>, TypeOnly<current.TSTNode<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TSTNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TSTNode = requireAssignableTo<TypeOnly<current.TSTNode<never>>, TypeOnly<old.TSTNode<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TSTResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_TSTResult = requireAssignableTo<TypeOnly<old.TSTResult<never>>, TypeOnly<current.TSTResult<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TSTResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TSTResult = requireAssignableTo<TypeOnly<current.TSTResult<never>>, TypeOnly<old.TSTResult<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ConflictAction": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ConflictAction = requireAssignableTo<TypeOnly<old.ConflictAction<never,never>>, TypeOnly<current.ConflictAction<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ConflictAction": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ConflictAction = requireAssignableTo<TypeOnly<current.ConflictAction<never,never>>, TypeOnly<old.ConflictAction<never,never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IMergeNode": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IMergeNode = requireAssignableTo<TypeOnly<old.IMergeNode>, TypeOnly<current.IMergeNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IMergeNode": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IMergeNode = requireAssignableTo<TypeOnly<current.IMergeNode>, TypeOnly<old.IMergeNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IMergeTreeDeltaOp": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IMergeTreeDeltaOp = requireAssignableTo<TypeOnly<old.IMergeTreeDeltaOp>, TypeOnly<current.IMergeTreeDeltaOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IMergeTreeDeltaOp": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IMergeTreeDeltaOp = requireAssignableTo<TypeOnly<current.IMergeTreeDeltaOp>, TypeOnly<old.IMergeTreeDeltaOp>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IMergeTreeOp": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IMergeTreeOp = requireAssignableTo<TypeOnly<old.IMergeTreeOp>, TypeOnly<current.IMergeTreeOp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IMergeTreeOp": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IMergeTreeOp = requireAssignableTo<TypeOnly<current.IMergeTreeOp>, TypeOnly<old.IMergeTreeOp>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IntervalConflictResolver": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IntervalConflictResolver = requireAssignableTo<TypeOnly<old.IntervalConflictResolver<never>>, TypeOnly<current.IntervalConflictResolver<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IntervalConflictResolver": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IntervalConflictResolver = requireAssignableTo<TypeOnly<current.IntervalConflictResolver<never>>, TypeOnly<old.IntervalConflictResolver<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IntervalNode": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IntervalNode = requireAssignableTo<TypeOnly<old.IntervalNode<never>>, TypeOnly<current.IntervalNode<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IntervalNode": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IntervalNode = requireAssignableTo<TypeOnly<current.IntervalNode<never>>, TypeOnly<old.IntervalNode<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LocalReferenceMapper": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_LocalReferenceMapper = requireAssignableTo<TypeOnly<old.LocalReferenceMapper>, TypeOnly<current.LocalReferenceMapper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LocalReferenceMapper": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_LocalReferenceMapper = requireAssignableTo<TypeOnly<current.LocalReferenceMapper>, TypeOnly<old.LocalReferenceMapper>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MergeTreeDeltaCallback": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_MergeTreeDeltaCallback = requireAssignableTo<TypeOnly<old.MergeTreeDeltaCallback>, TypeOnly<current.MergeTreeDeltaCallback>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MergeTreeDeltaCallback": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_MergeTreeDeltaCallback = requireAssignableTo<TypeOnly<current.MergeTreeDeltaCallback>, TypeOnly<old.MergeTreeDeltaCallback>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MergeTreeDeltaOperationType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_MergeTreeDeltaOperationType = requireAssignableTo<TypeOnly<old.MergeTreeDeltaOperationType>, TypeOnly<current.MergeTreeDeltaOperationType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MergeTreeDeltaOperationType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_MergeTreeDeltaOperationType = requireAssignableTo<TypeOnly<current.MergeTreeDeltaOperationType>, TypeOnly<old.MergeTreeDeltaOperationType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MergeTreeDeltaOperationTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_MergeTreeDeltaOperationTypes = requireAssignableTo<TypeOnly<old.MergeTreeDeltaOperationTypes>, TypeOnly<current.MergeTreeDeltaOperationTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MergeTreeDeltaOperationTypes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_MergeTreeDeltaOperationTypes = requireAssignableTo<TypeOnly<current.MergeTreeDeltaOperationTypes>, TypeOnly<old.MergeTreeDeltaOperationTypes>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MergeTreeDeltaType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_MergeTreeDeltaType = requireAssignableTo<TypeOnly<old.MergeTreeDeltaType>, TypeOnly<current.MergeTreeDeltaType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MergeTreeDeltaType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_MergeTreeDeltaType = requireAssignableTo<TypeOnly<current.MergeTreeDeltaType>, TypeOnly<old.MergeTreeDeltaType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MergeTreeMaintenanceCallback": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_MergeTreeMaintenanceCallback = requireAssignableTo<TypeOnly<old.MergeTreeMaintenanceCallback>, TypeOnly<current.MergeTreeMaintenanceCallback>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MergeTreeMaintenanceCallback": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_MergeTreeMaintenanceCallback = requireAssignableTo<TypeOnly<current.MergeTreeMaintenanceCallback>, TypeOnly<old.MergeTreeMaintenanceCallback>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MergeTreeMaintenanceType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_MergeTreeMaintenanceType = requireAssignableTo<TypeOnly<old.MergeTreeMaintenanceType>, TypeOnly<current.MergeTreeMaintenanceType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MergeTreeMaintenanceType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_MergeTreeMaintenanceType = requireAssignableTo<TypeOnly<current.MergeTreeMaintenanceType>, TypeOnly<old.MergeTreeMaintenanceType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_PropertySet": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_PropertySet = requireAssignableTo<TypeOnly<old.PropertySet>, TypeOnly<current.PropertySet>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_PropertySet": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_PropertySet = requireAssignableTo<TypeOnly<current.PropertySet>, TypeOnly<old.PropertySet>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RangeStackMap": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_RangeStackMap = requireAssignableTo<TypeOnly<old.RangeStackMap>, TypeOnly<current.RangeStackMap>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RangeStackMap": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_RangeStackMap = requireAssignableTo<TypeOnly<current.RangeStackMap>, TypeOnly<old.RangeStackMap>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RBColor": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_RBColor = requireAssignableTo<TypeOnly<old.RBColor>, TypeOnly<current.RBColor>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RBColor": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_RBColor = requireAssignableTo<TypeOnly<current.RBColor>, TypeOnly<old.RBColor>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_clientSeqComparer": {"backCompat": false}
 */
declare type current_as_old_for_Variable_clientSeqComparer = requireAssignableTo<TypeOnly<typeof current.clientSeqComparer>, TypeOnly<typeof old.clientSeqComparer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_compareNumbers": {"backCompat": false}
 */
declare type current_as_old_for_Variable_compareNumbers = requireAssignableTo<TypeOnly<typeof current.compareNumbers>, TypeOnly<typeof old.compareNumbers>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_compareStrings": {"backCompat": false}
 */
declare type current_as_old_for_Variable_compareStrings = requireAssignableTo<TypeOnly<typeof current.compareStrings>, TypeOnly<typeof old.compareStrings>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_DetachedReferencePosition": {"backCompat": false}
 */
declare type current_as_old_for_Variable_DetachedReferencePosition = requireAssignableTo<TypeOnly<typeof current.DetachedReferencePosition>, TypeOnly<typeof old.DetachedReferencePosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_integerRangeToString": {"backCompat": false}
 */
declare type current_as_old_for_Variable_integerRangeToString = requireAssignableTo<TypeOnly<typeof current.integerRangeToString>, TypeOnly<typeof old.integerRangeToString>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_LocalClientId": {"backCompat": false}
 */
declare type current_as_old_for_Variable_LocalClientId = requireAssignableTo<TypeOnly<typeof current.LocalClientId>, TypeOnly<typeof old.LocalClientId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_MaxNodesInBlock": {"backCompat": false}
 */
declare type current_as_old_for_Variable_MaxNodesInBlock = requireAssignableTo<TypeOnly<typeof current.MaxNodesInBlock>, TypeOnly<typeof old.MaxNodesInBlock>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_MergeTreeDeltaType": {"backCompat": false}
 */
declare type current_as_old_for_Variable_MergeTreeDeltaType = requireAssignableTo<TypeOnly<typeof current.MergeTreeDeltaType>, TypeOnly<typeof old.MergeTreeDeltaType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_MergeTreeMaintenanceType": {"backCompat": false}
 */
declare type current_as_old_for_Variable_MergeTreeMaintenanceType = requireAssignableTo<TypeOnly<typeof current.MergeTreeMaintenanceType>, TypeOnly<typeof old.MergeTreeMaintenanceType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_NonCollabClient": {"backCompat": false}
 */
declare type current_as_old_for_Variable_NonCollabClient = requireAssignableTo<TypeOnly<typeof current.NonCollabClient>, TypeOnly<typeof old.NonCollabClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_RBColor": {"backCompat": false}
 */
declare type current_as_old_for_Variable_RBColor = requireAssignableTo<TypeOnly<typeof current.RBColor>, TypeOnly<typeof old.RBColor>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_refGetRangeLabels": {"backCompat": false}
 */
declare type current_as_old_for_Variable_refGetRangeLabels = requireAssignableTo<TypeOnly<typeof current.refGetRangeLabels>, TypeOnly<typeof old.refGetRangeLabels>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_refGetTileLabels": {"backCompat": false}
 */
declare type current_as_old_for_Variable_refGetTileLabels = requireAssignableTo<TypeOnly<typeof current.refGetTileLabels>, TypeOnly<typeof old.refGetTileLabels>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_reservedMarkerIdKey": {"backCompat": false}
 */
declare type current_as_old_for_Variable_reservedMarkerIdKey = requireAssignableTo<TypeOnly<typeof current.reservedMarkerIdKey>, TypeOnly<typeof old.reservedMarkerIdKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_reservedMarkerSimpleTypeKey": {"backCompat": false}
 */
declare type current_as_old_for_Variable_reservedMarkerSimpleTypeKey = requireAssignableTo<TypeOnly<typeof current.reservedMarkerSimpleTypeKey>, TypeOnly<typeof old.reservedMarkerSimpleTypeKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_reservedRangeLabelsKey": {"backCompat": false}
 */
declare type current_as_old_for_Variable_reservedRangeLabelsKey = requireAssignableTo<TypeOnly<typeof current.reservedRangeLabelsKey>, TypeOnly<typeof old.reservedRangeLabelsKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_reservedTileLabelsKey": {"backCompat": false}
 */
declare type current_as_old_for_Variable_reservedTileLabelsKey = requireAssignableTo<TypeOnly<typeof current.reservedTileLabelsKey>, TypeOnly<typeof old.reservedTileLabelsKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_TreeMaintenanceSequenceNumber": {"backCompat": false}
 */
declare type current_as_old_for_Variable_TreeMaintenanceSequenceNumber = requireAssignableTo<TypeOnly<typeof current.TreeMaintenanceSequenceNumber>, TypeOnly<typeof old.TreeMaintenanceSequenceNumber>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_UnassignedSequenceNumber": {"backCompat": false}
 */
declare type current_as_old_for_Variable_UnassignedSequenceNumber = requireAssignableTo<TypeOnly<typeof current.UnassignedSequenceNumber>, TypeOnly<typeof old.UnassignedSequenceNumber>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_UniversalSequenceNumber": {"backCompat": false}
 */
declare type current_as_old_for_Variable_UniversalSequenceNumber = requireAssignableTo<TypeOnly<typeof current.UniversalSequenceNumber>, TypeOnly<typeof old.UniversalSequenceNumber>>
