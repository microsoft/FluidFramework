## Alpha API Report File for "@fluidframework/merge-tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @alpha
export interface AdjustParams {
    delta: number;
    max?: number | undefined;
    min?: number | undefined;
}

// @alpha
export function appendToMergeTreeDeltaRevertibles(deltaArgs: IMergeTreeDeltaCallbackArgs, revertibles: MergeTreeDeltaRevertible[]): void;

// @alpha (undocumented)
export abstract class BaseSegment implements ISegment {
    constructor(properties?: PropertySet);
    // (undocumented)
    protected addSerializedProps(jseg: IJSONSegment): void;
    // (undocumented)
    append(other: ISegment): void;
    // (undocumented)
    attribution?: IAttributionCollection<AttributionKey>;
    // (undocumented)
    cachedLength: number;
    // (undocumented)
    canAppend(segment: ISegment): boolean;
    // @deprecated (undocumented)
    clientId: number;
    // (undocumented)
    abstract clone(): ISegment;
    // (undocumented)
    protected cloneInto(b: ISegment): void;
    // (undocumented)
    protected abstract createSplitSegmentAt(pos: number): BaseSegment | undefined;
    // (undocumented)
    hasProperty(key: string): boolean;
    // @deprecated (undocumented)
    index: number;
    // (undocumented)
    isLeaf(): this is ISegment;
    // @deprecated (undocumented)
    localMovedSeq?: number;
    // @deprecated (undocumented)
    localRemovedSeq?: number;
    // @deprecated (undocumented)
    localSeq?: number;
    // @deprecated (undocumented)
    movedClientIds?: number[];
    // @deprecated (undocumented)
    movedSeq?: number;
    // @deprecated (undocumented)
    movedSeqs?: number[];
    // @deprecated (undocumented)
    ordinal: string;
    // (undocumented)
    properties?: PropertySet;
    // @deprecated (undocumented)
    removedClientIds?: number[];
    // @deprecated (undocumented)
    removedSeq?: number;
    // @deprecated (undocumented)
    seq: number;
    // (undocumented)
    splitAt(pos: number): ISegment | undefined;
    // (undocumented)
    abstract toJSONObject(): any;
    // (undocumented)
    readonly trackingCollection: TrackingGroupCollection;
    // (undocumented)
    abstract readonly type: string;
    // @deprecated (undocumented)
    wasMovedOnInsert?: boolean | undefined;
}

// @alpha
export function discardMergeTreeDeltaRevertible(revertibles: MergeTreeDeltaRevertible[]): void;

// @alpha
export function endpointPosAndSide(start: SequencePlace | undefined, end: SequencePlace | undefined): {
    startSide: Side | undefined;
    endSide: Side | undefined;
    startPos: number | "start" | "end" | undefined;
    endPos: number | "start" | "end" | undefined;
};

// @alpha (undocumented)
export interface IAttributionCollection<T> {
    // (undocumented)
    append(other: IAttributionCollection<T>): void;
    // (undocumented)
    readonly channelNames: Iterable<string>;
    // (undocumented)
    clone(): IAttributionCollection<T>;
    getAll(): IAttributionCollectionSpec<T>;
    getAtOffset(offset: number, channel?: string): AttributionKey | undefined;
    getKeysInOffsetRange(startOffset: number, endOffset?: number, channel?: string): {
        offset: number;
        key: AttributionKey;
    }[] | undefined;
    readonly length: number;
    // (undocumented)
    splitAt(pos: number): IAttributionCollection<T>;
    update(name: string | undefined, channel: IAttributionCollection<T>): void;
}

// @alpha @sealed (undocumented)
export interface IAttributionCollectionSerializer {
    populateAttributionCollections(segments: Iterable<ISegment>, summary: SerializedAttributionCollection): void;
    // (undocumented)
    serializeAttributionCollections(segments: Iterable<{
        attribution?: IAttributionCollection<AttributionKey>;
        cachedLength: number;
    }>): SerializedAttributionCollection;
}

// @alpha (undocumented)
export interface IAttributionCollectionSpec<T> {
    // (undocumented)
    channels?: {
        [name: string]: Iterable<{
            offset: number;
            key: T | null;
        }>;
    };
    // (undocumented)
    length: number;
    // (undocumented)
    root: Iterable<{
        offset: number;
        key: T | null;
    }>;
}

// @alpha (undocumented)
export interface IJSONMarkerSegment extends IJSONSegment {
    // (undocumented)
    marker: IMarkerDef;
}

// @alpha (undocumented)
export interface IJSONSegment {
    // (undocumented)
    props?: Record<string, any>;
}

// @alpha (undocumented)
export interface IJSONTextSegment extends IJSONSegment {
    // (undocumented)
    text: string;
}

// @alpha (undocumented)
export interface IMarkerDef {
    // (undocumented)
    refType?: ReferenceType;
}

// @alpha @deprecated
export interface IMergeNodeCommon {
    index: number;
    // (undocumented)
    isLeaf(): this is ISegment;
    ordinal: string;
}

// @alpha (undocumented)
export interface IMergeTreeAnnotateAdjustMsg extends IMergeTreeDelta {
    // (undocumented)
    adjust: Record<string, AdjustParams>;
    // (undocumented)
    pos1?: number;
    // (undocumented)
    pos2?: number;
    // (undocumented)
    props?: never;
    // (undocumented)
    relativePos1?: undefined;
    // (undocumented)
    relativePos2?: undefined;
    // (undocumented)
    type: typeof MergeTreeDeltaType.ANNOTATE;
}

// @alpha (undocumented)
export interface IMergeTreeAnnotateMsg extends IMergeTreeDelta {
    // (undocumented)
    adjust?: never;
    // (undocumented)
    pos1?: number;
    // (undocumented)
    pos2?: number;
    // (undocumented)
    props: Record<string, any>;
    // (undocumented)
    relativePos1?: IRelativePosition;
    // (undocumented)
    relativePos2?: IRelativePosition;
    // (undocumented)
    type: typeof MergeTreeDeltaType.ANNOTATE;
}

// @alpha (undocumented)
export interface IMergeTreeDelta {
    type: MergeTreeDeltaType;
}

// @alpha (undocumented)
export interface IMergeTreeDeltaCallbackArgs<TOperationType extends MergeTreeDeltaOperationTypes = MergeTreeDeltaOperationType> {
    readonly deltaSegments: IMergeTreeSegmentDelta[];
    readonly operation: TOperationType;
}

// @alpha (undocumented)
export type IMergeTreeDeltaOp = IMergeTreeInsertMsg | IMergeTreeRemoveMsg | IMergeTreeAnnotateMsg | IMergeTreeAnnotateAdjustMsg | IMergeTreeObliterateMsg | IMergeTreeObliterateSidedMsg;

// @alpha (undocumented)
export interface IMergeTreeDeltaOpArgs {
    readonly groupOp?: IMergeTreeGroupMsg;
    readonly op: IMergeTreeOp;
    readonly sequencedMessage?: ISequencedDocumentMessage;
}

// @alpha @deprecated (undocumented)
export interface IMergeTreeGroupMsg extends IMergeTreeDelta {
    // (undocumented)
    ops: IMergeTreeDeltaOp[];
    // (undocumented)
    type: typeof MergeTreeDeltaType.GROUP;
}

// @alpha (undocumented)
export interface IMergeTreeInsertMsg extends IMergeTreeDelta {
    // (undocumented)
    pos1?: number;
    // (undocumented)
    pos2?: number;
    // (undocumented)
    relativePos1?: IRelativePosition;
    // (undocumented)
    relativePos2?: IRelativePosition;
    // (undocumented)
    seg?: any;
    // (undocumented)
    type: typeof MergeTreeDeltaType.INSERT;
}

// @alpha (undocumented)
export interface IMergeTreeMaintenanceCallbackArgs extends IMergeTreeDeltaCallbackArgs<MergeTreeMaintenanceType> {
}

// @alpha @deprecated (undocumented)
export interface IMergeTreeObliterateMsg extends IMergeTreeDelta {
    // (undocumented)
    pos1?: number;
    // (undocumented)
    pos2?: number;
    relativePos1?: never;
    relativePos2?: never;
    // (undocumented)
    type: typeof MergeTreeDeltaType.OBLITERATE;
}

// @alpha (undocumented)
export interface IMergeTreeObliterateSidedMsg extends IMergeTreeDelta {
    // (undocumented)
    pos1: {
        pos: number;
        before: boolean;
    };
    // (undocumented)
    pos2: {
        pos: number;
        before: boolean;
    };
    relativePos1?: never;
    relativePos2?: never;
    // (undocumented)
    type: typeof MergeTreeDeltaType.OBLITERATE_SIDED;
}

// @alpha (undocumented)
export type IMergeTreeOp = IMergeTreeDeltaOp | IMergeTreeGroupMsg;

// @alpha (undocumented)
export interface IMergeTreeOptions {
    // (undocumented)
    catchUpBlobName?: string;
    mergeTreeEnableAnnotateAdjust?: boolean;
    mergeTreeEnableObliterate?: boolean;
    mergeTreeEnableObliterateReconnect?: boolean;
    mergeTreeEnableSidedObliterate?: boolean;
    mergeTreeReferencesCanSlideToEndpoint?: boolean;
    // (undocumented)
    mergeTreeSnapshotChunkSize?: number;
    newMergeTreeSnapshotFormat?: boolean;
}

// @alpha (undocumented)
export interface IMergeTreeRemoveMsg extends IMergeTreeDelta {
    // (undocumented)
    pos1?: number;
    // (undocumented)
    pos2?: number;
    // (undocumented)
    relativePos1?: IRelativePosition;
    // (undocumented)
    relativePos2?: IRelativePosition;
    // (undocumented)
    type: typeof MergeTreeDeltaType.REMOVE;
}

// @alpha (undocumented)
export interface IMergeTreeSegmentDelta {
    propertyDeltas?: PropertySet;
    segment: ISegment;
}

// @alpha @deprecated
export interface IMoveInfo {
    localMovedSeq?: number;
    movedClientIds: number[];
    movedSeq: number;
    movedSeqs: number[];
    moveDst?: ReferencePosition;
    wasMovedOnInsert: boolean;
}

// @alpha
export interface InteriorSequencePlace {
    // (undocumented)
    pos: number;
    // (undocumented)
    side: Side;
}

// @alpha
export interface IRelativePosition {
    before?: boolean;
    id?: string;
    offset?: number;
}

// @alpha @deprecated
export interface IRemovalInfo {
    localRemovedSeq?: number;
    removedClientIds: number[];
    removedSeq: number;
}

// @alpha
export interface ISegment extends ISegmentDeprecated {
    // (undocumented)
    append(segment: ISegment): void;
    attribution?: IAttributionCollection<AttributionKey>;
    cachedLength: number;
    // (undocumented)
    canAppend(segment: ISegment): boolean;
    // (undocumented)
    clone(): ISegment;
    // (undocumented)
    isLeaf(): this is ISegment;
    properties?: PropertySet;
    // (undocumented)
    splitAt(pos: number): ISegment | undefined;
    // (undocumented)
    toJSONObject(): any;
    // (undocumented)
    readonly trackingCollection: TrackingGroupCollection;
    // (undocumented)
    readonly type: string;
}

// @alpha (undocumented)
export interface ISegmentAction<TClientData> {
    // (undocumented)
    (segment: ISegment, pos: number, refSeq: number, clientId: number, start: number, end: number, accum: TClientData): boolean;
}

// @alpha @deprecated (undocumented)
export interface ISegmentDeprecated {
    // @deprecated
    clientId: number;
    // @deprecated
    readonly endpointType?: "start" | "end";
    // @deprecated
    index: number;
    // @deprecated
    localMovedSeq?: number;
    // @deprecated
    localRemovedSeq?: number;
    // @deprecated
    localSeq?: number;
    // @deprecated
    movedClientIds?: number[];
    // @deprecated
    movedSeq?: number;
    // @deprecated
    movedSeqs?: number[];
    // @deprecated
    moveDst?: ReferencePosition;
    // @deprecated
    ordinal: string;
    // @deprecated
    removedClientIds?: number[];
    // @deprecated
    removedSeq?: number;
    // @deprecated
    seq?: number;
    // @deprecated
    wasMovedOnInsert?: boolean;
}

// @alpha (undocumented)
export interface ITrackingGroup {
    // (undocumented)
    has(trackable: Trackable): boolean;
    // (undocumented)
    link(trackable: Trackable): void;
    // (undocumented)
    size: number;
    // (undocumented)
    tracked: readonly Trackable[];
    // (undocumented)
    unlink(trackable: Trackable): boolean;
}

// @alpha @sealed (undocumented)
export interface LocalReferencePosition extends ReferencePosition {
    // (undocumented)
    addProperties(newProps: PropertySet): void;
    // (undocumented)
    callbacks?: Partial<Record<"beforeSlide" | "afterSlide", (ref: LocalReferencePosition) => void>>;
    readonly canSlideToEndpoint?: boolean;
    // (undocumented)
    readonly trackingCollection: TrackingGroupCollection;
}

// @alpha
export interface MapLike<T> {
    // (undocumented)
    [index: string]: T;
}

// @alpha
export class Marker extends BaseSegment implements ReferencePosition, ISegment {
    constructor(refType: ReferenceType, props?: PropertySet);
    // (undocumented)
    append(): void;
    // (undocumented)
    canAppend(segment: ISegment): boolean;
    // (undocumented)
    clone(): Marker;
    // (undocumented)
    protected createSplitSegmentAt(pos: number): undefined;
    // (undocumented)
    static fromJSONObject(spec: IJSONSegment): Marker | undefined;
    // (undocumented)
    getId(): string | undefined;
    // (undocumented)
    getOffset(): number;
    // (undocumented)
    getProperties(): PropertySet | undefined;
    // (undocumented)
    getSegment(): Marker;
    // (undocumented)
    static is(segment: ISegment): segment is Marker;
    // (undocumented)
    static make(refType: ReferenceType, props?: PropertySet): Marker;
    // (undocumented)
    refType: ReferenceType;
    // (undocumented)
    toJSONObject(): IJSONMarkerSegment;
    // (undocumented)
    toString(): string;
    // (undocumented)
    static readonly type = "Marker";
    // (undocumented)
    readonly type = "Marker";
}

// @alpha (undocumented)
export type MergeTreeDeltaOperationType = typeof MergeTreeDeltaType.ANNOTATE | typeof MergeTreeDeltaType.INSERT | typeof MergeTreeDeltaType.REMOVE | typeof MergeTreeDeltaType.OBLITERATE;

// @alpha (undocumented)
export type MergeTreeDeltaOperationTypes = MergeTreeDeltaOperationType | MergeTreeMaintenanceType;

// @alpha (undocumented)
export type MergeTreeDeltaRevertible = {
    operation: typeof MergeTreeDeltaType.INSERT;
    trackingGroup: ITrackingGroup;
} | {
    operation: typeof MergeTreeDeltaType.REMOVE;
    trackingGroup: ITrackingGroup;
} | {
    operation: typeof MergeTreeDeltaType.ANNOTATE;
    trackingGroup: ITrackingGroup;
    propertyDeltas: PropertySet;
};

// @alpha (undocumented)
export const MergeTreeDeltaType: {
    readonly INSERT: 0;
    readonly REMOVE: 1;
    readonly ANNOTATE: 2;
    readonly GROUP: 3;
    readonly OBLITERATE: 4;
    readonly OBLITERATE_SIDED: 5;
};

// @alpha (undocumented)
export type MergeTreeDeltaType = (typeof MergeTreeDeltaType)[keyof typeof MergeTreeDeltaType];

// @alpha
export const MergeTreeMaintenanceType: {
    readonly APPEND: -1;
    readonly SPLIT: -2;
    readonly UNLINK: -3;
    readonly ACKNOWLEDGED: -4;
};

// @alpha (undocumented)
export type MergeTreeMaintenanceType = (typeof MergeTreeMaintenanceType)[keyof typeof MergeTreeMaintenanceType];

// @alpha (undocumented)
export interface MergeTreeRevertibleDriver {
    // (undocumented)
    annotateRange(start: number, end: number, props: PropertySet): void;
    // (undocumented)
    insertFromSpec(pos: number, spec: IJSONSegment): void;
    // (undocumented)
    removeRange(start: number, end: number): void;
}

// @alpha
export type PropertySet = MapLike<any>;

// @alpha
export interface ReferencePosition {
    getOffset(): number;
    getSegment(): ISegment | undefined;
    // (undocumented)
    isLeaf(): this is ISegment;
    properties?: PropertySet;
    // (undocumented)
    refType: ReferenceType;
    slidingPreference?: SlidingPreference;
}

// @alpha
export enum ReferenceType {
    RangeBegin = 16,
    RangeEnd = 32,
    // (undocumented)
    Simple = 0,
    SlideOnRemove = 64,
    StayOnRemove = 128,
    Tile = 1,
    Transient = 256
}

// @alpha
export const refGetTileLabels: (refPos: ReferencePosition) => string[] | undefined;

// @alpha
export function refHasTileLabel(refPos: ReferencePosition, label: string): boolean;

// @alpha
export const reservedMarkerIdKey = "markerId";

// @alpha
export function revertMergeTreeDeltaRevertibles(driver: MergeTreeRevertibleDriver, revertibles: MergeTreeDeltaRevertible[]): void;

// @alpha
export function segmentIsRemoved(segment: ISegment): boolean;

// @alpha (undocumented)
export interface SequenceOffsets {
    // (undocumented)
    posBreakpoints: number[];
    seqs: (number | AttributionKey | null)[];
}

// @alpha
export type SequencePlace = number | "start" | "end" | InteriorSequencePlace;

// @alpha (undocumented)
export interface SerializedAttributionCollection extends SequenceOffsets {
    // (undocumented)
    channels?: {
        [name: string]: SequenceOffsets;
    };
    // (undocumented)
    length: number;
}

// @alpha
export enum Side {
    // (undocumented)
    After = 1,
    // (undocumented)
    Before = 0
}

// @alpha
export const SlidingPreference: {
    readonly BACKWARD: 0;
    readonly FORWARD: 1;
};

// @alpha
export type SlidingPreference = (typeof SlidingPreference)[keyof typeof SlidingPreference];

// @alpha (undocumented)
export class TextSegment extends BaseSegment {
    constructor(text: string, props?: PropertySet);
    // (undocumented)
    append(segment: ISegment): void;
    // (undocumented)
    canAppend(segment: ISegment): boolean;
    // (undocumented)
    clone(start?: number, end?: number): TextSegment;
    // (undocumented)
    protected createSplitSegmentAt(pos: number): TextSegment | undefined;
    // (undocumented)
    static fromJSONObject(spec: string | IJSONSegment): TextSegment | undefined;
    // (undocumented)
    static is(segment: ISegment): segment is TextSegment;
    // (undocumented)
    static make(text: string, props?: PropertySet): TextSegment;
    // (undocumented)
    text: string;
    // (undocumented)
    toJSONObject(): IJSONTextSegment | string;
    // (undocumented)
    toString(): string;
    // (undocumented)
    static readonly type = "TextSegment";
    // (undocumented)
    readonly type = "TextSegment";
}

// @alpha (undocumented)
export type Trackable = ISegment | LocalReferencePosition;

// @alpha (undocumented)
export class TrackingGroup implements ITrackingGroup {
    constructor();
    // (undocumented)
    has(trackable: Trackable): boolean;
    // (undocumented)
    link(trackable: Trackable): void;
    // (undocumented)
    get size(): number;
    // (undocumented)
    get tracked(): readonly Trackable[];
    // (undocumented)
    unlink(trackable: Trackable): boolean;
}

// @alpha
export class TrackingGroupCollection {
    constructor(trackable: Trackable);
    // (undocumented)
    copyTo(trackable: Trackable): void;
    // (undocumented)
    get empty(): boolean;
    // (undocumented)
    link(trackingGroup: ITrackingGroup): void;
    // (undocumented)
    matches(trackingCollection: TrackingGroupCollection): boolean;
    // (undocumented)
    get trackingGroups(): Set<TrackingGroup>;
    // (undocumented)
    unlink(trackingGroup: ITrackingGroup): boolean;
}

// (No @packageDocumentation comment for this package)

```
