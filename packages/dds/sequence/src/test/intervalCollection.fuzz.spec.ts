/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import * as path from "path";
import { strict as assert } from "assert";
import {
	AcceptanceCondition,
	combineReducers,
	createWeightedGenerator,
	Generator,
	Reducer,
	take,
} from "@fluid-internal/stochastic-test-utils";
import { createDDSFuzzSuite, DDSFuzzModel, DDSFuzzTestState } from "@fluid-internal/test-dds-utils";
import { PropertySet } from "@fluidframework/merge-tree";
import { IntervalCollection, IntervalType, SequenceInterval } from "../intervalCollection";
import { SharedStringFactory } from "../sequenceFactory";
import { assertEquivalentSharedStrings } from "./intervalUtils";

type FuzzTestState = DDSFuzzTestState<SharedStringFactory>;

interface RangeSpec {
	start: number;
	end: number;
}

interface IntervalCollectionSpec {
	collectionName: string;
}

interface AddText {
	type: "addText";
	index: number;
	content: string;
}

interface RemoveRange extends RangeSpec {
	type: "removeRange";
}

// For non-interval collection fuzzing, annotating text would also be useful.

interface AddInterval extends IntervalCollectionSpec, RangeSpec {
	type: "addInterval";
	// Normally interval ids get autogenerated, but including it here allows tracking
	// what happened to an interval over the course of its lifetime based on the history
	// file, which is useful for debugging test failures.
	id: string;
}

interface ChangeInterval extends IntervalCollectionSpec, Partial<RangeSpec> {
	type: "changeInterval";
	id: string;
}

interface DeleteInterval extends IntervalCollectionSpec {
	type: "deleteInterval";
	id: string;
}

interface ChangeProperties extends IntervalCollectionSpec {
	type: "changeProperties";
	id: string;
	properties: PropertySet;
}

type IntervalOperation = AddInterval | ChangeInterval | DeleteInterval | ChangeProperties;

type TextOperation = AddText | RemoveRange;

type ClientOperation = IntervalOperation | TextOperation;

type Operation = ClientOperation;

// Note: none of these options are currently exercised, since the fuzz test fails with pretty much
// any configuration due to known bugs. Once shared interval collections are in a better state these
// should be revisited.
interface OperationGenerationConfig {
	/**
	 * Maximum length of the SharedString (locally) before no further AddText operations are generated.
	 * Note due to concurency, during test execution the actual length of the string may exceed this.
	 */
	maxStringLength?: number;
	/**
	 * Maximum number of intervals (locally) before no further AddInterval operations are generated.
	 * Note due to concurency, during test execution the actual number of intervals may exceed this.
	 */
	maxIntervals?: number;
	maxInsertLength?: number;
	intervalCollectionNamePool?: string[];
	propertyNamePool?: string[];
	validateInterval?: number;
}

const defaultOptions: Required<OperationGenerationConfig> = {
	maxStringLength: 1000,
	maxIntervals: 100,
	maxInsertLength: 10,
	intervalCollectionNamePool: ["comments"],
	propertyNamePool: ["prop1", "prop2", "prop3"],
	validateInterval: 100,
};

type ClientOpState = FuzzTestState;
function makeOperationGenerator(
	optionsParam?: OperationGenerationConfig,
): Generator<Operation, ClientOpState> {
	const options = { ...defaultOptions, ...(optionsParam ?? {}) };

	function isNonEmpty(collection: IntervalCollection<SequenceInterval>): boolean {
		for (const _ of collection) {
			return true;
		}

		return false;
	}

	// All subsequent helper functions are generators; note that they don't actually apply any operations.
	function startPosition({ random, channel }: ClientOpState): number {
		return random.integer(0, Math.max(0, channel.getLength() - 1));
	}

	function exclusiveRange(state: ClientOpState): RangeSpec {
		const start = startPosition(state);
		const end = state.random.integer(start + 1, state.channel.getLength());
		return { start, end };
	}

	function inclusiveRange(state: ClientOpState): RangeSpec {
		const start = startPosition(state);
		const end = state.random.integer(start, Math.max(start, state.channel.getLength() - 1));
		return { start, end };
	}

	function propertySet(state: ClientOpState): PropertySet {
		const propNamesShuffled = [...options.propertyNamePool];
		state.random.shuffle(propNamesShuffled);
		const propsToChange = propNamesShuffled.slice(
			0,
			state.random.integer(1, propNamesShuffled.length),
		);
		const propSet: PropertySet = {};
		for (const name of propsToChange) {
			propSet[name] = state.random.string(5);
		}
		return propSet;
	}

	function nonEmptyIntervalCollection({ channel, random }: ClientOpState): string {
		const nonEmptyLabels = Array.from(channel.getIntervalCollectionLabels()).filter((label) => {
			const collection = channel.getIntervalCollection(label);
			return isNonEmpty(collection);
		});
		return random.pick(nonEmptyLabels);
	}

	function interval(state: ClientOpState): { collectionName: string; id: string } {
		const collectionName = nonEmptyIntervalCollection(state);
		const intervals = Array.from(state.channel.getIntervalCollection(collectionName));
		const id = state.random.pick(intervals)?.getIntervalId();
		assert(id);

		return {
			id,
			collectionName,
		};
	}

	function addText(state: ClientOpState): AddText {
		const { random, channel } = state;
		return {
			type: "addText",
			index: random.integer(0, channel.getLength()),
			content: random.string(random.integer(0, options.maxInsertLength)),
		};
	}

	function removeRange(state: ClientOpState): RemoveRange {
		return { type: "removeRange", ...exclusiveRange(state) };
	}

	function addInterval(state: ClientOpState): AddInterval {
		return {
			type: "addInterval",
			...inclusiveRange(state),
			collectionName: state.random.pick(options.intervalCollectionNamePool),
			id: state.random.uuid4(),
		};
	}

	function deleteInterval(state: ClientOpState): DeleteInterval {
		return {
			type: "deleteInterval",
			...interval(state),
		};
	}

	function changeInterval(state: ClientOpState): ChangeInterval {
		const { start, end } = inclusiveRange(state);
		return {
			type: "changeInterval",
			start: state.random.integer(0, 5) === 5 ? undefined : start,
			end: state.random.integer(0, 5) === 5 ? undefined : end,
			...interval(state),
		};
	}

	function changeProperties(state: ClientOpState): ChangeProperties {
		return {
			type: "changeProperties",
			...interval(state),
			properties: propertySet(state),
		};
	}

	const hasAnInterval = ({ channel }: ClientOpState): boolean =>
		Array.from(channel.getIntervalCollectionLabels()).some((label) => {
			const collection = channel.getIntervalCollection(label);
			return isNonEmpty(collection);
		});

	const lengthSatisfies =
		(criteria: (length: number) => boolean): AcceptanceCondition<ClientOpState> =>
		({ channel }) =>
			criteria(channel.getLength());
	const hasNonzeroLength = lengthSatisfies((length) => length > 0);
	const isShorterThanMaxLength = lengthSatisfies((length) => length < options.maxStringLength);

	const hasNotTooManyIntervals: AcceptanceCondition<ClientOpState> = ({ channel }) => {
		let intervalCount = 0;
		for (const label of channel.getIntervalCollectionLabels()) {
			for (const _ of channel.getIntervalCollection(label)) {
				intervalCount++;
				if (intervalCount >= options.maxIntervals) {
					return false;
				}
			}
		}
		return true;
	};

	const all =
		<T>(...clauses: AcceptanceCondition<T>[]): AcceptanceCondition<T> =>
		(t: T) =>
			clauses.reduce<boolean>((prev, cond) => prev && cond(t), true);

	return createWeightedGenerator<Operation, ClientOpState>([
		[addText, 2, isShorterThanMaxLength],
		[removeRange, 1, hasNonzeroLength],
		// [addInterval, 0, all(hasNotTooManyIntervals, hasNonzeroLength)],
		[addInterval, 2, all(hasNotTooManyIntervals, hasNonzeroLength)],
		[deleteInterval, 2, hasAnInterval],
		[changeInterval, 2, all(hasAnInterval, hasNonzeroLength)],
		[changeProperties, 2, hasAnInterval],
	]);
}

interface LoggingInfo {
	/** id of the interval to track over time */
	intervalId: string;
	/** Clients to print */
	clientIds: string[];
}

function logCurrentState(state: FuzzTestState, loggingInfo: LoggingInfo): void {
	for (const id of loggingInfo.clientIds) {
		const { channel } = state.clients.find((s) => s.channel.id === id) ?? {};
		assert(channel);
		const labels = channel.getIntervalCollectionLabels();
		const interval = Array.from(labels)
			.map((label) =>
				channel.getIntervalCollection(label).getIntervalById(loggingInfo.intervalId),
			)
			.find((result) => result !== undefined);

		console.log(`Client ${id}:`);
		if (interval !== undefined) {
			const start = channel.localReferencePositionToPosition(interval.start);
			const end = channel.localReferencePositionToPosition(interval.end);
			if (end === start) {
				console.log(`${" ".repeat(start)}x`);
			} else {
				console.log(`${" ".repeat(start)}[${" ".repeat(end - start - 1)}]`);
			}
		}
		console.log(channel.getText());
		console.log("\n");
	}
}

function makeReducer(loggingInfo?: LoggingInfo): Reducer<Operation, ClientOpState> {
	const withLogging =
		<T>(baseReducer: (state: ClientOpState, operation: T) => void): Reducer<T, ClientOpState> =>
		(state, operation) => {
			if (loggingInfo !== undefined) {
				logCurrentState(state, loggingInfo);
				console.log("-".repeat(20));
				console.log("Next operation:", JSON.stringify(operation, undefined, 4));
			}
			baseReducer(state, operation);
		};

	const reducer = combineReducers<Operation, ClientOpState>({
		addText: ({ channel }, { index, content }) => {
			channel.insertText(index, content);
		},
		removeRange: ({ channel }, { start, end }) => {
			channel.removeRange(start, end);
		},
		addInterval: ({ channel }, { start, end, collectionName, id }) => {
			const collection = channel.getIntervalCollection(collectionName);
			collection.add(start, end, IntervalType.SlideOnRemove, { intervalId: id });
		},
		deleteInterval: ({ channel }, { id, collectionName }) => {
			const collection = channel.getIntervalCollection(collectionName);
			collection.removeIntervalById(id);
		},
		changeInterval: ({ channel }, { id, start, end, collectionName }) => {
			const collection = channel.getIntervalCollection(collectionName);
			collection.change(id, start, end);
		},
		changeProperties: ({ channel }, { id, properties, collectionName }) => {
			const collection = channel.getIntervalCollection(collectionName);
			collection.changeProperties(id, { ...properties });
		},
	});

	return withLogging(reducer);
}

describe("IntervalCollection fuzz testing", () => {
	const model: DDSFuzzModel<SharedStringFactory, Operation, FuzzTestState> = {
		workloadName: "default interval collection",
		generatorFactory: () => take(100, makeOperationGenerator()),
		reducer:
			// makeReducer supports a param for logging output which tracks the provided intervalId over time:
			// { intervalId: "00000000-0000-0000-0000-000000000000", clientIds: ["A", "B", "C"] }
			makeReducer(),
		validateConsistency: assertEquivalentSharedStrings,
		factory: new SharedStringFactory(),
	};

	createDDSFuzzSuite(model, {
		validationStrategy: { type: "fixedInterval", interval: 10 },
		reconnectProbability: 0.1,
		defaultTestCount: 100,
		saveFailures: { directory: path.join(__dirname, "../../src/test/results") },
		// Uncomment this line to replay a specific seed:
		// replay: 0,
		parseOperations: (serialized: string) => {
			let operations: Operation[] = JSON.parse(serialized);
			// Replace this value with some other interval ID to filter replay of the test suite to only include
			// interval operations with this ID.
			const filterIntervalId = "00000000-0000-0000-0000-000000000000";
			if (filterIntervalId) {
				operations = operations.filter((entry) =>
					[undefined, filterIntervalId].includes((entry as any).id),
				);
			}
			return operations;
		},
	});
});
