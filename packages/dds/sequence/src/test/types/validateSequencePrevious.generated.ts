/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/sequence-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_BaseSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_BaseSegment = requireAssignableTo<TypeOnly<old.BaseSegment>, TypeOnly<current.BaseSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_BaseSegment": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_BaseSegment = requireAssignableTo<TypeOnly<current.BaseSegment>, TypeOnly<old.BaseSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_DeserializeCallback": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_DeserializeCallback = requireAssignableTo<TypeOnly<old.DeserializeCallback>, TypeOnly<current.DeserializeCallback>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_DeserializeCallback": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_DeserializeCallback = requireAssignableTo<TypeOnly<current.DeserializeCallback>, TypeOnly<old.DeserializeCallback>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEndpointInRangeIndex": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IEndpointInRangeIndex = requireAssignableTo<TypeOnly<old.IEndpointInRangeIndex<any>>, TypeOnly<current.IEndpointInRangeIndex<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEndpointInRangeIndex": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IEndpointInRangeIndex = requireAssignableTo<TypeOnly<current.IEndpointInRangeIndex<any>>, TypeOnly<old.IEndpointInRangeIndex<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEndpointIndex": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IEndpointIndex = requireAssignableTo<TypeOnly<old.IEndpointIndex<any>>, TypeOnly<current.IEndpointIndex<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEndpointIndex": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IEndpointIndex = requireAssignableTo<TypeOnly<current.IEndpointIndex<any>>, TypeOnly<old.IEndpointIndex<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIdIntervalIndex": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IIdIntervalIndex = requireAssignableTo<TypeOnly<old.IIdIntervalIndex<any>>, TypeOnly<current.IIdIntervalIndex<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIdIntervalIndex": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IIdIntervalIndex = requireAssignableTo<TypeOnly<current.IIdIntervalIndex<any>>, TypeOnly<old.IIdIntervalIndex<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IInterval": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IInterval = requireAssignableTo<TypeOnly<old.IInterval>, TypeOnly<current.IInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IInterval": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IInterval = requireAssignableTo<TypeOnly<current.IInterval>, TypeOnly<old.IInterval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIntervalCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IIntervalCollection = requireAssignableTo<TypeOnly<old.IIntervalCollection<any>>, TypeOnly<current.IIntervalCollection<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIntervalCollection": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IIntervalCollection = requireAssignableTo<TypeOnly<current.IIntervalCollection<any>>, TypeOnly<old.IIntervalCollection<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIntervalCollectionEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IIntervalCollectionEvent = requireAssignableTo<TypeOnly<old.IIntervalCollectionEvent<any>>, TypeOnly<current.IIntervalCollectionEvent<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIntervalCollectionEvent": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IIntervalCollectionEvent = requireAssignableTo<TypeOnly<current.IIntervalCollectionEvent<any>>, TypeOnly<old.IIntervalCollectionEvent<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIntervalHelpers": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IIntervalHelpers = requireAssignableTo<TypeOnly<current.IIntervalHelpers<any>>, TypeOnly<old.IIntervalHelpers<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONRunSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IJSONRunSegment = requireAssignableTo<TypeOnly<old.IJSONRunSegment<any>>, TypeOnly<current.IJSONRunSegment<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONRunSegment": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IJSONRunSegment = requireAssignableTo<TypeOnly<current.IJSONRunSegment<any>>, TypeOnly<old.IJSONRunSegment<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMapMessageLocalMetadata": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IMapMessageLocalMetadata = requireAssignableTo<TypeOnly<old.IMapMessageLocalMetadata>, TypeOnly<current.IMapMessageLocalMetadata>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMapMessageLocalMetadata": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IMapMessageLocalMetadata = requireAssignableTo<TypeOnly<current.IMapMessageLocalMetadata>, TypeOnly<old.IMapMessageLocalMetadata>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOverlappingIntervalsIndex": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IOverlappingIntervalsIndex = requireAssignableTo<TypeOnly<old.IOverlappingIntervalsIndex<any>>, TypeOnly<current.IOverlappingIntervalsIndex<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOverlappingIntervalsIndex": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IOverlappingIntervalsIndex = requireAssignableTo<TypeOnly<current.IOverlappingIntervalsIndex<any>>, TypeOnly<old.IOverlappingIntervalsIndex<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISegment": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ISegment = requireAssignableTo<TypeOnly<old.ISegment>, TypeOnly<current.ISegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISegment": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ISegment = requireAssignableTo<TypeOnly<current.ISegment>, TypeOnly<old.ISegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISequenceDeltaRange": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ISequenceDeltaRange = requireAssignableTo<TypeOnly<old.ISequenceDeltaRange>, TypeOnly<current.ISequenceDeltaRange>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISequenceDeltaRange": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ISequenceDeltaRange = requireAssignableTo<TypeOnly<current.ISequenceDeltaRange>, TypeOnly<old.ISequenceDeltaRange>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISerializableInterval": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ISerializableInterval = requireAssignableTo<TypeOnly<old.ISerializableInterval>, TypeOnly<current.ISerializableInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISerializableInterval": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ISerializableInterval = requireAssignableTo<TypeOnly<current.ISerializableInterval>, TypeOnly<old.ISerializableInterval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISerializedInterval": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ISerializedInterval = requireAssignableTo<TypeOnly<old.ISerializedInterval>, TypeOnly<current.ISerializedInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISerializedInterval": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ISerializedInterval = requireAssignableTo<TypeOnly<current.ISerializedInterval>, TypeOnly<old.ISerializedInterval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharedIntervalCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ISharedIntervalCollection = requireAssignableTo<TypeOnly<old.ISharedIntervalCollection<any>>, TypeOnly<current.ISharedIntervalCollection<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharedIntervalCollection": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ISharedIntervalCollection = requireAssignableTo<TypeOnly<current.ISharedIntervalCollection<any>>, TypeOnly<old.ISharedIntervalCollection<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharedSegmentSequence": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ISharedSegmentSequence = requireAssignableTo<TypeOnly<old.ISharedSegmentSequence<any>>, TypeOnly<current.ISharedSegmentSequence<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharedSegmentSequence": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ISharedSegmentSequence = requireAssignableTo<TypeOnly<current.ISharedSegmentSequence<any>>, TypeOnly<old.ISharedSegmentSequence<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharedSegmentSequenceEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ISharedSegmentSequenceEvents = requireAssignableTo<TypeOnly<old.ISharedSegmentSequenceEvents>, TypeOnly<current.ISharedSegmentSequenceEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharedSegmentSequenceEvents": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ISharedSegmentSequenceEvents = requireAssignableTo<TypeOnly<current.ISharedSegmentSequenceEvents>, TypeOnly<old.ISharedSegmentSequenceEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharedString": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ISharedString = requireAssignableTo<TypeOnly<old.ISharedString>, TypeOnly<current.ISharedString>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharedString": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ISharedString = requireAssignableTo<TypeOnly<current.ISharedString>, TypeOnly<old.ISharedString>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IStartpointInRangeIndex": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IStartpointInRangeIndex = requireAssignableTo<TypeOnly<old.IStartpointInRangeIndex<any>>, TypeOnly<current.IStartpointInRangeIndex<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IStartpointInRangeIndex": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IStartpointInRangeIndex = requireAssignableTo<TypeOnly<current.IStartpointInRangeIndex<any>>, TypeOnly<old.IStartpointInRangeIndex<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IValueOpEmitter": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IValueOpEmitter = requireAssignableTo<TypeOnly<old.IValueOpEmitter>, TypeOnly<current.IValueOpEmitter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IValueOpEmitter": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IValueOpEmitter = requireAssignableTo<TypeOnly<current.IValueOpEmitter>, TypeOnly<old.IValueOpEmitter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_InteriorSequencePlace": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_InteriorSequencePlace = requireAssignableTo<TypeOnly<old.InteriorSequencePlace>, TypeOnly<current.InteriorSequencePlace>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_InteriorSequencePlace": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_InteriorSequencePlace = requireAssignableTo<TypeOnly<current.InteriorSequencePlace>, TypeOnly<old.InteriorSequencePlace>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Interval": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_Interval = requireAssignableTo<TypeOnly<old.Interval>, TypeOnly<current.Interval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Interval": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_Interval = requireAssignableTo<TypeOnly<current.Interval>, TypeOnly<old.Interval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IntervalIndex": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IntervalIndex = requireAssignableTo<TypeOnly<old.IntervalIndex<any>>, TypeOnly<current.IntervalIndex<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IntervalIndex": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IntervalIndex = requireAssignableTo<TypeOnly<current.IntervalIndex<any>>, TypeOnly<old.IntervalIndex<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IntervalLocator": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_IntervalLocator = requireAssignableTo<TypeOnly<old.IntervalLocator>, TypeOnly<current.IntervalLocator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IntervalLocator": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_IntervalLocator = requireAssignableTo<TypeOnly<current.IntervalLocator>, TypeOnly<old.IntervalLocator>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IntervalOpType": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_IntervalOpType = requireAssignableTo<TypeOnly<typeof old.IntervalOpType>, TypeOnly<typeof current.IntervalOpType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IntervalOpType": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_IntervalOpType = requireAssignableTo<TypeOnly<typeof current.IntervalOpType>, TypeOnly<typeof old.IntervalOpType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IntervalOpType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_IntervalOpType = requireAssignableTo<TypeOnly<old.IntervalOpType>, TypeOnly<current.IntervalOpType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IntervalOpType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_IntervalOpType = requireAssignableTo<TypeOnly<current.IntervalOpType>, TypeOnly<old.IntervalOpType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IntervalRevertible": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_IntervalRevertible = requireAssignableTo<TypeOnly<old.IntervalRevertible>, TypeOnly<current.IntervalRevertible>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IntervalRevertible": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_IntervalRevertible = requireAssignableTo<TypeOnly<current.IntervalRevertible>, TypeOnly<old.IntervalRevertible>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IntervalStickiness": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_IntervalStickiness = requireAssignableTo<TypeOnly<typeof old.IntervalStickiness>, TypeOnly<typeof current.IntervalStickiness>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IntervalStickiness": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_IntervalStickiness = requireAssignableTo<TypeOnly<typeof current.IntervalStickiness>, TypeOnly<typeof old.IntervalStickiness>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IntervalStickiness": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_IntervalStickiness = requireAssignableTo<TypeOnly<old.IntervalStickiness>, TypeOnly<current.IntervalStickiness>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IntervalStickiness": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_IntervalStickiness = requireAssignableTo<TypeOnly<current.IntervalStickiness>, TypeOnly<old.IntervalStickiness>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_IntervalType": {"forwardCompat": false}
 */
declare type old_as_current_for_EnumDeclaration_IntervalType = requireAssignableTo<TypeOnly<old.IntervalType>, TypeOnly<current.IntervalType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_IntervalType": {"backCompat": false}
 */
declare type current_as_old_for_EnumDeclaration_IntervalType = requireAssignableTo<TypeOnly<current.IntervalType>, TypeOnly<old.IntervalType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_LocalReferencePosition": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_LocalReferencePosition = requireAssignableTo<TypeOnly<current.LocalReferencePosition>, TypeOnly<old.LocalReferencePosition>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MapLike": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_MapLike = requireAssignableTo<TypeOnly<old.MapLike<any>>, TypeOnly<current.MapLike<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MapLike": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_MapLike = requireAssignableTo<TypeOnly<current.MapLike<any>>, TypeOnly<old.MapLike<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Marker": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_Marker = requireAssignableTo<TypeOnly<old.Marker>, TypeOnly<current.Marker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Marker": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_Marker = requireAssignableTo<TypeOnly<current.Marker>, TypeOnly<old.Marker>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_MergeTreeDeltaType": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_MergeTreeDeltaType = requireAssignableTo<TypeOnly<typeof old.MergeTreeDeltaType>, TypeOnly<typeof current.MergeTreeDeltaType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_MergeTreeDeltaType": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_MergeTreeDeltaType = requireAssignableTo<TypeOnly<typeof current.MergeTreeDeltaType>, TypeOnly<typeof old.MergeTreeDeltaType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_MergeTreeDeltaType = requireAssignableTo<TypeOnly<old.MergeTreeDeltaType>, TypeOnly<current.MergeTreeDeltaType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_MergeTreeDeltaType = requireAssignableTo<TypeOnly<current.MergeTreeDeltaType>, TypeOnly<old.MergeTreeDeltaType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_PropertySet": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_PropertySet = requireAssignableTo<TypeOnly<old.PropertySet>, TypeOnly<current.PropertySet>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_PropertySet": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_PropertySet = requireAssignableTo<TypeOnly<current.PropertySet>, TypeOnly<old.PropertySet>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ReferencePosition": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_ReferencePosition = requireAssignableTo<TypeOnly<old.ReferencePosition>, TypeOnly<current.ReferencePosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ReferencePosition": {"backCompat": false}
 */
declare type current_as_old_for_InterfaceDeclaration_ReferencePosition = requireAssignableTo<TypeOnly<current.ReferencePosition>, TypeOnly<old.ReferencePosition>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_ReferenceType": {"forwardCompat": false}
 */
declare type old_as_current_for_EnumDeclaration_ReferenceType = requireAssignableTo<TypeOnly<old.ReferenceType>, TypeOnly<current.ReferenceType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_ReferenceType": {"backCompat": false}
 */
declare type current_as_old_for_EnumDeclaration_ReferenceType = requireAssignableTo<TypeOnly<current.ReferenceType>, TypeOnly<old.ReferenceType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceDeltaEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_SequenceDeltaEvent = requireAssignableTo<TypeOnly<old.SequenceDeltaEvent>, TypeOnly<current.SequenceDeltaEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceDeltaEvent": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_SequenceDeltaEvent = requireAssignableTo<TypeOnly<current.SequenceDeltaEvent>, TypeOnly<old.SequenceDeltaEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_SequenceEvent = requireAssignableTo<TypeOnly<old.SequenceEvent>, TypeOnly<current.SequenceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceEvent": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_SequenceEvent = requireAssignableTo<TypeOnly<current.SequenceEvent>, TypeOnly<old.SequenceEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceInterval": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_SequenceInterval = requireAssignableTo<TypeOnly<old.SequenceInterval>, TypeOnly<current.SequenceInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceInterval": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_SequenceInterval = requireAssignableTo<TypeOnly<current.SequenceInterval>, TypeOnly<old.SequenceInterval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceMaintenanceEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_SequenceMaintenanceEvent = requireAssignableTo<TypeOnly<old.SequenceMaintenanceEvent>, TypeOnly<current.SequenceMaintenanceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceMaintenanceEvent": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_SequenceMaintenanceEvent = requireAssignableTo<TypeOnly<current.SequenceMaintenanceEvent>, TypeOnly<old.SequenceMaintenanceEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SequenceOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_InterfaceDeclaration_SequenceOptions = requireAssignableTo<TypeOnly<old.SequenceOptions>, TypeOnly<current.SequenceOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SequenceOptions": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_InterfaceDeclaration_SequenceOptions = requireAssignableTo<TypeOnly<current.SequenceOptions>, TypeOnly<old.SequenceOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SequencePlace": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_SequencePlace = requireAssignableTo<TypeOnly<old.SequencePlace>, TypeOnly<current.SequencePlace>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SequencePlace": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_SequencePlace = requireAssignableTo<TypeOnly<current.SequencePlace>, TypeOnly<old.SequencePlace>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SerializedIntervalDelta": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_SerializedIntervalDelta = requireAssignableTo<TypeOnly<old.SerializedIntervalDelta>, TypeOnly<current.SerializedIntervalDelta>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SerializedIntervalDelta": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_SerializedIntervalDelta = requireAssignableTo<TypeOnly<current.SerializedIntervalDelta>, TypeOnly<old.SerializedIntervalDelta>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedIntervalCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_SharedIntervalCollection = requireAssignableTo<TypeOnly<old.SharedIntervalCollection>, TypeOnly<current.SharedIntervalCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedIntervalCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_SharedIntervalCollection = requireAssignableTo<TypeOnly<current.SharedIntervalCollection>, TypeOnly<old.SharedIntervalCollection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedIntervalCollectionFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_SharedIntervalCollectionFactory = requireAssignableTo<TypeOnly<old.SharedIntervalCollectionFactory>, TypeOnly<current.SharedIntervalCollectionFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedIntervalCollectionFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_SharedIntervalCollectionFactory = requireAssignableTo<TypeOnly<current.SharedIntervalCollectionFactory>, TypeOnly<old.SharedIntervalCollectionFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedSegmentSequence": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_SharedSegmentSequence = requireAssignableTo<TypeOnly<old.SharedSegmentSequence<any>>, TypeOnly<current.SharedSegmentSequence<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedSegmentSequence": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_SharedSegmentSequence = requireAssignableTo<TypeOnly<current.SharedSegmentSequence<any>>, TypeOnly<old.SharedSegmentSequence<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedSequence": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_SharedSequence = requireAssignableTo<TypeOnly<old.SharedSequence<any>>, TypeOnly<current.SharedSequence<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedSequence": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_SharedSequence = requireAssignableTo<TypeOnly<current.SharedSequence<any>>, TypeOnly<old.SharedSequence<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_SharedString": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_VariableDeclaration_SharedString = requireAssignableTo<TypeOnly<typeof old.SharedString>, TypeOnly<typeof current.SharedString>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_SharedString": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_SharedString = requireAssignableTo<TypeOnly<typeof current.SharedString>, TypeOnly<typeof old.SharedString>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SharedString": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_SharedString = requireAssignableTo<TypeOnly<old.SharedString>, TypeOnly<current.SharedString>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SharedString": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_SharedString = requireAssignableTo<TypeOnly<current.SharedString>, TypeOnly<old.SharedString>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedStringClass": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_SharedStringClass = requireAssignableTo<TypeOnly<old.SharedStringClass>, TypeOnly<current.SharedStringClass>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedStringClass": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_SharedStringClass = requireAssignableTo<TypeOnly<current.SharedStringClass>, TypeOnly<old.SharedStringClass>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SharedStringRevertible": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_SharedStringRevertible = requireAssignableTo<TypeOnly<old.SharedStringRevertible>, TypeOnly<current.SharedStringRevertible>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SharedStringRevertible": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_SharedStringRevertible = requireAssignableTo<TypeOnly<current.SharedStringRevertible>, TypeOnly<old.SharedStringRevertible>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SharedStringSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAliasDeclaration_SharedStringSegment = requireAssignableTo<TypeOnly<old.SharedStringSegment>, TypeOnly<current.SharedStringSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SharedStringSegment": {"backCompat": false}
 */
declare type current_as_old_for_TypeAliasDeclaration_SharedStringSegment = requireAssignableTo<TypeOnly<current.SharedStringSegment>, TypeOnly<old.SharedStringSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_Side": {"forwardCompat": false}
 */
declare type old_as_current_for_EnumDeclaration_Side = requireAssignableTo<TypeOnly<old.Side>, TypeOnly<current.Side>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_Side": {"backCompat": false}
 */
declare type current_as_old_for_EnumDeclaration_Side = requireAssignableTo<TypeOnly<current.Side>, TypeOnly<old.Side>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SubSequence": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_SubSequence = requireAssignableTo<TypeOnly<old.SubSequence<any>>, TypeOnly<current.SubSequence<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SubSequence": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_SubSequence = requireAssignableTo<TypeOnly<current.SubSequence<any>>, TypeOnly<old.SubSequence<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TextSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_TextSegment = requireAssignableTo<TypeOnly<old.TextSegment>, TypeOnly<current.TextSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TextSegment": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_TextSegment = requireAssignableTo<TypeOnly<current.TextSegment>, TypeOnly<old.TextSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TrackingGroup": {"forwardCompat": false}
 */
declare type old_as_current_for_ClassDeclaration_TrackingGroup = requireAssignableTo<TypeOnly<old.TrackingGroup>, TypeOnly<current.TrackingGroup>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TrackingGroup": {"backCompat": false}
 */
declare type current_as_old_for_ClassDeclaration_TrackingGroup = requireAssignableTo<TypeOnly<current.TrackingGroup>, TypeOnly<old.TrackingGroup>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendAddIntervalToRevertibles": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_appendAddIntervalToRevertibles = requireAssignableTo<TypeOnly<typeof old.appendAddIntervalToRevertibles>, TypeOnly<typeof current.appendAddIntervalToRevertibles>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendAddIntervalToRevertibles": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_appendAddIntervalToRevertibles = requireAssignableTo<TypeOnly<typeof current.appendAddIntervalToRevertibles>, TypeOnly<typeof old.appendAddIntervalToRevertibles>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendChangeIntervalToRevertibles": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_appendChangeIntervalToRevertibles = requireAssignableTo<TypeOnly<typeof old.appendChangeIntervalToRevertibles>, TypeOnly<typeof current.appendChangeIntervalToRevertibles>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendChangeIntervalToRevertibles": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_appendChangeIntervalToRevertibles = requireAssignableTo<TypeOnly<typeof current.appendChangeIntervalToRevertibles>, TypeOnly<typeof old.appendChangeIntervalToRevertibles>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendDeleteIntervalToRevertibles": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_appendDeleteIntervalToRevertibles = requireAssignableTo<TypeOnly<typeof old.appendDeleteIntervalToRevertibles>, TypeOnly<typeof current.appendDeleteIntervalToRevertibles>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendDeleteIntervalToRevertibles": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_appendDeleteIntervalToRevertibles = requireAssignableTo<TypeOnly<typeof current.appendDeleteIntervalToRevertibles>, TypeOnly<typeof old.appendDeleteIntervalToRevertibles>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendIntervalPropertyChangedToRevertibles": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_appendIntervalPropertyChangedToRevertibles = requireAssignableTo<TypeOnly<typeof old.appendIntervalPropertyChangedToRevertibles>, TypeOnly<typeof current.appendIntervalPropertyChangedToRevertibles>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendIntervalPropertyChangedToRevertibles": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_appendIntervalPropertyChangedToRevertibles = requireAssignableTo<TypeOnly<typeof current.appendIntervalPropertyChangedToRevertibles>, TypeOnly<typeof old.appendIntervalPropertyChangedToRevertibles>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendSharedStringDeltaToRevertibles": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_appendSharedStringDeltaToRevertibles = requireAssignableTo<TypeOnly<typeof old.appendSharedStringDeltaToRevertibles>, TypeOnly<typeof current.appendSharedStringDeltaToRevertibles>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendSharedStringDeltaToRevertibles": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_appendSharedStringDeltaToRevertibles = requireAssignableTo<TypeOnly<typeof current.appendSharedStringDeltaToRevertibles>, TypeOnly<typeof old.appendSharedStringDeltaToRevertibles>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createEndpointInRangeIndex": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createEndpointInRangeIndex = requireAssignableTo<TypeOnly<typeof old.createEndpointInRangeIndex>, TypeOnly<typeof current.createEndpointInRangeIndex>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createEndpointInRangeIndex": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createEndpointInRangeIndex = requireAssignableTo<TypeOnly<typeof current.createEndpointInRangeIndex>, TypeOnly<typeof old.createEndpointInRangeIndex>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createEndpointIndex": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createEndpointIndex = requireAssignableTo<TypeOnly<typeof old.createEndpointIndex>, TypeOnly<typeof current.createEndpointIndex>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createEndpointIndex": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createEndpointIndex = requireAssignableTo<TypeOnly<typeof current.createEndpointIndex>, TypeOnly<typeof old.createEndpointIndex>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createIdIntervalIndex": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createIdIntervalIndex = requireAssignableTo<TypeOnly<typeof old.createIdIntervalIndex>, TypeOnly<typeof current.createIdIntervalIndex>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createIdIntervalIndex": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createIdIntervalIndex = requireAssignableTo<TypeOnly<typeof current.createIdIntervalIndex>, TypeOnly<typeof old.createIdIntervalIndex>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createOverlappingIntervalsIndex": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createOverlappingIntervalsIndex = requireAssignableTo<TypeOnly<typeof old.createOverlappingIntervalsIndex>, TypeOnly<typeof current.createOverlappingIntervalsIndex>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createOverlappingIntervalsIndex": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createOverlappingIntervalsIndex = requireAssignableTo<TypeOnly<typeof current.createOverlappingIntervalsIndex>, TypeOnly<typeof old.createOverlappingIntervalsIndex>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createOverlappingSequenceIntervalsIndex": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createOverlappingSequenceIntervalsIndex = requireAssignableTo<TypeOnly<typeof old.createOverlappingSequenceIntervalsIndex>, TypeOnly<typeof current.createOverlappingSequenceIntervalsIndex>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createOverlappingSequenceIntervalsIndex": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createOverlappingSequenceIntervalsIndex = requireAssignableTo<TypeOnly<typeof current.createOverlappingSequenceIntervalsIndex>, TypeOnly<typeof old.createOverlappingSequenceIntervalsIndex>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createStartpointInRangeIndex": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_createStartpointInRangeIndex = requireAssignableTo<TypeOnly<typeof old.createStartpointInRangeIndex>, TypeOnly<typeof current.createStartpointInRangeIndex>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createStartpointInRangeIndex": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_createStartpointInRangeIndex = requireAssignableTo<TypeOnly<typeof current.createStartpointInRangeIndex>, TypeOnly<typeof old.createStartpointInRangeIndex>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_discardSharedStringRevertibles": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_discardSharedStringRevertibles = requireAssignableTo<TypeOnly<typeof old.discardSharedStringRevertibles>, TypeOnly<typeof current.discardSharedStringRevertibles>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_discardSharedStringRevertibles": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_discardSharedStringRevertibles = requireAssignableTo<TypeOnly<typeof current.discardSharedStringRevertibles>, TypeOnly<typeof old.discardSharedStringRevertibles>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getTextAndMarkers": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_getTextAndMarkers = requireAssignableTo<TypeOnly<typeof old.getTextAndMarkers>, TypeOnly<typeof current.getTextAndMarkers>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getTextAndMarkers": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_getTextAndMarkers = requireAssignableTo<TypeOnly<typeof current.getTextAndMarkers>, TypeOnly<typeof old.getTextAndMarkers>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_intervalLocatorFromEndpoint": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_intervalLocatorFromEndpoint = requireAssignableTo<TypeOnly<typeof old.intervalLocatorFromEndpoint>, TypeOnly<typeof current.intervalLocatorFromEndpoint>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_intervalLocatorFromEndpoint": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_intervalLocatorFromEndpoint = requireAssignableTo<TypeOnly<typeof current.intervalLocatorFromEndpoint>, TypeOnly<typeof old.intervalLocatorFromEndpoint>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedMarkerIdKey": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_reservedMarkerIdKey = requireAssignableTo<TypeOnly<typeof old.reservedMarkerIdKey>, TypeOnly<typeof current.reservedMarkerIdKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedMarkerIdKey": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_reservedMarkerIdKey = requireAssignableTo<TypeOnly<typeof current.reservedMarkerIdKey>, TypeOnly<typeof old.reservedMarkerIdKey>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedRangeLabelsKey": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_reservedRangeLabelsKey = requireAssignableTo<TypeOnly<typeof old.reservedRangeLabelsKey>, TypeOnly<typeof current.reservedRangeLabelsKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedRangeLabelsKey": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_reservedRangeLabelsKey = requireAssignableTo<TypeOnly<typeof current.reservedRangeLabelsKey>, TypeOnly<typeof old.reservedRangeLabelsKey>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedTileLabelsKey": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_reservedTileLabelsKey = requireAssignableTo<TypeOnly<typeof old.reservedTileLabelsKey>, TypeOnly<typeof current.reservedTileLabelsKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedTileLabelsKey": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_reservedTileLabelsKey = requireAssignableTo<TypeOnly<typeof current.reservedTileLabelsKey>, TypeOnly<typeof old.reservedTileLabelsKey>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_revertSharedStringRevertibles": {"forwardCompat": false}
 */
declare type old_as_current_for_FunctionDeclaration_revertSharedStringRevertibles = requireAssignableTo<TypeOnly<typeof old.revertSharedStringRevertibles>, TypeOnly<typeof current.revertSharedStringRevertibles>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_revertSharedStringRevertibles": {"backCompat": false}
 */
declare type current_as_old_for_FunctionDeclaration_revertSharedStringRevertibles = requireAssignableTo<TypeOnly<typeof current.revertSharedStringRevertibles>, TypeOnly<typeof old.revertSharedStringRevertibles>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_sequenceIntervalHelpers": {"forwardCompat": false}
 */
declare type old_as_current_for_VariableDeclaration_sequenceIntervalHelpers = requireAssignableTo<TypeOnly<typeof old.sequenceIntervalHelpers>, TypeOnly<typeof current.sequenceIntervalHelpers>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_sequenceIntervalHelpers": {"backCompat": false}
 */
declare type current_as_old_for_VariableDeclaration_sequenceIntervalHelpers = requireAssignableTo<TypeOnly<typeof current.sequenceIntervalHelpers>, TypeOnly<typeof old.sequenceIntervalHelpers>>
