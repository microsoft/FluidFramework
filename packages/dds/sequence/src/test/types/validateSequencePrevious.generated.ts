/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/sequence-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Interval": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Interval = requireAssignableTo<TypeOnly<old.Interval>, TypeOnly<current.Interval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Interval": {"backCompat": false}
 */
declare type current_as_old_for_Class_Interval = requireAssignableTo<TypeOnly<current.Interval>, TypeOnly<old.Interval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_IntervalCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_IntervalCollection = requireAssignableTo<TypeOnly<old.IntervalCollection<never>>, TypeOnly<current.IntervalCollection<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_IntervalCollection": {"backCompat": false}
 */
declare type current_as_old_for_Class_IntervalCollection = requireAssignableTo<TypeOnly<current.IntervalCollection<never>>, TypeOnly<old.IntervalCollection<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_IntervalCollectionIterator": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_IntervalCollectionIterator = requireAssignableTo<TypeOnly<old.IntervalCollectionIterator<never>>, TypeOnly<current.IntervalCollectionIterator<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_IntervalCollectionIterator": {"backCompat": false}
 */
declare type current_as_old_for_Class_IntervalCollectionIterator = requireAssignableTo<TypeOnly<current.IntervalCollectionIterator<never>>, TypeOnly<old.IntervalCollectionIterator<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PaddingSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_PaddingSegment = requireAssignableTo<TypeOnly<old.PaddingSegment>, TypeOnly<current.PaddingSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PaddingSegment": {"backCompat": false}
 */
declare type current_as_old_for_Class_PaddingSegment = requireAssignableTo<TypeOnly<current.PaddingSegment>, TypeOnly<old.PaddingSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RunSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RunSegment = requireAssignableTo<TypeOnly<old.RunSegment>, TypeOnly<current.RunSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RunSegment": {"backCompat": false}
 */
declare type current_as_old_for_Class_RunSegment = requireAssignableTo<TypeOnly<current.RunSegment>, TypeOnly<old.RunSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceDeltaEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SequenceDeltaEvent = requireAssignableTo<TypeOnly<old.SequenceDeltaEvent>, TypeOnly<current.SequenceDeltaEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceDeltaEvent": {"backCompat": false}
 */
declare type current_as_old_for_Class_SequenceDeltaEvent = requireAssignableTo<TypeOnly<current.SequenceDeltaEvent>, TypeOnly<old.SequenceDeltaEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SequenceEvent = requireAssignableTo<TypeOnly<old.SequenceEvent>, TypeOnly<current.SequenceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceEvent": {"backCompat": false}
 */
declare type current_as_old_for_Class_SequenceEvent = requireAssignableTo<TypeOnly<current.SequenceEvent>, TypeOnly<old.SequenceEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceInterval": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SequenceInterval = requireAssignableTo<TypeOnly<old.SequenceInterval>, TypeOnly<current.SequenceInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceInterval": {"backCompat": false}
 */
declare type current_as_old_for_Class_SequenceInterval = requireAssignableTo<TypeOnly<current.SequenceInterval>, TypeOnly<old.SequenceInterval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceMaintenanceEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SequenceMaintenanceEvent = requireAssignableTo<TypeOnly<old.SequenceMaintenanceEvent>, TypeOnly<current.SequenceMaintenanceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceMaintenanceEvent": {"backCompat": false}
 */
declare type current_as_old_for_Class_SequenceMaintenanceEvent = requireAssignableTo<TypeOnly<current.SequenceMaintenanceEvent>, TypeOnly<old.SequenceMaintenanceEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedIntervalCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedIntervalCollection = requireAssignableTo<TypeOnly<old.SharedIntervalCollection>, TypeOnly<current.SharedIntervalCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedIntervalCollection": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedIntervalCollection = requireAssignableTo<TypeOnly<current.SharedIntervalCollection>, TypeOnly<old.SharedIntervalCollection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedIntervalCollectionFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedIntervalCollectionFactory = requireAssignableTo<TypeOnly<old.SharedIntervalCollectionFactory>, TypeOnly<current.SharedIntervalCollectionFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedIntervalCollectionFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedIntervalCollectionFactory = requireAssignableTo<TypeOnly<current.SharedIntervalCollectionFactory>, TypeOnly<old.SharedIntervalCollectionFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedNumberSequence": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedNumberSequence = requireAssignableTo<TypeOnly<old.SharedNumberSequence>, TypeOnly<current.SharedNumberSequence>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedNumberSequence": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedNumberSequence = requireAssignableTo<TypeOnly<current.SharedNumberSequence>, TypeOnly<old.SharedNumberSequence>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedNumberSequenceFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedNumberSequenceFactory = requireAssignableTo<TypeOnly<old.SharedNumberSequenceFactory>, TypeOnly<current.SharedNumberSequenceFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedNumberSequenceFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedNumberSequenceFactory = requireAssignableTo<TypeOnly<current.SharedNumberSequenceFactory>, TypeOnly<old.SharedNumberSequenceFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedObjectSequence": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedObjectSequence = requireAssignableTo<TypeOnly<old.SharedObjectSequence<never>>, TypeOnly<current.SharedObjectSequence<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedObjectSequence": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedObjectSequence = requireAssignableTo<TypeOnly<current.SharedObjectSequence<never>>, TypeOnly<old.SharedObjectSequence<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedObjectSequenceFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedObjectSequenceFactory = requireAssignableTo<TypeOnly<old.SharedObjectSequenceFactory>, TypeOnly<current.SharedObjectSequenceFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedObjectSequenceFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedObjectSequenceFactory = requireAssignableTo<TypeOnly<current.SharedObjectSequenceFactory>, TypeOnly<old.SharedObjectSequenceFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedSegmentSequence": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedSegmentSequence = requireAssignableTo<TypeOnly<old.SharedSegmentSequence<never>>, TypeOnly<current.SharedSegmentSequence<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedSegmentSequence": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedSegmentSequence = requireAssignableTo<TypeOnly<current.SharedSegmentSequence<never>>, TypeOnly<old.SharedSegmentSequence<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedSequence": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedSequence = requireAssignableTo<TypeOnly<old.SharedSequence<never>>, TypeOnly<current.SharedSequence<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedSequence": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedSequence = requireAssignableTo<TypeOnly<current.SharedSequence<never>>, TypeOnly<old.SharedSequence<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedString": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedString = requireAssignableTo<TypeOnly<old.SharedString>, TypeOnly<current.SharedString>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedString": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedString = requireAssignableTo<TypeOnly<current.SharedString>, TypeOnly<old.SharedString>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedStringFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedStringFactory = requireAssignableTo<TypeOnly<old.SharedStringFactory>, TypeOnly<current.SharedStringFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedStringFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedStringFactory = requireAssignableTo<TypeOnly<current.SharedStringFactory>, TypeOnly<old.SharedStringFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SparseMatrix": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SparseMatrix = requireAssignableTo<TypeOnly<old.SparseMatrix>, TypeOnly<current.SparseMatrix>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SparseMatrix": {"backCompat": false}
 */
declare type current_as_old_for_Class_SparseMatrix = requireAssignableTo<TypeOnly<current.SparseMatrix>, TypeOnly<old.SparseMatrix>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SparseMatrixFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SparseMatrixFactory = requireAssignableTo<TypeOnly<old.SparseMatrixFactory>, TypeOnly<current.SparseMatrixFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SparseMatrixFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SparseMatrixFactory = requireAssignableTo<TypeOnly<current.SparseMatrixFactory>, TypeOnly<old.SparseMatrixFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SubSequence": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SubSequence = requireAssignableTo<TypeOnly<old.SubSequence<never>>, TypeOnly<current.SubSequence<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SubSequence": {"backCompat": false}
 */
declare type current_as_old_for_Class_SubSequence = requireAssignableTo<TypeOnly<current.SubSequence<never>>, TypeOnly<old.SubSequence<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Interval": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Interval = requireAssignableTo<TypeOnly<typeof current.Interval>, TypeOnly<typeof old.Interval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_IntervalCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_IntervalCollection = requireAssignableTo<TypeOnly<typeof current.IntervalCollection>, TypeOnly<typeof old.IntervalCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_IntervalCollectionIterator": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_IntervalCollectionIterator = requireAssignableTo<TypeOnly<typeof current.IntervalCollectionIterator>, TypeOnly<typeof old.IntervalCollectionIterator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_PaddingSegment": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_PaddingSegment = requireAssignableTo<TypeOnly<typeof current.PaddingSegment>, TypeOnly<typeof old.PaddingSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RunSegment": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RunSegment = requireAssignableTo<TypeOnly<typeof current.RunSegment>, TypeOnly<typeof old.RunSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SequenceDeltaEvent": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SequenceDeltaEvent = requireAssignableTo<TypeOnly<typeof current.SequenceDeltaEvent>, TypeOnly<typeof old.SequenceDeltaEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SequenceEvent": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SequenceEvent = requireAssignableTo<TypeOnly<typeof current.SequenceEvent>, TypeOnly<typeof old.SequenceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SequenceInterval": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SequenceInterval = requireAssignableTo<TypeOnly<typeof current.SequenceInterval>, TypeOnly<typeof old.SequenceInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SequenceMaintenanceEvent": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SequenceMaintenanceEvent = requireAssignableTo<TypeOnly<typeof current.SequenceMaintenanceEvent>, TypeOnly<typeof old.SequenceMaintenanceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedIntervalCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedIntervalCollection = requireAssignableTo<TypeOnly<typeof current.SharedIntervalCollection>, TypeOnly<typeof old.SharedIntervalCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedIntervalCollectionFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedIntervalCollectionFactory = requireAssignableTo<TypeOnly<typeof current.SharedIntervalCollectionFactory>, TypeOnly<typeof old.SharedIntervalCollectionFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedNumberSequence": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedNumberSequence = requireAssignableTo<TypeOnly<typeof current.SharedNumberSequence>, TypeOnly<typeof old.SharedNumberSequence>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedNumberSequenceFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedNumberSequenceFactory = requireAssignableTo<TypeOnly<typeof current.SharedNumberSequenceFactory>, TypeOnly<typeof old.SharedNumberSequenceFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedObjectSequence": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedObjectSequence = requireAssignableTo<TypeOnly<typeof current.SharedObjectSequence>, TypeOnly<typeof old.SharedObjectSequence>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedObjectSequenceFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedObjectSequenceFactory = requireAssignableTo<TypeOnly<typeof current.SharedObjectSequenceFactory>, TypeOnly<typeof old.SharedObjectSequenceFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedSegmentSequence": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedSegmentSequence = requireAssignableTo<TypeOnly<typeof current.SharedSegmentSequence>, TypeOnly<typeof old.SharedSegmentSequence>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedSequence": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedSequence = requireAssignableTo<TypeOnly<typeof current.SharedSequence>, TypeOnly<typeof old.SharedSequence>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedString": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedString = requireAssignableTo<TypeOnly<typeof current.SharedString>, TypeOnly<typeof old.SharedString>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedStringFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedStringFactory = requireAssignableTo<TypeOnly<typeof current.SharedStringFactory>, TypeOnly<typeof old.SharedStringFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SparseMatrix": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SparseMatrix = requireAssignableTo<TypeOnly<typeof current.SparseMatrix>, TypeOnly<typeof old.SparseMatrix>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SparseMatrixFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SparseMatrixFactory = requireAssignableTo<TypeOnly<typeof current.SparseMatrixFactory>, TypeOnly<typeof old.SparseMatrixFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SubSequence": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SubSequence = requireAssignableTo<TypeOnly<typeof current.SubSequence>, TypeOnly<typeof old.SubSequence>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_IntervalType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_IntervalType = requireAssignableTo<TypeOnly<old.IntervalType>, TypeOnly<current.IntervalType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_IntervalType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_IntervalType = requireAssignableTo<TypeOnly<current.IntervalType>, TypeOnly<old.IntervalType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_positionToRowCol": {"backCompat": false}
 */
declare type current_as_old_for_Function_positionToRowCol = requireAssignableTo<TypeOnly<typeof current.positionToRowCol>, TypeOnly<typeof old.positionToRowCol>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IIntervalCollectionEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IIntervalCollectionEvent = requireAssignableTo<TypeOnly<old.IIntervalCollectionEvent<never>>, TypeOnly<current.IIntervalCollectionEvent<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IIntervalCollectionEvent": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IIntervalCollectionEvent = requireAssignableTo<TypeOnly<current.IIntervalCollectionEvent<never>>, TypeOnly<old.IIntervalCollectionEvent<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IIntervalHelpers": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IIntervalHelpers = requireAssignableTo<TypeOnly<old.IIntervalHelpers<never>>, TypeOnly<current.IIntervalHelpers<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IIntervalHelpers": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IIntervalHelpers = requireAssignableTo<TypeOnly<current.IIntervalHelpers<never>>, TypeOnly<old.IIntervalHelpers<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IJSONRunSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IJSONRunSegment = requireAssignableTo<TypeOnly<old.IJSONRunSegment<never>>, TypeOnly<current.IJSONRunSegment<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IJSONRunSegment": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IJSONRunSegment = requireAssignableTo<TypeOnly<current.IJSONRunSegment<never>>, TypeOnly<old.IJSONRunSegment<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMapMessageLocalMetadata": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMapMessageLocalMetadata = requireAssignableTo<TypeOnly<old.IMapMessageLocalMetadata>, TypeOnly<current.IMapMessageLocalMetadata>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMapMessageLocalMetadata": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMapMessageLocalMetadata = requireAssignableTo<TypeOnly<current.IMapMessageLocalMetadata>, TypeOnly<old.IMapMessageLocalMetadata>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequenceDeltaRange": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISequenceDeltaRange = requireAssignableTo<TypeOnly<old.ISequenceDeltaRange>, TypeOnly<current.ISequenceDeltaRange>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequenceDeltaRange": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISequenceDeltaRange = requireAssignableTo<TypeOnly<current.ISequenceDeltaRange>, TypeOnly<old.ISequenceDeltaRange>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializableInterval": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISerializableInterval = requireAssignableTo<TypeOnly<old.ISerializableInterval>, TypeOnly<current.ISerializableInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializableInterval": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISerializableInterval = requireAssignableTo<TypeOnly<current.ISerializableInterval>, TypeOnly<old.ISerializableInterval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializedInterval": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISerializedInterval = requireAssignableTo<TypeOnly<old.ISerializedInterval>, TypeOnly<current.ISerializedInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializedInterval": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISerializedInterval = requireAssignableTo<TypeOnly<current.ISerializedInterval>, TypeOnly<old.ISerializedInterval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializedIntervalCollectionV2": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISerializedIntervalCollectionV2 = requireAssignableTo<TypeOnly<old.ISerializedIntervalCollectionV2>, TypeOnly<current.ISerializedIntervalCollectionV2>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializedIntervalCollectionV2": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISerializedIntervalCollectionV2 = requireAssignableTo<TypeOnly<current.ISerializedIntervalCollectionV2>, TypeOnly<old.ISerializedIntervalCollectionV2>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedIntervalCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISharedIntervalCollection = requireAssignableTo<TypeOnly<old.ISharedIntervalCollection<never>>, TypeOnly<current.ISharedIntervalCollection<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedIntervalCollection": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISharedIntervalCollection = requireAssignableTo<TypeOnly<current.ISharedIntervalCollection<never>>, TypeOnly<old.ISharedIntervalCollection<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedSegmentSequenceEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISharedSegmentSequenceEvents = requireAssignableTo<TypeOnly<old.ISharedSegmentSequenceEvents>, TypeOnly<current.ISharedSegmentSequenceEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedSegmentSequenceEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISharedSegmentSequenceEvents = requireAssignableTo<TypeOnly<current.ISharedSegmentSequenceEvents>, TypeOnly<old.ISharedSegmentSequenceEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedString": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISharedString = requireAssignableTo<TypeOnly<old.ISharedString>, TypeOnly<current.ISharedString>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedString": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISharedString = requireAssignableTo<TypeOnly<current.ISharedString>, TypeOnly<old.ISharedString>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IValueOpEmitter": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IValueOpEmitter = requireAssignableTo<TypeOnly<old.IValueOpEmitter>, TypeOnly<current.IValueOpEmitter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IValueOpEmitter": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IValueOpEmitter = requireAssignableTo<TypeOnly<current.IValueOpEmitter>, TypeOnly<old.IValueOpEmitter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_CompressedSerializedInterval": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_CompressedSerializedInterval = requireAssignableTo<TypeOnly<old.CompressedSerializedInterval>, TypeOnly<current.CompressedSerializedInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_CompressedSerializedInterval": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_CompressedSerializedInterval = requireAssignableTo<TypeOnly<current.CompressedSerializedInterval>, TypeOnly<old.CompressedSerializedInterval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_DeserializeCallback": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_DeserializeCallback = requireAssignableTo<TypeOnly<old.DeserializeCallback>, TypeOnly<current.DeserializeCallback>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_DeserializeCallback": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_DeserializeCallback = requireAssignableTo<TypeOnly<current.DeserializeCallback>, TypeOnly<old.DeserializeCallback>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MatrixSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_MatrixSegment = requireAssignableTo<TypeOnly<old.MatrixSegment>, TypeOnly<current.MatrixSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MatrixSegment": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_MatrixSegment = requireAssignableTo<TypeOnly<current.MatrixSegment>, TypeOnly<old.MatrixSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SharedStringSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SharedStringSegment = requireAssignableTo<TypeOnly<old.SharedStringSegment>, TypeOnly<current.SharedStringSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SharedStringSegment": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SharedStringSegment = requireAssignableTo<TypeOnly<current.SharedStringSegment>, TypeOnly<old.SharedStringSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SparseMatrixItem": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SparseMatrixItem = requireAssignableTo<TypeOnly<old.SparseMatrixItem>, TypeOnly<current.SparseMatrixItem>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SparseMatrixItem": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SparseMatrixItem = requireAssignableTo<TypeOnly<current.SparseMatrixItem>, TypeOnly<old.SparseMatrixItem>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_maxCellPosition": {"backCompat": false}
 */
declare type current_as_old_for_Variable_maxCellPosition = requireAssignableTo<TypeOnly<typeof current.maxCellPosition>, TypeOnly<typeof old.maxCellPosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_maxCol": {"backCompat": false}
 */
declare type current_as_old_for_Variable_maxCol = requireAssignableTo<TypeOnly<typeof current.maxCol>, TypeOnly<typeof old.maxCol>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_maxCols": {"backCompat": false}
 */
declare type current_as_old_for_Variable_maxCols = requireAssignableTo<TypeOnly<typeof current.maxCols>, TypeOnly<typeof old.maxCols>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_maxRow": {"backCompat": false}
 */
declare type current_as_old_for_Variable_maxRow = requireAssignableTo<TypeOnly<typeof current.maxRow>, TypeOnly<typeof old.maxRow>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_maxRows": {"backCompat": false}
 */
declare type current_as_old_for_Variable_maxRows = requireAssignableTo<TypeOnly<typeof current.maxRows>, TypeOnly<typeof old.maxRows>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_rowColToPosition": {"backCompat": false}
 */
declare type current_as_old_for_Variable_rowColToPosition = requireAssignableTo<TypeOnly<typeof current.rowColToPosition>, TypeOnly<typeof old.rowColToPosition>>
