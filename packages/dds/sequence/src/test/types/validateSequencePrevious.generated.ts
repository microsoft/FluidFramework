/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type * as old from "@fluidframework/sequence-previous/internal";

import type * as current from "../../index.js";

type ValueOf<T> = T[keyof T];
type OnlySymbols<T> = T extends symbol ? T : never;
type WellKnownSymbols = OnlySymbols<ValueOf<typeof Symbol>>;
/**
 * Omit (replace with never) a key if it is a custom symbol,
 * not just symbol or a well known symbol from the global Symbol.
 */
type SkipUniqueSymbols<Key> = symbol extends Key
	? Key // Key is symbol or a generalization of symbol, so leave it as is.
	: Key extends symbol
		? Key extends WellKnownSymbols
			? Key // Key is a well known symbol from the global Symbol object. These are shared between packages, so they are fine and kept as is.
			: never // Key is most likely some specialized symbol, typically a unique symbol. These break type comparisons so are removed by replacing them with never.
		: Key; // Key is not a symbol (for example its a string or number), so leave it as is.
/**
 * Remove details of T which are incompatible with type testing while keeping as much as is practical.
 *
 * See 'build-tools/packages/build-tools/src/typeValidator/compatibility.ts' for more information.
 */
type TypeOnly<T> = T extends number
	? number
	: T extends boolean | bigint | string
		? T
		: T extends symbol
			? SkipUniqueSymbols<T>
			: {
					[P in keyof T as SkipUniqueSymbols<P>]: TypeOnly<T[P]>;
				};

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_BaseSegment": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_BaseSegment():
    TypeOnly<old.BaseSegment>;
declare function use_current_ClassDeclaration_BaseSegment(
    use: TypeOnly<current.BaseSegment>): void;
use_current_ClassDeclaration_BaseSegment(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_BaseSegment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_BaseSegment": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_BaseSegment():
    TypeOnly<current.BaseSegment>;
declare function use_old_ClassDeclaration_BaseSegment(
    use: TypeOnly<old.BaseSegment>): void;
use_old_ClassDeclaration_BaseSegment(
    get_current_ClassDeclaration_BaseSegment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_DeserializeCallback": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_DeserializeCallback():
    TypeOnly<old.DeserializeCallback>;
declare function use_current_TypeAliasDeclaration_DeserializeCallback(
    use: TypeOnly<current.DeserializeCallback>): void;
use_current_TypeAliasDeclaration_DeserializeCallback(
    get_old_TypeAliasDeclaration_DeserializeCallback());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_DeserializeCallback": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_DeserializeCallback():
    TypeOnly<current.DeserializeCallback>;
declare function use_old_TypeAliasDeclaration_DeserializeCallback(
    use: TypeOnly<old.DeserializeCallback>): void;
use_old_TypeAliasDeclaration_DeserializeCallback(
    get_current_TypeAliasDeclaration_DeserializeCallback());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEndpointInRangeIndex": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IEndpointInRangeIndex():
    TypeOnly<old.IEndpointInRangeIndex<any>>;
declare function use_current_InterfaceDeclaration_IEndpointInRangeIndex(
    use: TypeOnly<current.IEndpointInRangeIndex<any>>): void;
use_current_InterfaceDeclaration_IEndpointInRangeIndex(
    get_old_InterfaceDeclaration_IEndpointInRangeIndex());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEndpointInRangeIndex": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IEndpointInRangeIndex():
    TypeOnly<current.IEndpointInRangeIndex<any>>;
declare function use_old_InterfaceDeclaration_IEndpointInRangeIndex(
    use: TypeOnly<old.IEndpointInRangeIndex<any>>): void;
use_old_InterfaceDeclaration_IEndpointInRangeIndex(
    get_current_InterfaceDeclaration_IEndpointInRangeIndex());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEndpointIndex": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IEndpointIndex():
    TypeOnly<old.IEndpointIndex<any>>;
declare function use_current_InterfaceDeclaration_IEndpointIndex(
    use: TypeOnly<current.IEndpointIndex<any>>): void;
use_current_InterfaceDeclaration_IEndpointIndex(
    get_old_InterfaceDeclaration_IEndpointIndex());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IEndpointIndex": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IEndpointIndex():
    TypeOnly<current.IEndpointIndex<any>>;
declare function use_old_InterfaceDeclaration_IEndpointIndex(
    use: TypeOnly<old.IEndpointIndex<any>>): void;
use_old_InterfaceDeclaration_IEndpointIndex(
    get_current_InterfaceDeclaration_IEndpointIndex());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIdIntervalIndex": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IIdIntervalIndex():
    TypeOnly<old.IIdIntervalIndex<any>>;
declare function use_current_InterfaceDeclaration_IIdIntervalIndex(
    use: TypeOnly<current.IIdIntervalIndex<any>>): void;
use_current_InterfaceDeclaration_IIdIntervalIndex(
    get_old_InterfaceDeclaration_IIdIntervalIndex());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIdIntervalIndex": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IIdIntervalIndex():
    TypeOnly<current.IIdIntervalIndex<any>>;
declare function use_old_InterfaceDeclaration_IIdIntervalIndex(
    use: TypeOnly<old.IIdIntervalIndex<any>>): void;
use_old_InterfaceDeclaration_IIdIntervalIndex(
    get_current_InterfaceDeclaration_IIdIntervalIndex());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IInterval": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IInterval():
    TypeOnly<old.IInterval>;
declare function use_current_InterfaceDeclaration_IInterval(
    use: TypeOnly<current.IInterval>): void;
use_current_InterfaceDeclaration_IInterval(
    get_old_InterfaceDeclaration_IInterval());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IInterval": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IInterval():
    TypeOnly<current.IInterval>;
declare function use_old_InterfaceDeclaration_IInterval(
    use: TypeOnly<old.IInterval>): void;
use_old_InterfaceDeclaration_IInterval(
    get_current_InterfaceDeclaration_IInterval());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIntervalCollection": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IIntervalCollection():
    TypeOnly<old.IIntervalCollection<any>>;
declare function use_current_InterfaceDeclaration_IIntervalCollection(
    use: TypeOnly<current.IIntervalCollection<any>>): void;
use_current_InterfaceDeclaration_IIntervalCollection(
    get_old_InterfaceDeclaration_IIntervalCollection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIntervalCollection": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IIntervalCollection():
    TypeOnly<current.IIntervalCollection<any>>;
declare function use_old_InterfaceDeclaration_IIntervalCollection(
    use: TypeOnly<old.IIntervalCollection<any>>): void;
use_old_InterfaceDeclaration_IIntervalCollection(
    get_current_InterfaceDeclaration_IIntervalCollection());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIntervalCollectionEvent": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IIntervalCollectionEvent():
    TypeOnly<old.IIntervalCollectionEvent<any>>;
declare function use_current_InterfaceDeclaration_IIntervalCollectionEvent(
    use: TypeOnly<current.IIntervalCollectionEvent<any>>): void;
use_current_InterfaceDeclaration_IIntervalCollectionEvent(
    get_old_InterfaceDeclaration_IIntervalCollectionEvent());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIntervalCollectionEvent": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IIntervalCollectionEvent():
    TypeOnly<current.IIntervalCollectionEvent<any>>;
declare function use_old_InterfaceDeclaration_IIntervalCollectionEvent(
    use: TypeOnly<old.IIntervalCollectionEvent<any>>): void;
use_old_InterfaceDeclaration_IIntervalCollectionEvent(
    get_current_InterfaceDeclaration_IIntervalCollectionEvent());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIntervalHelpers": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IIntervalHelpers():
    TypeOnly<old.IIntervalHelpers<any>>;
declare function use_current_InterfaceDeclaration_IIntervalHelpers(
    use: TypeOnly<current.IIntervalHelpers<any>>): void;
use_current_InterfaceDeclaration_IIntervalHelpers(
    get_old_InterfaceDeclaration_IIntervalHelpers());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IIntervalHelpers": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IIntervalHelpers():
    TypeOnly<current.IIntervalHelpers<any>>;
declare function use_old_InterfaceDeclaration_IIntervalHelpers(
    use: TypeOnly<old.IIntervalHelpers<any>>): void;
use_old_InterfaceDeclaration_IIntervalHelpers(
    get_current_InterfaceDeclaration_IIntervalHelpers());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONRunSegment": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IJSONRunSegment():
    TypeOnly<old.IJSONRunSegment<any>>;
declare function use_current_InterfaceDeclaration_IJSONRunSegment(
    use: TypeOnly<current.IJSONRunSegment<any>>): void;
use_current_InterfaceDeclaration_IJSONRunSegment(
    get_old_InterfaceDeclaration_IJSONRunSegment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IJSONRunSegment": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IJSONRunSegment():
    TypeOnly<current.IJSONRunSegment<any>>;
declare function use_old_InterfaceDeclaration_IJSONRunSegment(
    use: TypeOnly<old.IJSONRunSegment<any>>): void;
use_old_InterfaceDeclaration_IJSONRunSegment(
    get_current_InterfaceDeclaration_IJSONRunSegment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMapMessageLocalMetadata": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMapMessageLocalMetadata():
    TypeOnly<old.IMapMessageLocalMetadata>;
declare function use_current_InterfaceDeclaration_IMapMessageLocalMetadata(
    use: TypeOnly<current.IMapMessageLocalMetadata>): void;
use_current_InterfaceDeclaration_IMapMessageLocalMetadata(
    get_old_InterfaceDeclaration_IMapMessageLocalMetadata());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMapMessageLocalMetadata": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMapMessageLocalMetadata():
    TypeOnly<current.IMapMessageLocalMetadata>;
declare function use_old_InterfaceDeclaration_IMapMessageLocalMetadata(
    use: TypeOnly<old.IMapMessageLocalMetadata>): void;
use_old_InterfaceDeclaration_IMapMessageLocalMetadata(
    get_current_InterfaceDeclaration_IMapMessageLocalMetadata());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOverlappingIntervalsIndex": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IOverlappingIntervalsIndex():
    TypeOnly<old.IOverlappingIntervalsIndex<any>>;
declare function use_current_InterfaceDeclaration_IOverlappingIntervalsIndex(
    use: TypeOnly<current.IOverlappingIntervalsIndex<any>>): void;
use_current_InterfaceDeclaration_IOverlappingIntervalsIndex(
    get_old_InterfaceDeclaration_IOverlappingIntervalsIndex());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IOverlappingIntervalsIndex": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IOverlappingIntervalsIndex():
    TypeOnly<current.IOverlappingIntervalsIndex<any>>;
declare function use_old_InterfaceDeclaration_IOverlappingIntervalsIndex(
    use: TypeOnly<old.IOverlappingIntervalsIndex<any>>): void;
use_old_InterfaceDeclaration_IOverlappingIntervalsIndex(
    get_current_InterfaceDeclaration_IOverlappingIntervalsIndex());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISegment": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISegment():
    TypeOnly<old.ISegment>;
declare function use_current_InterfaceDeclaration_ISegment(
    use: TypeOnly<current.ISegment>): void;
use_current_InterfaceDeclaration_ISegment(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_ISegment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISegment": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISegment():
    TypeOnly<current.ISegment>;
declare function use_old_InterfaceDeclaration_ISegment(
    use: TypeOnly<old.ISegment>): void;
use_old_InterfaceDeclaration_ISegment(
    get_current_InterfaceDeclaration_ISegment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISequenceDeltaRange": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISequenceDeltaRange():
    TypeOnly<old.ISequenceDeltaRange>;
declare function use_current_InterfaceDeclaration_ISequenceDeltaRange(
    use: TypeOnly<current.ISequenceDeltaRange>): void;
use_current_InterfaceDeclaration_ISequenceDeltaRange(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_ISequenceDeltaRange());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISequenceDeltaRange": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISequenceDeltaRange():
    TypeOnly<current.ISequenceDeltaRange>;
declare function use_old_InterfaceDeclaration_ISequenceDeltaRange(
    use: TypeOnly<old.ISequenceDeltaRange>): void;
use_old_InterfaceDeclaration_ISequenceDeltaRange(
    get_current_InterfaceDeclaration_ISequenceDeltaRange());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISerializableInterval": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISerializableInterval():
    TypeOnly<old.ISerializableInterval>;
declare function use_current_InterfaceDeclaration_ISerializableInterval(
    use: TypeOnly<current.ISerializableInterval>): void;
use_current_InterfaceDeclaration_ISerializableInterval(
    get_old_InterfaceDeclaration_ISerializableInterval());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISerializableInterval": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISerializableInterval():
    TypeOnly<current.ISerializableInterval>;
declare function use_old_InterfaceDeclaration_ISerializableInterval(
    use: TypeOnly<old.ISerializableInterval>): void;
use_old_InterfaceDeclaration_ISerializableInterval(
    get_current_InterfaceDeclaration_ISerializableInterval());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISerializedInterval": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISerializedInterval():
    TypeOnly<old.ISerializedInterval>;
declare function use_current_InterfaceDeclaration_ISerializedInterval(
    use: TypeOnly<current.ISerializedInterval>): void;
use_current_InterfaceDeclaration_ISerializedInterval(
    get_old_InterfaceDeclaration_ISerializedInterval());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISerializedInterval": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISerializedInterval():
    TypeOnly<current.ISerializedInterval>;
declare function use_old_InterfaceDeclaration_ISerializedInterval(
    use: TypeOnly<old.ISerializedInterval>): void;
use_old_InterfaceDeclaration_ISerializedInterval(
    get_current_InterfaceDeclaration_ISerializedInterval());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharedIntervalCollection": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISharedIntervalCollection():
    TypeOnly<old.ISharedIntervalCollection<any>>;
declare function use_current_InterfaceDeclaration_ISharedIntervalCollection(
    use: TypeOnly<current.ISharedIntervalCollection<any>>): void;
use_current_InterfaceDeclaration_ISharedIntervalCollection(
    get_old_InterfaceDeclaration_ISharedIntervalCollection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharedIntervalCollection": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISharedIntervalCollection():
    TypeOnly<current.ISharedIntervalCollection<any>>;
declare function use_old_InterfaceDeclaration_ISharedIntervalCollection(
    use: TypeOnly<old.ISharedIntervalCollection<any>>): void;
use_old_InterfaceDeclaration_ISharedIntervalCollection(
    get_current_InterfaceDeclaration_ISharedIntervalCollection());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharedSegmentSequenceEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISharedSegmentSequenceEvents():
    TypeOnly<old.ISharedSegmentSequenceEvents>;
declare function use_current_InterfaceDeclaration_ISharedSegmentSequenceEvents(
    use: TypeOnly<current.ISharedSegmentSequenceEvents>): void;
use_current_InterfaceDeclaration_ISharedSegmentSequenceEvents(
    get_old_InterfaceDeclaration_ISharedSegmentSequenceEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharedSegmentSequenceEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISharedSegmentSequenceEvents():
    TypeOnly<current.ISharedSegmentSequenceEvents>;
declare function use_old_InterfaceDeclaration_ISharedSegmentSequenceEvents(
    use: TypeOnly<old.ISharedSegmentSequenceEvents>): void;
use_old_InterfaceDeclaration_ISharedSegmentSequenceEvents(
    get_current_InterfaceDeclaration_ISharedSegmentSequenceEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharedString": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISharedString():
    TypeOnly<old.ISharedString>;
declare function use_current_InterfaceDeclaration_ISharedString(
    use: TypeOnly<current.ISharedString>): void;
use_current_InterfaceDeclaration_ISharedString(
    get_old_InterfaceDeclaration_ISharedString());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ISharedString": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISharedString():
    TypeOnly<current.ISharedString>;
declare function use_old_InterfaceDeclaration_ISharedString(
    use: TypeOnly<old.ISharedString>): void;
use_old_InterfaceDeclaration_ISharedString(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_ISharedString());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IStartpointInRangeIndex": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IStartpointInRangeIndex():
    TypeOnly<old.IStartpointInRangeIndex<any>>;
declare function use_current_InterfaceDeclaration_IStartpointInRangeIndex(
    use: TypeOnly<current.IStartpointInRangeIndex<any>>): void;
use_current_InterfaceDeclaration_IStartpointInRangeIndex(
    get_old_InterfaceDeclaration_IStartpointInRangeIndex());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IStartpointInRangeIndex": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IStartpointInRangeIndex():
    TypeOnly<current.IStartpointInRangeIndex<any>>;
declare function use_old_InterfaceDeclaration_IStartpointInRangeIndex(
    use: TypeOnly<old.IStartpointInRangeIndex<any>>): void;
use_old_InterfaceDeclaration_IStartpointInRangeIndex(
    get_current_InterfaceDeclaration_IStartpointInRangeIndex());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IValueOpEmitter": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IValueOpEmitter():
    TypeOnly<old.IValueOpEmitter>;
declare function use_current_InterfaceDeclaration_IValueOpEmitter(
    use: TypeOnly<current.IValueOpEmitter>): void;
use_current_InterfaceDeclaration_IValueOpEmitter(
    get_old_InterfaceDeclaration_IValueOpEmitter());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IValueOpEmitter": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IValueOpEmitter():
    TypeOnly<current.IValueOpEmitter>;
declare function use_old_InterfaceDeclaration_IValueOpEmitter(
    use: TypeOnly<old.IValueOpEmitter>): void;
use_old_InterfaceDeclaration_IValueOpEmitter(
    get_current_InterfaceDeclaration_IValueOpEmitter());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_InteriorSequencePlace": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_InteriorSequencePlace():
    TypeOnly<old.InteriorSequencePlace>;
declare function use_current_InterfaceDeclaration_InteriorSequencePlace(
    use: TypeOnly<current.InteriorSequencePlace>): void;
use_current_InterfaceDeclaration_InteriorSequencePlace(
    get_old_InterfaceDeclaration_InteriorSequencePlace());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_InteriorSequencePlace": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_InteriorSequencePlace():
    TypeOnly<current.InteriorSequencePlace>;
declare function use_old_InterfaceDeclaration_InteriorSequencePlace(
    use: TypeOnly<old.InteriorSequencePlace>): void;
use_old_InterfaceDeclaration_InteriorSequencePlace(
    get_current_InterfaceDeclaration_InteriorSequencePlace());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Interval": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_Interval():
    TypeOnly<old.Interval>;
declare function use_current_ClassDeclaration_Interval(
    use: TypeOnly<current.Interval>): void;
use_current_ClassDeclaration_Interval(
    get_old_ClassDeclaration_Interval());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Interval": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_Interval():
    TypeOnly<current.Interval>;
declare function use_old_ClassDeclaration_Interval(
    use: TypeOnly<old.Interval>): void;
use_old_ClassDeclaration_Interval(
    get_current_ClassDeclaration_Interval());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IntervalIndex": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IntervalIndex():
    TypeOnly<old.IntervalIndex<any>>;
declare function use_current_InterfaceDeclaration_IntervalIndex(
    use: TypeOnly<current.IntervalIndex<any>>): void;
use_current_InterfaceDeclaration_IntervalIndex(
    get_old_InterfaceDeclaration_IntervalIndex());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IntervalIndex": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IntervalIndex():
    TypeOnly<current.IntervalIndex<any>>;
declare function use_old_InterfaceDeclaration_IntervalIndex(
    use: TypeOnly<old.IntervalIndex<any>>): void;
use_old_InterfaceDeclaration_IntervalIndex(
    get_current_InterfaceDeclaration_IntervalIndex());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IntervalLocator": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IntervalLocator():
    TypeOnly<old.IntervalLocator>;
declare function use_current_InterfaceDeclaration_IntervalLocator(
    use: TypeOnly<current.IntervalLocator>): void;
use_current_InterfaceDeclaration_IntervalLocator(
    get_old_InterfaceDeclaration_IntervalLocator());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IntervalLocator": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IntervalLocator():
    TypeOnly<current.IntervalLocator>;
declare function use_old_InterfaceDeclaration_IntervalLocator(
    use: TypeOnly<old.IntervalLocator>): void;
use_old_InterfaceDeclaration_IntervalLocator(
    get_current_InterfaceDeclaration_IntervalLocator());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IntervalOpType": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_IntervalOpType():
    TypeOnly<typeof old.IntervalOpType>;
declare function use_current_VariableDeclaration_IntervalOpType(
    use: TypeOnly<typeof current.IntervalOpType>): void;
use_current_VariableDeclaration_IntervalOpType(
    get_old_VariableDeclaration_IntervalOpType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IntervalOpType": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_IntervalOpType():
    TypeOnly<typeof current.IntervalOpType>;
declare function use_old_VariableDeclaration_IntervalOpType(
    use: TypeOnly<typeof old.IntervalOpType>): void;
use_old_VariableDeclaration_IntervalOpType(
    get_current_VariableDeclaration_IntervalOpType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IntervalOpType": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IntervalOpType():
    TypeOnly<old.IntervalOpType>;
declare function use_current_TypeAliasDeclaration_IntervalOpType(
    use: TypeOnly<current.IntervalOpType>): void;
use_current_TypeAliasDeclaration_IntervalOpType(
    get_old_TypeAliasDeclaration_IntervalOpType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IntervalOpType": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IntervalOpType():
    TypeOnly<current.IntervalOpType>;
declare function use_old_TypeAliasDeclaration_IntervalOpType(
    use: TypeOnly<old.IntervalOpType>): void;
use_old_TypeAliasDeclaration_IntervalOpType(
    get_current_TypeAliasDeclaration_IntervalOpType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IntervalRevertible": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IntervalRevertible():
    TypeOnly<old.IntervalRevertible>;
declare function use_current_TypeAliasDeclaration_IntervalRevertible(
    use: TypeOnly<current.IntervalRevertible>): void;
use_current_TypeAliasDeclaration_IntervalRevertible(
    // @ts-expect-error compatibility expected to be broken
    get_old_TypeAliasDeclaration_IntervalRevertible());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IntervalRevertible": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IntervalRevertible():
    TypeOnly<current.IntervalRevertible>;
declare function use_old_TypeAliasDeclaration_IntervalRevertible(
    use: TypeOnly<old.IntervalRevertible>): void;
use_old_TypeAliasDeclaration_IntervalRevertible(
    get_current_TypeAliasDeclaration_IntervalRevertible());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IntervalStickiness": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_IntervalStickiness():
    TypeOnly<typeof old.IntervalStickiness>;
declare function use_current_VariableDeclaration_IntervalStickiness(
    use: TypeOnly<typeof current.IntervalStickiness>): void;
use_current_VariableDeclaration_IntervalStickiness(
    get_old_VariableDeclaration_IntervalStickiness());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_IntervalStickiness": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_IntervalStickiness():
    TypeOnly<typeof current.IntervalStickiness>;
declare function use_old_VariableDeclaration_IntervalStickiness(
    use: TypeOnly<typeof old.IntervalStickiness>): void;
use_old_VariableDeclaration_IntervalStickiness(
    get_current_VariableDeclaration_IntervalStickiness());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IntervalStickiness": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_IntervalStickiness():
    TypeOnly<old.IntervalStickiness>;
declare function use_current_TypeAliasDeclaration_IntervalStickiness(
    use: TypeOnly<current.IntervalStickiness>): void;
use_current_TypeAliasDeclaration_IntervalStickiness(
    get_old_TypeAliasDeclaration_IntervalStickiness());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_IntervalStickiness": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_IntervalStickiness():
    TypeOnly<current.IntervalStickiness>;
declare function use_old_TypeAliasDeclaration_IntervalStickiness(
    use: TypeOnly<old.IntervalStickiness>): void;
use_old_TypeAliasDeclaration_IntervalStickiness(
    get_current_TypeAliasDeclaration_IntervalStickiness());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_IntervalType": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_IntervalType():
    TypeOnly<old.IntervalType>;
declare function use_current_EnumDeclaration_IntervalType(
    use: TypeOnly<current.IntervalType>): void;
use_current_EnumDeclaration_IntervalType(
    get_old_EnumDeclaration_IntervalType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_IntervalType": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_IntervalType():
    TypeOnly<current.IntervalType>;
declare function use_old_EnumDeclaration_IntervalType(
    use: TypeOnly<old.IntervalType>): void;
use_old_EnumDeclaration_IntervalType(
    get_current_EnumDeclaration_IntervalType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_LocalReferencePosition": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_LocalReferencePosition():
    TypeOnly<old.LocalReferencePosition>;
declare function use_current_InterfaceDeclaration_LocalReferencePosition(
    use: TypeOnly<current.LocalReferencePosition>): void;
use_current_InterfaceDeclaration_LocalReferencePosition(
    get_old_InterfaceDeclaration_LocalReferencePosition());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_LocalReferencePosition": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_LocalReferencePosition():
    TypeOnly<current.LocalReferencePosition>;
declare function use_old_InterfaceDeclaration_LocalReferencePosition(
    use: TypeOnly<old.LocalReferencePosition>): void;
use_old_InterfaceDeclaration_LocalReferencePosition(
    get_current_InterfaceDeclaration_LocalReferencePosition());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MapLike": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_MapLike():
    TypeOnly<old.MapLike<any>>;
declare function use_current_InterfaceDeclaration_MapLike(
    use: TypeOnly<current.MapLike<any>>): void;
use_current_InterfaceDeclaration_MapLike(
    get_old_InterfaceDeclaration_MapLike());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_MapLike": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_MapLike():
    TypeOnly<current.MapLike<any>>;
declare function use_old_InterfaceDeclaration_MapLike(
    use: TypeOnly<old.MapLike<any>>): void;
use_old_InterfaceDeclaration_MapLike(
    get_current_InterfaceDeclaration_MapLike());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Marker": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_Marker():
    TypeOnly<old.Marker>;
declare function use_current_ClassDeclaration_Marker(
    use: TypeOnly<current.Marker>): void;
use_current_ClassDeclaration_Marker(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_Marker());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Marker": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_Marker():
    TypeOnly<current.Marker>;
declare function use_old_ClassDeclaration_Marker(
    use: TypeOnly<old.Marker>): void;
use_old_ClassDeclaration_Marker(
    get_current_ClassDeclaration_Marker());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_MergeTreeDeltaType": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_MergeTreeDeltaType():
    TypeOnly<typeof old.MergeTreeDeltaType>;
declare function use_current_VariableDeclaration_MergeTreeDeltaType(
    use: TypeOnly<typeof current.MergeTreeDeltaType>): void;
use_current_VariableDeclaration_MergeTreeDeltaType(
    get_old_VariableDeclaration_MergeTreeDeltaType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_MergeTreeDeltaType": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_MergeTreeDeltaType():
    TypeOnly<typeof current.MergeTreeDeltaType>;
declare function use_old_VariableDeclaration_MergeTreeDeltaType(
    use: TypeOnly<typeof old.MergeTreeDeltaType>): void;
use_old_VariableDeclaration_MergeTreeDeltaType(
    get_current_VariableDeclaration_MergeTreeDeltaType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaType": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_MergeTreeDeltaType():
    TypeOnly<old.MergeTreeDeltaType>;
declare function use_current_TypeAliasDeclaration_MergeTreeDeltaType(
    use: TypeOnly<current.MergeTreeDeltaType>): void;
use_current_TypeAliasDeclaration_MergeTreeDeltaType(
    get_old_TypeAliasDeclaration_MergeTreeDeltaType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MergeTreeDeltaType": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_MergeTreeDeltaType():
    TypeOnly<current.MergeTreeDeltaType>;
declare function use_old_TypeAliasDeclaration_MergeTreeDeltaType(
    use: TypeOnly<old.MergeTreeDeltaType>): void;
use_old_TypeAliasDeclaration_MergeTreeDeltaType(
    get_current_TypeAliasDeclaration_MergeTreeDeltaType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_PropertySet": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_PropertySet():
    TypeOnly<old.PropertySet>;
declare function use_current_TypeAliasDeclaration_PropertySet(
    use: TypeOnly<current.PropertySet>): void;
use_current_TypeAliasDeclaration_PropertySet(
    get_old_TypeAliasDeclaration_PropertySet());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_PropertySet": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_PropertySet():
    TypeOnly<current.PropertySet>;
declare function use_old_TypeAliasDeclaration_PropertySet(
    use: TypeOnly<old.PropertySet>): void;
use_old_TypeAliasDeclaration_PropertySet(
    get_current_TypeAliasDeclaration_PropertySet());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ReferencePosition": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ReferencePosition():
    TypeOnly<old.ReferencePosition>;
declare function use_current_InterfaceDeclaration_ReferencePosition(
    use: TypeOnly<current.ReferencePosition>): void;
use_current_InterfaceDeclaration_ReferencePosition(
    get_old_InterfaceDeclaration_ReferencePosition());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ReferencePosition": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ReferencePosition():
    TypeOnly<current.ReferencePosition>;
declare function use_old_InterfaceDeclaration_ReferencePosition(
    use: TypeOnly<old.ReferencePosition>): void;
use_old_InterfaceDeclaration_ReferencePosition(
    get_current_InterfaceDeclaration_ReferencePosition());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_ReferenceType": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_ReferenceType():
    TypeOnly<old.ReferenceType>;
declare function use_current_EnumDeclaration_ReferenceType(
    use: TypeOnly<current.ReferenceType>): void;
use_current_EnumDeclaration_ReferenceType(
    get_old_EnumDeclaration_ReferenceType());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_ReferenceType": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_ReferenceType():
    TypeOnly<current.ReferenceType>;
declare function use_old_EnumDeclaration_ReferenceType(
    use: TypeOnly<old.ReferenceType>): void;
use_old_EnumDeclaration_ReferenceType(
    get_current_EnumDeclaration_ReferenceType());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceDeltaEvent": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SequenceDeltaEvent():
    TypeOnly<old.SequenceDeltaEvent>;
declare function use_current_ClassDeclaration_SequenceDeltaEvent(
    use: TypeOnly<current.SequenceDeltaEvent>): void;
use_current_ClassDeclaration_SequenceDeltaEvent(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_SequenceDeltaEvent());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceDeltaEvent": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SequenceDeltaEvent():
    TypeOnly<current.SequenceDeltaEvent>;
declare function use_old_ClassDeclaration_SequenceDeltaEvent(
    use: TypeOnly<old.SequenceDeltaEvent>): void;
use_old_ClassDeclaration_SequenceDeltaEvent(
    get_current_ClassDeclaration_SequenceDeltaEvent());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceEvent": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SequenceEvent():
    TypeOnly<old.SequenceEvent>;
declare function use_current_ClassDeclaration_SequenceEvent(
    use: TypeOnly<current.SequenceEvent>): void;
use_current_ClassDeclaration_SequenceEvent(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_SequenceEvent());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceEvent": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SequenceEvent():
    TypeOnly<current.SequenceEvent>;
declare function use_old_ClassDeclaration_SequenceEvent(
    use: TypeOnly<old.SequenceEvent>): void;
use_old_ClassDeclaration_SequenceEvent(
    get_current_ClassDeclaration_SequenceEvent());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceInterval": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SequenceInterval():
    TypeOnly<old.SequenceInterval>;
declare function use_current_ClassDeclaration_SequenceInterval(
    use: TypeOnly<current.SequenceInterval>): void;
use_current_ClassDeclaration_SequenceInterval(
    get_old_ClassDeclaration_SequenceInterval());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceInterval": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SequenceInterval():
    TypeOnly<current.SequenceInterval>;
declare function use_old_ClassDeclaration_SequenceInterval(
    use: TypeOnly<old.SequenceInterval>): void;
use_old_ClassDeclaration_SequenceInterval(
    get_current_ClassDeclaration_SequenceInterval());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceMaintenanceEvent": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SequenceMaintenanceEvent():
    TypeOnly<old.SequenceMaintenanceEvent>;
declare function use_current_ClassDeclaration_SequenceMaintenanceEvent(
    use: TypeOnly<current.SequenceMaintenanceEvent>): void;
use_current_ClassDeclaration_SequenceMaintenanceEvent(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_SequenceMaintenanceEvent());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SequenceMaintenanceEvent": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SequenceMaintenanceEvent():
    TypeOnly<current.SequenceMaintenanceEvent>;
declare function use_old_ClassDeclaration_SequenceMaintenanceEvent(
    use: TypeOnly<old.SequenceMaintenanceEvent>): void;
use_old_ClassDeclaration_SequenceMaintenanceEvent(
    get_current_ClassDeclaration_SequenceMaintenanceEvent());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SequenceOptions": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SequenceOptions():
    TypeOnly<old.SequenceOptions>;
declare function use_current_InterfaceDeclaration_SequenceOptions(
    use: TypeOnly<current.SequenceOptions>): void;
use_current_InterfaceDeclaration_SequenceOptions(
    get_old_InterfaceDeclaration_SequenceOptions());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_SequenceOptions": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SequenceOptions():
    TypeOnly<current.SequenceOptions>;
declare function use_old_InterfaceDeclaration_SequenceOptions(
    use: TypeOnly<old.SequenceOptions>): void;
use_old_InterfaceDeclaration_SequenceOptions(
    get_current_InterfaceDeclaration_SequenceOptions());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SequencePlace": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SequencePlace():
    TypeOnly<old.SequencePlace>;
declare function use_current_TypeAliasDeclaration_SequencePlace(
    use: TypeOnly<current.SequencePlace>): void;
use_current_TypeAliasDeclaration_SequencePlace(
    get_old_TypeAliasDeclaration_SequencePlace());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SequencePlace": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SequencePlace():
    TypeOnly<current.SequencePlace>;
declare function use_old_TypeAliasDeclaration_SequencePlace(
    use: TypeOnly<old.SequencePlace>): void;
use_old_TypeAliasDeclaration_SequencePlace(
    get_current_TypeAliasDeclaration_SequencePlace());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SerializedIntervalDelta": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SerializedIntervalDelta():
    TypeOnly<old.SerializedIntervalDelta>;
declare function use_current_TypeAliasDeclaration_SerializedIntervalDelta(
    use: TypeOnly<current.SerializedIntervalDelta>): void;
use_current_TypeAliasDeclaration_SerializedIntervalDelta(
    get_old_TypeAliasDeclaration_SerializedIntervalDelta());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SerializedIntervalDelta": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SerializedIntervalDelta():
    TypeOnly<current.SerializedIntervalDelta>;
declare function use_old_TypeAliasDeclaration_SerializedIntervalDelta(
    use: TypeOnly<old.SerializedIntervalDelta>): void;
use_old_TypeAliasDeclaration_SerializedIntervalDelta(
    get_current_TypeAliasDeclaration_SerializedIntervalDelta());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedIntervalCollection": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SharedIntervalCollection():
    TypeOnly<old.SharedIntervalCollection>;
declare function use_current_ClassDeclaration_SharedIntervalCollection(
    use: TypeOnly<current.SharedIntervalCollection>): void;
use_current_ClassDeclaration_SharedIntervalCollection(
    get_old_ClassDeclaration_SharedIntervalCollection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedIntervalCollection": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SharedIntervalCollection():
    TypeOnly<current.SharedIntervalCollection>;
declare function use_old_ClassDeclaration_SharedIntervalCollection(
    use: TypeOnly<old.SharedIntervalCollection>): void;
use_old_ClassDeclaration_SharedIntervalCollection(
    get_current_ClassDeclaration_SharedIntervalCollection());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedIntervalCollectionFactory": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SharedIntervalCollectionFactory():
    TypeOnly<old.SharedIntervalCollectionFactory>;
declare function use_current_ClassDeclaration_SharedIntervalCollectionFactory(
    use: TypeOnly<current.SharedIntervalCollectionFactory>): void;
use_current_ClassDeclaration_SharedIntervalCollectionFactory(
    get_old_ClassDeclaration_SharedIntervalCollectionFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedIntervalCollectionFactory": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SharedIntervalCollectionFactory():
    TypeOnly<current.SharedIntervalCollectionFactory>;
declare function use_old_ClassDeclaration_SharedIntervalCollectionFactory(
    use: TypeOnly<old.SharedIntervalCollectionFactory>): void;
use_old_ClassDeclaration_SharedIntervalCollectionFactory(
    get_current_ClassDeclaration_SharedIntervalCollectionFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedSegmentSequence": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SharedSegmentSequence():
    TypeOnly<old.SharedSegmentSequence<any>>;
declare function use_current_ClassDeclaration_SharedSegmentSequence(
    use: TypeOnly<current.SharedSegmentSequence<any>>): void;
use_current_ClassDeclaration_SharedSegmentSequence(
    get_old_ClassDeclaration_SharedSegmentSequence());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedSegmentSequence": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SharedSegmentSequence():
    TypeOnly<current.SharedSegmentSequence<any>>;
declare function use_old_ClassDeclaration_SharedSegmentSequence(
    use: TypeOnly<old.SharedSegmentSequence<any>>): void;
use_old_ClassDeclaration_SharedSegmentSequence(
    get_current_ClassDeclaration_SharedSegmentSequence());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedSequence": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SharedSequence():
    TypeOnly<old.SharedSequence<any>>;
declare function use_current_ClassDeclaration_SharedSequence(
    use: TypeOnly<current.SharedSequence<any>>): void;
use_current_ClassDeclaration_SharedSequence(
    get_old_ClassDeclaration_SharedSequence());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedSequence": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SharedSequence():
    TypeOnly<current.SharedSequence<any>>;
declare function use_old_ClassDeclaration_SharedSequence(
    use: TypeOnly<old.SharedSequence<any>>): void;
use_old_ClassDeclaration_SharedSequence(
    get_current_ClassDeclaration_SharedSequence());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_SharedString": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_SharedString():
    TypeOnly<typeof old.SharedString>;
declare function use_current_VariableDeclaration_SharedString(
    use: TypeOnly<typeof current.SharedString>): void;
use_current_VariableDeclaration_SharedString(
    get_old_VariableDeclaration_SharedString());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_SharedString": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_SharedString():
    TypeOnly<typeof current.SharedString>;
declare function use_old_VariableDeclaration_SharedString(
    use: TypeOnly<typeof old.SharedString>): void;
use_old_VariableDeclaration_SharedString(
    get_current_VariableDeclaration_SharedString());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SharedString": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SharedString():
    TypeOnly<old.SharedString>;
declare function use_current_TypeAliasDeclaration_SharedString(
    use: TypeOnly<current.SharedString>): void;
use_current_TypeAliasDeclaration_SharedString(
    get_old_TypeAliasDeclaration_SharedString());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SharedString": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SharedString():
    TypeOnly<current.SharedString>;
declare function use_old_TypeAliasDeclaration_SharedString(
    use: TypeOnly<old.SharedString>): void;
use_old_TypeAliasDeclaration_SharedString(
    // @ts-expect-error compatibility expected to be broken
    get_current_TypeAliasDeclaration_SharedString());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedStringClass": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SharedStringClass():
    TypeOnly<old.SharedStringClass>;
declare function use_current_ClassDeclaration_SharedStringClass(
    use: TypeOnly<current.SharedStringClass>): void;
use_current_ClassDeclaration_SharedStringClass(
    get_old_ClassDeclaration_SharedStringClass());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SharedStringClass": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SharedStringClass():
    TypeOnly<current.SharedStringClass>;
declare function use_old_ClassDeclaration_SharedStringClass(
    use: TypeOnly<old.SharedStringClass>): void;
use_old_ClassDeclaration_SharedStringClass(
    // @ts-expect-error compatibility expected to be broken
    get_current_ClassDeclaration_SharedStringClass());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SharedStringRevertible": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SharedStringRevertible():
    TypeOnly<old.SharedStringRevertible>;
declare function use_current_TypeAliasDeclaration_SharedStringRevertible(
    use: TypeOnly<current.SharedStringRevertible>): void;
use_current_TypeAliasDeclaration_SharedStringRevertible(
    // @ts-expect-error compatibility expected to be broken
    get_old_TypeAliasDeclaration_SharedStringRevertible());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SharedStringRevertible": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SharedStringRevertible():
    TypeOnly<current.SharedStringRevertible>;
declare function use_old_TypeAliasDeclaration_SharedStringRevertible(
    use: TypeOnly<old.SharedStringRevertible>): void;
use_old_TypeAliasDeclaration_SharedStringRevertible(
    get_current_TypeAliasDeclaration_SharedStringRevertible());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SharedStringSegment": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SharedStringSegment():
    TypeOnly<old.SharedStringSegment>;
declare function use_current_TypeAliasDeclaration_SharedStringSegment(
    use: TypeOnly<current.SharedStringSegment>): void;
use_current_TypeAliasDeclaration_SharedStringSegment(
    // @ts-expect-error compatibility expected to be broken
    get_old_TypeAliasDeclaration_SharedStringSegment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_SharedStringSegment": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SharedStringSegment():
    TypeOnly<current.SharedStringSegment>;
declare function use_old_TypeAliasDeclaration_SharedStringSegment(
    use: TypeOnly<old.SharedStringSegment>): void;
use_old_TypeAliasDeclaration_SharedStringSegment(
    get_current_TypeAliasDeclaration_SharedStringSegment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_Side": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_Side():
    TypeOnly<old.Side>;
declare function use_current_EnumDeclaration_Side(
    use: TypeOnly<current.Side>): void;
use_current_EnumDeclaration_Side(
    get_old_EnumDeclaration_Side());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_Side": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_Side():
    TypeOnly<current.Side>;
declare function use_old_EnumDeclaration_Side(
    use: TypeOnly<old.Side>): void;
use_old_EnumDeclaration_Side(
    get_current_EnumDeclaration_Side());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SubSequence": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SubSequence():
    TypeOnly<old.SubSequence<any>>;
declare function use_current_ClassDeclaration_SubSequence(
    use: TypeOnly<current.SubSequence<any>>): void;
use_current_ClassDeclaration_SubSequence(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_SubSequence());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_SubSequence": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SubSequence():
    TypeOnly<current.SubSequence<any>>;
declare function use_old_ClassDeclaration_SubSequence(
    use: TypeOnly<old.SubSequence<any>>): void;
use_old_ClassDeclaration_SubSequence(
    get_current_ClassDeclaration_SubSequence());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TextSegment": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TextSegment():
    TypeOnly<old.TextSegment>;
declare function use_current_ClassDeclaration_TextSegment(
    use: TypeOnly<current.TextSegment>): void;
use_current_ClassDeclaration_TextSegment(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_TextSegment());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TextSegment": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TextSegment():
    TypeOnly<current.TextSegment>;
declare function use_old_ClassDeclaration_TextSegment(
    use: TypeOnly<old.TextSegment>): void;
use_old_ClassDeclaration_TextSegment(
    get_current_ClassDeclaration_TextSegment());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TrackingGroup": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TrackingGroup():
    TypeOnly<old.TrackingGroup>;
declare function use_current_ClassDeclaration_TrackingGroup(
    use: TypeOnly<current.TrackingGroup>): void;
use_current_ClassDeclaration_TrackingGroup(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_TrackingGroup());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TrackingGroup": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TrackingGroup():
    TypeOnly<current.TrackingGroup>;
declare function use_old_ClassDeclaration_TrackingGroup(
    use: TypeOnly<old.TrackingGroup>): void;
use_old_ClassDeclaration_TrackingGroup(
    get_current_ClassDeclaration_TrackingGroup());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendAddIntervalToRevertibles": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_appendAddIntervalToRevertibles():
    TypeOnly<typeof old.appendAddIntervalToRevertibles>;
declare function use_current_FunctionDeclaration_appendAddIntervalToRevertibles(
    use: TypeOnly<typeof current.appendAddIntervalToRevertibles>): void;
use_current_FunctionDeclaration_appendAddIntervalToRevertibles(
    get_old_FunctionDeclaration_appendAddIntervalToRevertibles());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendAddIntervalToRevertibles": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_appendAddIntervalToRevertibles():
    TypeOnly<typeof current.appendAddIntervalToRevertibles>;
declare function use_old_FunctionDeclaration_appendAddIntervalToRevertibles(
    use: TypeOnly<typeof old.appendAddIntervalToRevertibles>): void;
use_old_FunctionDeclaration_appendAddIntervalToRevertibles(
    get_current_FunctionDeclaration_appendAddIntervalToRevertibles());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendChangeIntervalToRevertibles": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_appendChangeIntervalToRevertibles():
    TypeOnly<typeof old.appendChangeIntervalToRevertibles>;
declare function use_current_FunctionDeclaration_appendChangeIntervalToRevertibles(
    use: TypeOnly<typeof current.appendChangeIntervalToRevertibles>): void;
use_current_FunctionDeclaration_appendChangeIntervalToRevertibles(
    get_old_FunctionDeclaration_appendChangeIntervalToRevertibles());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendChangeIntervalToRevertibles": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_appendChangeIntervalToRevertibles():
    TypeOnly<typeof current.appendChangeIntervalToRevertibles>;
declare function use_old_FunctionDeclaration_appendChangeIntervalToRevertibles(
    use: TypeOnly<typeof old.appendChangeIntervalToRevertibles>): void;
use_old_FunctionDeclaration_appendChangeIntervalToRevertibles(
    get_current_FunctionDeclaration_appendChangeIntervalToRevertibles());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendDeleteIntervalToRevertibles": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_appendDeleteIntervalToRevertibles():
    TypeOnly<typeof old.appendDeleteIntervalToRevertibles>;
declare function use_current_FunctionDeclaration_appendDeleteIntervalToRevertibles(
    use: TypeOnly<typeof current.appendDeleteIntervalToRevertibles>): void;
use_current_FunctionDeclaration_appendDeleteIntervalToRevertibles(
    get_old_FunctionDeclaration_appendDeleteIntervalToRevertibles());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendDeleteIntervalToRevertibles": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_appendDeleteIntervalToRevertibles():
    TypeOnly<typeof current.appendDeleteIntervalToRevertibles>;
declare function use_old_FunctionDeclaration_appendDeleteIntervalToRevertibles(
    use: TypeOnly<typeof old.appendDeleteIntervalToRevertibles>): void;
use_old_FunctionDeclaration_appendDeleteIntervalToRevertibles(
    get_current_FunctionDeclaration_appendDeleteIntervalToRevertibles());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendIntervalPropertyChangedToRevertibles": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_appendIntervalPropertyChangedToRevertibles():
    TypeOnly<typeof old.appendIntervalPropertyChangedToRevertibles>;
declare function use_current_FunctionDeclaration_appendIntervalPropertyChangedToRevertibles(
    use: TypeOnly<typeof current.appendIntervalPropertyChangedToRevertibles>): void;
use_current_FunctionDeclaration_appendIntervalPropertyChangedToRevertibles(
    get_old_FunctionDeclaration_appendIntervalPropertyChangedToRevertibles());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendIntervalPropertyChangedToRevertibles": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_appendIntervalPropertyChangedToRevertibles():
    TypeOnly<typeof current.appendIntervalPropertyChangedToRevertibles>;
declare function use_old_FunctionDeclaration_appendIntervalPropertyChangedToRevertibles(
    use: TypeOnly<typeof old.appendIntervalPropertyChangedToRevertibles>): void;
use_old_FunctionDeclaration_appendIntervalPropertyChangedToRevertibles(
    get_current_FunctionDeclaration_appendIntervalPropertyChangedToRevertibles());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendSharedStringDeltaToRevertibles": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_appendSharedStringDeltaToRevertibles():
    TypeOnly<typeof old.appendSharedStringDeltaToRevertibles>;
declare function use_current_FunctionDeclaration_appendSharedStringDeltaToRevertibles(
    use: TypeOnly<typeof current.appendSharedStringDeltaToRevertibles>): void;
use_current_FunctionDeclaration_appendSharedStringDeltaToRevertibles(
    get_old_FunctionDeclaration_appendSharedStringDeltaToRevertibles());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_appendSharedStringDeltaToRevertibles": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_appendSharedStringDeltaToRevertibles():
    TypeOnly<typeof current.appendSharedStringDeltaToRevertibles>;
declare function use_old_FunctionDeclaration_appendSharedStringDeltaToRevertibles(
    use: TypeOnly<typeof old.appendSharedStringDeltaToRevertibles>): void;
use_old_FunctionDeclaration_appendSharedStringDeltaToRevertibles(
    get_current_FunctionDeclaration_appendSharedStringDeltaToRevertibles());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createEndpointInRangeIndex": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createEndpointInRangeIndex():
    TypeOnly<typeof old.createEndpointInRangeIndex>;
declare function use_current_FunctionDeclaration_createEndpointInRangeIndex(
    use: TypeOnly<typeof current.createEndpointInRangeIndex>): void;
use_current_FunctionDeclaration_createEndpointInRangeIndex(
    get_old_FunctionDeclaration_createEndpointInRangeIndex());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createEndpointInRangeIndex": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createEndpointInRangeIndex():
    TypeOnly<typeof current.createEndpointInRangeIndex>;
declare function use_old_FunctionDeclaration_createEndpointInRangeIndex(
    use: TypeOnly<typeof old.createEndpointInRangeIndex>): void;
use_old_FunctionDeclaration_createEndpointInRangeIndex(
    get_current_FunctionDeclaration_createEndpointInRangeIndex());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createEndpointIndex": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createEndpointIndex():
    TypeOnly<typeof old.createEndpointIndex>;
declare function use_current_FunctionDeclaration_createEndpointIndex(
    use: TypeOnly<typeof current.createEndpointIndex>): void;
use_current_FunctionDeclaration_createEndpointIndex(
    get_old_FunctionDeclaration_createEndpointIndex());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createEndpointIndex": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createEndpointIndex():
    TypeOnly<typeof current.createEndpointIndex>;
declare function use_old_FunctionDeclaration_createEndpointIndex(
    use: TypeOnly<typeof old.createEndpointIndex>): void;
use_old_FunctionDeclaration_createEndpointIndex(
    get_current_FunctionDeclaration_createEndpointIndex());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createIdIntervalIndex": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createIdIntervalIndex():
    TypeOnly<typeof old.createIdIntervalIndex>;
declare function use_current_FunctionDeclaration_createIdIntervalIndex(
    use: TypeOnly<typeof current.createIdIntervalIndex>): void;
use_current_FunctionDeclaration_createIdIntervalIndex(
    get_old_FunctionDeclaration_createIdIntervalIndex());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createIdIntervalIndex": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createIdIntervalIndex():
    TypeOnly<typeof current.createIdIntervalIndex>;
declare function use_old_FunctionDeclaration_createIdIntervalIndex(
    use: TypeOnly<typeof old.createIdIntervalIndex>): void;
use_old_FunctionDeclaration_createIdIntervalIndex(
    get_current_FunctionDeclaration_createIdIntervalIndex());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createOverlappingIntervalsIndex": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createOverlappingIntervalsIndex():
    TypeOnly<typeof old.createOverlappingIntervalsIndex>;
declare function use_current_FunctionDeclaration_createOverlappingIntervalsIndex(
    use: TypeOnly<typeof current.createOverlappingIntervalsIndex>): void;
use_current_FunctionDeclaration_createOverlappingIntervalsIndex(
    get_old_FunctionDeclaration_createOverlappingIntervalsIndex());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createOverlappingIntervalsIndex": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createOverlappingIntervalsIndex():
    TypeOnly<typeof current.createOverlappingIntervalsIndex>;
declare function use_old_FunctionDeclaration_createOverlappingIntervalsIndex(
    use: TypeOnly<typeof old.createOverlappingIntervalsIndex>): void;
use_old_FunctionDeclaration_createOverlappingIntervalsIndex(
    get_current_FunctionDeclaration_createOverlappingIntervalsIndex());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createOverlappingSequenceIntervalsIndex": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createOverlappingSequenceIntervalsIndex():
    TypeOnly<typeof old.createOverlappingSequenceIntervalsIndex>;
declare function use_current_FunctionDeclaration_createOverlappingSequenceIntervalsIndex(
    use: TypeOnly<typeof current.createOverlappingSequenceIntervalsIndex>): void;
use_current_FunctionDeclaration_createOverlappingSequenceIntervalsIndex(
    get_old_FunctionDeclaration_createOverlappingSequenceIntervalsIndex());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createOverlappingSequenceIntervalsIndex": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createOverlappingSequenceIntervalsIndex():
    TypeOnly<typeof current.createOverlappingSequenceIntervalsIndex>;
declare function use_old_FunctionDeclaration_createOverlappingSequenceIntervalsIndex(
    use: TypeOnly<typeof old.createOverlappingSequenceIntervalsIndex>): void;
use_old_FunctionDeclaration_createOverlappingSequenceIntervalsIndex(
    get_current_FunctionDeclaration_createOverlappingSequenceIntervalsIndex());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createStartpointInRangeIndex": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createStartpointInRangeIndex():
    TypeOnly<typeof old.createStartpointInRangeIndex>;
declare function use_current_FunctionDeclaration_createStartpointInRangeIndex(
    use: TypeOnly<typeof current.createStartpointInRangeIndex>): void;
use_current_FunctionDeclaration_createStartpointInRangeIndex(
    get_old_FunctionDeclaration_createStartpointInRangeIndex());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createStartpointInRangeIndex": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createStartpointInRangeIndex():
    TypeOnly<typeof current.createStartpointInRangeIndex>;
declare function use_old_FunctionDeclaration_createStartpointInRangeIndex(
    use: TypeOnly<typeof old.createStartpointInRangeIndex>): void;
use_old_FunctionDeclaration_createStartpointInRangeIndex(
    get_current_FunctionDeclaration_createStartpointInRangeIndex());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_discardSharedStringRevertibles": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_discardSharedStringRevertibles():
    TypeOnly<typeof old.discardSharedStringRevertibles>;
declare function use_current_FunctionDeclaration_discardSharedStringRevertibles(
    use: TypeOnly<typeof current.discardSharedStringRevertibles>): void;
use_current_FunctionDeclaration_discardSharedStringRevertibles(
    get_old_FunctionDeclaration_discardSharedStringRevertibles());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_discardSharedStringRevertibles": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_discardSharedStringRevertibles():
    TypeOnly<typeof current.discardSharedStringRevertibles>;
declare function use_old_FunctionDeclaration_discardSharedStringRevertibles(
    use: TypeOnly<typeof old.discardSharedStringRevertibles>): void;
use_old_FunctionDeclaration_discardSharedStringRevertibles(
    get_current_FunctionDeclaration_discardSharedStringRevertibles());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getTextAndMarkers": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getTextAndMarkers():
    TypeOnly<typeof old.getTextAndMarkers>;
declare function use_current_FunctionDeclaration_getTextAndMarkers(
    use: TypeOnly<typeof current.getTextAndMarkers>): void;
use_current_FunctionDeclaration_getTextAndMarkers(
    get_old_FunctionDeclaration_getTextAndMarkers());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getTextAndMarkers": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getTextAndMarkers():
    TypeOnly<typeof current.getTextAndMarkers>;
declare function use_old_FunctionDeclaration_getTextAndMarkers(
    use: TypeOnly<typeof old.getTextAndMarkers>): void;
use_old_FunctionDeclaration_getTextAndMarkers(
    get_current_FunctionDeclaration_getTextAndMarkers());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_intervalLocatorFromEndpoint": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_intervalLocatorFromEndpoint():
    TypeOnly<typeof old.intervalLocatorFromEndpoint>;
declare function use_current_FunctionDeclaration_intervalLocatorFromEndpoint(
    use: TypeOnly<typeof current.intervalLocatorFromEndpoint>): void;
use_current_FunctionDeclaration_intervalLocatorFromEndpoint(
    get_old_FunctionDeclaration_intervalLocatorFromEndpoint());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_intervalLocatorFromEndpoint": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_intervalLocatorFromEndpoint():
    TypeOnly<typeof current.intervalLocatorFromEndpoint>;
declare function use_old_FunctionDeclaration_intervalLocatorFromEndpoint(
    use: TypeOnly<typeof old.intervalLocatorFromEndpoint>): void;
use_old_FunctionDeclaration_intervalLocatorFromEndpoint(
    get_current_FunctionDeclaration_intervalLocatorFromEndpoint());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedMarkerIdKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_reservedMarkerIdKey():
    TypeOnly<typeof old.reservedMarkerIdKey>;
declare function use_current_VariableDeclaration_reservedMarkerIdKey(
    use: TypeOnly<typeof current.reservedMarkerIdKey>): void;
use_current_VariableDeclaration_reservedMarkerIdKey(
    get_old_VariableDeclaration_reservedMarkerIdKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedMarkerIdKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_reservedMarkerIdKey():
    TypeOnly<typeof current.reservedMarkerIdKey>;
declare function use_old_VariableDeclaration_reservedMarkerIdKey(
    use: TypeOnly<typeof old.reservedMarkerIdKey>): void;
use_old_VariableDeclaration_reservedMarkerIdKey(
    get_current_VariableDeclaration_reservedMarkerIdKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedRangeLabelsKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_reservedRangeLabelsKey():
    TypeOnly<typeof old.reservedRangeLabelsKey>;
declare function use_current_VariableDeclaration_reservedRangeLabelsKey(
    use: TypeOnly<typeof current.reservedRangeLabelsKey>): void;
use_current_VariableDeclaration_reservedRangeLabelsKey(
    get_old_VariableDeclaration_reservedRangeLabelsKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedRangeLabelsKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_reservedRangeLabelsKey():
    TypeOnly<typeof current.reservedRangeLabelsKey>;
declare function use_old_VariableDeclaration_reservedRangeLabelsKey(
    use: TypeOnly<typeof old.reservedRangeLabelsKey>): void;
use_old_VariableDeclaration_reservedRangeLabelsKey(
    get_current_VariableDeclaration_reservedRangeLabelsKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedTileLabelsKey": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_reservedTileLabelsKey():
    TypeOnly<typeof old.reservedTileLabelsKey>;
declare function use_current_VariableDeclaration_reservedTileLabelsKey(
    use: TypeOnly<typeof current.reservedTileLabelsKey>): void;
use_current_VariableDeclaration_reservedTileLabelsKey(
    get_old_VariableDeclaration_reservedTileLabelsKey());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_reservedTileLabelsKey": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_reservedTileLabelsKey():
    TypeOnly<typeof current.reservedTileLabelsKey>;
declare function use_old_VariableDeclaration_reservedTileLabelsKey(
    use: TypeOnly<typeof old.reservedTileLabelsKey>): void;
use_old_VariableDeclaration_reservedTileLabelsKey(
    get_current_VariableDeclaration_reservedTileLabelsKey());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_revertSharedStringRevertibles": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_revertSharedStringRevertibles():
    TypeOnly<typeof old.revertSharedStringRevertibles>;
declare function use_current_FunctionDeclaration_revertSharedStringRevertibles(
    use: TypeOnly<typeof current.revertSharedStringRevertibles>): void;
use_current_FunctionDeclaration_revertSharedStringRevertibles(
    get_old_FunctionDeclaration_revertSharedStringRevertibles());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_revertSharedStringRevertibles": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_revertSharedStringRevertibles():
    TypeOnly<typeof current.revertSharedStringRevertibles>;
declare function use_old_FunctionDeclaration_revertSharedStringRevertibles(
    use: TypeOnly<typeof old.revertSharedStringRevertibles>): void;
use_old_FunctionDeclaration_revertSharedStringRevertibles(
    get_current_FunctionDeclaration_revertSharedStringRevertibles());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_sequenceIntervalHelpers": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_sequenceIntervalHelpers():
    TypeOnly<typeof old.sequenceIntervalHelpers>;
declare function use_current_VariableDeclaration_sequenceIntervalHelpers(
    use: TypeOnly<typeof current.sequenceIntervalHelpers>): void;
use_current_VariableDeclaration_sequenceIntervalHelpers(
    get_old_VariableDeclaration_sequenceIntervalHelpers());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_sequenceIntervalHelpers": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_sequenceIntervalHelpers():
    TypeOnly<typeof current.sequenceIntervalHelpers>;
declare function use_old_VariableDeclaration_sequenceIntervalHelpers(
    use: TypeOnly<typeof old.sequenceIntervalHelpers>): void;
use_old_VariableDeclaration_sequenceIntervalHelpers(
    get_current_VariableDeclaration_sequenceIntervalHelpers());
