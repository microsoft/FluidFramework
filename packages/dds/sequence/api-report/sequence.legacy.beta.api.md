## Beta API Report File for "@fluidframework/sequence"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @beta @legacy
export function appendAddIntervalToRevertibles(interval: SequenceInterval, revertibles: SharedStringRevertible[]): SharedStringRevertible[];

// @beta @legacy
export function appendChangeIntervalToRevertibles(string: ISharedString, newInterval: SequenceInterval, previousInterval: SequenceInterval, revertibles: SharedStringRevertible[]): SharedStringRevertible[];

// @beta @legacy
export function appendDeleteIntervalToRevertibles(string: ISharedString, interval: SequenceInterval, revertibles: SharedStringRevertible[]): SharedStringRevertible[];

// @beta @legacy
export function appendIntervalPropertyChangedToRevertibles(interval: SequenceInterval, deltas: PropertySet, revertibles: SharedStringRevertible[]): SharedStringRevertible[];

// @beta @legacy
export function appendSharedStringDeltaToRevertibles(string: ISharedString, delta: SequenceDeltaEvent, revertibles: SharedStringRevertible[]): void;

// @beta @legacy (undocumented)
export abstract class BaseSegment implements ISegment {
    constructor(properties?: PropertySet);
    // (undocumented)
    protected addSerializedProps(jseg: IJSONSegment): void;
    // (undocumented)
    append(other: ISegment): void;
    // (undocumented)
    attribution?: IAttributionCollection<AttributionKey>;
    // (undocumented)
    cachedLength: number;
    // (undocumented)
    canAppend(segment: ISegment): boolean;
    // (undocumented)
    abstract clone(): ISegment;
    // (undocumented)
    protected cloneInto(b: ISegment): void;
    // (undocumented)
    protected abstract createSplitSegmentAt(pos: number): BaseSegment | undefined;
    // (undocumented)
    hasProperty(key: string): boolean;
    // (undocumented)
    isLeaf(): this is ISegment;
    // (undocumented)
    properties?: PropertySet;
    // (undocumented)
    splitAt(pos: number): ISegment | undefined;
    // (undocumented)
    abstract toJSONObject(): any;
    // (undocumented)
    readonly trackingCollection: TrackingGroupCollection;
    // (undocumented)
    abstract readonly type: string;
}

// @beta @legacy (undocumented)
export function createOverlappingIntervalsIndex(sharedString: ISharedString): ISequenceOverlappingIntervalsIndex;

// @beta @legacy (undocumented)
export type DeserializeCallback = (properties: PropertySet) => void;

// @beta @legacy
export function discardSharedStringRevertibles(sharedString: ISharedString, revertibles: SharedStringRevertible[]): void;

// @beta @legacy
export interface IInterval {
    compare(b: IInterval): number;
    compareEnd(b: IInterval): number;
    compareStart(b: IInterval): number;
    // (undocumented)
    overlaps(b: IInterval): boolean;
}

// @beta @legacy
export interface InteriorSequencePlace {
    // (undocumented)
    pos: number;
    // (undocumented)
    side: Side;
}

// @beta @legacy
export const IntervalOpType: {
    readonly PROPERTY_CHANGED: "propertyChanged";
    readonly POSITION_REMOVE: "positionRemove";
    readonly ADD: "add";
    readonly DELETE: "delete";
    readonly CHANGE: "change";
};

// @beta @legacy (undocumented)
export type IntervalOpType = (typeof IntervalOpType)[keyof typeof IntervalOpType];

// @beta @legacy
export type IntervalRevertible = {
    event: typeof IntervalOpType.CHANGE;
    interval: SequenceInterval;
    start: LocalReferencePosition;
    end: LocalReferencePosition;
} | {
    event: typeof IntervalOpType.ADD;
    interval: SequenceInterval;
} | {
    event: typeof IntervalOpType.DELETE;
    interval: SequenceInterval;
    start: LocalReferencePosition;
    end: LocalReferencePosition;
} | {
    event: typeof IntervalOpType.PROPERTY_CHANGED;
    interval: SequenceInterval;
    propertyDeltas: PropertySet;
} | {
    event: typeof IntervalOpType.POSITION_REMOVE;
    intervals: {
        intervalId: string;
        label: string;
        startOffset?: number;
        endOffset?: number;
    }[];
    revertibleRefs: {
        revertible: IntervalRevertible;
        offset: number;
        isStart: boolean;
    }[];
    mergeTreeRevertible: MergeTreeDeltaRevertible;
};

// @beta @legacy
export const IntervalStickiness: {
    readonly NONE: 0;
    readonly START: 1;
    readonly END: 2;
    readonly FULL: 3;
};

// @beta @legacy
export type IntervalStickiness = (typeof IntervalStickiness)[keyof typeof IntervalStickiness];

// @beta @legacy (undocumented)
export enum IntervalType {
    // (undocumented)
    Simple = 0,
    SlideOnRemove = 2,// SlideOnRemove is default behavior - all intervals are SlideOnRemove
}

// @beta @legacy
export interface ISegment {
    // (undocumented)
    append(segment: ISegment): void;
    attribution?: IAttributionCollection<AttributionKey>;
    cachedLength: number;
    // (undocumented)
    canAppend(segment: ISegment): boolean;
    // (undocumented)
    clone(): ISegment;
    // (undocumented)
    isLeaf(): this is ISegment;
    properties?: PropertySet;
    // (undocumented)
    splitAt(pos: number): ISegment | undefined;
    // (undocumented)
    toJSONObject(): any;
    // (undocumented)
    readonly trackingCollection: TrackingGroupCollection;
    // (undocumented)
    readonly type: string;
}

// @beta @legacy
export interface ISequenceDeltaRange<TOperation extends MergeTreeDeltaOperationTypes = MergeTreeDeltaOperationTypes> {
    operation: TOperation;
    position: number;
    propertyDeltas: PropertySet;
    segment: ISegment;
}

// @beta @legacy
export interface ISequenceIntervalCollection extends TypedEventEmitter<ISequenceIntervalCollectionEvents> {
    // (undocumented)
    [Symbol.iterator](): Iterator<SequenceInterval>;
    add({ start, end, props, }: {
        start: SequencePlace;
        end: SequencePlace;
        props?: PropertySet;
    }): SequenceInterval;
    // @deprecated (undocumented)
    attachDeserializer(onDeserialize: DeserializeCallback): void;
    // (undocumented)
    readonly attached: boolean;
    attachIndex(index: SequenceIntervalIndex): void;
    change(id: string, { start, end, props }: {
        start?: SequencePlace;
        end?: SequencePlace;
        props?: PropertySet;
    }): SequenceInterval | undefined;
    // (undocumented)
    CreateBackwardIteratorWithEndPosition(endPosition: number): Iterator<SequenceInterval>;
    // (undocumented)
    CreateBackwardIteratorWithStartPosition(startPosition: number): Iterator<SequenceInterval>;
    // (undocumented)
    CreateForwardIteratorWithEndPosition(endPosition: number): Iterator<SequenceInterval>;
    // (undocumented)
    CreateForwardIteratorWithStartPosition(startPosition: number): Iterator<SequenceInterval>;
    detachIndex(index: SequenceIntervalIndex): boolean;
    // @deprecated (undocumented)
    findOverlappingIntervals(startPosition: number, endPosition: number): SequenceInterval[];
    gatherIterationResults(results: SequenceInterval[], iteratesForward: boolean, start?: number, end?: number): void;
    // (undocumented)
    getIntervalById(id: string): SequenceInterval | undefined;
    map(fn: (interval: SequenceInterval) => void): void;
    // @deprecated (undocumented)
    nextInterval(pos: number): SequenceInterval | undefined;
    // @deprecated (undocumented)
    previousInterval(pos: number): SequenceInterval | undefined;
    removeIntervalById(id: string): SequenceInterval | undefined;
}

// @beta @legacy
export interface ISequenceIntervalCollectionEvents extends IEvent {
    (event: "changeInterval", listener: (interval: SequenceInterval, previousInterval: SequenceInterval, local: boolean, op: ISequencedDocumentMessage | undefined, slide: boolean) => void): void;
    (event: "addInterval" | "deleteInterval", listener: (interval: SequenceInterval, local: boolean, op: ISequencedDocumentMessage | undefined) => void): void;
    (event: "propertyChanged", listener: (interval: SequenceInterval, propertyDeltas: PropertySet, local: boolean, op: ISequencedDocumentMessage | undefined) => void): void;
    (event: "changed", listener: (interval: SequenceInterval, propertyDeltas: PropertySet, previousInterval: SequenceInterval | undefined, local: boolean, slide: boolean) => void): void;
}

// @beta @legacy (undocumented)
export interface ISequenceOverlappingIntervalsIndex extends SequenceIntervalIndex {
    // (undocumented)
    findOverlappingIntervals(start: SequencePlace, end: SequencePlace): SequenceInterval[];
    gatherIterationResults(results: SequenceInterval[], iteratesForward: boolean, start?: SequencePlace, end?: SequencePlace): void;
}

// @beta @legacy
export interface ISerializedInterval {
    end: number | "start" | "end";
    // (undocumented)
    endSide?: Side;
    intervalType: IntervalType;
    properties?: PropertySet;
    sequenceNumber: number;
    start: number | "start" | "end";
    // (undocumented)
    startSide?: Side;
    stickiness?: IntervalStickiness;
}

// @beta @legacy (undocumented)
export interface ISharedSegmentSequence<T extends ISegment> extends ISharedObject<ISharedSegmentSequenceEvents>, MergeTreeRevertibleDriver {
    annotateAdjustRange(start: number, end: number, adjust: MapLike<AdjustParams>): void;
    annotateRange(start: number, end: number, props: PropertySet): void;
    createLocalReferencePosition(segment: T, offset: number, refType: ReferenceType, properties: PropertySet | undefined, slidingPreference?: SlidingPreference, canSlideToEndpoint?: boolean): LocalReferencePosition;
    getContainingSegment(pos: number): {
        segment: T | undefined;
        offset: number | undefined;
    };
    // (undocumented)
    getCurrentSeq(): number;
    getIntervalCollection(label: string): ISequenceIntervalCollection;
    // (undocumented)
    getIntervalCollectionLabels(): IterableIterator<string>;
    getLength(): number;
    getPosition(segment: ISegment): number;
    // (undocumented)
    getPropertiesAtPosition(pos: number): PropertySet | undefined;
    // (undocumented)
    getRangeExtentsOfPosition(pos: number): {
        posStart: number | undefined;
        posAfterEnd: number | undefined;
    };
    // @deprecated (undocumented)
    groupOperation(groupOp: IMergeTreeGroupMsg): void;
    initializeLocal(): void;
    insertAtReferencePosition(pos: ReferencePosition, segment: T): void;
    insertFromSpec(pos: number, spec: IJSONSegment): void;
    localReferencePositionToPosition(lref: ReferencePosition): number;
    obliterateRange(start: number | InteriorSequencePlace, end: number | InteriorSequencePlace): void;
    posFromRelativePos(relativePos: IRelativePosition): number;
    removeLocalReferencePosition(lref: LocalReferencePosition): LocalReferencePosition | undefined;
    // (undocumented)
    removeRange(start: number, end: number): void;
    resolveRemoteClientPosition(remoteClientPosition: number, remoteClientRefSeq: number, remoteClientId: string): number | undefined;
    walkSegments<TClientData>(handler: ISegmentAction<TClientData>, start?: number, end?: number, accum?: TClientData, splitRange?: boolean): void;
}

// @beta @legacy
export interface ISharedSegmentSequenceEvents extends ISharedObjectEvents {
    // (undocumented)
    (event: "createIntervalCollection", listener: (label: string, local: boolean, target: IEventThisPlaceHolder) => void): void;
    // (undocumented)
    (event: "sequenceDelta", listener: (event: SequenceDeltaEvent, target: IEventThisPlaceHolder) => void): void;
    // (undocumented)
    (event: "maintenance", listener: (event: SequenceMaintenanceEvent, target: IEventThisPlaceHolder) => void): void;
}

// @beta @legacy
export interface ISharedString extends ISharedSegmentSequence<SharedStringSegment> {
    annotateMarker(marker: Marker, props: PropertySet): void;
    getMarkerFromId(id: string): ISegment | undefined;
    getText(start?: number, end?: number): string;
    // (undocumented)
    getTextRangeWithMarkers(start: number, end: number): string;
    getTextWithPlaceholders(start?: number, end?: number): string;
    insertMarker(pos: number, refType: ReferenceType, props?: PropertySet): void;
    insertMarkerRelative(relativePos1: IRelativePosition, refType: ReferenceType, props?: PropertySet): void;
    insertText(pos: number, text: string, props?: PropertySet): void;
    insertTextRelative(relativePos1: IRelativePosition, text: string, props?: PropertySet): void;
    removeText(start: number, end: number): void;
    replaceText(start: number, end: number, text: string, props?: PropertySet): void;
    searchForMarker(startPos: number, markerLabel: string, forwards?: boolean): Marker | undefined;
}

// @beta @sealed @legacy (undocumented)
export interface LocalReferencePosition extends ReferencePosition {
    // (undocumented)
    addProperties(newProps: PropertySet): void;
    // (undocumented)
    callbacks?: Partial<Record<"beforeSlide" | "afterSlide", (ref: LocalReferencePosition) => void>>;
    readonly canSlideToEndpoint?: boolean;
    // (undocumented)
    readonly trackingCollection: TrackingGroupCollection;
}

// @beta @legacy
export interface MapLike<T> {
    // (undocumented)
    [index: string]: T;
}

// @beta @legacy
export class Marker extends BaseSegment implements ReferencePosition, ISegment {
    constructor(refType: ReferenceType, props?: PropertySet);
    // (undocumented)
    append(): void;
    // (undocumented)
    canAppend(segment: ISegment): boolean;
    // (undocumented)
    clone(): Marker;
    // (undocumented)
    protected createSplitSegmentAt(pos: number): undefined;
    // (undocumented)
    static fromJSONObject(spec: IJSONSegment): Marker | undefined;
    // (undocumented)
    getId(): string | undefined;
    // (undocumented)
    getOffset(): number;
    // (undocumented)
    getProperties(): PropertySet | undefined;
    // (undocumented)
    getSegment(): Marker;
    // (undocumented)
    static is(segment: ISegment): segment is Marker;
    // (undocumented)
    static make(refType: ReferenceType, props?: PropertySet): Marker;
    // (undocumented)
    refType: ReferenceType;
    // (undocumented)
    toJSONObject(): IJSONMarkerSegment;
    // (undocumented)
    toString(): string;
    // (undocumented)
    static readonly type = "Marker";
    // (undocumented)
    readonly type = "Marker";
}

// @beta @legacy (undocumented)
export const MergeTreeDeltaType: {
    readonly INSERT: 0;
    readonly REMOVE: 1;
    readonly ANNOTATE: 2;
    readonly GROUP: 3;
    readonly OBLITERATE: 4;
    readonly OBLITERATE_SIDED: 5;
};

// @beta @legacy (undocumented)
export type MergeTreeDeltaType = (typeof MergeTreeDeltaType)[keyof typeof MergeTreeDeltaType];

// @beta @legacy
export type PropertySet = MapLike<any>;

// @beta @legacy
export interface ReferencePosition {
    getOffset(): number;
    getSegment(): ISegment | undefined;
    // (undocumented)
    isLeaf(): this is ISegment;
    properties?: PropertySet;
    // (undocumented)
    refType: ReferenceType;
    slidingPreference?: SlidingPreference;
}

// @beta @legacy
export enum ReferenceType {
    RangeBegin = 16,
    RangeEnd = 32,
    // (undocumented)
    Simple = 0,
    SlideOnRemove = 64,
    StayOnRemove = 128,
    Tile = 1,
    Transient = 256
}

// @beta @legacy
export const reservedMarkerIdKey = "markerId";

// @beta @legacy
export function revertSharedStringRevertibles(sharedString: ISharedString, revertibles: SharedStringRevertible[]): void;

// @beta @legacy
export interface SequenceDeltaEvent extends SequenceEvent<MergeTreeDeltaOperationType> {
    readonly isLocal: boolean;
    // (undocumented)
    readonly opArgs: IMergeTreeDeltaOpArgs;
}

// @beta @legacy
export interface SequenceEvent<TOperation extends MergeTreeDeltaOperationTypes = MergeTreeDeltaOperationTypes> {
    readonly clientId: string | undefined;
    // (undocumented)
    readonly deltaArgs: IMergeTreeDeltaCallbackArgs<TOperation>;
    // (undocumented)
    readonly deltaOperation: TOperation;
    readonly first: Readonly<ISequenceDeltaRange<TOperation>>;
    readonly last: Readonly<ISequenceDeltaRange<TOperation>>;
    readonly ranges: readonly Readonly<ISequenceDeltaRange<TOperation>>[];
}

// @beta @legacy
export interface SequenceInterval extends IInterval {
    compare(b: SequenceInterval): number;
    compareEnd(b: SequenceInterval): number;
    compareStart(b: SequenceInterval): number;
    readonly end: LocalReferencePosition;
    // (undocumented)
    readonly endSide: Side;
    getIntervalId(): string;
    // (undocumented)
    readonly intervalType: IntervalType;
    // (undocumented)
    overlaps(b: SequenceInterval): boolean;
    // (undocumented)
    overlapsPos(bstart: number, bend: number): boolean;
    properties: PropertySet;
    // (undocumented)
    readonly start: LocalReferencePosition;
    // (undocumented)
    readonly startSide: Side;
    // (undocumented)
    readonly stickiness: IntervalStickiness;
}

// @beta @legacy
export interface SequenceIntervalIndex {
    add(interval: SequenceInterval): void;
    remove(interval: SequenceInterval): void;
}

// @beta @legacy
export interface SequenceMaintenanceEvent extends SequenceEvent<MergeTreeMaintenanceType> {
    // (undocumented)
    readonly opArgs: IMergeTreeDeltaOpArgs | undefined;
}

// @beta @legacy
export type SequencePlace = number | "start" | "end" | InteriorSequencePlace;

// @beta @legacy
export const SharedString: ISharedObjectKind<ISharedString> & SharedObjectKind<ISharedString>;

// @beta @legacy
export type SharedString = ISharedString;

// @beta @legacy
export type SharedStringRevertible = MergeTreeDeltaRevertible | IntervalRevertible;

// @beta @legacy (undocumented)
export type SharedStringSegment = TextSegment | Marker;

// @beta @legacy
export enum Side {
    // (undocumented)
    After = 1,
    // (undocumented)
    Before = 0
}

// @beta @legacy (undocumented)
export class TextSegment extends BaseSegment {
    constructor(text: string, props?: PropertySet);
    // (undocumented)
    append(segment: ISegment): void;
    // (undocumented)
    canAppend(segment: ISegment): boolean;
    // (undocumented)
    clone(start?: number, end?: number): TextSegment;
    // (undocumented)
    protected createSplitSegmentAt(pos: number): TextSegment | undefined;
    // (undocumented)
    static fromJSONObject(spec: string | IJSONSegment): TextSegment | undefined;
    // (undocumented)
    static is(segment: ISegment): segment is TextSegment;
    // (undocumented)
    static make(text: string, props?: PropertySet): TextSegment;
    // (undocumented)
    text: string;
    // (undocumented)
    toJSONObject(): IJSONTextSegment | string;
    // (undocumented)
    toString(): string;
    // (undocumented)
    static readonly type = "TextSegment";
    // (undocumented)
    readonly type = "TextSegment";
}

// @beta @legacy (undocumented)
export class TrackingGroup implements ITrackingGroup {
    constructor();
    // (undocumented)
    has(trackable: Trackable): boolean;
    // (undocumented)
    link(trackable: Trackable): void;
    // (undocumented)
    get size(): number;
    // (undocumented)
    get tracked(): readonly Trackable[];
    // (undocumented)
    unlink(trackable: Trackable): boolean;
}

```
