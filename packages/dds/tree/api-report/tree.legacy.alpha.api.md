## Alpha API Report File for "@fluidframework/tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type AllowedTypes = readonly LazyItem<TreeNodeSchema>[];

// @public
type AllowedTypesUnsafe = readonly LazyItem<TreeNodeSchemaUnsafe>[];

// @public
type ApplyKind<T, Kind extends FieldKind> = {
    [FieldKind.Required]: T;
    [FieldKind.Optional]: T | undefined;
    [FieldKind.Identifier]: T;
}[Kind];

// @public
type ApplyKindInput<T, Kind extends FieldKind, DefaultsAreOptional extends boolean> = [
Kind
] extends [FieldKind.Required] ? T : [Kind] extends [FieldKind.Optional] ? T | undefined : [Kind] extends [FieldKind.Identifier] ? DefaultsAreOptional extends true ? T | undefined : T : never;

// @public
export enum CommitKind {
    Default = 0,
    Redo = 2,
    Undo = 1
}

// @public @sealed
export interface CommitMetadata {
    readonly isLocal: boolean;
    readonly kind: CommitKind;
}

// @public @sealed
interface DefaultProvider extends ErasedType<"@fluidframework/tree.FieldProvider"> {
}

// @public
type ExtractItemType<Item extends LazyItem> = Item extends () => infer Result ? Result : Item;

// @public
type FieldHasDefault<T extends ImplicitFieldSchema> = T extends FieldSchema<FieldKind.Optional | FieldKind.Identifier> ? true : false;

// @public @sealed
type FieldHasDefaultUnsafe<T extends Unenforced<ImplicitFieldSchema>> = T extends FieldSchemaUnsafe<FieldKind.Optional | FieldKind.Identifier, Unenforced<ImplicitAllowedTypes>> ? true : false;

// @public
export enum FieldKind {
    Identifier = 2,
    Optional = 0,
    Required = 1
}

// @public
export interface FieldProps<TCustomMetadata = unknown> {
    readonly defaultProvider?: DefaultProvider;
    readonly key?: string;
    readonly metadata?: FieldSchemaMetadata<TCustomMetadata>;
}

// @public @sealed
export class FieldSchema<out Kind extends FieldKind = FieldKind, out Types extends ImplicitAllowedTypes = ImplicitAllowedTypes, out TCustomMetadata = unknown> {
    readonly allowedTypes: Types;
    get allowedTypeSet(): ReadonlySet<TreeNodeSchema>;
    readonly kind: Kind;
    get metadata(): FieldSchemaMetadata<TCustomMetadata> | undefined;
    readonly props?: FieldProps<TCustomMetadata> | undefined;
    readonly requiresValue: boolean;
    protected _typeCheck: MakeNominal;
}

// @public @sealed
export interface FieldSchemaMetadata<TCustomMetadata = unknown> {
    readonly custom?: TCustomMetadata;
    readonly description?: string | undefined;
}

// @public
export interface FieldSchemaUnsafe<out Kind extends FieldKind, out Types extends Unenforced<ImplicitAllowedTypes>> extends FieldSchema<Kind, any> {
    readonly allowedTypes: Types;
    readonly allowedTypeSet: ReadonlySet<TreeNodeSchema>;
    readonly kind: Kind;
}

// @public
type FlattenKeys<T> = [{
    [Property in keyof T]: T[Property];
}][_InlineTrick];

// @public
type FlexList<Item = unknown> = readonly LazyItem<Item>[];

// @public
type FlexListToUnion<TList extends FlexList> = ExtractItemType<TList[number]>;

// @public
export type ImplicitAllowedTypes = AllowedTypes | TreeNodeSchema;

// @public
export type ImplicitFieldSchema = FieldSchema | ImplicitAllowedTypes;

// @public
type _InlineTrick = 0;

// @public
export type Input<T extends never> = T;

// @public
type InsertableObjectFromSchemaRecord<T extends RestrictiveStringRecord<ImplicitFieldSchema>> = Record<string, never> extends T ? Record<string, never> : FlattenKeys<{
    readonly [Property in keyof T]?: InsertableTreeFieldFromImplicitField<T[Property & string]>;
} & {
    readonly [Property in keyof T as FieldHasDefault<T[Property & string]> extends false ? Property : never]: InsertableTreeFieldFromImplicitField<T[Property & string]>;
}>;

// @public
export type InsertableObjectFromSchemaRecordUnsafe<T extends Unenforced<RestrictiveStringRecord<ImplicitFieldSchema>>> = {
    readonly [Property in keyof T as FieldHasDefaultUnsafe<T[Property]> extends false ? Property : never]: InsertableTreeFieldFromImplicitFieldUnsafe<T[Property]>;
} & {
    readonly [Property in keyof T as FieldHasDefaultUnsafe<T[Property]> extends true ? Property : never]?: InsertableTreeFieldFromImplicitFieldUnsafe<T[Property]>;
};

// @public
export type InsertableTreeFieldFromImplicitField<TSchemaInput extends ImplicitFieldSchema, TSchema = UnionToIntersection<TSchemaInput>> = [TSchema] extends [FieldSchema<infer Kind, infer Types>] ? ApplyKindInput<InsertableTreeNodeFromImplicitAllowedTypes<Types>, Kind, true> : [TSchema] extends [ImplicitAllowedTypes] ? InsertableTreeNodeFromImplicitAllowedTypes<TSchema> : never;

// @public
export type InsertableTreeFieldFromImplicitFieldUnsafe<TSchemaInput extends Unenforced<ImplicitFieldSchema>, TSchema = UnionToIntersection<TSchemaInput>> = [TSchema] extends [FieldSchemaUnsafe<infer Kind, infer Types>] ? ApplyKindInput<InsertableTreeNodeFromImplicitAllowedTypesUnsafe<Types>, Kind, true> : [TSchema] extends [ImplicitAllowedTypes] ? InsertableTreeNodeFromImplicitAllowedTypesUnsafe<TSchema> : never;

// @public
export type InsertableTreeNodeFromAllowedTypes<TList extends AllowedTypes> = TList extends readonly [
LazyItem<infer TSchema extends TreeNodeSchema>,
...infer Rest extends AllowedTypes
] ? InsertableTypedNode<TSchema> | InsertableTreeNodeFromAllowedTypes<Rest> : never;

// @public
export type InsertableTreeNodeFromAllowedTypesUnsafe<TList extends Unenforced<AllowedTypesUnsafe>> = TList extends readonly [
LazyItem<infer TSchema extends TreeNodeSchemaUnsafe>,
...infer Rest extends AllowedTypesUnsafe
] ? InsertableTypedNodeUnsafe<TSchema> | InsertableTreeNodeFromAllowedTypesUnsafe<Rest> : never;

// @public
export type InsertableTreeNodeFromImplicitAllowedTypes<TSchema extends ImplicitAllowedTypes> = [
TSchema
] extends [TreeNodeSchema] ? InsertableTypedNode<TSchema> : [TSchema] extends [AllowedTypes] ? InsertableTreeNodeFromAllowedTypes<TSchema> : never;

// @public
export type InsertableTreeNodeFromImplicitAllowedTypesUnsafe<TSchema extends Unenforced<ImplicitAllowedTypes>> = [TSchema] extends [TreeNodeSchemaUnsafe] ? InsertableTypedNodeUnsafe<TSchema> : [TSchema] extends [AllowedTypesUnsafe] ? InsertableTreeNodeFromAllowedTypesUnsafe<TSchema> : never;

// @public
export type InsertableTypedNode<TSchema extends TreeNodeSchema, T = UnionToIntersection<TSchema>> = (T extends TreeNodeSchema<string, NodeKind, TreeNode | TreeLeafValue, never, true> ? NodeBuilderData<T> : never) | (T extends TreeNodeSchema ? Unhydrated<TreeNode extends NodeFromSchema<T> ? never : NodeFromSchema<T>> : never);

// @public
type InsertableTypedNodeUnsafe<TSchema extends Unenforced<TreeNodeSchemaUnsafe>, T = UnionToIntersection<TSchema>> = (T extends TreeNodeSchemaUnsafe<string, NodeKind, TreeNode | TreeLeafValue, never, true> ? NodeBuilderDataUnsafe<T> : never) | (T extends TreeNodeSchemaUnsafe ? NodeFromSchemaUnsafe<T> : never);

// @public @sealed
export interface InternalTreeNode extends ErasedType<"@fluidframework/tree.InternalTreeNode"> {
}

declare namespace InternalTypes {
    export {
        _InlineTrick,
        FlattenKeys,
        ApplyKind,
        ApplyKindInput,
        NodeBuilderData,
        FieldHasDefault,
        ScopedSchemaName,
        DefaultProvider,
        typeNameSymbol,
        InsertableObjectFromSchemaRecord,
        ObjectFromSchemaRecord,
        FieldHasDefaultUnsafe,
        ObjectFromSchemaRecordUnsafe,
        TreeObjectNodeUnsafe,
        TreeFieldFromImplicitFieldUnsafe,
        TreeNodeFromImplicitAllowedTypesUnsafe,
        InsertableTreeNodeFromImplicitAllowedTypesUnsafe,
        TreeArrayNodeUnsafe,
        TreeMapNodeUnsafe,
        InsertableObjectFromSchemaRecordUnsafe,
        InsertableTreeFieldFromImplicitFieldUnsafe,
        InsertableTypedNodeUnsafe,
        NodeBuilderDataUnsafe,
        NodeFromSchemaUnsafe,
        ReadonlyMapInlined,
        TreeNodeSchemaUnsafe,
        AllowedTypesUnsafe,
        TreeNodeSchemaNonClassUnsafe,
        FlexList,
        FlexListToUnion,
        ExtractItemType,
        TreeApi
    }
}
export { InternalTypes }

export { IsListener }

// @public @sealed
export class IterableTreeArrayContent<T> implements Iterable<T> {
    [Symbol.iterator](): Iterator<T>;
}

// @public @sealed
export interface ITree extends ViewableTree, IFluidLoadable {
}

// @public
export interface ITreeConfigurationOptions {
    enableSchemaValidation?: boolean;
    readonly preventAmbiguity?: boolean;
}

// @public
export interface ITreeViewConfiguration<TSchema extends ImplicitFieldSchema = ImplicitFieldSchema> extends ITreeConfigurationOptions {
    readonly schema: TSchema;
}

// @public
export type LazyItem<Item = unknown> = Item | (() => Item);

export { Listenable }

export { Listeners }

// @public @sealed
export interface MakeNominal {
}

// @public
export type MapNodeInsertableData<T extends ImplicitAllowedTypes> = Iterable<readonly [string, InsertableTreeNodeFromImplicitAllowedTypes<T>]> | RestrictiveStringRecord<InsertableTreeNodeFromImplicitAllowedTypes<T>>;

// @public
type NodeBuilderData<T extends TreeNodeSchemaCore<string, NodeKind, boolean>> = T extends TreeNodeSchemaCore<string, NodeKind, boolean, unknown, infer TBuild> ? TBuild : never;

// @public
type NodeBuilderDataUnsafe<T extends Unenforced<TreeNodeSchema>> = T extends TreeNodeSchemaUnsafe<string, NodeKind, unknown, infer TBuild> ? TBuild : never;

// @public
export type NodeFromSchema<T extends TreeNodeSchema> = T extends TreeNodeSchemaClass<string, NodeKind, infer TNode> ? TNode : T extends TreeNodeSchemaNonClass<string, NodeKind, infer TNode> ? TNode : never;

// @public
type NodeFromSchemaUnsafe<T extends Unenforced<TreeNodeSchema>> = T extends TreeNodeSchemaUnsafe<string, NodeKind, infer TNode> ? TNode : never;

// @public
export interface NodeInDocumentConstraint {
    // (undocumented)
    readonly node: TreeNode;
    // (undocumented)
    readonly type: "nodeInDocument";
}

// @public
export enum NodeKind {
    Array = 1,
    Leaf = 3,
    Map = 0,
    Object = 2
}

// @public
type ObjectFromSchemaRecord<T extends RestrictiveStringRecord<ImplicitFieldSchema>> = {
    -readonly [Property in keyof T]: Property extends string ? TreeFieldFromImplicitField<T[Property]> : unknown;
};

// @public
type ObjectFromSchemaRecordUnsafe<T extends Unenforced<RestrictiveStringRecord<ImplicitFieldSchema>>> = {
    -readonly [Property in keyof T]: TreeFieldFromImplicitFieldUnsafe<T[Property]>;
};

export { Off }

// @public @sealed
export interface ReadonlyArrayNode<out T = TreeNode | TreeLeafValue> extends ReadonlyArray<T>, Awaited<TreeNode & WithType<string, NodeKind.Array>> {
}

// @public @sealed
interface ReadonlyMapInlined<K, T extends Unenforced<ImplicitAllowedTypes>> {
    [Symbol.iterator](): IterableIterator<[K, TreeNodeFromImplicitAllowedTypesUnsafe<T>]>;
    entries(): IterableIterator<[K, TreeNodeFromImplicitAllowedTypesUnsafe<T>]>;
    // (undocumented)
    forEach(callbackfn: (value: TreeNodeFromImplicitAllowedTypesUnsafe<T>, key: K, map: ReadonlyMap<K, TreeNodeFromImplicitAllowedTypesUnsafe<T>>) => void, thisArg?: any): void;
    // (undocumented)
    get(key: K): TreeNodeFromImplicitAllowedTypesUnsafe<T> | undefined;
    // (undocumented)
    has(key: K): boolean;
    keys(): IterableIterator<K>;
    // (undocumented)
    readonly size: number;
    values(): IterableIterator<TreeNodeFromImplicitAllowedTypesUnsafe<T>>;
}

// @public @deprecated
export type RestrictiveReadonlyRecord<K extends symbol | string, T> = {
    readonly [P in symbol | string]: P extends K ? T : never;
};

// @public
export type RestrictiveStringRecord<T> = {
    readonly [P in string]: T;
} & {
    readonly [P in symbol]?: never;
};

// @public @sealed
export interface Revertible {
    dispose(): void;
    revert(): void;
    revert(dispose: boolean): void;
    readonly status: RevertibleStatus;
}

// @public @sealed
export type RevertibleFactory = (onRevertibleDisposed?: (revertible: Revertible) => void) => Revertible;

// @public
export enum RevertibleStatus {
    Disposed = 1,
    Valid = 0
}

// @public
export const rollback: unique symbol;

// @public @sealed
export interface RunTransaction {
    <TNode extends TreeNode, TResult>(node: TNode, transaction: (node: TNode) => TResult): TResult;
    <TView extends TreeView<any>, TResult>(tree: TView, transaction: (root: TView["root"]) => TResult): TResult;
    <TNode extends TreeNode, TResult>(node: TNode, transaction: (node: TNode) => TResult | typeof rollback): TResult | typeof rollback;
    <TView extends TreeView<any>, TResult>(tree: TView, transaction: (root: TView["root"]) => TResult | typeof rollback): TResult | typeof rollback;
    <TNode extends TreeNode>(node: TNode, transaction: (node: TNode) => void): void;
    <TView extends TreeView<any>>(tree: TView, transaction: (root: TView["root"]) => void): void;
    <TNode extends TreeNode, TResult>(node: TNode, transaction: (node: TNode) => TResult, preconditions?: readonly TransactionConstraint[]): TResult;
    <TView extends TreeView<any>, TResult>(tree: TView, transaction: (root: TView["root"]) => TResult, preconditions?: readonly TransactionConstraint[]): TResult;
    <TNode extends TreeNode, TResult>(node: TNode, transaction: (node: TNode) => TResult | typeof rollback, preconditions?: readonly TransactionConstraint[]): TResult | typeof rollback;
    <TView extends TreeView<any>, TResult>(tree: TView, transaction: (root: TView["root"]) => TResult | typeof rollback, preconditions?: readonly TransactionConstraint[]): TResult | typeof rollback;
    <TNode extends TreeNode>(node: TNode, transaction: (node: TNode) => void, preconditions?: readonly TransactionConstraint[]): void;
    <TView extends TreeView<any>>(tree: TView, transaction: (root: TView["root"]) => void, preconditions?: readonly TransactionConstraint[]): void;
    readonly rollback: typeof rollback;
}

// @public @sealed
export interface SchemaCompatibilityStatus {
    readonly canInitialize: boolean;
    readonly canUpgrade: boolean;
    readonly canView: boolean;
    readonly isEquivalent: boolean;
}

// @public @sealed
export class SchemaFactory<out TScope extends string | undefined = string | undefined, TName extends number | string = string> {
    constructor(
    scope: TScope);
    array<const T extends TreeNodeSchema | readonly TreeNodeSchema[]>(allowedTypes: T): TreeNodeSchemaNonClass<ScopedSchemaName<TScope, `Array<${string}>`>, NodeKind.Array, TreeArrayNode<T> & WithType<ScopedSchemaName<TScope, `Array<${string}>`>, NodeKind.Array>, Iterable<InsertableTreeNodeFromImplicitAllowedTypes<T>>, true, T, undefined>;
    array<const Name extends TName, const T extends ImplicitAllowedTypes>(name: Name, allowedTypes: T): TreeNodeSchemaClass<ScopedSchemaName<TScope, Name>, NodeKind.Array, TreeArrayNode<T> & WithType<ScopedSchemaName<TScope, Name>, NodeKind.Array>, Iterable<InsertableTreeNodeFromImplicitAllowedTypes<T>>, true, T, undefined>;
    arrayRecursive<const Name extends TName, const T extends Unenforced<ImplicitAllowedTypes>>(name: Name, allowedTypes: T): TreeNodeSchemaClass<ScopedSchemaName<TScope, Name>, NodeKind.Array, TreeArrayNodeUnsafe<T> & WithType<ScopedSchemaName<TScope, Name>, NodeKind.Array, unknown>, {
        [Symbol.iterator](): Iterator<InsertableTreeNodeFromImplicitAllowedTypesUnsafe<T>>;
    }, false, T, undefined>;
    readonly boolean: TreeNodeSchemaNonClass<"com.fluidframework.leaf.boolean", NodeKind.Leaf, boolean, boolean, true, unknown, never>;
    readonly handle: TreeNodeSchemaNonClass<"com.fluidframework.leaf.handle", NodeKind.Leaf, IFluidHandle<unknown>, IFluidHandle<unknown>, true, unknown, never>;
    get identifier(): FieldSchema<FieldKind.Identifier, typeof SchemaFactory.string>;
    map<const T extends TreeNodeSchema | readonly TreeNodeSchema[]>(allowedTypes: T): TreeNodeSchemaNonClass<ScopedSchemaName<TScope, `Map<${string}>`>, NodeKind.Map, TreeMapNode<T> & WithType<ScopedSchemaName<TScope, `Map<${string}>`>, NodeKind.Map>, MapNodeInsertableData<T>, true, T, undefined>;
    map<Name extends TName, const T extends ImplicitAllowedTypes>(name: Name, allowedTypes: T): TreeNodeSchemaClass<ScopedSchemaName<TScope, Name>, NodeKind.Map, TreeMapNode<T> & WithType<ScopedSchemaName<TScope, Name>, NodeKind.Map>, MapNodeInsertableData<T>, true, T, undefined>;
    mapRecursive<Name extends TName, const T extends Unenforced<ImplicitAllowedTypes>>(name: Name, allowedTypes: T): TreeNodeSchemaClass<ScopedSchemaName<TScope, Name>, NodeKind.Map, TreeMapNodeUnsafe<T> & WithType<ScopedSchemaName<TScope, Name>, NodeKind.Map, unknown>, {
        [Symbol.iterator](): Iterator<[
        string,
        InsertableTreeNodeFromImplicitAllowedTypesUnsafe<T>
        ]>;
    } | {
        readonly [x: string]: InsertableTreeNodeFromImplicitAllowedTypesUnsafe<T>;
    }, false, T, undefined>;
    readonly null: TreeNodeSchemaNonClass<"com.fluidframework.leaf.null", NodeKind.Leaf, null, null, true, unknown, never>;
    readonly number: TreeNodeSchemaNonClass<"com.fluidframework.leaf.number", NodeKind.Leaf, number, number, true, unknown, never>;
    object<const Name extends TName, const T extends RestrictiveStringRecord<ImplicitFieldSchema>>(name: Name, fields: T): TreeNodeSchemaClass<ScopedSchemaName<TScope, Name>, NodeKind.Object, TreeObjectNode<T, ScopedSchemaName<TScope, Name>>, object & InsertableObjectFromSchemaRecord<T>, true, T>;
    objectRecursive<const Name extends TName, const T extends Unenforced<RestrictiveStringRecord<ImplicitFieldSchema>>>(name: Name, t: T): TreeNodeSchemaClass<ScopedSchemaName<TScope, Name>, NodeKind.Object, TreeObjectNodeUnsafe<T, ScopedSchemaName<TScope, Name>>, object & InsertableObjectFromSchemaRecordUnsafe<T>, false, T>;
    optional<const T extends ImplicitAllowedTypes, const TCustomMetadata = unknown>(t: T, props?: Omit<FieldProps<TCustomMetadata>, "defaultProvider">): FieldSchema<FieldKind.Optional, T, TCustomMetadata>;
    optionalRecursive<const T extends Unenforced<ImplicitAllowedTypes>>(t: T, props?: Omit<FieldProps, "defaultProvider">): FieldSchemaUnsafe<FieldKind.Optional, T>;
    required<const T extends ImplicitAllowedTypes, const TCustomMetadata = unknown>(t: T, props?: Omit<FieldProps<TCustomMetadata>, "defaultProvider">): FieldSchema<FieldKind.Required, T, TCustomMetadata>;
    requiredRecursive<const T extends Unenforced<ImplicitAllowedTypes>>(t: T, props?: Omit<FieldProps, "defaultProvider">): FieldSchemaUnsafe<FieldKind.Required, T>;
    readonly scope: TScope;
    readonly string: TreeNodeSchemaNonClass<"com.fluidframework.leaf.string", NodeKind.Leaf, string, string, true, unknown, never>;
}

// @public
type ScopedSchemaName<TScope extends string | undefined, TName extends number | string> = TScope extends undefined ? `${TName}` : `${TScope}.${TName}`;

// @alpha
export const SharedTree: ISharedObjectKind<ITree> & SharedObjectKind<ITree>;

// @public
export type TransactionConstraint = NodeInDocumentConstraint;

// @public
export const Tree: TreeApi;

// @public @sealed
interface TreeApi extends TreeNodeApi {
    contains(node: TreeNode, other: TreeNode): boolean;
    readonly runTransaction: RunTransaction;
}

// @public @sealed
export interface TreeArrayNode<TAllowedTypes extends Unenforced<ImplicitAllowedTypes> = ImplicitAllowedTypes, out T = [TAllowedTypes] extends [ImplicitAllowedTypes] ? TreeNodeFromImplicitAllowedTypes<TAllowedTypes> : TreeNodeFromImplicitAllowedTypes<ImplicitAllowedTypes>, in TNew = [TAllowedTypes] extends [ImplicitAllowedTypes] ? InsertableTreeNodeFromImplicitAllowedTypes<TAllowedTypes> : InsertableTreeNodeFromImplicitAllowedTypes<ImplicitAllowedTypes>, in TMoveFrom = ReadonlyArrayNode> extends ReadonlyArrayNode<T> {
    insertAt(index: number, ...value: readonly (TNew | IterableTreeArrayContent<TNew>)[]): void;
    insertAtEnd(...value: readonly (TNew | IterableTreeArrayContent<TNew>)[]): void;
    insertAtStart(...value: readonly (TNew | IterableTreeArrayContent<TNew>)[]): void;
    moveRangeToEnd(sourceStart: number, sourceEnd: number): void;
    moveRangeToEnd(sourceStart: number, sourceEnd: number, source: TMoveFrom): void;
    moveRangeToIndex(destinationGap: number, sourceStart: number, sourceEnd: number): void;
    moveRangeToIndex(destinationGap: number, sourceStart: number, sourceEnd: number, source: TMoveFrom): void;
    moveRangeToStart(sourceStart: number, sourceEnd: number): void;
    moveRangeToStart(sourceStart: number, sourceEnd: number, source: TMoveFrom): void;
    moveToEnd(sourceIndex: number): void;
    moveToEnd(sourceIndex: number, source: TMoveFrom): void;
    moveToIndex(destinationGap: number, sourceIndex: number): void;
    moveToIndex(destinationGap: number, sourceIndex: number, source: TMoveFrom): void;
    moveToStart(sourceIndex: number): void;
    moveToStart(sourceIndex: number, source: TMoveFrom): void;
    removeAt(index: number): void;
    removeRange(start?: number, end?: number): void;
    values(): IterableIterator<T>;
}

// @public
export const TreeArrayNode: {
    readonly spread: <T>(content: Iterable<T>) => IterableTreeArrayContent<T>;
};

// @public @sealed
export interface TreeArrayNodeUnsafe<TAllowedTypes extends Unenforced<ImplicitAllowedTypes>> extends TreeArrayNode<TAllowedTypes, TreeNodeFromImplicitAllowedTypesUnsafe<TAllowedTypes>, InsertableTreeNodeFromImplicitAllowedTypesUnsafe<TAllowedTypes>> {
}

// @public @sealed
export interface TreeChangeEvents {
    nodeChanged(unstable?: unknown): void;
    treeChanged(): void;
}

// @public
export type TreeFieldFromImplicitField<TSchema extends ImplicitFieldSchema = FieldSchema> = TSchema extends FieldSchema<infer Kind, infer Types> ? ApplyKind<TreeNodeFromImplicitAllowedTypes<Types>, Kind> : TSchema extends ImplicitAllowedTypes ? TreeNodeFromImplicitAllowedTypes<TSchema> : TreeNode | TreeLeafValue | undefined;

// @public
type TreeFieldFromImplicitFieldUnsafe<TSchema extends Unenforced<ImplicitFieldSchema>> = TSchema extends FieldSchemaUnsafe<infer Kind, infer Types> ? ApplyKind<TreeNodeFromImplicitAllowedTypesUnsafe<Types>, Kind> : TSchema extends ImplicitAllowedTypes ? TreeNodeFromImplicitAllowedTypesUnsafe<TSchema> : unknown;

// @public
export type TreeLeafValue = number | string | boolean | IFluidHandle | null;

// @public @sealed
export interface TreeMapNode<T extends ImplicitAllowedTypes = ImplicitAllowedTypes> extends ReadonlyMap<string, TreeNodeFromImplicitAllowedTypes<T>>, TreeNode {
    delete(key: string): void;
    entries(): IterableIterator<[string, TreeNodeFromImplicitAllowedTypes<T>]>;
    forEach(callbackfn: (value: TreeNodeFromImplicitAllowedTypes<T>, key: string, map: ReadonlyMap<string, TreeNodeFromImplicitAllowedTypes<T>>) => void, thisArg?: any): void;
    keys(): IterableIterator<string>;
    set(key: string, value: InsertableTreeNodeFromImplicitAllowedTypes<T> | undefined): void;
    values(): IterableIterator<TreeNodeFromImplicitAllowedTypes<T>>;
}

// @public @sealed
export interface TreeMapNodeUnsafe<T extends Unenforced<ImplicitAllowedTypes>> extends ReadonlyMapInlined<string, T>, TreeNode {
    delete(key: string): void;
    set(key: string, value: InsertableTreeNodeFromImplicitAllowedTypesUnsafe<T> | undefined): void;
}

// @public @sealed
export abstract class TreeNode implements WithType {
    static [Symbol.hasInstance](value: unknown): value is TreeNode;
    static [Symbol.hasInstance]<TSchema extends abstract new (...args: any[]) => TreeNode>(this: TSchema, value: unknown): value is InstanceType<TSchema>;
    // @deprecated
    abstract get [typeNameSymbol](): string;
    abstract get [typeSchemaSymbol](): TreeNodeSchemaClass;
    protected constructor(token: unknown);
}

// @public @sealed
export interface TreeNodeApi {
    is<TSchema extends ImplicitAllowedTypes>(value: unknown, schema: TSchema): value is TreeNodeFromImplicitAllowedTypes<TSchema>;
    key(node: TreeNode): string | number;
    on<K extends keyof TreeChangeEvents>(node: TreeNode, eventName: K, listener: TreeChangeEvents[K]): () => void;
    parent(node: TreeNode): TreeNode | undefined;
    schema(node: TreeNode | TreeLeafValue): TreeNodeSchema;
    shortId(node: TreeNode): number | string | undefined;
    status(node: TreeNode): TreeStatus;
}

// @public
export type TreeNodeFromImplicitAllowedTypes<TSchema extends ImplicitAllowedTypes = TreeNodeSchema> = TSchema extends TreeNodeSchema ? NodeFromSchema<TSchema> : TSchema extends AllowedTypes ? NodeFromSchema<FlexListToUnion<TSchema>> : unknown;

// @public
type TreeNodeFromImplicitAllowedTypesUnsafe<TSchema extends Unenforced<ImplicitAllowedTypes>> = TSchema extends TreeNodeSchemaUnsafe ? NodeFromSchemaUnsafe<TSchema> : TSchema extends AllowedTypesUnsafe ? NodeFromSchemaUnsafe<FlexListToUnion<TSchema>> : unknown;

// @public @sealed
export type TreeNodeSchema<Name extends string = string, Kind extends NodeKind = NodeKind, TNode extends TreeNode | TreeLeafValue = TreeNode | TreeLeafValue, TBuild = never, ImplicitlyConstructable extends boolean = boolean, Info = unknown> = (TNode extends TreeNode ? TreeNodeSchemaClass<Name, Kind, TNode, TBuild, ImplicitlyConstructable, Info> : never) | TreeNodeSchemaNonClass<Name, Kind, TNode, TBuild, ImplicitlyConstructable, Info>;

// @public @sealed
export type TreeNodeSchemaClass<Name extends string = string, Kind extends NodeKind = NodeKind, TNode extends TreeNode = TreeNode, TInsertable = never, ImplicitlyConstructable extends boolean = boolean, Info = unknown, TConstructorExtra = never> = TreeNodeSchemaCore<Name, Kind, ImplicitlyConstructable, Info, TInsertable> & (undefined extends TConstructorExtra ? {
    new (data?: TInsertable | InternalTreeNode | TConstructorExtra): Unhydrated<TNode>;
} : {
    new (data: TInsertable | InternalTreeNode | TConstructorExtra): Unhydrated<TNode>;
});

// @public
export interface TreeNodeSchemaClassUnsafe<out Name extends string, out Kind extends NodeKind, out TNode extends Unenforced<TreeNode>, in TInsertable, out ImplicitlyConstructable extends boolean, out Info> extends TreeNodeSchemaCore<Name, Kind, ImplicitlyConstructable, Info> {
    // @sealed
    new (data: TInsertable | InternalTreeNode): Unhydrated<TNode>;
}

// @public @sealed
export interface TreeNodeSchemaCore<out Name extends string, out Kind extends NodeKind, out ImplicitlyConstructable extends boolean, out Info = unknown, out TInsertable = never> {
    readonly childTypes: ReadonlySet<TreeNodeSchema>;
    // @sealed
    createFromInsertable(data: TInsertable): Unhydrated<TreeNode | TreeLeafValue>;
    readonly identifier: Name;
    readonly implicitlyConstructable: ImplicitlyConstructable;
    readonly info: Info;
    // (undocumented)
    readonly kind: Kind;
}

// @public @sealed
export type TreeNodeSchemaNonClass<Name extends string = string, Kind extends NodeKind = NodeKind, TNode extends TreeNode | TreeLeafValue = TreeNode | TreeLeafValue, TInsertable = never, ImplicitlyConstructable extends boolean = boolean, Info = unknown, TConstructorExtra = never> = TreeNodeSchemaCore<Name, Kind, ImplicitlyConstructable, Info, TInsertable> & (undefined extends TConstructorExtra ? {
    create(data?: TInsertable | TConstructorExtra): TNode;
} : {
    create(data: TInsertable | TConstructorExtra): TNode;
});

// @public
interface TreeNodeSchemaNonClassUnsafe<out Name extends string, out Kind extends NodeKind, out TNode extends Unenforced<TreeNode | TreeLeafValue>, in TInsertable, out ImplicitlyConstructable extends boolean, out Info = unknown> extends TreeNodeSchemaCore<Name, Kind, ImplicitlyConstructable, Info> {
    // (undocumented)
    create(data: TInsertable): TNode;
}

// @public
type TreeNodeSchemaUnsafe<Name extends string = string, Kind extends NodeKind = NodeKind, TNode extends Unenforced<TreeNode | TreeLeafValue> = unknown, TBuild = never, ImplicitlyConstructable extends boolean = boolean, Info = unknown> = TreeNodeSchemaClassUnsafe<Name, Kind, TNode, TBuild, ImplicitlyConstructable, Info> | TreeNodeSchemaNonClassUnsafe<Name, Kind, TNode, TBuild, ImplicitlyConstructable, Info>;

// @public
export type TreeObjectNode<T extends RestrictiveStringRecord<ImplicitFieldSchema>, TypeName extends string = string> = TreeNode & ObjectFromSchemaRecord<T> & WithType<TypeName, NodeKind.Object, T>;

// @public
export type TreeObjectNodeUnsafe<T extends Unenforced<RestrictiveStringRecord<ImplicitFieldSchema>>, TypeName extends string = string> = TreeNode & ObjectFromSchemaRecordUnsafe<T> & WithType<TypeName, NodeKind.Object>;

// @public
export enum TreeStatus {
    Deleted = 2,
    InDocument = 0,
    New = 3,
    Removed = 1
}

// @public @sealed
export interface TreeView<in out TSchema extends ImplicitFieldSchema> extends IDisposable {
    readonly compatibility: SchemaCompatibilityStatus;
    readonly events: Listenable<TreeViewEvents>;
    initialize(content: InsertableTreeFieldFromImplicitField<TSchema>): void;
    get root(): TreeFieldFromImplicitField<TSchema>;
    set root(newRoot: InsertableTreeFieldFromImplicitField<TSchema>);
    readonly schema: TSchema;
    upgradeSchema(): void;
}

// @public @sealed
export class TreeViewConfiguration<const TSchema extends ImplicitFieldSchema = ImplicitFieldSchema> implements Required<ITreeViewConfiguration<TSchema>> {
    constructor(props: ITreeViewConfiguration<TSchema>);
    readonly enableSchemaValidation: boolean;
    readonly preventAmbiguity: boolean;
    readonly schema: TSchema;
    // (undocumented)
    protected _typeCheck: MakeNominal;
}

// @public @sealed
export interface TreeViewEvents {
    commitApplied(data: CommitMetadata, getRevertible?: RevertibleFactory): void;
    rootChanged(): void;
    schemaChanged(): void;
}

// @public @deprecated
const typeNameSymbol: unique symbol;

// @public
export const typeSchemaSymbol: unique symbol;

// @public
export type Unenforced<_DesiredExtendsConstraint> = unknown;

// @public
export type Unhydrated<T> = T;

// @public
export type UnionToIntersection<T> = (T extends T ? (k: T) => unknown : never) extends (k: infer U) => unknown ? U : never;

// @public
export type ValidateRecursiveSchema<T extends TreeNodeSchemaClass<string, NodeKind.Array | NodeKind.Map | NodeKind.Object, TreeNode & WithType<T["identifier"], T["kind"]>, {
    [NodeKind.Object]: T["info"] extends RestrictiveStringRecord<ImplicitFieldSchema> ? InsertableObjectFromSchemaRecord<T["info"]> : unknown;
    [NodeKind.Array]: T["info"] extends ImplicitAllowedTypes ? Iterable<InsertableTreeNodeFromImplicitAllowedTypes<T["info"]>> : unknown;
    [NodeKind.Map]: T["info"] extends ImplicitAllowedTypes ? Iterable<[string, InsertableTreeNodeFromImplicitAllowedTypes<T["info"]>]> : unknown;
}[T["kind"]], false, {
    [NodeKind.Object]: RestrictiveStringRecord<ImplicitFieldSchema>;
    [NodeKind.Array]: ImplicitAllowedTypes;
    [NodeKind.Map]: ImplicitAllowedTypes;
}[T["kind"]]>> = true;

// @public @sealed
export interface ViewableTree {
    viewWith<TRoot extends ImplicitFieldSchema>(config: TreeViewConfiguration<TRoot>): TreeView<TRoot>;
}

// @public @sealed
export interface WithType<out TName extends string = string, out TKind extends NodeKind = NodeKind, out TInfo = unknown> {
    // @deprecated
    get [typeNameSymbol](): TName;
    get [typeSchemaSymbol](): TreeNodeSchemaClass<TName, TKind, TreeNode, never, boolean, TInfo>;
}

// (No @packageDocumentation comment for this package)

```
