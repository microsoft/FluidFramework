/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { assert, unreachableCase } from "@fluidframework/core-utils/internal";
import type { TAnySchema } from "@sinclair/typebox";

import { DiscriminatedUnionDispatcher, type IJsonCodec } from "../../codec/index.js";
import type {
	ChangeEncodingContext,
	ChangesetLocalId,
	EncodedRevisionTag,
	RevisionTag,
} from "../../core/index.js";
import { type JsonCompatibleReadOnly, type Mutable, brand, fail } from "../../util/index.js";
import { makeChangeAtomIdCodec } from "../changeAtomIdCodec.js";

import {
	Changeset as ChangesetSchema,
	DetachIdOverrideType,
	type Encoded,
} from "./formatV1.js";
import {
	type Attach,
	type CellId,
	type Changeset,
	type Detach,
	type Insert,
	type Mark,
	type MarkEffect,
	NoopMarkType,
	type Remove,
	type Rename,
} from "./types.js";
import { getDetachOutputCellId, isNoopMark } from "./utils.js";
import type { FieldChangeEncodingContext } from "../index.js";
import { EncodedNodeChangeset } from "../modular-schema/index.js";

export function makeV1Codec(
	revisionTagCodec: IJsonCodec<
		RevisionTag,
		EncodedRevisionTag,
		EncodedRevisionTag,
		ChangeEncodingContext
	>,
): IJsonCodec<
	Changeset,
	JsonCompatibleReadOnly,
	JsonCompatibleReadOnly,
	FieldChangeEncodingContext
> {
	const changeAtomIdCodec = makeChangeAtomIdCodec(revisionTagCodec);
	const markEffectCodec: IJsonCodec<
		MarkEffect,
		Encoded.MarkEffect,
		Encoded.MarkEffect,
		ChangeEncodingContext
	> = {
		encode(effect: MarkEffect, context: ChangeEncodingContext): Encoded.MarkEffect {
			function encodeRevision(
				revision: RevisionTag | undefined,
			): EncodedRevisionTag | undefined {
				if (revision === undefined || revision === context.revision) {
					return undefined;
				}

				return revisionTagCodec.encode(revision, context);
			}

			const type = effect.type;
			switch (type) {
				case "Insert":
					return {
						insert: {
							revision: encodeRevision(effect.revision),
							id: effect.id,
						},
					};
				case "Remove":
					return {
						delete: {
							revision: encodeRevision(effect.revision),
							idOverride:
								effect.idOverride === undefined
									? undefined
									: {
											// An arbitrary override type is chosen here. It only had an impact on lineage logic which was not enabled in V1.
											type: DetachIdOverrideType.Unattach,
											id: cellIdCodec.encode(effect.idOverride, context),
										},
							id: effect.id,
						},
					};
				case "Rename":
					// In documents generated by clients on release >=2.2 (i.e., running the code from the PR that added this comment),
					// renames are encoded as AttachAndDetach with a special id.
					// This ensures forward-compatibility of clients on release <=2.1 with documents/ops generated by clients on release >=2.2.
					// XXX
					return {};
				case NoopMarkType:
					fail("Mark type: NoopMarkType should not be encoded.");
				default:
					unreachableCase(type);
			}
		},
		decode(encoded: Encoded.MarkEffect, context: ChangeEncodingContext): MarkEffect {
			return decoderLibrary.dispatch(encoded, context);
		},
	};

	function decodeRevision(
		encodedRevision: EncodedRevisionTag | undefined,
		context: ChangeEncodingContext,
	): RevisionTag {
		if (encodedRevision === undefined) {
			assert(context.revision !== undefined, 0x965 /* Implicit revision should be provided */);
			return context.revision;
		}

		return revisionTagCodec.decode(encodedRevision, context);
	}

	const decoderLibrary = new DiscriminatedUnionDispatcher<
		Encoded.MarkEffect,
		/* args */ [context: ChangeEncodingContext],
		MarkEffect
	>({
		moveIn(encoded: Encoded.MoveIn, context: ChangeEncodingContext): Insert {
			const { id, revision } = encoded;
			const mark: Insert = {
				type: "Insert",
				id,
			};

			// XXX: Final endpoint
			mark.revision = decodeRevision(revision, context);
			return mark;
		},
		insert(encoded: Encoded.Insert, context: ChangeEncodingContext): Insert {
			const { id, revision } = encoded;
			const mark: Insert = {
				type: "Insert",
				id,
			};

			mark.revision = decodeRevision(revision, context);
			return mark;
		},
		delete(encoded: Encoded.Remove, context: ChangeEncodingContext): Remove {
			const { id, revision, idOverride } = encoded;
			const mark: Mutable<Remove> = {
				type: "Remove",
				id,
			};

			mark.revision = decodeRevision(revision, context);
			if (idOverride !== undefined) {
				mark.idOverride = cellIdCodec.decode(idOverride.id, context);
			}
			return mark;
		},
		moveOut(encoded: Encoded.MoveOut, context: ChangeEncodingContext): Remove {
			const { id, idOverride, revision } = encoded;
			const mark: Mutable<Remove> = {
				type: "Remove",
				id,
			};

			// XXX: Final endpoint
			mark.revision = decodeRevision(revision, context);
			if (idOverride !== undefined) {
				mark.idOverride = cellIdCodec.decode(idOverride.id, context);
			}

			return mark;
		},
		attachAndDetach(encoded: Encoded.AttachAndDetach, context: ChangeEncodingContext): Rename {
			const attach = decoderLibrary.dispatch(encoded.attach, context) as Attach;
			const detach = decoderLibrary.dispatch(encoded.detach, context) as Detach;
			// In documents generated by clients on release >=2.2 (i.e., running the code from the PR that added this comment),
			// renames are encoded as AttachAndDetach with a special id.
			// This ensures forward-compatibility of clients on release <=2.1 with documents/ops generated by clients on release >=2.2.
			if (attach.id === renameLocalId) {
				assert(detach.idOverride !== undefined, 0x9f7 /* Rename must have idOverride */);
				return {
					type: "Rename",
					idOverride: detach.idOverride,
				};
			}
			return {
				type: "Rename",
				idOverride: getDetachOutputCellId(detach),
			};
		},
	});

	const cellIdCodec: IJsonCodec<
		CellId,
		Encoded.CellId,
		Encoded.CellId,
		ChangeEncodingContext
	> = {
		encode: (cellId: CellId, context: ChangeEncodingContext): Encoded.CellId => {
			const encoded: Encoded.CellId = {
				atom: changeAtomIdCodec.encode(cellId, context),
			};
			return encoded;
		},
		decode: ({ atom }: Encoded.CellId, context: ChangeEncodingContext): CellId => {
			return changeAtomIdCodec.decode(atom, context);
		},
	};

	/**
	 * If we want to make the node change aspect of this codec more type-safe, we could adjust generics
	 * to be in terms of the schema rather than the concrete type of the node change.
	 */
	type NodeChangeSchema = TAnySchema;

	return {
		encode: (
			changeset: Changeset,
			context: FieldChangeEncodingContext,
		): JsonCompatibleReadOnly & Encoded.Changeset<NodeChangeSchema> => {
			const jsonMarks: Encoded.Changeset<NodeChangeSchema> = [];
			for (const mark of changeset) {
				const encodedMark: Encoded.Mark<NodeChangeSchema> = {
					count: mark.count,
				};
				if (!isNoopMark(mark)) {
					encodedMark.effect = markEffectCodec.encode(mark, context.baseContext);
				}
				if (mark.cellId !== undefined) {
					encodedMark.cellId = cellIdCodec.encode(mark.cellId, context.baseContext);
				}
				if (mark.changes !== undefined) {
					encodedMark.changes = context.encodeNode(mark.changes);
				}
				jsonMarks.push(encodedMark);
			}
			return jsonMarks;
		},
		decode: (
			changeset: Encoded.Changeset<NodeChangeSchema>,
			context: FieldChangeEncodingContext,
		): Changeset => {
			const marks: Changeset = [];
			for (const mark of changeset) {
				const decodedMark: Mark = {
					count: mark.count,
				};

				if (mark.effect !== undefined) {
					Object.assign(decodedMark, markEffectCodec.decode(mark.effect, context.baseContext));
				}
				if (mark.cellId !== undefined) {
					decodedMark.cellId = cellIdCodec.decode(mark.cellId, context.baseContext);
				}

				// XXX: Hnadle attach and detach, move in, move out
				if (mark.changes !== undefined) {
					decodedMark.changes = context.decodeNode(mark.changes);
				}
				marks.push(decodedMark);
			}
			return marks;
		},
		encodedSchema: ChangesetSchema(EncodedNodeChangeset),
	};
}

/**
 * Arbitrary ID that is used to indicate a Rename effect.
 */
const renameLocalId: ChangesetLocalId = brand(-1);
