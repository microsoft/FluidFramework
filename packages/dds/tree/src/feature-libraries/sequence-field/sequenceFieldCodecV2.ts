/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { assert, unreachableCase } from "@fluidframework/core-utils/internal";
import type { TAnySchema } from "@sinclair/typebox";

import {
	DiscriminatedUnionDispatcher,
	type DiscriminatedUnionLibrary,
	type IJsonCodec,
} from "../../codec/index.js";
import type {
	ChangeEncodingContext,
	ChangesetLocalId,
	EncodedRevisionTag,
	RevisionTag,
} from "../../core/index.js";
import { type JsonCompatibleReadOnly, type Mutable, brand, fail } from "../../util/index.js";
import { makeChangeAtomIdCodec } from "../changeAtomIdCodec.js";

import { Changeset as ChangesetSchema, type Encoded } from "./formatV2.js";
import {
	type Attach,
	type AttachAndDetach,
	type Changeset,
	type Detach,
	type Insert,
	type Mark,
	type MarkEffect,
	type MoveIn,
	type MoveOut,
	NoopMarkType,
	type Remove,
	type Rename,
} from "./types.js";
import { isNoopMark, normalizeCellRename } from "./utils.js";
import type { FieldChangeEncodingContext } from "../index.js";
import { EncodedNodeChangeset } from "../modular-schema/index.js";
import type { SequenceCodecHelpers } from "./helperTypes.js";

export function makeV2CodecHelpers(
	revisionTagCodec: IJsonCodec<
		RevisionTag,
		EncodedRevisionTag,
		EncodedRevisionTag,
		ChangeEncodingContext
	>,
): SequenceCodecHelpers<MarkEffect, Encoded.MarkEffect> {
	const changeAtomIdCodec = makeChangeAtomIdCodec(revisionTagCodec);
	const markEffectCodec: IJsonCodec<
		MarkEffect,
		Encoded.MarkEffect,
		Encoded.MarkEffect,
		ChangeEncodingContext
	> = {
		encode(effect: MarkEffect, context: ChangeEncodingContext): Encoded.MarkEffect {
			function encodeRevision(
				revision: RevisionTag | undefined,
			): EncodedRevisionTag | undefined {
				if (revision === undefined || revision === context.revision) {
					return undefined;
				}

				return revisionTagCodec.encode(revision, context);
			}

			const type = effect.type;
			switch (type) {
				case "MoveIn":
					return {
						moveIn: {
							revision: encodeRevision(effect.revision),
							finalEndpoint:
								effect.finalEndpoint === undefined
									? undefined
									: changeAtomIdCodec.encode(effect.finalEndpoint, context),
							id: effect.id,
						},
					};
				case "Insert":
					return {
						insert: {
							revision: encodeRevision(effect.revision),
							id: effect.id,
						},
					};
				case "Remove":
					return {
						remove: {
							revision: encodeRevision(effect.revision),
							idOverride:
								effect.idOverride === undefined
									? undefined
									: changeAtomIdCodec.encode(effect.idOverride, context),
							id: effect.id,
						},
					};
				case "MoveOut":
					return {
						moveOut: {
							revision: encodeRevision(effect.revision),
							finalEndpoint:
								effect.finalEndpoint === undefined
									? undefined
									: changeAtomIdCodec.encode(effect.finalEndpoint, context),
							idOverride:
								effect.idOverride === undefined
									? undefined
									: changeAtomIdCodec.encode(effect.idOverride, context),
							id: effect.id,
						},
					};
				case "AttachAndDetach":
					return {
						attachAndDetach: {
							attach: markEffectCodec.encode(effect.attach, context) as Encoded.Attach,
							detach: markEffectCodec.encode(effect.detach, context) as Encoded.Detach,
						},
					};
				case "Rename":
					// In documents generated by clients on release >=2.2 (i.e., running the code from the PR that added this comment),
					// renames are encoded as AttachAndDetach with a special id.
					// This ensures forward-compatibility of clients on release <=2.1 with documents/ops generated by clients on release >=2.2.
					return markEffectCodec.encode(
						{
							type: "AttachAndDetach",
							attach: { type: "MoveIn", id: renameLocalId },
							detach: { type: "MoveOut", id: renameLocalId, idOverride: effect.idOverride },
						},
						context,
					);
				case NoopMarkType:
					fail(`Mark type: ${type} should not be encoded.`);
				default:
					unreachableCase(type);
			}
		},
		decode(encoded: Encoded.MarkEffect, context: ChangeEncodingContext): MarkEffect {
			return decoderDispatcher.dispatch(encoded, context);
		},
	};

	function decodeRevision(
		encodedRevision: EncodedRevisionTag | undefined,
		context: ChangeEncodingContext,
	): RevisionTag {
		if (encodedRevision === undefined) {
			assert(context.revision !== undefined, 0x996 /* Implicit revision should be provided */);
			return context.revision;
		}

		return revisionTagCodec.decode(encodedRevision, context);
	}

	const decoderLibrary: DiscriminatedUnionLibrary<
		Encoded.MarkEffect,
		/* args */ [context: ChangeEncodingContext],
		MarkEffect
	> = {
		moveIn(encoded: Encoded.MoveIn, context: ChangeEncodingContext): MoveIn {
			const { id, finalEndpoint, revision } = encoded;
			const mark: MoveIn = {
				type: "MoveIn",
				id,
			};

			mark.revision = decodeRevision(revision, context);
			if (finalEndpoint !== undefined) {
				mark.finalEndpoint = changeAtomIdCodec.decode(finalEndpoint, context);
			}
			return mark;
		},
		insert(encoded: Encoded.Insert, context: ChangeEncodingContext): Insert {
			const { id, revision } = encoded;
			const mark: Insert = {
				type: "Insert",
				id,
			};

			mark.revision = decodeRevision(revision, context);
			return mark;
		},
		remove(encoded: Encoded.Remove, context: ChangeEncodingContext): Remove {
			const { id, revision, idOverride } = encoded;
			const mark: Mutable<Remove> = {
				type: "Remove",
				id,
			};

			mark.revision = decodeRevision(revision, context);
			if (idOverride !== undefined) {
				mark.idOverride = changeAtomIdCodec.decode(idOverride, context);
			}
			return mark;
		},
		moveOut(encoded: Encoded.MoveOut, context: ChangeEncodingContext): MoveOut {
			const { id, finalEndpoint, idOverride, revision } = encoded;
			const mark: Mutable<MoveOut> = {
				type: "MoveOut",
				id,
			};

			mark.revision = decodeRevision(revision, context);
			if (finalEndpoint !== undefined) {
				mark.finalEndpoint = changeAtomIdCodec.decode(finalEndpoint, context);
			}
			if (idOverride !== undefined) {
				mark.idOverride = changeAtomIdCodec.decode(idOverride, context);
			}

			return mark;
		},
		attachAndDetach(
			encoded: Encoded.AttachAndDetach,
			context: ChangeEncodingContext,
		): AttachAndDetach | Rename {
			const attach = decoderDispatcher.dispatch(encoded.attach, context) as Attach;
			const detach = decoderDispatcher.dispatch(encoded.detach, context) as Detach;
			// In documents generated by clients on release >=2.2 (i.e., running the code from the PR that added this comment),
			// renames are encoded as AttachAndDetach with a special id.
			// This ensures forward-compatibility of clients on release <=2.1 with documents/ops generated by clients on release >=2.2.
			if (attach.id === renameLocalId) {
				assert(detach.idOverride !== undefined, 0x9f8 /* Rename must have idOverride */);
				return {
					type: "Rename",
					idOverride: detach.idOverride,
				};
			}
			return {
				type: "AttachAndDetach",
				attach,
				detach,
			};
		},
	};

	const decoderDispatcher = new DiscriminatedUnionDispatcher<
		Encoded.MarkEffect,
		/* args */ [context: ChangeEncodingContext],
		MarkEffect
	>(decoderLibrary);

	return {
		changeAtomIdCodec,
		markEffectCodec,
		decoderLibrary,
		decodeRevision,
	};
}

export function makeV2Codec(
	revisionTagCodec: IJsonCodec<
		RevisionTag,
		EncodedRevisionTag,
		EncodedRevisionTag,
		ChangeEncodingContext
	>,
): IJsonCodec<
	Changeset,
	JsonCompatibleReadOnly,
	JsonCompatibleReadOnly,
	FieldChangeEncodingContext
> {
	const { markEffectCodec, changeAtomIdCodec } = makeV2CodecHelpers(revisionTagCodec);
	/**
	 * If we want to make the node change aspect of this codec more type-safe, we could adjust generics
	 * to be in terms of the schema rather than the concrete type of the node change.
	 */
	type NodeChangeSchema = TAnySchema;

	return {
		encode: (
			changeset: Changeset,
			context: FieldChangeEncodingContext,
		): JsonCompatibleReadOnly & Encoded.Changeset<NodeChangeSchema> => {
			const jsonMarks: Encoded.Changeset<NodeChangeSchema> = [];
			for (const mark of changeset) {
				const encodedMark: Encoded.Mark<NodeChangeSchema> = {
					count: mark.count,
				};
				if (!isNoopMark(mark)) {
					encodedMark.effect = markEffectCodec.encode(mark, context.baseContext);
				}
				if (mark.cellId !== undefined) {
					encodedMark.cellId = changeAtomIdCodec.encode(mark.cellId, context.baseContext);
				}
				if (mark.changes !== undefined) {
					encodedMark.changes = context.encodeNode(mark.changes);
				}
				jsonMarks.push(encodedMark);
			}
			return jsonMarks;
		},
		decode: (
			changeset: Encoded.Changeset<NodeChangeSchema>,
			context: FieldChangeEncodingContext,
		): Changeset => {
			const marks: Changeset = [];
			for (const mark of changeset) {
				const decodedMark: Mark = {
					count: mark.count,
				};

				if (mark.effect !== undefined) {
					Object.assign(decodedMark, markEffectCodec.decode(mark.effect, context.baseContext));
				}
				if (mark.cellId !== undefined) {
					decodedMark.cellId = changeAtomIdCodec.decode(mark.cellId, context.baseContext);
				}
				// Type deduction wrongly narrows the type of `decodedMark` to `NoopMark & HasMarkFields`.
				// We declare a new casted copy of `decodedMark` to recover the correct type.
				let decodedMark2 = decodedMark as Mark;
				if (decodedMark2.cellId !== undefined && decodedMark2.type === "AttachAndDetach") {
					// In documents generated by clients on release <=2.1 (i.e., not running the code from the PR that added this comment),
					// rename-like AttachAndDetach marks are not normalized to Rename marks thus requiring this normalization step.
					// This ensures backward compatibility with documents generated by clients on release <=2.1.
					decodedMark2 = normalizeCellRename(
						decodedMark2.cellId,
						decodedMark2.count,
						decodedMark2.attach,
						decodedMark2.detach,
					);
				}
				if (mark.changes !== undefined) {
					decodedMark2.changes = context.decodeNode(mark.changes);
				}
				marks.push(decodedMark2);
			}
			return marks;
		},
		encodedSchema: ChangesetSchema(EncodedNodeChangeset),
	};
}

/**
 * Arbitrary ID that is used to indicate a Rename effect.
 */
const renameLocalId: ChangesetLocalId = brand(-1);
