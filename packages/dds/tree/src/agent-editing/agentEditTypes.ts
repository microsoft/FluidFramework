/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/* eslint-disable @typescript-eslint/no-unused-vars */

// eslint-disable-next-line import/no-internal-modules
import type { JsonObject, JsonValue } from "../json-handler/jsonParser.js";
import { SchemaFactory, TreeViewConfiguration } from "../simple-tree/index.js";

/**
 * TODO: The current scheme does not allow manipulation of arrays of primitive values because you cannot refer to them.
 * We could accomplish this via a path (probably JSON Pointer or JSONPath) from a possibly-null objectId, or wrap arrays in an identified object.
 *
 * TODO: We could add a "replace" edit type to avoid tons of little modifies.
 *
 * TODO: OpenAI doesn't include the schema in the input...would doing so decrease hallucination? Maybe a compact version? We will definitely need example edits.
 *
 * TODO: only 100 object fields total are allowed by OpenAI right now, so larger schemas will fail faster if we have a bunch of schema types generated for type-specific edits.
 *
 * TODO: experiment using https://github.com/outlines-dev/outlines (and maybe a llama model) to avoid many of the annoyances of OpenAI's JSON Schema subset.
 *
 * TODO: without field count limits, we could generate a schema for valid paths from the root object to any field, but it's not clear how useful that would be.
 *
 * TODO: add example of handling fields the model cannot initialize (identifiers, uuid fields, etc.)
 */

// For polymorphic edits, we need to wrap the edit in an object to avoid anyOf at the root level.
export interface EditWrapper {
	edits: TreeEdit[];
}

export type TreeEdit = SetRoot | Insert | Modify | Remove | Move;

export interface Edit {
	type: "setRoot" | "insert" | "modify" | "remove" | "move";
}

export type Selection = Target | Range;

export interface Target {
	objectId: number;
}

export interface Place extends Target {
	// No "start" or "end" because we don't have a way to refer to arrays directly.
	place: "before" | "after";
}

export interface Range {
	from: Place;
	to: Place;
}

export interface SetRoot extends Edit {
	type: "setRoot";
	content: JsonValue;
}

export interface Insert extends Edit {
	type: "insert";
	content: JsonObject;
	destination: Place;
}

export interface Modify extends Edit {
	type: "modify";
	target: Target;
	field: string;
	modification: JsonValue;
}

export interface Remove extends Edit {
	type: "remove";
	source: Selection;
}

export interface Move extends Edit {
	type: "move";
	source: Selection;
	destination: Place;
}

/** ---------------- EXAMPLE FOLLOWS ---------------------- */

// Example SharedTree schema:

const sf = new SchemaFactory("agentSchema");

class Vector extends sf.object("Vector", {
	id: sf.identifier, // will be omitted from the generated JSON schema
	x: sf.number,
	y: sf.number,
	z: sf.optional(sf.number),
}) {}

class RootObject extends sf.object("RootObject", {
	str: sf.string,
	vectors: sf.array(Vector),
	bools: sf.array(sf.boolean),
}) {}

const config = new TreeViewConfiguration({ schema: [sf.number, RootObject] });

// Example of generated JSON schema we send to the model:
// TODO: add descriptions to fluid-generated types

const _jsonSchema = {
	$ref: "#/$defs/__fluid_rootWrapper",
	$defs: {
		"agentSchema.Vector": {
			type: "object",
			properties: {
				// Add a type field (unconditionally for now) to disambiguate polymorphic inserts
				schemaType: { type: "string", enum: ["agentSchema.Vector"] },
				x: { type: "number" },
				y: { type: "number" },
				z: {
					// All fields must be required for OpenAI json schema
					anyOf: [{ type: "number" }, { type: "null" }],
				},
			},
			required: ["schemaType", "x", "y", "z"],
			// All types must have additionalProperties: false for OpenAI json schema
			additionalProperties: false,
		},
		"agentSchema.RootObject": {
			type: "object",
			properties: {
				schemaType: { type: "string", enum: ["agentSchema.RootObject"] },
				str: { type: "string" },
				vectors: {
					type: "array",
					items: { "$ref": "agentSchema.Vector" },
				},
				bools: {
					type: "array",
					items: { type: "boolean" },
				},
			},
			required: ["schemaType", "str", "vectors", "bools"],
			additionalProperties: false,
		},
		// Handle the polymorphic edit schema with a wrapper object since anyOf is banned at root with OpenAI
		// Names of types generated by fluid (this and edits) could contain a UUID to avoid collisions.
		"__fluid_rootWrapper": {
			type: "object",
			properties: {
				edits: {
					type: "array",
					items: {
						anyOf: [
							{ "$ref": "__fluid_setRoot" },
							{ "$ref": "__fluid_insert" },
							{ "$ref": "__fluid_modify" },
							{ "$ref": "__fluid_remove" },
							{ "$ref": "__fluid_move" },
						],
					},
				},
			},
			additionalProperties: false,
		},
		"__fluid_target": {
			type: "object",
			properties: {
				objectId: { type: "number" },
			},
			required: ["objectId"],
			additionalProperties: false,
		},
		"__fluid_place": {
			type: "object",
			properties: {
				objectId: { type: "number" },
				place: { type: "string", enum: ["before", "after"] },
			},
			required: ["objectId", "place"],
			additionalProperties: false,
		},
		"__fluid_range": {
			type: "object",
			properties: {
				from: { "$ref": "__fluid_place" },
				to: { "$ref": "__fluid_place" },
			},
			required: ["from", "to"],
			additionalProperties: false,
		},
		"__fluid_setRoot": {
			type: "object",
			properties: {
				type: { type: "string", enum: ["setRoot"] },
				// this matches the polymorphism in the tree config
				content: { anyOf: [{ type: "number" }, { "$ref": "agentSchema.RootObject" }] },
			},
			required: ["type", "content"],
			additionalProperties: false,
		},
		"__fluid_insert": {
			type: "object",
			properties: {
				type: { type: "string", enum: ["insert"] },
				// content can be any object type (todo: primitives) that appears in an array in the schema
				// note that we omit booleans
				content: {
					anyOf: [{ "$ref": "agentSchema.Vector" }],
				},
				destination: { "$ref": "__fluid_place" },
			},
			required: ["type", "content", "destination"],
			additionalProperties: false,
		},
		"__fluid_modify": {
			type: "object",
			properties: {
				type: { type: "string", enum: ["modify"] },
				target: { "$ref": "__fluid_target" },
				field: { type: "string", enum: ["x", "y", "z", "str", "vectors", "bools"] },
				modification: {
					// modifications can't be typed specifically to the field, so we allow any type that appears in a required or optional field (and include null if there are any optional fields)
					// note that we do not include Vector as a type here because it is only contained in an array in the schema
					anyOf: [
						{ type: "number" },
						{ type: "null" },
						{ type: "string" },
						{ type: "array", items: { "$ref": "agentSchema.Vector" } },
						{ type: "array", items: { type: "boolean" } },
					],
				},
			},
			required: ["type", "target", "field", "modification"],
			additionalProperties: false,
		},
		"__fluid_remove": {
			type: "object",
			properties: {
				type: { type: "string", enum: ["remove"] },
				source: { "$ref": "__fluid_range" },
			},
			required: ["type", "source"],
			additionalProperties: false,
		},
		"__fluid_move": {
			type: "object",
			properties: {
				type: { type: "string", enum: ["move"] },
				source: { "$ref": "__fluid_range" },
				destination: { "$ref": "__fluid_place" },
			},
			required: ["type", "source", "destination"],
			additionalProperties: false,
		},
	},
};
