/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/tree-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_FieldSchema": {"backCompat": false}
 */
declare type current_as_old_for_Class_FieldSchema = requireAssignableTo<TypeOnly<current.FieldSchema>, TypeOnly<old.FieldSchema>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_IterableTreeArrayContent": {"backCompat": false}
 */
declare type current_as_old_for_Class_IterableTreeArrayContent = requireAssignableTo<TypeOnly<current.IterableTreeArrayContent<never>>, TypeOnly<old.IterableTreeArrayContent<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SchemaFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SchemaFactory = requireAssignableTo<TypeOnly<current.SchemaFactory>, TypeOnly<old.SchemaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TreeNode": {"backCompat": false}
 */
declare type current_as_old_for_Class_TreeNode = requireAssignableTo<TypeOnly<current.TreeNode>, TypeOnly<old.TreeNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TreeViewConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Class_TreeViewConfiguration = requireAssignableTo<TypeOnly<current.TreeViewConfiguration>, TypeOnly<old.TreeViewConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_FieldSchema": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_FieldSchema = requireAssignableTo<TypeOnly<typeof current.FieldSchema>, TypeOnly<typeof old.FieldSchema>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_IterableTreeArrayContent": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_IterableTreeArrayContent = requireAssignableTo<TypeOnly<typeof current.IterableTreeArrayContent>, TypeOnly<typeof old.IterableTreeArrayContent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SchemaFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SchemaFactory = requireAssignableTo<TypeOnly<typeof current.SchemaFactory>, TypeOnly<typeof old.SchemaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TreeNode": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TreeNode = requireAssignableTo<TypeOnly<typeof current.TreeNode>, TypeOnly<typeof old.TreeNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TreeViewConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TreeViewConfiguration = requireAssignableTo<TypeOnly<typeof current.TreeViewConfiguration>, TypeOnly<typeof old.TreeViewConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_CommitKind": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_CommitKind = requireAssignableTo<TypeOnly<old.CommitKind>, TypeOnly<current.CommitKind>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_CommitKind": {"backCompat": false}
 */
declare type current_as_old_for_Enum_CommitKind = requireAssignableTo<TypeOnly<current.CommitKind>, TypeOnly<old.CommitKind>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_FieldKind": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_FieldKind = requireAssignableTo<TypeOnly<old.FieldKind>, TypeOnly<current.FieldKind>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_FieldKind": {"backCompat": false}
 */
declare type current_as_old_for_Enum_FieldKind = requireAssignableTo<TypeOnly<current.FieldKind>, TypeOnly<old.FieldKind>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_NodeKind": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_NodeKind = requireAssignableTo<TypeOnly<old.NodeKind>, TypeOnly<current.NodeKind>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_NodeKind": {"backCompat": false}
 */
declare type current_as_old_for_Enum_NodeKind = requireAssignableTo<TypeOnly<current.NodeKind>, TypeOnly<old.NodeKind>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_RevertibleStatus": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_RevertibleStatus = requireAssignableTo<TypeOnly<old.RevertibleStatus>, TypeOnly<current.RevertibleStatus>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_RevertibleStatus": {"backCompat": false}
 */
declare type current_as_old_for_Enum_RevertibleStatus = requireAssignableTo<TypeOnly<current.RevertibleStatus>, TypeOnly<old.RevertibleStatus>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_TreeStatus": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_TreeStatus = requireAssignableTo<TypeOnly<old.TreeStatus>, TypeOnly<current.TreeStatus>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_TreeStatus": {"backCompat": false}
 */
declare type current_as_old_for_Enum_TreeStatus = requireAssignableTo<TypeOnly<current.TreeStatus>, TypeOnly<old.TreeStatus>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_CommitMetadata": {"backCompat": false}
 */
declare type current_as_old_for_Interface_CommitMetadata = requireAssignableTo<TypeOnly<current.CommitMetadata>, TypeOnly<old.CommitMetadata>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FieldProps": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_FieldProps = requireAssignableTo<TypeOnly<old.FieldProps>, TypeOnly<current.FieldProps>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FieldProps": {"backCompat": false}
 */
declare type current_as_old_for_Interface_FieldProps = requireAssignableTo<TypeOnly<current.FieldProps>, TypeOnly<old.FieldProps>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FieldSchemaMetadata": {"backCompat": false}
 */
declare type current_as_old_for_Interface_FieldSchemaMetadata = requireAssignableTo<TypeOnly<current.FieldSchemaMetadata>, TypeOnly<old.FieldSchemaMetadata>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FieldSchemaUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_FieldSchemaUnsafe = requireAssignableTo<TypeOnly<old.FieldSchemaUnsafe<never,never>>, TypeOnly<current.FieldSchemaUnsafe<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FieldSchemaUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_Interface_FieldSchemaUnsafe = requireAssignableTo<TypeOnly<current.FieldSchemaUnsafe<never,never>>, TypeOnly<old.FieldSchemaUnsafe<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_InternalTreeNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_InternalTreeNode = requireAssignableTo<TypeOnly<current.InternalTreeNode>, TypeOnly<old.InternalTreeNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITree": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITree = requireAssignableTo<TypeOnly<current.ITree>, TypeOnly<old.ITree>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITreeConfigurationOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITreeConfigurationOptions = requireAssignableTo<TypeOnly<old.ITreeConfigurationOptions>, TypeOnly<current.ITreeConfigurationOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITreeConfigurationOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITreeConfigurationOptions = requireAssignableTo<TypeOnly<current.ITreeConfigurationOptions>, TypeOnly<old.ITreeConfigurationOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITreeViewConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITreeViewConfiguration = requireAssignableTo<TypeOnly<old.ITreeViewConfiguration>, TypeOnly<current.ITreeViewConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITreeViewConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITreeViewConfiguration = requireAssignableTo<TypeOnly<current.ITreeViewConfiguration>, TypeOnly<old.ITreeViewConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MakeNominal": {"backCompat": false}
 */
declare type current_as_old_for_Interface_MakeNominal = requireAssignableTo<TypeOnly<current.MakeNominal>, TypeOnly<old.MakeNominal>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_NodeInDocumentConstraint": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_NodeInDocumentConstraint = requireAssignableTo<TypeOnly<old.NodeInDocumentConstraint>, TypeOnly<current.NodeInDocumentConstraint>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_NodeInDocumentConstraint": {"backCompat": false}
 */
declare type current_as_old_for_Interface_NodeInDocumentConstraint = requireAssignableTo<TypeOnly<current.NodeInDocumentConstraint>, TypeOnly<old.NodeInDocumentConstraint>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_NodeSchemaMetadata": {"backCompat": false}
 */
declare type current_as_old_for_Interface_NodeSchemaMetadata = requireAssignableTo<TypeOnly<current.NodeSchemaMetadata>, TypeOnly<old.NodeSchemaMetadata>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_NodeSchemaOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_NodeSchemaOptions = requireAssignableTo<TypeOnly<current.NodeSchemaOptions>, TypeOnly<old.NodeSchemaOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_Revertible": {"backCompat": false}
 */
declare type current_as_old_for_Interface_Revertible = requireAssignableTo<TypeOnly<current.Revertible>, TypeOnly<old.Revertible>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_RunTransaction": {"backCompat": false}
 */
declare type current_as_old_for_Interface_RunTransaction = requireAssignableTo<TypeOnly<current.RunTransaction>, TypeOnly<old.RunTransaction>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SchemaCompatibilityStatus": {"backCompat": false}
 */
declare type current_as_old_for_Interface_SchemaCompatibilityStatus = requireAssignableTo<TypeOnly<current.SchemaCompatibilityStatus>, TypeOnly<old.SchemaCompatibilityStatus>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeArrayNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeArrayNode = requireAssignableTo<TypeOnly<current.TreeArrayNode>, TypeOnly<old.TreeArrayNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeChangeEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeChangeEvents = requireAssignableTo<TypeOnly<current.TreeChangeEvents>, TypeOnly<old.TreeChangeEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeMapNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeMapNode = requireAssignableTo<TypeOnly<current.TreeMapNode>, TypeOnly<old.TreeMapNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeNodeApi": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeNodeApi = requireAssignableTo<TypeOnly<current.TreeNodeApi>, TypeOnly<old.TreeNodeApi>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeNodeSchemaCore": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeNodeSchemaCore = requireAssignableTo<TypeOnly<current.TreeNodeSchemaCore<never,never,never>>, TypeOnly<old.TreeNodeSchemaCore<never,never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeView": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeView = requireAssignableTo<TypeOnly<current.TreeView<never>>, TypeOnly<old.TreeView<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeViewEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeViewEvents = requireAssignableTo<TypeOnly<current.TreeViewEvents>, TypeOnly<old.TreeViewEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_WithType": {"backCompat": false}
 */
declare type current_as_old_for_Interface_WithType = requireAssignableTo<TypeOnly<current.WithType>, TypeOnly<old.WithType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ImplicitAllowedTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ImplicitAllowedTypes = requireAssignableTo<TypeOnly<old.ImplicitAllowedTypes>, TypeOnly<current.ImplicitAllowedTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ImplicitAllowedTypes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ImplicitAllowedTypes = requireAssignableTo<TypeOnly<current.ImplicitAllowedTypes>, TypeOnly<old.ImplicitAllowedTypes>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ImplicitFieldSchema": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ImplicitFieldSchema = requireAssignableTo<TypeOnly<old.ImplicitFieldSchema>, TypeOnly<current.ImplicitFieldSchema>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ImplicitFieldSchema": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ImplicitFieldSchema = requireAssignableTo<TypeOnly<current.ImplicitFieldSchema>, TypeOnly<old.ImplicitFieldSchema>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTreeFieldFromImplicitField": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InsertableTreeFieldFromImplicitField = requireAssignableTo<TypeOnly<old.InsertableTreeFieldFromImplicitField<never>>, TypeOnly<current.InsertableTreeFieldFromImplicitField<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTreeFieldFromImplicitField": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InsertableTreeFieldFromImplicitField = requireAssignableTo<TypeOnly<current.InsertableTreeFieldFromImplicitField<never>>, TypeOnly<old.InsertableTreeFieldFromImplicitField<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTreeNodeFromImplicitAllowedTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InsertableTreeNodeFromImplicitAllowedTypes = requireAssignableTo<TypeOnly<old.InsertableTreeNodeFromImplicitAllowedTypes<never>>, TypeOnly<current.InsertableTreeNodeFromImplicitAllowedTypes<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTreeNodeFromImplicitAllowedTypes": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_TypeAlias_InsertableTreeNodeFromImplicitAllowedTypes = requireAssignableTo<TypeOnly<current.InsertableTreeNodeFromImplicitAllowedTypes<never>>, TypeOnly<old.InsertableTreeNodeFromImplicitAllowedTypes<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTypedNode": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InsertableTypedNode = requireAssignableTo<TypeOnly<old.InsertableTypedNode<never>>, TypeOnly<current.InsertableTypedNode<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTypedNode": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InsertableTypedNode = requireAssignableTo<TypeOnly<current.InsertableTypedNode<never>>, TypeOnly<old.InsertableTypedNode<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IsListener": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IsListener = requireAssignableTo<TypeOnly<old.IsListener<never>>, TypeOnly<current.IsListener<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IsListener": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IsListener = requireAssignableTo<TypeOnly<current.IsListener<never>>, TypeOnly<old.IsListener<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LazyItem": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_LazyItem = requireAssignableTo<TypeOnly<old.LazyItem>, TypeOnly<current.LazyItem>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LazyItem": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_LazyItem = requireAssignableTo<TypeOnly<current.LazyItem>, TypeOnly<old.LazyItem>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Listenable": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_Listenable = requireAssignableTo<TypeOnly<old.Listenable<never>>, TypeOnly<current.Listenable<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Listenable": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_Listenable = requireAssignableTo<TypeOnly<current.Listenable<never>>, TypeOnly<old.Listenable<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Listeners": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_Listeners = requireAssignableTo<TypeOnly<old.Listeners<never>>, TypeOnly<current.Listeners<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Listeners": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_Listeners = requireAssignableTo<TypeOnly<current.Listeners<never>>, TypeOnly<old.Listeners<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_NodeFromSchema": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_NodeFromSchema = requireAssignableTo<TypeOnly<old.NodeFromSchema<never>>, TypeOnly<current.NodeFromSchema<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_NodeFromSchema": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_NodeFromSchema = requireAssignableTo<TypeOnly<current.NodeFromSchema<never>>, TypeOnly<old.NodeFromSchema<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Off": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_Off = requireAssignableTo<TypeOnly<old.Off>, TypeOnly<current.Off>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Off": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_Off = requireAssignableTo<TypeOnly<current.Off>, TypeOnly<old.Off>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RestrictiveReadonlyRecord": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_RestrictiveReadonlyRecord = requireAssignableTo<TypeOnly<old.RestrictiveReadonlyRecord<never,never>>, TypeOnly<current.RestrictiveReadonlyRecord<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RestrictiveReadonlyRecord": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_RestrictiveReadonlyRecord = requireAssignableTo<TypeOnly<current.RestrictiveReadonlyRecord<never,never>>, TypeOnly<old.RestrictiveReadonlyRecord<never,never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RevertibleFactory": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_RevertibleFactory = requireAssignableTo<TypeOnly<current.RevertibleFactory>, TypeOnly<old.RevertibleFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TransactionConstraint": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TransactionConstraint = requireAssignableTo<TypeOnly<old.TransactionConstraint>, TypeOnly<current.TransactionConstraint>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TransactionConstraint": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TransactionConstraint = requireAssignableTo<TypeOnly<current.TransactionConstraint>, TypeOnly<old.TransactionConstraint>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeFieldFromImplicitField": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TreeFieldFromImplicitField = requireAssignableTo<TypeOnly<old.TreeFieldFromImplicitField>, TypeOnly<current.TreeFieldFromImplicitField>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeFieldFromImplicitField": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TreeFieldFromImplicitField = requireAssignableTo<TypeOnly<current.TreeFieldFromImplicitField>, TypeOnly<old.TreeFieldFromImplicitField>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeLeafValue": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TreeLeafValue = requireAssignableTo<TypeOnly<old.TreeLeafValue>, TypeOnly<current.TreeLeafValue>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeLeafValue": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TreeLeafValue = requireAssignableTo<TypeOnly<current.TreeLeafValue>, TypeOnly<old.TreeLeafValue>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeNodeFromImplicitAllowedTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TreeNodeFromImplicitAllowedTypes = requireAssignableTo<TypeOnly<old.TreeNodeFromImplicitAllowedTypes>, TypeOnly<current.TreeNodeFromImplicitAllowedTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeNodeFromImplicitAllowedTypes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TreeNodeFromImplicitAllowedTypes = requireAssignableTo<TypeOnly<current.TreeNodeFromImplicitAllowedTypes>, TypeOnly<old.TreeNodeFromImplicitAllowedTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeNodeSchema": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TreeNodeSchema = requireAssignableTo<TypeOnly<current.TreeNodeSchema>, TypeOnly<old.TreeNodeSchema>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeNodeSchemaClass": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TreeNodeSchemaClass = requireAssignableTo<TypeOnly<current.TreeNodeSchemaClass>, TypeOnly<old.TreeNodeSchemaClass>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeObjectNode": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TreeObjectNode = requireAssignableTo<TypeOnly<old.TreeObjectNode<never>>, TypeOnly<current.TreeObjectNode<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeObjectNode": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TreeObjectNode = requireAssignableTo<TypeOnly<current.TreeObjectNode<never>>, TypeOnly<old.TreeObjectNode<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Unenforced": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_Unenforced = requireAssignableTo<TypeOnly<old.Unenforced<never>>, TypeOnly<current.Unenforced<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Unenforced": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_Unenforced = requireAssignableTo<TypeOnly<current.Unenforced<never>>, TypeOnly<old.Unenforced<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Unhydrated": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_Unhydrated = requireAssignableTo<TypeOnly<old.Unhydrated<never>>, TypeOnly<current.Unhydrated<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Unhydrated": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_Unhydrated = requireAssignableTo<TypeOnly<current.Unhydrated<never>>, TypeOnly<old.Unhydrated<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ValidateRecursiveSchema": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ValidateRecursiveSchema = requireAssignableTo<TypeOnly<old.ValidateRecursiveSchema<never>>, TypeOnly<current.ValidateRecursiveSchema<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ValidateRecursiveSchema": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ValidateRecursiveSchema = requireAssignableTo<TypeOnly<current.ValidateRecursiveSchema<never>>, TypeOnly<old.ValidateRecursiveSchema<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_rollback": {"backCompat": false}
 */
declare type current_as_old_for_Variable_rollback = requireAssignableTo<TypeOnly<typeof current.rollback>, TypeOnly<typeof old.rollback>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_Tree": {"backCompat": false}
 */
declare type current_as_old_for_Variable_Tree = requireAssignableTo<TypeOnly<typeof current.Tree>, TypeOnly<typeof old.Tree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_TreeArrayNode": {"backCompat": false}
 */
declare type current_as_old_for_Variable_TreeArrayNode = requireAssignableTo<TypeOnly<typeof current.TreeArrayNode>, TypeOnly<typeof old.TreeArrayNode>>
