/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/tree-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_FieldSchema": {"backCompat": false}
 */
declare type current_as_old_for_Class_FieldSchema = requireAssignableTo<TypeOnly<current.FieldSchema>, TypeOnly<old.FieldSchema>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_IterableTreeArrayContent": {"backCompat": false}
 */
declare type current_as_old_for_Class_IterableTreeArrayContent = requireAssignableTo<TypeOnly<current.IterableTreeArrayContent<any>>, TypeOnly<old.IterableTreeArrayContent<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SchemaFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SchemaFactory = requireAssignableTo<TypeOnly<current.SchemaFactory>, TypeOnly<old.SchemaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TreeNode": {"backCompat": false}
 */
declare type current_as_old_for_Class_TreeNode = requireAssignableTo<TypeOnly<current.TreeNode>, TypeOnly<old.TreeNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TreeViewConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Class_TreeViewConfiguration = requireAssignableTo<TypeOnly<current.TreeViewConfiguration>, TypeOnly<old.TreeViewConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_FieldSchema": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_FieldSchema = requireAssignableTo<TypeOnly<typeof current.FieldSchema>, TypeOnly<typeof old.FieldSchema>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_IterableTreeArrayContent": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_IterableTreeArrayContent = requireAssignableTo<TypeOnly<typeof current.IterableTreeArrayContent>, TypeOnly<typeof old.IterableTreeArrayContent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SchemaFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SchemaFactory = requireAssignableTo<TypeOnly<typeof current.SchemaFactory>, TypeOnly<typeof old.SchemaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TreeNode": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TreeNode = requireAssignableTo<TypeOnly<typeof current.TreeNode>, TypeOnly<typeof old.TreeNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TreeViewConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TreeViewConfiguration = requireAssignableTo<TypeOnly<typeof current.TreeViewConfiguration>, TypeOnly<typeof old.TreeViewConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_CommitKind": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_CommitKind = requireAssignableTo<TypeOnly<old.CommitKind>, TypeOnly<current.CommitKind>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_CommitKind": {"backCompat": false}
 */
declare type current_as_old_for_Enum_CommitKind = requireAssignableTo<TypeOnly<current.CommitKind>, TypeOnly<old.CommitKind>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_FieldKind": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_FieldKind = requireAssignableTo<TypeOnly<old.FieldKind>, TypeOnly<current.FieldKind>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_FieldKind": {"backCompat": false}
 */
declare type current_as_old_for_Enum_FieldKind = requireAssignableTo<TypeOnly<current.FieldKind>, TypeOnly<old.FieldKind>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_NodeKind": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_NodeKind = requireAssignableTo<TypeOnly<old.NodeKind>, TypeOnly<current.NodeKind>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_NodeKind": {"backCompat": false}
 */
declare type current_as_old_for_Enum_NodeKind = requireAssignableTo<TypeOnly<current.NodeKind>, TypeOnly<old.NodeKind>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_RevertibleStatus": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_RevertibleStatus = requireAssignableTo<TypeOnly<old.RevertibleStatus>, TypeOnly<current.RevertibleStatus>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_RevertibleStatus": {"backCompat": false}
 */
declare type current_as_old_for_Enum_RevertibleStatus = requireAssignableTo<TypeOnly<current.RevertibleStatus>, TypeOnly<old.RevertibleStatus>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_TreeStatus": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_TreeStatus = requireAssignableTo<TypeOnly<old.TreeStatus>, TypeOnly<current.TreeStatus>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_TreeStatus": {"backCompat": false}
 */
declare type current_as_old_for_Enum_TreeStatus = requireAssignableTo<TypeOnly<current.TreeStatus>, TypeOnly<old.TreeStatus>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_CommitMetadata": {"backCompat": false}
 */
declare type current_as_old_for_Interface_CommitMetadata = requireAssignableTo<TypeOnly<current.CommitMetadata>, TypeOnly<old.CommitMetadata>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FieldProps": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_FieldProps = requireAssignableTo<TypeOnly<old.FieldProps>, TypeOnly<current.FieldProps>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FieldProps": {"backCompat": false}
 */
declare type current_as_old_for_Interface_FieldProps = requireAssignableTo<TypeOnly<current.FieldProps>, TypeOnly<old.FieldProps>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FieldSchemaUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_FieldSchemaUnsafe = requireAssignableTo<TypeOnly<old.FieldSchemaUnsafe<any,any>>, TypeOnly<current.FieldSchemaUnsafe<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_FieldSchemaUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_Interface_FieldSchemaUnsafe = requireAssignableTo<TypeOnly<current.FieldSchemaUnsafe<any,any>>, TypeOnly<old.FieldSchemaUnsafe<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_InternalTreeNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_InternalTreeNode = requireAssignableTo<TypeOnly<current.InternalTreeNode>, TypeOnly<old.InternalTreeNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_InternalTypes_DefaultProvider": {"backCompat": false}
 */
declare type current_as_old_for_Interface_InternalTypes_DefaultProvider = requireAssignableTo<TypeOnly<current.InternalTypes.DefaultProvider>, TypeOnly<old.InternalTypes.DefaultProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_InternalTypes_ReadonlyMapInlined": {"backCompat": false}
 */
declare type current_as_old_for_Interface_InternalTypes_ReadonlyMapInlined = requireAssignableTo<TypeOnly<current.InternalTypes.ReadonlyMapInlined<any,any>>, TypeOnly<old.InternalTypes.ReadonlyMapInlined<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_InternalTypes_TreeApi": {"backCompat": false}
 */
declare type current_as_old_for_Interface_InternalTypes_TreeApi = requireAssignableTo<TypeOnly<current.InternalTypes.TreeApi>, TypeOnly<old.InternalTypes.TreeApi>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_InternalTypes_TreeArrayNodeBase": {"backCompat": false}
 */
declare type current_as_old_for_Interface_InternalTypes_TreeArrayNodeBase = requireAssignableTo<TypeOnly<current.InternalTypes.TreeArrayNodeBase<any,any,any>>, TypeOnly<old.InternalTypes.TreeArrayNodeBase<any,any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_InternalTypes_TreeArrayNodeUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_Interface_InternalTypes_TreeArrayNodeUnsafe = requireAssignableTo<TypeOnly<current.InternalTypes.TreeArrayNodeUnsafe<any>>, TypeOnly<old.InternalTypes.TreeArrayNodeUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_InternalTypes_TreeMapNodeUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_Interface_InternalTypes_TreeMapNodeUnsafe = requireAssignableTo<TypeOnly<current.InternalTypes.TreeMapNodeUnsafe<any>>, TypeOnly<old.InternalTypes.TreeMapNodeUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_InternalTypes_TreeNodeSchemaNonClass": {"backCompat": false}
 */
declare type current_as_old_for_Interface_InternalTypes_TreeNodeSchemaNonClass = requireAssignableTo<TypeOnly<current.InternalTypes.TreeNodeSchemaNonClass>, TypeOnly<old.InternalTypes.TreeNodeSchemaNonClass>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITree": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITree = requireAssignableTo<TypeOnly<current.ITree>, TypeOnly<old.ITree>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITreeConfigurationOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITreeConfigurationOptions = requireAssignableTo<TypeOnly<old.ITreeConfigurationOptions>, TypeOnly<current.ITreeConfigurationOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITreeConfigurationOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITreeConfigurationOptions = requireAssignableTo<TypeOnly<current.ITreeConfigurationOptions>, TypeOnly<old.ITreeConfigurationOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITreeViewConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITreeViewConfiguration = requireAssignableTo<TypeOnly<old.ITreeViewConfiguration>, TypeOnly<current.ITreeViewConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITreeViewConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITreeViewConfiguration = requireAssignableTo<TypeOnly<current.ITreeViewConfiguration>, TypeOnly<old.ITreeViewConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_Listenable": {"backCompat": false}
 */
declare type current_as_old_for_Interface_Listenable = requireAssignableTo<TypeOnly<current.Listenable<any>>, TypeOnly<old.Listenable<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_MakeNominal": {"backCompat": false}
 */
declare type current_as_old_for_Interface_MakeNominal = requireAssignableTo<TypeOnly<current.MakeNominal>, TypeOnly<old.MakeNominal>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_NodeInDocumentConstraint": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_NodeInDocumentConstraint = requireAssignableTo<TypeOnly<old.NodeInDocumentConstraint>, TypeOnly<current.NodeInDocumentConstraint>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_NodeInDocumentConstraint": {"backCompat": false}
 */
declare type current_as_old_for_Interface_NodeInDocumentConstraint = requireAssignableTo<TypeOnly<current.NodeInDocumentConstraint>, TypeOnly<old.NodeInDocumentConstraint>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_Revertible": {"backCompat": false}
 */
declare type current_as_old_for_Interface_Revertible = requireAssignableTo<TypeOnly<current.Revertible>, TypeOnly<old.Revertible>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_RunTransaction": {"backCompat": false}
 */
declare type current_as_old_for_Interface_RunTransaction = requireAssignableTo<TypeOnly<current.RunTransaction>, TypeOnly<old.RunTransaction>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_SchemaCompatibilityStatus": {"backCompat": false}
 */
declare type current_as_old_for_Interface_SchemaCompatibilityStatus = requireAssignableTo<TypeOnly<current.SchemaCompatibilityStatus>, TypeOnly<old.SchemaCompatibilityStatus>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeArrayNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeArrayNode = requireAssignableTo<TypeOnly<current.TreeArrayNode>, TypeOnly<old.TreeArrayNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeArrayNodeUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeArrayNodeUnsafe = requireAssignableTo<TypeOnly<current.TreeArrayNodeUnsafe<any>>, TypeOnly<old.TreeArrayNodeUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeChangeEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeChangeEvents = requireAssignableTo<TypeOnly<current.TreeChangeEvents>, TypeOnly<old.TreeChangeEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeMapNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeMapNode = requireAssignableTo<TypeOnly<current.TreeMapNode>, TypeOnly<old.TreeMapNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeMapNodeUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeMapNodeUnsafe = requireAssignableTo<TypeOnly<current.TreeMapNodeUnsafe<any>>, TypeOnly<old.TreeMapNodeUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeNodeApi": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeNodeApi = requireAssignableTo<TypeOnly<current.TreeNodeApi>, TypeOnly<old.TreeNodeApi>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeNodeSchemaClass": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeNodeSchemaClass = requireAssignableTo<TypeOnly<current.TreeNodeSchemaClass>, TypeOnly<old.TreeNodeSchemaClass>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeNodeSchemaCore": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeNodeSchemaCore = requireAssignableTo<TypeOnly<current.TreeNodeSchemaCore<any,any,any>>, TypeOnly<old.TreeNodeSchemaCore<any,any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeView": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeView = requireAssignableTo<TypeOnly<current.TreeView<any>>, TypeOnly<old.TreeView<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_TreeViewEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_TreeViewEvents = requireAssignableTo<TypeOnly<current.TreeViewEvents>, TypeOnly<old.TreeViewEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_WithType": {"backCompat": false}
 */
declare type current_as_old_for_Interface_WithType = requireAssignableTo<TypeOnly<current.WithType>, TypeOnly<old.WithType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_AllowedTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_AllowedTypes = requireAssignableTo<TypeOnly<old.AllowedTypes>, TypeOnly<current.AllowedTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_AllowedTypes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_AllowedTypes = requireAssignableTo<TypeOnly<current.AllowedTypes>, TypeOnly<old.AllowedTypes>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ImplicitAllowedTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ImplicitAllowedTypes = requireAssignableTo<TypeOnly<old.ImplicitAllowedTypes>, TypeOnly<current.ImplicitAllowedTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ImplicitAllowedTypes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ImplicitAllowedTypes = requireAssignableTo<TypeOnly<current.ImplicitAllowedTypes>, TypeOnly<old.ImplicitAllowedTypes>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ImplicitFieldSchema": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ImplicitFieldSchema = requireAssignableTo<TypeOnly<old.ImplicitFieldSchema>, TypeOnly<current.ImplicitFieldSchema>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ImplicitFieldSchema": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ImplicitFieldSchema = requireAssignableTo<TypeOnly<current.ImplicitFieldSchema>, TypeOnly<old.ImplicitFieldSchema>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableObjectFromSchemaRecordUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InsertableObjectFromSchemaRecordUnsafe = requireAssignableTo<TypeOnly<old.InsertableObjectFromSchemaRecordUnsafe<any>>, TypeOnly<current.InsertableObjectFromSchemaRecordUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableObjectFromSchemaRecordUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InsertableObjectFromSchemaRecordUnsafe = requireAssignableTo<TypeOnly<current.InsertableObjectFromSchemaRecordUnsafe<any>>, TypeOnly<old.InsertableObjectFromSchemaRecordUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTreeFieldFromImplicitField": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InsertableTreeFieldFromImplicitField = requireAssignableTo<TypeOnly<old.InsertableTreeFieldFromImplicitField>, TypeOnly<current.InsertableTreeFieldFromImplicitField>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTreeFieldFromImplicitField": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InsertableTreeFieldFromImplicitField = requireAssignableTo<TypeOnly<current.InsertableTreeFieldFromImplicitField>, TypeOnly<old.InsertableTreeFieldFromImplicitField>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTreeFieldFromImplicitFieldUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InsertableTreeFieldFromImplicitFieldUnsafe = requireAssignableTo<TypeOnly<old.InsertableTreeFieldFromImplicitFieldUnsafe<any>>, TypeOnly<current.InsertableTreeFieldFromImplicitFieldUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTreeFieldFromImplicitFieldUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InsertableTreeFieldFromImplicitFieldUnsafe = requireAssignableTo<TypeOnly<current.InsertableTreeFieldFromImplicitFieldUnsafe<any>>, TypeOnly<old.InsertableTreeFieldFromImplicitFieldUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTreeNodeFromImplicitAllowedTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InsertableTreeNodeFromImplicitAllowedTypes = requireAssignableTo<TypeOnly<old.InsertableTreeNodeFromImplicitAllowedTypes>, TypeOnly<current.InsertableTreeNodeFromImplicitAllowedTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTreeNodeFromImplicitAllowedTypes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InsertableTreeNodeFromImplicitAllowedTypes = requireAssignableTo<TypeOnly<current.InsertableTreeNodeFromImplicitAllowedTypes>, TypeOnly<old.InsertableTreeNodeFromImplicitAllowedTypes>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTreeNodeFromImplicitAllowedTypesUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InsertableTreeNodeFromImplicitAllowedTypesUnsafe = requireAssignableTo<TypeOnly<old.InsertableTreeNodeFromImplicitAllowedTypesUnsafe<any>>, TypeOnly<current.InsertableTreeNodeFromImplicitAllowedTypesUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTreeNodeFromImplicitAllowedTypesUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InsertableTreeNodeFromImplicitAllowedTypesUnsafe = requireAssignableTo<TypeOnly<current.InsertableTreeNodeFromImplicitAllowedTypesUnsafe<any>>, TypeOnly<old.InsertableTreeNodeFromImplicitAllowedTypesUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTypedNode": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InsertableTypedNode = requireAssignableTo<TypeOnly<old.InsertableTypedNode<any>>, TypeOnly<current.InsertableTypedNode<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InsertableTypedNode": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InsertableTypedNode = requireAssignableTo<TypeOnly<current.InsertableTypedNode<any>>, TypeOnly<old.InsertableTypedNode<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes__InlineTrick": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes__InlineTrick = requireAssignableTo<TypeOnly<old.InternalTypes._InlineTrick>, TypeOnly<current.InternalTypes._InlineTrick>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes__InlineTrick": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes__InlineTrick = requireAssignableTo<TypeOnly<current.InternalTypes._InlineTrick>, TypeOnly<old.InternalTypes._InlineTrick>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_ApplyKind": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_ApplyKind = requireAssignableTo<TypeOnly<old.InternalTypes.ApplyKind<any,any,any>>, TypeOnly<current.InternalTypes.ApplyKind<any,any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_ApplyKind": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_ApplyKind = requireAssignableTo<TypeOnly<current.InternalTypes.ApplyKind<any,any,any>>, TypeOnly<old.InternalTypes.ApplyKind<any,any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_ExtractItemType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_ExtractItemType = requireAssignableTo<TypeOnly<old.InternalTypes.ExtractItemType<any>>, TypeOnly<current.InternalTypes.ExtractItemType<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_ExtractItemType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_ExtractItemType = requireAssignableTo<TypeOnly<current.InternalTypes.ExtractItemType<any>>, TypeOnly<old.InternalTypes.ExtractItemType<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_FieldHasDefault": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_FieldHasDefault = requireAssignableTo<TypeOnly<old.InternalTypes.FieldHasDefault<any>>, TypeOnly<current.InternalTypes.FieldHasDefault<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_FieldHasDefault": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_FieldHasDefault = requireAssignableTo<TypeOnly<current.InternalTypes.FieldHasDefault<any>>, TypeOnly<old.InternalTypes.FieldHasDefault<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_FieldHasDefaultUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_FieldHasDefaultUnsafe = requireAssignableTo<TypeOnly<current.InternalTypes.FieldHasDefaultUnsafe<any>>, TypeOnly<old.InternalTypes.FieldHasDefaultUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_FlattenKeys": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_FlattenKeys = requireAssignableTo<TypeOnly<old.InternalTypes.FlattenKeys<any>>, TypeOnly<current.InternalTypes.FlattenKeys<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_FlattenKeys": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_FlattenKeys = requireAssignableTo<TypeOnly<current.InternalTypes.FlattenKeys<any>>, TypeOnly<old.InternalTypes.FlattenKeys<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_FlexList": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_FlexList = requireAssignableTo<TypeOnly<old.InternalTypes.FlexList>, TypeOnly<current.InternalTypes.FlexList>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_FlexList": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_FlexList = requireAssignableTo<TypeOnly<current.InternalTypes.FlexList>, TypeOnly<old.InternalTypes.FlexList>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_FlexListToUnion": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_FlexListToUnion = requireAssignableTo<TypeOnly<old.InternalTypes.FlexListToUnion<any>>, TypeOnly<current.InternalTypes.FlexListToUnion<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_FlexListToUnion": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_FlexListToUnion = requireAssignableTo<TypeOnly<current.InternalTypes.FlexListToUnion<any>>, TypeOnly<old.InternalTypes.FlexListToUnion<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_InsertableObjectFromSchemaRecord": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_InsertableObjectFromSchemaRecord = requireAssignableTo<TypeOnly<old.InternalTypes.InsertableObjectFromSchemaRecord<any>>, TypeOnly<current.InternalTypes.InsertableObjectFromSchemaRecord<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_InsertableObjectFromSchemaRecord": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_InsertableObjectFromSchemaRecord = requireAssignableTo<TypeOnly<current.InternalTypes.InsertableObjectFromSchemaRecord<any>>, TypeOnly<old.InternalTypes.InsertableObjectFromSchemaRecord<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_InsertableObjectFromSchemaRecordUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_InsertableObjectFromSchemaRecordUnsafe = requireAssignableTo<TypeOnly<old.InternalTypes.InsertableObjectFromSchemaRecordUnsafe<any>>, TypeOnly<current.InternalTypes.InsertableObjectFromSchemaRecordUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_InsertableObjectFromSchemaRecordUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_InsertableObjectFromSchemaRecordUnsafe = requireAssignableTo<TypeOnly<current.InternalTypes.InsertableObjectFromSchemaRecordUnsafe<any>>, TypeOnly<old.InternalTypes.InsertableObjectFromSchemaRecordUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_InsertableTreeFieldFromImplicitFieldUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_InsertableTreeFieldFromImplicitFieldUnsafe = requireAssignableTo<TypeOnly<old.InternalTypes.InsertableTreeFieldFromImplicitFieldUnsafe<any>>, TypeOnly<current.InternalTypes.InsertableTreeFieldFromImplicitFieldUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_InsertableTreeFieldFromImplicitFieldUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_InsertableTreeFieldFromImplicitFieldUnsafe = requireAssignableTo<TypeOnly<current.InternalTypes.InsertableTreeFieldFromImplicitFieldUnsafe<any>>, TypeOnly<old.InternalTypes.InsertableTreeFieldFromImplicitFieldUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_InsertableTreeNodeFromImplicitAllowedTypesUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_InsertableTreeNodeFromImplicitAllowedTypesUnsafe = requireAssignableTo<TypeOnly<old.InternalTypes.InsertableTreeNodeFromImplicitAllowedTypesUnsafe<any>>, TypeOnly<current.InternalTypes.InsertableTreeNodeFromImplicitAllowedTypesUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_InsertableTreeNodeFromImplicitAllowedTypesUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_InsertableTreeNodeFromImplicitAllowedTypesUnsafe = requireAssignableTo<TypeOnly<current.InternalTypes.InsertableTreeNodeFromImplicitAllowedTypesUnsafe<any>>, TypeOnly<old.InternalTypes.InsertableTreeNodeFromImplicitAllowedTypesUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_InsertableTypedNodeUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_InsertableTypedNodeUnsafe = requireAssignableTo<TypeOnly<old.InternalTypes.InsertableTypedNodeUnsafe<any>>, TypeOnly<current.InternalTypes.InsertableTypedNodeUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_InsertableTypedNodeUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_InsertableTypedNodeUnsafe = requireAssignableTo<TypeOnly<current.InternalTypes.InsertableTypedNodeUnsafe<any>>, TypeOnly<old.InternalTypes.InsertableTypedNodeUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_NodeBuilderData": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_NodeBuilderData = requireAssignableTo<TypeOnly<old.InternalTypes.NodeBuilderData<any>>, TypeOnly<current.InternalTypes.NodeBuilderData<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_NodeBuilderData": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_NodeBuilderData = requireAssignableTo<TypeOnly<current.InternalTypes.NodeBuilderData<any>>, TypeOnly<old.InternalTypes.NodeBuilderData<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_NodeBuilderDataUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_NodeBuilderDataUnsafe = requireAssignableTo<TypeOnly<old.InternalTypes.NodeBuilderDataUnsafe<any>>, TypeOnly<current.InternalTypes.NodeBuilderDataUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_NodeBuilderDataUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_NodeBuilderDataUnsafe = requireAssignableTo<TypeOnly<current.InternalTypes.NodeBuilderDataUnsafe<any>>, TypeOnly<old.InternalTypes.NodeBuilderDataUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_NodeFromSchemaUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_NodeFromSchemaUnsafe = requireAssignableTo<TypeOnly<old.InternalTypes.NodeFromSchemaUnsafe<any>>, TypeOnly<current.InternalTypes.NodeFromSchemaUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_NodeFromSchemaUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_NodeFromSchemaUnsafe = requireAssignableTo<TypeOnly<current.InternalTypes.NodeFromSchemaUnsafe<any>>, TypeOnly<old.InternalTypes.NodeFromSchemaUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_ObjectFromSchemaRecord": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_ObjectFromSchemaRecord = requireAssignableTo<TypeOnly<old.InternalTypes.ObjectFromSchemaRecord<any>>, TypeOnly<current.InternalTypes.ObjectFromSchemaRecord<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_ObjectFromSchemaRecord": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_ObjectFromSchemaRecord = requireAssignableTo<TypeOnly<current.InternalTypes.ObjectFromSchemaRecord<any>>, TypeOnly<old.InternalTypes.ObjectFromSchemaRecord<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_ObjectFromSchemaRecordUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_ObjectFromSchemaRecordUnsafe = requireAssignableTo<TypeOnly<old.InternalTypes.ObjectFromSchemaRecordUnsafe<any>>, TypeOnly<current.InternalTypes.ObjectFromSchemaRecordUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_ObjectFromSchemaRecordUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_ObjectFromSchemaRecordUnsafe = requireAssignableTo<TypeOnly<current.InternalTypes.ObjectFromSchemaRecordUnsafe<any>>, TypeOnly<old.InternalTypes.ObjectFromSchemaRecordUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_ScopedSchemaName": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_ScopedSchemaName = requireAssignableTo<TypeOnly<old.InternalTypes.ScopedSchemaName<any,any>>, TypeOnly<current.InternalTypes.ScopedSchemaName<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_ScopedSchemaName": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_ScopedSchemaName = requireAssignableTo<TypeOnly<current.InternalTypes.ScopedSchemaName<any,any>>, TypeOnly<old.InternalTypes.ScopedSchemaName<any,any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_TreeFieldFromImplicitFieldUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_TreeFieldFromImplicitFieldUnsafe = requireAssignableTo<TypeOnly<old.InternalTypes.TreeFieldFromImplicitFieldUnsafe<any>>, TypeOnly<current.InternalTypes.TreeFieldFromImplicitFieldUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_TreeFieldFromImplicitFieldUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_TreeFieldFromImplicitFieldUnsafe = requireAssignableTo<TypeOnly<current.InternalTypes.TreeFieldFromImplicitFieldUnsafe<any>>, TypeOnly<old.InternalTypes.TreeFieldFromImplicitFieldUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_TreeNodeFromImplicitAllowedTypesUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_TreeNodeFromImplicitAllowedTypesUnsafe = requireAssignableTo<TypeOnly<old.InternalTypes.TreeNodeFromImplicitAllowedTypesUnsafe<any>>, TypeOnly<current.InternalTypes.TreeNodeFromImplicitAllowedTypesUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_TreeNodeFromImplicitAllowedTypesUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_TreeNodeFromImplicitAllowedTypesUnsafe = requireAssignableTo<TypeOnly<current.InternalTypes.TreeNodeFromImplicitAllowedTypesUnsafe<any>>, TypeOnly<old.InternalTypes.TreeNodeFromImplicitAllowedTypesUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_TreeObjectNodeUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_InternalTypes_TreeObjectNodeUnsafe = requireAssignableTo<TypeOnly<old.InternalTypes.TreeObjectNodeUnsafe<any>>, TypeOnly<current.InternalTypes.TreeObjectNodeUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_InternalTypes_TreeObjectNodeUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_InternalTypes_TreeObjectNodeUnsafe = requireAssignableTo<TypeOnly<current.InternalTypes.TreeObjectNodeUnsafe<any>>, TypeOnly<old.InternalTypes.TreeObjectNodeUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IsListener": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IsListener = requireAssignableTo<TypeOnly<old.IsListener<any>>, TypeOnly<current.IsListener<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IsListener": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IsListener = requireAssignableTo<TypeOnly<current.IsListener<any>>, TypeOnly<old.IsListener<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LazyItem": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_LazyItem = requireAssignableTo<TypeOnly<old.LazyItem>, TypeOnly<current.LazyItem>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LazyItem": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_LazyItem = requireAssignableTo<TypeOnly<current.LazyItem>, TypeOnly<old.LazyItem>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Listeners": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_Listeners = requireAssignableTo<TypeOnly<old.Listeners<any>>, TypeOnly<current.Listeners<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Listeners": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_Listeners = requireAssignableTo<TypeOnly<current.Listeners<any>>, TypeOnly<old.Listeners<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MapNodeInsertableData": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_MapNodeInsertableData = requireAssignableTo<TypeOnly<old.MapNodeInsertableData<any>>, TypeOnly<current.MapNodeInsertableData<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MapNodeInsertableData": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_MapNodeInsertableData = requireAssignableTo<TypeOnly<current.MapNodeInsertableData<any>>, TypeOnly<old.MapNodeInsertableData<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_NodeFromSchema": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_NodeFromSchema = requireAssignableTo<TypeOnly<old.NodeFromSchema<any>>, TypeOnly<current.NodeFromSchema<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_NodeFromSchema": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_NodeFromSchema = requireAssignableTo<TypeOnly<current.NodeFromSchema<any>>, TypeOnly<old.NodeFromSchema<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Off": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_Off = requireAssignableTo<TypeOnly<old.Off>, TypeOnly<current.Off>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Off": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_Off = requireAssignableTo<TypeOnly<current.Off>, TypeOnly<old.Off>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RestrictiveReadonlyRecord": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_RestrictiveReadonlyRecord = requireAssignableTo<TypeOnly<old.RestrictiveReadonlyRecord<any,any>>, TypeOnly<current.RestrictiveReadonlyRecord<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RestrictiveReadonlyRecord": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_RestrictiveReadonlyRecord = requireAssignableTo<TypeOnly<current.RestrictiveReadonlyRecord<any,any>>, TypeOnly<old.RestrictiveReadonlyRecord<any,any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RevertibleFactory": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_RevertibleFactory = requireAssignableTo<TypeOnly<current.RevertibleFactory>, TypeOnly<old.RevertibleFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TransactionConstraint": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TransactionConstraint = requireAssignableTo<TypeOnly<old.TransactionConstraint>, TypeOnly<current.TransactionConstraint>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TransactionConstraint": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TransactionConstraint = requireAssignableTo<TypeOnly<current.TransactionConstraint>, TypeOnly<old.TransactionConstraint>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeFieldFromImplicitField": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TreeFieldFromImplicitField = requireAssignableTo<TypeOnly<old.TreeFieldFromImplicitField>, TypeOnly<current.TreeFieldFromImplicitField>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeFieldFromImplicitField": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TreeFieldFromImplicitField = requireAssignableTo<TypeOnly<current.TreeFieldFromImplicitField>, TypeOnly<old.TreeFieldFromImplicitField>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeLeafValue": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TreeLeafValue = requireAssignableTo<TypeOnly<old.TreeLeafValue>, TypeOnly<current.TreeLeafValue>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeLeafValue": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TreeLeafValue = requireAssignableTo<TypeOnly<current.TreeLeafValue>, TypeOnly<old.TreeLeafValue>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeNodeFromImplicitAllowedTypes": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TreeNodeFromImplicitAllowedTypes = requireAssignableTo<TypeOnly<old.TreeNodeFromImplicitAllowedTypes>, TypeOnly<current.TreeNodeFromImplicitAllowedTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeNodeFromImplicitAllowedTypes": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TreeNodeFromImplicitAllowedTypes = requireAssignableTo<TypeOnly<current.TreeNodeFromImplicitAllowedTypes>, TypeOnly<old.TreeNodeFromImplicitAllowedTypes>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeNodeSchema": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TreeNodeSchema = requireAssignableTo<TypeOnly<current.TreeNodeSchema>, TypeOnly<old.TreeNodeSchema>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeObjectNode": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TreeObjectNode = requireAssignableTo<TypeOnly<old.TreeObjectNode<any>>, TypeOnly<current.TreeObjectNode<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeObjectNode": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TreeObjectNode = requireAssignableTo<TypeOnly<current.TreeObjectNode<any>>, TypeOnly<old.TreeObjectNode<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeObjectNodeUnsafe": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TreeObjectNodeUnsafe = requireAssignableTo<TypeOnly<old.TreeObjectNodeUnsafe<any>>, TypeOnly<current.TreeObjectNodeUnsafe<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TreeObjectNodeUnsafe": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TreeObjectNodeUnsafe = requireAssignableTo<TypeOnly<current.TreeObjectNodeUnsafe<any>>, TypeOnly<old.TreeObjectNodeUnsafe<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Unenforced": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_Unenforced = requireAssignableTo<TypeOnly<old.Unenforced<any>>, TypeOnly<current.Unenforced<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Unenforced": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_Unenforced = requireAssignableTo<TypeOnly<current.Unenforced<any>>, TypeOnly<old.Unenforced<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Unhydrated": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_Unhydrated = requireAssignableTo<TypeOnly<old.Unhydrated<any>>, TypeOnly<current.Unhydrated<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_Unhydrated": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_Unhydrated = requireAssignableTo<TypeOnly<current.Unhydrated<any>>, TypeOnly<old.Unhydrated<any>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ValidateRecursiveSchema": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ValidateRecursiveSchema = requireAssignableTo<TypeOnly<old.ValidateRecursiveSchema<any>>, TypeOnly<current.ValidateRecursiveSchema<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ValidateRecursiveSchema": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ValidateRecursiveSchema = requireAssignableTo<TypeOnly<current.ValidateRecursiveSchema<any>>, TypeOnly<old.ValidateRecursiveSchema<any>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_InternalTypes_typeNameSymbol": {"backCompat": false}
 */
declare type current_as_old_for_Variable_InternalTypes_typeNameSymbol = requireAssignableTo<TypeOnly<typeof current.InternalTypes.typeNameSymbol>, TypeOnly<typeof old.InternalTypes.typeNameSymbol>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_rollback": {"backCompat": false}
 */
declare type current_as_old_for_Variable_rollback = requireAssignableTo<TypeOnly<typeof current.rollback>, TypeOnly<typeof old.rollback>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_Tree": {"backCompat": false}
 */
declare type current_as_old_for_Variable_Tree = requireAssignableTo<TypeOnly<typeof current.Tree>, TypeOnly<typeof old.Tree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_TreeArrayNode": {"backCompat": false}
 */
declare type current_as_old_for_Variable_TreeArrayNode = requireAssignableTo<TypeOnly<typeof current.TreeArrayNode>, TypeOnly<typeof old.TreeArrayNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_typeSchemaSymbol": {"backCompat": false}
 */
declare type current_as_old_for_Variable_typeSchemaSymbol = requireAssignableTo<TypeOnly<typeof current.typeSchemaSymbol>, TypeOnly<typeof old.typeSchemaSymbol>>
