/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { strict as assert } from "assert";
import { v4, v5 } from "uuid";
import { validateAssertionError } from "@fluidframework/test-runtime-utils";
import { take } from "@fluid-internal/stochastic-test-utils";
import {
    IdCompressor,
    isFinalId,
    isLocalId,
    hasOngoingSession,
    legacySharedTreeInitialTreeId,
    LocalCompressedId,
    FinalCompressedId,
    SessionSpaceCompressedId,
    OpSpaceCompressedId,
    SessionId,
    createSessionId,
    incrementUuid,
    numericUuidFromStableId,
    stableIdFromNumericUuid,
    getIds,
    assertIsStableId,
    isStableId,
} from "../../id-compressor";
import type { IdCreationRange, UnackedLocalId } from "../../id-compressor";
import { fail } from "../../util";
import {
    createCompressor,
    performFuzzActions,
    sessionIds,
    IdCompressorTestNetwork,
    Client,
    DestinationClient,
    MetaClient,
    expectSerializes,
    roundtrip,
    sessionNumericUuids,
    makeOpGenerator,
    generateCompressedIds,
} from "./idCompressorTestUtilities";
import { expectDefined } from "./testCommon";

describe("IdCompressor", () => {
    it("detects invalid cluster sizes", () => {
        const compressor = createCompressor(Client.Client1, 1);
        assert.throws(
            () => (compressor.clusterCapacity = -1),
            (e) => validateAssertionError(e, "Clusters must have a positive capacity"),
        );
        assert.throws(
            () => (compressor.clusterCapacity = 0),
            (e) => validateAssertionError(e, "Clusters must have a positive capacity"),
        );
        assert.throws(
            () => (compressor.clusterCapacity = IdCompressor.maxClusterSize + 1),
            (e) => validateAssertionError(e, "Clusters must not exceed max cluster size"),
        );
    });

    it("reports the proper session ID", () => {
        const sessionId = createSessionId();
        const compressor = new IdCompressor(sessionId, 0);
        assert(compressor.localSessionId, sessionId);
    });

    it("accepts different numbers of reserved IDs", () => {
        for (const reservedIdCount of [0, 1, 5]) {
            const compressor = new IdCompressor(createSessionId(), reservedIdCount);
            if (reservedIdCount > 0) {
                assert.equal(
                    compressor.decompress(compressor.getReservedId(0)),
                    legacySharedTreeInitialTreeId,
                );
            }
        }
    });

    describe("ID Generation", () => {
        it("can create a compressed ID with an override", () => {
            const compressor = createCompressor(Client.Client1);
            const override = "override";
            const id = compressor.generateCompressedId(override);
            assert.equal(compressor.decompress(id), override);
        });

        it("can create compressed IDs with v5 overrides", () => {
            const compressor = createCompressor(Client.Client1);
            const uuidA = v5("foo", "7834b437-6e8c-4936-a1a3-0130b1178f17");
            const uuidB =
                uuidA.slice(0, uuidA.length - 1) +
                (uuidA.charAt(uuidA.length - 1) === "a" ? "b" : "a");
            const idA = compressor.generateCompressedId(uuidA);
            const idB = compressor.generateCompressedId(uuidB);
            assert.equal(compressor.decompress(idA), uuidA);
            assert.equal(compressor.decompress(idB), uuidB);
        });

        it("can manually create a compressed ID", () => {
            const compressor = createCompressor(Client.Client1);
            const id = compressor.generateCompressedId();
            const uuid = compressor.decompress(id);
            assert.equal(id, compressor.recompress(uuid));
        });

        it("will not decompress IDs it did not compress", () => {
            const errorMessage = "Compressed ID was not generated by this compressor";
            const compressor = createCompressor(Client.Client1);
            assert.throws(
                () => compressor.decompress(-1 as LocalCompressedId),
                (e) => validateAssertionError(e, errorMessage),
            );
            assert.throws(
                () => compressor.decompress(compressor.reservedIdCount as FinalCompressedId),
                (e) => validateAssertionError(e, errorMessage),
            );
        });

        it("will not re-compress uuids it did not originally compress", () => {
            const compressor = createCompressor(Client.Client1);
            assert.equal(
                compressor.tryRecompress("5fff846a-efd4-42fb-8b78-b32ce2672f99"),
                undefined,
            );
        });

        it("unifies duplicate overrides originating from the same compressor", () => {
            const override = "override";
            const compressor = createCompressor(Client.Client1, 3);

            // Client1 compresses a uuid
            const localId1 = compressor.generateCompressedId(override);
            const localId2 = compressor.generateCompressedId(override);
            assert.equal(
                localId1,
                localId2,
                "only one local ID should be allocated for the same override",
            );
            assert.equal(
                compressor.decompress(localId1),
                override,
                "override incorrectly associated with local ID",
            );
        });

        it("unifies overrides with sequential local IDs", () => {
            const compressor = createCompressor(Client.Client1, 3);

            // Client1 compresses a uuid
            compressor.generateCompressedId();
            const localId2 = compressor.generateCompressedId();
            const stableId2 = assertIsStableId(compressor.decompress(localId2));
            const localId3 = compressor.generateCompressedId(stableId2);
            assert.equal(
                localId3,
                localId2,
                "only one local ID should be allocated for the same sequential uuid",
            );
        });

        it("unifies overrides with sequential local IDs that sort before the reserved session UUID", () => {
            // This is a regression test for an issue where passing a sequential UUID that sorted before the reserved UUID
            // as an override created duplicate overrides in the compressor.
            const newSession = `0${legacySharedTreeInitialTreeId.slice(1)}` as SessionId;
            const compressor = new IdCompressor(newSession, 1 /* just needs to be > 0 */);

            // Client1 compresses a uuid
            compressor.generateCompressedId();
            const localId2 = compressor.generateCompressedId();
            const stableId2 = assertIsStableId(compressor.decompress(localId2));
            const localId3 = compressor.generateCompressedId(stableId2);
            assert.equal(
                localId3,
                localId2,
                "only one local ID should be allocated for the same sequential uuid",
            );
        });

        it("unifies overrides with sequential local IDs that sort after an existing override", () => {
            // This is a regression test for an issue where passing a sequential UUID that sorted after an existing override
            // as an override created duplicate overrides in the compressor.
            const newSession = `b${v4().slice(1)}` as SessionId;
            const compressor = new IdCompressor(newSession, 0);

            // Client1 compresses a uuid with some override that will sort before the session uuid
            compressor.generateCompressedId(`a${v4().slice(1)}`);
            const localId2 = compressor.generateCompressedId();
            const stableId2 = assertIsStableId(compressor.decompress(localId2));
            const localId3 = compressor.generateCompressedId(stableId2);
            assert.equal(
                localId3,
                localId2,
                "only one local ID should be allocated for the same sequential uuid",
            );
        });

        it("unifies overrides with sequential local IDs that sort after an existing cluster", () => {
            // This is a regression test for an issue where passing a sequential UUID that sorted after an existing cluster
            // as an override created duplicate overrides in the compressor.
            const newSession1 = `c${v4().slice(1)}` as SessionId;
            const newSession2 = `b${v4().slice(1)}` as SessionId;
            const compressor1 = new IdCompressor(newSession1, 0);
            const compressor2 = new IdCompressor(newSession2, 0);
            compressor1.clusterCapacity = 5;
            compressor2.clusterCapacity = 5;

            compressor2.generateCompressedId(); // one ID, enough to make a cluster
            compressor1.finalizeCreationRange(compressor2.takeNextCreationRange());

            const localId = compressor1.generateCompressedId();
            const stableId2 = assertIsStableId(compressor1.decompress(localId));
            const localId3 = compressor1.generateCompressedId(stableId2);
            assert.equal(
                localId3,
                localId,
                "only one local ID should be allocated for the same sequential uuid",
            );
        });

        it("unifies unfinalized local overrides with final IDs from a remote session", () => {
            const compressor1 = createCompressor(Client.Client1, 3);
            const compressor2 = createCompressor(Client.Client2, 3);

            const override = "override";
            const local1 = compressor1.generateCompressedId(override);
            const local2 = compressor2.generateCompressedId(override);
            const creationRange = compressor2.takeNextCreationRange();
            compressor1.finalizeCreationRange(creationRange);
            compressor2.finalizeCreationRange(creationRange);

            assert.equal(compressor1.decompress(local1), override);
            const final1 = compressor1.normalizeToOpSpace(local1);
            const final2 = compressor2.normalizeToOpSpace(local2);
            assert(isFinalId(final1));
            assert.equal(final1, final2);
        });

        it("unifies overrides with sequential local IDs that have been finalized", () => {
            const compressor = createCompressor(Client.Client1);
            const id = compressor.generateCompressedId();
            compressor.finalizeCreationRange(compressor.takeNextCreationRange());
            const stableId = assertIsStableId(compressor.decompress(id));
            const localId2 = compressor.generateCompressedId(stableId);
            assert.equal(
                localId2,
                id,
                "only one local ID should be allocated for the same sequential uuid",
            );
        });
    });

    describe("can enumerate all locally created IDs", () => {
        const idCount = 10;
        it("created without finalization", () => {
            const compressor = createCompressor(Client.Client1, idCount);
            const ids: SessionSpaceCompressedId[] = [];
            for (let i = 0; i < idCount; i++) {
                ids.push(compressor.generateCompressedId());
            }
            const returnedIds = [...compressor.getAllIdsFromLocalSession()];
            assert.deepEqual(returnedIds, ids);
        });

        it("created with finalization", () => {
            const compressor = createCompressor(Client.Client1, idCount);
            const ids: SessionSpaceCompressedId[] = [];
            for (let i = 0; i < idCount; i++) {
                if (i === Math.floor(idCount / 2)) {
                    compressor.finalizeCreationRange(compressor.takeNextCreationRange());
                }
                ids.push(compressor.generateCompressedId());
            }
            const returnedIds = [...compressor.getAllIdsFromLocalSession()];
            assert.deepEqual(returnedIds, ids);
        });

        it("created with expanded finalization", () => {
            const compressor = createCompressor(Client.Client1, idCount);
            const ids: SessionSpaceCompressedId[] = [];
            for (let i = 0; i < idCount * 4; i++) {
                if (i !== 0 && i % Math.floor(idCount / 3) === 0) {
                    compressor.finalizeCreationRange(compressor.takeNextCreationRange());
                }
                ids.push(compressor.generateCompressedId());
            }
            const returnedIds = [...compressor.getAllIdsFromLocalSession()];
            assert.deepEqual(returnedIds, ids);
        });

        it("created with overrides", () => {
            const capacity = 100;
            const compressor = createCompressor(Client.Client1, capacity);
            const ids: SessionSpaceCompressedId[] = [];
            for (let i = 0; i < capacity; i++) {
                if (i === 1) {
                    compressor.finalizeCreationRange(compressor.takeNextCreationRange());
                }
                ids.push(compressor.generateCompressedId(i % 3 === 0 ? undefined : `override${i}`));
            }
            const returnedIds = [...compressor.getAllIdsFromLocalSession()];
            assert.deepEqual(returnedIds, ids);
        });
    });

    describe("can produce a creation range", () => {
        const tests: {
            title: string;
            overrideIndices: number[];
            idCount: number;
        }[] = [
            { title: "that is empty", overrideIndices: [], idCount: 0 },
            { title: "with only sequential IDs", overrideIndices: [], idCount: 3 },
            {
                title: "with an overriding ID",
                overrideIndices: [0],
                idCount: 1,
            },
            {
                title: "with a sequential ID before an overriding ID",
                overrideIndices: [1],
                idCount: 2,
            },
            {
                title: "with a sequential ID after an overriding ID",
                overrideIndices: [0],
                idCount: 2,
            },
            {
                title: "with an overriding ID between sequential IDs",
                overrideIndices: [1],
                idCount: 3,
            },
            {
                title: "with a sequential ID between override IDs",
                overrideIndices: [0, 2],
                idCount: 3,
            },
        ];

        tests.forEach(({ title, overrideIndices, idCount }) => {
            it(title, () => {
                const compressor = createCompressor(Client.Client1);
                validateIdCreationRange(compressor, idCount, new Set(overrideIndices));
            });

            tests.forEach(
                ({ title: title2, overrideIndices: overrideIndices2, idCount: idCount2 }) => {
                    it(`${title2} after a range ${title}`, () => {
                        const compressor = createCompressor(Client.Client1);
                        const lastTaken = validateIdCreationRange(
                            compressor,
                            idCount,
                            new Set(overrideIndices),
                        );
                        validateIdCreationRange(
                            compressor,
                            idCount2,
                            new Set(overrideIndices2),
                            lastTaken,
                        );
                    });
                },
            );
        });

        function validateIdCreationRange(
            compressor: IdCompressor,
            idCount: number,
            overrideIndices: Set<number>,
            lastTakenId = 0 as UnackedLocalId,
        ): UnackedLocalId {
            const overrides: [SessionSpaceCompressedId, string?][] = [];
            for (let i = 0; i < idCount; i++) {
                const override = overrideIndices.has(i) ? v4() : undefined;
                const id = compressor.generateCompressedId(override);
                overrides.push([id, override]);
            }
            const range = compressor.takeNextCreationRange();
            let newLastTakenId = lastTakenId;
            let idsActual = getIds(range);
            if (overrides.length === 0) {
                assert.equal(idsActual, undefined);
            } else {
                idsActual = expectDefined(idsActual);
                assert.equal(overrides[0][0], idsActual.first);
                assert.equal(overrides[overrides.length - 1][0], idsActual.last);
                newLastTakenId = idsActual.last;
            }

            return newLastTakenId;
        }
    });

    describe("Finalizing", () => {
        it("can finalize multiple overrides into the same cluster using different ranges", () => {
            const compressor = createCompressor(Client.Client1);
            const override1 = "override1";
            const override2 = "override2";
            const id1 = compressor.generateCompressedId(override1);
            compressor.generateCompressedId();
            const range1 = compressor.takeNextCreationRange();
            const id2 = compressor.generateCompressedId(override2);
            const range2 = compressor.takeNextCreationRange();
            compressor.finalizeCreationRange(range1);
            compressor.finalizeCreationRange(range2);
            const finalId1 = compressor.normalizeToOpSpace(id1);
            const finalId2 = compressor.normalizeToOpSpace(id2);
            assert(isFinalId(finalId1));
            assert(isFinalId(finalId2));
            assert.equal(compressor.decompress(finalId1), override1);
            assert.equal(compressor.decompress(finalId2), override2);
        });

        it("prevents attempts to finalize ranges twice", () => {
            const rangeCompressor = createCompressor(Client.Client1);
            generateCompressedIds(rangeCompressor, 3);
            const batchRange = rangeCompressor.takeNextCreationRange();
            rangeCompressor.finalizeCreationRange(batchRange);
            assert.throws(
                () => rangeCompressor.finalizeCreationRange(batchRange),
                (e) => validateAssertionError(e, "Ranges finalized out of order."),
            );

            // Make a new compressor, as the first one will be left in a bad state
            const explicitCompressor = createCompressor(Client.Client1);
            explicitCompressor.generateCompressedId();
            explicitCompressor.generateCompressedId("override");
            const explicitRange = explicitCompressor.takeNextCreationRange();
            explicitCompressor.finalizeCreationRange(explicitRange);
            assert.throws(
                () => explicitCompressor.finalizeCreationRange(explicitRange),
                (e) => validateAssertionError(e, "Ranges finalized out of order."),
            );
        });

        it("prevents attempts to finalize ranges out of order", () => {
            const compressor = createCompressor(Client.Client1);
            compressor.generateCompressedId();
            compressor.takeNextCreationRange();
            compressor.generateCompressedId();
            const secondRange = compressor.takeNextCreationRange();
            assert.throws(
                () => compressor.finalizeCreationRange(secondRange),
                (e) => validateAssertionError(e, "Ranges finalized out of order."),
            );
        });

        it("prevents finalizing unacceptably enormous amounts of ID allocation", () => {
            const compressor1 = createCompressor(Client.Client1);
            const integerLargerThanHalfMax = Math.round((Number.MAX_SAFE_INTEGER / 3) * 2);
            const midPoint = -integerLargerThanHalfMax as UnackedLocalId;
            const largeRange1: IdCreationRange = {
                sessionId: sessionIds.get(Client.Client2),
                ids: { first: -1 as UnackedLocalId, last: midPoint },
            };
            compressor1.finalizeCreationRange(largeRange1);
            const largeRange2: IdCreationRange = {
                sessionId: sessionIds.get(Client.Client2),
                ids: {
                    first: (midPoint - 1) as UnackedLocalId,
                    last: (-Number.MAX_SAFE_INTEGER - 2) as UnackedLocalId,
                },
            };
            assert.throws(
                () => compressor1.finalizeCreationRange(largeRange2),
                (e) =>
                    validateAssertionError(
                        e,
                        "The number of allocated final IDs must not exceed the JS maximum safe integer.",
                    ),
            );
        });
    });

    describe("Compression", () => {
        it("can re-compress a sequential uuid it generated", () => {
            const compressor = createCompressor(Client.Client1);
            const id = compressor.generateCompressedId();
            const uuid = compressor.decompress(id);
            assert.equal(compressor.recompress(uuid), id);
            compressor.finalizeCreationRange(compressor.takeNextCreationRange());
            assert.equal(compressor.recompress(uuid), id);
        });

        it("can re-compress an override", () => {
            const compressor = createCompressor(Client.Client1);
            const override = "override";
            const id = compressor.generateCompressedId(override);
            assert.equal(compressor.recompress(override), id);
            compressor.finalizeCreationRange(compressor.takeNextCreationRange());
            assert.equal(compressor.recompress(override), id);
        });

        it("can re-compress overrides from a remote client it has finalized", () => {
            const compressor = createCompressor(Client.Client1);
            const id = compressor.generateCompressedId();
            const override = "override";
            compressor.generateCompressedId(override);
            const uuid = compressor.decompress(id);

            const compressor2 = createCompressor(Client.Client2);
            compressor2.finalizeCreationRange(compressor.takeNextCreationRange());
            const finalId1 = compressor2.recompress(uuid);
            const finalId2 = compressor2.recompress(override);
            if (finalId1 === undefined || finalId2 === undefined) {
                assert.fail();
            }
            assert(isFinalId(finalId1));
            assert(isFinalId(finalId2));
        });

        it("will not compress an override it never compressed or finalized", () => {
            const compressor = createCompressor(Client.Client1, 5);
            // Leading zeroes to exploit calls to getOrNextLower on uuid maps, as it will be before test session uuids
            const override = "override";
            assert.equal(compressor.tryRecompress(override), undefined);
            assert.equal(
                compressor.tryRecompress(
                    stableIdFromNumericUuid(sessionNumericUuids.get(Client.Client1), 1),
                ),
                undefined,
            );
            compressor.generateCompressedId(override);
            generateCompressedIds(compressor, 2);
            compressor.finalizeCreationRange(compressor.takeNextCreationRange());
            assert.equal(
                compressor.tryRecompress(
                    stableIdFromNumericUuid(sessionNumericUuids.get(Client.Client1), 4),
                ),
                undefined,
            );
        });

        it("can re-compress an eagerly generated final ID that is not finalized", () => {
            const compressor = createCompressor(Client.Client1, 5);
            compressor.generateCompressedId();
            compressor.finalizeCreationRange(compressor.takeNextCreationRange());
            const finalId = compressor.generateCompressedId();
            assert(isFinalId(finalId));
            const stableId = stableIdFromNumericUuid(
                numericUuidFromStableId(sessionIds.get(Client.Client1)),
                1,
            );
            assert.equal(compressor.recompress(stableId), finalId);
        });
    });

    describe("Decompression", () => {
        it("can decompress a local ID before and after finalizing", () => {
            const compressor = createCompressor(Client.Client1);
            const id = compressor.generateCompressedId();
            const uuid = compressor.decompress(id);
            assert(isStableId(uuid));
            compressor.finalizeCreationRange(compressor.takeNextCreationRange());
            assert.equal(compressor.decompress(id), uuid);
        });

        it("can decompress reserved IDs", () => {
            // This is a glass box test in that it increments UUIDs
            const compressor = createCompressor(Client.Client1);
            assert.equal(
                compressor.decompress(compressor.getReservedId(0)),
                legacySharedTreeInitialTreeId,
            );
            const reservedSessionUuid = numericUuidFromStableId(
                assertIsStableId(compressor.decompress(compressor.getReservedId(1))),
            );
            for (let i = 1; i < compressor.reservedIdCount; i++) {
                const reservedId = compressor.getReservedId(i);
                const stable = compressor.decompress(reservedId);
                assert(stable, stableIdFromNumericUuid(incrementUuid(reservedSessionUuid, i - 1)));
                const finalIdForReserved = compressor.recompress(stable);
                assert(!isLocalId(finalIdForReserved));
                assert.equal(finalIdForReserved, reservedId);
            }
            const outOfBoundsError = "Reserved Id index out of bounds";
            assert.throws(
                () => compressor.getReservedId(-1),
                (e) => validateAssertionError(e, outOfBoundsError),
            );
            assert.throws(
                () => compressor.getReservedId(compressor.reservedIdCount),
                (e) => validateAssertionError(e, outOfBoundsError),
            );
        });

        it("can decompress a final ID", () => {
            const compressor = createCompressor(Client.Client1);
            const id = compressor.generateCompressedId();
            compressor.finalizeCreationRange(compressor.takeNextCreationRange());
            const finalId = compressor.normalizeToOpSpace(id);
            if (isLocalId(finalId)) {
                assert.fail("Op space ID was finalized but is local");
            }
            const uuid = compressor.decompress(finalId);
            assert(isStableId(uuid));
        });

        it("can decompress a final ID with an override", () => {
            const compressor = createCompressor(Client.Client1);
            const override = "override";
            const id = compressor.generateCompressedId(override);
            const range = compressor.takeNextCreationRange();
            compressor.finalizeCreationRange(range);
            const finalId = compressor.normalizeToOpSpace(id);
            if (isLocalId(finalId)) {
                assert.fail("Op space ID was finalized but is local");
            }
            const uuid = compressor.decompress(finalId);
            assert.equal(uuid, override);
        });

        it("can decompress an override that is an UUID", () => {
            const compressor = createCompressor(Client.Client1, 5);
            const uuid = "d1302ab1-3c08-4e79-a49a-4c39ac369c16";
            const id = compressor.generateCompressedId(uuid);
            assert.equal(compressor.decompress(id), uuid);
        });

        it("properly sorts UUID-like overrides separately from true UUIDs", () => {
            // This is a glass box test that ensures overrides which would sort in between a cluster base UUID and an UUID higher up in the
            // same cluster are not accidentally retrieved during cluster ID lookup.
            const compressor = createCompressor(Client.Client1, 5);
            const override = `${compressor.localSessionId}6`;
            const id = compressor.generateCompressedId();
            compressor.generateCompressedId(override);
            const decompressedId = compressor.decompress(id);
            assert.equal(compressor.recompress(decompressedId), id);
        });

        it("can decompress an override that starts with the reserved prefix character", () => {
            const compressor = createCompressor(Client.Client1, 5);
            const override = `\ue15e${compressor.localSessionId}`;
            const id = compressor.generateCompressedId(override);
            assert.equal(compressor.decompress(id), override);
        });

        it("can decompress an eagerly generated final ID that is not finalized", () => {
            const compressor = createCompressor(Client.Client1, 5);
            compressor.generateCompressedId();
            compressor.finalizeCreationRange(compressor.takeNextCreationRange());
            const finalId = compressor.generateCompressedId();
            assert(isFinalId(finalId));
            assert.equal(
                compressor.decompress(finalId),
                stableIdFromNumericUuid(numericUuidFromStableId(sessionIds.get(Client.Client1)), 1),
            );
        });
    });

    describe("Normalization", () => {
        it("can normalize a local ID to op space before finalizing", () => {
            const compressor = createCompressor(Client.Client1);
            const id = compressor.generateCompressedId();
            const normalized = compressor.normalizeToOpSpace(id);
            assert(isLocalId(id));
            assert.equal(id, normalized);
        });

        it("can normalize a local ID to op space after finalizing", () => {
            const compressor = createCompressor(Client.Client1);
            const id = compressor.generateCompressedId();
            compressor.finalizeCreationRange(compressor.takeNextCreationRange());
            const normalized = compressor.normalizeToOpSpace(id);
            assert(isFinalId(normalized));
            assert.notEqual(id, normalized);
        });

        it("can normalize an eagerly generated final ID", () => {
            const compressor = createCompressor(Client.Client1, 5);
            compressor.generateCompressedId();
            compressor.finalizeCreationRange(compressor.takeNextCreationRange());
            const eagerFinalId = compressor.generateCompressedId();
            assert(isFinalId(eagerFinalId));
            const opNormalized = compressor.normalizeToOpSpace(eagerFinalId);
            assert.equal(eagerFinalId, opNormalized);
            const sessionNormalized = compressor.normalizeToSessionSpace(
                opNormalized,
                compressor.localSessionId,
            );
            assert.equal(sessionNormalized, opNormalized);
        });

        it("cannot normalize a remote ID to session space if it has not been finalized", () => {
            const compressor1 = createCompressor(Client.Client1);
            const compressor2 = createCompressor(Client.Client2);
            const normalized = compressor1.normalizeToOpSpace(compressor1.generateCompressedId());
            assert.throws(
                () => compressor2.normalizeToSessionSpace(normalized, compressor1.localSessionId),
                (e) =>
                    validateAssertionError(
                        e,
                        "No IDs have ever been finalized by the supplied session.",
                    ),
            );
        });

        it("can normalize local and final IDs from a remote session to session space", () => {
            const compressor1 = createCompressor(Client.Client1);
            const compressor2 = createCompressor(Client.Client2);
            const id = compressor1.generateCompressedId();
            const normalizedLocal = compressor1.normalizeToOpSpace(id);
            const range = compressor1.takeNextCreationRange();
            compressor1.finalizeCreationRange(range);
            const normalizedFinal = compressor1.normalizeToOpSpace(id);
            compressor2.finalizeCreationRange(range);
            assert(isLocalId(normalizedLocal));
            assert(isFinalId(normalizedFinal));
            assert.equal(
                compressor2.normalizeToSessionSpace(normalizedFinal, compressor1.localSessionId),
                normalizedFinal,
            );
            assert.equal(
                compressor2.normalizeToSessionSpace(normalizedLocal, compressor1.localSessionId),
                normalizedFinal,
            );
        });

        it("can normalize a final ID created by the local session but sent in another client's op space", () => {
            // Regression test for the situation in which a client creates a final ID and another client references
            // that final ID in a message back to the creating client. The creating client will normalize it and
            // pass the session ID of the remote (non-creating) client. This should be handled correctly.
            const compressor = createCompressor(Client.Client1, 5);
            const compressor2 = createCompressor(Client.Client2, 5);
            const id = compressor.generateCompressedId();
            const creationRange = compressor.takeNextCreationRange();
            compressor.finalizeCreationRange(creationRange);
            compressor2.finalizeCreationRange(creationRange);
            const idInClient2OpSpace = compressor2.normalizeToOpSpace(
                compressor2.normalizeToSessionSpace(
                    compressor.normalizeToOpSpace(id),
                    compressor.localSessionId,
                ),
            );
            const normalizedToClient1SessionSpace = compressor.normalizeToSessionSpace(
                idInClient2OpSpace,
                compressor2.localSessionId,
            );
            assert.equal(normalizedToClient1SessionSpace, id);
        });
    });

    describe("Serialization", () => {
        it("can serialize an empty compressor", () => {
            const compressor = createCompressor(Client.Client1);
            const [serializedNoSession, serializedWithSession] = expectSerializes(compressor);
            assert.equal(
                serializedWithSession.clusters.length,
                0,
                "reserved cluster should not be serialized",
            );
            assert.equal(
                serializedNoSession.clusters.length,
                0,
                "reserved cluster should not be serialized",
            );
        });

        it("correctly deserializes and resumes a session", () => {
            const compressor1 = createCompressor(Client.Client1, undefined);
            const compressor2 = createCompressor(Client.Client2, undefined);
            compressor1.generateCompressedId();
            const creationRange = compressor1.takeNextCreationRange();
            compressor1.finalizeCreationRange(creationRange);
            compressor2.finalizeCreationRange(creationRange);
            const [_, serializedWithSession] = expectSerializes(compressor1);
            const compressorResumed = IdCompressor.deserialize(serializedWithSession);
            compressorResumed.generateCompressedId();
            const range2 = compressorResumed.takeNextCreationRange();
            compressor1.finalizeCreationRange(range2);
            compressor2.finalizeCreationRange(range2);
            assert(
                IdCompressor.deserialize(compressor1.serialize(false), createSessionId()).equals(
                    IdCompressor.deserialize(compressor2.serialize(false), createSessionId()),
                    false, // don't compare local state
                ),
            );
        });
    });

    // No validation, as these leave the network in a broken state
    describeNetworkNoValidation("detects UUID collision", (itNetwork) => {
        itNetwork(
            "when a client requests an override that is an UUID reserved for later allocation by a cluster",
            2,
            (network) => {
                network.allocateAndSendIds(Client.Client2, 1);
                network.deliverOperations(Client.Client1);
                const compressor2 = network.getCompressor(Client.Client2);
                const id = network.getIdLog(Client.Client2)[0].id;
                const uuid = assertIsStableId(compressor2.decompress(id));
                const nextUuid = stableIdFromNumericUuid(numericUuidFromStableId(uuid), 1);
                // TODO:#283: Re-assess test when full unification is implemented
                assert.doesNotThrow(
                    () => network.allocateAndSendIds(Client.Client1, 1, { 0: nextUuid }),
                    Error(`Override '${nextUuid}' collides with another allocated UUID.`),
                );
            },
        );

        itNetwork(
            "when a new cluster is allocated whose base UUID collides with an existing override",
            2,
            (network) => {
                network.allocateAndSendIds(Client.Client1, 1);
                network.deliverOperations(DestinationClient.All);
                const compressor1 = network.getCompressor(Client.Client1);
                const id = network.getIdLog(Client.Client1)[0].id;
                const uuid = assertIsStableId(compressor1.decompress(id));
                const nextUuid = stableIdFromNumericUuid(numericUuidFromStableId(uuid), 2);
                network.allocateAndSendIds(Client.Client1, 1, { 0: nextUuid });
                network.allocateAndSendIds(Client.Client2, 1);
                network.deliverOperations(DestinationClient.All);
                network.allocateAndSendIds(Client.Client1, 1); // new cluster
                assert.throws(
                    () => network.deliverOperations(Client.Client1),
                    (e) =>
                        validateAssertionError(
                            e,
                            `Override '${nextUuid}' collides with another allocated UUID.`,
                        ),
                );
            },
        );

        itNetwork("detects colliding override UUIDs when expanding a cluster", 1, (network) => {
            // This is a glass box test in that it is testing cluster expansion
            network.allocateAndSendIds(Client.Client1, 1);
            network.deliverOperations(DestinationClient.All);
            const compressor1 = network.getCompressor(Client.Client1);
            const id = network.getIdLog(Client.Client1)[0].id;
            const uuid = assertIsStableId(compressor1.decompress(id));
            const expansion = 3;
            const nextUuid = stableIdFromNumericUuid(numericUuidFromStableId(uuid), expansion);
            network.allocateAndSendIds(Client.Client1, expansion, { 0: nextUuid });
            assert.throws(
                () => network.deliverOperations(DestinationClient.All),
                (e) =>
                    validateAssertionError(
                        e,
                        `Override '${nextUuid}' collides with another allocated UUID.`,
                    ),
            );
        });
    });

    describeNetwork("Networked", (itNetwork) => {
        itNetwork(
            "upholds the invariant that IDs always decompress to the same UUID",
            2,
            (network) => {
                network.allocateAndSendIds(Client.Client1, 5, {
                    1: "override1",
                });
                network.allocateAndSendIds(Client.Client2, 5, {
                    2: "override2",
                });
                network.allocateAndSendIds(Client.Client3, 5, {
                    3: "override3",
                });

                const preAckLocals = new Map<Client, [SessionSpaceCompressedId, string][]>();
                for (const [client, compressor] of network.getTargetCompressors(MetaClient.All)) {
                    const locals: [SessionSpaceCompressedId, string][] = [];
                    for (const idData of network.getIdLog(client)) {
                        locals.push([idData.id, compressor.decompress(idData.id)]);
                    }
                    preAckLocals.set(client, locals);
                }

                // Ack all IDs
                network.deliverOperations(DestinationClient.All);

                for (const [client, compressor] of network.getTargetCompressors(MetaClient.All)) {
                    const preAckLocalIds =
                        preAckLocals.get(client) ?? fail("Expected preack locals for client");
                    let i = 0;
                    for (const idData of network.getIdLog(client)) {
                        if (idData.originatingClient === client) {
                            assert(!isFinalId(idData.id));
                            const currentUuid = compressor.decompress(idData.id);
                            assert.equal(currentUuid, preAckLocalIds[i % preAckLocalIds.length][1]);
                            i++;
                        }
                    }
                }
            },
        );

        itNetwork("can normalize session space IDs to op space", 5, (network) => {
            const clusterCapacity = 5;
            const idCount = clusterCapacity * 2;
            for (let i = 0; i < idCount; i++) {
                network.allocateAndSendIds(Client.Client1, 1);
                network.allocateAndSendIds(Client.Client2, 1);
                network.allocateAndSendIds(Client.Client3, 1);
            }

            for (const [client, compressor] of network.getTargetCompressors(MetaClient.All)) {
                for (const idData of network.getIdLog(client)) {
                    assert.equal(idData.originatingClient, client);
                    assert(isLocalId(compressor.normalizeToOpSpace(idData.id)));
                }
            }

            network.deliverOperations(DestinationClient.All);

            for (const [client, compressor] of network.getTargetCompressors(MetaClient.All)) {
                for (const idData of network.getIdLog(client)) {
                    assert(isFinalId(compressor.normalizeToOpSpace(idData.id)));
                }
            }
        });

        itNetwork(
            "can normalize local op space IDs from a local session to session space IDs",
            (network) => {
                const compressor = network.getCompressor(Client.Client1);
                network.allocateAndSendIds(Client.Client1, 1);
                network.deliverOperations(Client.Client1);
                const sessionSpaceIds = network.getIdLog(Client.Client1);
                const opSpaceId = compressor.normalizeToOpSpace(sessionSpaceIds[0].id);
                const sessionSpaceId = compressor.normalizeToSessionSpace(
                    opSpaceId,
                    compressor.localSessionId,
                );
                assert(isFinalId(opSpaceId));
                assert(isLocalId(sessionSpaceId));
            },
        );

        itNetwork(
            "can normalize local op space IDs from a remote session to session space IDs",
            (network) => {
                const compressor1 = network.getCompressor(Client.Client1);
                const compressor2 = network.getCompressor(Client.Client2);
                const opSpaceIds = network.allocateAndSendIds(Client.Client1, 1);
                // Mimic sending a reference to an ID that hasn't been acked yet, such as in a slow network
                const id = opSpaceIds[0];
                const getSessionNormalizedId = () =>
                    compressor2.normalizeToSessionSpace(id, compressor1.localSessionId);
                assert.throws(getSessionNormalizedId, (e) =>
                    validateAssertionError(
                        e,
                        "No IDs have ever been finalized by the supplied session.",
                    ),
                );
                network.deliverOperations(Client.Client2);
                assert(isFinalId(getSessionNormalizedId()));
            },
        );

        itNetwork("unifies duplicate overrides", 3, (network) => {
            const override = "override";
            const compressor1 = network.getCompressor(Client.Client1);
            const compressor2 = network.getCompressor(Client.Client2);
            const compressor3 = network.getCompressor(Client.Client3);
            const clusterCapacity = compressor1.clusterCapacity;

            // Ensure some clusters exist to avoid simple case of empty clusters
            network.allocateAndSendIds(Client.Client1, clusterCapacity);
            network.allocateAndSendIds(Client.Client2, clusterCapacity);
            network.allocateAndSendIds(Client.Client3, clusterCapacity);
            network.deliverOperations(DestinationClient.All);

            const range1 = network.allocateAndSendIds(Client.Client1, 1, { 0: override });
            const overrides1 = expectDefined(getIds(range1)?.overrides);
            const id1 = compressor1.normalizeToSessionSpace(
                overrides1[0][0],
                compressor1.localSessionId,
            );
            const opNormalizedLocal1 = compressor1.normalizeToOpSpace(id1);
            assert(isLocalId(opNormalizedLocal1));
            assert(!isFinalId(id1));

            network.deliverOperations(DestinationClient.Client1);

            const finalId1 = compressor1.normalizeToOpSpace(id1);
            assert(isFinalId(finalId1));

            const range2 = network.allocateAndSendIds(Client.Client2, 2, { 1: override });
            const overrides2 = expectDefined(getIds(range2)?.overrides);
            const id2 = compressor2.normalizeToSessionSpace(
                overrides2[0][0],
                compressor2.localSessionId,
            );
            const opNormalizedLocal2 = compressor2.normalizeToOpSpace(id2);
            assert(isLocalId(opNormalizedLocal2));
            assert(!isFinalId(id2));

            network.allocateAndSendIds(Client.Client3, 1);
            network.deliverOperations(DestinationClient.All);

            const finalId2 = compressor2.normalizeToOpSpace(id2);
            assert(isFinalId(finalId2));

            assert.equal(finalId1, finalId2);

            assert.equal(compressor1.normalizeToOpSpace(id1), finalId1);
            assert.equal(
                compressor1.normalizeToSessionSpace(finalId1, compressor1.localSessionId),
                id1,
            );
            assert.equal(
                compressor1.normalizeToSessionSpace(opNormalizedLocal2, compressor2.localSessionId),
                id1,
            );
            assert.equal(compressor1.decompress(id1), override);
            assert.equal(compressor1.decompress(finalId1), override);
            assert.equal(compressor1.recompress(override), id1);

            assert.equal(compressor2.normalizeToOpSpace(id2), finalId2);
            assert.equal(
                compressor2.normalizeToSessionSpace(finalId1, compressor1.localSessionId),
                id2,
            );
            assert.equal(
                compressor2.normalizeToSessionSpace(opNormalizedLocal1, compressor1.localSessionId),
                id2,
            );
            assert.equal(compressor2.decompress(id2), override);
            assert.equal(compressor2.decompress(finalId2), override);
            assert.equal(compressor2.tryRecompress(override), id2);

            assert.equal(
                compressor3.normalizeToSessionSpace(finalId1, compressor1.localSessionId),
                finalId1,
            );
            assert.equal(
                compressor3.normalizeToSessionSpace(opNormalizedLocal1, compressor1.localSessionId),
                finalId1,
            );
            assert.equal(
                compressor3.normalizeToSessionSpace(opNormalizedLocal2, compressor2.localSessionId),
                finalId1,
            );
            assert.equal(compressor3.decompress(finalId1), override);
            assert.equal(compressor3.recompress(override), finalId1);
        });

        itNetwork("maintains alignment after unifying duplicate overrides", 3, (network) => {
            const override = "override";
            network.allocateAndSendIds(Client.Client1, 1, { 0: override });
            network.allocateAndSendIds(Client.Client2, 2, { 1: override });
            network.allocateAndSendIds(Client.Client1, 5);
            network.allocateAndSendIds(Client.Client2, 5);
            expectSequencedLogsAlign(network, Client.Client1, Client.Client2, 1);
        });

        function expectSequencedLogsAlign(
            network: IdCompressorTestNetwork,
            client1: Client,
            client2: Client,
            numUnifications = 0,
        ): void {
            network.deliverOperations(DestinationClient.All);
            assert(client1 !== client2, "Clients must not be the same");
            const log1 = network.getSequencedIdLog(client1);
            const log2 = network.getSequencedIdLog(client2);
            assert.equal(log1.length, log2.length);
            const compressor1 = network.getCompressor(client1);
            const compressor2 = network.getCompressor(client2);
            const ids = new Set<OpSpaceCompressedId>();
            const uuidsOrOverrides = new Set<string>();
            for (let i = 0; i < log1.length; i++) {
                const data1 = log1[i];
                const id1 = compressor1.normalizeToOpSpace(data1.id);
                const id2 = compressor2.normalizeToOpSpace(log2[i].id);
                assert(isFinalId(id1));
                ids.add(id1);
                assert.equal(id1, id2);
                const uuidOrOverride1 = compressor1.decompress(id1);
                uuidsOrOverrides.add(uuidOrOverride1);
                if (data1.expectedOverride === undefined) {
                    assert(isStableId(uuidOrOverride1));
                }
                assert.equal(uuidOrOverride1, compressor2.decompress(id2));
            }
            const expectedSize = log1.length - numUnifications;
            assert.equal(ids.size, expectedSize);
            assert.equal(uuidsOrOverrides.size, expectedSize);
        }

        itNetwork("produces ID spaces correctly", (network) => {
            // This test asserts that IDs returned from IDCompressor APIs are correctly encoded as either local or final.
            // This is a glass box test in that it assumes the negative/positive encoding of CompressedIds (negative = local, positive = final).
            const compressor1 = network.getCompressor(Client.Client1);

            // Client 1 makes two IDs, two explicit (one with an override) and one sequential
            network.allocateAndSendIds(Client.Client1, 3, {
                1: "override1",
            });

            network.getIdLog(Client.Client1).forEach(({ id }) => assert(isLocalId(id)));

            // Client 1's IDs have not been acked so have no op space equivalent
            network
                .getIdLog(Client.Client1)
                .forEach((idData) => assert(isLocalId(compressor1.normalizeToOpSpace(idData.id))));

            // Client 1's IDs are acked
            network.deliverOperations(Client.Client1);
            network.getIdLog(Client.Client1).forEach(({ id }) => assert(isLocalId(id)));

            // Client 3 makes two IDs, two explicit (one with an override) and one sequential
            network.allocateAndSendIds(Client.Client2, 3, {
                1: "override2",
            });

            network.getIdLog(Client.Client2).forEach(({ id }) => assert(isLocalId(id)));

            // Client 1 receives Client 2's IDs
            network.deliverOperations(Client.Client1);

            network
                .getIdLog(Client.Client1)
                .slice(-3)
                .forEach(({ id }) => assert(isFinalId(id)));

            // All IDs have been acked or are from another client, and therefore have a final form in op space
            network
                .getIdLog(Client.Client1)
                .forEach(({ id }) => assert(isFinalId(compressor1.normalizeToOpSpace(id))));

            // Compression should preserve ID space correctness
            network.getIdLog(Client.Client1).forEach((idData) => {
                const roundtripped = compressor1.recompress(compressor1.decompress(idData.id));
                assert.equal(Math.sign(roundtripped), Math.sign(idData.id));
            });

            network.getIdLog(Client.Client1).forEach((idData) => {
                const opNormalized = compressor1.normalizeToOpSpace(idData.id);
                assert.equal(
                    Math.sign(compressor1.normalizeToSessionSpace(opNormalized, idData.sessionId)),
                    Math.sign(idData.id),
                );
            });
        });

        itNetwork("produces consistent IDs with large fuzz input", (network) => {
            const generator = take(1000, makeOpGenerator({ includeOverrides: true }));
            performFuzzActions(generator, network, 1984, undefined, true, (n) =>
                n.assertNetworkState(),
            );
            network.deliverOperations(DestinationClient.All);
        });

        itNetwork("can set the cluster size via constructor", 2, (network) => {
            const compressor = network.getCompressor(Client.Client1);
            const compressor2 = network.getCompressor(Client.Client2);
            network.allocateAndSendIds(Client.Client1, 1);
            const opSpaceIds = network.allocateAndSendIds(Client.Client2, 2);
            network.deliverOperations(DestinationClient.All);
            // Glass box test, as it knows the order of final IDs
            assert.equal(
                compressor.normalizeToSessionSpace(opSpaceIds[0], compressor2.localSessionId),
                compressor.reservedIdCount + compressor.clusterCapacity,
            );
        });

        itNetwork("can set the cluster size via API", 2, (network) => {
            const compressor = network.getCompressor(Client.Client1);
            const compressor2 = network.getCompressor(Client.Client2);
            const initialClusterCapacity = compressor.clusterCapacity;
            network.allocateAndSendIds(Client.Client1, initialClusterCapacity);
            network.allocateAndSendIds(Client.Client2, initialClusterCapacity);
            network.enqueueCapacityChange(5);
            network.allocateAndSendIds(Client.Client1, 1);
            const opSpaceIds = network.allocateAndSendIds(Client.Client2, 1);
            network.deliverOperations(DestinationClient.All);
            // Glass box test, as it knows the order of final IDs
            assert.equal(
                compressor.normalizeToSessionSpace(opSpaceIds[0], compressor2.localSessionId),
                compressor.reservedIdCount +
                    initialClusterCapacity * 2 +
                    compressor.clusterCapacity,
            );
        });

        itNetwork("does not decompress ids for empty parts of clusters", 2, (network) => {
            // This is a glass box test in that it creates a final ID outside of the ID compressor
            network.allocateAndSendIds(Client.Client1, 1);
            network.deliverOperations(DestinationClient.All);
            const id = network.getSequencedIdLog(Client.Client2)[0].id;
            assert(isFinalId(id));
            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
            const emptyId = (id + 1) as FinalCompressedId;
            assert.throws(
                () => network.getCompressor(Client.Client2).decompress(emptyId),
                (e) =>
                    validateAssertionError(e, "Compressed ID was not generated by this compressor"),
            );
        });

        describe("Eager final ID allocation", () => {
            it("eagerly allocates final IDs when cluster creation has been finalized", () => {
                const compressor = createCompressor(Client.Client1, 5);
                const localId1 = compressor.generateCompressedId();
                assert(isLocalId(localId1));
                const localId2 = compressor.generateCompressedId();
                assert(isLocalId(localId2));
                compressor.finalizeCreationRange(compressor.takeNextCreationRange());
                const finalId3 = compressor.generateCompressedId();
                assert(isFinalId(finalId3));
                const finalId4 = compressor.generateCompressedId();
                assert(isFinalId(finalId4));
                const finalId5 = compressor.generateCompressedId();
                assert(isFinalId(finalId5));
                const localId6 = compressor.generateCompressedId();
                assert(isLocalId(localId6));

                compressor.finalizeCreationRange(compressor.takeNextCreationRange());

                const opSpaceId1 = compressor.normalizeToOpSpace(localId1);
                const opSpaceId2 = compressor.normalizeToOpSpace(localId2);
                const opSpaceId3 = compressor.normalizeToOpSpace(finalId3);
                const opSpaceId4 = compressor.normalizeToOpSpace(finalId4);
                const opSpaceId5 = compressor.normalizeToOpSpace(finalId5);
                const opSpaceId6 = compressor.normalizeToOpSpace(localId6);

                assert(isFinalId(opSpaceId1));
                assert(isFinalId(opSpaceId2));
                assert(isFinalId(opSpaceId3) && opSpaceId3 === finalId3);
                assert(isFinalId(opSpaceId4) && opSpaceId4 === finalId4);
                assert(isFinalId(opSpaceId5) && opSpaceId5 === finalId5);
                assert(isFinalId(opSpaceId6));

                assert.equal(compressor.normalizeToSessionSpace(opSpaceId1), localId1);
                assert.equal(compressor.normalizeToSessionSpace(opSpaceId2), localId2);
                assert.equal(compressor.normalizeToSessionSpace(opSpaceId3), finalId3);
                assert.equal(compressor.normalizeToSessionSpace(opSpaceId4), finalId4);
                assert.equal(compressor.normalizeToSessionSpace(opSpaceId5), finalId5);
                assert.equal(compressor.normalizeToSessionSpace(opSpaceId6), localId6);
            });

            it("does not eagerly allocate final IDs for IDs with overrides", () => {
                const compressor = createCompressor(Client.Client1, 5);
                const localId1 = compressor.generateCompressedId();
                compressor.finalizeCreationRange(compressor.takeNextCreationRange());

                const override1 = compressor.generateCompressedId("override1");
                assert(isLocalId(override1));
                const finalId1 = compressor.generateCompressedId();
                assert(isFinalId(finalId1));

                generateCompressedIds(compressor, 5);
                compressor.finalizeCreationRange(compressor.takeNextCreationRange());

                const override2 = compressor.generateCompressedId("override2");
                assert(isLocalId(override2));
                const finalId2 = compressor.generateCompressedId();
                assert(isFinalId(finalId2));

                compressor.finalizeCreationRange(compressor.takeNextCreationRange());

                const opSpaceId1 = compressor.normalizeToOpSpace(localId1);
                const opSpaceId2 = compressor.normalizeToOpSpace(override1);
                const opSpaceId3 = compressor.normalizeToOpSpace(finalId1);
                const opSpaceId4 = compressor.normalizeToOpSpace(override2);
                const opSpaceId5 = compressor.normalizeToOpSpace(finalId2);

                assert(isFinalId(opSpaceId1));
                assert(isFinalId(opSpaceId2));
                assert(isFinalId(opSpaceId3) && opSpaceId3 === finalId1);
                assert(isFinalId(opSpaceId4));
                assert(isFinalId(opSpaceId5) && opSpaceId5 === finalId2);

                assert.equal(compressor.normalizeToSessionSpace(opSpaceId1), localId1);
                assert.equal(compressor.normalizeToSessionSpace(opSpaceId2), override1);
                assert.equal(compressor.normalizeToSessionSpace(opSpaceId3), finalId1);
                assert.equal(compressor.normalizeToSessionSpace(opSpaceId4), override2);
                assert.equal(compressor.normalizeToSessionSpace(opSpaceId5), finalId2);
            });

            it("correctly normalizes eagerly allocated final IDs", () => {
                const compressor = createCompressor(Client.Client1, 5);
                const localId1 = compressor.generateCompressedId();
                const range1 = compressor.takeNextCreationRange();
                const localId2 = compressor.generateCompressedId();
                const range2 = compressor.takeNextCreationRange();
                assert(isLocalId(localId1));
                assert(isLocalId(localId2));

                compressor.finalizeCreationRange(range1);
                compressor.finalizeCreationRange(range2);

                const opSpaceId1 = compressor.normalizeToOpSpace(localId1);
                const opSpaceId2 = compressor.normalizeToOpSpace(localId2);

                assert(isFinalId(opSpaceId1));
                assert(isFinalId(opSpaceId2));

                assert.equal(compressor.normalizeToSessionSpace(opSpaceId1), localId1);
                assert.equal(compressor.normalizeToSessionSpace(opSpaceId2), localId2);
            });

            it("generates correct eager finals when there are outstanding locals after cluster expansion", () => {
                const compressor = createCompressor(Client.Client1, 2);

                // Before cluster expansion
                assert(isLocalId(compressor.generateCompressedId()));
                const rangeA = compressor.takeNextCreationRange();
                compressor.finalizeCreationRange(rangeA);
                assert(isFinalId(compressor.generateCompressedId()));

                // After cluster expansion
                assert(isLocalId(compressor.generateCompressedId()));
                const rangeB = compressor.takeNextCreationRange();
                const localId = compressor.generateCompressedId();
                assert(isLocalId(localId));

                // Take a range that won't be finalized in this test; the finalizing of range B should associate this range with finals
                const rangeC = compressor.takeNextCreationRange();

                compressor.finalizeCreationRange(rangeB);
                const eagerId = compressor.generateCompressedId();
                assert(isFinalId(eagerId));

                assert.equal(compressor.recompress(compressor.decompress(localId)), localId);
                assert.equal(compressor.recompress(compressor.decompress(eagerId)), eagerId);

                compressor.finalizeCreationRange(rangeC);

                assert.equal(compressor.recompress(compressor.decompress(localId)), localId);
                assert.equal(compressor.recompress(compressor.decompress(eagerId)), eagerId);
            });
        });

        describe("Finalizing", () => {
            itNetwork("can finalize IDs from multiple clients", (network) => {
                network.allocateAndSendIds(Client.Client1, 3, {
                    1: "override1",
                });
                network.allocateAndSendIds(Client.Client2, 3, {
                    1: "override2",
                });
                expectSequencedLogsAlign(network, Client.Client1, Client.Client2);
            });

            itNetwork("can finalize a range when the current cluster is full", 5, (network) => {
                const clusterCapacity = network.getCompressor(Client.Client1).clusterCapacity;
                network.allocateAndSendIds(Client.Client1, clusterCapacity);
                network.allocateAndSendIds(Client.Client2, clusterCapacity);
                network.allocateAndSendIds(Client.Client1, clusterCapacity, {
                    0: "override1",
                    1: "override2",
                    2: "override3",
                });
                expectSequencedLogsAlign(network, Client.Client1, Client.Client2);
            });

            itNetwork("can finalize a range that spans multiple clusters", 5, (network) => {
                const clusterCapacity = network.getCompressor(Client.Client1).clusterCapacity;
                network.allocateAndSendIds(Client.Client1, clusterCapacity - 2, {
                    0: "override1",
                    1: "override2",
                });
                network.allocateAndSendIds(Client.Client2, 1);
                network.allocateAndSendIds(Client.Client1, clusterCapacity, {
                    0: "override3",
                    1: "override4",
                    2: "override5",
                });
                expectSequencedLogsAlign(network, Client.Client1, Client.Client2);
            });
        });

        describe("Serialization", () => {
            itNetwork(
                "prevents attempts to resume a session from a serialized compressor with no session",
                (network) => {
                    const compressor = network.getCompressor(Client.Client1);
                    network.allocateAndSendIds(Client.Client2, 1);
                    network.allocateAndSendIds(Client.Client3, 1);
                    network.deliverOperations(Client.Client1);
                    const serializedWithoutLocalState = compressor.serialize(false);
                    assert.throws(
                        () =>
                            IdCompressor.deserialize(
                                serializedWithoutLocalState,
                                sessionIds.get(Client.Client2),
                            ),
                        (e) => validateAssertionError(e, "Cannot resume existing session."),
                    );
                },
            );

            itNetwork("round-trips local state", 3, (network) => {
                network.allocateAndSendIds(Client.Client1, 2);
                network.allocateAndSendIds(Client.Client2, 3);
                network.allocateAndSendIds(Client.Client1, 5);
                network.allocateAndSendIds(Client.Client1, 5);
                network.allocateAndSendIds(Client.Client3, 3);
                network.allocateAndSendIds(Client.Client2, 3);
                network.deliverOperations(Client.Client1);
                // Some un-acked locals at the end
                network.allocateAndSendIds(Client.Client1, 4);
                const [serializedNoSession, serializedWithSession] = expectSerializes(
                    network.getCompressor(Client.Client1),
                );
                assert(hasOngoingSession(serializedWithSession));
                assert(!hasOngoingSession(serializedNoSession));
            });

            itNetwork("can serialize a partially empty cluster", 5, (network) => {
                network.allocateAndSendIds(Client.Client1, 2);
                network.deliverOperations(DestinationClient.All);
                expectSerializes(network.getCompressor(Client.Client1));
                expectSerializes(network.getCompressor(Client.Client3));
            });

            itNetwork("can serialize a full cluster", 2, (network) => {
                network.allocateAndSendIds(Client.Client1, 2);
                network.deliverOperations(DestinationClient.All);
                expectSerializes(network.getCompressor(Client.Client1));
                expectSerializes(network.getCompressor(Client.Client3));
            });

            itNetwork("can serialize full clusters from different clients", 2, (network) => {
                network.allocateAndSendIds(Client.Client1, 2);
                network.allocateAndSendIds(Client.Client2, 2);
                network.deliverOperations(DestinationClient.All);
                expectSerializes(network.getCompressor(Client.Client1));
                expectSerializes(network.getCompressor(Client.Client3));
            });

            itNetwork("can serialize clusters of different sizes and clients", 3, (network) => {
                network.allocateAndSendIds(Client.Client1, 2);
                network.allocateAndSendIds(Client.Client2, 3);
                network.allocateAndSendIds(Client.Client1, 5);
                network.allocateAndSendIds(Client.Client1, 5);
                network.allocateAndSendIds(Client.Client2, 3);
                network.deliverOperations(DestinationClient.All);
                expectSerializes(network.getCompressor(Client.Client1));
                expectSerializes(network.getCompressor(Client.Client3));
            });

            itNetwork("can serialize clusters with overrides", 3, (network) => {
                network.allocateAndSendIds(Client.Client1, 2, {
                    1: "override",
                });
                network.allocateAndSendIds(Client.Client2, 3, {
                    0: "override1",
                    2: "override2",
                });
                network.deliverOperations(DestinationClient.All);
                expectSerializes(network.getCompressor(Client.Client1));
                expectSerializes(network.getCompressor(Client.Client3));
            });

            itNetwork(
                "packs IDs into a single cluster when a single client generates non-overridden ids",
                3,
                (network) => {
                    network.allocateAndSendIds(Client.Client1, 20);
                    network.deliverOperations(DestinationClient.All);
                    const [serialized1WithNoSession, serialized1WithSession] = expectSerializes(
                        network.getCompressor(Client.Client1),
                    );
                    assert.equal(serialized1WithNoSession.clusters.length, 1);
                    assert.equal(serialized1WithSession.clusters.length, 1);
                    const [serialized3WithNoSession, serialized3WithSession] = expectSerializes(
                        network.getCompressor(Client.Client3),
                    );
                    assert.equal(serialized3WithNoSession.clusters.length, 1);
                    assert.equal(serialized3WithSession.clusters.length, 1);
                },
            );

            itNetwork("serializes correctly after unifying duplicate overrides", 3, (network) => {
                const override = "override";
                network.allocateAndSendIds(Client.Client1, 1, { 0: override });
                network.allocateAndSendIds(Client.Client2, 2, { 1: override });
                network.allocateAndSendIds(Client.Client1, 5);
                network.allocateAndSendIds(Client.Client2, 5);
                network.deliverOperations(DestinationClient.All);
                expectSerializes(network.getCompressor(Client.Client1));
                expectSerializes(network.getCompressor(Client.Client2));
                expectSerializes(network.getCompressor(Client.Client3));
            });

            itNetwork(
                "can resume a session and interact with multiple other clients",
                3,
                (network) => {
                    const clusterSize = network.getCompressor(Client.Client1).clusterCapacity;
                    network.allocateAndSendIds(Client.Client1, clusterSize);
                    network.allocateAndSendIds(Client.Client2, clusterSize);
                    network.allocateAndSendIds(Client.Client3, clusterSize);
                    network.allocateAndSendIds(Client.Client1, clusterSize);
                    network.allocateAndSendIds(Client.Client2, clusterSize);
                    network.allocateAndSendIds(Client.Client3, clusterSize);
                    network.deliverOperations(DestinationClient.All);
                    network.goOfflineThenResume(Client.Client1);
                    network.allocateAndSendIds(Client.Client1, 2);
                    network.allocateAndSendIds(Client.Client2, 2);
                    network.allocateAndSendIds(Client.Client3, 2);
                    expectSequencedLogsAlign(network, Client.Client1, Client.Client2);
                },
            );

            itNetwork("can serialize after a large fuzz input", 3, (network) => {
                const generator = take(1000, makeOpGenerator({ includeOverrides: true }));
                performFuzzActions(generator, network, Math.PI, undefined, true, (n) => {
                    // Periodically check that everyone in the network has the same serialized state
                    n.deliverOperations(DestinationClient.All);
                    const compressors = n.getTargetCompressors(DestinationClient.All);
                    let deserializedPrev = roundtrip(compressors[0][1], false)[1];
                    for (let i = 1; i < compressors.length; i++) {
                        const deserializedCur = roundtrip(compressors[i][1], false)[1];
                        assert(deserializedPrev.equals(deserializedCur, false));
                        deserializedPrev = deserializedCur;
                    }
                });
                expectSerializes(network.getCompressor(Client.Client1));
                expectSerializes(network.getCompressor(Client.Client2));
                expectSerializes(network.getCompressor(Client.Client3));
            });

            itNetwork("stores override indices relative to their clusters", 3, (network) => {
                network.allocateAndSendIds(Client.Client1, 3, { 0: "cluster1" });
                network.allocateAndSendIds(Client.Client2, 3, { 0: "cluster2" });
                network.deliverOperations(Client.Client1);
                const serialized = network.getCompressor(Client.Client1).serialize(false);
                assert.equal(serialized.clusters.length, 2);
                const cluster0 = serialized.clusters[0][2] ?? fail("Expected overrides cluster");
                const cluster1 = serialized.clusters[1][2] ?? fail("Expected overrides cluster");
                assert(typeof cluster0 !== "number", "Expected overrides cluster");
                assert(typeof cluster1 !== "number", "Expected overrides cluster");
                assert.equal(cluster0[0][0], 0);
                assert.equal(cluster1[0][0], 0);
            });
        });
    });
});

type NetworkTestFunction = (
    title: string,
    test: (network: IdCompressorTestNetwork) => void,
) => void;

type NetworkTestFunctionWithCapacity = (
    title: string,
    initialClusterCapacity: number,
    test: (network: IdCompressorTestNetwork) => void,
) => void;

function createNetworkTestFunction(
    validateAfter: boolean,
): NetworkTestFunction & NetworkTestFunctionWithCapacity {
    return (
        title: string,
        testOrCapacity: ((network: IdCompressorTestNetwork) => void) | number,
        test?: (network: IdCompressorTestNetwork) => void,
    ) => {
        it(title, () => {
            const hasCapacity = typeof testOrCapacity === "number";
            const capacity = hasCapacity ? testOrCapacity : undefined;
            const network = new IdCompressorTestNetwork(capacity);
            (hasCapacity ? test ?? fail("test must be defined") : testOrCapacity)(network);
            if (validateAfter) {
                network.deliverOperations(DestinationClient.All);
                network.assertNetworkState();
            }
        }).timeout(10000);
    };
}

function describeNetwork(
    title: string,
    its: (itFunc: NetworkTestFunction & NetworkTestFunctionWithCapacity) => void,
) {
    describe(title, () => {
        its(createNetworkTestFunction(false));
    });

    describe(`${title} (with validation)`, () => {
        its(createNetworkTestFunction(true));
    });
}

function describeNetworkNoValidation(
    title: string,
    its: (itFunc: NetworkTestFunction & NetworkTestFunctionWithCapacity) => void,
) {
    describe(title, () => {
        its(createNetworkTestFunction(false));
    });
}
