{"version":3,"file":"rootCallbackListener.js","sourceRoot":"","sources":["../../src/helpers/rootCallbackListener.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAYH,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,aAAa,EAAE,MAAM,SAAS,CAAC;AACxC,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AACtD,OAAO,EAAE,aAAa,EAAE,MAAM,GAAG,CAAC;AAElC;;;;;;;;;;;;;GAaG;AACH,MAAM,CAAC,MAAM,2BAA2B,GAAG,CAIvC,cAA8B,EAC9B,eAA2B,EAC3B,aAAa,EACb,WAAyB,EACzB,OAA+B,EAC/B,KAAS,EACT,QAIS,EACT,WAAmC,EACnC,WAAoC,EACtC,EAAE,CAAC,CAAC,MAA8B,EAAE,KAAc,EAAE,EAAE;IACpD,MAAM,iBAAiB,GAAG,aAAa,CACnC,aAAa,EACb,WAAW,EACX,cAAc,EACd,WAAW,CACd,CAAC;IACF,IAAI,iBAAiB,KAAK,SAAS,EAAE;QACjC,MAAM,KAAK,CAAC,kEAAkE,CAAC,CAAC;KACnF;IACD,MAAM,eAAe,GAAa,WAAW,KAAK,SAAS;QACvD,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,QAAkB,CAAC;QACzE,CAAC,CAAC,EAAE,CAAC;IACT,IAAI,CAAC,KAAK,IAAI,MAAM,CAAC,GAAG,KAAK,eAAe,aAAa,EAAE,EAAE;QACzD,oFAAoF;QACpF,SAAS,CACL,IAAI,EACJ,aAAa,EACb,WAAW,EACX,OAAO,EACP,KAAK,EACL,QAAQ,EACR,cAAc,EACd,WAAW,EACX,WAAW,CACd,CAAC;KACL;SAAM,IACH,WAAW,KAAK,SAAS;QACzB,eAAe,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,EACtC;QACE,gGAAgG;QAChG,0BAA0B;QAC1B,MAAM,QAAQ,GAAG,aAAa,CAAC,MAAM,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;QACxD,IAAI,QAAQ,KAAK,SAAS,EAAE;YACxB,MAAM,eAAe,GAAG,gBAAgB,CACpC,aAAa,EACb,WAAW,EACX,MAAM,CAAC,GAAe,EACtB,cAAc,EACd,WAAW,EACX,KAAK,EACL,iBAAiB,CACpB,CAAC;YACF,KAAK,CAAC,QAAkB,CAAC,GAAG,eAAe,CAAC,QAAQ,CAAC,CAAC;YACtD,KAAK,CAAC,cAAc,GAAG,cAAc,CAAC;YACtC,QAAQ,CAAC,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;SAChC;aAAM;YACH,MAAM,KAAK,CACP,8DAA8D,MAAM,CAAC,GAAG,EAAE,CAC7E,CAAC;SACL;KACJ;AACL,CAAC,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ISharedMap, IDirectoryValueChanged } from \"@fluidframework/map\";\nimport { IFluidDataStoreRuntime } from \"@fluidframework/datastore-definitions\";\nimport {\n    FluidObjectMap,\n    ViewToFluidMap,\n    FluidToViewMap,\n    IViewState,\n    IFluidState,\n} from \"../interface\";\nimport { ISyncedState } from \"..\";\nimport { syncState } from \"./syncState\";\nimport { getByFluidKey } from \"./utils\";\nimport { getViewFromFluid } from \"./getViewFromFluid\";\nimport { getFluidState } from \".\";\n\n/**\n * The callback that is added to the \"valueChanged\" event on the Fluid object this\n * is passed in to. This will trigger state updates when the synced state value is updated\n * @param fluidObjectMap - A map of Fluid handle paths to their Fluid objects\n * @param syncedStateId - Unique ID for this synced Fluid object's state\n * @param syncedState - The shared map this Fluid object's synced state is stored on\n * @param runtime - The data store runtime\n * @param state - The current view state\n * @param setState - Callback to update the react view state\n * @param fluidToView - A map of the Fluid state values that need conversion to their view state counterparts and the\n * respective converters\n * @param viewToFluid - A map of the view state values that need conversion to their Fluid state counterparts and the\n * respective converters\n */\nexport const syncedStateCallbackListener = <\n    SV extends IViewState,\n    SF extends IFluidState\n>(\n    fluidObjectMap: FluidObjectMap,\n    storedHandleMap: ISharedMap,\n    syncedStateId,\n    syncedState: ISyncedState,\n    runtime: IFluidDataStoreRuntime,\n    state: SV,\n    setState: (\n        newState: SV,\n        fromRootUpdate?: boolean,\n        isLocal?: boolean\n    ) => void,\n    fluidToView: FluidToViewMap<SV, SF>,\n    viewToFluid?: ViewToFluidMap<SV, SF>,\n) => (change: IDirectoryValueChanged, local: boolean) => {\n    const currentFluidState = getFluidState(\n        syncedStateId,\n        syncedState,\n        fluidObjectMap,\n        fluidToView,\n    );\n    if (currentFluidState === undefined) {\n        throw Error(\"Synced state update triggered before Fluid state was initialized\");\n    }\n    const viewToFluidKeys: string[] = viewToFluid !== undefined\n        ? Array.from(viewToFluid.values()).map((item) => item.fluidKey as string)\n        : [];\n    if (!local && change.key === `syncedState-${syncedStateId}`) {\n        // If the update is to the synced Fluid state, update both the Fluid and view states\n        syncState(\n            true,\n            syncedStateId,\n            syncedState,\n            runtime,\n            state,\n            setState,\n            fluidObjectMap,\n            fluidToView,\n            viewToFluid,\n        );\n    } else if (\n        viewToFluid !== undefined &&\n        viewToFluidKeys.includes(change.key)\n    ) {\n        // If the update is to a child Fluid object, trigger only a view update as the child itself will\n        // update its Fluid update\n        const stateKey = getByFluidKey(change.key, viewToFluid);\n        if (stateKey !== undefined) {\n            const newPartialState = getViewFromFluid(\n                syncedStateId,\n                syncedState,\n                change.key as keyof SF,\n                fluidObjectMap,\n                fluidToView,\n                state,\n                currentFluidState,\n            );\n            state[stateKey as string] = newPartialState[stateKey];\n            state.fluidObjectMap = fluidObjectMap;\n            setState(state, true, local);\n        } else {\n            throw Error(\n                `Unable to extract view state from synced state change key: ${change.key}`,\n            );\n        }\n    }\n};\n"]}