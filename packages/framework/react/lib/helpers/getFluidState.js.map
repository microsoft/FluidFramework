{"version":3,"file":"getFluidState.js","sourceRoot":"","sources":["../../src/helpers/getFluidState.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAgBH;;;;;;;GAOG;AACH,MAAM,UAAU,aAAa,CAIzB,aAAqB,EACrB,WAAyB,EACzB,cAA8B,EAC9B,WAAmD;;IAEnD,MAAM,sBAAsB,GAAG,WAAW,CAAC,GAAG,CAC1C,eAAe,aAAa,EAAE,CACjC,CAAC;IACF,IAAI,sBAAsB,KAAK,SAAS,EAAE;QACtC,OAAO;KACV;IACD,MAAM,gBAAgB,GAAG,MAAA,cAAc,CAAC,GAAG,CAAC,sBAAsB,CAAC,YAAY,CAAC,0CAC1E,WAAwB,CAAC;IAC/B,IAAI,gBAAgB,KAAK,SAAS,EAAE;QAChC,OAAO;KACV;IACD,MAAM,UAAU,GAAG,EAAE,CAAC;IACtB,KAAK,MAAM,QAAQ,IAAI,gBAAgB,CAAC,IAAI,EAAE,EAAE;QAC5C,MAAM,cAAc,SAAG,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,GAAG,CAAC,QAAoB,2CACtD,kBAAkB,CAAC;QACzB,IAAI,KAAK,GAAG,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAC3C,IAAI,KAAK,KAAK,SAAS,IAAI,cAAc,KAAK,SAAS,EAAE;YACrD,MAAM,qBAAqB,eAAI,KAAsB,0CAC/C,YAAY,0CAAE,YAAY,CAAC;YACjC,IAAI,qBAAqB,KAAK,SAAS,EAAE;gBACrC,KAAK,GAAG,CAAC,cAAc,CAAC,GAAG,CAAC,qBAAqB,CAAC,CAAwB,CAAC;gBAC3E,UAAU,CAAC,QAAQ,CAAC,GAAG,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,WAAW,CAAC;aAC7C;iBAAM;gBACH,UAAU,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC;aAChC;SACJ;aAAM;YACH,UAAU,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC;SAChC;KACJ;IACD,OAAO,UAAgB,CAAC;AAC5B,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    IFluidObject,\n    IFluidHandle,\n} from \"@fluidframework/core-interfaces\";\nimport { ISharedMap, SharedMap } from \"@fluidframework/map\";\nimport {\n    IViewConverter,\n    FluidObjectMap,\n    IViewState,\n    IFluidState,\n    ISyncedState,\n    IFluidObjectMapItem,\n} from \"..\";\n\n/**\n * Return the Fluid state from the syncedState with all handles converted into Fluid objects\n * @param syncedStateId - Unique ID for the synced state of this view\n * @param syncedState - Shared map the synced state is stored on\n * @param fluidObjectMap - Map of Fluid handle paths to their respective Fluid objects\n * @param fluidToView - Map of the Fluid state keys contains the optional syncedState key parameter,\n * in case the Fluid value is stored in the syncedState under a different key\n */\nexport function getFluidState<\n    SV extends IViewState,\n    SF extends IFluidState\n>(\n    syncedStateId: string,\n    syncedState: ISyncedState,\n    fluidObjectMap: FluidObjectMap,\n    fluidToView?: Map<keyof SF, IViewConverter<SV, SF>>,\n): SF | undefined {\n    const fluidObjectStateHandle = syncedState.get<IFluidHandle<ISharedMap>>(\n        `syncedState-${syncedStateId}`,\n    );\n    if (fluidObjectStateHandle === undefined) {\n        return;\n    }\n    const fluidObjectState = fluidObjectMap.get(fluidObjectStateHandle.absolutePath)\n        ?.fluidObject as SharedMap;\n    if (fluidObjectState === undefined) {\n        return;\n    }\n    const fluidState = {};\n    for (const fluidKey of fluidObjectState.keys()) {\n        const createCallback = fluidToView?.get(fluidKey as keyof SF)\n            ?.sharedObjectCreate;\n        let value = fluidObjectState.get(fluidKey);\n        if (value !== undefined && createCallback !== undefined) {\n            const possibleFluidObjectId = (value as IFluidObject)\n                ?.IFluidHandle?.absolutePath;\n            if (possibleFluidObjectId !== undefined) {\n                value = (fluidObjectMap.get(possibleFluidObjectId)) as IFluidObjectMapItem;\n                fluidState[fluidKey] = value?.fluidObject;\n            } else {\n                fluidState[fluidKey] = value;\n            }\n        } else {\n            fluidState[fluidKey] = value;\n        }\n    }\n    return fluidState as SF;\n}\n"]}