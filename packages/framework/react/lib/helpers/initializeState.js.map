{"version":3,"file":"initializeState.js","sourceRoot":"","sources":["../../src/helpers/initializeState.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    ISharedMap,\n    IDirectoryValueChanged,\n    ISharedDirectory,\n    SharedMap,\n} from \"@fluidframework/map\";\nimport { IComponentHandle } from \"@fluidframework/component-core-interfaces\";\nimport {\n    IFluidDataProps,\n    FluidToViewMap,\n    ViewToFluidMap,\n    IFluidFunctionalComponentViewState,\n    IFluidFunctionalComponentFluidState,\n} from \"../interface\";\nimport {\n    getFluidStateFromRoot,\n    getComponentSchemaFromRoot,\n    generateComponentSchema,\n    setComponentSchemaToRoot,\n    rootCallbackListener,\n    updateStateAndComponentMap,\n} from \".\";\nimport { IFluidSchema, IFluidComponent } from \"..\";\n\n/**\n * Initialize the stored state on the root and dynamically generate the schemas\n * that will be used for all future operations\n * @param syncedStateId - Unique ID for this synced component's state\n * @param fluidToView - A map of the Fluid state values that need conversion to their view state counterparts and the\n * respective converters\n * @param dataProps - Contains the runtime and fluidComponentMap to create and store DDS'\n * @param state - Current view state\n * @param setState - Callback to update view state\n * @param viewToFluid - A map of the view state values that need conversion to their Fluid state counterparts and the\n * respective converters\n * @param fluidToView - A map of the Fluid state values that need conversion to their view state counterparts and the\n * respective converters\n */\nexport async function initializeState<\n    SV extends IFluidFunctionalComponentViewState,\n    SF extends IFluidFunctionalComponentFluidState\n>(\n    syncedStateId,\n    root: ISharedDirectory,\n    dataProps: IFluidDataProps,\n    state: SV,\n    setState: (\n        newState: SV,\n        fromRootUpdate?: boolean,\n        isLocal?: boolean\n    ) => void,\n    fluidToView: FluidToViewMap<SV, SF>,\n    viewToFluid?: ViewToFluidMap<SV, SF>,\n): Promise<void> {\n    let unlistenedComponentHandles: IComponentHandle[] = [];\n    let storedFluidStateHandle = root.get<IComponentHandle>(\n        `syncedState-${syncedStateId}`,\n    );\n    // TODO #2457 - Move synced state initializing into component lifecycle, expose API for update\n    if (storedFluidStateHandle === undefined) {\n        const storedFluidState = SharedMap.create(dataProps.runtime);\n        dataProps.fluidComponentMap.set(storedFluidState.handle.path, {\n            component: storedFluidState,\n            isRuntimeMap: true,\n        });\n        root.set(`syncedState-${syncedStateId}`, storedFluidState.handle);\n        storedFluidStateHandle = storedFluidState.handle;\n    } else {\n        dataProps.fluidComponentMap.set(storedFluidStateHandle.path, {\n            component: await storedFluidStateHandle.get(),\n            isRuntimeMap: true,\n        });\n    }\n    const fluidStateMap = (await storedFluidStateHandle.get()) as SharedMap;\n    if (fluidStateMap === undefined) {\n        throw Error(\"Failed to initialize synced fluid state\");\n    }\n\n    for (const key of fluidToView.keys()) {\n        const fluidKey = key as string;\n        const rootKey = fluidToView?.get(fluidKey as keyof SF)?.rootKey;\n        const createCallback = fluidToView?.get(fluidKey as keyof SF)\n            ?.sharedObjectCreate;\n        if (createCallback) {\n            if (fluidStateMap.get(fluidKey) === undefined) {\n                const sharedObject = createCallback(dataProps.runtime);\n                dataProps.fluidComponentMap.set(sharedObject.handle.path, {\n                    component: sharedObject,\n                    listenedEvents: fluidToView?.get(fluidKey as keyof SF)\n                        ?.listenedEvents || [\"valueChanged\"],\n                });\n                fluidStateMap.set(fluidKey, sharedObject.handle);\n                if (rootKey) {\n                    root.set(rootKey, sharedObject.handle);\n                }\n            } else {\n                const handle = fluidStateMap.get(fluidKey);\n                dataProps.fluidComponentMap.set(handle.path, {\n                    component: await handle.get(),\n                    listenedEvents: fluidToView?.get(fluidKey as keyof SF)\n                        ?.listenedEvents,\n                });\n            }\n        } else if (rootKey) {\n            fluidStateMap.set(fluidKey, root.get(rootKey));\n        }\n    }\n\n    unlistenedComponentHandles.push(storedFluidStateHandle);\n    const initFluidState = getFluidStateFromRoot(\n        syncedStateId,\n        root,\n        dataProps.fluidComponentMap,\n        fluidToView,\n    );\n    if (!initFluidState) {\n        throw Error(\"Failed to initialize fluid state\");\n    }\n\n    // If the stored schema is undefined on this root, i.e. it is the first time this\n    // component is being loaded, generate it and store it\n    let componentSchemaHandles = getComponentSchemaFromRoot(\n        syncedStateId,\n        root,\n    );\n    if (componentSchemaHandles === undefined) {\n        const componentSchema: IFluidSchema = generateComponentSchema(\n            dataProps.runtime,\n            state,\n            initFluidState,\n            fluidToView,\n            viewToFluid,\n        );\n        componentSchemaHandles = {\n            componentKeyMapHandle: componentSchema.componentKeyMap\n                .handle as IComponentHandle<ISharedMap>,\n            fluidMatchingMapHandle: componentSchema.fluidMatchingMap\n                .handle as IComponentHandle<ISharedMap>,\n            viewMatchingMapHandle: componentSchema.viewMatchingMap\n                .handle as IComponentHandle<ISharedMap>,\n        };\n        setComponentSchemaToRoot(syncedStateId, root, componentSchemaHandles);\n    }\n\n    state.isInitialized = true;\n    state.syncedStateId = syncedStateId;\n\n    // Add the list of SharedMap handles for the schema and any unlistened handles passed in through the component\n    // map to the list of handles we will fetch and start listening to\n    unlistenedComponentHandles = [\n        ...unlistenedComponentHandles,\n        ...[\n            componentSchemaHandles.componentKeyMapHandle,\n            componentSchemaHandles.fluidMatchingMapHandle,\n            componentSchemaHandles.viewMatchingMapHandle,\n        ],\n    ];\n    const unlistenedMapHandles = [...unlistenedComponentHandles];\n\n    dataProps.fluidComponentMap.forEach((value: IFluidComponent, k) => {\n        if (!value.isListened && value.component?.handle !== undefined) {\n            unlistenedComponentHandles.push(value.component.handle);\n        }\n    });\n\n    // Initialize the FluidComponentMap with our data handles\n    for (const handle of unlistenedMapHandles) {\n        dataProps.fluidComponentMap.set(handle.path, {\n            isListened: false,\n            isRuntimeMap: true,\n            component: await handle.get(),\n        });\n    }\n\n    // Define the root callback listener that will be responsible for triggering state updates on root value changes\n    const initRootCallback = (\n        change: IDirectoryValueChanged,\n        local: boolean,\n    ) => {\n        const callback = rootCallbackListener(\n            dataProps.fluidComponentMap,\n            syncedStateId,\n            root,\n            dataProps.runtime,\n            state,\n            setState,\n            fluidToView,\n            viewToFluid,\n        );\n        return callback(change, local);\n    };\n    // Add the callback to the component's own root\n    root.on(\"valueChanged\", initRootCallback);\n    // Add the callback to all the unlistened components and then update the state afterwards\n    return updateStateAndComponentMap<SV, SF>(\n        unlistenedComponentHandles,\n        dataProps.fluidComponentMap,\n        true,\n        syncedStateId,\n        root,\n        dataProps.runtime,\n        state,\n        setState,\n        initRootCallback,\n        fluidToView,\n        viewToFluid,\n    );\n}\n"]}