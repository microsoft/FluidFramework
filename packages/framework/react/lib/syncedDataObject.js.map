{"version":3,"file":"syncedDataObject.js","sourceRoot":"","sources":["../src/syncedDataObject.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { DataObject } from \"@fluidframework/aqueduct\";\nimport {\n    IFluidObject,\n    IFluidHandle,\n} from \"@fluidframework/core-interfaces\";\nimport { IEvent } from \"@fluidframework/common-definitions\";\nimport { SharedMap, ISharedMap } from \"@fluidframework/map\";\nimport { IFluidHTMLView } from \"@fluidframework/view-interfaces\";\n\nimport {\n    FluidObjectMap,\n    SyncedStateConfig,\n    ISyncedStateConfig,\n    IViewState,\n    IFluidState,\n    ISyncedState,\n} from \"./interface\";\nimport {\n    generateFluidObjectSchema,\n    setSchema,\n    getSchema,\n} from \"./helpers\";\n\n/**\n * SyncedDataObject is a base class for Fluid data objects with views. It extends DataObject.\n * In addition to the root and task manager, the SyncedDataObject also provides a syncedStateConfig\n * and assures that the syncedState will be initialized according the config by the time the view\n * is rendered.\n *\n * As this is used for views, it also implements the IFluidHTMLView interface, and requires\n * the render function to be filled in.\n */\nexport abstract class SyncedDataObject<\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    P extends IFluidObject = object,\n    S = undefined,\n    E extends IEvent = IEvent\n    > extends DataObject<P, S, E> implements IFluidHTMLView {\n    private readonly syncedStateConfig: SyncedStateConfig = new Map();\n    private readonly fluidObjectMap: FluidObjectMap = new Map();\n    private readonly syncedStateDirectoryId = \"syncedState\";\n    private internalSyncedState: ISharedMap | undefined;\n\n    public get IFluidHTMLView() {\n        return this;\n    }\n\n    /**\n     * Runs the first time the SyncedDataObject is generated and sets up all necessary data structures for the view\n     * To extend this function, please call super() prior to adding to functionality to ensure correct initializing\n     */\n    protected async initializingFirstTime(): Promise<void> {\n        // Initialize our synced state map for the first time using our\n        // syncedStateConfig values\n        await this.initializeStateFirstTime();\n    }\n\n    /**\n     * Runs any time the SyncedDataObject is rendered again. It sets up all necessary data structures for the view,\n     * along with any additional ones that may have been added due to user behavior\n     * To extend this function, please call super() prior to adding to functionality to ensure correct initializing\n     */\n    protected async initializingFromExisting(): Promise<void> {\n        // Load our existing state values to be ready for the render lifecycle\n        await this.initializeStateFromExisting();\n    }\n\n    /**\n     * Returns an interface to interact with the stored synced state for the SyncedDataObject.\n     * Views can get and fetch values from it based on their syncedStateId to retrieve their view-specific information.\n     * They can also attach listeners using the addValueChangedListener\n     */\n    public get syncedState(): ISyncedState {\n        if (this.internalSyncedState === undefined) {\n            throw new Error(this.getUninitializedErrorString(`syncedState`));\n        }\n        return {\n            set: this.internalSyncedState.set.bind(this.internalSyncedState),\n            get: this.internalSyncedState.get.bind(this.internalSyncedState),\n            addValueChangedListener: (callback) => {\n                if (this.internalSyncedState === undefined) {\n                    throw new Error(\n                        this.getUninitializedErrorString(`syncedState`),\n                    );\n                }\n                this.internalSyncedState.on(\"valueChanged\", callback);\n            },\n        };\n    }\n\n    /**\n     * Returns the data props used by the view to manage the different DDSes and add any new ones\n     */\n    public get dataProps() {\n        return {\n            runtime: this.runtime,\n            fluidObjectMap: this.fluidObjectMap,\n        };\n    }\n\n    /**\n     * Set values to the syncedStateConfig where the view and Fluid states have the same values defined by S.\n     * Each view with a unique syncedStateId needs its own value in the syncedStateConfig.\n     * @param key - The syncedStateId that maps to the view that will be using these definitions\n     * @param value - The config value containing the syncedStateId and the fluidToView and viewToFluid maps\n     */\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    public setConfig<S>(key: string, value: ISyncedStateConfig<S, S>) {\n        this.syncedStateConfig.set(key, value);\n    }\n\n    /**\n     * Set values to the syncedStateConfig with different view and Fluid state definitions.\n     * Each view with a unique syncedStateId needs its own value in the syncedStateConfig,\n     * with SV being the view state definition and SF being the Fluid state definition.\n     * @param key - The syncedStateId that maps to the view that will be using these definitions\n     * @param value - The config value containing the syncedStateId and the fluidToView and viewToFluid maps\n     * that establish the relationship between SV and SF\n     */\n    public setFluidConfig<\n        SV extends IViewState,\n        SF extends IFluidState\n    >(key: string, value: ISyncedStateConfig<SV, SF>) {\n        this.syncedStateConfig.set(key, value);\n    }\n\n    /**\n     * Get a config for a specific view with the key as its syncedStateId\n     * @param key - The syncedStateId to get the config for\n     */\n    public getConfig(key: string) {\n        return this.syncedStateConfig.get(key);\n    }\n\n    /**\n     * Returns a view. This function need to be implemented for any consumer of SyncedDataObject\n     * to render values that have been initialized using the syncedStateConfig\n     * @param element - The document that the rendered value will be displayed in\n     */\n    public render(element: HTMLElement) {\n        throw Error(\"Render function was not implemented\");\n    }\n\n    private async initializeStateFirstTime() {\n        this.internalSyncedState = SharedMap.create(\n            this.runtime,\n            this.syncedStateDirectoryId,\n        );\n        this.internalSyncedState.bindToContext();\n        for (const stateConfig of this.syncedStateConfig.values()) {\n            const {\n                syncedStateId,\n                fluidToView,\n                viewToFluid,\n                defaultViewState,\n            } = stateConfig;\n            // Add the SharedMap to store the Fluid state\n            const storedFluidState = SharedMap.create(this.runtime);\n            // Add it to the Fluid object map so that it will have a listener added to it once\n            // we enter the render lifecycle\n            this.fluidObjectMap.set(storedFluidState.handle.absolutePath, {\n                fluidObject: storedFluidState,\n                isRuntimeMap: true,\n            });\n            // Add the state to our map of synced states so that we can load it later for persistence\n            this.syncedState.set(\n                `syncedState-${syncedStateId}`,\n                storedFluidState.handle,\n            );\n            // Initialize any DDSes needed for the state or fetch any values from the root if they are stored\n            // on the root under a different key\n            for (const [key, value] of fluidToView.entries()) {\n                const fluidKey = key as string;\n                const rootKey = value.rootKey;\n                const createCallback = value.sharedObjectCreate;\n                if (createCallback !== undefined) {\n                    const sharedObject = createCallback(this.runtime);\n                    this.fluidObjectMap.set(sharedObject.handle.absolutePath, {\n                        fluidObject: sharedObject,\n                        listenedEvents: value.listenedEvents ?? [\"valueChanged\"],\n                    });\n                    storedFluidState.set(fluidKey, sharedObject.handle);\n                    if (rootKey !== undefined) {\n                        this.root.set(rootKey, sharedObject.handle);\n                    }\n                } else if (rootKey !== undefined) {\n                    storedFluidState.set(fluidKey, this.root.get(rootKey));\n                }\n            }\n\n            // Generate our schema and store it, so that we don't need to parse our maps each time\n            const schema = generateFluidObjectSchema(\n                this.runtime,\n                defaultViewState,\n                fluidToView,\n                viewToFluid,\n            );\n            const schemaHandles = {\n                fluidMatchingMapHandle: schema.fluidMatchingMap\n                    .handle as IFluidHandle<SharedMap>,\n                viewMatchingMapHandle: schema.viewMatchingMap\n                    .handle as IFluidHandle<SharedMap>,\n                storedHandleMapHandle: schema.storedHandleMap\n                    .handle as IFluidHandle<SharedMap>,\n            };\n            this.fluidObjectMap.set(\n                schema.fluidMatchingMap.handle.absolutePath,\n                {\n                    fluidObject: schema.fluidMatchingMap,\n                    isRuntimeMap: true,\n                },\n            );\n            this.fluidObjectMap.set(\n                schema.viewMatchingMap.handle.absolutePath,\n                {\n                    fluidObject: schema.viewMatchingMap,\n                    isRuntimeMap: true,\n                },\n            );\n            this.fluidObjectMap.set(\n                schema.storedHandleMap.handle.absolutePath,\n                {\n                    fluidObject: schema.storedHandleMap,\n                    isRuntimeMap: true,\n                },\n            );\n\n            setSchema(\n                syncedStateId,\n                this.syncedState,\n                schemaHandles,\n            );\n        }\n    }\n\n    private async initializeStateFromExisting() {\n        // Fetch our synced state that stores all of our information to re-initialize the view state\n        this.internalSyncedState = (await this.runtime.getChannel(\n            this.syncedStateDirectoryId,\n        )) as ISharedMap;\n        // Reload the stored state for each config provided\n        for (const stateConfig of this.syncedStateConfig.values()) {\n            const { syncedStateId, fluidToView } = stateConfig;\n            // Fetch this specific view's state using the syncedStateId\n            const storedFluidStateHandle = this.syncedState.get<\n                IFluidHandle<ISharedMap>\n            >(`syncedState-${syncedStateId}`);\n            if (storedFluidStateHandle === undefined) {\n                throw new Error(\n                    this.getUninitializedErrorString(\n                        `syncedState-${syncedStateId}`,\n                    ),\n                );\n            }\n            const storedFluidState = await storedFluidStateHandle.get();\n            // Add it to the Fluid object map so that it will have a listener added to it once\n            // we enter the render lifecycle\n            this.fluidObjectMap.set(storedFluidStateHandle.absolutePath, {\n                fluidObject: storedFluidState,\n                isRuntimeMap: true,\n            });\n            // If the view is using any Fluid data stores or SharedObjects, asynchronously fetch them\n            // from their stored handles\n            for (const [key, value] of fluidToView.entries()) {\n                const fluidKey = key as string;\n                const rootKey = value.rootKey;\n                const createCallback = value.sharedObjectCreate;\n                if (createCallback !== undefined) {\n                    const handle = rootKey !== undefined\n                        ? this.root.get(rootKey)\n                        : storedFluidState.get(fluidKey);\n                    if (handle === undefined) {\n                        throw new Error(\n                            `Failed to find ${fluidKey} in synced state`,\n                        );\n                    }\n                    this.fluidObjectMap.set(handle.absolutePath, {\n                        fluidObject: await handle.get(),\n                        listenedEvents: value.listenedEvents ?? [\"valueChanged\"],\n                    });\n                } else {\n                    const storedValue = rootKey !== undefined\n                        ? this.root.get(rootKey)\n                        : storedFluidState.get(fluidKey);\n                    const handle = storedValue?.IFluidHandle;\n                    if (handle !== undefined) {\n                        this.fluidObjectMap.set(handle.absolutePath, {\n                            fluidObject: await handle.get(),\n                            listenedEvents: value.listenedEvents ?? [\n                                \"valueChanged\",\n                            ],\n                        });\n                    }\n                }\n            }\n            const schemaHandles = getSchema(\n                syncedStateId,\n                this.syncedState,\n            );\n            if (schemaHandles === undefined) {\n                throw new Error(\n                    this.getUninitializedErrorString(\n                        `schema-${syncedStateId}`,\n                    ),\n                );\n            }\n            this.fluidObjectMap.set(\n                schemaHandles.fluidMatchingMapHandle.absolutePath,\n                {\n                    fluidObject: await schemaHandles.fluidMatchingMapHandle.get(),\n                    isRuntimeMap: true,\n                },\n            );\n            this.fluidObjectMap.set(\n                schemaHandles.viewMatchingMapHandle.absolutePath,\n                {\n                    fluidObject: await schemaHandles.viewMatchingMapHandle.get(),\n                    isRuntimeMap: true,\n                },\n            );\n            this.fluidObjectMap.set(\n                schemaHandles.storedHandleMapHandle.absolutePath,\n                {\n                    fluidObject: await schemaHandles.storedHandleMapHandle.get(),\n                    isRuntimeMap: true,\n                },\n            );\n        }\n    }\n}\n"]}