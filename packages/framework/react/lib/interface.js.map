{"version":3,"file":"interface.js","sourceRoot":"","sources":["../src/interface.ts"],"names":[],"mappings":"AAwOA,MAAM,CAAC,MAAM,wBAAwB,GAAG,CACpC,MAAW,EACa,EAAE,CAC1B,MAAM,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,gBAAgB,IAAI,MAAM,CAAC;AAgE5D,MAAM,CAAC,MAAM,wBAAwB,GAAG,CAKpC,MAAW,EAC6B,EAAE,CAC1C,MAAM,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,UAAU,IAAI,MAAM,CAAC;AAoBtD,MAAM,CAAC,MAAM,6BAA6B,GAAG,CAKzC,MAAW,EACkC,EAAE,CAC/C,MAAM,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,eAAe,IAAI,MAAM,CAAC;AAqB3D,MAAM,CAAC,MAAM,6BAA6B,GAAG,CAKzC,MAAW,EACkC,EAAE,CAC/C,MAAM,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,UAAU,IAAI,MAAM,CAAC;AAwCtD,MAAM,CAAC,MAAM,kCAAkC,GAAG,CAK9C,MAAW,EACuC,EAAE,CACpD,MAAM,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,eAAe,IAAI,MAAM,CAAC;AA6C3D,MAAM,CAAC,MAAM,0BAA0B,GAAG,CAKtC,MAAW,EAC+B,EAAE,CAC5C,MAAM,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,UAAU,IAAI,MAAM,CAAC;AAEtD,MAAM,CAAC,MAAM,qCAAqC,GAAG,CAKjD,MAAW,EACqC,EAAE,CAClD,MAAM,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,UAAU,IAAI,MAAM,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { ISharedMap, IDirectoryValueChanged } from \"@fluidframework/map\";\nimport { IFluidDataStoreRuntime } from \"@fluidframework/datastore-definitions\";\nimport {\n    IFluidHandle,\n    IFluidLoadable,\n    IFluidObject,\n} from \"@fluidframework/core-interfaces\";\nimport { SyncedDataObject } from \"./syncedDataObject\";\n\n/**\n * The combined state contains the Fluid and view states and the data props\n * that are passed in to all reducers and selectors\n */\nexport interface ICombinedState<\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n    > {\n    /**\n     * The react view state that will be used for all view renders\n     */\n    viewState: SV;\n    /**\n     * The Fluid state that will be used to update the synced values in the state. This will be\n     * undefined until it is initialized, after which the state will update with the defined values\n     */\n    fluidState?: SF;\n    /**\n     * Data props that are loaded in during the Fluid initialization step. This contains the runtime\n     * and the Fluid object map, along with any other properties the user wants to pass to reducers\n     * and selectors\n     */\n    dataProps: C;\n}\n\n/**\n * The Fluid schema that is generated on load and will be stored in the synced state\n */\nexport interface IFluidSchema {\n    /**\n     * (k,v) = (viewKeys, needsFluidConverter)\n     */\n    viewMatchingMap: ISharedMap;\n    /**\n     * (k,v) = (fluidKeys, needsViewConverter)\n     */\n    fluidMatchingMap: ISharedMap;\n    /**\n     * (k,v) = (path, handle)\n     */\n    storedHandleMap: ISharedMap;\n}\n\n/**\n * A map of the view state values that need conversion to their Fluid state counterparts and the\n * respective converters\n */\nexport type ViewToFluidMap<SV, SF> = Map<keyof SV, IFluidConverter<SV, SF>>;\n\n/**\n * A map of the Fluid state values that need conversion to their view state counterparts and the\n * respective converters\n */\nexport type FluidToViewMap<SV, SF> = Map<keyof SF, IViewConverter<SV, SF>>;\n\n/**\n * The Fluid reducer, containing an object that is keyed by function name and contains state update and\n * effect functions. Each function will have the view state, fluid state, and data props passed into it\n * as parameters in the combined state. State update functions are used to modify values on the state and return\n * the updated state and any new Fluid object handles. Effect functions use values on the state to apply changes\n * elsewhere. They do not return any new objects or state.\n */\nexport interface IFluidReducer<\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n    > {\n    [key: string]:\n    | FluidAsyncStateUpdateFunction<SV, SF, C>\n    | FluidStateUpdateFunction<SV, SF, C>\n    | FluidEffectFunction<SV, SF, C>\n    | FluidAsyncEffectFunction<SV, SF, C>;\n}\n\n/**\n * The Fluid selector, containing an object that is keyed by function name and contains selector\n * functions. Each function will have the view state, fluid state, and data props passed into it\n * as parameters in the combined state. Selector functions can also optionally pass in a\n * handle to fetch from the Fluid object map.\n * Selector functions are used to retrieve Fluid objects or parameters from other Fluid objects.\n * It offers a way to fetch these values and return them to the view, with the\n * Fluid object map being updated if the view requires a Fluid object that hasn't been locally loaded yet\n */\nexport interface IFluidSelector<\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n    > {\n    [key: string]:\n    | FluidSelectorFunction<SV, SF, C>\n    | FluidObjectSelectorFunction<SV, SF, C>;\n}\n\n/**\n * Props passed in to create a FluidReactView or passed in to the useStateFluid hook\n */\nexport interface IFluidProps<\n    SV extends IViewState,\n    SF extends IFluidState\n    > {\n    /**\n     *  Unique ID to use for storing the synced state in the SyncedDataObject's syncedState SharedMap\n     */\n    syncedStateId: string;\n    /**\n     * An instance of the SyncedDataObject that this view will be rendered in\n     */\n    syncedDataObject: SyncedDataObject;\n    /**\n     * Data props containing the Fluid object map and the runtime\n     * Optional as the above two will be passed by default. This only need to be defined\n     * if there are additional values from the Fluid object lifecycle that need to be made\n     * available to the reducers\n     */\n    dataProps?: IFluidDataProps;\n}\n\n/**\n * View converters to take the synced state Fluid value that they are keyed against in the FluidToView map\n * and convert them into their view state counterparts\n */\nexport interface IViewConverter<\n    SV extends IViewState,\n    SF extends IFluidState\n    > {\n    /**\n     * The type of object this key in the Fluid state holds\n     */\n    type: string;\n    /**\n     * The corresponding value key within the view state type\n     */\n    viewKey: keyof SV;\n    /**\n     * A callback that takes in the partial Fluid state containing the value that\n     * this converter maps to, and returns the corresponding partial view state\n     */\n    viewConverter?: (\n        viewState: SV,\n        fluidState: Partial<SF>,\n        fluidObjectMap: FluidObjectMap\n    ) => Partial<SV>;\n    /**\n     * If this is a fluid DDS SharedObject type (i.e. SharedCounter, SharedMap), supply its create function\n     * here and add any events that it will fire to the listenedEvents param below to trigger state updates\n     */\n    sharedObjectCreate?: (runtime: IFluidDataStoreRuntime) => any;\n    /**\n     * List of events fired on this Fluid object that will trigger a state update\n     */\n    listenedEvents?: string[];\n    /**\n     * If this Fluid object is stored on the Fluid DataObject root under a different key\n     * than the name of this Fluid state key within the synced state map,\n     * provide the key on the root for this object here. The changes will also\n     * reflect under that key if the data needs to be used elsewhere\n     */\n    rootKey?: string;\n}\n\n/**\n * Fluid converters to take the view state value that they are keyed against in the ViewToFluid map\n * and convert them into their synced Fluid state counterparts\n */\nexport interface IFluidConverter<\n    SV extends IViewState,\n    SF extends IFluidState\n    > {\n    /**\n     * The type of object this key in the view state holds\n     */\n    type: string;\n    /**\n     * The corresponding value within the Fluid state\n     */\n    fluidKey: keyof SF;\n    /**\n     * A callback that takes in the partial view state containing the value that\n     * this converter maps to, and optionally returns a value. This value will be automatically set on the synced state\n     * under the view key this converter maps to\n     */\n    fluidConverter?: (viewState: SV, fluidState: Partial<SF>) => any;\n}\n\n/**\n * Base interface to extend from for the Fluid state. These values can and should be left\n * undefined when passing in the initial state as they will be used to establish the Fluid state\n */\nexport interface IFluidState {\n    /**\n     * The unique state ID for this React Fluid view\n     */\n    syncedStateId?: string;\n    /**\n     * Boolean indicating if any DDSes or Fluid objects on this state are being listened on\n     * for synced state updates to trigger React state updates\n     */\n    isInitialized?: boolean;\n}\n\n/**\n * Base interface to extend from for the view state.\n * This should be crafted based off of what the view will use from the Fluid state.\n */\nexport interface IViewState\n    extends IFluidState {\n    /**\n     * The map containing the locally available Fluid objects that have been loaded. If there are\n     * any Fluid objects loaded during initialization that the view needs to use,\n     * they should be fetched and loaded in here.\n     * Any new Fluid objects added through reducers/selectors during the React lifecycle\n     * will be automatically added to this map and the state will re-update when they become asynchronously available\n     */\n    fluidObjectMap?: FluidObjectMap;\n}\n\nexport type IFluidReactState = IFluidState & IViewState;\n\nexport const instanceOfIFluidLoadable = (\n    object: any,\n): object is IFluidLoadable =>\n    object === Object(object) && \"IFluidLoadable\" in object;\n\n/**\n * The values stored in the Fluid object map\n */\nexport interface IFluidObjectMapItem {\n    /**\n     * The actual Fluid object that the path this value is keyed against leads to\n     */\n    fluidObject?: IFluidObject & IFluidLoadable;\n    /**\n     * Boolean indicating if we are listening to changes on this Fluid object's synced state to trigger React\n     * state updates. Only set if you want custom behavior for adding listeners to your Fluid state\n     */\n    isListened?: boolean;\n    /**\n     * List of events fired on this Fluid object that will trigger a state update\n     */\n    listenedEvents?: string[];\n    /**\n     * INTERNAL\n     * Does not need to be set\n     * Is this a SharedMap that was added as a Fluid React requirement\n     */\n    isRuntimeMap?: boolean;\n}\n\n/**\n * A map of the Fluid object handle absolute path to the Fluid object\n */\nexport type FluidObjectMap = Map<string, IFluidObjectMapItem>;\n\n/**\n * Base interface to extend from for the data props that will be passed in for reducers and\n * selectors to use to offer inter-Fluid object operability\n */\nexport interface IFluidDataProps {\n    /**\n     * The Fluid data store runtime passed in from Fluid object initialization\n     */\n    runtime: IFluidDataStoreRuntime;\n    /**\n     * The running map of all the Fluid objects being used to render the React view. This\n     * can be view/data Fluid objects, and they will be asynchronously loaded here so that they are,\n     * in turn, synchronously available for the view when the state updates after they are fetched\n     */\n    fluidObjectMap: FluidObjectMap;\n}\n\n/**\n * Definition for an effect function used in reducers\n */\nexport interface FluidEffectFunction<\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n    > {\n    /**\n     * The function defined here will take the combined state and apply some\n     * logic that does not cause any state update changes\n     */\n    function: (oldState?: ICombinedState<SV, SF, C>, ...args: any) => void;\n}\n\nexport const instanceOfEffectFunction = <\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n>(\n    object: any,\n): object is FluidEffectFunction<SV, SF, C> =>\n    object === Object(object) && \"function\" in object;\n\n/**\n * Definition for an async effect function used in reducers\n */\nexport interface FluidAsyncEffectFunction<\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n    > {\n    /**\n     *  The function defined here will take the combined state and apply some\n     * async logic that does not cause any state update changes\n     */\n    asyncFunction: (\n        oldState?: ICombinedState<SV, SF, C>,\n        ...args: any\n    ) => Promise<void>;\n}\n\nexport const instanceOfAsyncEffectFunction = <\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n>(\n    object: any,\n): object is FluidAsyncEffectFunction<SV, SF, C> =>\n    object === Object(object) && \"asyncFunction\" in object;\n\n/**\n * Definition for a state update function used in reducers\n */\nexport interface FluidStateUpdateFunction<\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n    > {\n    /**\n     * The function defined here will take the combined state and update either\n     * the Fluid state, the view state, or both. The new combined state and any new Fluid object\n     * handles to load in are returned by the function.\n     */\n    function: (\n        oldState?: ICombinedState<SV, SF, C>,\n        ...args: any\n    ) => IStateUpdateResult<SV, SF, C>;\n}\n\nexport const instanceOfStateUpdateFunction = <\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n>(\n    object: any,\n): object is FluidStateUpdateFunction<SV, SF, C> =>\n    object === Object(object) && \"function\" in object;\n\n/**\n * Definition for an async state update function used in reducers\n */\nexport interface FluidAsyncStateUpdateFunction<\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n    > {\n    /**\n     * The function defined here will take the combined state and update either\n     * the Fluid state, the view state, or both in an async manner. The new combined state and any new\n     * Fluid object handles to load in will be returned by the function when it finishes.\n     */\n    asyncFunction: (\n        oldState?: ICombinedState<SV, SF, C>,\n        ...args: any\n    ) => Promise<IStateUpdateResult<SV, SF, C>>;\n}\n\n/**\n * The value returned by state update functions.\n */\nexport interface IStateUpdateResult<\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n    > {\n    /**\n     * The new view and Fluid states that were updated by the function\n     */\n    state: ICombinedState<SV, SF, C>;\n    /**\n     * Any new Fluid objects that were added in due this function need to have\n     * their corresponding handles passed in so that the object can also be loaded for all other users\n     */\n    newFluidHandles?: IFluidHandle[];\n}\n\nexport const instanceOfAsyncStateUpdateFunction = <\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n>(\n    object: any,\n): object is FluidAsyncStateUpdateFunction<SF, SV, C> =>\n    object === Object(object) && \"asyncFunction\" in object;\n\n/**\n * Definition for a selector function used in selectors\n */\nexport interface FluidSelectorFunction<\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n    > {\n    /**\n     * The function defined here will take the combined state and return\n     * to the view any values that it needs  from other values/Fluid objects that were passed\n     * in to the data props on initializing.\n     * It will also return any new Fluid handles that will be needed for other users to render the view value\n     */\n    function: (\n        state?: ICombinedState<SV, SF, C>\n    ) => {\n        result: any | undefined;\n        newFluidHandles?: IFluidHandle[];\n    };\n}\n\n/**\n * Definition for a Fluid object selector function used in selectors\n */\nexport interface FluidObjectSelectorFunction<\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n    > {\n    /**\n     * Similar to the FluidSelectorFunction's function but this also takes in a\n     * handle if we need to fetch a Fluid object from the fluidObjectMap\n     */\n    function: (\n        handle: IFluidHandle<any>,\n        state?: ICombinedState<SV, SF, C>,\n    ) => {\n        result: IFluidObject | undefined;\n        newFluidHandles?: IFluidHandle[];\n    };\n}\n\nexport const instanceOfSelectorFunction = <\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n>(\n    object: any,\n): object is FluidSelectorFunction<SV, SF, C> =>\n    object === Object(object) && \"function\" in object;\n\nexport const instanceOfFluidObjectSelectorFunction = <\n    SV extends IViewState,\n    SF extends IFluidState,\n    C extends IFluidDataProps\n>(\n    object: any,\n): object is FluidObjectSelectorFunction<SV, SF, C> =>\n    object === Object(object) && \"function\" in object;\n\n/**\n * Props passed in to the useReducerFluid hook\n */\nexport interface IFluidReducerProps<\n    SV extends IViewState,\n    SF extends IFluidState,\n    A extends IFluidReducer<SV, SF, C>,\n    B,\n    C extends IFluidDataProps\n    > {\n    /**\n     * Unique ID to use for storing the view's synced state in the SyncedDataObject's syncedState SharedMap\n     */\n    syncedStateId: string;\n    /**\n     * An instance of the SyncedDataObject that this will be rendered in\n     */\n    syncedDataObject: SyncedDataObject;\n    /**\n     * The Fluid reducer containing all the functions as defined by an extension of the IFluidReducer type.\n     * Any mutations to the state, or effects outside of the Fluid object involving the state should be done here.\n     */\n    reducer: A;\n    /**\n     * The Fluid selector containing all the functions as defined by an extension of the IFluidSelector\n     * type. Any fetching of new Fluid objects or data from other Fluid objects should be done here.\n     */\n    selector: B;\n    /**\n     * Data props that are loaded in during the Fluid initialization step. This contains the runtime\n     * and the Fluid object map\n     * TODO: Move data props out as it can be fetched from synced Fluid data object but\n     * still needs to be extensible for reducers\n     */\n    dataProps?: C;\n}\n\n/**\n * Props containing the context that will be passed down through the Fluid context provider to the consumer\n */\nexport interface IFluidContextProps<SV, SF, C> extends IFluidProps<SV, SF> {\n    /**\n     * The additional data that will be passed through the Fluid context\n     */\n    reactContext?: C;\n}\n\n/**\n * The state that is available through the react context\n */\nexport interface FluidContextState<\n    SV extends IViewState,\n    C\n    > {\n    /**\n     * The view state\n     */\n    state: SV;\n    /**\n     * Callback to update the state\n     */\n    setState: (state: SV) => void;\n    /**\n     * The context passed in from the props\n     */\n    reactContext: Partial<C>;\n}\n\n/**\n * The returned value of createFluidContext\n */\nexport interface FluidContext<\n    SV extends IViewState,\n    C\n    > {\n    /**\n     * The context provider React component that will give the FluidContextState to\n     * its children\n     */\n    Provider: React.ProviderExoticComponent<\n        React.ProviderProps<FluidContextState<SV, C>>\n    >;\n    /**\n     * The context consumer that allows children to use the FluidContextState\n     */\n    Consumer: React.Consumer<FluidContextState<SV, C>>;\n    /**\n     * Callback to get the context\n     */\n    usePrimedContext: () => FluidContextState<SV, C>;\n    /**\n     * The view state\n     */\n    state: SV;\n    /**\n     * Callback to update the state\n     */\n    setState: (newState: SV) => void;\n}\n\nexport interface ISyncedStateConfig<SV, SF> {\n    /**\n     * Unique ID to use for storing the view's synced state in the SyncedDataObject's syncedState SharedMap\n     */\n    syncedStateId: string;\n    /**\n     * The backup default view that any view with this ID will use prior to Fluid state initializing, this can be\n     * overridden by the view developer themselves\n     */\n    defaultViewState: SV;\n    /**\n     * A map of the Fluid state values that need conversion to their view state counterparts and the\n     * respective converters\n     */\n    fluidToView: FluidToViewMap<SV, SF>;\n    /**\n     * A map of the view state values that need conversion to their Fluid state counterparts and the\n     * respective converters\n     */\n    viewToFluid?: ViewToFluidMap<SV, SF>;\n}\n\n/**\n * The configurations that define the relationships between Fluid and view states for\n * views that are rendered in a SyncedDataObject\n */\nexport type SyncedStateConfig = Map<string, ISyncedStateConfig<any, any>>;\n\n/**\n * The interface for interacting with the synced state that is stored on a SyncedDataObject\n */\nexport interface ISyncedState {\n    /**\n     * Set values on the synced state for a syncedStateId as key\n     */\n    set: (key: string, value: any) => void;\n    /**\n     * Get values from the synced state for a syncedStateId as key\n     */\n    get: <T>(key: string) => T | undefined;\n    /**\n     * Add a listener to the synced state using a provided callback\n     */\n    addValueChangedListener: (\n        callback: (changed: IDirectoryValueChanged, local: boolean) => void) => void;\n}\n"]}