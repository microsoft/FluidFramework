{"version":3,"file":"useReducerFluid.js","sourceRoot":"","sources":["../src/useReducerFluid.tsx"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as React from \"react\";\nimport { IFluidHandle } from \"@fluidframework/core-interfaces\";\nimport { SharedMap } from \"@fluidframework/map\";\nimport {\n    IViewState,\n    IFluidReducerProps,\n    IFluidDataProps,\n    instanceOfStateUpdateFunction,\n    instanceOfAsyncStateUpdateFunction,\n    instanceOfSelectorFunction,\n    instanceOfFluidObjectSelectorFunction,\n    instanceOfEffectFunction,\n    instanceOfAsyncEffectFunction,\n    IStateUpdateResult,\n    IFluidState,\n    IFluidReducer,\n    IFluidSelector,\n    ICombinedState,\n    ISyncedStateConfig,\n} from \"./interface\";\nimport { useStateFluid } from \"./useStateFluid\";\nimport {\n    updateStateAndFluidObjectMap,\n    syncedStateCallbackListener,\n    getFluidState,\n    syncState,\n    getSchema,\n} from \"./helpers\";\n\nexport function useReducerFluid<\n    SV extends IViewState,\n    SF extends IFluidState,\n    A extends IFluidReducer<SV, SF, C>,\n    B extends IFluidSelector<SV, SF, C>,\n    C extends IFluidDataProps\n>(\n    props: IFluidReducerProps<SV, SF, A, B, C>,\n    initialViewState: SV,\n): [ICombinedState<SV, SF, C>, A, B] {\n    const {\n        syncedStateId,\n        reducer,\n        selector,\n        syncedDataObject,\n    } = props;\n    const config = syncedDataObject.getConfig(syncedStateId);\n    if (config === undefined) {\n        throw Error(`Failed to find configuration for synced state ID: ${syncedStateId}`);\n    }\n    const dataProps = props.dataProps ?? syncedDataObject.dataProps as C;\n    // Get our combined synced state and setState callbacks from the useStateFluid function\n    const [viewState, setState] = useStateFluid<SV, SF>({\n        syncedStateId,\n        syncedDataObject,\n        dataProps,\n    }, initialViewState);\n    const syncedState = syncedDataObject.syncedState;\n    const { fluidToView, viewToFluid } = config as ISyncedStateConfig<SV, SF>;\n\n    const schemaHandles = getSchema(\n        syncedStateId,\n        syncedState,\n    );\n    if (schemaHandles?.storedHandleMapHandle.absolutePath === undefined) {\n        throw Error(`Component schema not initialized prior to render for ${syncedStateId}`);\n    }\n    const storedHandleMap = dataProps.fluidObjectMap.get(\n        schemaHandles?.storedHandleMapHandle.absolutePath,\n    )?.fluidObject as SharedMap;\n    if (storedHandleMap === undefined) {\n        throw Error(`Stored handle map not initialized prior to render for ${syncedStateId}`);\n    }\n\n    // Dispatch is an in-memory object that will load the reducer actions provided by the user\n    // and add updates to the view and Fluid state based off of the type of function and\n    // state values that were updated. Think of it as prepping the data in the first\n    // stage of dynamic programming. The dispatch functions are copies of the user-defined functions\n    // but with the updates to synced state also handled\n    const dispatch = React.useCallback(\n        (\n            type: keyof A,\n            dispatchState?: ICombinedState<SV, SF, C>,\n            ...args: any\n        ) => {\n            // Retrieve the current state that is stored on the synced state for this Fluid object ID\n            const currentFluidState = getFluidState(\n                syncedStateId,\n                syncedState,\n                dataProps.fluidObjectMap,\n                fluidToView,\n            );\n            if (currentFluidState === undefined) {\n                throw Error(\n                    \"Attempted to dispatch function before fluid state was initialized\",\n                );\n            }\n            const combinedDispatchFluidState: SF = {\n                ...currentFluidState,\n                ...dispatchState?.fluidState,\n            };\n            const combinedDispatchViewState: SV = {\n                ...viewState,\n                ...dispatchState?.viewState,\n            };\n            const combinedDispatchDataProps: C = {\n                ...dataProps,\n                ...dispatchState?.dataProps,\n            };\n            const combinedDispatchState = {\n                fluidState: combinedDispatchFluidState,\n                viewState: combinedDispatchViewState,\n                dataProps: combinedDispatchDataProps,\n            };\n            const action = reducer[type];\n            if (action !== undefined) {\n                if (instanceOfStateUpdateFunction<SV, SF, C>(action)) {\n                    // If its a synchronous state update function, call it and inspect the result\n                    // for new Fluid object handles\n                    const result = (action.function as any)(\n                        combinedDispatchState,\n                        ...args,\n                    );\n                    if (result.newComponentHandles !== undefined) {\n                        // Fetch any new Fluid objects and add a listener to their synced state.\n                        // Then update the view state.\n                        const callback = syncedStateCallbackListener(\n                            combinedDispatchDataProps.fluidObjectMap,\n                            storedHandleMap,\n                            syncedStateId,\n                            syncedState,\n                            combinedDispatchDataProps.runtime,\n                            result.state.viewState,\n                            setState,\n                            fluidToView,\n                            viewToFluid,\n                        );\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                        updateStateAndFluidObjectMap(\n                            result.newComponentHandles,\n                            combinedDispatchDataProps.fluidObjectMap,\n                            storedHandleMap,\n                            false,\n                            syncedStateId,\n                            syncedState,\n                            combinedDispatchDataProps.runtime,\n                            result.state.viewState,\n                            setState,\n                            callback,\n                            fluidToView,\n                            viewToFluid,\n                        );\n                    } else {\n                        // Update the state directly\n                        syncState(\n                            false,\n                            syncedStateId,\n                            syncedState,\n                            combinedDispatchDataProps.runtime,\n                            result.state.viewState,\n                            setState,\n                            combinedDispatchDataProps.fluidObjectMap,\n                            fluidToView,\n                            viewToFluid,\n                        );\n                    }\n                } else if (instanceOfAsyncStateUpdateFunction<SV, SF, C>(action)) {\n                    // In the case of an async function, the function promise is treated as a Thenable\n                    // and the returned result is inspected after the function has completed\n                    (action.asyncFunction as any)(\n                        combinedDispatchState,\n                        ...args,\n                    ).then((result: IStateUpdateResult<SV, SF, C>) => {\n                        const callback = syncedStateCallbackListener(\n                            combinedDispatchDataProps.fluidObjectMap,\n                            storedHandleMap,\n                            syncedStateId,\n                            syncedState,\n                            combinedDispatchDataProps.runtime,\n                            result.state.viewState,\n                            setState,\n                            fluidToView,\n                            viewToFluid,\n                        );\n                        if (result.newFluidHandles !== undefined) {\n                            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                            updateStateAndFluidObjectMap(\n                                result.newFluidHandles,\n                                combinedDispatchDataProps.fluidObjectMap,\n                                storedHandleMap,\n                                false,\n                                syncedStateId,\n                                syncedState,\n                                combinedDispatchDataProps.runtime,\n                                result.state.viewState,\n                                setState,\n                                callback,\n                                fluidToView,\n                                viewToFluid,\n                            );\n                        } else {\n                            syncState(\n                                false,\n                                syncedStateId,\n                                syncedState,\n                                combinedDispatchDataProps.runtime,\n                                result.state.viewState,\n                                setState,\n                                combinedDispatchDataProps.fluidObjectMap,\n                                fluidToView,\n                                viewToFluid,\n                            );\n                        }\n                    });\n                } else if (instanceOfAsyncEffectFunction<SV, SF, C>(action)) {\n                    (action.asyncFunction as any)(\n                        combinedDispatchState,\n                        ...args,\n                    ).then(() =>\n                        syncState(\n                            false,\n                            syncedStateId,\n                            syncedState,\n                            combinedDispatchDataProps.runtime,\n                            combinedDispatchState.viewState,\n                            setState,\n                            combinedDispatchDataProps.fluidObjectMap,\n                            fluidToView,\n                            viewToFluid,\n                        ),\n                    );\n                } else if (instanceOfEffectFunction<SV, SF, C>(action)) {\n                    (action.function as any)(combinedDispatchState, ...args);\n                    syncState(\n                        false,\n                        syncedStateId,\n                        syncedState,\n                        combinedDispatchDataProps.runtime,\n                        combinedDispatchState.viewState,\n                        setState,\n                        combinedDispatchDataProps.fluidObjectMap,\n                        fluidToView,\n                        viewToFluid,\n                    );\n                } else {\n                    throw new Error(\n                        `Action with key ${action} does not match an expected reducer action interface`,\n                    );\n                }\n            } else {\n                throw new Error(\n                    `Action with key ${action} does not\n                 exist in the reducers provided`,\n                );\n            }\n        },\n        [reducer, viewState, setState, dataProps],\n    );\n\n    // The combinedReducer is then created using the dispatch functions we created above.\n    // This allows us to preserve the reducer interface while injecting Fluid-specific logic\n    // into the updating of the state. This is the second phase of DP, using the earlier created\n    // in-memory object to access the function the user is trying to use in constant time and then,\n    // subsequently performing it, taking the updated state, and applying it both locally and remotely\n    const combinedReducer = {};\n    Object.entries(reducer).forEach(([functionName, functionItem], i) => {\n        if ((functionItem as any).asyncFunction !== undefined) {\n            combinedReducer[functionName] = {\n                asyncFunction: (\n                    dispatchState: ICombinedState<SV, SF, C>,\n                    ...args: any\n                ) => dispatch(functionName, dispatchState, ...args),\n            };\n        } else {\n            combinedReducer[functionName] = {\n                function: (\n                    dispatchState: ICombinedState<SV, SF, C>,\n                    ...args: any\n                ) => dispatch(functionName, dispatchState, ...args),\n            };\n        }\n    });\n\n    // Fetch is an in-memory object similar to dispatch, but now made for selector actions.\n    // Selectors are NOT used for updating the state but instead to be able to access\n    // and add other Fluid Fluid objects using the handle provided. If the handle provided is not available\n    // in our Fluid object map, it will be dynamically updated and setState will be called again\n    // with the updated Fluid object map available for use.\n    // Alternatively, if you would like to pre-load Fluid objects before React is initialized,\n    // you can do so and provide them in dataProps.\n    // Fetch can also be used to retrieve data from these Fluid objects as they will also be available as a parameter.\n    const fetch = React.useCallback(\n        (\n            type: keyof B,\n            fetchState?: ICombinedState<SV, SF, C>,\n            handle?: IFluidHandle,\n        ) => {\n            // Retrieve the current state that is stored on the syncedState for this Fluid object ID\n            const currentFluidState = getFluidState(\n                syncedStateId,\n                syncedState,\n                dataProps.fluidObjectMap,\n                fluidToView,\n            );\n            if (currentFluidState === undefined) {\n                throw Error(\n                    \"Attempted to dispatch function before fluid state was initialized\",\n                );\n            }\n            const combinedFetchFluidState: SF = {\n                ...currentFluidState,\n                ...fetchState?.fluidState,\n            };\n            const combinedFetchViewState: SV = {\n                ...viewState,\n                ...fetchState?.viewState,\n            };\n            const combinedFetchDataProps: C = {\n                ...dataProps,\n                ...fetchState?.dataProps,\n            };\n            const combinedFetchState = {\n                fluidState: combinedFetchFluidState,\n                viewState: combinedFetchViewState,\n                dataProps: combinedFetchDataProps,\n            };\n            const action = selector[type];\n            if (action !== undefined) {\n                if (instanceOfSelectorFunction<SV, SF, C>(action)) {\n                    // Add any new handles that were returned by the selector to our list\n                    // to be loaded to the fluid Fluid object map\n                    let newHandles: IFluidHandle[] = [];\n                    if (\n                        handle !== undefined &&\n                        instanceOfFluidObjectSelectorFunction<SV, SF, C>(action) &&\n                        combinedFetchDataProps.fluidObjectMap.get(\n                            handle.absolutePath,\n                        ) === undefined\n                    ) {\n                        newHandles.push(handle);\n                    }\n                    const actionResult = (action.function as any)(\n                        combinedFetchState,\n                        handle,\n                    );\n                    if (\n                        actionResult !== undefined &&\n                        actionResult.newComponentHandles !== undefined\n                    ) {\n                        newHandles = newHandles.concat(\n                            actionResult.newComponentHandles,\n                        );\n                    }\n                    // If there are handles, start a call to update the Fluid object map and then call the set state\n                    // callback when it has finished to provide the updated map in the state\n                    if (newHandles.length > 0) {\n                        const callback = syncedStateCallbackListener(\n                            combinedFetchDataProps.fluidObjectMap,\n                            storedHandleMap,\n                            syncedStateId,\n                            syncedState,\n                            combinedFetchDataProps.runtime,\n                            combinedFetchState.viewState,\n                            setState,\n                            fluidToView,\n                            viewToFluid,\n                        );\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                        updateStateAndFluidObjectMap(\n                            newHandles,\n                            combinedFetchDataProps.fluidObjectMap,\n                            storedHandleMap,\n                            true,\n                            syncedStateId,\n                            syncedState,\n                            combinedFetchDataProps.runtime,\n                            combinedFetchState.viewState,\n                            setState,\n                            callback,\n                            fluidToView,\n                            viewToFluid,\n                        );\n                    }\n                    // Always return the result immediately\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    return actionResult;\n                } else {\n                    throw new Error(\n                        `Action with key ${action} does not match an expected selector action interface`,\n                    );\n                }\n            } else {\n                throw new Error(\n                    `Action with key ${action} does not\n                 exist in the selectors provided`,\n                );\n            }\n        },\n        [selector, viewState, setState, dataProps],\n    );\n\n    // The combined selector is then similarly created with the Fluid-specific logic of adding any new Fluid objects\n    // to our Fluid object map interjected into the setState logic\n    const combinedSelector = {};\n    Object.entries(selector).forEach(([functionName, functionItem], i) => {\n        combinedSelector[functionName] = {\n            function: (\n                fetchState: ICombinedState<SV, SF, C>,\n                handle?: IFluidHandle,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            ) => fetch(functionName, fetchState, handle),\n        };\n    });\n\n    // Retrieve the current state that is stored on the syncedState for this Fluid object ID\n    const fluidState = getFluidState(\n        syncedStateId,\n        syncedState,\n        dataProps.fluidObjectMap,\n        fluidToView,\n    );\n\n    return [\n        {\n            viewState,\n            fluidState,\n            dataProps,\n        },\n        combinedReducer as A,\n        combinedSelector as B,\n    ];\n}\n"]}