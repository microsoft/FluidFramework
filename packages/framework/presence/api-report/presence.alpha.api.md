## Alpha API Report File for "@fluidframework/presence"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @beta @system
export type Accessor<T, BaseAccessor extends ValueAccessor<T>> = BaseAccessor extends ProxiedValueAccessor<T> ? () => DeepReadonly<JsonDeserialized<T>> | undefined : BaseAccessor extends RawValueAccessor<T> ? DeepReadonly<JsonDeserialized<T>> : never;

// @beta @sealed
export interface Attendee<SpecificAttendeeId extends AttendeeId = AttendeeId> {
    readonly attendeeId: SpecificAttendeeId;
    getConnectionId(): ClientConnectionId;
    getConnectionStatus(): AttendeeStatus;
}

// @beta
export type AttendeeId = SessionId & {
    readonly AttendeeId: "AttendeeId";
};

// @beta @sealed
export interface AttendeesEvents {
    // @eventProperty
    attendeeConnected: (attendee: Attendee) => void;
    // @eventProperty
    attendeeDisconnected: (attendee: Attendee) => void;
}

// @beta
export const AttendeeStatus: {
    readonly Connected: "Connected";
    readonly Disconnected: "Disconnected";
};

// @beta
export type AttendeeStatus = (typeof AttendeeStatus)[keyof typeof AttendeeStatus];

// @beta @sealed
export interface BroadcastControls {
    allowableUpdateLatencyMs: number | undefined;
}

// @beta
export interface BroadcastControlSettings {
    readonly allowableUpdateLatencyMs?: number;
}

// @beta
export type ClientConnectionId = string;

// @alpha @sealed @deprecated
export class ExperimentalPresenceDO {
}

// @alpha @deprecated
export const ExperimentalPresenceManager: SharedObjectKind<IFluidLoadable & ExperimentalPresenceDO>;

// @beta
export const getPresence: (fluidContainer: IFluidContainer) => Presence;

// @alpha
export function getPresenceAlpha(fluidContainer: IFluidContainer): PresenceWithNotifications;

// @alpha @deprecated
export function getPresenceViaDataObject(fluidLoadable: ExperimentalPresenceDO): PresenceWithNotifications;

// @beta @system
export namespace InternalTypes {
    // @system
    export type ManagerFactory<TKey extends string, TValue extends ValueDirectoryOrState<any>, TManager> = {
        instanceBase: new (...args: any[]) => any;
    } & ((key: TKey, datastoreHandle: StateDatastoreHandle<TKey, TValue>) => {
        initialData?: {
            value: TValue;
            allowableUpdateLatencyMs: number | undefined;
        };
        manager: StateValue<TManager>;
    });
    // @system
    export interface MapValueState<T, Keys extends string | number> {
        // (undocumented)
        items: {
            [name in Keys]: ValueOptionalState<T>;
        };
        // (undocumented)
        rev: number;
    }
    // @system
    export interface NotificationType {
        // (undocumented)
        args: unknown[];
        // (undocumented)
        name: string;
    }
    // @system
    export class StateDatastoreHandle<TKey, TValue extends ValueDirectoryOrState<any>> {
    }
    // @system
    export type StateValue<T> = T & StateValueBrand<T>;
    // @system
    export class StateValueBrand<T> {
    }
    // @system
    export interface ValueDirectory<T> {
        // (undocumented)
        items: {
            [name: string | number]: ValueOptionalState<T> | ValueDirectory<T>;
        };
        // (undocumented)
        rev: number;
    }
    // @system
    export type ValueDirectoryOrState<T> = ValueRequiredState<T> | ValueDirectory<T>;
    // @system
    export interface ValueOptionalState<TValue> extends ValueStateMetadata {
        // (undocumented)
        value?: OpaqueJsonDeserialized<TValue>;
    }
    // @system
    export interface ValueRequiredState<TValue> extends ValueStateMetadata {
        // (undocumented)
        value: OpaqueJsonDeserialized<TValue>;
    }
    // @system
    export interface ValueStateMetadata {
        // (undocumented)
        rev: number;
        // (undocumented)
        timestamp: number;
    }
}

// @alpha @system
export namespace InternalUtilityTypes {
    // @system
    export type IfNotificationListener<Event, IfListener, Else> = Event extends (...args: infer P) => void ? InternalUtilityTypes_2.IfSameType<P, JsonSerializable<P>, IfListener, Else> : Else;
    // @system
    export type JsonDeserializedParameters<T extends (...args: any[]) => any> = T extends (...args: infer P) => any ? JsonDeserialized<P> : never;
    // @system
    export type JsonSerializableParameters<T extends (...args: any[]) => any> = T extends (...args: infer P) => any ? JsonSerializable<P> : never;
    // @system
    export type NotificationListeners<E> = {
        [P in keyof E as IfNotificationListener<E[P], P, never>]: E[P];
    };
}

// @beta @sealed
export interface Latest<T, TRemoteAccessor extends ValueAccessor<T> = ProxiedValueAccessor<T>> {
    readonly controls: BroadcastControls;
    readonly events: Listenable<LatestEvents<T, TRemoteAccessor>>;
    getRemote(attendee: Attendee): LatestData<T, TRemoteAccessor>;
    getRemotes(): IterableIterator<LatestClientData<T, TRemoteAccessor>>;
    getStateAttendees(): Attendee[];
    get local(): DeepReadonly<JsonDeserialized<T>>;
    set local(value: JsonSerializable<T>);
    readonly presence: Presence;
}

// @beta @input
export interface LatestArguments<T extends object | null> extends LatestArgumentsRaw<T> {
    validator: StateSchemaValidator<T>;
}

// @beta @input
export interface LatestArgumentsRaw<T extends object | null> {
    local: JsonSerializable<T>;
    settings?: BroadcastControlSettings | undefined;
}

// @beta @sealed
export interface LatestClientData<T, TValueAccessor extends ValueAccessor<T> = ProxiedValueAccessor<T>> extends LatestData<T, TValueAccessor> {
    attendee: Attendee;
}

// @beta @sealed
export interface LatestData<T, TValueAccessor extends ValueAccessor<T>> {
    metadata: LatestMetadata;
    value: Accessor<T, TValueAccessor>;
}

// @beta @sealed
export interface LatestEvents<T, TRemoteValueAccessor extends ValueAccessor<T> = ProxiedValueAccessor<T>> {
    // @eventProperty
    localUpdated: (update: {
        value: DeepReadonly<JsonSerializable<T>>;
    }) => void;
    // @eventProperty
    remoteUpdated: (update: LatestClientData<T, TRemoteValueAccessor>) => void;
}

// @beta @sealed
export interface LatestFactory {
    <T extends object | null, Key extends string = string>(args: LatestArguments<T>): InternalTypes.ManagerFactory<Key, InternalTypes.ValueRequiredState<T>, Latest<T>>;
    <T extends object | null, Key extends string = string>(args: LatestArgumentsRaw<T>): InternalTypes.ManagerFactory<Key, InternalTypes.ValueRequiredState<T>, LatestRaw<T>>;
}

// @beta @sealed
export interface LatestMap<T, Keys extends string | number = string | number, TRemoteAccessor extends ValueAccessor<T> = ProxiedValueAccessor<T>> {
    readonly controls: BroadcastControls;
    readonly events: Listenable<LatestMapEvents<T, Keys, TRemoteAccessor>>;
    getRemote(attendee: Attendee): ReadonlyMap<Keys, LatestData<T, TRemoteAccessor>>;
    getRemotes(): IterableIterator<LatestMapClientData<T, Keys, TRemoteAccessor>>;
    getStateAttendees(): Attendee[];
    readonly local: StateMap<Keys, T>;
    readonly presence: Presence;
}

// @beta @input
export interface LatestMapArgumentsRaw<T, Keys extends string | number = string | number> {
    local?: {
        [K in Keys]: JsonSerializable<T>;
    };
    settings?: BroadcastControlSettings | undefined;
}

// @beta @sealed
export interface LatestMapClientData<T, Keys extends string | number, TValueAccessor extends ValueAccessor<T>, SpecificAttendeeId extends AttendeeId = AttendeeId> {
    attendee: Attendee<SpecificAttendeeId>;
    items: ReadonlyMap<Keys, LatestData<T, TValueAccessor>>;
}

// @beta @sealed
export interface LatestMapEvents<T, K extends string | number, TRemoteValueAccessor extends ValueAccessor<T> = ProxiedValueAccessor<T>> {
    // @eventProperty
    localItemRemoved: (removedItem: {
        key: K;
    }) => void;
    // @eventProperty
    localItemUpdated: (updatedItem: {
        value: DeepReadonly<JsonSerializable<T>>;
        key: K;
    }) => void;
    // @eventProperty
    remoteItemRemoved: (removedItem: LatestMapItemRemovedClientData<K>) => void;
    // @eventProperty
    remoteItemUpdated: (updatedItem: LatestMapItemUpdatedClientData<T, K, TRemoteValueAccessor>) => void;
    // @eventProperty
    remoteUpdated: (updates: LatestMapClientData<T, K, TRemoteValueAccessor>) => void;
}

// @beta @sealed
export interface LatestMapFactory {
    <T, Keys extends string | number = string | number, RegistrationKey extends string = string>(args?: LatestMapArgumentsRaw<T, Keys>): InternalTypes.ManagerFactory<RegistrationKey, InternalTypes.MapValueState<T, Keys>, LatestMapRaw<T, Keys>>;
}

// @beta @sealed
export interface LatestMapItemRemovedClientData<K extends string | number> {
    attendee: Attendee;
    key: K;
    metadata: LatestMetadata;
}

// @beta @sealed
export interface LatestMapItemUpdatedClientData<T, K extends string | number, TValueAccessor extends ValueAccessor<T>> extends LatestClientData<T, TValueAccessor> {
    key: K;
}

// @beta @sealed
export type LatestMapRaw<T, Keys extends string | number = string | number> = LatestMap<T, Keys, RawValueAccessor<T>>;

// @beta @sealed
export type LatestMapRawEvents<T, K extends string | number> = LatestMapEvents<T, K, RawValueAccessor<T>>;

// @beta @sealed
export interface LatestMetadata {
    revision: number;
    timestamp: number;
}

// @beta @sealed
export type LatestRaw<T> = Latest<T, RawValueAccessor<T>>;

// @beta @sealed
export type LatestRawEvents<T> = LatestEvents<T, RawValueAccessor<T>>;

// @alpha @sealed
export interface NotificationEmitter<E extends InternalUtilityTypes.NotificationListeners<E>> {
    broadcast<K extends keyof InternalUtilityTypes.NotificationListeners<E>>(notificationName: K, ...args: Parameters<E[K]>): void;
    unicast<K extends keyof InternalUtilityTypes.NotificationListeners<E>>(notificationName: K, targetAttendee: Attendee, ...args: Parameters<E[K]>): void;
}

// @alpha @sealed
export interface NotificationListenable<TListeners extends InternalUtilityTypes.NotificationListeners<TListeners>> {
    off<K extends keyof InternalUtilityTypes.NotificationListeners<TListeners>>(notificationName: K, listener: (sender: Attendee, ...args: InternalUtilityTypes.JsonDeserializedParameters<TListeners[K]>) => void): void;
    on<K extends keyof InternalUtilityTypes.NotificationListeners<TListeners>>(notificationName: K, listener: (sender: Attendee, ...args: InternalUtilityTypes.JsonDeserializedParameters<TListeners[K]>) => void): Off;
}

// @alpha
export function Notifications<T extends InternalUtilityTypes.NotificationListeners<T>, Key extends string = string>(initialSubscriptions: Partial<NotificationSubscriptions<T>>): InternalTypes.ManagerFactory<Key, InternalTypes.ValueRequiredState<InternalTypes.NotificationType>, NotificationsManager<T>>;

// @alpha @sealed
export interface NotificationsManager<T extends InternalUtilityTypes.NotificationListeners<T>> {
    readonly emit: NotificationEmitter<T>;
    readonly events: Listenable<NotificationsManagerEvents>;
    readonly notifications: NotificationListenable<T>;
    readonly presence: PresenceWithNotifications;
}

// @alpha @sealed (undocumented)
export interface NotificationsManagerEvents {
    // @eventProperty
    unattendedNotification: (name: string, sender: Attendee, ...content: unknown[]) => void;
}

// @alpha @sealed
export type NotificationSubscriptions<E extends InternalUtilityTypes.NotificationListeners<E>> = {
    [K in string & keyof InternalUtilityTypes.NotificationListeners<E>]: (sender: Attendee, ...args: InternalUtilityTypes.JsonDeserializedParameters<E[K]>) => void;
};

// @alpha @sealed
export interface NotificationsWorkspace<TSchema extends NotificationsWorkspaceSchema> {
    add<TKey extends string, TValue extends InternalTypes.ValueDirectoryOrState<any>, TManager extends NotificationsManager<any>>(key: TKey, manager: InternalTypes.ManagerFactory<TKey, TValue, TManager>): asserts this is NotificationsWorkspace<TSchema & Record<TKey, InternalTypes.ManagerFactory<TKey, TValue, TManager>>>;
    readonly notifications: StatesWorkspaceEntries<TSchema>;
    readonly presence: PresenceWithNotifications;
}

// @alpha
export interface NotificationsWorkspaceSchema {
    // (undocumented)
    [key: string]: InternalTypes.ManagerFactory<typeof key, InternalTypes.ValueRequiredState<InternalTypes.NotificationType>, NotificationsManager<any>>;
}

// @beta @sealed
export interface Presence {
    readonly attendees: {
        readonly events: Listenable<AttendeesEvents>;
        getAttendees(): ReadonlySet<Attendee>;
        getAttendee(clientId: ClientConnectionId | AttendeeId): Attendee;
        getMyself(): Attendee;
    };
    readonly events: Listenable<PresenceEvents>;
    readonly states: {
        getWorkspace<StatesSchema extends StatesWorkspaceSchema>(workspaceAddress: WorkspaceAddress, requestedStates: StatesSchema, controls?: BroadcastControlSettings): StatesWorkspace<StatesSchema>;
    };
}

// @beta @sealed
export interface PresenceEvents {
    workspaceActivated: (workspaceAddress: WorkspaceAddress, type: "States" | "Notifications" | "Unknown") => void;
}

// @alpha @sealed
export interface PresenceWithNotifications extends Presence {
    // (undocumented)
    readonly notifications: {
        getWorkspace<NotificationsSchema extends NotificationsWorkspaceSchema>(notificationsId: WorkspaceAddress, requestedNotifications: NotificationsSchema): NotificationsWorkspace<NotificationsSchema>;
    };
}

// @beta @system
export interface ProxiedValueAccessor<T> {
    // (undocumented)
    readonly data: T;
    // (undocumented)
    readonly kind: "proxied";
}

// @beta @system
export interface RawValueAccessor<T> {
    // (undocumented)
    readonly data: T;
    // (undocumented)
    readonly kind: "raw";
}

// @beta
export const StateFactory: {
    latest: LatestFactory;
    latestMap: LatestMapFactory;
};

// @beta @sealed
export interface StateMap<K extends string | number, V> {
    clear(): void;
    delete(key: K): boolean;
    forEach(callbackfn: (value: DeepReadonly<JsonDeserialized<V>>, key: K, map: StateMap<K, V>) => void, thisArg?: unknown): void;
    get(key: K): DeepReadonly<JsonDeserialized<V>> | undefined;
    has(key: K): boolean;
    keys(): IterableIterator<K>;
    set(key: K, value: JsonSerializable<V>): this;
    readonly size: number;
}

// @beta
export type StateSchemaValidator<T> = (
unvalidatedData: unknown) => JsonDeserialized<T> | undefined;

// @beta @sealed
export interface StatesWorkspace<TSchema extends StatesWorkspaceSchema, TManagerConstraints = unknown> {
    add<TKey extends string, TValue extends InternalTypes.ValueDirectoryOrState<any>, TManager extends TManagerConstraints>(key: TKey, manager: InternalTypes.ManagerFactory<TKey, TValue, TManager>): asserts this is StatesWorkspace<TSchema & Record<TKey, InternalTypes.ManagerFactory<TKey, TValue, TManager>>, TManagerConstraints>;
    readonly controls: BroadcastControls;
    readonly presence: Presence;
    readonly states: StatesWorkspaceEntries<TSchema>;
}

// @beta @sealed
export type StatesWorkspaceEntries<TSchema extends StatesWorkspaceSchema> = {
    /**
    * Registered State objects.
    */
    readonly [Key in keyof TSchema]: ReturnType<TSchema[Key]>["manager"] extends InternalTypes.StateValue<infer TManager> ? TManager : never;
};

// @beta
export type StatesWorkspaceEntry<TKey extends string, TValue extends InternalTypes.ValueDirectoryOrState<unknown>, TManager = unknown> = InternalTypes.ManagerFactory<TKey, TValue, TManager>;

// @beta
export interface StatesWorkspaceSchema {
    [key: string]: StatesWorkspaceEntry<typeof key, InternalTypes.ValueDirectoryOrState<any>>;
}

// @beta @system
export type ValueAccessor<T> = RawValueAccessor<T> | ProxiedValueAccessor<T>;

// @beta
export type WorkspaceAddress = `${string}:${string}`;

```
