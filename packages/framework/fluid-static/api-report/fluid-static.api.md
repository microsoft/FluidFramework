## API Report File for "@fluidframework/fluid-static"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AttachState } from '@fluidframework/container-definitions';
import { ConnectionState } from '@fluidframework/container-definitions';
import { IClient } from '@fluidframework/protocol-definitions';
import { ICompressionRuntimeOptions } from '@fluidframework/container-runtime';
import { IContainer } from '@fluidframework/container-definitions';
import { ICriticalContainerError } from '@fluidframework/container-definitions';
import { IEvent } from '@fluidframework/core-interfaces';
import { IEventProvider } from '@fluidframework/core-interfaces';
import { IFluidLoadable } from '@fluidframework/core-interfaces';
import { IRuntimeFactory } from '@fluidframework/container-definitions';
import { ISharedObjectKind } from '@fluidframework/shared-object-base';

// @public (undocumented)
export interface AzureContainerSchema extends ContainerSchema {
    // (undocumented)
    documentCompatibility?: FluidDocFormatCompatibility;
}

// @public
export type ContainerAttachProps<T = unknown> = T;

// @public
export interface ContainerSchema {
    readonly dynamicObjectTypes?: readonly LoadableObjectClass[];
    readonly initialObjects: LoadableObjectClassRecord;
}

// @internal
export function createDOProviderContainerRuntimeFactory(props: {
    schema: ContainerSchema;
    documentCompatibility?: FluidDocFormatCompatibility;
}): IRuntimeFactory;

// @internal
export function createFluidContainer<TContainerSchema extends ContainerSchema = ContainerSchema>(props: {
    container: IContainer;
    rootDataObject: IRootDataObject;
}): IFluidContainer<TContainerSchema>;

// @internal
export function createServiceAudience<TMember extends IMember = IMember>(props: {
    container: IContainer;
    createServiceMember: (audienceMember: IClient) => TMember;
}): IServiceAudience<TMember>;

// @public
export type DataObjectClass<T extends IFluidLoadable = IFluidLoadable> = {
    readonly factory: {
        IFluidDataStoreFactory: DataObjectClass<T>["factory"];
    };
} & (new (...args: any[]) => T);

// @public
export type FluidDocFormatCompatibility =
/**
* Use V1 setting in the following scenario:
* A version of your application used 1.x version of Fluid Framework and shipped that application version to production.
* There is no way to ship new application code (including Fluid Framework bits) instantly to all clients of a given application.
* This means every update must result in at least two "current" versions at a time for a while.
* These application versions need to use same (compatible) schema, for as long as old version of the application is in circulation.
* V1 settings does precisely that - it instructs FluidFramework to disable all the features that modify document schema,
* allowing full compatibility with old versions of FluidFramework library.
*
* Please note that even if you have no documents at rest (i.e. all Fluid containers are deleted as soon as all clients leave document),
* you have to use V1 setting for a while. A user could open a document and close a lid of latop, and come back after a while (day/week/month/year)
* Even if application will attempt to immidiatly close container in such cases, it's a race with FluidFramework attempting to reconnect
* to container and receive / send ops, which may result in not the best user experience.
*
* That said, once it's safe (the new version of application with FluidFramework 2.0 has been deployed and reached 99.99% saturarion),
* we highly recomend you to switch to V2 and rip all the benefits of latest changes.
*
* You should assume that FluidFramework 3.0 will remove this option. I.e. applications will be able to consume FluidFramework 3.0 only
* after they deployed application version with FluidFramework 2.0 and this version saturated in production.
*
* V1 option does not allow usage of added in 2.0 Tree data structure.
*/
    {
    compatibilityLevel: "1.x";
}
/**
* Use V2 settign in one of the following scenarios:
* 1. You are building a new application, i.e. you never used 1.x version of FluidFramework.
* 2. An application version used V1 setting, deployed it to production and reached certain high level of saturation (99.99%) that makes it save
* to enable V2 and gain the benefits of FluidFramework 2.0 work
*
* Please note that using Tree data structure requires this option.
* Please see all the benefits of this setting descrived above.
*/
| {
    compatibilityLevel: "2.x";
    compressionOptions?: ICompressionRuntimeOptions;
};

// @public
export interface IConnection {
    id: string;
    mode: "write" | "read";
}

// @public @sealed
export interface IFluidContainer<TContainerSchema extends ContainerSchema = ContainerSchema> extends IEventProvider<IFluidContainerEvents> {
    attach(props?: ContainerAttachProps): Promise<string>;
    readonly attachState: AttachState;
    connect(): void;
    readonly connectionState: ConnectionState;
    create<T extends IFluidLoadable>(objectClass: LoadableObjectClass<T>): Promise<T>;
    disconnect(): void;
    dispose(): void;
    readonly disposed: boolean;
    readonly initialObjects: InitialObjects<TContainerSchema>;
    readonly isDirty: boolean;
}

// @public @sealed
export interface IFluidContainerEvents extends IEvent {
    (event: "connected", listener: () => void): void;
    (event: "disconnected", listener: () => void): void;
    (event: "saved", listener: () => void): void;
    (event: "dirty", listener: () => void): void;
    (event: "disposed", listener: (error?: ICriticalContainerError) => void): any;
}

// @public
export interface IMember {
    connections: IConnection[];
    userId: string;
}

// @public
export type InitialObjects<T extends ContainerSchema> = {
    [K in keyof T["initialObjects"]]: T["initialObjects"][K] extends LoadableObjectClass<infer TChannel> ? TChannel : never;
};

// @internal (undocumented)
export interface IProvideRootDataObject {
    // (undocumented)
    readonly IRootDataObject: IRootDataObject;
}

// @internal
export interface IRootDataObject extends IProvideRootDataObject {
    create<T extends IFluidLoadable>(objectClass: LoadableObjectClass<T>): Promise<T>;
    readonly initialObjects: LoadableObjectRecord;
}

// @public
export interface IServiceAudience<M extends IMember> extends IEventProvider<IServiceAudienceEvents<M>> {
    getMembers(): Map<string, M>;
    getMyself(): Myself<M> | undefined;
}

// @public
export interface IServiceAudienceEvents<M extends IMember> extends IEvent {
    // @eventProperty
    (event: "membersChanged", listener: () => void): void;
    // @eventProperty
    (event: "memberAdded", listener: MemberChangedListener<M>): void;
    // @eventProperty
    (event: "memberRemoved", listener: MemberChangedListener<M>): void;
}

// @public
export type LoadableObjectClass<T extends IFluidLoadable = IFluidLoadable> = ISharedObjectKind<T> | DataObjectClass<T>;

// @public
export type LoadableObjectClassRecord = Record<string, LoadableObjectClass>;

// @internal
export type LoadableObjectRecord = Record<string, IFluidLoadable>;

// @public
export type MemberChangedListener<M extends IMember> = (clientId: string, member: M) => void;

// @public
export type Myself<M extends IMember = IMember> = M & {
    currentConnection: string;
};

```
