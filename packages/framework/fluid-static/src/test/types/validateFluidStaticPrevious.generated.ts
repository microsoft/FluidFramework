/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/fluid-static-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DOProviderContainerRuntimeFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DOProviderContainerRuntimeFactory = requireAssignableTo<TypeOnly<old.DOProviderContainerRuntimeFactory>, TypeOnly<current.DOProviderContainerRuntimeFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DOProviderContainerRuntimeFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_DOProviderContainerRuntimeFactory = requireAssignableTo<TypeOnly<current.DOProviderContainerRuntimeFactory>, TypeOnly<old.DOProviderContainerRuntimeFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_FluidContainer": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_FluidContainer = requireAssignableTo<TypeOnly<old.FluidContainer>, TypeOnly<current.FluidContainer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_FluidContainer": {"backCompat": false}
 */
declare type current_as_old_for_Class_FluidContainer = requireAssignableTo<TypeOnly<current.FluidContainer>, TypeOnly<old.FluidContainer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RootDataObject": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RootDataObject = requireAssignableTo<TypeOnly<old.RootDataObject>, TypeOnly<current.RootDataObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RootDataObject": {"backCompat": false}
 */
declare type current_as_old_for_Class_RootDataObject = requireAssignableTo<TypeOnly<current.RootDataObject>, TypeOnly<old.RootDataObject>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ServiceAudience": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ServiceAudience = requireAssignableTo<TypeOnly<old.ServiceAudience>, TypeOnly<current.ServiceAudience>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ServiceAudience": {"backCompat": false}
 */
declare type current_as_old_for_Class_ServiceAudience = requireAssignableTo<TypeOnly<current.ServiceAudience>, TypeOnly<old.ServiceAudience>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DOProviderContainerRuntimeFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DOProviderContainerRuntimeFactory = requireAssignableTo<TypeOnly<typeof current.DOProviderContainerRuntimeFactory>, TypeOnly<typeof old.DOProviderContainerRuntimeFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_FluidContainer": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_FluidContainer = requireAssignableTo<TypeOnly<typeof current.FluidContainer>, TypeOnly<typeof old.FluidContainer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RootDataObject": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RootDataObject = requireAssignableTo<TypeOnly<typeof current.RootDataObject>, TypeOnly<typeof old.RootDataObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ServiceAudience": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ServiceAudience = requireAssignableTo<TypeOnly<typeof current.ServiceAudience>, TypeOnly<typeof old.ServiceAudience>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ContainerSchema": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ContainerSchema = requireAssignableTo<TypeOnly<old.ContainerSchema>, TypeOnly<current.ContainerSchema>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ContainerSchema": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ContainerSchema = requireAssignableTo<TypeOnly<current.ContainerSchema>, TypeOnly<old.ContainerSchema>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnection": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConnection = requireAssignableTo<TypeOnly<old.IConnection>, TypeOnly<current.IConnection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnection": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConnection = requireAssignableTo<TypeOnly<current.IConnection>, TypeOnly<old.IConnection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidContainer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidContainer = requireAssignableTo<TypeOnly<old.IFluidContainer>, TypeOnly<current.IFluidContainer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidContainer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidContainer = requireAssignableTo<TypeOnly<current.IFluidContainer>, TypeOnly<old.IFluidContainer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidContainerEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidContainerEvents = requireAssignableTo<TypeOnly<old.IFluidContainerEvents>, TypeOnly<current.IFluidContainerEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidContainerEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidContainerEvents = requireAssignableTo<TypeOnly<current.IFluidContainerEvents>, TypeOnly<old.IFluidContainerEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMember": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMember = requireAssignableTo<TypeOnly<old.IMember>, TypeOnly<current.IMember>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMember": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMember = requireAssignableTo<TypeOnly<current.IMember>, TypeOnly<old.IMember>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServiceAudience": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IServiceAudience = requireAssignableTo<TypeOnly<old.IServiceAudience<never>>, TypeOnly<current.IServiceAudience<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServiceAudience": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IServiceAudience = requireAssignableTo<TypeOnly<current.IServiceAudience<never>>, TypeOnly<old.IServiceAudience<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServiceAudienceEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IServiceAudienceEvents = requireAssignableTo<TypeOnly<old.IServiceAudienceEvents<never>>, TypeOnly<current.IServiceAudienceEvents<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServiceAudienceEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IServiceAudienceEvents = requireAssignableTo<TypeOnly<current.IServiceAudienceEvents<never>>, TypeOnly<old.IServiceAudienceEvents<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_RootDataObjectProps": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_RootDataObjectProps = requireAssignableTo<TypeOnly<old.RootDataObjectProps>, TypeOnly<current.RootDataObjectProps>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_RootDataObjectProps": {"backCompat": false}
 */
declare type current_as_old_for_Interface_RootDataObjectProps = requireAssignableTo<TypeOnly<current.RootDataObjectProps>, TypeOnly<old.RootDataObjectProps>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_DataObjectClass": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_DataObjectClass = requireAssignableTo<TypeOnly<old.DataObjectClass<never>>, TypeOnly<current.DataObjectClass<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_DataObjectClass": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_DataObjectClass = requireAssignableTo<TypeOnly<current.DataObjectClass<never>>, TypeOnly<old.DataObjectClass<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectClass": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_LoadableObjectClass = requireAssignableTo<TypeOnly<old.LoadableObjectClass<never>>, TypeOnly<current.LoadableObjectClass<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectClass": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_LoadableObjectClass = requireAssignableTo<TypeOnly<current.LoadableObjectClass<never>>, TypeOnly<old.LoadableObjectClass<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectClassRecord": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_LoadableObjectClassRecord = requireAssignableTo<TypeOnly<old.LoadableObjectClassRecord>, TypeOnly<current.LoadableObjectClassRecord>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectClassRecord": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_LoadableObjectClassRecord = requireAssignableTo<TypeOnly<current.LoadableObjectClassRecord>, TypeOnly<old.LoadableObjectClassRecord>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectCtor": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_LoadableObjectCtor = requireAssignableTo<TypeOnly<old.LoadableObjectCtor<never>>, TypeOnly<current.LoadableObjectCtor<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectCtor": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_LoadableObjectCtor = requireAssignableTo<TypeOnly<current.LoadableObjectCtor<never>>, TypeOnly<old.LoadableObjectCtor<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectRecord": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_LoadableObjectRecord = requireAssignableTo<TypeOnly<old.LoadableObjectRecord>, TypeOnly<current.LoadableObjectRecord>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectRecord": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_LoadableObjectRecord = requireAssignableTo<TypeOnly<current.LoadableObjectRecord>, TypeOnly<old.LoadableObjectRecord>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SharedObjectClass": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SharedObjectClass = requireAssignableTo<TypeOnly<old.SharedObjectClass<never>>, TypeOnly<current.SharedObjectClass<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SharedObjectClass": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SharedObjectClass = requireAssignableTo<TypeOnly<current.SharedObjectClass<never>>, TypeOnly<old.SharedObjectClass<never>>>
