/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/fluid-static-previous/internal";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_CompatibilityMode": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_CompatibilityMode():
    TypeOnly<old.CompatibilityMode>;
declare function use_current_TypeAliasDeclaration_CompatibilityMode(
    use: TypeOnly<current.CompatibilityMode>): void;
use_current_TypeAliasDeclaration_CompatibilityMode(
    get_old_TypeAliasDeclaration_CompatibilityMode());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_CompatibilityMode": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_CompatibilityMode():
    TypeOnly<current.CompatibilityMode>;
declare function use_old_TypeAliasDeclaration_CompatibilityMode(
    use: TypeOnly<old.CompatibilityMode>): void;
use_old_TypeAliasDeclaration_CompatibilityMode(
    get_current_TypeAliasDeclaration_CompatibilityMode());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ContainerAttachProps": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ContainerAttachProps():
    TypeOnly<old.ContainerAttachProps>;
declare function use_current_TypeAliasDeclaration_ContainerAttachProps(
    use: TypeOnly<current.ContainerAttachProps>): void;
use_current_TypeAliasDeclaration_ContainerAttachProps(
    get_old_TypeAliasDeclaration_ContainerAttachProps());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ContainerAttachProps": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ContainerAttachProps():
    TypeOnly<current.ContainerAttachProps>;
declare function use_old_TypeAliasDeclaration_ContainerAttachProps(
    use: TypeOnly<old.ContainerAttachProps>): void;
use_old_TypeAliasDeclaration_ContainerAttachProps(
    get_current_TypeAliasDeclaration_ContainerAttachProps());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ContainerSchema": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ContainerSchema():
    TypeOnly<old.ContainerSchema>;
declare function use_current_InterfaceDeclaration_ContainerSchema(
    use: TypeOnly<current.ContainerSchema>): void;
use_current_InterfaceDeclaration_ContainerSchema(
    get_old_InterfaceDeclaration_ContainerSchema());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ContainerSchema": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ContainerSchema():
    TypeOnly<current.ContainerSchema>;
declare function use_old_InterfaceDeclaration_ContainerSchema(
    use: TypeOnly<old.ContainerSchema>): void;
use_old_InterfaceDeclaration_ContainerSchema(
    get_current_InterfaceDeclaration_ContainerSchema());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConnection": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IConnection():
    TypeOnly<old.IConnection>;
declare function use_current_InterfaceDeclaration_IConnection(
    use: TypeOnly<current.IConnection>): void;
use_current_InterfaceDeclaration_IConnection(
    get_old_InterfaceDeclaration_IConnection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConnection": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IConnection():
    TypeOnly<current.IConnection>;
declare function use_old_InterfaceDeclaration_IConnection(
    use: TypeOnly<old.IConnection>): void;
use_old_InterfaceDeclaration_IConnection(
    get_current_InterfaceDeclaration_IConnection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidContainer": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidContainer():
    TypeOnly<current.IFluidContainer>;
declare function use_old_InterfaceDeclaration_IFluidContainer(
    use: TypeOnly<old.IFluidContainer>): void;
use_old_InterfaceDeclaration_IFluidContainer(
    get_current_InterfaceDeclaration_IFluidContainer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidContainerEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidContainerEvents():
    TypeOnly<current.IFluidContainerEvents>;
declare function use_old_InterfaceDeclaration_IFluidContainerEvents(
    use: TypeOnly<old.IFluidContainerEvents>): void;
use_old_InterfaceDeclaration_IFluidContainerEvents(
    get_current_InterfaceDeclaration_IFluidContainerEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMember": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMember():
    TypeOnly<old.IMember>;
declare function use_current_InterfaceDeclaration_IMember(
    use: TypeOnly<current.IMember>): void;
use_current_InterfaceDeclaration_IMember(
    get_old_InterfaceDeclaration_IMember());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMember": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMember():
    TypeOnly<current.IMember>;
declare function use_old_InterfaceDeclaration_IMember(
    use: TypeOnly<old.IMember>): void;
use_old_InterfaceDeclaration_IMember(
    get_current_InterfaceDeclaration_IMember());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideRootDataObject": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProvideRootDataObject():
    TypeOnly<old.IProvideRootDataObject>;
declare function use_current_InterfaceDeclaration_IProvideRootDataObject(
    use: TypeOnly<current.IProvideRootDataObject>): void;
use_current_InterfaceDeclaration_IProvideRootDataObject(
    get_old_InterfaceDeclaration_IProvideRootDataObject());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideRootDataObject": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProvideRootDataObject():
    TypeOnly<current.IProvideRootDataObject>;
declare function use_old_InterfaceDeclaration_IProvideRootDataObject(
    use: TypeOnly<old.IProvideRootDataObject>): void;
use_old_InterfaceDeclaration_IProvideRootDataObject(
    get_current_InterfaceDeclaration_IProvideRootDataObject());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRootDataObject": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IRootDataObject():
    TypeOnly<old.IRootDataObject>;
declare function use_current_InterfaceDeclaration_IRootDataObject(
    use: TypeOnly<current.IRootDataObject>): void;
use_current_InterfaceDeclaration_IRootDataObject(
    get_old_InterfaceDeclaration_IRootDataObject());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRootDataObject": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IRootDataObject():
    TypeOnly<current.IRootDataObject>;
declare function use_old_InterfaceDeclaration_IRootDataObject(
    use: TypeOnly<old.IRootDataObject>): void;
use_old_InterfaceDeclaration_IRootDataObject(
    get_current_InterfaceDeclaration_IRootDataObject());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IServiceAudience": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IServiceAudience():
    TypeOnly<old.IServiceAudience<any>>;
declare function use_current_InterfaceDeclaration_IServiceAudience(
    use: TypeOnly<current.IServiceAudience<any>>): void;
use_current_InterfaceDeclaration_IServiceAudience(
    get_old_InterfaceDeclaration_IServiceAudience());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IServiceAudience": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IServiceAudience():
    TypeOnly<current.IServiceAudience<any>>;
declare function use_old_InterfaceDeclaration_IServiceAudience(
    use: TypeOnly<old.IServiceAudience<any>>): void;
use_old_InterfaceDeclaration_IServiceAudience(
    get_current_InterfaceDeclaration_IServiceAudience());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IServiceAudienceEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IServiceAudienceEvents():
    TypeOnly<old.IServiceAudienceEvents<any>>;
declare function use_current_InterfaceDeclaration_IServiceAudienceEvents(
    use: TypeOnly<current.IServiceAudienceEvents<any>>): void;
use_current_InterfaceDeclaration_IServiceAudienceEvents(
    get_old_InterfaceDeclaration_IServiceAudienceEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IServiceAudienceEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IServiceAudienceEvents():
    TypeOnly<current.IServiceAudienceEvents<any>>;
declare function use_old_InterfaceDeclaration_IServiceAudienceEvents(
    use: TypeOnly<old.IServiceAudienceEvents<any>>): void;
use_old_InterfaceDeclaration_IServiceAudienceEvents(
    get_current_InterfaceDeclaration_IServiceAudienceEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_InitialObjects": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_InitialObjects():
    TypeOnly<old.InitialObjects<any>>;
declare function use_current_TypeAliasDeclaration_InitialObjects(
    use: TypeOnly<current.InitialObjects<any>>): void;
use_current_TypeAliasDeclaration_InitialObjects(
    get_old_TypeAliasDeclaration_InitialObjects());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_InitialObjects": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_InitialObjects():
    TypeOnly<current.InitialObjects<any>>;
declare function use_old_TypeAliasDeclaration_InitialObjects(
    use: TypeOnly<old.InitialObjects<any>>): void;
use_old_TypeAliasDeclaration_InitialObjects(
    get_current_TypeAliasDeclaration_InitialObjects());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_LoadableObjectRecord": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_LoadableObjectRecord():
    TypeOnly<old.LoadableObjectRecord>;
declare function use_current_TypeAliasDeclaration_LoadableObjectRecord(
    use: TypeOnly<current.LoadableObjectRecord>): void;
use_current_TypeAliasDeclaration_LoadableObjectRecord(
    get_old_TypeAliasDeclaration_LoadableObjectRecord());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_LoadableObjectRecord": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_LoadableObjectRecord():
    TypeOnly<current.LoadableObjectRecord>;
declare function use_old_TypeAliasDeclaration_LoadableObjectRecord(
    use: TypeOnly<old.LoadableObjectRecord>): void;
use_old_TypeAliasDeclaration_LoadableObjectRecord(
    get_current_TypeAliasDeclaration_LoadableObjectRecord());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MemberChangedListener": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_MemberChangedListener():
    TypeOnly<old.MemberChangedListener<any>>;
declare function use_current_TypeAliasDeclaration_MemberChangedListener(
    use: TypeOnly<current.MemberChangedListener<any>>): void;
use_current_TypeAliasDeclaration_MemberChangedListener(
    get_old_TypeAliasDeclaration_MemberChangedListener());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MemberChangedListener": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_MemberChangedListener():
    TypeOnly<current.MemberChangedListener<any>>;
declare function use_old_TypeAliasDeclaration_MemberChangedListener(
    use: TypeOnly<old.MemberChangedListener<any>>): void;
use_old_TypeAliasDeclaration_MemberChangedListener(
    get_current_TypeAliasDeclaration_MemberChangedListener());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_Myself": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_Myself():
    TypeOnly<old.Myself>;
declare function use_current_TypeAliasDeclaration_Myself(
    use: TypeOnly<current.Myself>): void;
use_current_TypeAliasDeclaration_Myself(
    get_old_TypeAliasDeclaration_Myself());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_Myself": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_Myself():
    TypeOnly<current.Myself>;
declare function use_old_TypeAliasDeclaration_Myself(
    use: TypeOnly<old.Myself>): void;
use_old_TypeAliasDeclaration_Myself(
    get_current_TypeAliasDeclaration_Myself());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createDOProviderContainerRuntimeFactory": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createDOProviderContainerRuntimeFactory():
    TypeOnly<typeof old.createDOProviderContainerRuntimeFactory>;
declare function use_current_FunctionDeclaration_createDOProviderContainerRuntimeFactory(
    use: TypeOnly<typeof current.createDOProviderContainerRuntimeFactory>): void;
use_current_FunctionDeclaration_createDOProviderContainerRuntimeFactory(
    get_old_FunctionDeclaration_createDOProviderContainerRuntimeFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createDOProviderContainerRuntimeFactory": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createDOProviderContainerRuntimeFactory():
    TypeOnly<typeof current.createDOProviderContainerRuntimeFactory>;
declare function use_old_FunctionDeclaration_createDOProviderContainerRuntimeFactory(
    use: TypeOnly<typeof old.createDOProviderContainerRuntimeFactory>): void;
use_old_FunctionDeclaration_createDOProviderContainerRuntimeFactory(
    get_current_FunctionDeclaration_createDOProviderContainerRuntimeFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createFluidContainer": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createFluidContainer():
    TypeOnly<typeof old.createFluidContainer>;
declare function use_current_FunctionDeclaration_createFluidContainer(
    use: TypeOnly<typeof current.createFluidContainer>): void;
use_current_FunctionDeclaration_createFluidContainer(
    get_old_FunctionDeclaration_createFluidContainer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createFluidContainer": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createFluidContainer():
    TypeOnly<typeof current.createFluidContainer>;
declare function use_old_FunctionDeclaration_createFluidContainer(
    use: TypeOnly<typeof old.createFluidContainer>): void;
use_old_FunctionDeclaration_createFluidContainer(
    get_current_FunctionDeclaration_createFluidContainer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createServiceAudience": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createServiceAudience():
    TypeOnly<typeof old.createServiceAudience>;
declare function use_current_FunctionDeclaration_createServiceAudience(
    use: TypeOnly<typeof current.createServiceAudience>): void;
use_current_FunctionDeclaration_createServiceAudience(
    get_old_FunctionDeclaration_createServiceAudience());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createServiceAudience": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createServiceAudience():
    TypeOnly<typeof current.createServiceAudience>;
declare function use_old_FunctionDeclaration_createServiceAudience(
    use: TypeOnly<typeof old.createServiceAudience>): void;
use_old_FunctionDeclaration_createServiceAudience(
    get_current_FunctionDeclaration_createServiceAudience());
