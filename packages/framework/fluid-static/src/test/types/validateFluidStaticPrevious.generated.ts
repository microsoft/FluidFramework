/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type * as old from "@fluidframework/fluid-static-previous/internal";

import type * as current from "../../index.js";

type ValueOf<T> = T[keyof T];
type OnlySymbols<T> = T extends symbol ? T : never;
type WellKnownSymbols = OnlySymbols<ValueOf<typeof Symbol>>;
/**
 * Omit (replace with never) a key if it is a custom symbol,
 * not just symbol or a well known symbol from the global Symbol.
 */
type SkipUniqueSymbols<Key> = symbol extends Key
	? Key // Key is symbol or a generalization of symbol, so leave it as is.
	: Key extends symbol
		? Key extends WellKnownSymbols
			? Key // Key is a well known symbol from the global Symbol object. These are shared between packages, so they are fine and kept as is.
			: never // Key is most likely some specialized symbol, typically a unique symbol. These break type comparisons so are removed by replacing them with never.
		: Key; // Key is not a symbol (for example its a string or number), so leave it as is.
/**
 * Remove details of T which are incompatible with type testing while keeping as much as is practical.
 *
 * See 'build-tools/packages/build-tools/src/typeValidator/compatibility.ts' for more information.
 */
type TypeOnly<T> = T extends number
	? number
	: T extends boolean | bigint | string
		? T
		: T extends symbol
			? SkipUniqueSymbols<T>
			: {
					[P in keyof T as SkipUniqueSymbols<P>]: TypeOnly<T[P]>;
				};

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ContainerAttachProps": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ContainerAttachProps():
    TypeOnly<old.ContainerAttachProps>;
declare function use_current_TypeAliasDeclaration_ContainerAttachProps(
    use: TypeOnly<current.ContainerAttachProps>): void;
use_current_TypeAliasDeclaration_ContainerAttachProps(
    get_old_TypeAliasDeclaration_ContainerAttachProps());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_ContainerAttachProps": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ContainerAttachProps():
    TypeOnly<current.ContainerAttachProps>;
declare function use_old_TypeAliasDeclaration_ContainerAttachProps(
    use: TypeOnly<old.ContainerAttachProps>): void;
use_old_TypeAliasDeclaration_ContainerAttachProps(
    get_current_TypeAliasDeclaration_ContainerAttachProps());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ContainerSchema": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ContainerSchema():
    TypeOnly<old.ContainerSchema>;
declare function use_current_InterfaceDeclaration_ContainerSchema(
    use: TypeOnly<current.ContainerSchema>): void;
use_current_InterfaceDeclaration_ContainerSchema(
    get_old_InterfaceDeclaration_ContainerSchema());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ContainerSchema": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ContainerSchema():
    TypeOnly<current.ContainerSchema>;
declare function use_old_InterfaceDeclaration_ContainerSchema(
    use: TypeOnly<old.ContainerSchema>): void;
use_old_InterfaceDeclaration_ContainerSchema(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_ContainerSchema());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "RemovedTypeAliasDeclaration_DataObjectClass": {"forwardCompat": false}
 */

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "RemovedTypeAliasDeclaration_DataObjectClass": {"backCompat": false}
 */

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConnection": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IConnection():
    TypeOnly<old.IConnection>;
declare function use_current_InterfaceDeclaration_IConnection(
    use: TypeOnly<current.IConnection>): void;
use_current_InterfaceDeclaration_IConnection(
    get_old_InterfaceDeclaration_IConnection());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IConnection": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IConnection():
    TypeOnly<current.IConnection>;
declare function use_old_InterfaceDeclaration_IConnection(
    use: TypeOnly<old.IConnection>): void;
use_old_InterfaceDeclaration_IConnection(
    get_current_InterfaceDeclaration_IConnection());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidContainer": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidContainer():
    TypeOnly<old.IFluidContainer>;
declare function use_current_InterfaceDeclaration_IFluidContainer(
    use: TypeOnly<current.IFluidContainer>): void;
use_current_InterfaceDeclaration_IFluidContainer(
    get_old_InterfaceDeclaration_IFluidContainer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidContainer": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidContainer():
    TypeOnly<current.IFluidContainer>;
declare function use_old_InterfaceDeclaration_IFluidContainer(
    use: TypeOnly<old.IFluidContainer>): void;
use_old_InterfaceDeclaration_IFluidContainer(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IFluidContainer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidContainerEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IFluidContainerEvents():
    TypeOnly<old.IFluidContainerEvents>;
declare function use_current_InterfaceDeclaration_IFluidContainerEvents(
    use: TypeOnly<current.IFluidContainerEvents>): void;
use_current_InterfaceDeclaration_IFluidContainerEvents(
    get_old_InterfaceDeclaration_IFluidContainerEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IFluidContainerEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IFluidContainerEvents():
    TypeOnly<current.IFluidContainerEvents>;
declare function use_old_InterfaceDeclaration_IFluidContainerEvents(
    use: TypeOnly<old.IFluidContainerEvents>): void;
use_old_InterfaceDeclaration_IFluidContainerEvents(
    get_current_InterfaceDeclaration_IFluidContainerEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMember": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IMember():
    TypeOnly<old.IMember>;
declare function use_current_InterfaceDeclaration_IMember(
    use: TypeOnly<current.IMember>): void;
use_current_InterfaceDeclaration_IMember(
    get_old_InterfaceDeclaration_IMember());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IMember": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IMember():
    TypeOnly<current.IMember>;
declare function use_old_InterfaceDeclaration_IMember(
    use: TypeOnly<old.IMember>): void;
use_old_InterfaceDeclaration_IMember(
    get_current_InterfaceDeclaration_IMember());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideRootDataObject": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProvideRootDataObject():
    TypeOnly<old.IProvideRootDataObject>;
declare function use_current_InterfaceDeclaration_IProvideRootDataObject(
    use: TypeOnly<current.IProvideRootDataObject>): void;
use_current_InterfaceDeclaration_IProvideRootDataObject(
    get_old_InterfaceDeclaration_IProvideRootDataObject());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProvideRootDataObject": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProvideRootDataObject():
    TypeOnly<current.IProvideRootDataObject>;
declare function use_old_InterfaceDeclaration_IProvideRootDataObject(
    use: TypeOnly<old.IProvideRootDataObject>): void;
use_old_InterfaceDeclaration_IProvideRootDataObject(
    get_current_InterfaceDeclaration_IProvideRootDataObject());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRootDataObject": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IRootDataObject():
    TypeOnly<old.IRootDataObject>;
declare function use_current_InterfaceDeclaration_IRootDataObject(
    use: TypeOnly<current.IRootDataObject>): void;
use_current_InterfaceDeclaration_IRootDataObject(
    get_old_InterfaceDeclaration_IRootDataObject());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IRootDataObject": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IRootDataObject():
    TypeOnly<current.IRootDataObject>;
declare function use_old_InterfaceDeclaration_IRootDataObject(
    use: TypeOnly<old.IRootDataObject>): void;
use_old_InterfaceDeclaration_IRootDataObject(
    get_current_InterfaceDeclaration_IRootDataObject());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IServiceAudience": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IServiceAudience():
    TypeOnly<old.IServiceAudience<any>>;
declare function use_current_InterfaceDeclaration_IServiceAudience(
    use: TypeOnly<current.IServiceAudience<any>>): void;
use_current_InterfaceDeclaration_IServiceAudience(
    get_old_InterfaceDeclaration_IServiceAudience());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IServiceAudience": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IServiceAudience():
    TypeOnly<current.IServiceAudience<any>>;
declare function use_old_InterfaceDeclaration_IServiceAudience(
    use: TypeOnly<old.IServiceAudience<any>>): void;
use_old_InterfaceDeclaration_IServiceAudience(
    get_current_InterfaceDeclaration_IServiceAudience());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IServiceAudienceEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IServiceAudienceEvents():
    TypeOnly<old.IServiceAudienceEvents<any>>;
declare function use_current_InterfaceDeclaration_IServiceAudienceEvents(
    use: TypeOnly<current.IServiceAudienceEvents<any>>): void;
use_current_InterfaceDeclaration_IServiceAudienceEvents(
    get_old_InterfaceDeclaration_IServiceAudienceEvents());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IServiceAudienceEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IServiceAudienceEvents():
    TypeOnly<current.IServiceAudienceEvents<any>>;
declare function use_old_InterfaceDeclaration_IServiceAudienceEvents(
    use: TypeOnly<old.IServiceAudienceEvents<any>>): void;
use_old_InterfaceDeclaration_IServiceAudienceEvents(
    get_current_InterfaceDeclaration_IServiceAudienceEvents());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_InitialObjects": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_InitialObjects():
    TypeOnly<old.InitialObjects<any>>;
declare function use_current_TypeAliasDeclaration_InitialObjects(
    use: TypeOnly<current.InitialObjects<any>>): void;
use_current_TypeAliasDeclaration_InitialObjects(
    get_old_TypeAliasDeclaration_InitialObjects());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_InitialObjects": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_InitialObjects():
    TypeOnly<current.InitialObjects<any>>;
declare function use_old_TypeAliasDeclaration_InitialObjects(
    use: TypeOnly<old.InitialObjects<any>>): void;
use_old_TypeAliasDeclaration_InitialObjects(
    // @ts-expect-error compatibility expected to be broken
    get_current_TypeAliasDeclaration_InitialObjects());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "RemovedTypeAliasDeclaration_LoadableObjectClass": {"forwardCompat": false}
 */

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "RemovedTypeAliasDeclaration_LoadableObjectClass": {"backCompat": false}
 */

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "RemovedTypeAliasDeclaration_LoadableObjectClassRecord": {"forwardCompat": false}
 */

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "RemovedTypeAliasDeclaration_LoadableObjectClassRecord": {"backCompat": false}
 */

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_LoadableObjectRecord": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_LoadableObjectRecord():
    TypeOnly<old.LoadableObjectRecord>;
declare function use_current_TypeAliasDeclaration_LoadableObjectRecord(
    use: TypeOnly<current.LoadableObjectRecord>): void;
use_current_TypeAliasDeclaration_LoadableObjectRecord(
    get_old_TypeAliasDeclaration_LoadableObjectRecord());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_LoadableObjectRecord": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_LoadableObjectRecord():
    TypeOnly<current.LoadableObjectRecord>;
declare function use_old_TypeAliasDeclaration_LoadableObjectRecord(
    use: TypeOnly<old.LoadableObjectRecord>): void;
use_old_TypeAliasDeclaration_LoadableObjectRecord(
    get_current_TypeAliasDeclaration_LoadableObjectRecord());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MemberChangedListener": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_MemberChangedListener():
    TypeOnly<old.MemberChangedListener<any>>;
declare function use_current_TypeAliasDeclaration_MemberChangedListener(
    use: TypeOnly<current.MemberChangedListener<any>>): void;
use_current_TypeAliasDeclaration_MemberChangedListener(
    get_old_TypeAliasDeclaration_MemberChangedListener());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_MemberChangedListener": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_MemberChangedListener():
    TypeOnly<current.MemberChangedListener<any>>;
declare function use_old_TypeAliasDeclaration_MemberChangedListener(
    use: TypeOnly<old.MemberChangedListener<any>>): void;
use_old_TypeAliasDeclaration_MemberChangedListener(
    get_current_TypeAliasDeclaration_MemberChangedListener());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_Myself": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_Myself():
    TypeOnly<old.Myself>;
declare function use_current_TypeAliasDeclaration_Myself(
    use: TypeOnly<current.Myself>): void;
use_current_TypeAliasDeclaration_Myself(
    get_old_TypeAliasDeclaration_Myself());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_Myself": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_Myself():
    TypeOnly<current.Myself>;
declare function use_old_TypeAliasDeclaration_Myself(
    use: TypeOnly<old.Myself>): void;
use_old_TypeAliasDeclaration_Myself(
    get_current_TypeAliasDeclaration_Myself());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createDOProviderContainerRuntimeFactory": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createDOProviderContainerRuntimeFactory():
    TypeOnly<typeof old.createDOProviderContainerRuntimeFactory>;
declare function use_current_FunctionDeclaration_createDOProviderContainerRuntimeFactory(
    use: TypeOnly<typeof current.createDOProviderContainerRuntimeFactory>): void;
use_current_FunctionDeclaration_createDOProviderContainerRuntimeFactory(
    get_old_FunctionDeclaration_createDOProviderContainerRuntimeFactory());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createDOProviderContainerRuntimeFactory": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createDOProviderContainerRuntimeFactory():
    TypeOnly<typeof current.createDOProviderContainerRuntimeFactory>;
declare function use_old_FunctionDeclaration_createDOProviderContainerRuntimeFactory(
    use: TypeOnly<typeof old.createDOProviderContainerRuntimeFactory>): void;
use_old_FunctionDeclaration_createDOProviderContainerRuntimeFactory(
    get_current_FunctionDeclaration_createDOProviderContainerRuntimeFactory());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createFluidContainer": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createFluidContainer():
    TypeOnly<typeof old.createFluidContainer>;
declare function use_current_FunctionDeclaration_createFluidContainer(
    use: TypeOnly<typeof current.createFluidContainer>): void;
use_current_FunctionDeclaration_createFluidContainer(
    get_old_FunctionDeclaration_createFluidContainer());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createFluidContainer": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createFluidContainer():
    TypeOnly<typeof current.createFluidContainer>;
declare function use_old_FunctionDeclaration_createFluidContainer(
    use: TypeOnly<typeof old.createFluidContainer>): void;
use_old_FunctionDeclaration_createFluidContainer(
    get_current_FunctionDeclaration_createFluidContainer());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createServiceAudience": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createServiceAudience():
    TypeOnly<typeof old.createServiceAudience>;
declare function use_current_FunctionDeclaration_createServiceAudience(
    use: TypeOnly<typeof current.createServiceAudience>): void;
use_current_FunctionDeclaration_createServiceAudience(
    get_old_FunctionDeclaration_createServiceAudience());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createServiceAudience": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createServiceAudience():
    TypeOnly<typeof current.createServiceAudience>;
declare function use_old_FunctionDeclaration_createServiceAudience(
    use: TypeOnly<typeof old.createServiceAudience>): void;
use_old_FunctionDeclaration_createServiceAudience(
    get_current_FunctionDeclaration_createServiceAudience());
