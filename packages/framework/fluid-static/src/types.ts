/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import {
	type IEvent,
	type IEventProvider,
	type IFluidLoadable,
} from "@fluidframework/core-interfaces";
import { type ISharedObjectKind } from "@fluidframework/shared-object-base";

/**
 * A mapping of string identifiers to instantiated `DataObject`s or `SharedObject`s.
 * @internal
 */
export type LoadableObjectRecord = Record<string, IFluidLoadable>;

/**
 * A mapping of string identifiers to classes that will later be used to instantiate a corresponding `DataObject`
 * or `SharedObject`.
 * @public
 */
export type LoadableObjectClassRecord = Record<string, LoadableObjectClass>;

/**
 * A class object of `DataObject` or `SharedObject`.
 *
 * @typeParam T - The class of the `DataObject` or `SharedObject`.
 * @public
 *
 * @privateRemarks
 * There are some edge cases in TypeScript where the order of the members in a union matter.
 * Once such edge case is when multiple members of a generic union partially match, and the type parameter is being inferred.
 * In this case, its better to have the desired match and/or the simpler type first.
 * In this case placing ISharedObjectKind fixed one usage and didn't break anything, and generally seems more likely to work than the reverse, so this is the order being used.
 * This is likely (a bug in TypeScript)[https://github.com/microsoft/TypeScript/issues/45809].
 */
export type LoadableObjectClass<T extends IFluidLoadable = IFluidLoadable> =
	| ISharedObjectKind<T>
	| DataObjectClass<T>;

/**
 * A class that has a factory that can create a `DataObject` and a
 * constructor that will return the type of the `DataObject`.
 *
 * @typeParam T - The class of the `DataObject`.
 * @public
 */
export type DataObjectClass<T extends IFluidLoadable = IFluidLoadable> = {
	readonly factory: { IFluidDataStoreFactory: DataObjectClass<T>["factory"] };
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
} & (new (...args: any[]) => T);

/**
 * Represents properties that can be attached to a container.
 * @public
 */
export type ContainerAttachProps<T = unknown> = T;

/**
 * Declares the Fluid objects that will be available in the {@link IFluidContainer | Container}.
 *
 * @remarks
 *
 * It includes both the instances of objects that are initially available upon `Container` creation, as well
 * as the types of objects that may be dynamically created throughout the lifetime of the `Container`.
 * @public
 */
export interface ContainerSchema {
	/**
	 * Defines loadable objects that will be created when the {@link IFluidContainer | Container} is first created.
	 *
	 * @remarks It uses the key as the id and the value as the loadable object to create.
	 *
	 * @example
	 *
	 * In the example below two objects will be created when the `Container` is first
	 * created. One with id "map1" that will return a `SharedMap` and the other with
	 * id "pair1" that will return a `KeyValueDataObject`.
	 *
	 * ```typescript
	 * {
	 *   map1: SharedMap,
	 *   pair1: KeyValueDataObject,
	 * }
	 * ```
	 */
	readonly initialObjects: LoadableObjectClassRecord;

	/**
	 * Loadable objects that can be created after the initial {@link IFluidContainer | Container} creation.
	 *
	 * @remarks
	 *
	 * Types defined in `initialObjects` will always be available and are not required to be provided here.
	 *
	 * For best practice it's recommended to define all the dynamic types you create even if they are
	 * included via initialObjects.
	 */
	readonly dynamicObjectTypes?: readonly LoadableObjectClass[];
}

/**
 * Defines compatibility requirements of the application / container.
 * Required pre-reading: https://github.com/microsoft/FluidFramework/blob/main/packages/dds/SchemaVersioning.md:
 *
 * Fluid Framework adds a number of new capabilities in 2.0 release. Many of these capabilities require document
 * schema changes (ops and/or summaries). All of these capabilities are opt-in, allowing applications to make a
 * decision on when it's safe to enable such capabilities in a safe (for an application) timeframe.
 *
 * New capabilities added in 2.0 that require V2 setting:
 * 1. Tree data structure
 * 2. Op compression. Uses really fast (lz4) compression algorithm that substantially reduces bytes over the wire, and thus latency
 * of sending and receiving ops.
 * 3. Op grouping. It allows all the ops made in one JS turn to be grouped together, compressed, and chunked into small number of ops on the wire.
 * Your results will very (and depend on payloads generated by your application), but we in our internal testing we observe that 2000-3000 ops
 * with total size of 20-30Mb usually result in only 8-10 ops of ~200K in size (each) being sent over wire.
 * In addition to gaining efficiency, this also results in substantially smaller bills as one of the key metrics used in determining cost
 * is number of ops processed and braodcast by service (i.e. ops on the wire).
 *
 * @public
 */
export enum FluidRuntimeMinVersion {
	/**
	 * Use V1 setting in the following scenario:
	 * A version of your application used 1.x version of Fluid Framework and shipped that application version to production.
	 * There is no way to ship new application code (including Fluid Framework bits) instantly to all clients of a given application.
	 * This means every update must result in at least two "current" versions at a time for a while.
	 * These application versions need to use same (compatible) schema, for as long as old version of the application is in circulation.
	 * V1 settings does precisely that - it instructs FluidFramework to disable all the features that modify document schema,
	 * allowing full compatibility with old versions of FluidFramework library.
	 *
	 * Please note that even if you have no documents at rest (i.e. all Fluid containers are deleted as soon as all clients leave document),
	 * you have to use V1 setting for a while. A user could open a document and close a lid of latop, and come back after a while (day/week/month/year)
	 * Even if application will attempt to immidiatly close container in such cases, it's a race with FluidFramework attempting to reconnect
	 * to container and receive / send ops, which may result in not the best user experience.
	 *
	 * That said, once it's safe (the new version of application with FluidFramework 2.0 has been deployed and reached 99.99% saturarion),
	 * we highly recomend you to switch to V2 and rip all the benefits of latest changes.
	 *
	 * You should assume that FluidFramework 3.0 will remove this option. I.e. applications will be able to consume FluidFramework 3.0 only
	 * after they deployed application version with FluidFramework 2.0 and this version saturated in production.
	 *
	 * V1 option does not allow usage of added in 2.0 Tree data structure.
	 */
	V1,

	/**
	 * Use V2 settign in one of the following scenarios:
	 * 1. You are building a new application, i.e. you never used 1.x version of FluidFramework.
	 * 2. An application version used V1 setting, deployed it to production and reached certain high level of saturation (99.99%) that makes it save
	 * to enable V2 and gain the benefits of FluidFramework 2.0 work
	 *
	 * Please note that using Tree data structure requires this option.
	 * Please see all the benefits of this setting descrived above.
	 */
	V2,
}

/**
 * @public
 */
export interface AzureContainerSchema extends ContainerSchema {
	// Default is V2!
	minRuntimeVersion?: FluidRuntimeMinVersion;
}

/**
 * @internal
 */
export interface IProvideRootDataObject {
	readonly IRootDataObject: IRootDataObject;
}

/**
 * Holds the collection of objects that the container was initially created with, as well as provides the ability
 * to dynamically create further objects during usage.
 * @internal
 */
export interface IRootDataObject extends IProvideRootDataObject {
	/**
	 * Provides a record of the initial objects defined on creation.
	 */
	readonly initialObjects: LoadableObjectRecord;

	/**
	 * Dynamically creates a new detached collaborative object (DDS/DataObject).
	 *
	 * @param objectClass - Type of the collaborative object to be created.
	 *
	 * @typeParam T - The class of the `DataObject` or `SharedObject`.
	 */
	create<T extends IFluidLoadable>(objectClass: LoadableObjectClass<T>): Promise<T>;
}

/**
 * Signature for {@link IMember} change events.
 *
 * @param clientId - A unique identifier for the client.
 * @param member - The service-specific member object for the client.
 *
 * @see See {@link IServiceAudienceEvents} for usage details.
 * @public
 */
export type MemberChangedListener<M extends IMember> = (clientId: string, member: M) => void;

/**
 * Events that trigger when the roster of members in the Fluid session change.
 *
 * @remarks
 *
 * Only changes that would be reflected in the returned map of {@link IServiceAudience}'s
 * {@link IServiceAudience.getMembers} method will emit events.
 *
 * @typeParam M - A service-specific {@link IMember} implementation.
 * @public
 */
export interface IServiceAudienceEvents<M extends IMember> extends IEvent {
	/**
	 * Emitted when a {@link IMember | member}(s) are either added or removed.
	 *
	 * @eventProperty
	 */
	(event: "membersChanged", listener: () => void): void;

	/**
	 * Emitted when a {@link IMember | member} joins the audience.
	 *
	 * @eventProperty
	 */
	(event: "memberAdded", listener: MemberChangedListener<M>): void;

	/**
	 * Emitted when a {@link IMember | member} leaves the audience.
	 *
	 * @eventProperty
	 */
	(event: "memberRemoved", listener: MemberChangedListener<M>): void;
}

/**
 * Base interface to be implemented to fetch each service's audience.
 *
 * @remarks
 *
 * The type parameter `M` allows consumers to further extend the client object with service-specific
 * details about the connecting client, such as device information, environment, or a username.
 *
 * @typeParam M - A service-specific {@link IMember} type.
 * @public
 */
export interface IServiceAudience<M extends IMember>
	extends IEventProvider<IServiceAudienceEvents<M>> {
	/**
	 * Returns an map of all users currently in the Fluid session where key is the userId and the value is the
	 * member object.  The implementation may choose to exclude certain connections from the returned map.
	 * E.g. ServiceAudience excludes non-interactive connections to represent only the roster of live users.
	 */
	getMembers(): Map<string, M>;

	/**
	 * Returns the current active user on this client once they are connected. Otherwise, returns undefined.
	 */
	getMyself(): Myself<M> | undefined;
}

/**
 * Base interface for information for each connection made to the Fluid session.
 *
 * @remarks This interface can be extended to provide additional information specific to each service.
 * @public
 */
export interface IConnection {
	/**
	 * A unique ID for the connection.  A single user may have multiple connections, each with a different ID.
	 */
	id: string;

	/**
	 * Whether the connection is in read or read/write mode.
	 */
	mode: "write" | "read";
}

/**
 * Base interface to be implemented to fetch each service's member.
 *
 * @remarks This interface can be extended by each service to provide additional service-specific user metadata.
 * @public
 */
export interface IMember {
	/**
	 * An ID for the user, unique among each individual user connecting to the session.
	 */
	userId: string;

	/**
	 * The set of connections the user has made, e.g. from multiple tabs or devices.
	 */
	connections: IConnection[];
}

/**
 * An extended member object that includes currentConnection
 * @public
 */
export type Myself<M extends IMember = IMember> = M & { currentConnection: string };
