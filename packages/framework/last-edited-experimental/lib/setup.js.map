{"version":3,"file":"setup.js","sourceRoot":"","sources":["../src/setup.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAGH,OAAO,EAAE,oBAAoB,EAAE,MAAM,mCAAmC,CAAC;AAIzE,yGAAyG;AACzG,mEAAmE;AACnE,SAAS,2BAA2B,CAAC,OAAkC;IACnE,IAAI,OAAO,CAAC,IAAI,KAAK,oBAAoB,CAAC,MAAM,IAAI,OAAO,CAAC,IAAI,KAAK,oBAAoB,CAAC,gBAAgB,EAAE;QACxG,OAAO,KAAK,CAAC;KAChB;IACD,OAAO,IAAI,CAAC;AAChB,CAAC;AAED,gHAAgH;AAChH,2DAA2D;AAC3D,SAAS,6BAA6B,CAClC,OAAkC,EAClC,MAAe;IAEf,MAAM,eAAe,GAAG,MAAM,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;IAC3D,MAAM,IAAI,GAAG,eAAe,aAAf,eAAe,uBAAf,eAAe,CAAE,MAAM,CAAC,IAAI,CAAC;IAC1C,IAAI,IAAI,KAAK,SAAS,EAAE;QACpB,MAAM,eAAe,GAAqB;YACtC,IAAI;YACJ,SAAS,EAAE,OAAO,CAAC,SAAS;SAC/B,CAAC;QACF,OAAO,eAAe,CAAC;KAC1B;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAED;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,kCAAkC,CAC9C,iBAA0C,EAC1C,OAA0B,EAC1B,yBAA0E,2BAA2B;IAErG,+EAA+E;IAC/E,+CAA+C;IAC/C,8GAA8G;IAC9G,OAAO,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,OAAkC,EAAE,EAAE;QACpD,mGAAmG;QACnG,oGAAoG;QACpG,4CAA4C;QAC5C,MAAM,WAAW,GAAG,OAAO,CAAC,0BAA0B,KAAK,SAAS;YAChE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,0BAA0B,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;QAC5E,IAAI,sBAAsB,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,EAAE;YACjD,OAAO;SACV;QAED,6EAA6E;QAC7E,MAAM,eAAe,GAAG,6BAA6B,CAAC,OAAO,EAAE,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC;QACpF,IAAI,eAAe,KAAK,SAAS,EAAE;YAC/B,OAAO;SACV;QAED,iBAAiB,CAAC,qBAAqB,CAAC,eAAe,CAAC,CAAC;IAC7D,CAAC,CAAC,CAAC;AACP,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ISequencedDocumentMessage, IQuorum } from \"@fluidframework/protocol-definitions\";\nimport { ContainerMessageType } from \"@fluidframework/container-runtime\";\nimport { IContainerRuntime } from \"@fluidframework/container-runtime-definitions\";\nimport { ILastEditDetails, IFluidLastEditedTracker } from \"./interfaces\";\n\n// Default implementation of the shouldDiscardMessageFn function below that tells that all messages other\n// than \"Attach\" and \"Operation\" type messages should be discarded.\nfunction shouldDiscardMessageDefault(message: ISequencedDocumentMessage) {\n    if (message.type === ContainerMessageType.Attach || message.type === ContainerMessageType.FluidDataStoreOp) {\n        return false;\n    }\n    return true;\n}\n\n// Extracts the user information and timestamp from a message. Returns undefined if the user information for the\n// client who sent the message doesn't exist in the quorum.\nfunction getLastEditDetailsFromMessage(\n    message: ISequencedDocumentMessage,\n    quorum: IQuorum,\n): ILastEditDetails | undefined {\n    const sequencedClient = quorum.getMember(message.clientId);\n    const user = sequencedClient?.client.user;\n    if (user !== undefined) {\n        const lastEditDetails: ILastEditDetails = {\n            user,\n            timestamp: message.timestamp,\n        };\n        return lastEditDetails;\n    }\n    return undefined;\n}\n\n/**\n * Helper function to set up a data object that provides IFluidLastEditedTracker to track last edited in a Container.\n * It does the following:\n * - Registers an \"op\" listener on the runtime. On each message, it calls the shouldDiscardMessageFn to check\n *   if the message should be discarded. It also discards all scheduler message. If a message is not discarded,\n *   it passes the last edited information from the message to the last edited tracker.\n * - The last edited information from the last message received before the lastEditedTracker is\n *   loaded is stored and passed tothe tracker once it loads.\n * @param lastEditedTracker - The last editied tracker.\n * @param runtime - The container runtime whose messages are to be tracked.\n * @param shouldDiscardMessageFn - Function that tells if a message should not be considered in computing last edited.\n */\nexport function setupLastEditedTrackerForContainer(\n    lastEditedTracker: IFluidLastEditedTracker,\n    runtime: IContainerRuntime,\n    shouldDiscardMessageFn: (message: ISequencedDocumentMessage) => boolean = shouldDiscardMessageDefault,\n) {\n    // Register an op listener on the runtime. If the lastEditedTracker has loaded,\n    // it passes the last edited information to its\n    // last edited tracker. If the lastEditedTracker hasn't loaded, store the last edited information temporarily.\n    runtime.on(\"op\", (message: ISequencedDocumentMessage) => {\n        // If this is a scheduler messages or it should be discarded as per shouldDiscardMessageFn, return.\n        // To check for this, we use the runtime's isMessageDirtyable API. If it is not available, we assume\n        // that the message should not be discarded.\n        const isDirtyable = runtime.IContainerRuntimeDirtyable === undefined\n            ? true : runtime.IContainerRuntimeDirtyable.isMessageDirtyable(message);\n        if (shouldDiscardMessageFn(message) || !isDirtyable) {\n            return;\n        }\n\n        // Get the last edited details from the message. If it doesn't exist, return.\n        const lastEditDetails = getLastEditDetailsFromMessage(message, runtime.getQuorum());\n        if (lastEditDetails === undefined) {\n            return;\n        }\n\n        lastEditedTracker.updateLastEditDetails(lastEditDetails);\n    });\n}\n"]}