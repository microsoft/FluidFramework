{"version":3,"file":"discover.js","sourceRoot":"","sources":["../src/discover.ts"],"names":[],"mappings":"AAAA;;;GAGG;AA8BH,MAAM,CAAC,MAAM,gCAAgC,GACvC,kCAAkC,CAAC;AAmBzC,MAAM,CAAC,MAAM,4BAA4B,GAA8C,8BAA8B,CAAC;AAqCtH,MAAM,CAAC,MAAM,4BAA4B,GAA8C,8BAA8B,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IFluidObject } from \"@fluidframework/core-interfaces\";\n\n/**\n * The interfaces in this file are related to component interface discovery. The idea\n * is that a component could say, for example, that it only cares about (and wants to be\n * notified of) components that implement IFluidHTMLView. Then, using these patterns,\n * it will be notified of all loaded components that implement that type on load, and\n * of all new components that are loaded during that session that implement IFluidHTMLView.\n *\n * Components who want their functionality to be discoverable should implement\n * IComponentDiscoverableInterfaces and list the interfaces they implement. Components that\n * want to be notified of other components that implement certain interfaces should implement\n * IComponentDiscoverInterfaces.\n *\n * This file also includes the interface for an IComponentInterfacesRegistry, which we use\n * to implement a component that carries out the matching between different components.\n *\n * Disclaimer: These interfaces are experimental and are subject to change.\n */\n\ndeclare module \"@fluidframework/core-interfaces\" {\n    // eslint-disable-next-line @typescript-eslint/no-empty-interface\n    export interface IFluidObject extends Readonly<Partial<\n        IProvideComponentDiscoverableInterfaces\n        & IProvideComponentDiscoverInterfaces\n        & IProvideComponentInterfacesRegistry>> { }\n}\n\nexport const IComponentDiscoverableInterfaces: keyof IProvideComponentDiscoverableInterfaces\n    = \"IComponentDiscoverableInterfaces\";\n\nexport interface IProvideComponentDiscoverableInterfaces {\n    readonly IComponentDiscoverableInterfaces: IComponentDiscoverableInterfaces;\n}\n\n/**\n * The interface for a component that wants to allow its functionality to be discoverable,\n * i.e. other components in the ecosystem will be able to find and interact with this\n * component based on its functionality alone.\n */\nexport interface IComponentDiscoverableInterfaces extends IProvideComponentDiscoverableInterfaces {\n    /**\n     * The interfaces this component implements that it wants other components to be able\n     * to discover.\n     */\n    readonly discoverableInterfaces: (keyof (IFluidObject))[];\n}\n\nexport const IComponentDiscoverInterfaces: keyof IProvideComponentDiscoverInterfaces = \"IComponentDiscoverInterfaces\";\n\nexport interface IProvideComponentDiscoverInterfaces {\n    readonly IComponentDiscoverInterfaces: IComponentDiscoverInterfaces;\n}\n\n/**\n * The interface for a component that wants to be notified of components that implement the\n * interfaces specified in interfacesToDiscover.\n *\n * Components should expect to be notified of other components when they are loaded, and should\n * not expect for this relationship to be persisted beyond the current session.\n */\nexport interface IComponentDiscoverInterfaces extends IProvideComponentDiscoverInterfaces {\n    /**\n     * The interfaces this component cares about, i.e. it wants to be notified when other components\n     * that implement any of these interfaces are added to the ecosystem.\n     */\n    readonly interfacesToDiscover: (keyof (IFluidObject))[];\n\n    /**\n     * Invoked when any components that implement any of the interfaces in interfacesToDiscover are\n     * registered in the component ecosystem.\n     *\n     * This function should be called when:\n     * 1. This component is initially loaded, to be notified of all existing components in the ecosystem\n     * that implement interfaces in interfacesToDiscover, and\n     * 2. Whenever subsequent components are loaded that implement the same interfaces.\n     *\n     * @param interfaceName - The name of the interface that the given components implement.\n     * @param components - A list of the components that implement the given interface.\n     */\n    notifyComponentsDiscovered(\n        interfaceName: keyof (IFluidObject),\n        components: readonly (IFluidObject)[]): void;\n}\n\nexport const IComponentInterfacesRegistry: keyof IProvideComponentInterfacesRegistry = \"IComponentInterfacesRegistry\";\n\nexport interface IProvideComponentInterfacesRegistry {\n    readonly IComponentInterfacesRegistry: IComponentInterfacesRegistry;\n}\n\n/**\n * IComponentInterfacesRegistry is the contract for a component that can act as a registry\n * of the interfaces of different components that are loaded in the container.\n *\n * The current use case of this pattern is that components who deal with interface discovery\n * will notify the interfaces registry when they are loaded. Then, the interface registry\n * can handle matching of components that implement/want to discover the same interfaces.\n *\n * This relationship only exists per session as components are loaded and we recommend against\n * persisting the registry.\n *\n */\nexport interface IComponentInterfacesRegistry extends IProvideComponentInterfacesRegistry {\n    /**\n     * Invoked when a component is to be registered as a component with discoverable interfaces.\n     */\n    registerComponentInterfaces(\n        component: IProvideComponentDiscoverInterfaces | IProvideComponentDiscoverableInterfaces): void;\n\n    /**\n     * Invoked when a component is to be unregistered from the registry.\n     */\n    unregisterComponentInterfaces(\n        component: IProvideComponentDiscoverInterfaces | IProvideComponentDiscoverableInterfaces): void;\n}\n"]}