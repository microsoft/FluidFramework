## Beta API Report File for "@fluidframework/aqueduct"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @beta @legacy
export class BaseContainerRuntimeFactory extends RuntimeFactoryHelper implements IProvideFluidDataStoreRegistry {
    constructor(props: BaseContainerRuntimeFactoryProps);
    protected containerHasInitialized(runtime: IContainerRuntime): Promise<void>;
    protected containerInitializingFirstTime(runtime: IContainerRuntime): Promise<void>;
    get IFluidDataStoreRegistry(): IFluidDataStoreRegistry;
    instantiateFirstTime(runtime: IContainerRuntime): Promise<void>;
    instantiateFromExisting(runtime: IContainerRuntime): Promise<void>;
    preInitialize(context: IContainerContext, existing: boolean): Promise<IContainerRuntime & IRuntime>;
}

// @beta @legacy
export interface BaseContainerRuntimeFactoryProps {
    // @deprecated (undocumented)
    dependencyContainer?: IFluidDependencySynthesizer;
    minVersionForCollab?: MinimumVersionForCollab | undefined;
    provideEntryPoint: (runtime: IContainerRuntime) => Promise<FluidObject>;
    registryEntries: NamedFluidDataStoreRegistryEntries;
    // @deprecated
    requestHandlers?: RuntimeRequestHandler[];
    runtimeOptions?: IContainerRuntimeOptions;
}

// @beta @legacy
export class ContainerRuntimeFactoryWithDefaultDataStore extends BaseContainerRuntimeFactory {
    constructor(props: ContainerRuntimeFactoryWithDefaultDataStoreProps);
    protected containerInitializingFirstTime(runtime: IContainerRuntime): Promise<void>;
    // (undocumented)
    static readonly defaultDataStoreId = "default";
    // (undocumented)
    protected readonly defaultFactory: IFluidDataStoreFactory;
}

// @beta @legacy
export interface ContainerRuntimeFactoryWithDefaultDataStoreProps {
    // (undocumented)
    defaultFactory: IFluidDataStoreFactory;
    // @deprecated (undocumented)
    dependencyContainer?: IFluidDependencySynthesizer;
    provideEntryPoint?: (runtime: IContainerRuntime) => Promise<FluidObject>;
    registryEntries: NamedFluidDataStoreRegistryEntries;
    // @deprecated
    requestHandlers?: RuntimeRequestHandler[];
    runtimeOptions?: IContainerRuntimeOptions;
}

// @beta @legacy
export interface CreateDataObjectProps<TObj extends PureDataObject, I extends DataObjectTypes> {
    // (undocumented)
    context: IFluidDataStoreContext;
    // (undocumented)
    ctor: new (props: IDataObjectProps<I>) => TObj;
    // (undocumented)
    existing: boolean;
    // (undocumented)
    initialState?: I["InitialState"];
    // (undocumented)
    optionalProviders: FluidObjectSymbolProvider<I["OptionalProviders"]>;
    // (undocumented)
    policies?: Partial<IFluidDataStorePolicies>;
    // (undocumented)
    runtimeClassArg: typeof FluidDataStoreRuntime;
    // (undocumented)
    sharedObjectRegistry: ISharedObjectRegistry;
}

// @beta @legacy
export abstract class DataObject<I extends DataObjectTypes = DataObjectTypes> extends MigrationDataObject<RootDirectoryView, I> {
    // (undocumented)
    protected asyncGetDataForMigration(existingModel: RootDirectoryView): Promise<never>;
    // (undocumented)
    protected canPerformMigration(): Promise<boolean>;
    // (undocumented)
    protected migrateDataObject(newModel: RootDirectoryView, data: never): void;
    protected static modelDescriptors: [
    ModelDescriptor<RootDirectoryView>,
    ...ModelDescriptor<RootDirectoryView>[]
    ];
    protected get root(): ISharedDirectory;
}

// @beta @legacy
export class DataObjectFactory<TObj extends DataObject<I>, I extends DataObjectTypes = DataObjectTypes> extends PureDataObjectFactory<TObj, I> {
    constructor(type: string, ctor: new (props: IDataObjectProps<I>) => TObj, sharedObjects?: readonly IChannelFactory[], optionalProviders?: FluidObjectSymbolProvider<I["OptionalProviders"]>, registryEntries?: NamedFluidDataStoreRegistryEntries, runtimeFactory?: typeof FluidDataStoreRuntime);
    constructor(props: DataObjectFactoryProps<TObj, I>);
}

// @beta @legacy
export interface DataObjectFactoryProps<TObj extends PureDataObject<I>, I extends DataObjectTypes = DataObjectTypes> {
    readonly afterBindRuntime?: (runtime: IFluidDataStoreChannel) => Promise<void>;
    readonly ctor: new (props: IDataObjectProps<I>) => TObj;
    readonly optionalProviders?: FluidObjectSymbolProvider<I["OptionalProviders"]>;
    readonly policies?: Partial<IFluidDataStorePolicies>;
    readonly registryEntries?: NamedFluidDataStoreRegistryEntries;
    readonly runtimeClass?: typeof FluidDataStoreRuntime;
    readonly sharedObjects?: readonly IChannelFactory[];
    readonly type: string;
}

// @beta @legacy
export interface DataObjectTypes {
    Events?: IEvent;
    InitialState?: any;
    OptionalProviders?: FluidObject;
}

// @beta @legacy (undocumented)
export interface IDataObjectProps<I extends DataObjectTypes = DataObjectTypes> {
    // (undocumented)
    readonly context: IFluidDataStoreContext;
    // (undocumented)
    readonly initProps?: I["InitialState"];
    // (undocumented)
    readonly providers: AsyncFluidObjectProvider<I["OptionalProviders"]>;
    // (undocumented)
    readonly runtime: IFluidDataStoreRuntime;
}

// @beta @legacy
export interface IDelayLoadChannelFactory<T = unknown> extends IChannelFactory<T> {
    // (undocumented)
    createAsync(runtime: IFluidDataStoreRuntime, id?: string): Promise<T>;
    // (undocumented)
    loadObjectKindAsync(): Promise<void>;
}

// @beta @legacy
export interface IMigrationInfo extends IProvideMigrationInfo {
    readonly migrate: () => Promise<void>;
    readonly targetFormatTag: string;
}

// @beta @legacy
export interface IProvideMigrationInfo extends FluidObject {
    IMigrationInfo?: IMigrationInfo | undefined;
}

// @beta @legacy
export abstract class MigrationDataObject<TUniversalView, I extends DataObjectTypes = DataObjectTypes, TMigrationData = never> extends PureDataObject<I> implements IProvideMigrationInfo {
    protected abstract asyncGetDataForMigration(existingModel: TUniversalView): Promise<TMigrationData>;
    protected abstract canPerformMigration(): Promise<boolean>;
    get dataModel(): {
        descriptor: ModelDescriptor<TUniversalView>;
        view: TUniversalView;
    } | undefined;
    protected abstract getModelDescriptors(): Promise<readonly [ModelDescriptor<TUniversalView>, ...ModelDescriptor<TUniversalView>[]]>;
    protected getUninitializedErrorString(item: string): string;
    // (undocumented)
    get IMigrationInfo(): IMigrationInfo | undefined;
    // (undocumented)
    initializeInternal(existing: boolean): Promise<void>;
    // (undocumented)
    migrate(): Promise<void>;
    protected abstract migrateDataObject(newModel: TUniversalView, data: TMigrationData): void;
    // (undocumented)
    shouldMigrateBeforeInitialized(): Promise<boolean>;
}

// @beta @legacy
export class MigrationDataObjectFactory<TObj extends MigrationDataObject<TUniversalView, I>, TUniversalView, I extends DataObjectTypes = DataObjectTypes> extends PureDataObjectFactory<TObj, I> {
    constructor(props: DataObjectFactoryProps<TObj, I>, modelDescriptors: readonly ModelDescriptor<TUniversalView>[]);
}

// @beta @legacy
export interface ModelDescriptor<TModel = unknown> {
    create: (runtime: IFluidDataStoreRuntime) => TModel;
    ensureFactoriesLoaded: () => Promise<void>;
    // (undocumented)
    is?: (m: unknown) => m is TModel;
    // (undocumented)
    probe: (runtime: IFluidDataStoreRuntime) => Promise<TModel | undefined>;
    sharedObjects: {
        alwaysLoaded?: IChannelFactory[];
        delayLoaded?: IDelayLoadChannelFactory[];
    };
}

// @beta @legacy
export abstract class PureDataObject<I extends DataObjectTypes = DataObjectTypes> extends TypedEventEmitter<I["Events"] & IEvent> implements IFluidLoadable, IProvideFluidHandle {
    constructor(props: IDataObjectProps<I>);
    protected readonly context: IFluidDataStoreContext;
    finishInitialization(existing: boolean): Promise<void>;
    // (undocumented)
    static getDataObject(runtime: IFluidDataStoreRuntime): Promise<PureDataObject>;
    get handle(): IFluidHandleInternal<this>;
    protected hasInitialized(): Promise<void>;
    // (undocumented)
    get id(): string;
    get IFluidHandle(): IFluidHandleInternal<this>;
    get IFluidLoadable(): this;
    initializeInternal(existing: boolean): Promise<void>;
    protected initializeP: Promise<void> | undefined;
    protected initializingFirstTime(props?: I["InitialState"]): Promise<void>;
    protected initializingFromExisting(): Promise<void>;
    // (undocumented)
    protected initProps?: I["InitialState"];
    protected preInitialize(): Promise<void>;
    protected readonly providers: AsyncFluidObjectProvider<I["OptionalProviders"]>;
    request(req: IRequest): Promise<IResponse>;
    protected readonly runtime: IFluidDataStoreRuntime;
}

// @beta @legacy
export class PureDataObjectFactory<TObj extends PureDataObject<I>, I extends DataObjectTypes = DataObjectTypes> implements IFluidDataStoreFactory, Partial<IProvideFluidDataStoreRegistry> {
    constructor(type: string, ctor: new (props: IDataObjectProps<I>) => TObj, sharedObjects?: readonly IChannelFactory[], optionalProviders?: FluidObjectSymbolProvider<I["OptionalProviders"]>, registryEntries?: NamedFluidDataStoreRegistryEntries, runtimeClass?: typeof FluidDataStoreRuntime);
    constructor(props: DataObjectFactoryProps<TObj, I>);
    readonly afterBindRuntime?: (runtime: IFluidDataStoreChannel) => Promise<void>;
    createChildInstance(parentContext: IFluidDataStoreContext, initialState?: I["InitialState"], loadingGroupId?: string): Promise<TObj>;
    createInstance(runtime: IContainerRuntimeBase, initialState?: I["InitialState"], loadingGroupId?: string): Promise<TObj>;
    // (undocumented)
    protected createInstanceCore(context: IFluidDataStoreContextDetached, initialState?: I["InitialState"]): Promise<TObj>;
    createInstanceWithDataStore(containerRuntime: IContainerRuntimeBase, initialState?: I["InitialState"], packagePath?: Readonly<string[]>, loadingGroupId?: string): Promise<[TObj, IDataStore]>;
    // (undocumented)
    protected createNonRootInstanceCore(containerRuntime: IContainerRuntimeBase, packagePath: Readonly<string[]>, initialState?: I["InitialState"], loadingGroupId?: string): Promise<TObj>;
    createPeerInstance(peerContext: IFluidDataStoreContext, initialState?: I["InitialState"], loadingGroupId?: string): Promise<TObj>;
    // @deprecated
    createRootInstance(rootDataStoreId: string, runtime: IContainerRuntime, initialState?: I["InitialState"]): Promise<TObj>;
    get IFluidDataStoreFactory(): this;
    get IFluidDataStoreRegistry(): IFluidDataStoreRegistry | undefined;
    instantiateDataStore(context: IFluidDataStoreContext, existing: boolean): Promise<IFluidDataStoreChannel>;
    // (undocumented)
    protected observeCreateDataObject(createProps: CreateDataObjectProps<TObj, I>): Promise<void>;
    get registryEntry(): NamedFluidDataStoreRegistryEntry;
    readonly type: string;
}

// @beta @legacy
export interface RootDirectoryView {
    // (undocumented)
    root: ISharedDirectory;
}

// @beta @legacy
export interface RootTreeView {
    // (undocumented)
    tree: ITree_2;
}

// @beta @legacy
export abstract class TreeDataObject<TDataObjectTypes extends DataObjectTypes = DataObjectTypes> extends MigrationDataObject<RootTreeView, TDataObjectTypes> {
    protected static modelDescriptors: [
    ModelDescriptor<RootTreeView>,
    ...ModelDescriptor<RootTreeView>[]
    ];
    protected get tree(): ITree_2;
}

// @beta @legacy
export class TreeDataObjectFactory<TDataObject extends TreeDataObject<TDataObjectTypes>, TDataObjectTypes extends DataObjectTypes = DataObjectTypes> extends PureDataObjectFactory<TDataObject, TDataObjectTypes> {
    constructor(props: DataObjectFactoryProps<TDataObject, TDataObjectTypes>);
}

```
