## Alpha API Report File for "fluid-framework"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Client } from '@fluidframework/merge-tree/internal';
import { ErasedType } from '@fluidframework/core-interfaces';
import { IChannel } from '@fluidframework/datastore-definitions/internal';
import { IDisposable } from '@fluidframework/core-interfaces';
import type { IErrorBase } from '@fluidframework/core-interfaces';
import { IErrorEvent } from '@fluidframework/core-interfaces';
import { IEvent } from '@fluidframework/core-interfaces';
import { IEventProvider } from '@fluidframework/core-interfaces';
import { IEventThisPlaceHolder } from '@fluidframework/core-interfaces';
import { IFluidHandle } from '@fluidframework/core-interfaces';
import { IFluidLoadable } from '@fluidframework/core-interfaces';
import { IGarbageCollectionData } from '@fluidframework/runtime-definitions/internal';
import { IJSONSegment } from '@fluidframework/merge-tree/internal';
import { IMergeTreeDeltaCallbackArgs } from '@fluidframework/merge-tree/internal';
import { IMergeTreeDeltaOpArgs } from '@fluidframework/merge-tree/internal';
import { IMergeTreeGroupMsg } from '@fluidframework/merge-tree/internal';
import { IMergeTreeMaintenanceCallbackArgs } from '@fluidframework/merge-tree/internal';
import { IRelativePosition } from '@fluidframework/merge-tree/internal';
import { ISegment } from '@fluidframework/merge-tree/internal';
import { ISegmentAction } from '@fluidframework/merge-tree/internal';
import { ISharedObjectKind } from '@fluidframework/shared-object-base/internal';
import { LocalReferencePosition } from '@fluidframework/merge-tree/internal';
import { Marker } from '@fluidframework/merge-tree/internal';
import { MergeTreeDeltaOperationType } from '@fluidframework/merge-tree/internal';
import { MergeTreeDeltaOperationTypes } from '@fluidframework/merge-tree/internal';
import { MergeTreeMaintenanceType } from '@fluidframework/merge-tree/internal';
import { MergeTreeRevertibleDriver } from '@fluidframework/merge-tree/internal';
import { PropertiesManager } from '@fluidframework/merge-tree/internal';
import { PropertySet } from '@fluidframework/merge-tree/internal';
import { ReferencePosition } from '@fluidframework/merge-tree/internal';
import { ReferenceType } from '@fluidframework/merge-tree/internal';
import { SharedObjectKind as SharedObjectKind_2 } from '@fluidframework/shared-object-base/internal';
import { SlidingPreference } from '@fluidframework/merge-tree/internal';
import { TextSegment } from '@fluidframework/merge-tree/internal';
import { TypedEventEmitter } from '@fluid-internal/client-utils';

// @public
export type AllowedTypes = readonly LazyItem<TreeNodeSchema>[];

// @public
export type ApplyKind<T, Kind extends FieldKind, DefaultsAreOptional extends boolean> = {
    [FieldKind.Required]: T;
    [FieldKind.Optional]: T | undefined;
    [FieldKind.Identifier]: DefaultsAreOptional extends true ? T | undefined : T;
}[Kind];

// @public
export enum AttachState {
    Attached = "Attached",
    Attaching = "Attaching",
    Detached = "Detached"
}

// @public
export enum CommitKind {
    Default = 0,
    Redo = 2,
    Undo = 1
}

// @public
export interface CommitMetadata {
    readonly isLocal: boolean;
    readonly kind: CommitKind;
}

// @public
export enum ConnectionState {
    CatchingUp = 1,
    Connected = 2,
    Disconnected = 0,
    EstablishingConnection = 3
}

// @public
export namespace ConnectionStateType {
    export type CatchingUp = 1;
    export type Connected = 2;
    export type Disconnected = 0;
    export type EstablishingConnection = 3;
}

// @public
export type ConnectionStateType = ConnectionStateType.Disconnected | ConnectionStateType.EstablishingConnection | ConnectionStateType.CatchingUp | ConnectionStateType.Connected;

// @public
export type ContainerAttachProps<T = unknown> = T;

// @public
export interface ContainerSchema {
    readonly dynamicObjectTypes?: readonly SharedObjectKind[];
    readonly initialObjects: Record<string, SharedObjectKind>;
}

// @public
export interface DefaultProvider extends ErasedType<"@fluidframework/tree.FieldProvider"> {
}

// @alpha (undocumented)
export type DeserializeCallback = (properties: PropertySet) => void;

// @public
export type ExtractItemType<Item extends LazyItem> = Item extends () => infer Result ? Result : Item;

// @public
export enum FieldKind {
    Identifier = 2,
    Optional = 0,
    Required = 1
}

// @public
export interface FieldProps {
    readonly defaultProvider?: DefaultProvider;
    readonly key?: string;
}

// @public @sealed
export class FieldSchema<out Kind extends FieldKind = FieldKind, out Types extends ImplicitAllowedTypes = ImplicitAllowedTypes> {
    readonly allowedTypes: Types;
    get allowedTypeSet(): ReadonlySet<TreeNodeSchema>;
    readonly kind: Kind;
    readonly props?: FieldProps | undefined;
    protected _typeCheck?: MakeNominal;
}

// @public
export interface FieldSchemaUnsafe<out Kind extends FieldKind, out Types extends Unenforced<ImplicitAllowedTypes>> extends FieldSchema<Kind, any> {
    readonly allowedTypes: Types;
    readonly allowedTypeSet: ReadonlySet<TreeNodeSchema>;
    readonly kind: Kind;
}

// @public
export type FlexList<Item = unknown> = readonly LazyItem<Item>[];

// @public
export type FlexListToUnion<TList extends FlexList> = ExtractItemType<TList[number]>;

// @public
export interface IBranchOrigin {
    id: string;
    minimumSequenceNumber: number;
    sequenceNumber: number;
}

// @public
export interface IConnection {
    readonly id: string;
    readonly mode: "write" | "read";
}

// @public
export type ICriticalContainerError = IErrorBase;

// @alpha
export interface IDirectory extends Map<string, any>, IEventProvider<IDirectoryEvents>, Partial<IDisposable> {
    readonly absolutePath: string;
    countSubDirectory?(): number;
    createSubDirectory(subdirName: string): IDirectory;
    deleteSubDirectory(subdirName: string): boolean;
    get<T = any>(key: string): T | undefined;
    getSubDirectory(subdirName: string): IDirectory | undefined;
    getWorkingDirectory(relativePath: string): IDirectory | undefined;
    hasSubDirectory(subdirName: string): boolean;
    set<T = unknown>(key: string, value: T): this;
    subdirectories(): IterableIterator<[string, IDirectory]>;
}

// @alpha
export interface IDirectoryEvents extends IEvent {
    (event: "containedValueChanged", listener: (changed: IValueChanged, local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "subDirectoryCreated", listener: (path: string, local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "subDirectoryDeleted", listener: (path: string, local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "disposed", listener: (target: IEventThisPlaceHolder) => void): any;
    (event: "undisposed", listener: (target: IEventThisPlaceHolder) => void): any;
}

// @alpha
export interface IDirectoryValueChanged extends IValueChanged {
    path: string;
}

// @public @sealed
export interface IFluidContainer<TContainerSchema extends ContainerSchema = ContainerSchema> extends IEventProvider<IFluidContainerEvents> {
    attach(props?: ContainerAttachProps): Promise<string>;
    readonly attachState: AttachState;
    connect(): void;
    readonly connectionState: ConnectionStateType;
    create<T extends IFluidLoadable>(objectClass: SharedObjectKind<T>): Promise<T>;
    disconnect(): void;
    dispose(): void;
    readonly disposed: boolean;
    readonly initialObjects: InitialObjects<TContainerSchema>;
    readonly isDirty: boolean;
}

// @public @sealed
export interface IFluidContainerEvents extends IEvent {
    (event: "connected", listener: () => void): void;
    (event: "disconnected", listener: () => void): void;
    (event: "saved", listener: () => void): void;
    (event: "dirty", listener: () => void): void;
    (event: "disposed", listener: (error?: ICriticalContainerError) => void): any;
}

// @alpha
export interface IInterval {
    // (undocumented)
    clone(): IInterval;
    compare(b: IInterval): number;
    compareEnd(b: IInterval): number;
    compareStart(b: IInterval): number;
    modify(label: string, start: SequencePlace | undefined, end: SequencePlace | undefined, op?: ISequencedDocumentMessage, localSeq?: number, useNewSlidingBehavior?: boolean): IInterval | undefined;
    // (undocumented)
    overlaps(b: IInterval): boolean;
    union(b: IInterval): IInterval;
}

// @alpha
export interface IIntervalCollection<TInterval extends ISerializableInterval> extends TypedEventEmitter<IIntervalCollectionEvent<TInterval>> {
    // (undocumented)
    [Symbol.iterator](): Iterator<TInterval>;
    add({ start, end, props, }: {
        start: SequencePlace;
        end: SequencePlace;
        props?: PropertySet;
    }): TInterval;
    // (undocumented)
    attachDeserializer(onDeserialize: DeserializeCallback): void;
    // (undocumented)
    readonly attached: boolean;
    attachIndex(index: IntervalIndex<TInterval>): void;
    change(id: string, { start, end, props }: {
        start?: SequencePlace;
        end?: SequencePlace;
        props?: PropertySet;
    }): TInterval | undefined;
    // (undocumented)
    CreateBackwardIteratorWithEndPosition(endPosition: number): Iterator<TInterval>;
    // (undocumented)
    CreateBackwardIteratorWithStartPosition(startPosition: number): Iterator<TInterval>;
    // (undocumented)
    CreateForwardIteratorWithEndPosition(endPosition: number): Iterator<TInterval>;
    // (undocumented)
    CreateForwardIteratorWithStartPosition(startPosition: number): Iterator<TInterval>;
    detachIndex(index: IntervalIndex<TInterval>): boolean;
    // @deprecated (undocumented)
    findOverlappingIntervals(startPosition: number, endPosition: number): TInterval[];
    gatherIterationResults(results: TInterval[], iteratesForward: boolean, start?: number, end?: number): void;
    // (undocumented)
    getIntervalById(id: string): TInterval | undefined;
    map(fn: (interval: TInterval) => void): void;
    // @deprecated (undocumented)
    nextInterval(pos: number): TInterval | undefined;
    // @deprecated (undocumented)
    previousInterval(pos: number): TInterval | undefined;
    removeIntervalById(id: string): TInterval | undefined;
}

// @alpha
export interface IIntervalCollectionEvent<TInterval extends ISerializableInterval> extends IEvent {
    (event: "changeInterval", listener: (interval: TInterval, previousInterval: TInterval, local: boolean, op: ISequencedDocumentMessage | undefined, slide: boolean) => void): void;
    (event: "addInterval" | "deleteInterval", listener: (interval: TInterval, local: boolean, op: ISequencedDocumentMessage | undefined) => void): void;
    (event: "propertyChanged", listener: (interval: TInterval, propertyDeltas: PropertySet, local: boolean, op: ISequencedDocumentMessage | undefined) => void): void;
    (event: "changed", listener: (interval: TInterval, propertyDeltas: PropertySet, previousInterval: TInterval | undefined, local: boolean, slide: boolean) => void): void;
}

// @public
export interface IMember {
    readonly connections: IConnection[];
    readonly id: string;
}

// @public
export type ImplicitAllowedTypes = AllowedTypes | TreeNodeSchema;

// @public
export type ImplicitFieldSchema = FieldSchema | ImplicitAllowedTypes;

// @public
export type InitialObjects<T extends ContainerSchema> = {
    [K in keyof T["initialObjects"]]: T["initialObjects"][K] extends SharedObjectKind<infer TChannel> ? TChannel : never;
};

// @public
export type InsertableObjectFromSchemaRecord<T extends RestrictiveReadonlyRecord<string, ImplicitFieldSchema>> = {
    readonly [Property in keyof T]: InsertableTreeFieldFromImplicitField<T[Property]>;
};

// @public
export type InsertableObjectFromSchemaRecordUnsafe<T extends Unenforced<RestrictiveReadonlyRecord<string, ImplicitFieldSchema>>> = {
    readonly [Property in keyof T]: InsertableTreeFieldFromImplicitFieldUnsafe<T[Property]>;
};

// @public
export type InsertableTreeFieldFromImplicitField<TSchema extends ImplicitFieldSchema = FieldSchema> = TSchema extends FieldSchema<infer Kind, infer Types> ? ApplyKind<InsertableTreeNodeFromImplicitAllowedTypes<Types>, Kind, true> : TSchema extends ImplicitAllowedTypes ? InsertableTreeNodeFromImplicitAllowedTypes<TSchema> : unknown;

// @public
export type InsertableTreeFieldFromImplicitFieldUnsafe<TSchema extends Unenforced<ImplicitFieldSchema>> = TSchema extends FieldSchemaUnsafe<infer Kind, infer Types> ? ApplyKind<InsertableTreeNodeFromImplicitAllowedTypesUnsafe<Types>, Kind, true> : InsertableTreeNodeFromImplicitAllowedTypesUnsafe<TSchema>;

// @public
export type InsertableTreeNodeFromImplicitAllowedTypes<TSchema extends ImplicitAllowedTypes = TreeNodeSchema> = TSchema extends TreeNodeSchema ? InsertableTypedNode<TSchema> : TSchema extends AllowedTypes ? InsertableTypedNode<FlexListToUnion<TSchema>> : never;

// @public
export type InsertableTreeNodeFromImplicitAllowedTypesUnsafe<TSchema extends Unenforced<ImplicitAllowedTypes>> = TSchema extends AllowedTypes ? InsertableTypedNodeUnsafe<FlexListToUnion<TSchema>> : InsertableTypedNodeUnsafe<TSchema>;

// @public
export type InsertableTypedNode<T extends TreeNodeSchema> = (T extends {
    implicitlyConstructable: true;
} ? NodeBuilderData<T> : never) | Unhydrated<NodeFromSchema<T>>;

// @public
export type InsertableTypedNodeUnsafe<T extends Unenforced<TreeNodeSchema>> = Unhydrated<NodeFromSchemaUnsafe<T>> | (T extends {
    implicitlyConstructable: true;
} ? NodeBuilderDataUnsafe<T> : never);

// @alpha
export interface InteriorSequencePlace {
    // (undocumented)
    pos: number;
    // (undocumented)
    side: Side;
}

// @public
export interface InternalTreeNode extends ErasedType<"@fluidframework/tree.InternalTreeNode"> {
}

// @alpha
export interface IntervalIndex<TInterval extends ISerializableInterval> {
    add(interval: TInterval): void;
    remove(interval: TInterval): void;
}

// @alpha
export const IntervalStickiness: {
    readonly NONE: 0;
    readonly START: 1;
    readonly END: 2;
    readonly FULL: 3;
};

// @alpha
export type IntervalStickiness = (typeof IntervalStickiness)[keyof typeof IntervalStickiness];

// @alpha (undocumented)
export enum IntervalType {
    // (undocumented)
    Simple = 0,
    SlideOnRemove = 2,// SlideOnRemove is default behavior - all intervals are SlideOnRemove
}

// @public
export interface ISequencedDocumentMessage {
    clientId: string | null;
    clientSequenceNumber: number;
    // @deprecated
    compression?: string;
    contents: unknown;
    data?: string;
    // @deprecated
    expHash1?: string;
    metadata?: unknown;
    minimumSequenceNumber: number;
    origin?: IBranchOrigin;
    referenceSequenceNumber: number;
    sequenceNumber: number;
    serverMetadata?: unknown;
    timestamp: number;
    traces?: ITrace[];
    type: string;
}

// @alpha
export interface ISequenceDeltaRange<TOperation extends MergeTreeDeltaOperationTypes = MergeTreeDeltaOperationTypes> {
    operation: TOperation;
    position: number;
    propertyDeltas: PropertySet;
    segment: ISegment;
}

// @alpha (undocumented)
export interface ISerializableInterval extends IInterval {
    // (undocumented)
    addProperties(props: PropertySet, collaborating?: boolean, seq?: number): PropertySet | undefined;
    getIntervalId(): string | undefined;
    properties: PropertySet;
    // (undocumented)
    propertyManager: PropertiesManager;
    // (undocumented)
    serialize(): ISerializedInterval;
}

// @alpha
export interface ISerializedInterval {
    end: number | "start" | "end";
    // (undocumented)
    endSide?: Side;
    intervalType: IntervalType;
    properties?: PropertySet;
    sequenceNumber: number;
    start: number | "start" | "end";
    // (undocumented)
    startSide?: Side;
    stickiness?: IntervalStickiness;
}

// @public
export interface IServiceAudience<M extends IMember> extends IEventProvider<IServiceAudienceEvents<M>> {
    getMembers(): ReadonlyMap<string, M>;
    getMyself(): Myself<M> | undefined;
}

// @public
export interface IServiceAudienceEvents<M extends IMember> extends IEvent {
    // @eventProperty
    (event: "membersChanged", listener: () => void): void;
    // @eventProperty
    (event: "memberAdded", listener: MemberChangedListener<M>): void;
    // @eventProperty
    (event: "memberRemoved", listener: MemberChangedListener<M>): void;
}

// @alpha
export interface ISharedDirectory extends ISharedObject<ISharedDirectoryEvents & IDirectoryEvents>, Omit<IDirectory, "on" | "once" | "off"> {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<[string, any]>;
    // (undocumented)
    readonly [Symbol.toStringTag]: string;
}

// @alpha
export interface ISharedDirectoryEvents extends ISharedObjectEvents {
    (event: "valueChanged", listener: (changed: IDirectoryValueChanged, local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "clear", listener: (local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "subDirectoryCreated", listener: (path: string, local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "subDirectoryDeleted", listener: (path: string, local: boolean, target: IEventThisPlaceHolder) => void): any;
}

// @alpha (undocumented)
export interface ISharedIntervalCollection<TInterval extends ISerializableInterval> {
    // (undocumented)
    getIntervalCollection(label: string): IIntervalCollection<TInterval>;
}

// @alpha @sealed
export interface ISharedMap extends ISharedObject<ISharedMapEvents>, Map<string, any> {
    get<T = any>(key: string): T | undefined;
    set<T = unknown>(key: string, value: T): this;
}

// @alpha @sealed
export interface ISharedMapEvents extends ISharedObjectEvents {
    (event: "valueChanged", listener: (changed: IValueChanged, local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "clear", listener: (local: boolean, target: IEventThisPlaceHolder) => void): any;
}

// @alpha
export interface ISharedObject<TEvent extends ISharedObjectEvents = ISharedObjectEvents> extends IChannel, IEventProvider<TEvent> {
    bindToContext(): void;
    getGCData(fullGC?: boolean): IGarbageCollectionData;
}

// @alpha
export interface ISharedObjectEvents extends IErrorEvent {
    // @eventProperty
    (event: "pre-op", listener: (op: ISequencedDocumentMessage, local: boolean, target: IEventThisPlaceHolder) => void): any;
    // @eventProperty
    (event: "op", listener: (op: ISequencedDocumentMessage, local: boolean, target: IEventThisPlaceHolder) => void): any;
}

// @alpha (undocumented)
export interface ISharedSegmentSequence<T extends ISegment> extends ISharedObject<ISharedSegmentSequenceEvents>, ISharedIntervalCollection<SequenceInterval>, MergeTreeRevertibleDriver {
    annotateRange(start: number, end: number, props: PropertySet): void;
    createLocalReferencePosition(segment: T, offset: number, refType: ReferenceType, properties: PropertySet | undefined, slidingPreference?: SlidingPreference, canSlideToEndpoint?: boolean): LocalReferencePosition;
    getContainingSegment(pos: number): {
        segment: T | undefined;
        offset: number | undefined;
    };
    // (undocumented)
    getCurrentSeq(): number;
    getIntervalCollection(label: string): IIntervalCollection<SequenceInterval>;
    // (undocumented)
    getIntervalCollectionLabels(): IterableIterator<string>;
    getLength(): number;
    getPosition(segment: ISegment): number;
    // (undocumented)
    getPropertiesAtPosition(pos: number): PropertySet | undefined;
    // (undocumented)
    getRangeExtentsOfPosition(pos: number): {
        posStart: number | undefined;
        posAfterEnd: number | undefined;
    };
    // @deprecated (undocumented)
    groupOperation(groupOp: IMergeTreeGroupMsg): void;
    initializeLocal(): void;
    insertAtReferencePosition(pos: ReferencePosition, segment: T): void;
    insertFromSpec(pos: number, spec: IJSONSegment): void;
    localReferencePositionToPosition(lref: ReferencePosition): number;
    obliterateRange(start: number, end: number): void;
    posFromRelativePos(relativePos: IRelativePosition): number;
    removeLocalReferencePosition(lref: LocalReferencePosition): LocalReferencePosition | undefined;
    // (undocumented)
    removeRange(start: number, end: number): void;
    resolveRemoteClientPosition(remoteClientPosition: number, remoteClientRefSeq: number, remoteClientId: string): number | undefined;
    walkSegments<TClientData>(handler: ISegmentAction<TClientData>, start?: number, end?: number, accum?: TClientData, splitRange?: boolean): void;
}

// @alpha
export interface ISharedSegmentSequenceEvents extends ISharedObjectEvents {
    // (undocumented)
    (event: "createIntervalCollection", listener: (label: string, local: boolean, target: IEventThisPlaceHolder) => void): void;
    // (undocumented)
    (event: "sequenceDelta", listener: (event: SequenceDeltaEvent, target: IEventThisPlaceHolder) => void): void;
    // (undocumented)
    (event: "maintenance", listener: (event: SequenceMaintenanceEvent, target: IEventThisPlaceHolder) => void): void;
}

// @alpha
export interface ISharedString extends ISharedSegmentSequence<SharedStringSegment> {
    annotateMarker(marker: Marker, props: PropertySet): void;
    getMarkerFromId(id: string): ISegment | undefined;
    getText(start?: number, end?: number): string;
    // (undocumented)
    getTextRangeWithMarkers(start: number, end: number): string;
    getTextWithPlaceholders(start?: number, end?: number): string;
    insertMarker(pos: number, refType: ReferenceType, props?: PropertySet): void;
    insertMarkerRelative(relativePos1: IRelativePosition, refType: ReferenceType, props?: PropertySet): void;
    insertText(pos: number, text: string, props?: PropertySet): void;
    insertTextRelative(relativePos1: IRelativePosition, text: string, props?: PropertySet): void;
    removeText(start: number, end: number): void;
    replaceText(start: number, end: number, text: string, props?: PropertySet): void;
    searchForMarker(startPos: number, markerLabel: string, forwards?: boolean): Marker | undefined;
}

// @public
export type IsListener<TListener> = TListener extends (...args: any[]) => void ? true : false;

// @public
export class IterableTreeArrayContent<T> implements Iterable<T> {
    [Symbol.iterator](): Iterator<T>;
}

// @public
export interface ITrace {
    action: string;
    service: string;
    timestamp: number;
}

// @public
export interface ITree extends IFluidLoadable {
    schematize<TRoot extends ImplicitFieldSchema>(config: TreeConfiguration<TRoot>): TreeView<TRoot>;
}

// @public
export interface ITreeConfigurationOptions {
    enableSchemaValidation?: boolean;
}

// @alpha @sealed
export interface IValueChanged {
    readonly key: string;
    readonly previousValue: any;
}

// @public
export type LazyItem<Item = unknown> = Item | (() => Item);

// @public
export interface Listenable<TListeners extends object> {
    on<K extends keyof Listeners<TListeners>>(eventName: K, listener: TListeners[K]): Off;
}

// @public
export type Listeners<T extends object> = {
    [P in (string | symbol) & keyof T as IsListener<T[P]> extends true ? P : never]: T[P];
};

// @public
export interface MakeNominal {
}

// @public
export type MemberChangedListener<M extends IMember> = (clientId: string, member: M) => void;

// @public
export type Myself<M extends IMember = IMember> = M & {
    readonly currentConnection: string;
};

// @public
export type NodeBuilderData<T extends TreeNodeSchema> = T extends TreeNodeSchema<string, NodeKind, unknown, infer TBuild> ? TBuild : never;

// @public
export type NodeBuilderDataUnsafe<T extends Unenforced<TreeNodeSchema>> = T extends TreeNodeSchema<string, NodeKind, unknown, infer TBuild> ? TBuild : never;

// @public
export type NodeFromSchema<T extends TreeNodeSchema> = T extends TreeNodeSchema<string, NodeKind, infer TNode> ? TNode : never;

// @public
export type NodeFromSchemaUnsafe<T extends Unenforced<TreeNodeSchema>> = T extends TreeNodeSchema<string, NodeKind, infer TNode> ? TNode : never;

// @public
export interface NodeInDocumentConstraint {
    // (undocumented)
    readonly node: TreeNode;
    // (undocumented)
    readonly type: "nodeInDocument";
}

// @public
export enum NodeKind {
    Array = 1,
    Leaf = 3,
    Map = 0,
    Object = 2
}

// @public
export type ObjectFromSchemaRecord<T extends RestrictiveReadonlyRecord<string, ImplicitFieldSchema>> = {
    -readonly [Property in keyof T]: TreeFieldFromImplicitField<T[Property]>;
};

// @public
export type ObjectFromSchemaRecordUnsafe<T extends Unenforced<RestrictiveReadonlyRecord<string, ImplicitFieldSchema>>> = {
    -readonly [Property in keyof T]: TreeFieldFromImplicitFieldUnsafe<T[Property]>;
};

// @public
export type Off = () => void;

// @public
export type RestrictiveReadonlyRecord<K extends symbol | string, T> = {
    readonly [P in symbol | string]: P extends K ? T : never;
};

// @public
export interface Revertible {
    dispose(): void;
    revert(): void;
    revert(dispose: boolean): void;
    readonly status: RevertibleStatus;
}

// @public
export type RevertibleFactory = (onRevertibleDisposed?: (revertible: Revertible) => void) => Revertible;

// @public
export enum RevertibleStatus {
    Disposed = 1,
    Valid = 0
}

// @public
export const rollback: unique symbol;

// @public
export interface RunTransaction {
    <TNode extends TreeNode, TResult>(node: TNode, transaction: (node: TNode) => TResult): TResult;
    <TView extends TreeView<ImplicitFieldSchema>, TResult>(tree: TView, transaction: (root: TView["root"]) => TResult): TResult;
    <TNode extends TreeNode, TResult>(node: TNode, transaction: (node: TNode) => TResult | typeof rollback): TResult | typeof rollback;
    <TView extends TreeView<ImplicitFieldSchema>, TResult>(tree: TView, transaction: (root: TView["root"]) => TResult | typeof rollback): TResult | typeof rollback;
    <TNode extends TreeNode>(node: TNode, transaction: (node: TNode) => void): void;
    <TView extends TreeView<ImplicitFieldSchema>>(tree: TView, transaction: (root: TView["root"]) => void): void;
    <TNode extends TreeNode, TResult>(node: TNode, transaction: (node: TNode) => TResult, preconditions?: readonly TransactionConstraint[]): TResult;
    <TView extends TreeView<ImplicitFieldSchema>, TResult>(tree: TView, transaction: (root: TView["root"]) => TResult, preconditions?: readonly TransactionConstraint[]): TResult;
    <TNode extends TreeNode, TResult>(node: TNode, transaction: (node: TNode) => TResult | typeof rollback, preconditions?: readonly TransactionConstraint[]): TResult | typeof rollback;
    <TView extends TreeView<ImplicitFieldSchema>, TResult>(tree: TView, transaction: (root: TView["root"]) => TResult | typeof rollback, preconditions?: readonly TransactionConstraint[]): TResult | typeof rollback;
    <TNode extends TreeNode>(node: TNode, transaction: (node: TNode) => void, preconditions?: readonly TransactionConstraint[]): void;
    <TView extends TreeView<ImplicitFieldSchema>>(tree: TView, transaction: (root: TView["root"]) => void, preconditions?: readonly TransactionConstraint[]): void;
    readonly rollback: typeof rollback;
}

// @public @sealed
export class SchemaFactory<out TScope extends string | undefined = string | undefined, TName extends number | string = string> {
    constructor(scope: TScope);
    array<const T extends TreeNodeSchema | readonly TreeNodeSchema[]>(allowedTypes: T): TreeNodeSchema<ScopedSchemaName<TScope, `Array<${string}>`>, NodeKind.Array, TreeArrayNode<T> & WithType<ScopedSchemaName<TScope, `Array<${string}>`>>, Iterable<InsertableTreeNodeFromImplicitAllowedTypes<T>>, true, T>;
    array<const Name extends TName, const T extends ImplicitAllowedTypes>(name: Name, allowedTypes: T): TreeNodeSchemaClass<ScopedSchemaName<TScope, Name>, NodeKind.Array, TreeArrayNode<T> & WithType<ScopedSchemaName<TScope, Name>>, Iterable<InsertableTreeNodeFromImplicitAllowedTypes<T>>, true, T>;
    arrayRecursive<const Name extends TName, const T extends Unenforced<ImplicitAllowedTypes>>(name: Name, allowedTypes: T): TreeNodeSchemaClass<ScopedSchemaName<TScope, Name>, NodeKind.Array, TreeArrayNodeUnsafe<T> & WithType<ScopedSchemaName<TScope, Name>>, {
        [Symbol.iterator](): Iterator<InsertableTreeNodeFromImplicitAllowedTypesUnsafe<T>>;
    }, false, T>;
    readonly boolean: TreeNodeSchema<"com.fluidframework.leaf.boolean", NodeKind.Leaf, boolean, boolean>;
    readonly handle: TreeNodeSchema<"com.fluidframework.leaf.handle", NodeKind.Leaf, IFluidHandle<unknown>, IFluidHandle<unknown>>;
    get identifier(): FieldSchema<FieldKind.Identifier, typeof SchemaFactory.string>;
    map<const T extends TreeNodeSchema | readonly TreeNodeSchema[]>(allowedTypes: T): TreeNodeSchema<ScopedSchemaName<TScope, `Map<${string}>`>, NodeKind.Map, TreeMapNode<T> & WithType<ScopedSchemaName<TScope, `Map<${string}>`>>, Iterable<[string, InsertableTreeNodeFromImplicitAllowedTypes<T>]>, true, T>;
    map<Name extends TName, const T extends ImplicitAllowedTypes>(name: Name, allowedTypes: T): TreeNodeSchemaClass<ScopedSchemaName<TScope, Name>, NodeKind.Map, TreeMapNode<T> & WithType<ScopedSchemaName<TScope, Name>>, Iterable<[string, InsertableTreeNodeFromImplicitAllowedTypes<T>]>, true, T>;
    mapRecursive<Name extends TName, const T extends Unenforced<ImplicitAllowedTypes>>(name: Name, allowedTypes: T): TreeNodeSchemaClass<ScopedSchemaName<TScope, Name>, NodeKind.Map, TreeMapNodeUnsafe<T> & WithType<ScopedSchemaName<TScope, Name>>, {
        [Symbol.iterator](): Iterator<[
        string,
        InsertableTreeNodeFromImplicitAllowedTypesUnsafe<T>
        ]>;
    }, false, T>;
    readonly null: TreeNodeSchema<"com.fluidframework.leaf.null", NodeKind.Leaf, null, null>;
    readonly number: TreeNodeSchema<"com.fluidframework.leaf.number", NodeKind.Leaf, number, number>;
    object<const Name extends TName, const T extends RestrictiveReadonlyRecord<string, ImplicitFieldSchema>>(name: Name, fields: T): TreeNodeSchemaClass<ScopedSchemaName<TScope, Name>, NodeKind.Object, TreeObjectNode<T, ScopedSchemaName<TScope, Name>>, object & InsertableObjectFromSchemaRecord<T>, true, T>;
    objectRecursive<const Name extends TName, const T extends Unenforced<RestrictiveReadonlyRecord<string, ImplicitFieldSchema>>>(name: Name, t: T): TreeNodeSchemaClass<ScopedSchemaName<TScope, Name>, NodeKind.Object, TreeObjectNodeUnsafe<T, ScopedSchemaName<TScope, Name>>, object & InsertableObjectFromSchemaRecordUnsafe<T>, false, T>;
    optional<const T extends ImplicitAllowedTypes>(t: T, props?: Omit<FieldProps, "defaultProvider">): FieldSchema<FieldKind.Optional, T>;
    optionalRecursive<const T extends Unenforced<ImplicitAllowedTypes>>(t: T, props?: Omit<FieldProps, "defaultProvider">): FieldSchemaUnsafe<FieldKind.Optional, T>;
    required<const T extends ImplicitAllowedTypes>(t: T, props?: Omit<FieldProps, "defaultProvider">): FieldSchema<FieldKind.Required, T>;
    requiredRecursive<const T extends Unenforced<ImplicitAllowedTypes>>(t: T, props?: Omit<FieldProps, "defaultProvider">): FieldSchemaUnsafe<FieldKind.Required, T>;
    // (undocumented)
    readonly scope: TScope;
    readonly string: TreeNodeSchema<"com.fluidframework.leaf.string", NodeKind.Leaf, string, string>;
}

// @public
export interface SchemaIncompatible {
    readonly canUpgrade: boolean;
}

// @public
export type ScopedSchemaName<TScope extends string | undefined, TName extends number | string> = TScope extends undefined ? `${TName}` : `${TScope}.${TName}`;

// @alpha
export class SequenceDeltaEvent extends SequenceEvent<MergeTreeDeltaOperationType> {
    constructor(opArgs: IMergeTreeDeltaOpArgs, deltaArgs: IMergeTreeDeltaCallbackArgs, mergeTreeClient: Client);
    readonly isLocal: boolean;
    // (undocumented)
    readonly opArgs: IMergeTreeDeltaOpArgs;
}

// @alpha
export abstract class SequenceEvent<TOperation extends MergeTreeDeltaOperationTypes = MergeTreeDeltaOperationTypes> {
    constructor(
    deltaArgs: IMergeTreeDeltaCallbackArgs<TOperation>, mergeTreeClient: Client);
    get clientId(): string | undefined;
    readonly deltaArgs: IMergeTreeDeltaCallbackArgs<TOperation>;
    // (undocumented)
    readonly deltaOperation: TOperation;
    get first(): Readonly<ISequenceDeltaRange<TOperation>>;
    get last(): Readonly<ISequenceDeltaRange<TOperation>>;
    get ranges(): readonly Readonly<ISequenceDeltaRange<TOperation>>[];
}

// @alpha
export class SequenceInterval implements ISerializableInterval {
    constructor(client: Client,
    start: LocalReferencePosition,
    end: LocalReferencePosition, intervalType: IntervalType, props?: PropertySet, startSide?: Side, endSide?: Side);
    addPositionChangeListeners(beforePositionChange: () => void, afterPositionChange: () => void): void;
    // (undocumented)
    addProperties(newProps: PropertySet, collab?: boolean, seq?: number): PropertySet | undefined;
    // (undocumented)
    clone(): SequenceInterval;
    compare(b: SequenceInterval): number;
    compareEnd(b: SequenceInterval): number;
    compareStart(b: SequenceInterval): number;
    end: LocalReferencePosition;
    // (undocumented)
    readonly endSide: Side;
    getIntervalId(): string;
    // (undocumented)
    intervalType: IntervalType;
    modify(label: string, start: SequencePlace | undefined, end: SequencePlace | undefined, op?: ISequencedDocumentMessage, localSeq?: number, useNewSlidingBehavior?: boolean): SequenceInterval;
    // (undocumented)
    overlaps(b: SequenceInterval): boolean;
    // (undocumented)
    overlapsPos(bstart: number, bend: number): boolean;
    properties: PropertySet;
    // (undocumented)
    propertyManager: PropertiesManager;
    removePositionChangeListeners(): void;
    // (undocumented)
    serialize(): ISerializedInterval;
    start: LocalReferencePosition;
    // (undocumented)
    readonly startSide: Side;
    // (undocumented)
    get stickiness(): IntervalStickiness;
    union(b: SequenceInterval): SequenceInterval;
}

// @alpha
export class SequenceMaintenanceEvent extends SequenceEvent<MergeTreeMaintenanceType> {
    constructor(
    opArgs: IMergeTreeDeltaOpArgs | undefined, deltaArgs: IMergeTreeMaintenanceCallbackArgs, mergeTreeClient: Client);
    readonly opArgs: IMergeTreeDeltaOpArgs | undefined;
}

// @alpha
export type SequencePlace = number | "start" | "end" | InteriorSequencePlace;

// @alpha
export const SharedDirectory: ISharedObjectKind<ISharedDirectory> & SharedObjectKind_2<ISharedDirectory>;

// @alpha @deprecated
export type SharedDirectory = ISharedDirectory;

// @alpha
export const SharedMap: ISharedObjectKind<ISharedMap> & SharedObjectKind_2<ISharedMap>;

// @alpha
export type SharedMap = ISharedMap;

// @public
export interface SharedObjectKind<out TSharedObject = unknown> extends ErasedType<readonly ["SharedObjectKind", TSharedObject]> {
}

// @alpha
export const SharedString: ISharedObjectKind<ISharedString> & SharedObjectKind_2<ISharedString>;

// @alpha
export type SharedString = ISharedString;

// @alpha (undocumented)
export type SharedStringSegment = TextSegment | Marker;

// @public
export const SharedTree: SharedObjectKind<ITree>;

// @alpha
export enum Side {
    // (undocumented)
    After = 1,
    // (undocumented)
    Before = 0
}

// @public
export type TransactionConstraint = NodeInDocumentConstraint;

// @public
export const Tree: TreeApi;

// @public
export interface TreeApi extends TreeNodeApi {
    contains(node: TreeNode, other: TreeNode): boolean;
    readonly runTransaction: RunTransaction;
}

// @public
export interface TreeArrayNode<TAllowedTypes extends ImplicitAllowedTypes = ImplicitAllowedTypes> extends TreeArrayNodeBase<TreeNodeFromImplicitAllowedTypes<TAllowedTypes>, InsertableTreeNodeFromImplicitAllowedTypes<TAllowedTypes>, TreeArrayNode> {
}

// @public
export const TreeArrayNode: {
    spread: <T>(content: Iterable<T>) => IterableTreeArrayContent<T>;
};

// @public
export interface TreeArrayNodeBase<out T, in TNew, in TMoveFrom> extends ReadonlyArray<T>, TreeNode {
    insertAt(index: number, ...value: readonly (TNew | IterableTreeArrayContent<TNew>)[]): void;
    insertAtEnd(...value: readonly (TNew | IterableTreeArrayContent<TNew>)[]): void;
    insertAtStart(...value: readonly (TNew | IterableTreeArrayContent<TNew>)[]): void;
    moveRangeToEnd(sourceStart: number, sourceEnd: number): void;
    moveRangeToEnd(sourceStart: number, sourceEnd: number, source: TMoveFrom): void;
    moveRangeToIndex(index: number, sourceStart: number, sourceEnd: number): void;
    moveRangeToIndex(index: number, sourceStart: number, sourceEnd: number, source: TMoveFrom): void;
    moveRangeToStart(sourceStart: number, sourceEnd: number): void;
    moveRangeToStart(sourceStart: number, sourceEnd: number, source: TMoveFrom): void;
    moveToEnd(sourceIndex: number): void;
    moveToEnd(sourceIndex: number, source: TMoveFrom): void;
    moveToIndex(index: number, sourceIndex: number): void;
    moveToIndex(index: number, sourceIndex: number, source: TMoveFrom): void;
    moveToStart(sourceIndex: number): void;
    moveToStart(sourceIndex: number, source: TMoveFrom): void;
    removeAt(index: number): void;
    removeRange(start?: number, end?: number): void;
}

// @public
export interface TreeArrayNodeUnsafe<TAllowedTypes extends Unenforced<ImplicitAllowedTypes>> extends TreeArrayNodeBase<TreeNodeFromImplicitAllowedTypesUnsafe<TAllowedTypes>, InsertableTreeNodeFromImplicitAllowedTypesUnsafe<TAllowedTypes>, TreeArrayNode> {
}

// @public
export interface TreeChangeEvents {
    nodeChanged(): void;
    treeChanged(): void;
}

// @public
export class TreeConfiguration<TSchema extends ImplicitFieldSchema = ImplicitFieldSchema> {
    constructor(schema: TSchema, initialTree: () => InsertableTreeFieldFromImplicitField<TSchema>, options?: ITreeConfigurationOptions);
    // (undocumented)
    readonly initialTree: () => InsertableTreeFieldFromImplicitField<TSchema>;
    readonly options: Required<ITreeConfigurationOptions>;
    // (undocumented)
    readonly schema: TSchema;
}

// @public
export type TreeFieldFromImplicitField<TSchema extends ImplicitFieldSchema = FieldSchema> = TSchema extends FieldSchema<infer Kind, infer Types> ? ApplyKind<TreeNodeFromImplicitAllowedTypes<Types>, Kind, false> : TSchema extends ImplicitAllowedTypes ? TreeNodeFromImplicitAllowedTypes<TSchema> : unknown;

// @public
export type TreeFieldFromImplicitFieldUnsafe<TSchema extends Unenforced<ImplicitFieldSchema>> = TSchema extends FieldSchemaUnsafe<infer Kind, infer Types> ? ApplyKind<TreeNodeFromImplicitAllowedTypesUnsafe<Types>, Kind, false> : TSchema extends ImplicitAllowedTypes ? TreeNodeFromImplicitAllowedTypesUnsafe<TSchema> : unknown;

// @public
export type TreeLeafValue = number | string | boolean | IFluidHandle | null;

// @public
export interface TreeMapNode<T extends ImplicitAllowedTypes = ImplicitAllowedTypes> extends ReadonlyMap<string, TreeNodeFromImplicitAllowedTypes<T>>, TreeNode {
    delete(key: string): void;
    entries(): IterableIterator<[string, TreeNodeFromImplicitAllowedTypes<T>]>;
    forEach(callbackfn: (value: TreeNodeFromImplicitAllowedTypes<T>, key: string, map: ReadonlyMap<string, TreeNodeFromImplicitAllowedTypes<T>>) => void, thisArg?: any): void;
    keys(): IterableIterator<string>;
    set(key: string, value: InsertableTreeNodeFromImplicitAllowedTypes<T> | undefined): void;
    values(): IterableIterator<TreeNodeFromImplicitAllowedTypes<T>>;
}

// @public
export interface TreeMapNodeUnsafe<T extends Unenforced<ImplicitAllowedTypes>> extends ReadonlyMap<string, TreeNodeFromImplicitAllowedTypesUnsafe<T>>, TreeNode {
    delete(key: string): void;
    set(key: string, value: InsertableTreeNodeFromImplicitAllowedTypesUnsafe<T> | undefined): void;
}

// @public
export abstract class TreeNode implements WithType {
    abstract get [type](): string;
    protected constructor();
}

// @public
export interface TreeNodeApi {
    is<TSchema extends ImplicitAllowedTypes>(value: unknown, schema: TSchema): value is TreeNodeFromImplicitAllowedTypes<TSchema>;
    key(node: TreeNode): string | number;
    on<K extends keyof TreeChangeEvents>(node: TreeNode, eventName: K, listener: TreeChangeEvents[K]): () => void;
    parent(node: TreeNode): TreeNode | undefined;
    schema<T extends TreeNode | TreeLeafValue>(node: T): TreeNodeSchema<string, NodeKind, unknown, T>;
    shortId(node: TreeNode): number | string | undefined;
    readonly status: (node: TreeNode) => TreeStatus;
}

// @public
export type TreeNodeFromImplicitAllowedTypes<TSchema extends ImplicitAllowedTypes = TreeNodeSchema> = TSchema extends TreeNodeSchema ? NodeFromSchema<TSchema> : TSchema extends AllowedTypes ? NodeFromSchema<FlexListToUnion<TSchema>> : unknown;

// @public
export type TreeNodeFromImplicitAllowedTypesUnsafe<TSchema extends Unenforced<ImplicitAllowedTypes>> = TSchema extends ImplicitAllowedTypes ? TreeNodeFromImplicitAllowedTypes<TSchema> : TSchema extends TreeNodeSchema ? NodeFromSchema<TSchema> : TSchema extends AllowedTypes ? NodeFromSchema<FlexListToUnion<TSchema>> : unknown;

// @public
export type TreeNodeSchema<Name extends string = string, Kind extends NodeKind = NodeKind, TNode = unknown, TBuild = never, ImplicitlyConstructable extends boolean = boolean, Info = unknown> = TreeNodeSchemaClass<Name, Kind, TNode, TBuild, ImplicitlyConstructable, Info> | TreeNodeSchemaNonClass<Name, Kind, TNode, TBuild, ImplicitlyConstructable, Info>;

// @public
export interface TreeNodeSchemaClass<out Name extends string = string, out Kind extends NodeKind = NodeKind, out TNode = unknown, in TInsertable = never, out ImplicitlyConstructable extends boolean = boolean, out Info = unknown> extends TreeNodeSchemaCore<Name, Kind, ImplicitlyConstructable, Info> {
    // @sealed
    new (data: TInsertable | InternalTreeNode): Unhydrated<TNode>;
}

// @public
export interface TreeNodeSchemaCore<out Name extends string, out Kind extends NodeKind, out ImplicitlyConstructable extends boolean, out Info = unknown> {
    // (undocumented)
    readonly identifier: Name;
    readonly implicitlyConstructable: ImplicitlyConstructable;
    readonly info: Info;
    // (undocumented)
    readonly kind: Kind;
}

// @public
export interface TreeNodeSchemaNonClass<out Name extends string = string, out Kind extends NodeKind = NodeKind, out TNode = unknown, in TInsertable = never, out ImplicitlyConstructable extends boolean = boolean, out Info = unknown> extends TreeNodeSchemaCore<Name, Kind, ImplicitlyConstructable, Info> {
    // (undocumented)
    create(data: TInsertable): TNode;
}

// @public
export type TreeObjectNode<T extends RestrictiveReadonlyRecord<string, ImplicitFieldSchema>, TypeName extends string = string> = TreeNode & ObjectFromSchemaRecord<T> & WithType<TypeName>;

// @public
export type TreeObjectNodeUnsafe<T extends Unenforced<RestrictiveReadonlyRecord<string, ImplicitFieldSchema>>, TypeName extends string = string> = TreeNode & ObjectFromSchemaRecordUnsafe<T> & WithType<TypeName>;

// @public
export enum TreeStatus {
    Deleted = 2,
    InDocument = 0,
    New = 3,
    Removed = 1
}

// @public
export interface TreeView<TSchema extends ImplicitFieldSchema> extends IDisposable {
    readonly error?: SchemaIncompatible;
    readonly events: Listenable<TreeViewEvents>;
    get root(): TreeFieldFromImplicitField<TSchema>;
    set root(newRoot: InsertableTreeFieldFromImplicitField<TSchema>);
    upgradeSchema(): void;
}

// @public
export interface TreeViewEvents {
    afterBatch(): void;
    commitApplied(data: CommitMetadata, getRevertible?: RevertibleFactory): void;
    rootChanged(): void;
}

// @public
export const type: unique symbol;

// @public
export type Unenforced<_DesiredExtendsConstraint> = unknown;

// @public
export type Unhydrated<T> = T;

// @public
export type ValidateRecursiveSchema<T extends TreeNodeSchemaClass<string, NodeKind.Array | NodeKind.Map | NodeKind.Object, TreeNode & WithType<T["identifier"]>, {
    [NodeKind.Object]: T["info"] extends RestrictiveReadonlyRecord<string, ImplicitFieldSchema> ? InsertableObjectFromSchemaRecord<T["info"]> : unknown;
    [NodeKind.Array]: T["info"] extends ImplicitAllowedTypes ? Iterable<InsertableTreeNodeFromImplicitAllowedTypes<T["info"]>> : unknown;
    [NodeKind.Map]: T["info"] extends ImplicitAllowedTypes ? Iterable<[string, InsertableTreeNodeFromImplicitAllowedTypes<T["info"]>]> : unknown;
}[T["kind"]], false, {
    [NodeKind.Object]: RestrictiveReadonlyRecord<string, ImplicitFieldSchema>;
    [NodeKind.Array]: ImplicitAllowedTypes;
    [NodeKind.Map]: ImplicitAllowedTypes;
}[T["kind"]]>> = true;

// @public
export interface WithType<TName extends string = string> {
    get [type](): TName;
}

```
