## API Report File for "fluid-framework"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { FluidObject } from '@fluidframework/core-interfaces';
import { IChannel } from '@fluidframework/datastore-definitions';
import { IChannelAttributes } from '@fluidframework/datastore-definitions';
import { IChannelFactory } from '@fluidframework/datastore-definitions';
import { IChannelServices } from '@fluidframework/datastore-definitions';
import { IChannelStorageService } from '@fluidframework/datastore-definitions';
import { IErrorBase } from '@fluidframework/core-interfaces';
import { IEvent } from '@fluidframework/core-interfaces';
import { IEventProvider } from '@fluidframework/core-interfaces';
import { IEventThisPlaceHolder } from '@fluidframework/core-interfaces';
import { IExperimentalIncrementalSummaryContext } from '@fluidframework/runtime-definitions';
import { IFluidDataStoreRuntime } from '@fluidframework/datastore-definitions';
import { IFluidHandle } from '@fluidframework/core-interfaces';
import { IFluidLoadable } from '@fluidframework/core-interfaces';
import { IFluidSerializer } from '@fluidframework/shared-object-base';
import { IGarbageCollectionData } from '@fluidframework/runtime-definitions';
import { ISequencedDocumentMessage } from '@fluidframework/protocol-definitions';
import { ISharedObject } from '@fluidframework/shared-object-base';
import { ISharedObjectEvents } from '@fluidframework/shared-object-base';
import { ISummaryTreeWithStats } from '@fluidframework/runtime-definitions';
import { ITelemetryContext } from '@fluidframework/runtime-definitions';
import { SharedObject } from '@fluidframework/shared-object-base';

// @public
export type AllowedTypes = readonly LazyItem<TreeNodeSchema>[];

// @public
export type ApplyKind<T, Kind extends FieldKind> = Kind extends FieldKind.Required ? T : undefined | T;

// @public
export type ArrayToUnion<T extends readonly unknown[]> = T extends readonly (infer TValue)[] ? TValue : never;

// @public
export enum AttachState {
    Attached = "Attached",
    Attaching = "Attaching",
    Detached = "Detached"
}

// @public (undocumented)
export enum ConnectionState {
    CatchingUp = 1,
    Connected = 2,
    Disconnected = 0,
    EstablishingConnection = 3
}

// @public
export namespace ConnectionStateType {
    export type CatchingUp = 1;
    export type Connected = 2;
    export type Disconnected = 0;
    export type EstablishingConnection = 3;
}

// @public
export type ConnectionStateType = ConnectionStateType.Disconnected | ConnectionStateType.EstablishingConnection | ConnectionStateType.CatchingUp | ConnectionStateType.Connected;

// @alpha
export const ContainerErrorTypes: {
    readonly clientSessionExpiredError: "clientSessionExpiredError";
    readonly genericError: "genericError";
    readonly throttlingError: "throttlingError";
    readonly dataCorruptionError: "dataCorruptionError";
    readonly dataProcessingError: "dataProcessingError";
    readonly usageError: "usageError";
};

// @alpha (undocumented)
export type ContainerErrorTypes = (typeof ContainerErrorTypes)[keyof typeof ContainerErrorTypes];

// @public
export interface ContainerSchema {
    dynamicObjectTypes?: LoadableObjectClass<any>[];
    initialObjects: LoadableObjectClassRecord;
}

// @public
export type DataObjectClass<T extends IFluidLoadable> = {
    readonly factory: {
        IFluidDataStoreFactory: DataObjectClass<T>["factory"];
    };
} & LoadableObjectCtor<T>;

// @public
export const disposeSymbol: unique symbol;

// @public
export const DriverErrorTypes: {
    readonly genericNetworkError: "genericNetworkError";
    readonly authorizationError: "authorizationError";
    readonly fileNotFoundOrAccessDeniedError: "fileNotFoundOrAccessDeniedError";
    readonly offlineError: "offlineError";
    readonly unsupportedClientProtocolVersion: "unsupportedClientProtocolVersion";
    readonly writeError: "writeError";
    readonly fetchFailure: "fetchFailure";
    readonly fetchTokenError: "fetchTokenError";
    readonly incorrectServerResponse: "incorrectServerResponse";
    readonly fileOverwrittenInStorage: "fileOverwrittenInStorage";
    readonly deltaStreamConnectionForbidden: "deltaStreamConnectionForbidden";
    readonly locationRedirection: "locationRedirection";
    readonly fluidInvalidSchema: "fluidInvalidSchema";
    readonly fileIsLocked: "fileIsLocked";
    readonly outOfStorageError: "outOfStorageError";
    readonly genericError: "genericError";
    readonly throttlingError: "throttlingError";
    readonly usageError: "usageError";
};

// @public (undocumented)
export type DriverErrorTypes = (typeof DriverErrorTypes)[keyof typeof DriverErrorTypes];

// @public
export type Events<E> = {
    [P in (string | symbol) & keyof E as IsEvent<E[P]> extends true ? P : never]: E[P];
};

// @public
export type ExtractItemType<Item extends LazyItem> = Item extends () => infer Result ? Result : Item;

// @public
export enum FieldKind {
    Optional = 0,
    Required = 1
}

// @public @sealed
export class FieldSchema<out Kind extends FieldKind = FieldKind, out Types extends ImplicitAllowedTypes = ImplicitAllowedTypes> {
    constructor(kind: Kind, allowedTypes: Types);
    // (undocumented)
    readonly allowedTypes: Types;
    // (undocumented)
    readonly kind: Kind;
    protected _typeCheck?: MakeNominal;
}

// @public
export type FlexList<Item = unknown> = readonly LazyItem<Item>[];

// @public
export type FlexListToUnion<TList extends FlexList> = ExtractItemType<ArrayToUnion<TList>>;

// @public
export interface IConnection {
    id: string;
    mode: "write" | "read";
}

// @public
export type ICriticalContainerError = IErrorBase;

// @public
export interface IDisposable {
    [disposeSymbol](): void;
}

// @public @sealed
export interface IFluidContainer<TContainerSchema extends ContainerSchema = ContainerSchema> extends IEventProvider<IFluidContainerEvents> {
    attach(): Promise<string>;
    readonly attachState: AttachState;
    connect(): void;
    readonly connectionState: ConnectionStateType;
    create<T extends IFluidLoadable>(objectClass: LoadableObjectClass<T>): Promise<T>;
    disconnect(): void;
    dispose(): void;
    readonly disposed: boolean;
    readonly initialObjects: InitialObjects<TContainerSchema>;
    readonly isDirty: boolean;
}

// @public @sealed
export interface IFluidContainerEvents extends IEvent {
    (event: "connected", listener: () => void): void;
    (event: "disconnected", listener: () => void): void;
    (event: "saved", listener: () => void): void;
    (event: "dirty", listener: () => void): void;
    (event: "disposed", listener: (error?: ICriticalContainerError) => void): any;
}

// @public
export interface IMember {
    connections: IConnection[];
    userId: string;
}

// @public
export type ImplicitAllowedTypes = AllowedTypes | TreeNodeSchema;

// @public
export type ImplicitFieldSchema = FieldSchema | ImplicitAllowedTypes;

// @public
export type InitialObjects<T extends ContainerSchema> = {
    [K in keyof T["initialObjects"]]: T["initialObjects"][K] extends LoadableObjectClass<infer TChannel> ? TChannel : never;
};

// @public
export type InsertableObjectFromSchemaRecord<T extends RestrictiveReadonlyRecord<string, ImplicitFieldSchema>> = {
    readonly [Property in keyof T]: InsertableTreeFieldFromImplicitField<T[Property]>;
};

// @public
export type InsertableTreeFieldFromImplicitField<TSchema extends ImplicitFieldSchema = FieldSchema> = TSchema extends FieldSchema<infer Kind, infer Types> ? ApplyKind<InsertableTreeNodeFromImplicitAllowedTypes<Types>, Kind> : TSchema extends ImplicitAllowedTypes ? InsertableTreeNodeFromImplicitAllowedTypes<TSchema> : unknown;

// @public
export type InsertableTreeNodeFromImplicitAllowedTypes<TSchema extends ImplicitAllowedTypes = TreeNodeSchema> = TSchema extends TreeNodeSchema ? InsertableTypedNode<TSchema> : TSchema extends AllowedTypes ? InsertableTypedNode<FlexListToUnion<TSchema>> : never;

// @public
export type InsertableTypedNode<T extends TreeNodeSchema> = (T extends {
    implicitlyConstructable: true;
} ? NodeBuilderData<T> : never) | Unhydrated<NodeFromSchema<T>>;

// @public
export interface IServiceAudience<M extends IMember> extends IEventProvider<IServiceAudienceEvents<M>> {
    getMembers(): Map<string, M>;
    getMyself(): Myself<M> | undefined;
}

// @public
export interface IServiceAudienceEvents<M extends IMember> extends IEvent {
    // @eventProperty
    (event: "membersChanged", listener: () => void): void;
    // @eventProperty
    (event: "memberAdded", listener: MemberChangedListener<M>): void;
    // @eventProperty
    (event: "memberRemoved", listener: MemberChangedListener<M>): void;
}

// @public
export type IsEvent<Event> = Event extends (...args: any[]) => any ? true : false;

// @public @sealed
export interface ISharedMap extends ISharedObject<ISharedMapEvents>, Map<string, any> {
    get<T = any>(key: string): T | undefined;
    set<T = unknown>(key: string, value: T): this;
}

// @public @sealed
export interface ISharedMapEvents extends ISharedObjectEvents {
    (event: "valueChanged", listener: (changed: IValueChanged, local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "clear", listener: (local: boolean, target: IEventThisPlaceHolder) => void): any;
}

// @public
export interface ISubscribable<E extends Events<E>> {
    on<K extends keyof Events<E>>(eventName: K, listener: E[K]): () => void;
}

// @public
export class IterableTreeArrayContent<T> implements Iterable<T> {
    [Symbol.iterator](): Iterator<T>;
}

// @public
export interface ITree extends IChannel {
    schematize<TRoot extends ImplicitFieldSchema>(config: TreeConfiguration<TRoot>): TreeView<TreeFieldFromImplicitField<TRoot>>;
}

// @public @sealed
export interface IValueChanged {
    key: string;
    previousValue: any;
}

// @public
export type LazyItem<Item = unknown> = Item | (() => Item);

// @public
export type LoadableObjectClass<T extends IFluidLoadable> = DataObjectClass<T> | SharedObjectClass<T>;

// @public
export type LoadableObjectClassRecord = Record<string, LoadableObjectClass<any>>;

// @public
export type LoadableObjectCtor<T extends IFluidLoadable> = new (...args: any[]) => T;

// @public
export interface MakeNominal {
}

// @public
export type MemberChangedListener<M extends IMember> = (clientId: string, member: M) => void;

// @public
export type Myself<M extends IMember = IMember> = M & {
    currentConnection: string;
};

// @public
export type NodeBuilderData<T extends TreeNodeSchema> = T extends TreeNodeSchema<string, NodeKind, unknown, infer TBuild> ? TBuild : never;

// @public
export type NodeFromSchema<T extends TreeNodeSchema> = T extends TreeNodeSchema<string, NodeKind, infer TNode> ? TNode : never;

// @public
export enum NodeKind {
    Array = 1,
    Leaf = 3,
    Map = 0,
    Object = 2
}

// @public
export type ObjectFromSchemaRecord<T extends RestrictiveReadonlyRecord<string, ImplicitFieldSchema>> = {
    -readonly [Property in keyof T]: TreeFieldFromImplicitField<T[Property]>;
};

// @public
export type RestrictiveReadonlyRecord<K extends symbol | string, T> = {
    readonly [P in symbol | string]: P extends K ? T : never;
};

// @public @sealed
export class SchemaFactory<TScope extends string = string, TName extends number | string = string> {
    constructor(scope: TScope);
    array<const T extends TreeNodeSchema | readonly TreeNodeSchema[]>(allowedTypes: T): TreeNodeSchema<`${TScope}.Array<${string}>`, NodeKind.Array, TreeArrayNode<T> & WithType<`${TScope}.Array<${string}>`>, Iterable<InsertableTreeNodeFromImplicitAllowedTypes<T>>, true>;
    array<const Name extends TName, const T extends ImplicitAllowedTypes>(name: Name, allowedTypes: T): TreeNodeSchemaClass<`${TScope}.${Name}`, NodeKind.Array, TreeArrayNode<T> & WithType<`${TScope}.${Name}`>, Iterable<InsertableTreeNodeFromImplicitAllowedTypes<T>>, true>;
    readonly boolean: TreeNodeSchema<"com.fluidframework.leaf.boolean", NodeKind.Leaf, boolean, boolean>;
    fixRecursiveReference<T extends AllowedTypes>(...types: T): void;
    readonly handle: TreeNodeSchema<"com.fluidframework.leaf.handle", NodeKind.Leaf, IFluidHandle<FluidObject & IFluidLoadable>, IFluidHandle<FluidObject & IFluidLoadable>>;
    map<const T extends TreeNodeSchema | readonly TreeNodeSchema[]>(allowedTypes: T): TreeNodeSchema<`${TScope}.Map<${string}>`, NodeKind.Map, TreeMapNode<T> & WithType<`${TScope}.Map<${string}>`>, ReadonlyMap<string, TreeNodeFromImplicitAllowedTypes<T>>, true>;
    map<Name extends TName, const T extends ImplicitAllowedTypes>(name: Name, allowedTypes: T): TreeNodeSchemaClass<`${TScope}.${Name}`, NodeKind.Map, TreeMapNode<T> & WithType<`${TScope}.${Name}`>, ReadonlyMap<string, InsertableTreeNodeFromImplicitAllowedTypes<T>>, true>;
    namedArray_internal<Name extends TName | string, const T extends ImplicitAllowedTypes, const ImplicitlyConstructable extends boolean>(name: Name, allowedTypes: T, customizable: boolean, implicitlyConstructable: ImplicitlyConstructable): TreeNodeSchemaClass<`${TScope}.${Name}`, NodeKind.Array, TreeArrayNode<T> & WithType<`${TScope}.${string}`>, Iterable<InsertableTreeNodeFromImplicitAllowedTypes<T>>, ImplicitlyConstructable>;
    namedMap_internal<Name extends TName | string, const T extends ImplicitAllowedTypes, const ImplicitlyConstructable extends boolean>(name: Name, allowedTypes: T, customizable: boolean, implicitlyConstructable: ImplicitlyConstructable): TreeNodeSchemaClass<`${TScope}.${Name}`, NodeKind.Map, TreeMapNode<T> & WithType<`${TScope}.${Name}`>, ReadonlyMap<string, InsertableTreeNodeFromImplicitAllowedTypes<T>>, ImplicitlyConstructable>;
    readonly null: TreeNodeSchema<"com.fluidframework.leaf.null", NodeKind.Leaf, null, null>;
    readonly number: TreeNodeSchema<"com.fluidframework.leaf.number", NodeKind.Leaf, number, number>;
    object<const Name extends TName, const T extends RestrictiveReadonlyRecord<string, ImplicitFieldSchema>>(name: Name, t: T): TreeNodeSchemaClass<`${TScope}.${Name}`, NodeKind.Object, object & TreeNode & ObjectFromSchemaRecord<T> & WithType<`${TScope}.${Name}`>, object & InsertableObjectFromSchemaRecord<T>, true>;
    optional<const T extends ImplicitAllowedTypes>(t: T): FieldSchema<FieldKind.Optional, T>;
    // (undocumented)
    readonly scope: TScope;
    readonly string: TreeNodeSchema<"com.fluidframework.leaf.string", NodeKind.Leaf, string, string>;
}

// @public @deprecated
export class SharedMap extends SharedObject<ISharedMapEvents> implements ISharedMap {
    [Symbol.iterator](): IterableIterator<[string, any]>;
    readonly [Symbol.toStringTag]: string;
    constructor(id: string, runtime: IFluidDataStoreRuntime, attributes: IChannelAttributes);
    // (undocumented)
    protected applyStashedOp(content: unknown): unknown;
    clear(): void;
    static create(runtime: IFluidDataStoreRuntime, id?: string): SharedMap;
    delete(key: string): boolean;
    entries(): IterableIterator<[string, any]>;
    forEach(callbackFn: (value: any, key: string, map: Map<string, any>) => void): void;
    get<T = any>(key: string): T | undefined;
    static getFactory(): IChannelFactory;
    has(key: string): boolean;
    keys(): IterableIterator<string>;
    // (undocumented)
    protected loadCore(storage: IChannelStorageService): Promise<void>;
    // (undocumented)
    protected onDisconnect(): void;
    // (undocumented)
    protected processCore(message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown): void;
    // (undocumented)
    protected reSubmitCore(content: unknown, localOpMetadata: unknown): void;
    // (undocumented)
    protected rollback(content: unknown, localOpMetadata: unknown): void;
    set(key: string, value: unknown): this;
    get size(): number;
    // (undocumented)
    protected summarizeCore(serializer: IFluidSerializer, telemetryContext?: ITelemetryContext): ISummaryTreeWithStats;
    values(): IterableIterator<any>;
}

// @public
export type SharedObjectClass<T extends IFluidLoadable> = {
    readonly getFactory: () => IChannelFactory;
} & LoadableObjectCtor<T>;

// @public
export class SharedTree implements ITree {
    // (undocumented)
    get attributes(): IChannelAttributes;
    // (undocumented)
    connect(services: IChannelServices): void;
    // (undocumented)
    getAttachSummary(fullTree?: boolean | undefined, trackState?: boolean | undefined, telemetryContext?: ITelemetryContext | undefined): ISummaryTreeWithStats;
    // (undocumented)
    static getFactory(): IChannelFactory;
    // (undocumented)
    getGCData(fullGC?: boolean | undefined): IGarbageCollectionData;
    // (undocumented)
    get handle(): IFluidHandle;
    // (undocumented)
    get id(): string;
    // (undocumented)
    get IFluidLoadable(): IFluidLoadable;
    // (undocumented)
    isAttached(): boolean;
    // (undocumented)
    schematize<TRoot extends ImplicitFieldSchema>(config: TreeConfiguration<TRoot>): TreeView<TreeFieldFromImplicitField<TRoot>>;
    // (undocumented)
    summarize(fullTree?: boolean | undefined, trackState?: boolean | undefined, telemetryContext?: ITelemetryContext | undefined, incrementalSummaryContext?: IExperimentalIncrementalSummaryContext | undefined): Promise<ISummaryTreeWithStats>;
}

// @public
export const Tree: TreeApi;

// @public
export interface TreeApi {
    is<TSchema extends TreeNodeSchema>(value: unknown, schema: TSchema): value is NodeFromSchema<TSchema>;
    key(node: TreeNode): string | number;
    on<K extends keyof TreeNodeEvents>(node: TreeNode, eventName: K, listener: TreeNodeEvents[K]): () => void;
    parent(node: TreeNode): TreeNode | undefined;
    schema<T extends TreeNode | TreeLeafValue>(node: T): TreeNodeSchema<string, NodeKind, unknown, T>;
    readonly status: (node: TreeNode) => TreeStatus;
}

// @public
export interface TreeArrayNode<TAllowedTypes extends ImplicitAllowedTypes = ImplicitAllowedTypes> extends TreeNode, TreeArrayNodeBase<TreeNodeFromImplicitAllowedTypes<TAllowedTypes>, InsertableTreeNodeFromImplicitAllowedTypes<TAllowedTypes>, TreeArrayNode> {
}

// @public
export const TreeArrayNode: {
    spread: <T>(content: Iterable<T>) => IterableTreeArrayContent<T>;
};

// @public
export interface TreeArrayNodeBase<out T, in TNew, in TMoveFrom> extends ReadonlyArray<T>, TreeNode {
    insertAt(index: number, ...value: (TNew | IterableTreeArrayContent<TNew>)[]): void;
    insertAtEnd(...value: (TNew | IterableTreeArrayContent<TNew>)[]): void;
    insertAtStart(...value: (TNew | IterableTreeArrayContent<TNew>)[]): void;
    moveRangeToEnd(sourceStart: number, sourceEnd: number): void;
    moveRangeToEnd(sourceStart: number, sourceEnd: number, source: TMoveFrom): void;
    moveRangeToIndex(index: number, sourceStart: number, sourceEnd: number): void;
    moveRangeToIndex(index: number, sourceStart: number, sourceEnd: number, source: TMoveFrom): void;
    moveRangeToStart(sourceStart: number, sourceEnd: number): void;
    moveRangeToStart(sourceStart: number, sourceEnd: number, source: TMoveFrom): void;
    moveToEnd(sourceIndex: number): void;
    moveToEnd(sourceIndex: number, source: TMoveFrom): void;
    moveToIndex(index: number, sourceIndex: number): void;
    moveToIndex(index: number, sourceIndex: number, source: TMoveFrom): void;
    moveToStart(sourceIndex: number): void;
    moveToStart(sourceIndex: number, source: TMoveFrom): void;
    removeAt(index: number): void;
    removeRange(start?: number, end?: number): void;
}

// @public
export class TreeConfiguration<TSchema extends ImplicitFieldSchema = ImplicitFieldSchema> {
    constructor(schema: TSchema, initialTree: () => InsertableTreeFieldFromImplicitField<TSchema>);
    // (undocumented)
    readonly initialTree: () => InsertableTreeFieldFromImplicitField<TSchema>;
    // (undocumented)
    readonly schema: TSchema;
}

// @public
export type TreeFieldFromImplicitField<TSchema extends ImplicitFieldSchema = FieldSchema> = TSchema extends FieldSchema<infer Kind, infer Types> ? ApplyKind<TreeNodeFromImplicitAllowedTypes<Types>, Kind> : TSchema extends ImplicitAllowedTypes ? TreeNodeFromImplicitAllowedTypes<TSchema> : unknown;

// @public
export type TreeLeafValue = number | string | boolean | IFluidHandle | null;

// @public
export interface TreeMapNode<T extends ImplicitAllowedTypes = ImplicitAllowedTypes> extends ReadonlyMap<string, TreeNodeFromImplicitAllowedTypes<T>>, TreeNode {
    delete(key: string): void;
    set(key: string, value: InsertableTreeNodeFromImplicitAllowedTypes<T> | undefined): void;
}

// @public
export abstract class TreeNode implements WithType {
    abstract get [type](): string;
}

// @public
export interface TreeNodeEvents {
    afterChange(): void;
}

// @public
export type TreeNodeFromImplicitAllowedTypes<TSchema extends ImplicitAllowedTypes = TreeNodeSchema> = TSchema extends TreeNodeSchema ? NodeFromSchema<TSchema> : TSchema extends AllowedTypes ? NodeFromSchema<FlexListToUnion<TSchema>> : unknown;

// @public
export type TreeNodeSchema<Name extends string = string, Kind extends NodeKind = NodeKind, TNode = unknown, TBuild = never, ImplicitlyConstructable extends boolean = boolean> = TreeNodeSchemaClass<Name, Kind, TNode, TBuild, ImplicitlyConstructable> | TreeNodeSchemaNonClass<Name, Kind, TNode, TBuild, ImplicitlyConstructable>;

// @public
export interface TreeNodeSchemaClass<out Name extends string = string, out Kind extends NodeKind = NodeKind, out TNode = unknown, in TInsertable = never, out ImplicitlyConstructable extends boolean = boolean> extends TreeNodeSchemaCore<Name, Kind, ImplicitlyConstructable> {
    // @sealed
    new (data: TInsertable): Unhydrated<TNode>;
}

// @public
export interface TreeNodeSchemaCore<out Name extends string, out Kind extends NodeKind, out ImplicitlyConstructable extends boolean> {
    // (undocumented)
    readonly identifier: Name;
    readonly implicitlyConstructable: ImplicitlyConstructable;
    // (undocumented)
    readonly info: unknown;
    // (undocumented)
    readonly kind: Kind;
}

// @public
export interface TreeNodeSchemaNonClass<out Name extends string = string, out Kind extends NodeKind = NodeKind, out TNode = unknown, in TInsertable = never, out ImplicitlyConstructable extends boolean = boolean> extends TreeNodeSchemaCore<Name, Kind, ImplicitlyConstructable> {
    // (undocumented)
    create(data: TInsertable): TNode;
}

// @public
export enum TreeStatus {
    Deleted = 2,
    InDocument = 0,
    Removed = 1
}

// @public
export interface TreeView<in out TRoot> extends IDisposable {
    readonly events: ISubscribable<TreeViewEvents>;
    readonly root: TRoot;
}

// @public
export interface TreeViewEvents {
    afterBatch(): void;
}

// @public
export const type: unique symbol;

// @public
export type Unhydrated<T> = T;

// @public
export interface WithType<TName extends string = string> {
    get [type](): TName;
}

```
