/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "fluid-framework-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DirectoryFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_DirectoryFactory = requireAssignableTo<TypeOnly<current.DirectoryFactory>, TypeOnly<old.DirectoryFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DOProviderContainerRuntimeFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DOProviderContainerRuntimeFactory = requireAssignableTo<TypeOnly<old.DOProviderContainerRuntimeFactory>, TypeOnly<current.DOProviderContainerRuntimeFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DOProviderContainerRuntimeFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_DOProviderContainerRuntimeFactory = requireAssignableTo<TypeOnly<current.DOProviderContainerRuntimeFactory>, TypeOnly<old.DOProviderContainerRuntimeFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_FluidContainer": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_FluidContainer = requireAssignableTo<TypeOnly<old.FluidContainer>, TypeOnly<current.FluidContainer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_FluidContainer": {"backCompat": false}
 */
declare type current_as_old_for_Class_FluidContainer = requireAssignableTo<TypeOnly<current.FluidContainer>, TypeOnly<old.FluidContainer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Interval": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Interval = requireAssignableTo<TypeOnly<old.Interval>, TypeOnly<current.Interval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Interval": {"backCompat": false}
 */
declare type current_as_old_for_Class_Interval = requireAssignableTo<TypeOnly<current.Interval>, TypeOnly<old.Interval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_IntervalCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_IntervalCollection = requireAssignableTo<TypeOnly<old.IntervalCollection<never>>, TypeOnly<current.IntervalCollection<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_IntervalCollection": {"backCompat": false}
 */
declare type current_as_old_for_Class_IntervalCollection = requireAssignableTo<TypeOnly<current.IntervalCollection<never>>, TypeOnly<old.IntervalCollection<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_IntervalCollectionIterator": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_IntervalCollectionIterator = requireAssignableTo<TypeOnly<old.IntervalCollectionIterator<never>>, TypeOnly<current.IntervalCollectionIterator<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_IntervalCollectionIterator": {"backCompat": false}
 */
declare type current_as_old_for_Class_IntervalCollectionIterator = requireAssignableTo<TypeOnly<current.IntervalCollectionIterator<never>>, TypeOnly<old.IntervalCollectionIterator<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalValueMaker": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_LocalValueMaker = requireAssignableTo<TypeOnly<old.LocalValueMaker>, TypeOnly<current.LocalValueMaker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalValueMaker": {"backCompat": false}
 */
declare type current_as_old_for_Class_LocalValueMaker = requireAssignableTo<TypeOnly<current.LocalValueMaker>, TypeOnly<old.LocalValueMaker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MapFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_MapFactory = requireAssignableTo<TypeOnly<current.MapFactory>, TypeOnly<old.MapFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PaddingSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_PaddingSegment = requireAssignableTo<TypeOnly<old.PaddingSegment>, TypeOnly<current.PaddingSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PaddingSegment": {"backCompat": false}
 */
declare type current_as_old_for_Class_PaddingSegment = requireAssignableTo<TypeOnly<current.PaddingSegment>, TypeOnly<old.PaddingSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RootDataObject": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RootDataObject = requireAssignableTo<TypeOnly<old.RootDataObject>, TypeOnly<current.RootDataObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RootDataObject": {"backCompat": false}
 */
declare type current_as_old_for_Class_RootDataObject = requireAssignableTo<TypeOnly<current.RootDataObject>, TypeOnly<old.RootDataObject>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RunSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RunSegment = requireAssignableTo<TypeOnly<old.RunSegment>, TypeOnly<current.RunSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RunSegment": {"backCompat": false}
 */
declare type current_as_old_for_Class_RunSegment = requireAssignableTo<TypeOnly<current.RunSegment>, TypeOnly<old.RunSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceDeltaEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SequenceDeltaEvent = requireAssignableTo<TypeOnly<old.SequenceDeltaEvent>, TypeOnly<current.SequenceDeltaEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceDeltaEvent": {"backCompat": false}
 */
declare type current_as_old_for_Class_SequenceDeltaEvent = requireAssignableTo<TypeOnly<current.SequenceDeltaEvent>, TypeOnly<old.SequenceDeltaEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SequenceEvent = requireAssignableTo<TypeOnly<old.SequenceEvent>, TypeOnly<current.SequenceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceEvent": {"backCompat": false}
 */
declare type current_as_old_for_Class_SequenceEvent = requireAssignableTo<TypeOnly<current.SequenceEvent>, TypeOnly<old.SequenceEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceInterval": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SequenceInterval = requireAssignableTo<TypeOnly<old.SequenceInterval>, TypeOnly<current.SequenceInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceInterval": {"backCompat": false}
 */
declare type current_as_old_for_Class_SequenceInterval = requireAssignableTo<TypeOnly<current.SequenceInterval>, TypeOnly<old.SequenceInterval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceMaintenanceEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SequenceMaintenanceEvent = requireAssignableTo<TypeOnly<old.SequenceMaintenanceEvent>, TypeOnly<current.SequenceMaintenanceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SequenceMaintenanceEvent": {"backCompat": false}
 */
declare type current_as_old_for_Class_SequenceMaintenanceEvent = requireAssignableTo<TypeOnly<current.SequenceMaintenanceEvent>, TypeOnly<old.SequenceMaintenanceEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ServiceAudience": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ServiceAudience = requireAssignableTo<TypeOnly<old.ServiceAudience>, TypeOnly<current.ServiceAudience>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ServiceAudience": {"backCompat": false}
 */
declare type current_as_old_for_Class_ServiceAudience = requireAssignableTo<TypeOnly<current.ServiceAudience>, TypeOnly<old.ServiceAudience>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedDirectory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedDirectory = requireAssignableTo<TypeOnly<current.SharedDirectory>, TypeOnly<old.SharedDirectory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedIntervalCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedIntervalCollection = requireAssignableTo<TypeOnly<old.SharedIntervalCollection>, TypeOnly<current.SharedIntervalCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedIntervalCollection": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedIntervalCollection = requireAssignableTo<TypeOnly<current.SharedIntervalCollection>, TypeOnly<old.SharedIntervalCollection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedIntervalCollectionFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedIntervalCollectionFactory = requireAssignableTo<TypeOnly<old.SharedIntervalCollectionFactory>, TypeOnly<current.SharedIntervalCollectionFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedIntervalCollectionFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedIntervalCollectionFactory = requireAssignableTo<TypeOnly<current.SharedIntervalCollectionFactory>, TypeOnly<old.SharedIntervalCollectionFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedMap": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedMap = requireAssignableTo<TypeOnly<old.SharedMap>, TypeOnly<current.SharedMap>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedMap": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedMap = requireAssignableTo<TypeOnly<current.SharedMap>, TypeOnly<old.SharedMap>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedNumberSequence": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedNumberSequence = requireAssignableTo<TypeOnly<old.SharedNumberSequence>, TypeOnly<current.SharedNumberSequence>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedNumberSequence": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedNumberSequence = requireAssignableTo<TypeOnly<current.SharedNumberSequence>, TypeOnly<old.SharedNumberSequence>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedNumberSequenceFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedNumberSequenceFactory = requireAssignableTo<TypeOnly<old.SharedNumberSequenceFactory>, TypeOnly<current.SharedNumberSequenceFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedNumberSequenceFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedNumberSequenceFactory = requireAssignableTo<TypeOnly<current.SharedNumberSequenceFactory>, TypeOnly<old.SharedNumberSequenceFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedObjectSequence": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedObjectSequence = requireAssignableTo<TypeOnly<old.SharedObjectSequence<never>>, TypeOnly<current.SharedObjectSequence<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedObjectSequence": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedObjectSequence = requireAssignableTo<TypeOnly<current.SharedObjectSequence<never>>, TypeOnly<old.SharedObjectSequence<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedObjectSequenceFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedObjectSequenceFactory = requireAssignableTo<TypeOnly<old.SharedObjectSequenceFactory>, TypeOnly<current.SharedObjectSequenceFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedObjectSequenceFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedObjectSequenceFactory = requireAssignableTo<TypeOnly<current.SharedObjectSequenceFactory>, TypeOnly<old.SharedObjectSequenceFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedSegmentSequence": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedSegmentSequence = requireAssignableTo<TypeOnly<old.SharedSegmentSequence<never>>, TypeOnly<current.SharedSegmentSequence<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedSegmentSequence": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedSegmentSequence = requireAssignableTo<TypeOnly<current.SharedSegmentSequence<never>>, TypeOnly<old.SharedSegmentSequence<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedSequence": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedSequence = requireAssignableTo<TypeOnly<old.SharedSequence<never>>, TypeOnly<current.SharedSequence<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedSequence": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedSequence = requireAssignableTo<TypeOnly<current.SharedSequence<never>>, TypeOnly<old.SharedSequence<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedString": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedString = requireAssignableTo<TypeOnly<old.SharedString>, TypeOnly<current.SharedString>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedString": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedString = requireAssignableTo<TypeOnly<current.SharedString>, TypeOnly<old.SharedString>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedStringFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SharedStringFactory = requireAssignableTo<TypeOnly<old.SharedStringFactory>, TypeOnly<current.SharedStringFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SharedStringFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SharedStringFactory = requireAssignableTo<TypeOnly<current.SharedStringFactory>, TypeOnly<old.SharedStringFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SparseMatrix": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SparseMatrix = requireAssignableTo<TypeOnly<old.SparseMatrix>, TypeOnly<current.SparseMatrix>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SparseMatrix": {"backCompat": false}
 */
declare type current_as_old_for_Class_SparseMatrix = requireAssignableTo<TypeOnly<current.SparseMatrix>, TypeOnly<old.SparseMatrix>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SparseMatrixFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SparseMatrixFactory = requireAssignableTo<TypeOnly<old.SparseMatrixFactory>, TypeOnly<current.SparseMatrixFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SparseMatrixFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SparseMatrixFactory = requireAssignableTo<TypeOnly<current.SparseMatrixFactory>, TypeOnly<old.SparseMatrixFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SubSequence": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SubSequence = requireAssignableTo<TypeOnly<old.SubSequence<never>>, TypeOnly<current.SubSequence<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SubSequence": {"backCompat": false}
 */
declare type current_as_old_for_Class_SubSequence = requireAssignableTo<TypeOnly<current.SubSequence<never>>, TypeOnly<old.SubSequence<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DirectoryFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DirectoryFactory = requireAssignableTo<TypeOnly<typeof current.DirectoryFactory>, TypeOnly<typeof old.DirectoryFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DOProviderContainerRuntimeFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DOProviderContainerRuntimeFactory = requireAssignableTo<TypeOnly<typeof current.DOProviderContainerRuntimeFactory>, TypeOnly<typeof old.DOProviderContainerRuntimeFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_FluidContainer": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_FluidContainer = requireAssignableTo<TypeOnly<typeof current.FluidContainer>, TypeOnly<typeof old.FluidContainer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Interval": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Interval = requireAssignableTo<TypeOnly<typeof current.Interval>, TypeOnly<typeof old.Interval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_IntervalCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_IntervalCollection = requireAssignableTo<TypeOnly<typeof current.IntervalCollection>, TypeOnly<typeof old.IntervalCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_IntervalCollectionIterator": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_IntervalCollectionIterator = requireAssignableTo<TypeOnly<typeof current.IntervalCollectionIterator>, TypeOnly<typeof old.IntervalCollectionIterator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_LocalValueMaker": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_LocalValueMaker = requireAssignableTo<TypeOnly<typeof current.LocalValueMaker>, TypeOnly<typeof old.LocalValueMaker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MapFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MapFactory = requireAssignableTo<TypeOnly<typeof current.MapFactory>, TypeOnly<typeof old.MapFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_PaddingSegment": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_PaddingSegment = requireAssignableTo<TypeOnly<typeof current.PaddingSegment>, TypeOnly<typeof old.PaddingSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RootDataObject": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RootDataObject = requireAssignableTo<TypeOnly<typeof current.RootDataObject>, TypeOnly<typeof old.RootDataObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RunSegment": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RunSegment = requireAssignableTo<TypeOnly<typeof current.RunSegment>, TypeOnly<typeof old.RunSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SequenceDeltaEvent": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SequenceDeltaEvent = requireAssignableTo<TypeOnly<typeof current.SequenceDeltaEvent>, TypeOnly<typeof old.SequenceDeltaEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SequenceEvent": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SequenceEvent = requireAssignableTo<TypeOnly<typeof current.SequenceEvent>, TypeOnly<typeof old.SequenceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SequenceInterval": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SequenceInterval = requireAssignableTo<TypeOnly<typeof current.SequenceInterval>, TypeOnly<typeof old.SequenceInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SequenceMaintenanceEvent": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SequenceMaintenanceEvent = requireAssignableTo<TypeOnly<typeof current.SequenceMaintenanceEvent>, TypeOnly<typeof old.SequenceMaintenanceEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ServiceAudience": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ServiceAudience = requireAssignableTo<TypeOnly<typeof current.ServiceAudience>, TypeOnly<typeof old.ServiceAudience>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedDirectory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedDirectory = requireAssignableTo<TypeOnly<typeof current.SharedDirectory>, TypeOnly<typeof old.SharedDirectory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedIntervalCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedIntervalCollection = requireAssignableTo<TypeOnly<typeof current.SharedIntervalCollection>, TypeOnly<typeof old.SharedIntervalCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedIntervalCollectionFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedIntervalCollectionFactory = requireAssignableTo<TypeOnly<typeof current.SharedIntervalCollectionFactory>, TypeOnly<typeof old.SharedIntervalCollectionFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedMap": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedMap = requireAssignableTo<TypeOnly<typeof current.SharedMap>, TypeOnly<typeof old.SharedMap>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedNumberSequence": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedNumberSequence = requireAssignableTo<TypeOnly<typeof current.SharedNumberSequence>, TypeOnly<typeof old.SharedNumberSequence>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedNumberSequenceFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedNumberSequenceFactory = requireAssignableTo<TypeOnly<typeof current.SharedNumberSequenceFactory>, TypeOnly<typeof old.SharedNumberSequenceFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedObjectSequence": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedObjectSequence = requireAssignableTo<TypeOnly<typeof current.SharedObjectSequence>, TypeOnly<typeof old.SharedObjectSequence>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedObjectSequenceFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedObjectSequenceFactory = requireAssignableTo<TypeOnly<typeof current.SharedObjectSequenceFactory>, TypeOnly<typeof old.SharedObjectSequenceFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedSegmentSequence": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedSegmentSequence = requireAssignableTo<TypeOnly<typeof current.SharedSegmentSequence>, TypeOnly<typeof old.SharedSegmentSequence>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedSequence": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedSequence = requireAssignableTo<TypeOnly<typeof current.SharedSequence>, TypeOnly<typeof old.SharedSequence>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedString": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedString = requireAssignableTo<TypeOnly<typeof current.SharedString>, TypeOnly<typeof old.SharedString>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SharedStringFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SharedStringFactory = requireAssignableTo<TypeOnly<typeof current.SharedStringFactory>, TypeOnly<typeof old.SharedStringFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SparseMatrix": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SparseMatrix = requireAssignableTo<TypeOnly<typeof current.SparseMatrix>, TypeOnly<typeof old.SparseMatrix>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SparseMatrixFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SparseMatrixFactory = requireAssignableTo<TypeOnly<typeof current.SparseMatrixFactory>, TypeOnly<typeof old.SparseMatrixFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SubSequence": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SubSequence = requireAssignableTo<TypeOnly<typeof current.SubSequence>, TypeOnly<typeof old.SubSequence>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_AttachState": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_AttachState = requireAssignableTo<TypeOnly<old.AttachState>, TypeOnly<current.AttachState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_AttachState": {"backCompat": false}
 */
declare type current_as_old_for_Enum_AttachState = requireAssignableTo<TypeOnly<current.AttachState>, TypeOnly<old.AttachState>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ConnectionState": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_ConnectionState = requireAssignableTo<TypeOnly<old.ConnectionState>, TypeOnly<current.ConnectionState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ConnectionState": {"backCompat": false}
 */
declare type current_as_old_for_Enum_ConnectionState = requireAssignableTo<TypeOnly<current.ConnectionState>, TypeOnly<old.ConnectionState>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ContainerErrorType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_ContainerErrorType = requireAssignableTo<TypeOnly<old.ContainerErrorType>, TypeOnly<current.ContainerErrorType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ContainerErrorType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_ContainerErrorType = requireAssignableTo<TypeOnly<current.ContainerErrorType>, TypeOnly<old.ContainerErrorType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_DriverErrorType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_DriverErrorType = requireAssignableTo<TypeOnly<old.DriverErrorType>, TypeOnly<current.DriverErrorType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_DriverErrorType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_DriverErrorType = requireAssignableTo<TypeOnly<current.DriverErrorType>, TypeOnly<old.DriverErrorType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_IntervalType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_IntervalType = requireAssignableTo<TypeOnly<old.IntervalType>, TypeOnly<current.IntervalType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_IntervalType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_IntervalType = requireAssignableTo<TypeOnly<current.IntervalType>, TypeOnly<old.IntervalType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_positionToRowCol": {"backCompat": false}
 */
declare type current_as_old_for_Function_positionToRowCol = requireAssignableTo<TypeOnly<typeof current.positionToRowCol>, TypeOnly<typeof old.positionToRowCol>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ContainerSchema": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ContainerSchema = requireAssignableTo<TypeOnly<old.ContainerSchema>, TypeOnly<current.ContainerSchema>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ContainerSchema": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ContainerSchema = requireAssignableTo<TypeOnly<current.ContainerSchema>, TypeOnly<old.ContainerSchema>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnection": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConnection = requireAssignableTo<TypeOnly<old.IConnection>, TypeOnly<current.IConnection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnection": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConnection = requireAssignableTo<TypeOnly<current.IConnection>, TypeOnly<old.IConnection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectory": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDirectory = requireAssignableTo<TypeOnly<old.IDirectory>, TypeOnly<current.IDirectory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectory": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDirectory = requireAssignableTo<TypeOnly<current.IDirectory>, TypeOnly<old.IDirectory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryClearOperation": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDirectoryClearOperation = requireAssignableTo<TypeOnly<old.IDirectoryClearOperation>, TypeOnly<current.IDirectoryClearOperation>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryClearOperation": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDirectoryClearOperation = requireAssignableTo<TypeOnly<current.IDirectoryClearOperation>, TypeOnly<old.IDirectoryClearOperation>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryCreateSubDirectoryOperation": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDirectoryCreateSubDirectoryOperation = requireAssignableTo<TypeOnly<old.IDirectoryCreateSubDirectoryOperation>, TypeOnly<current.IDirectoryCreateSubDirectoryOperation>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryCreateSubDirectoryOperation": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDirectoryCreateSubDirectoryOperation = requireAssignableTo<TypeOnly<current.IDirectoryCreateSubDirectoryOperation>, TypeOnly<old.IDirectoryCreateSubDirectoryOperation>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryDataObject": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDirectoryDataObject = requireAssignableTo<TypeOnly<old.IDirectoryDataObject>, TypeOnly<current.IDirectoryDataObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryDataObject": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDirectoryDataObject = requireAssignableTo<TypeOnly<current.IDirectoryDataObject>, TypeOnly<old.IDirectoryDataObject>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryDeleteOperation": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDirectoryDeleteOperation = requireAssignableTo<TypeOnly<old.IDirectoryDeleteOperation>, TypeOnly<current.IDirectoryDeleteOperation>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryDeleteOperation": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDirectoryDeleteOperation = requireAssignableTo<TypeOnly<current.IDirectoryDeleteOperation>, TypeOnly<old.IDirectoryDeleteOperation>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryDeleteSubDirectoryOperation": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDirectoryDeleteSubDirectoryOperation = requireAssignableTo<TypeOnly<old.IDirectoryDeleteSubDirectoryOperation>, TypeOnly<current.IDirectoryDeleteSubDirectoryOperation>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryDeleteSubDirectoryOperation": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDirectoryDeleteSubDirectoryOperation = requireAssignableTo<TypeOnly<current.IDirectoryDeleteSubDirectoryOperation>, TypeOnly<old.IDirectoryDeleteSubDirectoryOperation>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDirectoryEvents = requireAssignableTo<TypeOnly<old.IDirectoryEvents>, TypeOnly<current.IDirectoryEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDirectoryEvents = requireAssignableTo<TypeOnly<current.IDirectoryEvents>, TypeOnly<old.IDirectoryEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryNewStorageFormat": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDirectoryNewStorageFormat = requireAssignableTo<TypeOnly<old.IDirectoryNewStorageFormat>, TypeOnly<current.IDirectoryNewStorageFormat>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryNewStorageFormat": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDirectoryNewStorageFormat = requireAssignableTo<TypeOnly<current.IDirectoryNewStorageFormat>, TypeOnly<old.IDirectoryNewStorageFormat>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectorySetOperation": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDirectorySetOperation = requireAssignableTo<TypeOnly<old.IDirectorySetOperation>, TypeOnly<current.IDirectorySetOperation>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectorySetOperation": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDirectorySetOperation = requireAssignableTo<TypeOnly<current.IDirectorySetOperation>, TypeOnly<old.IDirectorySetOperation>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryValueChanged": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDirectoryValueChanged = requireAssignableTo<TypeOnly<old.IDirectoryValueChanged>, TypeOnly<current.IDirectoryValueChanged>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDirectoryValueChanged": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDirectoryValueChanged = requireAssignableTo<TypeOnly<current.IDirectoryValueChanged>, TypeOnly<old.IDirectoryValueChanged>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidContainer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidContainer = requireAssignableTo<TypeOnly<old.IFluidContainer>, TypeOnly<current.IFluidContainer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidContainer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidContainer = requireAssignableTo<TypeOnly<current.IFluidContainer>, TypeOnly<old.IFluidContainer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidContainerEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IFluidContainerEvents = requireAssignableTo<TypeOnly<old.IFluidContainerEvents>, TypeOnly<current.IFluidContainerEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IFluidContainerEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IFluidContainerEvents = requireAssignableTo<TypeOnly<current.IFluidContainerEvents>, TypeOnly<old.IFluidContainerEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IIntervalCollectionEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IIntervalCollectionEvent = requireAssignableTo<TypeOnly<old.IIntervalCollectionEvent<never>>, TypeOnly<current.IIntervalCollectionEvent<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IIntervalCollectionEvent": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IIntervalCollectionEvent = requireAssignableTo<TypeOnly<current.IIntervalCollectionEvent<never>>, TypeOnly<old.IIntervalCollectionEvent<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IIntervalHelpers": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IIntervalHelpers = requireAssignableTo<TypeOnly<old.IIntervalHelpers<never>>, TypeOnly<current.IIntervalHelpers<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IIntervalHelpers": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IIntervalHelpers = requireAssignableTo<TypeOnly<current.IIntervalHelpers<never>>, TypeOnly<old.IIntervalHelpers<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IJSONRunSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IJSONRunSegment = requireAssignableTo<TypeOnly<old.IJSONRunSegment<never>>, TypeOnly<current.IJSONRunSegment<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IJSONRunSegment": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IJSONRunSegment = requireAssignableTo<TypeOnly<current.IJSONRunSegment<never>>, TypeOnly<old.IJSONRunSegment<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILocalValue": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ILocalValue = requireAssignableTo<TypeOnly<old.ILocalValue>, TypeOnly<current.ILocalValue>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILocalValue": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ILocalValue = requireAssignableTo<TypeOnly<current.ILocalValue>, TypeOnly<old.ILocalValue>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMapMessageLocalMetadata": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMapMessageLocalMetadata = requireAssignableTo<TypeOnly<old.IMapMessageLocalMetadata>, TypeOnly<current.IMapMessageLocalMetadata>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMapMessageLocalMetadata": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMapMessageLocalMetadata = requireAssignableTo<TypeOnly<current.IMapMessageLocalMetadata>, TypeOnly<old.IMapMessageLocalMetadata>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMember": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMember = requireAssignableTo<TypeOnly<old.IMember>, TypeOnly<current.IMember>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMember": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMember = requireAssignableTo<TypeOnly<current.IMember>, TypeOnly<old.IMember>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequenceDeltaRange": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISequenceDeltaRange = requireAssignableTo<TypeOnly<old.ISequenceDeltaRange>, TypeOnly<current.ISequenceDeltaRange>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequenceDeltaRange": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISequenceDeltaRange = requireAssignableTo<TypeOnly<current.ISequenceDeltaRange>, TypeOnly<old.ISequenceDeltaRange>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializableInterval": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISerializableInterval = requireAssignableTo<TypeOnly<old.ISerializableInterval>, TypeOnly<current.ISerializableInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializableInterval": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISerializableInterval = requireAssignableTo<TypeOnly<current.ISerializableInterval>, TypeOnly<old.ISerializableInterval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializableValue": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISerializableValue = requireAssignableTo<TypeOnly<old.ISerializableValue>, TypeOnly<current.ISerializableValue>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializableValue": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISerializableValue = requireAssignableTo<TypeOnly<current.ISerializableValue>, TypeOnly<old.ISerializableValue>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializedInterval": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISerializedInterval = requireAssignableTo<TypeOnly<old.ISerializedInterval>, TypeOnly<current.ISerializedInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializedInterval": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISerializedInterval = requireAssignableTo<TypeOnly<current.ISerializedInterval>, TypeOnly<old.ISerializedInterval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializedIntervalCollectionV2": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISerializedIntervalCollectionV2 = requireAssignableTo<TypeOnly<old.ISerializedIntervalCollectionV2>, TypeOnly<current.ISerializedIntervalCollectionV2>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializedIntervalCollectionV2": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISerializedIntervalCollectionV2 = requireAssignableTo<TypeOnly<current.ISerializedIntervalCollectionV2>, TypeOnly<old.ISerializedIntervalCollectionV2>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializedValue": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISerializedValue = requireAssignableTo<TypeOnly<old.ISerializedValue>, TypeOnly<current.ISerializedValue>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISerializedValue": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISerializedValue = requireAssignableTo<TypeOnly<current.ISerializedValue>, TypeOnly<old.ISerializedValue>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServiceAudience": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IServiceAudience = requireAssignableTo<TypeOnly<old.IServiceAudience<never>>, TypeOnly<current.IServiceAudience<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServiceAudience": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IServiceAudience = requireAssignableTo<TypeOnly<current.IServiceAudience<never>>, TypeOnly<old.IServiceAudience<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServiceAudienceEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IServiceAudienceEvents = requireAssignableTo<TypeOnly<old.IServiceAudienceEvents<never>>, TypeOnly<current.IServiceAudienceEvents<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServiceAudienceEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IServiceAudienceEvents = requireAssignableTo<TypeOnly<current.IServiceAudienceEvents<never>>, TypeOnly<old.IServiceAudienceEvents<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedDirectory": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISharedDirectory = requireAssignableTo<TypeOnly<old.ISharedDirectory>, TypeOnly<current.ISharedDirectory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedDirectory": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISharedDirectory = requireAssignableTo<TypeOnly<current.ISharedDirectory>, TypeOnly<old.ISharedDirectory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedDirectoryEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISharedDirectoryEvents = requireAssignableTo<TypeOnly<old.ISharedDirectoryEvents>, TypeOnly<current.ISharedDirectoryEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedDirectoryEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISharedDirectoryEvents = requireAssignableTo<TypeOnly<current.ISharedDirectoryEvents>, TypeOnly<old.ISharedDirectoryEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedIntervalCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISharedIntervalCollection = requireAssignableTo<TypeOnly<old.ISharedIntervalCollection<never>>, TypeOnly<current.ISharedIntervalCollection<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedIntervalCollection": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISharedIntervalCollection = requireAssignableTo<TypeOnly<current.ISharedIntervalCollection<never>>, TypeOnly<old.ISharedIntervalCollection<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedMap": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISharedMap = requireAssignableTo<TypeOnly<old.ISharedMap>, TypeOnly<current.ISharedMap>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedMap": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISharedMap = requireAssignableTo<TypeOnly<current.ISharedMap>, TypeOnly<old.ISharedMap>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedMapEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISharedMapEvents = requireAssignableTo<TypeOnly<old.ISharedMapEvents>, TypeOnly<current.ISharedMapEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedMapEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISharedMapEvents = requireAssignableTo<TypeOnly<current.ISharedMapEvents>, TypeOnly<old.ISharedMapEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedSegmentSequenceEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISharedSegmentSequenceEvents = requireAssignableTo<TypeOnly<old.ISharedSegmentSequenceEvents>, TypeOnly<current.ISharedSegmentSequenceEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedSegmentSequenceEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISharedSegmentSequenceEvents = requireAssignableTo<TypeOnly<current.ISharedSegmentSequenceEvents>, TypeOnly<old.ISharedSegmentSequenceEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedString": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISharedString = requireAssignableTo<TypeOnly<old.ISharedString>, TypeOnly<current.ISharedString>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISharedString": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISharedString = requireAssignableTo<TypeOnly<current.ISharedString>, TypeOnly<old.ISharedString>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IValueChanged": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IValueChanged = requireAssignableTo<TypeOnly<old.IValueChanged>, TypeOnly<current.IValueChanged>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IValueChanged": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IValueChanged = requireAssignableTo<TypeOnly<current.IValueChanged>, TypeOnly<old.IValueChanged>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IValueOpEmitter": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IValueOpEmitter = requireAssignableTo<TypeOnly<old.IValueOpEmitter>, TypeOnly<current.IValueOpEmitter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IValueOpEmitter": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IValueOpEmitter = requireAssignableTo<TypeOnly<current.IValueOpEmitter>, TypeOnly<old.IValueOpEmitter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_RootDataObjectProps": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_RootDataObjectProps = requireAssignableTo<TypeOnly<old.RootDataObjectProps>, TypeOnly<current.RootDataObjectProps>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_RootDataObjectProps": {"backCompat": false}
 */
declare type current_as_old_for_Interface_RootDataObjectProps = requireAssignableTo<TypeOnly<current.RootDataObjectProps>, TypeOnly<old.RootDataObjectProps>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_CompressedSerializedInterval": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_CompressedSerializedInterval = requireAssignableTo<TypeOnly<old.CompressedSerializedInterval>, TypeOnly<current.CompressedSerializedInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_CompressedSerializedInterval": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_CompressedSerializedInterval = requireAssignableTo<TypeOnly<current.CompressedSerializedInterval>, TypeOnly<old.CompressedSerializedInterval>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_DataObjectClass": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_DataObjectClass = requireAssignableTo<TypeOnly<old.DataObjectClass<never>>, TypeOnly<current.DataObjectClass<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_DataObjectClass": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_DataObjectClass = requireAssignableTo<TypeOnly<current.DataObjectClass<never>>, TypeOnly<old.DataObjectClass<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_DeserializeCallback": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_DeserializeCallback = requireAssignableTo<TypeOnly<old.DeserializeCallback>, TypeOnly<current.DeserializeCallback>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_DeserializeCallback": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_DeserializeCallback = requireAssignableTo<TypeOnly<current.DeserializeCallback>, TypeOnly<old.DeserializeCallback>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ICriticalContainerError": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ICriticalContainerError = requireAssignableTo<TypeOnly<old.ICriticalContainerError>, TypeOnly<current.ICriticalContainerError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ICriticalContainerError": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ICriticalContainerError = requireAssignableTo<TypeOnly<current.ICriticalContainerError>, TypeOnly<old.ICriticalContainerError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IDirectoryKeyOperation": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IDirectoryKeyOperation = requireAssignableTo<TypeOnly<old.IDirectoryKeyOperation>, TypeOnly<current.IDirectoryKeyOperation>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IDirectoryKeyOperation": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IDirectoryKeyOperation = requireAssignableTo<TypeOnly<current.IDirectoryKeyOperation>, TypeOnly<old.IDirectoryKeyOperation>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IDirectoryOperation": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IDirectoryOperation = requireAssignableTo<TypeOnly<old.IDirectoryOperation>, TypeOnly<current.IDirectoryOperation>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IDirectoryOperation": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IDirectoryOperation = requireAssignableTo<TypeOnly<current.IDirectoryOperation>, TypeOnly<old.IDirectoryOperation>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IDirectoryStorageOperation": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IDirectoryStorageOperation = requireAssignableTo<TypeOnly<old.IDirectoryStorageOperation>, TypeOnly<current.IDirectoryStorageOperation>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IDirectoryStorageOperation": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IDirectoryStorageOperation = requireAssignableTo<TypeOnly<current.IDirectoryStorageOperation>, TypeOnly<old.IDirectoryStorageOperation>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IDirectorySubDirectoryOperation": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IDirectorySubDirectoryOperation = requireAssignableTo<TypeOnly<old.IDirectorySubDirectoryOperation>, TypeOnly<current.IDirectorySubDirectoryOperation>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IDirectorySubDirectoryOperation": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IDirectorySubDirectoryOperation = requireAssignableTo<TypeOnly<current.IDirectorySubDirectoryOperation>, TypeOnly<old.IDirectorySubDirectoryOperation>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectClass": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_LoadableObjectClass = requireAssignableTo<TypeOnly<old.LoadableObjectClass<never>>, TypeOnly<current.LoadableObjectClass<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectClass": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_LoadableObjectClass = requireAssignableTo<TypeOnly<current.LoadableObjectClass<never>>, TypeOnly<old.LoadableObjectClass<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectClassRecord": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_LoadableObjectClassRecord = requireAssignableTo<TypeOnly<old.LoadableObjectClassRecord>, TypeOnly<current.LoadableObjectClassRecord>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectClassRecord": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_LoadableObjectClassRecord = requireAssignableTo<TypeOnly<current.LoadableObjectClassRecord>, TypeOnly<old.LoadableObjectClassRecord>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectCtor": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_LoadableObjectCtor = requireAssignableTo<TypeOnly<old.LoadableObjectCtor<never>>, TypeOnly<current.LoadableObjectCtor<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectCtor": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_LoadableObjectCtor = requireAssignableTo<TypeOnly<current.LoadableObjectCtor<never>>, TypeOnly<old.LoadableObjectCtor<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectRecord": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_LoadableObjectRecord = requireAssignableTo<TypeOnly<old.LoadableObjectRecord>, TypeOnly<current.LoadableObjectRecord>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LoadableObjectRecord": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_LoadableObjectRecord = requireAssignableTo<TypeOnly<current.LoadableObjectRecord>, TypeOnly<old.LoadableObjectRecord>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MatrixSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_MatrixSegment = requireAssignableTo<TypeOnly<old.MatrixSegment>, TypeOnly<current.MatrixSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_MatrixSegment": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_MatrixSegment = requireAssignableTo<TypeOnly<current.MatrixSegment>, TypeOnly<old.MatrixSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SharedObjectClass": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SharedObjectClass = requireAssignableTo<TypeOnly<old.SharedObjectClass<never>>, TypeOnly<current.SharedObjectClass<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SharedObjectClass": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SharedObjectClass = requireAssignableTo<TypeOnly<current.SharedObjectClass<never>>, TypeOnly<old.SharedObjectClass<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SharedStringSegment": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SharedStringSegment = requireAssignableTo<TypeOnly<old.SharedStringSegment>, TypeOnly<current.SharedStringSegment>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SharedStringSegment": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SharedStringSegment = requireAssignableTo<TypeOnly<current.SharedStringSegment>, TypeOnly<old.SharedStringSegment>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SparseMatrixItem": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SparseMatrixItem = requireAssignableTo<TypeOnly<old.SparseMatrixItem>, TypeOnly<current.SparseMatrixItem>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SparseMatrixItem": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SparseMatrixItem = requireAssignableTo<TypeOnly<current.SparseMatrixItem>, TypeOnly<old.SparseMatrixItem>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_maxCellPosition": {"backCompat": false}
 */
declare type current_as_old_for_Variable_maxCellPosition = requireAssignableTo<TypeOnly<typeof current.maxCellPosition>, TypeOnly<typeof old.maxCellPosition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_maxCol": {"backCompat": false}
 */
declare type current_as_old_for_Variable_maxCol = requireAssignableTo<TypeOnly<typeof current.maxCol>, TypeOnly<typeof old.maxCol>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_maxCols": {"backCompat": false}
 */
declare type current_as_old_for_Variable_maxCols = requireAssignableTo<TypeOnly<typeof current.maxCols>, TypeOnly<typeof old.maxCols>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_maxRow": {"backCompat": false}
 */
declare type current_as_old_for_Variable_maxRow = requireAssignableTo<TypeOnly<typeof current.maxRow>, TypeOnly<typeof old.maxRow>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_maxRows": {"backCompat": false}
 */
declare type current_as_old_for_Variable_maxRows = requireAssignableTo<TypeOnly<typeof current.maxRows>, TypeOnly<typeof old.maxRows>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_rowColToPosition": {"backCompat": false}
 */
declare type current_as_old_for_Variable_rowColToPosition = requireAssignableTo<TypeOnly<typeof current.rowColToPosition>, TypeOnly<typeof old.rowColToPosition>>
