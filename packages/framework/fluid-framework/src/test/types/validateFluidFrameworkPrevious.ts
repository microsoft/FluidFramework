/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "fluid-framework-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_AttachState": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_AttachState():
    TypeOnly<old.AttachState>;
declare function use_current_EnumDeclaration_AttachState(
    use: TypeOnly<current.AttachState>);
use_current_EnumDeclaration_AttachState(
    get_old_EnumDeclaration_AttachState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_AttachState": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_AttachState():
    TypeOnly<current.AttachState>;
declare function use_old_EnumDeclaration_AttachState(
    use: TypeOnly<old.AttachState>);
use_old_EnumDeclaration_AttachState(
    get_current_EnumDeclaration_AttachState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CompressedSerializedInterval": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_CompressedSerializedInterval():
    TypeOnly<old.CompressedSerializedInterval>;
declare function use_current_TypeAliasDeclaration_CompressedSerializedInterval(
    use: TypeOnly<current.CompressedSerializedInterval>);
use_current_TypeAliasDeclaration_CompressedSerializedInterval(
    get_old_TypeAliasDeclaration_CompressedSerializedInterval());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CompressedSerializedInterval": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_CompressedSerializedInterval():
    TypeOnly<current.CompressedSerializedInterval>;
declare function use_old_TypeAliasDeclaration_CompressedSerializedInterval(
    use: TypeOnly<old.CompressedSerializedInterval>);
use_old_TypeAliasDeclaration_CompressedSerializedInterval(
    get_current_TypeAliasDeclaration_CompressedSerializedInterval());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ConnectionState": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_ConnectionState():
    TypeOnly<old.ConnectionState>;
declare function use_current_EnumDeclaration_ConnectionState(
    use: TypeOnly<current.ConnectionState>);
use_current_EnumDeclaration_ConnectionState(
    get_old_EnumDeclaration_ConnectionState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ConnectionState": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_ConnectionState():
    TypeOnly<current.ConnectionState>;
declare function use_old_EnumDeclaration_ConnectionState(
    use: TypeOnly<old.ConnectionState>);
use_old_EnumDeclaration_ConnectionState(
    get_current_EnumDeclaration_ConnectionState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerSchema": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ContainerSchema():
    TypeOnly<old.ContainerSchema>;
declare function use_current_InterfaceDeclaration_ContainerSchema(
    use: TypeOnly<current.ContainerSchema>);
use_current_InterfaceDeclaration_ContainerSchema(
    get_old_InterfaceDeclaration_ContainerSchema());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ContainerSchema": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ContainerSchema():
    TypeOnly<current.ContainerSchema>;
declare function use_old_InterfaceDeclaration_ContainerSchema(
    use: TypeOnly<old.ContainerSchema>);
use_old_InterfaceDeclaration_ContainerSchema(
    get_current_InterfaceDeclaration_ContainerSchema());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_DataObjectClass": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_DataObjectClass():
    TypeOnly<old.DataObjectClass<any>>;
declare function use_current_TypeAliasDeclaration_DataObjectClass(
    use: TypeOnly<current.DataObjectClass<any>>);
use_current_TypeAliasDeclaration_DataObjectClass(
    get_old_TypeAliasDeclaration_DataObjectClass());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_DataObjectClass": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_DataObjectClass():
    TypeOnly<current.DataObjectClass<any>>;
declare function use_old_TypeAliasDeclaration_DataObjectClass(
    use: TypeOnly<old.DataObjectClass<any>>);
use_old_TypeAliasDeclaration_DataObjectClass(
    get_current_TypeAliasDeclaration_DataObjectClass());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_DeserializeCallback": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_DeserializeCallback():
    TypeOnly<old.DeserializeCallback>;
declare function use_current_TypeAliasDeclaration_DeserializeCallback(
    use: TypeOnly<current.DeserializeCallback>);
use_current_TypeAliasDeclaration_DeserializeCallback(
    get_old_TypeAliasDeclaration_DeserializeCallback());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_DeserializeCallback": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_DeserializeCallback():
    TypeOnly<current.DeserializeCallback>;
declare function use_old_TypeAliasDeclaration_DeserializeCallback(
    use: TypeOnly<old.DeserializeCallback>);
use_old_TypeAliasDeclaration_DeserializeCallback(
    get_current_TypeAliasDeclaration_DeserializeCallback());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DirectoryFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DirectoryFactory():
    TypeOnly<old.DirectoryFactory>;
declare function use_current_ClassDeclaration_DirectoryFactory(
    use: TypeOnly<current.DirectoryFactory>);
use_current_ClassDeclaration_DirectoryFactory(
    get_old_ClassDeclaration_DirectoryFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DirectoryFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DirectoryFactory():
    TypeOnly<current.DirectoryFactory>;
declare function use_old_ClassDeclaration_DirectoryFactory(
    use: TypeOnly<old.DirectoryFactory>);
use_old_ClassDeclaration_DirectoryFactory(
    get_current_ClassDeclaration_DirectoryFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DOProviderContainerRuntimeFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DOProviderContainerRuntimeFactory():
    TypeOnly<old.DOProviderContainerRuntimeFactory>;
declare function use_current_ClassDeclaration_DOProviderContainerRuntimeFactory(
    use: TypeOnly<current.DOProviderContainerRuntimeFactory>);
use_current_ClassDeclaration_DOProviderContainerRuntimeFactory(
    get_old_ClassDeclaration_DOProviderContainerRuntimeFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DOProviderContainerRuntimeFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DOProviderContainerRuntimeFactory():
    TypeOnly<current.DOProviderContainerRuntimeFactory>;
declare function use_old_ClassDeclaration_DOProviderContainerRuntimeFactory(
    use: TypeOnly<old.DOProviderContainerRuntimeFactory>);
use_old_ClassDeclaration_DOProviderContainerRuntimeFactory(
    get_current_ClassDeclaration_DOProviderContainerRuntimeFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_FluidContainer": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_FluidContainer():
    TypeOnly<old.FluidContainer>;
declare function use_current_ClassDeclaration_FluidContainer(
    use: TypeOnly<current.FluidContainer>);
use_current_ClassDeclaration_FluidContainer(
    get_old_ClassDeclaration_FluidContainer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_FluidContainer": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_FluidContainer():
    TypeOnly<current.FluidContainer>;
declare function use_old_ClassDeclaration_FluidContainer(
    use: TypeOnly<old.FluidContainer>);
use_old_ClassDeclaration_FluidContainer(
    get_current_ClassDeclaration_FluidContainer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getTextAndMarkers": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getTextAndMarkers():
    TypeOnly<typeof old.getTextAndMarkers>;
declare function use_current_FunctionDeclaration_getTextAndMarkers(
    use: TypeOnly<typeof current.getTextAndMarkers>);
use_current_FunctionDeclaration_getTextAndMarkers(
    get_old_FunctionDeclaration_getTextAndMarkers());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getTextAndMarkers": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getTextAndMarkers():
    TypeOnly<typeof current.getTextAndMarkers>;
declare function use_old_FunctionDeclaration_getTextAndMarkers(
    use: TypeOnly<typeof old.getTextAndMarkers>);
use_old_FunctionDeclaration_getTextAndMarkers(
    get_current_FunctionDeclaration_getTextAndMarkers());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnection": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConnection():
    TypeOnly<old.IConnection>;
declare function use_current_InterfaceDeclaration_IConnection(
    use: TypeOnly<current.IConnection>);
use_current_InterfaceDeclaration_IConnection(
    get_old_InterfaceDeclaration_IConnection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConnection": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConnection():
    TypeOnly<current.IConnection>;
declare function use_old_InterfaceDeclaration_IConnection(
    use: TypeOnly<old.IConnection>);
use_old_InterfaceDeclaration_IConnection(
    get_current_InterfaceDeclaration_IConnection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDirectory():
    TypeOnly<old.IDirectory>;
declare function use_current_InterfaceDeclaration_IDirectory(
    use: TypeOnly<current.IDirectory>);
use_current_InterfaceDeclaration_IDirectory(
    get_old_InterfaceDeclaration_IDirectory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDirectory():
    TypeOnly<current.IDirectory>;
declare function use_old_InterfaceDeclaration_IDirectory(
    use: TypeOnly<old.IDirectory>);
use_old_InterfaceDeclaration_IDirectory(
    get_current_InterfaceDeclaration_IDirectory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryClearOperation": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDirectoryClearOperation():
    TypeOnly<old.IDirectoryClearOperation>;
declare function use_current_InterfaceDeclaration_IDirectoryClearOperation(
    use: TypeOnly<current.IDirectoryClearOperation>);
use_current_InterfaceDeclaration_IDirectoryClearOperation(
    get_old_InterfaceDeclaration_IDirectoryClearOperation());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryClearOperation": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDirectoryClearOperation():
    TypeOnly<current.IDirectoryClearOperation>;
declare function use_old_InterfaceDeclaration_IDirectoryClearOperation(
    use: TypeOnly<old.IDirectoryClearOperation>);
use_old_InterfaceDeclaration_IDirectoryClearOperation(
    get_current_InterfaceDeclaration_IDirectoryClearOperation());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryCreateSubDirectoryOperation": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDirectoryCreateSubDirectoryOperation():
    TypeOnly<old.IDirectoryCreateSubDirectoryOperation>;
declare function use_current_InterfaceDeclaration_IDirectoryCreateSubDirectoryOperation(
    use: TypeOnly<current.IDirectoryCreateSubDirectoryOperation>);
use_current_InterfaceDeclaration_IDirectoryCreateSubDirectoryOperation(
    get_old_InterfaceDeclaration_IDirectoryCreateSubDirectoryOperation());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryCreateSubDirectoryOperation": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDirectoryCreateSubDirectoryOperation():
    TypeOnly<current.IDirectoryCreateSubDirectoryOperation>;
declare function use_old_InterfaceDeclaration_IDirectoryCreateSubDirectoryOperation(
    use: TypeOnly<old.IDirectoryCreateSubDirectoryOperation>);
use_old_InterfaceDeclaration_IDirectoryCreateSubDirectoryOperation(
    get_current_InterfaceDeclaration_IDirectoryCreateSubDirectoryOperation());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryDataObject": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDirectoryDataObject():
    TypeOnly<old.IDirectoryDataObject>;
declare function use_current_InterfaceDeclaration_IDirectoryDataObject(
    use: TypeOnly<current.IDirectoryDataObject>);
use_current_InterfaceDeclaration_IDirectoryDataObject(
    get_old_InterfaceDeclaration_IDirectoryDataObject());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryDataObject": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDirectoryDataObject():
    TypeOnly<current.IDirectoryDataObject>;
declare function use_old_InterfaceDeclaration_IDirectoryDataObject(
    use: TypeOnly<old.IDirectoryDataObject>);
use_old_InterfaceDeclaration_IDirectoryDataObject(
    get_current_InterfaceDeclaration_IDirectoryDataObject());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryDeleteOperation": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDirectoryDeleteOperation():
    TypeOnly<old.IDirectoryDeleteOperation>;
declare function use_current_InterfaceDeclaration_IDirectoryDeleteOperation(
    use: TypeOnly<current.IDirectoryDeleteOperation>);
use_current_InterfaceDeclaration_IDirectoryDeleteOperation(
    get_old_InterfaceDeclaration_IDirectoryDeleteOperation());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryDeleteOperation": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDirectoryDeleteOperation():
    TypeOnly<current.IDirectoryDeleteOperation>;
declare function use_old_InterfaceDeclaration_IDirectoryDeleteOperation(
    use: TypeOnly<old.IDirectoryDeleteOperation>);
use_old_InterfaceDeclaration_IDirectoryDeleteOperation(
    get_current_InterfaceDeclaration_IDirectoryDeleteOperation());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryDeleteSubDirectoryOperation": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDirectoryDeleteSubDirectoryOperation():
    TypeOnly<old.IDirectoryDeleteSubDirectoryOperation>;
declare function use_current_InterfaceDeclaration_IDirectoryDeleteSubDirectoryOperation(
    use: TypeOnly<current.IDirectoryDeleteSubDirectoryOperation>);
use_current_InterfaceDeclaration_IDirectoryDeleteSubDirectoryOperation(
    get_old_InterfaceDeclaration_IDirectoryDeleteSubDirectoryOperation());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryDeleteSubDirectoryOperation": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDirectoryDeleteSubDirectoryOperation():
    TypeOnly<current.IDirectoryDeleteSubDirectoryOperation>;
declare function use_old_InterfaceDeclaration_IDirectoryDeleteSubDirectoryOperation(
    use: TypeOnly<old.IDirectoryDeleteSubDirectoryOperation>);
use_old_InterfaceDeclaration_IDirectoryDeleteSubDirectoryOperation(
    get_current_InterfaceDeclaration_IDirectoryDeleteSubDirectoryOperation());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDirectoryEvents():
    TypeOnly<old.IDirectoryEvents>;
declare function use_current_InterfaceDeclaration_IDirectoryEvents(
    use: TypeOnly<current.IDirectoryEvents>);
use_current_InterfaceDeclaration_IDirectoryEvents(
    get_old_InterfaceDeclaration_IDirectoryEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDirectoryEvents():
    TypeOnly<current.IDirectoryEvents>;
declare function use_old_InterfaceDeclaration_IDirectoryEvents(
    use: TypeOnly<old.IDirectoryEvents>);
use_old_InterfaceDeclaration_IDirectoryEvents(
    get_current_InterfaceDeclaration_IDirectoryEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IDirectoryKeyOperation": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IDirectoryKeyOperation():
    TypeOnly<old.IDirectoryKeyOperation>;
declare function use_current_TypeAliasDeclaration_IDirectoryKeyOperation(
    use: TypeOnly<current.IDirectoryKeyOperation>);
use_current_TypeAliasDeclaration_IDirectoryKeyOperation(
    get_old_TypeAliasDeclaration_IDirectoryKeyOperation());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IDirectoryKeyOperation": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IDirectoryKeyOperation():
    TypeOnly<current.IDirectoryKeyOperation>;
declare function use_old_TypeAliasDeclaration_IDirectoryKeyOperation(
    use: TypeOnly<old.IDirectoryKeyOperation>);
use_old_TypeAliasDeclaration_IDirectoryKeyOperation(
    get_current_TypeAliasDeclaration_IDirectoryKeyOperation());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryNewStorageFormat": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDirectoryNewStorageFormat():
    TypeOnly<old.IDirectoryNewStorageFormat>;
declare function use_current_InterfaceDeclaration_IDirectoryNewStorageFormat(
    use: TypeOnly<current.IDirectoryNewStorageFormat>);
use_current_InterfaceDeclaration_IDirectoryNewStorageFormat(
    get_old_InterfaceDeclaration_IDirectoryNewStorageFormat());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryNewStorageFormat": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDirectoryNewStorageFormat():
    TypeOnly<current.IDirectoryNewStorageFormat>;
declare function use_old_InterfaceDeclaration_IDirectoryNewStorageFormat(
    use: TypeOnly<old.IDirectoryNewStorageFormat>);
use_old_InterfaceDeclaration_IDirectoryNewStorageFormat(
    get_current_InterfaceDeclaration_IDirectoryNewStorageFormat());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IDirectoryOperation": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IDirectoryOperation():
    TypeOnly<old.IDirectoryOperation>;
declare function use_current_TypeAliasDeclaration_IDirectoryOperation(
    use: TypeOnly<current.IDirectoryOperation>);
use_current_TypeAliasDeclaration_IDirectoryOperation(
    get_old_TypeAliasDeclaration_IDirectoryOperation());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IDirectoryOperation": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IDirectoryOperation():
    TypeOnly<current.IDirectoryOperation>;
declare function use_old_TypeAliasDeclaration_IDirectoryOperation(
    use: TypeOnly<old.IDirectoryOperation>);
use_old_TypeAliasDeclaration_IDirectoryOperation(
    get_current_TypeAliasDeclaration_IDirectoryOperation());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectorySetOperation": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDirectorySetOperation():
    TypeOnly<old.IDirectorySetOperation>;
declare function use_current_InterfaceDeclaration_IDirectorySetOperation(
    use: TypeOnly<current.IDirectorySetOperation>);
use_current_InterfaceDeclaration_IDirectorySetOperation(
    get_old_InterfaceDeclaration_IDirectorySetOperation());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectorySetOperation": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDirectorySetOperation():
    TypeOnly<current.IDirectorySetOperation>;
declare function use_old_InterfaceDeclaration_IDirectorySetOperation(
    use: TypeOnly<old.IDirectorySetOperation>);
use_old_InterfaceDeclaration_IDirectorySetOperation(
    get_current_InterfaceDeclaration_IDirectorySetOperation());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IDirectoryStorageOperation": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IDirectoryStorageOperation():
    TypeOnly<old.IDirectoryStorageOperation>;
declare function use_current_TypeAliasDeclaration_IDirectoryStorageOperation(
    use: TypeOnly<current.IDirectoryStorageOperation>);
use_current_TypeAliasDeclaration_IDirectoryStorageOperation(
    get_old_TypeAliasDeclaration_IDirectoryStorageOperation());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IDirectoryStorageOperation": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IDirectoryStorageOperation():
    TypeOnly<current.IDirectoryStorageOperation>;
declare function use_old_TypeAliasDeclaration_IDirectoryStorageOperation(
    use: TypeOnly<old.IDirectoryStorageOperation>);
use_old_TypeAliasDeclaration_IDirectoryStorageOperation(
    get_current_TypeAliasDeclaration_IDirectoryStorageOperation());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IDirectorySubDirectoryOperation": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IDirectorySubDirectoryOperation():
    TypeOnly<old.IDirectorySubDirectoryOperation>;
declare function use_current_TypeAliasDeclaration_IDirectorySubDirectoryOperation(
    use: TypeOnly<current.IDirectorySubDirectoryOperation>);
use_current_TypeAliasDeclaration_IDirectorySubDirectoryOperation(
    get_old_TypeAliasDeclaration_IDirectorySubDirectoryOperation());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IDirectorySubDirectoryOperation": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IDirectorySubDirectoryOperation():
    TypeOnly<current.IDirectorySubDirectoryOperation>;
declare function use_old_TypeAliasDeclaration_IDirectorySubDirectoryOperation(
    use: TypeOnly<old.IDirectorySubDirectoryOperation>);
use_old_TypeAliasDeclaration_IDirectorySubDirectoryOperation(
    get_current_TypeAliasDeclaration_IDirectorySubDirectoryOperation());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryValueChanged": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDirectoryValueChanged():
    TypeOnly<old.IDirectoryValueChanged>;
declare function use_current_InterfaceDeclaration_IDirectoryValueChanged(
    use: TypeOnly<current.IDirectoryValueChanged>);
use_current_InterfaceDeclaration_IDirectoryValueChanged(
    get_old_InterfaceDeclaration_IDirectoryValueChanged());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDirectoryValueChanged": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDirectoryValueChanged():
    TypeOnly<current.IDirectoryValueChanged>;
declare function use_old_InterfaceDeclaration_IDirectoryValueChanged(
    use: TypeOnly<old.IDirectoryValueChanged>);
use_old_InterfaceDeclaration_IDirectoryValueChanged(
    get_current_InterfaceDeclaration_IDirectoryValueChanged());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidContainer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidContainer():
    TypeOnly<old.IFluidContainer>;
declare function use_current_InterfaceDeclaration_IFluidContainer(
    use: TypeOnly<current.IFluidContainer>);
use_current_InterfaceDeclaration_IFluidContainer(
    get_old_InterfaceDeclaration_IFluidContainer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidContainer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidContainer():
    TypeOnly<current.IFluidContainer>;
declare function use_old_InterfaceDeclaration_IFluidContainer(
    use: TypeOnly<old.IFluidContainer>);
use_old_InterfaceDeclaration_IFluidContainer(
    get_current_InterfaceDeclaration_IFluidContainer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidContainerEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IFluidContainerEvents():
    TypeOnly<old.IFluidContainerEvents>;
declare function use_current_InterfaceDeclaration_IFluidContainerEvents(
    use: TypeOnly<current.IFluidContainerEvents>);
use_current_InterfaceDeclaration_IFluidContainerEvents(
    get_old_InterfaceDeclaration_IFluidContainerEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IFluidContainerEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IFluidContainerEvents():
    TypeOnly<current.IFluidContainerEvents>;
declare function use_old_InterfaceDeclaration_IFluidContainerEvents(
    use: TypeOnly<old.IFluidContainerEvents>);
use_old_InterfaceDeclaration_IFluidContainerEvents(
    get_current_InterfaceDeclaration_IFluidContainerEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInterval": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInterval():
    TypeOnly<old.IInterval>;
declare function use_current_InterfaceDeclaration_IInterval(
    use: TypeOnly<current.IInterval>);
use_current_InterfaceDeclaration_IInterval(
    get_old_InterfaceDeclaration_IInterval());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInterval": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInterval():
    TypeOnly<current.IInterval>;
declare function use_old_InterfaceDeclaration_IInterval(
    use: TypeOnly<old.IInterval>);
use_old_InterfaceDeclaration_IInterval(
    get_current_InterfaceDeclaration_IInterval());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IIntervalCollectionEvent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IIntervalCollectionEvent():
    TypeOnly<old.IIntervalCollectionEvent<any>>;
declare function use_current_InterfaceDeclaration_IIntervalCollectionEvent(
    use: TypeOnly<current.IIntervalCollectionEvent<any>>);
use_current_InterfaceDeclaration_IIntervalCollectionEvent(
    get_old_InterfaceDeclaration_IIntervalCollectionEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IIntervalCollectionEvent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IIntervalCollectionEvent():
    TypeOnly<current.IIntervalCollectionEvent<any>>;
declare function use_old_InterfaceDeclaration_IIntervalCollectionEvent(
    use: TypeOnly<old.IIntervalCollectionEvent<any>>);
use_old_InterfaceDeclaration_IIntervalCollectionEvent(
    get_current_InterfaceDeclaration_IIntervalCollectionEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IIntervalHelpers": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IIntervalHelpers():
    TypeOnly<old.IIntervalHelpers<any>>;
declare function use_current_InterfaceDeclaration_IIntervalHelpers(
    use: TypeOnly<current.IIntervalHelpers<any>>);
use_current_InterfaceDeclaration_IIntervalHelpers(
    get_old_InterfaceDeclaration_IIntervalHelpers());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IIntervalHelpers": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IIntervalHelpers():
    TypeOnly<current.IIntervalHelpers<any>>;
declare function use_old_InterfaceDeclaration_IIntervalHelpers(
    use: TypeOnly<old.IIntervalHelpers<any>>);
use_old_InterfaceDeclaration_IIntervalHelpers(
    get_current_InterfaceDeclaration_IIntervalHelpers());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IJSONRunSegment": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IJSONRunSegment():
    TypeOnly<old.IJSONRunSegment<any>>;
declare function use_current_InterfaceDeclaration_IJSONRunSegment(
    use: TypeOnly<current.IJSONRunSegment<any>>);
use_current_InterfaceDeclaration_IJSONRunSegment(
    get_old_InterfaceDeclaration_IJSONRunSegment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IJSONRunSegment": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IJSONRunSegment():
    TypeOnly<current.IJSONRunSegment<any>>;
declare function use_old_InterfaceDeclaration_IJSONRunSegment(
    use: TypeOnly<old.IJSONRunSegment<any>>);
use_old_InterfaceDeclaration_IJSONRunSegment(
    get_current_InterfaceDeclaration_IJSONRunSegment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILocalValue": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ILocalValue():
    TypeOnly<old.ILocalValue>;
declare function use_current_InterfaceDeclaration_ILocalValue(
    use: TypeOnly<current.ILocalValue>);
use_current_InterfaceDeclaration_ILocalValue(
    get_old_InterfaceDeclaration_ILocalValue());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILocalValue": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ILocalValue():
    TypeOnly<current.ILocalValue>;
declare function use_old_InterfaceDeclaration_ILocalValue(
    use: TypeOnly<old.ILocalValue>);
use_old_InterfaceDeclaration_ILocalValue(
    get_current_InterfaceDeclaration_ILocalValue());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMapMessageLocalMetadata": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMapMessageLocalMetadata():
    TypeOnly<old.IMapMessageLocalMetadata>;
declare function use_current_InterfaceDeclaration_IMapMessageLocalMetadata(
    use: TypeOnly<current.IMapMessageLocalMetadata>);
use_current_InterfaceDeclaration_IMapMessageLocalMetadata(
    get_old_InterfaceDeclaration_IMapMessageLocalMetadata());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMapMessageLocalMetadata": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMapMessageLocalMetadata():
    TypeOnly<current.IMapMessageLocalMetadata>;
declare function use_old_InterfaceDeclaration_IMapMessageLocalMetadata(
    use: TypeOnly<old.IMapMessageLocalMetadata>);
use_old_InterfaceDeclaration_IMapMessageLocalMetadata(
    get_current_InterfaceDeclaration_IMapMessageLocalMetadata());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMember": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMember():
    TypeOnly<old.IMember>;
declare function use_current_InterfaceDeclaration_IMember(
    use: TypeOnly<current.IMember>);
use_current_InterfaceDeclaration_IMember(
    get_old_InterfaceDeclaration_IMember());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMember": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMember():
    TypeOnly<current.IMember>;
declare function use_old_InterfaceDeclaration_IMember(
    use: TypeOnly<old.IMember>);
use_old_InterfaceDeclaration_IMember(
    get_current_InterfaceDeclaration_IMember());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Interval": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Interval():
    TypeOnly<old.Interval>;
declare function use_current_ClassDeclaration_Interval(
    use: TypeOnly<current.Interval>);
use_current_ClassDeclaration_Interval(
    get_old_ClassDeclaration_Interval());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Interval": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Interval():
    TypeOnly<current.Interval>;
declare function use_old_ClassDeclaration_Interval(
    use: TypeOnly<old.Interval>);
use_old_ClassDeclaration_Interval(
    get_current_ClassDeclaration_Interval());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_IntervalCollection": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_IntervalCollection():
    TypeOnly<old.IntervalCollection<any>>;
declare function use_current_ClassDeclaration_IntervalCollection(
    use: TypeOnly<current.IntervalCollection<any>>);
use_current_ClassDeclaration_IntervalCollection(
    get_old_ClassDeclaration_IntervalCollection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_IntervalCollection": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_IntervalCollection():
    TypeOnly<current.IntervalCollection<any>>;
declare function use_old_ClassDeclaration_IntervalCollection(
    use: TypeOnly<old.IntervalCollection<any>>);
use_old_ClassDeclaration_IntervalCollection(
    get_current_ClassDeclaration_IntervalCollection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_IntervalCollectionIterator": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_IntervalCollectionIterator():
    TypeOnly<old.IntervalCollectionIterator<any>>;
declare function use_current_ClassDeclaration_IntervalCollectionIterator(
    use: TypeOnly<current.IntervalCollectionIterator<any>>);
use_current_ClassDeclaration_IntervalCollectionIterator(
    get_old_ClassDeclaration_IntervalCollectionIterator());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_IntervalCollectionIterator": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_IntervalCollectionIterator():
    TypeOnly<current.IntervalCollectionIterator<any>>;
declare function use_old_ClassDeclaration_IntervalCollectionIterator(
    use: TypeOnly<old.IntervalCollectionIterator<any>>);
use_old_ClassDeclaration_IntervalCollectionIterator(
    get_current_ClassDeclaration_IntervalCollectionIterator());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IntervalConflictResolver": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IntervalConflictResolver():
    TypeOnly<old.IntervalConflictResolver<any>>;
declare function use_current_TypeAliasDeclaration_IntervalConflictResolver(
    use: TypeOnly<current.IntervalConflictResolver<any>>);
use_current_TypeAliasDeclaration_IntervalConflictResolver(
    get_old_TypeAliasDeclaration_IntervalConflictResolver());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IntervalConflictResolver": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IntervalConflictResolver():
    TypeOnly<current.IntervalConflictResolver<any>>;
declare function use_old_TypeAliasDeclaration_IntervalConflictResolver(
    use: TypeOnly<old.IntervalConflictResolver<any>>);
use_old_TypeAliasDeclaration_IntervalConflictResolver(
    get_current_TypeAliasDeclaration_IntervalConflictResolver());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IntervalLocator": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IntervalLocator():
    TypeOnly<old.IntervalLocator>;
declare function use_current_InterfaceDeclaration_IntervalLocator(
    use: TypeOnly<current.IntervalLocator>);
use_current_InterfaceDeclaration_IntervalLocator(
    get_old_InterfaceDeclaration_IntervalLocator());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IntervalLocator": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IntervalLocator():
    TypeOnly<current.IntervalLocator>;
declare function use_old_InterfaceDeclaration_IntervalLocator(
    use: TypeOnly<old.IntervalLocator>);
use_old_InterfaceDeclaration_IntervalLocator(
    get_current_InterfaceDeclaration_IntervalLocator());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_intervalLocatorFromEndpoint": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_intervalLocatorFromEndpoint():
    TypeOnly<typeof old.intervalLocatorFromEndpoint>;
declare function use_current_FunctionDeclaration_intervalLocatorFromEndpoint(
    use: TypeOnly<typeof current.intervalLocatorFromEndpoint>);
use_current_FunctionDeclaration_intervalLocatorFromEndpoint(
    get_old_FunctionDeclaration_intervalLocatorFromEndpoint());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_intervalLocatorFromEndpoint": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_intervalLocatorFromEndpoint():
    TypeOnly<typeof current.intervalLocatorFromEndpoint>;
declare function use_old_FunctionDeclaration_intervalLocatorFromEndpoint(
    use: TypeOnly<typeof old.intervalLocatorFromEndpoint>);
use_old_FunctionDeclaration_intervalLocatorFromEndpoint(
    get_current_FunctionDeclaration_intervalLocatorFromEndpoint());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_IntervalType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_IntervalType():
    TypeOnly<old.IntervalType>;
declare function use_current_EnumDeclaration_IntervalType(
    use: TypeOnly<current.IntervalType>);
use_current_EnumDeclaration_IntervalType(
    get_old_EnumDeclaration_IntervalType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_IntervalType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_IntervalType():
    TypeOnly<current.IntervalType>;
declare function use_old_EnumDeclaration_IntervalType(
    use: TypeOnly<old.IntervalType>);
use_old_EnumDeclaration_IntervalType(
    get_current_EnumDeclaration_IntervalType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRootDataObject": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRootDataObject():
    TypeOnly<old.IRootDataObject>;
declare function use_current_InterfaceDeclaration_IRootDataObject(
    use: TypeOnly<current.IRootDataObject>);
use_current_InterfaceDeclaration_IRootDataObject(
    get_old_InterfaceDeclaration_IRootDataObject());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRootDataObject": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRootDataObject():
    TypeOnly<current.IRootDataObject>;
declare function use_old_InterfaceDeclaration_IRootDataObject(
    use: TypeOnly<old.IRootDataObject>);
use_old_InterfaceDeclaration_IRootDataObject(
    get_current_InterfaceDeclaration_IRootDataObject());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISequenceDeltaRange": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISequenceDeltaRange():
    TypeOnly<old.ISequenceDeltaRange>;
declare function use_current_InterfaceDeclaration_ISequenceDeltaRange(
    use: TypeOnly<current.ISequenceDeltaRange>);
use_current_InterfaceDeclaration_ISequenceDeltaRange(
    get_old_InterfaceDeclaration_ISequenceDeltaRange());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISequenceDeltaRange": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISequenceDeltaRange():
    TypeOnly<current.ISequenceDeltaRange>;
declare function use_old_InterfaceDeclaration_ISequenceDeltaRange(
    use: TypeOnly<old.ISequenceDeltaRange>);
use_old_InterfaceDeclaration_ISequenceDeltaRange(
    get_current_InterfaceDeclaration_ISequenceDeltaRange());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISerializableInterval": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISerializableInterval():
    TypeOnly<old.ISerializableInterval>;
declare function use_current_InterfaceDeclaration_ISerializableInterval(
    use: TypeOnly<current.ISerializableInterval>);
use_current_InterfaceDeclaration_ISerializableInterval(
    get_old_InterfaceDeclaration_ISerializableInterval());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISerializableInterval": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISerializableInterval():
    TypeOnly<current.ISerializableInterval>;
declare function use_old_InterfaceDeclaration_ISerializableInterval(
    use: TypeOnly<old.ISerializableInterval>);
use_old_InterfaceDeclaration_ISerializableInterval(
    get_current_InterfaceDeclaration_ISerializableInterval());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISerializableValue": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISerializableValue():
    TypeOnly<old.ISerializableValue>;
declare function use_current_InterfaceDeclaration_ISerializableValue(
    use: TypeOnly<current.ISerializableValue>);
use_current_InterfaceDeclaration_ISerializableValue(
    get_old_InterfaceDeclaration_ISerializableValue());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISerializableValue": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISerializableValue():
    TypeOnly<current.ISerializableValue>;
declare function use_old_InterfaceDeclaration_ISerializableValue(
    use: TypeOnly<old.ISerializableValue>);
use_old_InterfaceDeclaration_ISerializableValue(
    get_current_InterfaceDeclaration_ISerializableValue());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISerializedInterval": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISerializedInterval():
    TypeOnly<old.ISerializedInterval>;
declare function use_current_InterfaceDeclaration_ISerializedInterval(
    use: TypeOnly<current.ISerializedInterval>);
use_current_InterfaceDeclaration_ISerializedInterval(
    get_old_InterfaceDeclaration_ISerializedInterval());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISerializedInterval": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISerializedInterval():
    TypeOnly<current.ISerializedInterval>;
declare function use_old_InterfaceDeclaration_ISerializedInterval(
    use: TypeOnly<old.ISerializedInterval>);
use_old_InterfaceDeclaration_ISerializedInterval(
    get_current_InterfaceDeclaration_ISerializedInterval());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISerializedIntervalCollectionV2": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISerializedIntervalCollectionV2():
    TypeOnly<old.ISerializedIntervalCollectionV2>;
declare function use_current_InterfaceDeclaration_ISerializedIntervalCollectionV2(
    use: TypeOnly<current.ISerializedIntervalCollectionV2>);
use_current_InterfaceDeclaration_ISerializedIntervalCollectionV2(
    get_old_InterfaceDeclaration_ISerializedIntervalCollectionV2());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISerializedIntervalCollectionV2": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISerializedIntervalCollectionV2():
    TypeOnly<current.ISerializedIntervalCollectionV2>;
declare function use_old_InterfaceDeclaration_ISerializedIntervalCollectionV2(
    use: TypeOnly<old.ISerializedIntervalCollectionV2>);
use_old_InterfaceDeclaration_ISerializedIntervalCollectionV2(
    get_current_InterfaceDeclaration_ISerializedIntervalCollectionV2());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISerializedValue": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISerializedValue():
    TypeOnly<old.ISerializedValue>;
declare function use_current_InterfaceDeclaration_ISerializedValue(
    use: TypeOnly<current.ISerializedValue>);
use_current_InterfaceDeclaration_ISerializedValue(
    get_old_InterfaceDeclaration_ISerializedValue());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISerializedValue": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISerializedValue():
    TypeOnly<current.ISerializedValue>;
declare function use_old_InterfaceDeclaration_ISerializedValue(
    use: TypeOnly<old.ISerializedValue>);
use_old_InterfaceDeclaration_ISerializedValue(
    get_current_InterfaceDeclaration_ISerializedValue());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IServiceAudience": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IServiceAudience():
    TypeOnly<old.IServiceAudience<any>>;
declare function use_current_InterfaceDeclaration_IServiceAudience(
    use: TypeOnly<current.IServiceAudience<any>>);
use_current_InterfaceDeclaration_IServiceAudience(
    get_old_InterfaceDeclaration_IServiceAudience());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IServiceAudience": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IServiceAudience():
    TypeOnly<current.IServiceAudience<any>>;
declare function use_old_InterfaceDeclaration_IServiceAudience(
    use: TypeOnly<old.IServiceAudience<any>>);
use_old_InterfaceDeclaration_IServiceAudience(
    get_current_InterfaceDeclaration_IServiceAudience());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IServiceAudienceEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IServiceAudienceEvents():
    TypeOnly<old.IServiceAudienceEvents<any>>;
declare function use_current_InterfaceDeclaration_IServiceAudienceEvents(
    use: TypeOnly<current.IServiceAudienceEvents<any>>);
use_current_InterfaceDeclaration_IServiceAudienceEvents(
    get_old_InterfaceDeclaration_IServiceAudienceEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IServiceAudienceEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IServiceAudienceEvents():
    TypeOnly<current.IServiceAudienceEvents<any>>;
declare function use_old_InterfaceDeclaration_IServiceAudienceEvents(
    use: TypeOnly<old.IServiceAudienceEvents<any>>);
use_old_InterfaceDeclaration_IServiceAudienceEvents(
    get_current_InterfaceDeclaration_IServiceAudienceEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharedDirectory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISharedDirectory():
    TypeOnly<old.ISharedDirectory>;
declare function use_current_InterfaceDeclaration_ISharedDirectory(
    use: TypeOnly<current.ISharedDirectory>);
use_current_InterfaceDeclaration_ISharedDirectory(
    get_old_InterfaceDeclaration_ISharedDirectory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharedDirectory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISharedDirectory():
    TypeOnly<current.ISharedDirectory>;
declare function use_old_InterfaceDeclaration_ISharedDirectory(
    use: TypeOnly<old.ISharedDirectory>);
use_old_InterfaceDeclaration_ISharedDirectory(
    get_current_InterfaceDeclaration_ISharedDirectory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharedDirectoryEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISharedDirectoryEvents():
    TypeOnly<old.ISharedDirectoryEvents>;
declare function use_current_InterfaceDeclaration_ISharedDirectoryEvents(
    use: TypeOnly<current.ISharedDirectoryEvents>);
use_current_InterfaceDeclaration_ISharedDirectoryEvents(
    get_old_InterfaceDeclaration_ISharedDirectoryEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharedDirectoryEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISharedDirectoryEvents():
    TypeOnly<current.ISharedDirectoryEvents>;
declare function use_old_InterfaceDeclaration_ISharedDirectoryEvents(
    use: TypeOnly<old.ISharedDirectoryEvents>);
use_old_InterfaceDeclaration_ISharedDirectoryEvents(
    get_current_InterfaceDeclaration_ISharedDirectoryEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharedIntervalCollection": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISharedIntervalCollection():
    TypeOnly<old.ISharedIntervalCollection<any>>;
declare function use_current_InterfaceDeclaration_ISharedIntervalCollection(
    use: TypeOnly<current.ISharedIntervalCollection<any>>);
use_current_InterfaceDeclaration_ISharedIntervalCollection(
    get_old_InterfaceDeclaration_ISharedIntervalCollection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharedIntervalCollection": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISharedIntervalCollection():
    TypeOnly<current.ISharedIntervalCollection<any>>;
declare function use_old_InterfaceDeclaration_ISharedIntervalCollection(
    use: TypeOnly<old.ISharedIntervalCollection<any>>);
use_old_InterfaceDeclaration_ISharedIntervalCollection(
    get_current_InterfaceDeclaration_ISharedIntervalCollection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharedMap": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISharedMap():
    TypeOnly<old.ISharedMap>;
declare function use_current_InterfaceDeclaration_ISharedMap(
    use: TypeOnly<current.ISharedMap>);
use_current_InterfaceDeclaration_ISharedMap(
    get_old_InterfaceDeclaration_ISharedMap());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharedMap": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISharedMap():
    TypeOnly<current.ISharedMap>;
declare function use_old_InterfaceDeclaration_ISharedMap(
    use: TypeOnly<old.ISharedMap>);
use_old_InterfaceDeclaration_ISharedMap(
    get_current_InterfaceDeclaration_ISharedMap());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharedMapEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISharedMapEvents():
    TypeOnly<old.ISharedMapEvents>;
declare function use_current_InterfaceDeclaration_ISharedMapEvents(
    use: TypeOnly<current.ISharedMapEvents>);
use_current_InterfaceDeclaration_ISharedMapEvents(
    get_old_InterfaceDeclaration_ISharedMapEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharedMapEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISharedMapEvents():
    TypeOnly<current.ISharedMapEvents>;
declare function use_old_InterfaceDeclaration_ISharedMapEvents(
    use: TypeOnly<old.ISharedMapEvents>);
use_old_InterfaceDeclaration_ISharedMapEvents(
    get_current_InterfaceDeclaration_ISharedMapEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharedSegmentSequenceEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISharedSegmentSequenceEvents():
    TypeOnly<old.ISharedSegmentSequenceEvents>;
declare function use_current_InterfaceDeclaration_ISharedSegmentSequenceEvents(
    use: TypeOnly<current.ISharedSegmentSequenceEvents>);
use_current_InterfaceDeclaration_ISharedSegmentSequenceEvents(
    get_old_InterfaceDeclaration_ISharedSegmentSequenceEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharedSegmentSequenceEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISharedSegmentSequenceEvents():
    TypeOnly<current.ISharedSegmentSequenceEvents>;
declare function use_old_InterfaceDeclaration_ISharedSegmentSequenceEvents(
    use: TypeOnly<old.ISharedSegmentSequenceEvents>);
use_old_InterfaceDeclaration_ISharedSegmentSequenceEvents(
    get_current_InterfaceDeclaration_ISharedSegmentSequenceEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharedString": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISharedString():
    TypeOnly<old.ISharedString>;
declare function use_current_InterfaceDeclaration_ISharedString(
    use: TypeOnly<current.ISharedString>);
use_current_InterfaceDeclaration_ISharedString(
    get_old_InterfaceDeclaration_ISharedString());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISharedString": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISharedString():
    TypeOnly<current.ISharedString>;
declare function use_old_InterfaceDeclaration_ISharedString(
    use: TypeOnly<old.ISharedString>);
use_old_InterfaceDeclaration_ISharedString(
    get_current_InterfaceDeclaration_ISharedString());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IValueChanged": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IValueChanged():
    TypeOnly<old.IValueChanged>;
declare function use_current_InterfaceDeclaration_IValueChanged(
    use: TypeOnly<current.IValueChanged>);
use_current_InterfaceDeclaration_IValueChanged(
    get_old_InterfaceDeclaration_IValueChanged());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IValueChanged": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IValueChanged():
    TypeOnly<current.IValueChanged>;
declare function use_old_InterfaceDeclaration_IValueChanged(
    use: TypeOnly<old.IValueChanged>);
use_old_InterfaceDeclaration_IValueChanged(
    get_current_InterfaceDeclaration_IValueChanged());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IValueOpEmitter": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IValueOpEmitter():
    TypeOnly<old.IValueOpEmitter>;
declare function use_current_InterfaceDeclaration_IValueOpEmitter(
    use: TypeOnly<current.IValueOpEmitter>);
use_current_InterfaceDeclaration_IValueOpEmitter(
    get_old_InterfaceDeclaration_IValueOpEmitter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IValueOpEmitter": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IValueOpEmitter():
    TypeOnly<current.IValueOpEmitter>;
declare function use_old_InterfaceDeclaration_IValueOpEmitter(
    use: TypeOnly<old.IValueOpEmitter>);
use_old_InterfaceDeclaration_IValueOpEmitter(
    get_current_InterfaceDeclaration_IValueOpEmitter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_LoadableObjectClass": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_LoadableObjectClass():
    TypeOnly<old.LoadableObjectClass<any>>;
declare function use_current_TypeAliasDeclaration_LoadableObjectClass(
    use: TypeOnly<current.LoadableObjectClass<any>>);
use_current_TypeAliasDeclaration_LoadableObjectClass(
    get_old_TypeAliasDeclaration_LoadableObjectClass());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_LoadableObjectClass": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_LoadableObjectClass():
    TypeOnly<current.LoadableObjectClass<any>>;
declare function use_old_TypeAliasDeclaration_LoadableObjectClass(
    use: TypeOnly<old.LoadableObjectClass<any>>);
use_old_TypeAliasDeclaration_LoadableObjectClass(
    get_current_TypeAliasDeclaration_LoadableObjectClass());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_LoadableObjectClassRecord": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_LoadableObjectClassRecord():
    TypeOnly<old.LoadableObjectClassRecord>;
declare function use_current_TypeAliasDeclaration_LoadableObjectClassRecord(
    use: TypeOnly<current.LoadableObjectClassRecord>);
use_current_TypeAliasDeclaration_LoadableObjectClassRecord(
    get_old_TypeAliasDeclaration_LoadableObjectClassRecord());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_LoadableObjectClassRecord": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_LoadableObjectClassRecord():
    TypeOnly<current.LoadableObjectClassRecord>;
declare function use_old_TypeAliasDeclaration_LoadableObjectClassRecord(
    use: TypeOnly<old.LoadableObjectClassRecord>);
use_old_TypeAliasDeclaration_LoadableObjectClassRecord(
    get_current_TypeAliasDeclaration_LoadableObjectClassRecord());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_LoadableObjectCtor": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_LoadableObjectCtor():
    TypeOnly<old.LoadableObjectCtor<any>>;
declare function use_current_TypeAliasDeclaration_LoadableObjectCtor(
    use: TypeOnly<current.LoadableObjectCtor<any>>);
use_current_TypeAliasDeclaration_LoadableObjectCtor(
    get_old_TypeAliasDeclaration_LoadableObjectCtor());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_LoadableObjectCtor": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_LoadableObjectCtor():
    TypeOnly<current.LoadableObjectCtor<any>>;
declare function use_old_TypeAliasDeclaration_LoadableObjectCtor(
    use: TypeOnly<old.LoadableObjectCtor<any>>);
use_old_TypeAliasDeclaration_LoadableObjectCtor(
    get_current_TypeAliasDeclaration_LoadableObjectCtor());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_LoadableObjectRecord": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_LoadableObjectRecord():
    TypeOnly<old.LoadableObjectRecord>;
declare function use_current_TypeAliasDeclaration_LoadableObjectRecord(
    use: TypeOnly<current.LoadableObjectRecord>);
use_current_TypeAliasDeclaration_LoadableObjectRecord(
    get_old_TypeAliasDeclaration_LoadableObjectRecord());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_LoadableObjectRecord": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_LoadableObjectRecord():
    TypeOnly<current.LoadableObjectRecord>;
declare function use_old_TypeAliasDeclaration_LoadableObjectRecord(
    use: TypeOnly<old.LoadableObjectRecord>);
use_old_TypeAliasDeclaration_LoadableObjectRecord(
    get_current_TypeAliasDeclaration_LoadableObjectRecord());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LocalValueMaker": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_LocalValueMaker():
    TypeOnly<old.LocalValueMaker>;
declare function use_current_ClassDeclaration_LocalValueMaker(
    use: TypeOnly<current.LocalValueMaker>);
use_current_ClassDeclaration_LocalValueMaker(
    get_old_ClassDeclaration_LocalValueMaker());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LocalValueMaker": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_LocalValueMaker():
    TypeOnly<current.LocalValueMaker>;
declare function use_old_ClassDeclaration_LocalValueMaker(
    use: TypeOnly<old.LocalValueMaker>);
use_old_ClassDeclaration_LocalValueMaker(
    get_current_ClassDeclaration_LocalValueMaker());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MapFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MapFactory():
    TypeOnly<old.MapFactory>;
declare function use_current_ClassDeclaration_MapFactory(
    use: TypeOnly<current.MapFactory>);
use_current_ClassDeclaration_MapFactory(
    get_old_ClassDeclaration_MapFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MapFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MapFactory():
    TypeOnly<current.MapFactory>;
declare function use_old_ClassDeclaration_MapFactory(
    use: TypeOnly<old.MapFactory>);
use_old_ClassDeclaration_MapFactory(
    get_current_ClassDeclaration_MapFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_MemberChangedListener": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_MemberChangedListener():
    TypeOnly<old.MemberChangedListener<any>>;
declare function use_current_TypeAliasDeclaration_MemberChangedListener(
    use: TypeOnly<current.MemberChangedListener<any>>);
use_current_TypeAliasDeclaration_MemberChangedListener(
    get_old_TypeAliasDeclaration_MemberChangedListener());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_MemberChangedListener": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_MemberChangedListener():
    TypeOnly<current.MemberChangedListener<any>>;
declare function use_old_TypeAliasDeclaration_MemberChangedListener(
    use: TypeOnly<old.MemberChangedListener<any>>);
use_old_TypeAliasDeclaration_MemberChangedListener(
    get_current_TypeAliasDeclaration_MemberChangedListener());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedTypeAliasDeclaration_Myself": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedTypeAliasDeclaration_Myself": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RootDataObject": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_RootDataObject():
    TypeOnly<old.RootDataObject>;
declare function use_current_ClassDeclaration_RootDataObject(
    use: TypeOnly<current.RootDataObject>);
use_current_ClassDeclaration_RootDataObject(
    get_old_ClassDeclaration_RootDataObject());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RootDataObject": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_RootDataObject():
    TypeOnly<current.RootDataObject>;
declare function use_old_ClassDeclaration_RootDataObject(
    use: TypeOnly<old.RootDataObject>);
use_old_ClassDeclaration_RootDataObject(
    get_current_ClassDeclaration_RootDataObject());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_RootDataObjectProps": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_RootDataObjectProps():
    TypeOnly<old.RootDataObjectProps>;
declare function use_current_InterfaceDeclaration_RootDataObjectProps(
    use: TypeOnly<current.RootDataObjectProps>);
use_current_InterfaceDeclaration_RootDataObjectProps(
    get_old_InterfaceDeclaration_RootDataObjectProps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_RootDataObjectProps": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_RootDataObjectProps():
    TypeOnly<current.RootDataObjectProps>;
declare function use_old_InterfaceDeclaration_RootDataObjectProps(
    use: TypeOnly<old.RootDataObjectProps>);
use_old_InterfaceDeclaration_RootDataObjectProps(
    get_current_InterfaceDeclaration_RootDataObjectProps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SequenceDeltaEvent": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SequenceDeltaEvent():
    TypeOnly<old.SequenceDeltaEvent>;
declare function use_current_ClassDeclaration_SequenceDeltaEvent(
    use: TypeOnly<current.SequenceDeltaEvent>);
use_current_ClassDeclaration_SequenceDeltaEvent(
    get_old_ClassDeclaration_SequenceDeltaEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SequenceDeltaEvent": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SequenceDeltaEvent():
    TypeOnly<current.SequenceDeltaEvent>;
declare function use_old_ClassDeclaration_SequenceDeltaEvent(
    use: TypeOnly<old.SequenceDeltaEvent>);
use_old_ClassDeclaration_SequenceDeltaEvent(
    get_current_ClassDeclaration_SequenceDeltaEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SequenceEvent": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SequenceEvent():
    TypeOnly<old.SequenceEvent>;
declare function use_current_ClassDeclaration_SequenceEvent(
    use: TypeOnly<current.SequenceEvent>);
use_current_ClassDeclaration_SequenceEvent(
    get_old_ClassDeclaration_SequenceEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SequenceEvent": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SequenceEvent():
    TypeOnly<current.SequenceEvent>;
declare function use_old_ClassDeclaration_SequenceEvent(
    use: TypeOnly<old.SequenceEvent>);
use_old_ClassDeclaration_SequenceEvent(
    get_current_ClassDeclaration_SequenceEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SequenceInterval": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SequenceInterval():
    TypeOnly<old.SequenceInterval>;
declare function use_current_ClassDeclaration_SequenceInterval(
    use: TypeOnly<current.SequenceInterval>);
use_current_ClassDeclaration_SequenceInterval(
    get_old_ClassDeclaration_SequenceInterval());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SequenceInterval": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SequenceInterval():
    TypeOnly<current.SequenceInterval>;
declare function use_old_ClassDeclaration_SequenceInterval(
    use: TypeOnly<old.SequenceInterval>);
use_old_ClassDeclaration_SequenceInterval(
    get_current_ClassDeclaration_SequenceInterval());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SequenceMaintenanceEvent": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SequenceMaintenanceEvent():
    TypeOnly<old.SequenceMaintenanceEvent>;
declare function use_current_ClassDeclaration_SequenceMaintenanceEvent(
    use: TypeOnly<current.SequenceMaintenanceEvent>);
use_current_ClassDeclaration_SequenceMaintenanceEvent(
    get_old_ClassDeclaration_SequenceMaintenanceEvent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SequenceMaintenanceEvent": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SequenceMaintenanceEvent():
    TypeOnly<current.SequenceMaintenanceEvent>;
declare function use_old_ClassDeclaration_SequenceMaintenanceEvent(
    use: TypeOnly<old.SequenceMaintenanceEvent>);
use_old_ClassDeclaration_SequenceMaintenanceEvent(
    get_current_ClassDeclaration_SequenceMaintenanceEvent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SerializedIntervalDelta": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SerializedIntervalDelta():
    TypeOnly<old.SerializedIntervalDelta>;
declare function use_current_TypeAliasDeclaration_SerializedIntervalDelta(
    use: TypeOnly<current.SerializedIntervalDelta>);
use_current_TypeAliasDeclaration_SerializedIntervalDelta(
    get_old_TypeAliasDeclaration_SerializedIntervalDelta());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SerializedIntervalDelta": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SerializedIntervalDelta():
    TypeOnly<current.SerializedIntervalDelta>;
declare function use_old_TypeAliasDeclaration_SerializedIntervalDelta(
    use: TypeOnly<old.SerializedIntervalDelta>);
use_old_TypeAliasDeclaration_SerializedIntervalDelta(
    get_current_TypeAliasDeclaration_SerializedIntervalDelta());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ServiceAudience": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ServiceAudience():
    TypeOnly<old.ServiceAudience>;
declare function use_current_ClassDeclaration_ServiceAudience(
    use: TypeOnly<current.ServiceAudience>);
use_current_ClassDeclaration_ServiceAudience(
    get_old_ClassDeclaration_ServiceAudience());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ServiceAudience": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ServiceAudience():
    TypeOnly<current.ServiceAudience>;
declare function use_old_ClassDeclaration_ServiceAudience(
    use: TypeOnly<old.ServiceAudience>);
use_old_ClassDeclaration_ServiceAudience(
    get_current_ClassDeclaration_ServiceAudience());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedDirectory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SharedDirectory():
    TypeOnly<old.SharedDirectory>;
declare function use_current_ClassDeclaration_SharedDirectory(
    use: TypeOnly<current.SharedDirectory>);
use_current_ClassDeclaration_SharedDirectory(
    get_old_ClassDeclaration_SharedDirectory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedDirectory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SharedDirectory():
    TypeOnly<current.SharedDirectory>;
declare function use_old_ClassDeclaration_SharedDirectory(
    use: TypeOnly<old.SharedDirectory>);
use_old_ClassDeclaration_SharedDirectory(
    get_current_ClassDeclaration_SharedDirectory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedIntervalCollection": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SharedIntervalCollection():
    TypeOnly<old.SharedIntervalCollection>;
declare function use_current_ClassDeclaration_SharedIntervalCollection(
    use: TypeOnly<current.SharedIntervalCollection>);
use_current_ClassDeclaration_SharedIntervalCollection(
    get_old_ClassDeclaration_SharedIntervalCollection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedIntervalCollection": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SharedIntervalCollection():
    TypeOnly<current.SharedIntervalCollection>;
declare function use_old_ClassDeclaration_SharedIntervalCollection(
    use: TypeOnly<old.SharedIntervalCollection>);
use_old_ClassDeclaration_SharedIntervalCollection(
    get_current_ClassDeclaration_SharedIntervalCollection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedIntervalCollectionFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SharedIntervalCollectionFactory():
    TypeOnly<old.SharedIntervalCollectionFactory>;
declare function use_current_ClassDeclaration_SharedIntervalCollectionFactory(
    use: TypeOnly<current.SharedIntervalCollectionFactory>);
use_current_ClassDeclaration_SharedIntervalCollectionFactory(
    get_old_ClassDeclaration_SharedIntervalCollectionFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedIntervalCollectionFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SharedIntervalCollectionFactory():
    TypeOnly<current.SharedIntervalCollectionFactory>;
declare function use_old_ClassDeclaration_SharedIntervalCollectionFactory(
    use: TypeOnly<old.SharedIntervalCollectionFactory>);
use_old_ClassDeclaration_SharedIntervalCollectionFactory(
    get_current_ClassDeclaration_SharedIntervalCollectionFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedMap": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SharedMap():
    TypeOnly<old.SharedMap>;
declare function use_current_ClassDeclaration_SharedMap(
    use: TypeOnly<current.SharedMap>);
use_current_ClassDeclaration_SharedMap(
    get_old_ClassDeclaration_SharedMap());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedMap": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SharedMap():
    TypeOnly<current.SharedMap>;
declare function use_old_ClassDeclaration_SharedMap(
    use: TypeOnly<old.SharedMap>);
use_old_ClassDeclaration_SharedMap(
    get_current_ClassDeclaration_SharedMap());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SharedObjectClass": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SharedObjectClass():
    TypeOnly<old.SharedObjectClass<any>>;
declare function use_current_TypeAliasDeclaration_SharedObjectClass(
    use: TypeOnly<current.SharedObjectClass<any>>);
use_current_TypeAliasDeclaration_SharedObjectClass(
    get_old_TypeAliasDeclaration_SharedObjectClass());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SharedObjectClass": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SharedObjectClass():
    TypeOnly<current.SharedObjectClass<any>>;
declare function use_old_TypeAliasDeclaration_SharedObjectClass(
    use: TypeOnly<old.SharedObjectClass<any>>);
use_old_TypeAliasDeclaration_SharedObjectClass(
    get_current_TypeAliasDeclaration_SharedObjectClass());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedSegmentSequence": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SharedSegmentSequence():
    TypeOnly<old.SharedSegmentSequence<any>>;
declare function use_current_ClassDeclaration_SharedSegmentSequence(
    use: TypeOnly<current.SharedSegmentSequence<any>>);
use_current_ClassDeclaration_SharedSegmentSequence(
    get_old_ClassDeclaration_SharedSegmentSequence());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedSegmentSequence": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SharedSegmentSequence():
    TypeOnly<current.SharedSegmentSequence<any>>;
declare function use_old_ClassDeclaration_SharedSegmentSequence(
    use: TypeOnly<old.SharedSegmentSequence<any>>);
use_old_ClassDeclaration_SharedSegmentSequence(
    get_current_ClassDeclaration_SharedSegmentSequence());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedSequence": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SharedSequence():
    TypeOnly<old.SharedSequence<any>>;
declare function use_current_ClassDeclaration_SharedSequence(
    use: TypeOnly<current.SharedSequence<any>>);
use_current_ClassDeclaration_SharedSequence(
    get_old_ClassDeclaration_SharedSequence());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedSequence": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SharedSequence():
    TypeOnly<current.SharedSequence<any>>;
declare function use_old_ClassDeclaration_SharedSequence(
    use: TypeOnly<old.SharedSequence<any>>);
use_old_ClassDeclaration_SharedSequence(
    get_current_ClassDeclaration_SharedSequence());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedString": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SharedString():
    TypeOnly<old.SharedString>;
declare function use_current_ClassDeclaration_SharedString(
    use: TypeOnly<current.SharedString>);
use_current_ClassDeclaration_SharedString(
    get_old_ClassDeclaration_SharedString());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedString": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SharedString():
    TypeOnly<current.SharedString>;
declare function use_old_ClassDeclaration_SharedString(
    use: TypeOnly<old.SharedString>);
use_old_ClassDeclaration_SharedString(
    get_current_ClassDeclaration_SharedString());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedStringFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SharedStringFactory():
    TypeOnly<old.SharedStringFactory>;
declare function use_current_ClassDeclaration_SharedStringFactory(
    use: TypeOnly<current.SharedStringFactory>);
use_current_ClassDeclaration_SharedStringFactory(
    get_old_ClassDeclaration_SharedStringFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SharedStringFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SharedStringFactory():
    TypeOnly<current.SharedStringFactory>;
declare function use_old_ClassDeclaration_SharedStringFactory(
    use: TypeOnly<old.SharedStringFactory>);
use_old_ClassDeclaration_SharedStringFactory(
    get_current_ClassDeclaration_SharedStringFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SharedStringSegment": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_SharedStringSegment():
    TypeOnly<old.SharedStringSegment>;
declare function use_current_TypeAliasDeclaration_SharedStringSegment(
    use: TypeOnly<current.SharedStringSegment>);
use_current_TypeAliasDeclaration_SharedStringSegment(
    get_old_TypeAliasDeclaration_SharedStringSegment());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_SharedStringSegment": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_SharedStringSegment():
    TypeOnly<current.SharedStringSegment>;
declare function use_old_TypeAliasDeclaration_SharedStringSegment(
    use: TypeOnly<old.SharedStringSegment>);
use_old_TypeAliasDeclaration_SharedStringSegment(
    get_current_TypeAliasDeclaration_SharedStringSegment());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SubSequence": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SubSequence():
    TypeOnly<old.SubSequence<any>>;
declare function use_current_ClassDeclaration_SubSequence(
    use: TypeOnly<current.SubSequence<any>>);
use_current_ClassDeclaration_SubSequence(
    get_old_ClassDeclaration_SubSequence());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SubSequence": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SubSequence():
    TypeOnly<current.SubSequence<any>>;
declare function use_old_ClassDeclaration_SubSequence(
    use: TypeOnly<old.SubSequence<any>>);
use_old_ClassDeclaration_SubSequence(
    get_current_ClassDeclaration_SubSequence());
