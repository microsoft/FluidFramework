{"version":3,"file":"storage.js","sourceRoot":"","sources":["../src/storage.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAmMH,MAAM,CAAN,IAAY,mBAUX;AAVD,WAAY,mBAAmB;IAC3B;;OAEG;IACH,uEAAS,CAAA;IAET;;OAEG;IACH,qEAAQ,CAAA;AACZ,CAAC,EAVW,mBAAmB,KAAnB,mBAAmB,QAU9B","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IEventProvider, IErrorEvent, ITelemetryBaseLogger } from \"@fluidframework/common-definitions\";\nimport {\n    ConnectionMode,\n    IClient,\n    IClientConfiguration,\n    ICreateBlobResponse,\n    IDocumentMessage,\n    IErrorTrackingService,\n    INack,\n    ISequencedDocumentMessage,\n    ISignalClient,\n    ISignalMessage,\n    ISnapshotTree,\n    ISummaryHandle,\n    ISummaryTree,\n    ITokenClaims,\n    ITree,\n    IVersion,\n} from \"@fluidframework/protocol-definitions\";\nimport { IResolvedUrl } from \"./urlResolver\";\n\nexport interface IDeltasFetchResult {\n    /**\n     * Sequential set of messages starting from 'from' sequence number.\n     * May be partial result, i.e. not fulfill original request in full.\n     */\n    messages: ISequencedDocumentMessage[];\n\n    /**\n     * If true, storage only partially fulfilled request, but has more ops\n     * If false, the request was fulfilled. If less ops were returned then\n     * requested, then storage does not have more ops in this range.\n     */\n    partialResult: boolean;\n}\n\n/**\n * Interface to provide access to stored deltas for a shared object\n */\nexport interface IDeltaStorageService {\n    /**\n     * Retrieves all the delta operations within the inclusive sequence number range\n     */\n    get(\n        tenantId: string,\n        id: string,\n        from: number,\n        to: number): Promise<IDeltasFetchResult>;\n}\n\n/**\n * Interface to provide access to stored deltas for a shared object\n */\nexport interface IDocumentDeltaStorageService {\n    /**\n     * Retrieves all the delta operations within the exclusive sequence number range\n     */\n    get(from: number, to: number): Promise<IDeltasFetchResult>;\n}\n\n/**\n * Interface to provide access to snapshots saved for a shared object\n */\nexport interface IDocumentStorageService {\n    repositoryUrl: string;\n\n    /**\n     * Returns the snapshot tree.\n     */\n    getSnapshotTree(version?: IVersion): Promise<ISnapshotTree | null>;\n\n    /**\n     * Retrieves all versions of the document starting at the specified versionId - or null if from the head\n     */\n    getVersions(versionId: string | null, count: number): Promise<IVersion[]>;\n\n    /**\n     * Reads the object with the given ID, returns content in base64\n     */\n    read(id: string): Promise<string>;\n\n    /**\n     * Writes to the object with the given ID\n     */\n    write(root: ITree, parents: string[], message: string, ref: string): Promise<IVersion>;\n\n    /**\n     * Creates a blob out of the given buffer\n     */\n    createBlob(file: ArrayBufferLike): Promise<ICreateBlobResponse>;\n\n    readBlob(id: string): Promise<ArrayBufferLike>;\n\n    /**\n     * Uploads a summary tree to storage using the given context for reference of previous summary handle.\n     * The ISummaryHandles in the uploaded tree should have paths to indicate which summary object they are\n     * referencing from the previously acked summary.\n     * Returns the uploaded summary handle.\n     */\n    uploadSummaryWithContext(summary: ISummaryTree, context: ISummaryContext): Promise<string>;\n\n    /**\n     * Retrieves the commit that matches the packfile handle. If the packfile has already been committed and the\n     * server has deleted it this call may result in a broken promise.\n     */\n    downloadSummary(handle: ISummaryHandle): Promise<ISummaryTree>;\n}\n\nexport interface IDocumentDeltaConnectionEvents extends IErrorEvent {\n    (event: \"nack\", listener: (documentId: string, message: INack[]) => void);\n    (event: \"disconnect\", listener: (reason: any) => void);\n    (event: \"op\", listener: (documentId: string, messages: ISequencedDocumentMessage[]) => void);\n    (event: \"signal\", listener: (message: ISignalMessage) => void);\n    (event: \"pong\", listener: (latency: number) => void);\n    (event: \"error\", listener: (error: any) => void);\n}\n\nexport interface IDocumentDeltaConnection extends IEventProvider<IDocumentDeltaConnectionEvents> {\n    /**\n     * ClientID for the connection\n     */\n    clientId: string;\n\n    /**\n     * Claims for the client\n     */\n    claims: ITokenClaims;\n\n    /**\n     * Mode of the client\n     */\n    mode: ConnectionMode;\n\n    /**\n     * Whether the connection was made to a new or existing document\n     */\n    existing: boolean;\n\n    /**\n     * Maximum size of a message that can be sent to the server. Messages larger than this size must be chunked.\n     */\n    maxMessageSize: number;\n\n    /**\n     * Protocol version being used with the service\n     */\n    version: string;\n\n    /**\n     * Messages sent during the connection\n     */\n    initialMessages: ISequencedDocumentMessage[];\n\n    /**\n     * Signals sent during the connection\n     */\n    initialSignals: ISignalMessage[];\n\n    /**\n     * Prior clients already connected.\n     */\n    initialClients: ISignalClient[];\n\n    /**\n     * Configuration details provided by the service\n     */\n    serviceConfiguration: IClientConfiguration;\n\n    /**\n     * Last known sequence number to ordering service at the time of connection\n     * It may lap actual last sequence number (quite a bit, if container  is very active).\n     * But it's best information for client to figure out how far it is behind, at least\n     * for \"read\" connections. \"write\" connections may use own \"join\" op to similar information,\n     * that is likely to be more up-to-date.\n     */\n    checkpointSequenceNumber?: number;\n\n    /**\n     * Submit a new message to the server\n     */\n    submit(messages: IDocumentMessage[]): void;\n\n    /**\n     * Submit a new signal to the server\n     */\n    submitSignal(message: any): void;\n\n    /**\n     * Disconnects the given delta connection\n     */\n    close(): void;\n}\n\nexport enum LoaderCachingPolicy {\n    /**\n     * The loader should not implement any prefetching or caching policy.\n     */\n    NoCaching,\n\n    /**\n     * The loader should implement prefetching policy, i.e. it should prefetch resources from the latest snapshot.\n     */\n    Prefetch,\n}\n\nexport interface IDocumentServicePolicies {\n    readonly caching?: LoaderCachingPolicy;\n}\n\nexport interface IDocumentService {\n\n    resolvedUrl: IResolvedUrl;\n\n    /**\n     * Policies implemented/instructed by driver.\n     */\n    policies?: IDocumentServicePolicies;\n\n    /**\n     * Access to storage associated with the document...\n     */\n    connectToStorage(): Promise<IDocumentStorageService>;\n\n    /**\n     * Access to delta storage associated with the document\n     */\n    connectToDeltaStorage(): Promise<IDocumentDeltaStorageService>;\n\n    /**\n     * Subscribes to the document delta stream\n     */\n    connectToDeltaStream(client: IClient): Promise<IDocumentDeltaConnection>;\n\n    /**\n     * Returns the error tracking service\n     */\n    getErrorTrackingService(): IErrorTrackingService | null;\n\n}\n\nexport interface IDocumentServiceFactory {\n    /**\n     * Name of the protocol used by factory\n     */\n    protocolName: string;\n\n    /**\n     * Returns an instance of IDocumentService\n     */\n    createDocumentService(resolvedUrl: IResolvedUrl, logger?: ITelemetryBaseLogger): Promise<IDocumentService>;\n\n    // Creates a new document on the host with the provided options. Returns the document service.\n    createContainer(\n        createNewSummary: ISummaryTree,\n        createNewResolvedUrl: IResolvedUrl,\n        logger?: ITelemetryBaseLogger,\n    ): Promise<IDocumentService>;\n}\n\n/**\n * Context for uploading a summary to storage.\n * Indicates the previously acked summary.\n */\nexport interface ISummaryContext {\n    /**\n     * Parent summary proposed handle (from summary op)\n     */\n    readonly proposalHandle: string | undefined;\n\n    /**\n     * Parent summary acked handle (from summary ack)\n     */\n    readonly ackHandle: string | undefined;\n}\n"]}