{"version":3,"file":"urlResolver.js","sourceRoot":"","sources":["../src/urlResolver.ts"],"names":[],"mappings":"AAAA;;;GAGG;AA4DH;;GAEG;AACH,MAAM,CAAN,IAAY,YAKX;AALD,WAAY,YAAY;IACpB,qDAAqD;IACrD,6DAA6C,CAAA;IAC7C,iDAAiD;IACjD,uCAAuB,CAAA;AAC3B,CAAC,EALW,YAAY,KAAZ,YAAY,QAKvB","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IRequest, IFluidCodeDetails } from \"@fluidframework/core-interfaces\";\n\nexport type IResolvedUrl = IWebResolvedUrl | IFluidResolvedUrl;\n\nexport interface IResolvedUrlBase {\n    type: string;\n}\n\nexport interface IWebResolvedUrl extends IResolvedUrlBase {\n    type: \"web\";\n    data: string;\n}\n\nexport interface IFluidResolvedUrl extends IResolvedUrlBase {\n    type: \"fluid\";\n    url: string;\n    tokens: { [name: string]: string };\n    endpoints: { [name: string]: string };\n}\n\nexport interface IUrlResolver {\n\n    // Like DNS should be able to cache resolution requests. Then possibly just have a token provider go and do stuff?\n    // the expiration of it could be relative to the lifetime of the token? Requests after need to refresh?\n    // or do we split the token access from this?\n    resolve(request: IRequest): Promise<IResolvedUrl | undefined>;\n\n    // Creates a url for the created container with any data store path given in the relative url.\n    getAbsoluteUrl(\n        resolvedUrl: IResolvedUrl,\n        relativeUrl: string,\n        codeDetails?: IFluidCodeDetails,\n    ): Promise<string>;\n}\n\n/**\n* Information that can be returned by a lightweight, seperately exported driver function. Used to preanalyze a URL\n* for driver compatibility and preload information.\n*/\nexport interface DriverPreCheckInfo {\n    /**\n     * @deprecated - only needed as long as long as Loader.request() does not work as intended. When\n     * Loader.request() caches and resolves pathing properly, this can be removed. #4489, #4491\n     */\n    containerPath: string;\n\n    /**\n     * A code details hint that can potentially be used to prefetch container code prior to having a snapshot.\n     */\n    codeDetailsHint?: string;\n\n    /**\n     * Domains that will be connected to on the critical boot path. Hosts can choose to preconnect to these for\n     * improved performance.\n     */\n    criticalBootDomains?: string[];\n  }\n\n/**\n * Additional key in the loader request header\n */\nexport enum DriverHeader {\n    // Key to indicate whether the request for summarizer\n    summarizingClient = \"fluid-client-summarizer\",\n    // createNew information, specific to each driver\n    createNew = \"createNew\",\n}\n\nexport interface IDriverHeader {\n    [DriverHeader.summarizingClient]: boolean;\n    [DriverHeader.createNew]: any;\n}\n\ndeclare module \"@fluidframework/core-interfaces\" {\n    // eslint-disable-next-line @typescript-eslint/no-empty-interface\n    export interface IRequestHeader extends Partial<IDriverHeader> { }\n}\n"]}