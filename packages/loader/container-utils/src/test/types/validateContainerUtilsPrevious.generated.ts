/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/container-utils-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ClientSessionExpiredError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ClientSessionExpiredError = requireAssignableTo<TypeOnly<old.ClientSessionExpiredError>, TypeOnly<current.ClientSessionExpiredError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ClientSessionExpiredError": {"backCompat": false}
 */
declare type current_as_old_for_Class_ClientSessionExpiredError = requireAssignableTo<TypeOnly<current.ClientSessionExpiredError>, TypeOnly<old.ClientSessionExpiredError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DataCorruptionError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DataCorruptionError = requireAssignableTo<TypeOnly<old.DataCorruptionError>, TypeOnly<current.DataCorruptionError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DataCorruptionError": {"backCompat": false}
 */
declare type current_as_old_for_Class_DataCorruptionError = requireAssignableTo<TypeOnly<current.DataCorruptionError>, TypeOnly<old.DataCorruptionError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DataProcessingError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DataProcessingError = requireAssignableTo<TypeOnly<old.DataProcessingError>, TypeOnly<current.DataProcessingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DataProcessingError": {"backCompat": false}
 */
declare type current_as_old_for_Class_DataProcessingError = requireAssignableTo<TypeOnly<current.DataProcessingError>, TypeOnly<old.DataProcessingError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_GenericError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_GenericError = requireAssignableTo<TypeOnly<old.GenericError>, TypeOnly<current.GenericError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_GenericError": {"backCompat": false}
 */
declare type current_as_old_for_Class_GenericError = requireAssignableTo<TypeOnly<current.GenericError>, TypeOnly<old.GenericError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ThrottlingWarning": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ThrottlingWarning = requireAssignableTo<TypeOnly<old.ThrottlingWarning>, TypeOnly<current.ThrottlingWarning>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ThrottlingWarning": {"backCompat": false}
 */
declare type current_as_old_for_Class_ThrottlingWarning = requireAssignableTo<TypeOnly<current.ThrottlingWarning>, TypeOnly<old.ThrottlingWarning>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_UsageError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_UsageError = requireAssignableTo<TypeOnly<old.UsageError>, TypeOnly<current.UsageError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_UsageError": {"backCompat": false}
 */
declare type current_as_old_for_Class_UsageError = requireAssignableTo<TypeOnly<current.UsageError>, TypeOnly<old.UsageError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ClientSessionExpiredError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ClientSessionExpiredError = requireAssignableTo<TypeOnly<typeof current.ClientSessionExpiredError>, TypeOnly<typeof old.ClientSessionExpiredError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DataCorruptionError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DataCorruptionError = requireAssignableTo<TypeOnly<typeof current.DataCorruptionError>, TypeOnly<typeof old.DataCorruptionError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DataProcessingError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DataProcessingError = requireAssignableTo<TypeOnly<typeof current.DataProcessingError>, TypeOnly<typeof old.DataProcessingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_GenericError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_GenericError = requireAssignableTo<TypeOnly<typeof current.GenericError>, TypeOnly<typeof old.GenericError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ThrottlingWarning": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ThrottlingWarning = requireAssignableTo<TypeOnly<typeof current.ThrottlingWarning>, TypeOnly<typeof old.ThrottlingWarning>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_UsageError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_UsageError = requireAssignableTo<TypeOnly<typeof current.UsageError>, TypeOnly<typeof old.UsageError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_extractSafePropertiesFromMessage": {"backCompat": false}
 */
declare type current_as_old_for_Variable_extractSafePropertiesFromMessage = requireAssignableTo<TypeOnly<typeof current.extractSafePropertiesFromMessage>, TypeOnly<typeof old.extractSafePropertiesFromMessage>>
