/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/driver-utils-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_AuthorizationError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_AuthorizationError = requireAssignableTo<TypeOnly<old.AuthorizationError>, TypeOnly<current.AuthorizationError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_AuthorizationError": {"backCompat": false}
 */
declare type current_as_old_for_Class_AuthorizationError = requireAssignableTo<TypeOnly<current.AuthorizationError>, TypeOnly<old.AuthorizationError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BlobAggregationStorage": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_BlobAggregationStorage = requireAssignableTo<TypeOnly<old.BlobAggregationStorage>, TypeOnly<current.BlobAggregationStorage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BlobAggregationStorage": {"backCompat": false}
 */
declare type current_as_old_for_Class_BlobAggregationStorage = requireAssignableTo<TypeOnly<current.BlobAggregationStorage>, TypeOnly<old.BlobAggregationStorage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BlobCacheStorageService": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_BlobCacheStorageService = requireAssignableTo<TypeOnly<old.BlobCacheStorageService>, TypeOnly<current.BlobCacheStorageService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BlobCacheStorageService": {"backCompat": false}
 */
declare type current_as_old_for_Class_BlobCacheStorageService = requireAssignableTo<TypeOnly<current.BlobCacheStorageService>, TypeOnly<old.BlobCacheStorageService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DeltaStreamConnectionForbiddenError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DeltaStreamConnectionForbiddenError = requireAssignableTo<TypeOnly<old.DeltaStreamConnectionForbiddenError>, TypeOnly<current.DeltaStreamConnectionForbiddenError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DeltaStreamConnectionForbiddenError": {"backCompat": false}
 */
declare type current_as_old_for_Class_DeltaStreamConnectionForbiddenError = requireAssignableTo<TypeOnly<current.DeltaStreamConnectionForbiddenError>, TypeOnly<old.DeltaStreamConnectionForbiddenError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DocumentStorageServiceProxy": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DocumentStorageServiceProxy = requireAssignableTo<TypeOnly<old.DocumentStorageServiceProxy>, TypeOnly<current.DocumentStorageServiceProxy>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DocumentStorageServiceProxy": {"backCompat": false}
 */
declare type current_as_old_for_Class_DocumentStorageServiceProxy = requireAssignableTo<TypeOnly<current.DocumentStorageServiceProxy>, TypeOnly<old.DocumentStorageServiceProxy>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_EmptyDocumentDeltaStorageService": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_EmptyDocumentDeltaStorageService = requireAssignableTo<TypeOnly<old.EmptyDocumentDeltaStorageService>, TypeOnly<current.EmptyDocumentDeltaStorageService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_EmptyDocumentDeltaStorageService": {"backCompat": false}
 */
declare type current_as_old_for_Class_EmptyDocumentDeltaStorageService = requireAssignableTo<TypeOnly<current.EmptyDocumentDeltaStorageService>, TypeOnly<old.EmptyDocumentDeltaStorageService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_GenericNetworkError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_GenericNetworkError = requireAssignableTo<TypeOnly<old.GenericNetworkError>, TypeOnly<current.GenericNetworkError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_GenericNetworkError": {"backCompat": false}
 */
declare type current_as_old_for_Class_GenericNetworkError = requireAssignableTo<TypeOnly<current.GenericNetworkError>, TypeOnly<old.GenericNetworkError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_InsecureUrlResolver": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_InsecureUrlResolver = requireAssignableTo<TypeOnly<old.InsecureUrlResolver>, TypeOnly<current.InsecureUrlResolver>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_InsecureUrlResolver": {"backCompat": false}
 */
declare type current_as_old_for_Class_InsecureUrlResolver = requireAssignableTo<TypeOnly<current.InsecureUrlResolver>, TypeOnly<old.InsecureUrlResolver>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MultiDocumentServiceFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MultiDocumentServiceFactory = requireAssignableTo<TypeOnly<old.MultiDocumentServiceFactory>, TypeOnly<current.MultiDocumentServiceFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MultiDocumentServiceFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_MultiDocumentServiceFactory = requireAssignableTo<TypeOnly<current.MultiDocumentServiceFactory>, TypeOnly<old.MultiDocumentServiceFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MultiUrlResolver": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MultiUrlResolver = requireAssignableTo<TypeOnly<old.MultiUrlResolver>, TypeOnly<current.MultiUrlResolver>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MultiUrlResolver": {"backCompat": false}
 */
declare type current_as_old_for_Class_MultiUrlResolver = requireAssignableTo<TypeOnly<current.MultiUrlResolver>, TypeOnly<old.MultiUrlResolver>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NetworkErrorBasic": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_NetworkErrorBasic = requireAssignableTo<TypeOnly<old.NetworkErrorBasic<never>>, TypeOnly<current.NetworkErrorBasic<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NetworkErrorBasic": {"backCompat": false}
 */
declare type current_as_old_for_Class_NetworkErrorBasic = requireAssignableTo<TypeOnly<current.NetworkErrorBasic<never>>, TypeOnly<old.NetworkErrorBasic<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NonRetryableError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_NonRetryableError = requireAssignableTo<TypeOnly<old.NonRetryableError<never>>, TypeOnly<current.NonRetryableError<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NonRetryableError": {"backCompat": false}
 */
declare type current_as_old_for_Class_NonRetryableError = requireAssignableTo<TypeOnly<current.NonRetryableError<never>>, TypeOnly<old.NonRetryableError<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ParallelRequests": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ParallelRequests = requireAssignableTo<TypeOnly<old.ParallelRequests<never>>, TypeOnly<current.ParallelRequests<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ParallelRequests": {"backCompat": false}
 */
declare type current_as_old_for_Class_ParallelRequests = requireAssignableTo<TypeOnly<current.ParallelRequests<never>>, TypeOnly<old.ParallelRequests<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PrefetchDocumentStorageService": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_PrefetchDocumentStorageService = requireAssignableTo<TypeOnly<old.PrefetchDocumentStorageService>, TypeOnly<current.PrefetchDocumentStorageService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PrefetchDocumentStorageService": {"backCompat": false}
 */
declare type current_as_old_for_Class_PrefetchDocumentStorageService = requireAssignableTo<TypeOnly<current.PrefetchDocumentStorageService>, TypeOnly<old.PrefetchDocumentStorageService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Queue": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Queue = requireAssignableTo<TypeOnly<old.Queue<never>>, TypeOnly<current.Queue<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Queue": {"backCompat": false}
 */
declare type current_as_old_for_Class_Queue = requireAssignableTo<TypeOnly<current.Queue<never>>, TypeOnly<old.Queue<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RateLimiter": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RateLimiter = requireAssignableTo<TypeOnly<old.RateLimiter>, TypeOnly<current.RateLimiter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RateLimiter": {"backCompat": false}
 */
declare type current_as_old_for_Class_RateLimiter = requireAssignableTo<TypeOnly<current.RateLimiter>, TypeOnly<old.RateLimiter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RetryableError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RetryableError = requireAssignableTo<TypeOnly<old.RetryableError<never>>, TypeOnly<current.RetryableError<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RetryableError": {"backCompat": false}
 */
declare type current_as_old_for_Class_RetryableError = requireAssignableTo<TypeOnly<current.RetryableError<never>>, TypeOnly<old.RetryableError<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SnapshotExtractor": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SnapshotExtractor = requireAssignableTo<TypeOnly<old.SnapshotExtractor>, TypeOnly<current.SnapshotExtractor>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SnapshotExtractor": {"backCompat": false}
 */
declare type current_as_old_for_Class_SnapshotExtractor = requireAssignableTo<TypeOnly<current.SnapshotExtractor>, TypeOnly<old.SnapshotExtractor>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SummaryTreeAssembler": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SummaryTreeAssembler = requireAssignableTo<TypeOnly<old.SummaryTreeAssembler>, TypeOnly<current.SummaryTreeAssembler>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SummaryTreeAssembler": {"backCompat": false}
 */
declare type current_as_old_for_Class_SummaryTreeAssembler = requireAssignableTo<TypeOnly<current.SummaryTreeAssembler>, TypeOnly<old.SummaryTreeAssembler>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ThrottlingError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ThrottlingError = requireAssignableTo<TypeOnly<old.ThrottlingError>, TypeOnly<current.ThrottlingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ThrottlingError": {"backCompat": false}
 */
declare type current_as_old_for_Class_ThrottlingError = requireAssignableTo<TypeOnly<current.ThrottlingError>, TypeOnly<old.ThrottlingError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_UsageError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_UsageError = requireAssignableTo<TypeOnly<old.UsageError>, TypeOnly<current.UsageError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_UsageError": {"backCompat": false}
 */
declare type current_as_old_for_Class_UsageError = requireAssignableTo<TypeOnly<current.UsageError>, TypeOnly<old.UsageError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_AuthorizationError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_AuthorizationError = requireAssignableTo<TypeOnly<typeof current.AuthorizationError>, TypeOnly<typeof old.AuthorizationError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_BlobAggregationStorage": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_BlobAggregationStorage = requireAssignableTo<TypeOnly<typeof current.BlobAggregationStorage>, TypeOnly<typeof old.BlobAggregationStorage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_BlobCacheStorageService": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_BlobCacheStorageService = requireAssignableTo<TypeOnly<typeof current.BlobCacheStorageService>, TypeOnly<typeof old.BlobCacheStorageService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DeltaStreamConnectionForbiddenError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DeltaStreamConnectionForbiddenError = requireAssignableTo<TypeOnly<typeof current.DeltaStreamConnectionForbiddenError>, TypeOnly<typeof old.DeltaStreamConnectionForbiddenError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DocumentStorageServiceProxy": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DocumentStorageServiceProxy = requireAssignableTo<TypeOnly<typeof current.DocumentStorageServiceProxy>, TypeOnly<typeof old.DocumentStorageServiceProxy>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_EmptyDocumentDeltaStorageService": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_EmptyDocumentDeltaStorageService = requireAssignableTo<TypeOnly<typeof current.EmptyDocumentDeltaStorageService>, TypeOnly<typeof old.EmptyDocumentDeltaStorageService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_GenericNetworkError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_GenericNetworkError = requireAssignableTo<TypeOnly<typeof current.GenericNetworkError>, TypeOnly<typeof old.GenericNetworkError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_InsecureUrlResolver": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_InsecureUrlResolver = requireAssignableTo<TypeOnly<typeof current.InsecureUrlResolver>, TypeOnly<typeof old.InsecureUrlResolver>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MultiDocumentServiceFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MultiDocumentServiceFactory = requireAssignableTo<TypeOnly<typeof current.MultiDocumentServiceFactory>, TypeOnly<typeof old.MultiDocumentServiceFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MultiUrlResolver": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MultiUrlResolver = requireAssignableTo<TypeOnly<typeof current.MultiUrlResolver>, TypeOnly<typeof old.MultiUrlResolver>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_NetworkErrorBasic": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_NetworkErrorBasic = requireAssignableTo<TypeOnly<typeof current.NetworkErrorBasic>, TypeOnly<typeof old.NetworkErrorBasic>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_NonRetryableError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_NonRetryableError = requireAssignableTo<TypeOnly<typeof current.NonRetryableError>, TypeOnly<typeof old.NonRetryableError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ParallelRequests": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ParallelRequests = requireAssignableTo<TypeOnly<typeof current.ParallelRequests>, TypeOnly<typeof old.ParallelRequests>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_PrefetchDocumentStorageService": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_PrefetchDocumentStorageService = requireAssignableTo<TypeOnly<typeof current.PrefetchDocumentStorageService>, TypeOnly<typeof old.PrefetchDocumentStorageService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Queue": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Queue = requireAssignableTo<TypeOnly<typeof current.Queue>, TypeOnly<typeof old.Queue>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RateLimiter": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RateLimiter = requireAssignableTo<TypeOnly<typeof current.RateLimiter>, TypeOnly<typeof old.RateLimiter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RetryableError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RetryableError = requireAssignableTo<TypeOnly<typeof current.RetryableError>, TypeOnly<typeof old.RetryableError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SnapshotExtractor": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SnapshotExtractor = requireAssignableTo<TypeOnly<typeof current.SnapshotExtractor>, TypeOnly<typeof old.SnapshotExtractor>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SummaryTreeAssembler": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SummaryTreeAssembler = requireAssignableTo<TypeOnly<typeof current.SummaryTreeAssembler>, TypeOnly<typeof old.SummaryTreeAssembler>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ThrottlingError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ThrottlingError = requireAssignableTo<TypeOnly<typeof current.ThrottlingError>, TypeOnly<typeof old.ThrottlingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_UsageError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_UsageError = requireAssignableTo<TypeOnly<typeof current.UsageError>, TypeOnly<typeof old.UsageError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_OnlineStatus": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_OnlineStatus = requireAssignableTo<TypeOnly<old.OnlineStatus>, TypeOnly<current.OnlineStatus>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_OnlineStatus": {"backCompat": false}
 */
declare type current_as_old_for_Enum_OnlineStatus = requireAssignableTo<TypeOnly<current.OnlineStatus>, TypeOnly<old.OnlineStatus>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_buildSnapshotTree": {"backCompat": false}
 */
declare type current_as_old_for_Function_buildSnapshotTree = requireAssignableTo<TypeOnly<typeof current.buildSnapshotTree>, TypeOnly<typeof old.buildSnapshotTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_combineAppAndProtocolSummary": {"backCompat": false}
 */
declare type current_as_old_for_Function_combineAppAndProtocolSummary = requireAssignableTo<TypeOnly<typeof current.combineAppAndProtocolSummary>, TypeOnly<typeof old.combineAppAndProtocolSummary>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_configurableUrlResolver": {"backCompat": false}
 */
declare type current_as_old_for_Function_configurableUrlResolver = requireAssignableTo<TypeOnly<typeof current.configurableUrlResolver>, TypeOnly<typeof old.configurableUrlResolver>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_convertSnapshotAndBlobsToSummaryTree": {"backCompat": false}
 */
declare type current_as_old_for_Function_convertSnapshotAndBlobsToSummaryTree = requireAssignableTo<TypeOnly<typeof current.convertSnapshotAndBlobsToSummaryTree>, TypeOnly<typeof old.convertSnapshotAndBlobsToSummaryTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_convertSummaryTreeToSnapshotITree": {"backCompat": false}
 */
declare type current_as_old_for_Function_convertSummaryTreeToSnapshotITree = requireAssignableTo<TypeOnly<typeof current.convertSummaryTreeToSnapshotITree>, TypeOnly<typeof old.convertSummaryTreeToSnapshotITree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createGenericNetworkError": {"backCompat": false}
 */
declare type current_as_old_for_Function_createGenericNetworkError = requireAssignableTo<TypeOnly<typeof current.createGenericNetworkError>, TypeOnly<typeof old.createGenericNetworkError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_ensureFluidResolvedUrl": {"backCompat": false}
 */
declare type current_as_old_for_Function_ensureFluidResolvedUrl = requireAssignableTo<TypeOnly<typeof current.ensureFluidResolvedUrl>, TypeOnly<typeof old.ensureFluidResolvedUrl>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getDocAttributesFromProtocolSummary": {"backCompat": false}
 */
declare type current_as_old_for_Function_getDocAttributesFromProtocolSummary = requireAssignableTo<TypeOnly<typeof current.getDocAttributesFromProtocolSummary>, TypeOnly<typeof old.getDocAttributesFromProtocolSummary>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getQuorumValuesFromProtocolSummary": {"backCompat": false}
 */
declare type current_as_old_for_Function_getQuorumValuesFromProtocolSummary = requireAssignableTo<TypeOnly<typeof current.getQuorumValuesFromProtocolSummary>, TypeOnly<typeof old.getQuorumValuesFromProtocolSummary>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isClientMessage": {"backCompat": false}
 */
declare type current_as_old_for_Function_isClientMessage = requireAssignableTo<TypeOnly<typeof current.isClientMessage>, TypeOnly<typeof old.isClientMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isOnline": {"backCompat": false}
 */
declare type current_as_old_for_Function_isOnline = requireAssignableTo<TypeOnly<typeof current.isOnline>, TypeOnly<typeof old.isOnline>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isRuntimeMessage": {"backCompat": false}
 */
declare type current_as_old_for_Function_isRuntimeMessage = requireAssignableTo<TypeOnly<typeof current.isRuntimeMessage>, TypeOnly<typeof old.isRuntimeMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isUnpackedRuntimeMessage": {"backCompat": false}
 */
declare type current_as_old_for_Function_isUnpackedRuntimeMessage = requireAssignableTo<TypeOnly<typeof current.isUnpackedRuntimeMessage>, TypeOnly<typeof old.isUnpackedRuntimeMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_logNetworkFailure": {"backCompat": false}
 */
declare type current_as_old_for_Function_logNetworkFailure = requireAssignableTo<TypeOnly<typeof current.logNetworkFailure>, TypeOnly<typeof old.logNetworkFailure>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_readAndParse": {"backCompat": false}
 */
declare type current_as_old_for_Function_readAndParse = requireAssignableTo<TypeOnly<typeof current.readAndParse>, TypeOnly<typeof old.readAndParse>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_requestOps": {"backCompat": false}
 */
declare type current_as_old_for_Function_requestOps = requireAssignableTo<TypeOnly<typeof current.requestOps>, TypeOnly<typeof old.requestOps>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_runWithRetry": {"backCompat": false}
 */
declare type current_as_old_for_Function_runWithRetry = requireAssignableTo<TypeOnly<typeof current.runWithRetry>, TypeOnly<typeof old.runWithRetry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_streamFromMessages": {"backCompat": false}
 */
declare type current_as_old_for_Function_streamFromMessages = requireAssignableTo<TypeOnly<typeof current.streamFromMessages>, TypeOnly<typeof old.streamFromMessages>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_streamObserver": {"backCompat": false}
 */
declare type current_as_old_for_Function_streamObserver = requireAssignableTo<TypeOnly<typeof current.streamObserver>, TypeOnly<typeof old.streamObserver>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_waitForConnectedState": {"backCompat": false}
 */
declare type current_as_old_for_Function_waitForConnectedState = requireAssignableTo<TypeOnly<typeof current.waitForConnectedState>, TypeOnly<typeof old.waitForConnectedState>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAnyDriverError": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IAnyDriverError = requireAssignableTo<TypeOnly<old.IAnyDriverError>, TypeOnly<current.IAnyDriverError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAnyDriverError": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IAnyDriverError = requireAssignableTo<TypeOnly<current.IAnyDriverError>, TypeOnly<old.IAnyDriverError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProgress": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IProgress = requireAssignableTo<TypeOnly<old.IProgress>, TypeOnly<current.IProgress>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProgress": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProgress = requireAssignableTo<TypeOnly<current.IProgress>, TypeOnly<old.IProgress>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryTreeAssemblerProps": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryTreeAssemblerProps = requireAssignableTo<TypeOnly<old.ISummaryTreeAssemblerProps>, TypeOnly<current.ISummaryTreeAssemblerProps>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryTreeAssemblerProps": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryTreeAssemblerProps = requireAssignableTo<TypeOnly<current.ISummaryTreeAssemblerProps>, TypeOnly<old.ISummaryTreeAssemblerProps>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_DriverErrorTelemetryProps": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_DriverErrorTelemetryProps = requireAssignableTo<TypeOnly<old.DriverErrorTelemetryProps>, TypeOnly<current.DriverErrorTelemetryProps>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_DriverErrorTelemetryProps": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_DriverErrorTelemetryProps = requireAssignableTo<TypeOnly<current.DriverErrorTelemetryProps>, TypeOnly<old.DriverErrorTelemetryProps>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_canRetryOnError": {"backCompat": false}
 */
declare type current_as_old_for_Variable_canRetryOnError = requireAssignableTo<TypeOnly<typeof current.canRetryOnError>, TypeOnly<typeof old.canRetryOnError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_createWriteError": {"backCompat": false}
 */
declare type current_as_old_for_Variable_createWriteError = requireAssignableTo<TypeOnly<typeof current.createWriteError>, TypeOnly<typeof old.createWriteError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_emptyMessageStream": {"backCompat": false}
 */
declare type current_as_old_for_Variable_emptyMessageStream = requireAssignableTo<TypeOnly<typeof current.emptyMessageStream>, TypeOnly<typeof old.emptyMessageStream>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_getRetryDelayFromError": {"backCompat": false}
 */
declare type current_as_old_for_Variable_getRetryDelayFromError = requireAssignableTo<TypeOnly<typeof current.getRetryDelayFromError>, TypeOnly<typeof old.getRetryDelayFromError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_getRetryDelaySecondsFromError": {"backCompat": false}
 */
declare type current_as_old_for_Variable_getRetryDelaySecondsFromError = requireAssignableTo<TypeOnly<typeof current.getRetryDelaySecondsFromError>, TypeOnly<typeof old.getRetryDelaySecondsFromError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_isFluidResolvedUrl": {"backCompat": false}
 */
declare type current_as_old_for_Variable_isFluidResolvedUrl = requireAssignableTo<TypeOnly<typeof current.isFluidResolvedUrl>, TypeOnly<typeof old.isFluidResolvedUrl>>
