/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type * as old from "@fluidframework/driver-utils-previous/internal";

import type * as current from "../../index.js";

type ValueOf<T> = T[keyof T];
type OnlySymbols<T> = T extends symbol ? T : never;
type WellKnownSymbols = OnlySymbols<ValueOf<typeof Symbol>>;
/**
 * Omit (replace with never) a key if it is a custom symbol,
 * not just symbol or a well known symbol from the global Symbol.
 */
type SkipUniqueSymbols<Key> = symbol extends Key
	? Key // Key is symbol or a generalization of symbol, so leave it as is.
	: Key extends symbol
		? Key extends WellKnownSymbols
			? Key // Key is a well known symbol from the global Symbol object. These are shared between packages, so they are fine and kept as is.
			: never // Key is most likely some specialized symbol, typically a unique symbol. These break type comparisons so are removed by replacing them with never.
		: Key; // Key is not a symbol (for example its a string or number), so leave it as is.
/**
 * Remove details of T which are incompatible with type testing while keeping as much as is practical.
 *
 * See 'build-tools/packages/build-tools/src/typeValidator/compatibility.ts' for more information.
 */
type TypeOnly<T> = T extends number
	? number
	: T extends boolean | bigint | string
		? T
		: T extends symbol
			? SkipUniqueSymbols<T>
			: {
					[P in keyof T as SkipUniqueSymbols<P>]: TypeOnly<T[P]>;
				};

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_AttachmentTreeEntry": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_AttachmentTreeEntry():
    TypeOnly<old.AttachmentTreeEntry>;
declare function use_current_ClassDeclaration_AttachmentTreeEntry(
    use: TypeOnly<current.AttachmentTreeEntry>): void;
use_current_ClassDeclaration_AttachmentTreeEntry(
    get_old_ClassDeclaration_AttachmentTreeEntry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_AttachmentTreeEntry": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_AttachmentTreeEntry():
    TypeOnly<current.AttachmentTreeEntry>;
declare function use_old_ClassDeclaration_AttachmentTreeEntry(
    use: TypeOnly<old.AttachmentTreeEntry>): void;
use_old_ClassDeclaration_AttachmentTreeEntry(
    get_current_ClassDeclaration_AttachmentTreeEntry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_AuthorizationError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_AuthorizationError():
    TypeOnly<old.AuthorizationError>;
declare function use_current_ClassDeclaration_AuthorizationError(
    use: TypeOnly<current.AuthorizationError>): void;
use_current_ClassDeclaration_AuthorizationError(
    get_old_ClassDeclaration_AuthorizationError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_AuthorizationError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_AuthorizationError():
    TypeOnly<current.AuthorizationError>;
declare function use_old_ClassDeclaration_AuthorizationError(
    use: TypeOnly<old.AuthorizationError>): void;
use_old_ClassDeclaration_AuthorizationError(
    get_current_ClassDeclaration_AuthorizationError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_BlobTreeEntry": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_BlobTreeEntry():
    TypeOnly<old.BlobTreeEntry>;
declare function use_current_ClassDeclaration_BlobTreeEntry(
    use: TypeOnly<current.BlobTreeEntry>): void;
use_current_ClassDeclaration_BlobTreeEntry(
    get_old_ClassDeclaration_BlobTreeEntry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_BlobTreeEntry": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_BlobTreeEntry():
    TypeOnly<current.BlobTreeEntry>;
declare function use_old_ClassDeclaration_BlobTreeEntry(
    use: TypeOnly<old.BlobTreeEntry>): void;
use_old_ClassDeclaration_BlobTreeEntry(
    get_current_ClassDeclaration_BlobTreeEntry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_CombinedAppAndProtocolSummary": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_CombinedAppAndProtocolSummary():
    TypeOnly<old.CombinedAppAndProtocolSummary>;
declare function use_current_InterfaceDeclaration_CombinedAppAndProtocolSummary(
    use: TypeOnly<current.CombinedAppAndProtocolSummary>): void;
use_current_InterfaceDeclaration_CombinedAppAndProtocolSummary(
    get_old_InterfaceDeclaration_CombinedAppAndProtocolSummary());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_CombinedAppAndProtocolSummary": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_CombinedAppAndProtocolSummary():
    TypeOnly<current.CombinedAppAndProtocolSummary>;
declare function use_old_InterfaceDeclaration_CombinedAppAndProtocolSummary(
    use: TypeOnly<old.CombinedAppAndProtocolSummary>): void;
use_old_InterfaceDeclaration_CombinedAppAndProtocolSummary(
    get_current_InterfaceDeclaration_CombinedAppAndProtocolSummary());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DeltaStreamConnectionForbiddenError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_DeltaStreamConnectionForbiddenError():
    TypeOnly<old.DeltaStreamConnectionForbiddenError>;
declare function use_current_ClassDeclaration_DeltaStreamConnectionForbiddenError(
    use: TypeOnly<current.DeltaStreamConnectionForbiddenError>): void;
use_current_ClassDeclaration_DeltaStreamConnectionForbiddenError(
    get_old_ClassDeclaration_DeltaStreamConnectionForbiddenError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DeltaStreamConnectionForbiddenError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_DeltaStreamConnectionForbiddenError():
    TypeOnly<current.DeltaStreamConnectionForbiddenError>;
declare function use_old_ClassDeclaration_DeltaStreamConnectionForbiddenError(
    use: TypeOnly<old.DeltaStreamConnectionForbiddenError>): void;
use_old_ClassDeclaration_DeltaStreamConnectionForbiddenError(
    get_current_ClassDeclaration_DeltaStreamConnectionForbiddenError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DocumentStorageServiceProxy": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_DocumentStorageServiceProxy():
    TypeOnly<old.DocumentStorageServiceProxy>;
declare function use_current_ClassDeclaration_DocumentStorageServiceProxy(
    use: TypeOnly<current.DocumentStorageServiceProxy>): void;
use_current_ClassDeclaration_DocumentStorageServiceProxy(
    get_old_ClassDeclaration_DocumentStorageServiceProxy());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_DocumentStorageServiceProxy": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_DocumentStorageServiceProxy():
    TypeOnly<current.DocumentStorageServiceProxy>;
declare function use_old_ClassDeclaration_DocumentStorageServiceProxy(
    use: TypeOnly<old.DocumentStorageServiceProxy>): void;
use_old_ClassDeclaration_DocumentStorageServiceProxy(
    get_current_ClassDeclaration_DocumentStorageServiceProxy());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_DriverErrorTelemetryProps": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_DriverErrorTelemetryProps():
    TypeOnly<old.DriverErrorTelemetryProps>;
declare function use_current_TypeAliasDeclaration_DriverErrorTelemetryProps(
    use: TypeOnly<current.DriverErrorTelemetryProps>): void;
use_current_TypeAliasDeclaration_DriverErrorTelemetryProps(
    get_old_TypeAliasDeclaration_DriverErrorTelemetryProps());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAliasDeclaration_DriverErrorTelemetryProps": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_DriverErrorTelemetryProps():
    TypeOnly<current.DriverErrorTelemetryProps>;
declare function use_old_TypeAliasDeclaration_DriverErrorTelemetryProps(
    use: TypeOnly<old.DriverErrorTelemetryProps>): void;
use_old_TypeAliasDeclaration_DriverErrorTelemetryProps(
    get_current_TypeAliasDeclaration_DriverErrorTelemetryProps());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_FluidInvalidSchemaError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_FluidInvalidSchemaError():
    TypeOnly<old.FluidInvalidSchemaError>;
declare function use_current_ClassDeclaration_FluidInvalidSchemaError(
    use: TypeOnly<current.FluidInvalidSchemaError>): void;
use_current_ClassDeclaration_FluidInvalidSchemaError(
    get_old_ClassDeclaration_FluidInvalidSchemaError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_FluidInvalidSchemaError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_FluidInvalidSchemaError():
    TypeOnly<current.FluidInvalidSchemaError>;
declare function use_old_ClassDeclaration_FluidInvalidSchemaError(
    use: TypeOnly<old.FluidInvalidSchemaError>): void;
use_old_ClassDeclaration_FluidInvalidSchemaError(
    get_current_ClassDeclaration_FluidInvalidSchemaError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_GenericNetworkError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_GenericNetworkError():
    TypeOnly<old.GenericNetworkError>;
declare function use_current_ClassDeclaration_GenericNetworkError(
    use: TypeOnly<current.GenericNetworkError>): void;
use_current_ClassDeclaration_GenericNetworkError(
    get_old_ClassDeclaration_GenericNetworkError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_GenericNetworkError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_GenericNetworkError():
    TypeOnly<current.GenericNetworkError>;
declare function use_old_ClassDeclaration_GenericNetworkError(
    use: TypeOnly<old.GenericNetworkError>): void;
use_old_ClassDeclaration_GenericNetworkError(
    get_current_ClassDeclaration_GenericNetworkError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICompressionStorageConfig": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ICompressionStorageConfig():
    TypeOnly<old.ICompressionStorageConfig>;
declare function use_current_InterfaceDeclaration_ICompressionStorageConfig(
    use: TypeOnly<current.ICompressionStorageConfig>): void;
use_current_InterfaceDeclaration_ICompressionStorageConfig(
    get_old_InterfaceDeclaration_ICompressionStorageConfig());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_ICompressionStorageConfig": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ICompressionStorageConfig():
    TypeOnly<current.ICompressionStorageConfig>;
declare function use_old_InterfaceDeclaration_ICompressionStorageConfig(
    use: TypeOnly<old.ICompressionStorageConfig>): void;
use_old_InterfaceDeclaration_ICompressionStorageConfig(
    get_current_InterfaceDeclaration_ICompressionStorageConfig());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProgress": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_IProgress():
    TypeOnly<old.IProgress>;
declare function use_current_InterfaceDeclaration_IProgress(
    use: TypeOnly<current.IProgress>): void;
use_current_InterfaceDeclaration_IProgress(
    get_old_InterfaceDeclaration_IProgress());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "InterfaceDeclaration_IProgress": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_IProgress():
    TypeOnly<current.IProgress>;
declare function use_old_InterfaceDeclaration_IProgress(
    use: TypeOnly<old.IProgress>): void;
use_old_InterfaceDeclaration_IProgress(
    get_current_InterfaceDeclaration_IProgress());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_InsecureUrlResolver": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_InsecureUrlResolver():
    TypeOnly<old.InsecureUrlResolver>;
declare function use_current_ClassDeclaration_InsecureUrlResolver(
    use: TypeOnly<current.InsecureUrlResolver>): void;
use_current_ClassDeclaration_InsecureUrlResolver(
    get_old_ClassDeclaration_InsecureUrlResolver());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_InsecureUrlResolver": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_InsecureUrlResolver():
    TypeOnly<current.InsecureUrlResolver>;
declare function use_old_ClassDeclaration_InsecureUrlResolver(
    use: TypeOnly<old.InsecureUrlResolver>): void;
use_old_ClassDeclaration_InsecureUrlResolver(
    get_current_ClassDeclaration_InsecureUrlResolver());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LocationRedirectionError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_LocationRedirectionError():
    TypeOnly<old.LocationRedirectionError>;
declare function use_current_ClassDeclaration_LocationRedirectionError(
    use: TypeOnly<current.LocationRedirectionError>): void;
use_current_ClassDeclaration_LocationRedirectionError(
    get_old_ClassDeclaration_LocationRedirectionError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_LocationRedirectionError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_LocationRedirectionError():
    TypeOnly<current.LocationRedirectionError>;
declare function use_old_ClassDeclaration_LocationRedirectionError(
    use: TypeOnly<old.LocationRedirectionError>): void;
use_old_ClassDeclaration_LocationRedirectionError(
    get_current_ClassDeclaration_LocationRedirectionError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_MessageType2": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_MessageType2():
    TypeOnly<old.MessageType2>;
declare function use_current_EnumDeclaration_MessageType2(
    use: TypeOnly<current.MessageType2>): void;
use_current_EnumDeclaration_MessageType2(
    get_old_EnumDeclaration_MessageType2());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_MessageType2": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_MessageType2():
    TypeOnly<current.MessageType2>;
declare function use_old_EnumDeclaration_MessageType2(
    use: TypeOnly<old.MessageType2>): void;
use_old_EnumDeclaration_MessageType2(
    get_current_EnumDeclaration_MessageType2());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_NetworkErrorBasic": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_NetworkErrorBasic():
    TypeOnly<old.NetworkErrorBasic<any>>;
declare function use_current_ClassDeclaration_NetworkErrorBasic(
    use: TypeOnly<current.NetworkErrorBasic<any>>): void;
use_current_ClassDeclaration_NetworkErrorBasic(
    get_old_ClassDeclaration_NetworkErrorBasic());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_NetworkErrorBasic": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_NetworkErrorBasic():
    TypeOnly<current.NetworkErrorBasic<any>>;
declare function use_old_ClassDeclaration_NetworkErrorBasic(
    use: TypeOnly<old.NetworkErrorBasic<any>>): void;
use_old_ClassDeclaration_NetworkErrorBasic(
    get_current_ClassDeclaration_NetworkErrorBasic());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_NonRetryableError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_NonRetryableError():
    TypeOnly<old.NonRetryableError<any>>;
declare function use_current_ClassDeclaration_NonRetryableError(
    use: TypeOnly<current.NonRetryableError<any>>): void;
use_current_ClassDeclaration_NonRetryableError(
    get_old_ClassDeclaration_NonRetryableError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_NonRetryableError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_NonRetryableError():
    TypeOnly<current.NonRetryableError<any>>;
declare function use_old_ClassDeclaration_NonRetryableError(
    use: TypeOnly<old.NonRetryableError<any>>): void;
use_old_ClassDeclaration_NonRetryableError(
    get_current_ClassDeclaration_NonRetryableError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_OnlineStatus": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_OnlineStatus():
    TypeOnly<old.OnlineStatus>;
declare function use_current_EnumDeclaration_OnlineStatus(
    use: TypeOnly<current.OnlineStatus>): void;
use_current_EnumDeclaration_OnlineStatus(
    get_old_EnumDeclaration_OnlineStatus());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_OnlineStatus": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_OnlineStatus():
    TypeOnly<current.OnlineStatus>;
declare function use_old_EnumDeclaration_OnlineStatus(
    use: TypeOnly<old.OnlineStatus>): void;
use_old_EnumDeclaration_OnlineStatus(
    get_current_EnumDeclaration_OnlineStatus());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ParallelRequests": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_ParallelRequests():
    TypeOnly<old.ParallelRequests<any>>;
declare function use_current_ClassDeclaration_ParallelRequests(
    use: TypeOnly<current.ParallelRequests<any>>): void;
use_current_ClassDeclaration_ParallelRequests(
    get_old_ClassDeclaration_ParallelRequests());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ParallelRequests": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_ParallelRequests():
    TypeOnly<current.ParallelRequests<any>>;
declare function use_old_ClassDeclaration_ParallelRequests(
    use: TypeOnly<old.ParallelRequests<any>>): void;
use_old_ClassDeclaration_ParallelRequests(
    get_current_ClassDeclaration_ParallelRequests());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_PrefetchDocumentStorageService": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_PrefetchDocumentStorageService():
    TypeOnly<old.PrefetchDocumentStorageService>;
declare function use_current_ClassDeclaration_PrefetchDocumentStorageService(
    use: TypeOnly<current.PrefetchDocumentStorageService>): void;
use_current_ClassDeclaration_PrefetchDocumentStorageService(
    get_old_ClassDeclaration_PrefetchDocumentStorageService());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_PrefetchDocumentStorageService": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_PrefetchDocumentStorageService():
    TypeOnly<current.PrefetchDocumentStorageService>;
declare function use_old_ClassDeclaration_PrefetchDocumentStorageService(
    use: TypeOnly<old.PrefetchDocumentStorageService>): void;
use_old_ClassDeclaration_PrefetchDocumentStorageService(
    get_current_ClassDeclaration_PrefetchDocumentStorageService());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Queue": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_Queue():
    TypeOnly<old.Queue<any>>;
declare function use_current_ClassDeclaration_Queue(
    use: TypeOnly<current.Queue<any>>): void;
use_current_ClassDeclaration_Queue(
    get_old_ClassDeclaration_Queue());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_Queue": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_Queue():
    TypeOnly<current.Queue<any>>;
declare function use_old_ClassDeclaration_Queue(
    use: TypeOnly<old.Queue<any>>): void;
use_old_ClassDeclaration_Queue(
    get_current_ClassDeclaration_Queue());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_RateLimiter": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_RateLimiter():
    TypeOnly<old.RateLimiter>;
declare function use_current_ClassDeclaration_RateLimiter(
    use: TypeOnly<current.RateLimiter>): void;
use_current_ClassDeclaration_RateLimiter(
    get_old_ClassDeclaration_RateLimiter());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_RateLimiter": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_RateLimiter():
    TypeOnly<current.RateLimiter>;
declare function use_old_ClassDeclaration_RateLimiter(
    use: TypeOnly<old.RateLimiter>): void;
use_old_ClassDeclaration_RateLimiter(
    get_current_ClassDeclaration_RateLimiter());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_RetryableError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_RetryableError():
    TypeOnly<old.RetryableError<any>>;
declare function use_current_ClassDeclaration_RetryableError(
    use: TypeOnly<current.RetryableError<any>>): void;
use_current_ClassDeclaration_RetryableError(
    get_old_ClassDeclaration_RetryableError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_RetryableError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_RetryableError():
    TypeOnly<current.RetryableError<any>>;
declare function use_old_ClassDeclaration_RetryableError(
    use: TypeOnly<old.RetryableError<any>>): void;
use_old_ClassDeclaration_RetryableError(
    get_current_ClassDeclaration_RetryableError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_SummaryCompressionAlgorithm": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_SummaryCompressionAlgorithm():
    TypeOnly<old.SummaryCompressionAlgorithm>;
declare function use_current_EnumDeclaration_SummaryCompressionAlgorithm(
    use: TypeOnly<current.SummaryCompressionAlgorithm>): void;
use_current_EnumDeclaration_SummaryCompressionAlgorithm(
    get_old_EnumDeclaration_SummaryCompressionAlgorithm());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "EnumDeclaration_SummaryCompressionAlgorithm": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_SummaryCompressionAlgorithm():
    TypeOnly<current.SummaryCompressionAlgorithm>;
declare function use_old_EnumDeclaration_SummaryCompressionAlgorithm(
    use: TypeOnly<old.SummaryCompressionAlgorithm>): void;
use_old_EnumDeclaration_SummaryCompressionAlgorithm(
    get_current_EnumDeclaration_SummaryCompressionAlgorithm());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ThrottlingError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_ThrottlingError():
    TypeOnly<old.ThrottlingError>;
declare function use_current_ClassDeclaration_ThrottlingError(
    use: TypeOnly<current.ThrottlingError>): void;
use_current_ClassDeclaration_ThrottlingError(
    get_old_ClassDeclaration_ThrottlingError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_ThrottlingError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_ThrottlingError():
    TypeOnly<current.ThrottlingError>;
declare function use_old_ClassDeclaration_ThrottlingError(
    use: TypeOnly<old.ThrottlingError>): void;
use_old_ClassDeclaration_ThrottlingError(
    get_current_ClassDeclaration_ThrottlingError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TreeTreeEntry": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TreeTreeEntry():
    TypeOnly<old.TreeTreeEntry>;
declare function use_current_ClassDeclaration_TreeTreeEntry(
    use: TypeOnly<current.TreeTreeEntry>): void;
use_current_ClassDeclaration_TreeTreeEntry(
    get_old_ClassDeclaration_TreeTreeEntry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_TreeTreeEntry": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TreeTreeEntry():
    TypeOnly<current.TreeTreeEntry>;
declare function use_old_ClassDeclaration_TreeTreeEntry(
    use: TypeOnly<old.TreeTreeEntry>): void;
use_old_ClassDeclaration_TreeTreeEntry(
    get_current_ClassDeclaration_TreeTreeEntry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_UsageError": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_UsageError():
    TypeOnly<old.UsageError>;
declare function use_current_ClassDeclaration_UsageError(
    use: TypeOnly<current.UsageError>): void;
use_current_ClassDeclaration_UsageError(
    get_old_ClassDeclaration_UsageError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassDeclaration_UsageError": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_UsageError():
    TypeOnly<current.UsageError>;
declare function use_old_ClassDeclaration_UsageError(
    use: TypeOnly<old.UsageError>): void;
use_old_ClassDeclaration_UsageError(
    get_current_ClassDeclaration_UsageError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_applyStorageCompression": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_applyStorageCompression():
    TypeOnly<typeof old.applyStorageCompression>;
declare function use_current_FunctionDeclaration_applyStorageCompression(
    use: TypeOnly<typeof current.applyStorageCompression>): void;
use_current_FunctionDeclaration_applyStorageCompression(
    get_old_FunctionDeclaration_applyStorageCompression());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_applyStorageCompression": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_applyStorageCompression():
    TypeOnly<typeof current.applyStorageCompression>;
declare function use_old_FunctionDeclaration_applyStorageCompression(
    use: TypeOnly<typeof old.applyStorageCompression>): void;
use_old_FunctionDeclaration_applyStorageCompression(
    get_current_FunctionDeclaration_applyStorageCompression());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_blobHeadersBlobName": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_blobHeadersBlobName():
    TypeOnly<typeof old.blobHeadersBlobName>;
declare function use_current_VariableDeclaration_blobHeadersBlobName(
    use: TypeOnly<typeof current.blobHeadersBlobName>): void;
use_current_VariableDeclaration_blobHeadersBlobName(
    get_old_VariableDeclaration_blobHeadersBlobName());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_blobHeadersBlobName": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_blobHeadersBlobName():
    TypeOnly<typeof current.blobHeadersBlobName>;
declare function use_old_VariableDeclaration_blobHeadersBlobName(
    use: TypeOnly<typeof old.blobHeadersBlobName>): void;
use_old_VariableDeclaration_blobHeadersBlobName(
    get_current_VariableDeclaration_blobHeadersBlobName());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_buildSnapshotTree": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_buildSnapshotTree():
    TypeOnly<typeof old.buildSnapshotTree>;
declare function use_current_FunctionDeclaration_buildSnapshotTree(
    use: TypeOnly<typeof current.buildSnapshotTree>): void;
use_current_FunctionDeclaration_buildSnapshotTree(
    get_old_FunctionDeclaration_buildSnapshotTree());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_buildSnapshotTree": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_buildSnapshotTree():
    TypeOnly<typeof current.buildSnapshotTree>;
declare function use_old_FunctionDeclaration_buildSnapshotTree(
    use: TypeOnly<typeof old.buildSnapshotTree>): void;
use_old_FunctionDeclaration_buildSnapshotTree(
    get_current_FunctionDeclaration_buildSnapshotTree());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_calculateMaxWaitTime": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_calculateMaxWaitTime():
    TypeOnly<typeof old.calculateMaxWaitTime>;
declare function use_current_FunctionDeclaration_calculateMaxWaitTime(
    use: TypeOnly<typeof current.calculateMaxWaitTime>): void;
use_current_FunctionDeclaration_calculateMaxWaitTime(
    get_old_FunctionDeclaration_calculateMaxWaitTime());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_calculateMaxWaitTime": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_calculateMaxWaitTime():
    TypeOnly<typeof current.calculateMaxWaitTime>;
declare function use_old_FunctionDeclaration_calculateMaxWaitTime(
    use: TypeOnly<typeof old.calculateMaxWaitTime>): void;
use_old_FunctionDeclaration_calculateMaxWaitTime(
    get_current_FunctionDeclaration_calculateMaxWaitTime());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_canBeCoalescedByService": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_canBeCoalescedByService():
    TypeOnly<typeof old.canBeCoalescedByService>;
declare function use_current_FunctionDeclaration_canBeCoalescedByService(
    use: TypeOnly<typeof current.canBeCoalescedByService>): void;
use_current_FunctionDeclaration_canBeCoalescedByService(
    get_old_FunctionDeclaration_canBeCoalescedByService());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_canBeCoalescedByService": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_canBeCoalescedByService():
    TypeOnly<typeof current.canBeCoalescedByService>;
declare function use_old_FunctionDeclaration_canBeCoalescedByService(
    use: TypeOnly<typeof old.canBeCoalescedByService>): void;
use_old_FunctionDeclaration_canBeCoalescedByService(
    get_current_FunctionDeclaration_canBeCoalescedByService());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_canRetryOnError": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_canRetryOnError():
    TypeOnly<typeof old.canRetryOnError>;
declare function use_current_VariableDeclaration_canRetryOnError(
    use: TypeOnly<typeof current.canRetryOnError>): void;
use_current_VariableDeclaration_canRetryOnError(
    get_old_VariableDeclaration_canRetryOnError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_canRetryOnError": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_canRetryOnError():
    TypeOnly<typeof current.canRetryOnError>;
declare function use_old_VariableDeclaration_canRetryOnError(
    use: TypeOnly<typeof old.canRetryOnError>): void;
use_old_VariableDeclaration_canRetryOnError(
    get_current_VariableDeclaration_canRetryOnError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_convertSummaryTreeToSnapshotITree": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_convertSummaryTreeToSnapshotITree():
    TypeOnly<typeof old.convertSummaryTreeToSnapshotITree>;
declare function use_current_FunctionDeclaration_convertSummaryTreeToSnapshotITree(
    use: TypeOnly<typeof current.convertSummaryTreeToSnapshotITree>): void;
use_current_FunctionDeclaration_convertSummaryTreeToSnapshotITree(
    get_old_FunctionDeclaration_convertSummaryTreeToSnapshotITree());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_convertSummaryTreeToSnapshotITree": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_convertSummaryTreeToSnapshotITree():
    TypeOnly<typeof current.convertSummaryTreeToSnapshotITree>;
declare function use_old_FunctionDeclaration_convertSummaryTreeToSnapshotITree(
    use: TypeOnly<typeof old.convertSummaryTreeToSnapshotITree>): void;
use_old_FunctionDeclaration_convertSummaryTreeToSnapshotITree(
    get_current_FunctionDeclaration_convertSummaryTreeToSnapshotITree());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createGenericNetworkError": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_createGenericNetworkError():
    TypeOnly<typeof old.createGenericNetworkError>;
declare function use_current_FunctionDeclaration_createGenericNetworkError(
    use: TypeOnly<typeof current.createGenericNetworkError>): void;
use_current_FunctionDeclaration_createGenericNetworkError(
    get_old_FunctionDeclaration_createGenericNetworkError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_createGenericNetworkError": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_createGenericNetworkError():
    TypeOnly<typeof current.createGenericNetworkError>;
declare function use_old_FunctionDeclaration_createGenericNetworkError(
    use: TypeOnly<typeof old.createGenericNetworkError>): void;
use_old_FunctionDeclaration_createGenericNetworkError(
    get_current_FunctionDeclaration_createGenericNetworkError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createWriteError": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_createWriteError():
    TypeOnly<typeof old.createWriteError>;
declare function use_current_VariableDeclaration_createWriteError(
    use: TypeOnly<typeof current.createWriteError>): void;
use_current_VariableDeclaration_createWriteError(
    get_old_VariableDeclaration_createWriteError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_createWriteError": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_createWriteError():
    TypeOnly<typeof current.createWriteError>;
declare function use_old_VariableDeclaration_createWriteError(
    use: TypeOnly<typeof old.createWriteError>): void;
use_old_VariableDeclaration_createWriteError(
    get_current_VariableDeclaration_createWriteError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_emptyMessageStream": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_emptyMessageStream():
    TypeOnly<typeof old.emptyMessageStream>;
declare function use_current_VariableDeclaration_emptyMessageStream(
    use: TypeOnly<typeof current.emptyMessageStream>): void;
use_current_VariableDeclaration_emptyMessageStream(
    get_old_VariableDeclaration_emptyMessageStream());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_emptyMessageStream": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_emptyMessageStream():
    TypeOnly<typeof current.emptyMessageStream>;
declare function use_old_VariableDeclaration_emptyMessageStream(
    use: TypeOnly<typeof old.emptyMessageStream>): void;
use_old_VariableDeclaration_emptyMessageStream(
    get_current_VariableDeclaration_emptyMessageStream());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getDocAttributesFromProtocolSummary": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getDocAttributesFromProtocolSummary():
    TypeOnly<typeof old.getDocAttributesFromProtocolSummary>;
declare function use_current_FunctionDeclaration_getDocAttributesFromProtocolSummary(
    use: TypeOnly<typeof current.getDocAttributesFromProtocolSummary>): void;
use_current_FunctionDeclaration_getDocAttributesFromProtocolSummary(
    get_old_FunctionDeclaration_getDocAttributesFromProtocolSummary());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getDocAttributesFromProtocolSummary": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getDocAttributesFromProtocolSummary():
    TypeOnly<typeof current.getDocAttributesFromProtocolSummary>;
declare function use_old_FunctionDeclaration_getDocAttributesFromProtocolSummary(
    use: TypeOnly<typeof old.getDocAttributesFromProtocolSummary>): void;
use_old_FunctionDeclaration_getDocAttributesFromProtocolSummary(
    get_current_FunctionDeclaration_getDocAttributesFromProtocolSummary());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getQuorumValuesFromProtocolSummary": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getQuorumValuesFromProtocolSummary():
    TypeOnly<typeof old.getQuorumValuesFromProtocolSummary>;
declare function use_current_FunctionDeclaration_getQuorumValuesFromProtocolSummary(
    use: TypeOnly<typeof current.getQuorumValuesFromProtocolSummary>): void;
use_current_FunctionDeclaration_getQuorumValuesFromProtocolSummary(
    get_old_FunctionDeclaration_getQuorumValuesFromProtocolSummary());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getQuorumValuesFromProtocolSummary": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getQuorumValuesFromProtocolSummary():
    TypeOnly<typeof current.getQuorumValuesFromProtocolSummary>;
declare function use_old_FunctionDeclaration_getQuorumValuesFromProtocolSummary(
    use: TypeOnly<typeof old.getQuorumValuesFromProtocolSummary>): void;
use_old_FunctionDeclaration_getQuorumValuesFromProtocolSummary(
    get_current_FunctionDeclaration_getQuorumValuesFromProtocolSummary());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getRetryDelayFromError": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_getRetryDelayFromError():
    TypeOnly<typeof old.getRetryDelayFromError>;
declare function use_current_VariableDeclaration_getRetryDelayFromError(
    use: TypeOnly<typeof current.getRetryDelayFromError>): void;
use_current_VariableDeclaration_getRetryDelayFromError(
    get_old_VariableDeclaration_getRetryDelayFromError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getRetryDelayFromError": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_getRetryDelayFromError():
    TypeOnly<typeof current.getRetryDelayFromError>;
declare function use_old_VariableDeclaration_getRetryDelayFromError(
    use: TypeOnly<typeof old.getRetryDelayFromError>): void;
use_old_VariableDeclaration_getRetryDelayFromError(
    get_current_VariableDeclaration_getRetryDelayFromError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getRetryDelaySecondsFromError": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_getRetryDelaySecondsFromError():
    TypeOnly<typeof old.getRetryDelaySecondsFromError>;
declare function use_current_VariableDeclaration_getRetryDelaySecondsFromError(
    use: TypeOnly<typeof current.getRetryDelaySecondsFromError>): void;
use_current_VariableDeclaration_getRetryDelaySecondsFromError(
    get_old_VariableDeclaration_getRetryDelaySecondsFromError());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "VariableDeclaration_getRetryDelaySecondsFromError": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_getRetryDelaySecondsFromError():
    TypeOnly<typeof current.getRetryDelaySecondsFromError>;
declare function use_old_VariableDeclaration_getRetryDelaySecondsFromError(
    use: TypeOnly<typeof old.getRetryDelaySecondsFromError>): void;
use_old_VariableDeclaration_getRetryDelaySecondsFromError(
    get_current_VariableDeclaration_getRetryDelaySecondsFromError());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getSnapshotTree": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getSnapshotTree():
    TypeOnly<typeof old.getSnapshotTree>;
declare function use_current_FunctionDeclaration_getSnapshotTree(
    use: TypeOnly<typeof current.getSnapshotTree>): void;
use_current_FunctionDeclaration_getSnapshotTree(
    get_old_FunctionDeclaration_getSnapshotTree());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_getSnapshotTree": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getSnapshotTree():
    TypeOnly<typeof current.getSnapshotTree>;
declare function use_old_FunctionDeclaration_getSnapshotTree(
    use: TypeOnly<typeof old.getSnapshotTree>): void;
use_old_FunctionDeclaration_getSnapshotTree(
    get_current_FunctionDeclaration_getSnapshotTree());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isCombinedAppAndProtocolSummary": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_isCombinedAppAndProtocolSummary():
    TypeOnly<typeof old.isCombinedAppAndProtocolSummary>;
declare function use_current_FunctionDeclaration_isCombinedAppAndProtocolSummary(
    use: TypeOnly<typeof current.isCombinedAppAndProtocolSummary>): void;
use_current_FunctionDeclaration_isCombinedAppAndProtocolSummary(
    get_old_FunctionDeclaration_isCombinedAppAndProtocolSummary());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isCombinedAppAndProtocolSummary": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_isCombinedAppAndProtocolSummary():
    TypeOnly<typeof current.isCombinedAppAndProtocolSummary>;
declare function use_old_FunctionDeclaration_isCombinedAppAndProtocolSummary(
    use: TypeOnly<typeof old.isCombinedAppAndProtocolSummary>): void;
use_old_FunctionDeclaration_isCombinedAppAndProtocolSummary(
    get_current_FunctionDeclaration_isCombinedAppAndProtocolSummary());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isInstanceOfISnapshot": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_isInstanceOfISnapshot():
    TypeOnly<typeof old.isInstanceOfISnapshot>;
declare function use_current_FunctionDeclaration_isInstanceOfISnapshot(
    use: TypeOnly<typeof current.isInstanceOfISnapshot>): void;
use_current_FunctionDeclaration_isInstanceOfISnapshot(
    get_old_FunctionDeclaration_isInstanceOfISnapshot());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isInstanceOfISnapshot": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_isInstanceOfISnapshot():
    TypeOnly<typeof current.isInstanceOfISnapshot>;
declare function use_old_FunctionDeclaration_isInstanceOfISnapshot(
    use: TypeOnly<typeof old.isInstanceOfISnapshot>): void;
use_old_FunctionDeclaration_isInstanceOfISnapshot(
    get_current_FunctionDeclaration_isInstanceOfISnapshot());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isOnline": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_isOnline():
    TypeOnly<typeof old.isOnline>;
declare function use_current_FunctionDeclaration_isOnline(
    use: TypeOnly<typeof current.isOnline>): void;
use_current_FunctionDeclaration_isOnline(
    get_old_FunctionDeclaration_isOnline());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isOnline": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_isOnline():
    TypeOnly<typeof current.isOnline>;
declare function use_old_FunctionDeclaration_isOnline(
    use: TypeOnly<typeof old.isOnline>): void;
use_old_FunctionDeclaration_isOnline(
    get_current_FunctionDeclaration_isOnline());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isRuntimeMessage": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_isRuntimeMessage():
    TypeOnly<typeof old.isRuntimeMessage>;
declare function use_current_FunctionDeclaration_isRuntimeMessage(
    use: TypeOnly<typeof current.isRuntimeMessage>): void;
use_current_FunctionDeclaration_isRuntimeMessage(
    get_old_FunctionDeclaration_isRuntimeMessage());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_isRuntimeMessage": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_isRuntimeMessage():
    TypeOnly<typeof current.isRuntimeMessage>;
declare function use_old_FunctionDeclaration_isRuntimeMessage(
    use: TypeOnly<typeof old.isRuntimeMessage>): void;
use_old_FunctionDeclaration_isRuntimeMessage(
    get_current_FunctionDeclaration_isRuntimeMessage());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_logNetworkFailure": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_logNetworkFailure():
    TypeOnly<typeof old.logNetworkFailure>;
declare function use_current_FunctionDeclaration_logNetworkFailure(
    use: TypeOnly<typeof current.logNetworkFailure>): void;
use_current_FunctionDeclaration_logNetworkFailure(
    get_old_FunctionDeclaration_logNetworkFailure());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_logNetworkFailure": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_logNetworkFailure():
    TypeOnly<typeof current.logNetworkFailure>;
declare function use_old_FunctionDeclaration_logNetworkFailure(
    use: TypeOnly<typeof old.logNetworkFailure>): void;
use_old_FunctionDeclaration_logNetworkFailure(
    get_current_FunctionDeclaration_logNetworkFailure());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_readAndParse": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_readAndParse():
    TypeOnly<typeof old.readAndParse>;
declare function use_current_FunctionDeclaration_readAndParse(
    use: TypeOnly<typeof current.readAndParse>): void;
use_current_FunctionDeclaration_readAndParse(
    get_old_FunctionDeclaration_readAndParse());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_readAndParse": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_readAndParse():
    TypeOnly<typeof current.readAndParse>;
declare function use_old_FunctionDeclaration_readAndParse(
    use: TypeOnly<typeof old.readAndParse>): void;
use_old_FunctionDeclaration_readAndParse(
    get_current_FunctionDeclaration_readAndParse());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_requestOps": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_requestOps():
    TypeOnly<typeof old.requestOps>;
declare function use_current_FunctionDeclaration_requestOps(
    use: TypeOnly<typeof current.requestOps>): void;
use_current_FunctionDeclaration_requestOps(
    get_old_FunctionDeclaration_requestOps());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_requestOps": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_requestOps():
    TypeOnly<typeof current.requestOps>;
declare function use_old_FunctionDeclaration_requestOps(
    use: TypeOnly<typeof old.requestOps>): void;
use_old_FunctionDeclaration_requestOps(
    get_current_FunctionDeclaration_requestOps());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_runWithRetry": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_runWithRetry():
    TypeOnly<typeof old.runWithRetry>;
declare function use_current_FunctionDeclaration_runWithRetry(
    use: TypeOnly<typeof current.runWithRetry>): void;
use_current_FunctionDeclaration_runWithRetry(
    get_old_FunctionDeclaration_runWithRetry());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_runWithRetry": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_runWithRetry():
    TypeOnly<typeof current.runWithRetry>;
declare function use_old_FunctionDeclaration_runWithRetry(
    use: TypeOnly<typeof old.runWithRetry>): void;
use_old_FunctionDeclaration_runWithRetry(
    get_current_FunctionDeclaration_runWithRetry());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_streamFromMessages": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_streamFromMessages():
    TypeOnly<typeof old.streamFromMessages>;
declare function use_current_FunctionDeclaration_streamFromMessages(
    use: TypeOnly<typeof current.streamFromMessages>): void;
use_current_FunctionDeclaration_streamFromMessages(
    get_old_FunctionDeclaration_streamFromMessages());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_streamFromMessages": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_streamFromMessages():
    TypeOnly<typeof current.streamFromMessages>;
declare function use_old_FunctionDeclaration_streamFromMessages(
    use: TypeOnly<typeof old.streamFromMessages>): void;
use_old_FunctionDeclaration_streamFromMessages(
    get_current_FunctionDeclaration_streamFromMessages());

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_streamObserver": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_streamObserver():
    TypeOnly<typeof old.streamObserver>;
declare function use_current_FunctionDeclaration_streamObserver(
    use: TypeOnly<typeof current.streamObserver>): void;
use_current_FunctionDeclaration_streamObserver(
    get_old_FunctionDeclaration_streamObserver());

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "FunctionDeclaration_streamObserver": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_streamObserver():
    TypeOnly<typeof current.streamObserver>;
declare function use_old_FunctionDeclaration_streamObserver(
    use: TypeOnly<typeof old.streamObserver>): void;
use_old_FunctionDeclaration_streamObserver(
    get_current_FunctionDeclaration_streamObserver());
