/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "@fluidframework/driver-utils-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_AuthorizationError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_AuthorizationError():
    TypeOnly<old.AuthorizationError>;
declare function use_current_ClassDeclaration_AuthorizationError(
    use: TypeOnly<current.AuthorizationError>);
use_current_ClassDeclaration_AuthorizationError(
    get_old_ClassDeclaration_AuthorizationError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_AuthorizationError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_AuthorizationError():
    TypeOnly<current.AuthorizationError>;
declare function use_old_ClassDeclaration_AuthorizationError(
    use: TypeOnly<old.AuthorizationError>);
use_old_ClassDeclaration_AuthorizationError(
    // @ts-expect-error compatibility expected to be broken
    get_current_ClassDeclaration_AuthorizationError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BlobAggregationStorage": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_BlobAggregationStorage():
    TypeOnly<old.BlobAggregationStorage>;
declare function use_current_ClassDeclaration_BlobAggregationStorage(
    use: TypeOnly<current.BlobAggregationStorage>);
use_current_ClassDeclaration_BlobAggregationStorage(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_BlobAggregationStorage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BlobAggregationStorage": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_BlobAggregationStorage():
    TypeOnly<current.BlobAggregationStorage>;
declare function use_old_ClassDeclaration_BlobAggregationStorage(
    use: TypeOnly<old.BlobAggregationStorage>);
use_old_ClassDeclaration_BlobAggregationStorage(
    get_current_ClassDeclaration_BlobAggregationStorage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BlobCacheStorageService": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_BlobCacheStorageService():
    TypeOnly<old.BlobCacheStorageService>;
declare function use_current_ClassDeclaration_BlobCacheStorageService(
    use: TypeOnly<current.BlobCacheStorageService>);
use_current_ClassDeclaration_BlobCacheStorageService(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_BlobCacheStorageService());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BlobCacheStorageService": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_BlobCacheStorageService():
    TypeOnly<current.BlobCacheStorageService>;
declare function use_old_ClassDeclaration_BlobCacheStorageService(
    use: TypeOnly<old.BlobCacheStorageService>);
use_old_ClassDeclaration_BlobCacheStorageService(
    get_current_ClassDeclaration_BlobCacheStorageService());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_buildSnapshotTree": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_buildSnapshotTree():
    TypeOnly<typeof old.buildSnapshotTree>;
declare function use_current_FunctionDeclaration_buildSnapshotTree(
    use: TypeOnly<typeof current.buildSnapshotTree>);
use_current_FunctionDeclaration_buildSnapshotTree(
    get_old_FunctionDeclaration_buildSnapshotTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_buildSnapshotTree": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_buildSnapshotTree():
    TypeOnly<typeof current.buildSnapshotTree>;
declare function use_old_FunctionDeclaration_buildSnapshotTree(
    use: TypeOnly<typeof old.buildSnapshotTree>);
use_old_FunctionDeclaration_buildSnapshotTree(
    get_current_FunctionDeclaration_buildSnapshotTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_canRetryOnError": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_canRetryOnError():
    TypeOnly<typeof old.canRetryOnError>;
declare function use_current_VariableDeclaration_canRetryOnError(
    use: TypeOnly<typeof current.canRetryOnError>);
use_current_VariableDeclaration_canRetryOnError(
    get_old_VariableDeclaration_canRetryOnError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_canRetryOnError": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_canRetryOnError():
    TypeOnly<typeof current.canRetryOnError>;
declare function use_old_VariableDeclaration_canRetryOnError(
    use: TypeOnly<typeof old.canRetryOnError>);
use_old_VariableDeclaration_canRetryOnError(
    get_current_VariableDeclaration_canRetryOnError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_combineAppAndProtocolSummary": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_combineAppAndProtocolSummary():
    TypeOnly<typeof old.combineAppAndProtocolSummary>;
declare function use_current_FunctionDeclaration_combineAppAndProtocolSummary(
    use: TypeOnly<typeof current.combineAppAndProtocolSummary>);
use_current_FunctionDeclaration_combineAppAndProtocolSummary(
    get_old_FunctionDeclaration_combineAppAndProtocolSummary());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_combineAppAndProtocolSummary": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_combineAppAndProtocolSummary():
    TypeOnly<typeof current.combineAppAndProtocolSummary>;
declare function use_old_FunctionDeclaration_combineAppAndProtocolSummary(
    use: TypeOnly<typeof old.combineAppAndProtocolSummary>);
use_old_FunctionDeclaration_combineAppAndProtocolSummary(
    get_current_FunctionDeclaration_combineAppAndProtocolSummary());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_configurableUrlResolver": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_configurableUrlResolver():
    TypeOnly<typeof old.configurableUrlResolver>;
declare function use_current_FunctionDeclaration_configurableUrlResolver(
    use: TypeOnly<typeof current.configurableUrlResolver>);
use_current_FunctionDeclaration_configurableUrlResolver(
    get_old_FunctionDeclaration_configurableUrlResolver());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_configurableUrlResolver": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_configurableUrlResolver():
    TypeOnly<typeof current.configurableUrlResolver>;
declare function use_old_FunctionDeclaration_configurableUrlResolver(
    use: TypeOnly<typeof old.configurableUrlResolver>);
use_old_FunctionDeclaration_configurableUrlResolver(
    get_current_FunctionDeclaration_configurableUrlResolver());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_convertSnapshotAndBlobsToSummaryTree": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_convertSnapshotAndBlobsToSummaryTree():
    TypeOnly<typeof old.convertSnapshotAndBlobsToSummaryTree>;
declare function use_current_FunctionDeclaration_convertSnapshotAndBlobsToSummaryTree(
    use: TypeOnly<typeof current.convertSnapshotAndBlobsToSummaryTree>);
use_current_FunctionDeclaration_convertSnapshotAndBlobsToSummaryTree(
    get_old_FunctionDeclaration_convertSnapshotAndBlobsToSummaryTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_convertSnapshotAndBlobsToSummaryTree": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_convertSnapshotAndBlobsToSummaryTree():
    TypeOnly<typeof current.convertSnapshotAndBlobsToSummaryTree>;
declare function use_old_FunctionDeclaration_convertSnapshotAndBlobsToSummaryTree(
    use: TypeOnly<typeof old.convertSnapshotAndBlobsToSummaryTree>);
use_old_FunctionDeclaration_convertSnapshotAndBlobsToSummaryTree(
    get_current_FunctionDeclaration_convertSnapshotAndBlobsToSummaryTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_convertSummaryTreeToSnapshotITree": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_convertSummaryTreeToSnapshotITree():
    TypeOnly<typeof old.convertSummaryTreeToSnapshotITree>;
declare function use_current_FunctionDeclaration_convertSummaryTreeToSnapshotITree(
    use: TypeOnly<typeof current.convertSummaryTreeToSnapshotITree>);
use_current_FunctionDeclaration_convertSummaryTreeToSnapshotITree(
    get_old_FunctionDeclaration_convertSummaryTreeToSnapshotITree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_convertSummaryTreeToSnapshotITree": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_convertSummaryTreeToSnapshotITree():
    TypeOnly<typeof current.convertSummaryTreeToSnapshotITree>;
declare function use_old_FunctionDeclaration_convertSummaryTreeToSnapshotITree(
    use: TypeOnly<typeof old.convertSummaryTreeToSnapshotITree>);
use_old_FunctionDeclaration_convertSummaryTreeToSnapshotITree(
    get_current_FunctionDeclaration_convertSummaryTreeToSnapshotITree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createGenericNetworkError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createGenericNetworkError():
    TypeOnly<typeof old.createGenericNetworkError>;
declare function use_current_FunctionDeclaration_createGenericNetworkError(
    use: TypeOnly<typeof current.createGenericNetworkError>);
use_current_FunctionDeclaration_createGenericNetworkError(
    get_old_FunctionDeclaration_createGenericNetworkError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createGenericNetworkError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createGenericNetworkError():
    TypeOnly<typeof current.createGenericNetworkError>;
declare function use_old_FunctionDeclaration_createGenericNetworkError(
    use: TypeOnly<typeof old.createGenericNetworkError>);
use_old_FunctionDeclaration_createGenericNetworkError(
    get_current_FunctionDeclaration_createGenericNetworkError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createWriteError": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_createWriteError():
    TypeOnly<typeof old.createWriteError>;
declare function use_current_VariableDeclaration_createWriteError(
    use: TypeOnly<typeof current.createWriteError>);
use_current_VariableDeclaration_createWriteError(
    get_old_VariableDeclaration_createWriteError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createWriteError": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_createWriteError():
    TypeOnly<typeof current.createWriteError>;
declare function use_old_VariableDeclaration_createWriteError(
    use: TypeOnly<typeof old.createWriteError>);
use_old_VariableDeclaration_createWriteError(
    get_current_VariableDeclaration_createWriteError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeltaStreamConnectionForbiddenError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DeltaStreamConnectionForbiddenError():
    TypeOnly<old.DeltaStreamConnectionForbiddenError>;
declare function use_current_ClassDeclaration_DeltaStreamConnectionForbiddenError(
    use: TypeOnly<current.DeltaStreamConnectionForbiddenError>);
use_current_ClassDeclaration_DeltaStreamConnectionForbiddenError(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_DeltaStreamConnectionForbiddenError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeltaStreamConnectionForbiddenError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DeltaStreamConnectionForbiddenError():
    TypeOnly<current.DeltaStreamConnectionForbiddenError>;
declare function use_old_ClassDeclaration_DeltaStreamConnectionForbiddenError(
    use: TypeOnly<old.DeltaStreamConnectionForbiddenError>);
use_old_ClassDeclaration_DeltaStreamConnectionForbiddenError(
    get_current_ClassDeclaration_DeltaStreamConnectionForbiddenError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DocumentStorageServiceProxy": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DocumentStorageServiceProxy():
    TypeOnly<old.DocumentStorageServiceProxy>;
declare function use_current_ClassDeclaration_DocumentStorageServiceProxy(
    use: TypeOnly<current.DocumentStorageServiceProxy>);
use_current_ClassDeclaration_DocumentStorageServiceProxy(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_DocumentStorageServiceProxy());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DocumentStorageServiceProxy": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DocumentStorageServiceProxy():
    TypeOnly<current.DocumentStorageServiceProxy>;
declare function use_old_ClassDeclaration_DocumentStorageServiceProxy(
    use: TypeOnly<old.DocumentStorageServiceProxy>);
use_old_ClassDeclaration_DocumentStorageServiceProxy(
    get_current_ClassDeclaration_DocumentStorageServiceProxy());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_DriverErrorTelemetryProps": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_DriverErrorTelemetryProps():
    TypeOnly<old.DriverErrorTelemetryProps>;
declare function use_current_TypeAliasDeclaration_DriverErrorTelemetryProps(
    use: TypeOnly<current.DriverErrorTelemetryProps>);
use_current_TypeAliasDeclaration_DriverErrorTelemetryProps(
    get_old_TypeAliasDeclaration_DriverErrorTelemetryProps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_DriverErrorTelemetryProps": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_DriverErrorTelemetryProps():
    TypeOnly<current.DriverErrorTelemetryProps>;
declare function use_old_TypeAliasDeclaration_DriverErrorTelemetryProps(
    use: TypeOnly<old.DriverErrorTelemetryProps>);
use_old_TypeAliasDeclaration_DriverErrorTelemetryProps(
    get_current_TypeAliasDeclaration_DriverErrorTelemetryProps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EmptyDocumentDeltaStorageService": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_EmptyDocumentDeltaStorageService():
    TypeOnly<old.EmptyDocumentDeltaStorageService>;
declare function use_current_ClassDeclaration_EmptyDocumentDeltaStorageService(
    use: TypeOnly<current.EmptyDocumentDeltaStorageService>);
use_current_ClassDeclaration_EmptyDocumentDeltaStorageService(
    get_old_ClassDeclaration_EmptyDocumentDeltaStorageService());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EmptyDocumentDeltaStorageService": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_EmptyDocumentDeltaStorageService():
    TypeOnly<current.EmptyDocumentDeltaStorageService>;
declare function use_old_ClassDeclaration_EmptyDocumentDeltaStorageService(
    use: TypeOnly<old.EmptyDocumentDeltaStorageService>);
use_old_ClassDeclaration_EmptyDocumentDeltaStorageService(
    get_current_ClassDeclaration_EmptyDocumentDeltaStorageService());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_emptyMessageStream": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_emptyMessageStream():
    TypeOnly<typeof old.emptyMessageStream>;
declare function use_current_VariableDeclaration_emptyMessageStream(
    use: TypeOnly<typeof current.emptyMessageStream>);
use_current_VariableDeclaration_emptyMessageStream(
    get_old_VariableDeclaration_emptyMessageStream());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_emptyMessageStream": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_emptyMessageStream():
    TypeOnly<typeof current.emptyMessageStream>;
declare function use_old_VariableDeclaration_emptyMessageStream(
    use: TypeOnly<typeof old.emptyMessageStream>);
use_old_VariableDeclaration_emptyMessageStream(
    get_current_VariableDeclaration_emptyMessageStream());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ensureFluidResolvedUrl": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_ensureFluidResolvedUrl():
    TypeOnly<typeof old.ensureFluidResolvedUrl>;
declare function use_current_FunctionDeclaration_ensureFluidResolvedUrl(
    use: TypeOnly<typeof current.ensureFluidResolvedUrl>);
use_current_FunctionDeclaration_ensureFluidResolvedUrl(
    get_old_FunctionDeclaration_ensureFluidResolvedUrl());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_ensureFluidResolvedUrl": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_ensureFluidResolvedUrl():
    TypeOnly<typeof current.ensureFluidResolvedUrl>;
declare function use_old_FunctionDeclaration_ensureFluidResolvedUrl(
    use: TypeOnly<typeof old.ensureFluidResolvedUrl>);
use_old_FunctionDeclaration_ensureFluidResolvedUrl(
    get_current_FunctionDeclaration_ensureFluidResolvedUrl());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_GenericNetworkError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_GenericNetworkError():
    TypeOnly<old.GenericNetworkError>;
declare function use_current_ClassDeclaration_GenericNetworkError(
    use: TypeOnly<current.GenericNetworkError>);
use_current_ClassDeclaration_GenericNetworkError(
    get_old_ClassDeclaration_GenericNetworkError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_GenericNetworkError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_GenericNetworkError():
    TypeOnly<current.GenericNetworkError>;
declare function use_old_ClassDeclaration_GenericNetworkError(
    use: TypeOnly<old.GenericNetworkError>);
use_old_ClassDeclaration_GenericNetworkError(
    // @ts-expect-error compatibility expected to be broken
    get_current_ClassDeclaration_GenericNetworkError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getDocAttributesFromProtocolSummary": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getDocAttributesFromProtocolSummary():
    TypeOnly<typeof old.getDocAttributesFromProtocolSummary>;
declare function use_current_FunctionDeclaration_getDocAttributesFromProtocolSummary(
    use: TypeOnly<typeof current.getDocAttributesFromProtocolSummary>);
use_current_FunctionDeclaration_getDocAttributesFromProtocolSummary(
    get_old_FunctionDeclaration_getDocAttributesFromProtocolSummary());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getDocAttributesFromProtocolSummary": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getDocAttributesFromProtocolSummary():
    TypeOnly<typeof current.getDocAttributesFromProtocolSummary>;
declare function use_old_FunctionDeclaration_getDocAttributesFromProtocolSummary(
    use: TypeOnly<typeof old.getDocAttributesFromProtocolSummary>);
use_old_FunctionDeclaration_getDocAttributesFromProtocolSummary(
    get_current_FunctionDeclaration_getDocAttributesFromProtocolSummary());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getQuorumValuesFromProtocolSummary": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getQuorumValuesFromProtocolSummary():
    TypeOnly<typeof old.getQuorumValuesFromProtocolSummary>;
declare function use_current_FunctionDeclaration_getQuorumValuesFromProtocolSummary(
    use: TypeOnly<typeof current.getQuorumValuesFromProtocolSummary>);
use_current_FunctionDeclaration_getQuorumValuesFromProtocolSummary(
    get_old_FunctionDeclaration_getQuorumValuesFromProtocolSummary());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getQuorumValuesFromProtocolSummary": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getQuorumValuesFromProtocolSummary():
    TypeOnly<typeof current.getQuorumValuesFromProtocolSummary>;
declare function use_old_FunctionDeclaration_getQuorumValuesFromProtocolSummary(
    use: TypeOnly<typeof old.getQuorumValuesFromProtocolSummary>);
use_old_FunctionDeclaration_getQuorumValuesFromProtocolSummary(
    get_current_FunctionDeclaration_getQuorumValuesFromProtocolSummary());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getRetryDelayFromError": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getRetryDelayFromError():
    TypeOnly<typeof old.getRetryDelayFromError>;
declare function use_current_VariableDeclaration_getRetryDelayFromError(
    use: TypeOnly<typeof current.getRetryDelayFromError>);
use_current_VariableDeclaration_getRetryDelayFromError(
    get_old_VariableDeclaration_getRetryDelayFromError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getRetryDelayFromError": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getRetryDelayFromError():
    TypeOnly<typeof current.getRetryDelayFromError>;
declare function use_old_VariableDeclaration_getRetryDelayFromError(
    use: TypeOnly<typeof old.getRetryDelayFromError>);
use_old_VariableDeclaration_getRetryDelayFromError(
    get_current_VariableDeclaration_getRetryDelayFromError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getRetryDelaySecondsFromError": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getRetryDelaySecondsFromError():
    TypeOnly<typeof old.getRetryDelaySecondsFromError>;
declare function use_current_VariableDeclaration_getRetryDelaySecondsFromError(
    use: TypeOnly<typeof current.getRetryDelaySecondsFromError>);
use_current_VariableDeclaration_getRetryDelaySecondsFromError(
    get_old_VariableDeclaration_getRetryDelaySecondsFromError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getRetryDelaySecondsFromError": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getRetryDelaySecondsFromError():
    TypeOnly<typeof current.getRetryDelaySecondsFromError>;
declare function use_old_VariableDeclaration_getRetryDelaySecondsFromError(
    use: TypeOnly<typeof old.getRetryDelaySecondsFromError>);
use_old_VariableDeclaration_getRetryDelaySecondsFromError(
    get_current_VariableDeclaration_getRetryDelaySecondsFromError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAnyDriverError": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAnyDriverError():
    TypeOnly<old.IAnyDriverError>;
declare function use_current_InterfaceDeclaration_IAnyDriverError(
    use: TypeOnly<current.IAnyDriverError>);
use_current_InterfaceDeclaration_IAnyDriverError(
    get_old_InterfaceDeclaration_IAnyDriverError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAnyDriverError": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAnyDriverError():
    TypeOnly<current.IAnyDriverError>;
declare function use_old_InterfaceDeclaration_IAnyDriverError(
    use: TypeOnly<old.IAnyDriverError>);
use_old_InterfaceDeclaration_IAnyDriverError(
    get_current_InterfaceDeclaration_IAnyDriverError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_InsecureUrlResolver": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_InsecureUrlResolver():
    TypeOnly<old.InsecureUrlResolver>;
declare function use_current_ClassDeclaration_InsecureUrlResolver(
    use: TypeOnly<current.InsecureUrlResolver>);
use_current_ClassDeclaration_InsecureUrlResolver(
    get_old_ClassDeclaration_InsecureUrlResolver());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_InsecureUrlResolver": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_InsecureUrlResolver():
    TypeOnly<current.InsecureUrlResolver>;
declare function use_old_ClassDeclaration_InsecureUrlResolver(
    use: TypeOnly<old.InsecureUrlResolver>);
use_old_ClassDeclaration_InsecureUrlResolver(
    get_current_ClassDeclaration_InsecureUrlResolver());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProgress": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProgress():
    TypeOnly<old.IProgress>;
declare function use_current_InterfaceDeclaration_IProgress(
    use: TypeOnly<current.IProgress>);
use_current_InterfaceDeclaration_IProgress(
    get_old_InterfaceDeclaration_IProgress());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProgress": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProgress():
    TypeOnly<current.IProgress>;
declare function use_old_InterfaceDeclaration_IProgress(
    use: TypeOnly<old.IProgress>);
use_old_InterfaceDeclaration_IProgress(
    get_current_InterfaceDeclaration_IProgress());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_isClientMessage": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_isClientMessage": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidResolvedUrl": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isFluidResolvedUrl():
    TypeOnly<typeof old.isFluidResolvedUrl>;
declare function use_current_VariableDeclaration_isFluidResolvedUrl(
    use: TypeOnly<typeof current.isFluidResolvedUrl>);
use_current_VariableDeclaration_isFluidResolvedUrl(
    get_old_VariableDeclaration_isFluidResolvedUrl());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isFluidResolvedUrl": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isFluidResolvedUrl():
    TypeOnly<typeof current.isFluidResolvedUrl>;
declare function use_old_VariableDeclaration_isFluidResolvedUrl(
    use: TypeOnly<typeof old.isFluidResolvedUrl>);
use_old_VariableDeclaration_isFluidResolvedUrl(
    get_current_VariableDeclaration_isFluidResolvedUrl());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isOnline": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isOnline():
    TypeOnly<typeof old.isOnline>;
declare function use_current_FunctionDeclaration_isOnline(
    use: TypeOnly<typeof current.isOnline>);
use_current_FunctionDeclaration_isOnline(
    get_old_FunctionDeclaration_isOnline());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isOnline": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isOnline():
    TypeOnly<typeof current.isOnline>;
declare function use_old_FunctionDeclaration_isOnline(
    use: TypeOnly<typeof old.isOnline>);
use_old_FunctionDeclaration_isOnline(
    get_current_FunctionDeclaration_isOnline());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isRuntimeMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isRuntimeMessage():
    TypeOnly<typeof old.isRuntimeMessage>;
declare function use_current_FunctionDeclaration_isRuntimeMessage(
    use: TypeOnly<typeof current.isRuntimeMessage>);
use_current_FunctionDeclaration_isRuntimeMessage(
    get_old_FunctionDeclaration_isRuntimeMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isRuntimeMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isRuntimeMessage():
    TypeOnly<typeof current.isRuntimeMessage>;
declare function use_old_FunctionDeclaration_isRuntimeMessage(
    use: TypeOnly<typeof old.isRuntimeMessage>);
use_old_FunctionDeclaration_isRuntimeMessage(
    get_current_FunctionDeclaration_isRuntimeMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryTreeAssemblerProps": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryTreeAssemblerProps():
    TypeOnly<old.ISummaryTreeAssemblerProps>;
declare function use_current_InterfaceDeclaration_ISummaryTreeAssemblerProps(
    use: TypeOnly<current.ISummaryTreeAssemblerProps>);
use_current_InterfaceDeclaration_ISummaryTreeAssemblerProps(
    get_old_InterfaceDeclaration_ISummaryTreeAssemblerProps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryTreeAssemblerProps": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryTreeAssemblerProps():
    TypeOnly<current.ISummaryTreeAssemblerProps>;
declare function use_old_InterfaceDeclaration_ISummaryTreeAssemblerProps(
    use: TypeOnly<old.ISummaryTreeAssemblerProps>);
use_old_InterfaceDeclaration_ISummaryTreeAssemblerProps(
    get_current_InterfaceDeclaration_ISummaryTreeAssemblerProps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isUnpackedRuntimeMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isUnpackedRuntimeMessage():
    TypeOnly<typeof old.isUnpackedRuntimeMessage>;
declare function use_current_FunctionDeclaration_isUnpackedRuntimeMessage(
    use: TypeOnly<typeof current.isUnpackedRuntimeMessage>);
use_current_FunctionDeclaration_isUnpackedRuntimeMessage(
    get_old_FunctionDeclaration_isUnpackedRuntimeMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isUnpackedRuntimeMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isUnpackedRuntimeMessage():
    TypeOnly<typeof current.isUnpackedRuntimeMessage>;
declare function use_old_FunctionDeclaration_isUnpackedRuntimeMessage(
    use: TypeOnly<typeof old.isUnpackedRuntimeMessage>);
use_old_FunctionDeclaration_isUnpackedRuntimeMessage(
    get_current_FunctionDeclaration_isUnpackedRuntimeMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_logNetworkFailure": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_logNetworkFailure():
    TypeOnly<typeof old.logNetworkFailure>;
declare function use_current_FunctionDeclaration_logNetworkFailure(
    use: TypeOnly<typeof current.logNetworkFailure>);
use_current_FunctionDeclaration_logNetworkFailure(
    get_old_FunctionDeclaration_logNetworkFailure());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_logNetworkFailure": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_logNetworkFailure():
    TypeOnly<typeof current.logNetworkFailure>;
declare function use_old_FunctionDeclaration_logNetworkFailure(
    use: TypeOnly<typeof old.logNetworkFailure>);
use_old_FunctionDeclaration_logNetworkFailure(
    get_current_FunctionDeclaration_logNetworkFailure());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MultiDocumentServiceFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MultiDocumentServiceFactory():
    TypeOnly<old.MultiDocumentServiceFactory>;
declare function use_current_ClassDeclaration_MultiDocumentServiceFactory(
    use: TypeOnly<current.MultiDocumentServiceFactory>);
use_current_ClassDeclaration_MultiDocumentServiceFactory(
    get_old_ClassDeclaration_MultiDocumentServiceFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MultiDocumentServiceFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MultiDocumentServiceFactory():
    TypeOnly<current.MultiDocumentServiceFactory>;
declare function use_old_ClassDeclaration_MultiDocumentServiceFactory(
    use: TypeOnly<old.MultiDocumentServiceFactory>);
use_old_ClassDeclaration_MultiDocumentServiceFactory(
    get_current_ClassDeclaration_MultiDocumentServiceFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MultiUrlResolver": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MultiUrlResolver():
    TypeOnly<old.MultiUrlResolver>;
declare function use_current_ClassDeclaration_MultiUrlResolver(
    use: TypeOnly<current.MultiUrlResolver>);
use_current_ClassDeclaration_MultiUrlResolver(
    get_old_ClassDeclaration_MultiUrlResolver());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MultiUrlResolver": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MultiUrlResolver():
    TypeOnly<current.MultiUrlResolver>;
declare function use_old_ClassDeclaration_MultiUrlResolver(
    use: TypeOnly<old.MultiUrlResolver>);
use_old_ClassDeclaration_MultiUrlResolver(
    get_current_ClassDeclaration_MultiUrlResolver());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_NetworkErrorBasic": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_NetworkErrorBasic():
    TypeOnly<old.NetworkErrorBasic<any>>;
declare function use_current_ClassDeclaration_NetworkErrorBasic(
    use: TypeOnly<current.NetworkErrorBasic<any>>);
use_current_ClassDeclaration_NetworkErrorBasic(
    get_old_ClassDeclaration_NetworkErrorBasic());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_NetworkErrorBasic": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_NetworkErrorBasic():
    TypeOnly<current.NetworkErrorBasic<any>>;
declare function use_old_ClassDeclaration_NetworkErrorBasic(
    use: TypeOnly<old.NetworkErrorBasic<any>>);
use_old_ClassDeclaration_NetworkErrorBasic(
    get_current_ClassDeclaration_NetworkErrorBasic());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_NonRetryableError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_NonRetryableError():
    TypeOnly<old.NonRetryableError<any>>;
declare function use_current_ClassDeclaration_NonRetryableError(
    use: TypeOnly<current.NonRetryableError<any>>);
use_current_ClassDeclaration_NonRetryableError(
    get_old_ClassDeclaration_NonRetryableError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_NonRetryableError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_NonRetryableError():
    TypeOnly<current.NonRetryableError<any>>;
declare function use_old_ClassDeclaration_NonRetryableError(
    use: TypeOnly<old.NonRetryableError<any>>);
use_old_ClassDeclaration_NonRetryableError(
    get_current_ClassDeclaration_NonRetryableError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_OnlineStatus": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_OnlineStatus():
    TypeOnly<old.OnlineStatus>;
declare function use_current_EnumDeclaration_OnlineStatus(
    use: TypeOnly<current.OnlineStatus>);
use_current_EnumDeclaration_OnlineStatus(
    get_old_EnumDeclaration_OnlineStatus());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_OnlineStatus": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_OnlineStatus():
    TypeOnly<current.OnlineStatus>;
declare function use_old_EnumDeclaration_OnlineStatus(
    use: TypeOnly<old.OnlineStatus>);
use_old_EnumDeclaration_OnlineStatus(
    get_current_EnumDeclaration_OnlineStatus());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ParallelRequests": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ParallelRequests():
    TypeOnly<old.ParallelRequests<any>>;
declare function use_current_ClassDeclaration_ParallelRequests(
    use: TypeOnly<current.ParallelRequests<any>>);
use_current_ClassDeclaration_ParallelRequests(
    get_old_ClassDeclaration_ParallelRequests());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ParallelRequests": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ParallelRequests():
    TypeOnly<current.ParallelRequests<any>>;
declare function use_old_ClassDeclaration_ParallelRequests(
    use: TypeOnly<old.ParallelRequests<any>>);
use_old_ClassDeclaration_ParallelRequests(
    get_current_ClassDeclaration_ParallelRequests());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PrefetchDocumentStorageService": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_PrefetchDocumentStorageService():
    TypeOnly<old.PrefetchDocumentStorageService>;
declare function use_current_ClassDeclaration_PrefetchDocumentStorageService(
    use: TypeOnly<current.PrefetchDocumentStorageService>);
use_current_ClassDeclaration_PrefetchDocumentStorageService(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_PrefetchDocumentStorageService());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PrefetchDocumentStorageService": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_PrefetchDocumentStorageService():
    TypeOnly<current.PrefetchDocumentStorageService>;
declare function use_old_ClassDeclaration_PrefetchDocumentStorageService(
    use: TypeOnly<old.PrefetchDocumentStorageService>);
use_old_ClassDeclaration_PrefetchDocumentStorageService(
    get_current_ClassDeclaration_PrefetchDocumentStorageService());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Queue": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Queue():
    TypeOnly<old.Queue<any>>;
declare function use_current_ClassDeclaration_Queue(
    use: TypeOnly<current.Queue<any>>);
use_current_ClassDeclaration_Queue(
    get_old_ClassDeclaration_Queue());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Queue": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Queue():
    TypeOnly<current.Queue<any>>;
declare function use_old_ClassDeclaration_Queue(
    use: TypeOnly<old.Queue<any>>);
use_old_ClassDeclaration_Queue(
    get_current_ClassDeclaration_Queue());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RateLimiter": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_RateLimiter():
    TypeOnly<old.RateLimiter>;
declare function use_current_ClassDeclaration_RateLimiter(
    use: TypeOnly<current.RateLimiter>);
use_current_ClassDeclaration_RateLimiter(
    get_old_ClassDeclaration_RateLimiter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RateLimiter": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_RateLimiter():
    TypeOnly<current.RateLimiter>;
declare function use_old_ClassDeclaration_RateLimiter(
    use: TypeOnly<old.RateLimiter>);
use_old_ClassDeclaration_RateLimiter(
    get_current_ClassDeclaration_RateLimiter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_readAndParse": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_readAndParse():
    TypeOnly<typeof old.readAndParse>;
declare function use_current_FunctionDeclaration_readAndParse(
    use: TypeOnly<typeof current.readAndParse>);
use_current_FunctionDeclaration_readAndParse(
    get_old_FunctionDeclaration_readAndParse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_readAndParse": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_readAndParse():
    TypeOnly<typeof current.readAndParse>;
declare function use_old_FunctionDeclaration_readAndParse(
    use: TypeOnly<typeof old.readAndParse>);
use_old_FunctionDeclaration_readAndParse(
    get_current_FunctionDeclaration_readAndParse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_requestOps": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_requestOps():
    TypeOnly<typeof old.requestOps>;
declare function use_current_FunctionDeclaration_requestOps(
    use: TypeOnly<typeof current.requestOps>);
use_current_FunctionDeclaration_requestOps(
    get_old_FunctionDeclaration_requestOps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_requestOps": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_requestOps():
    TypeOnly<typeof current.requestOps>;
declare function use_old_FunctionDeclaration_requestOps(
    use: TypeOnly<typeof old.requestOps>);
use_old_FunctionDeclaration_requestOps(
    get_current_FunctionDeclaration_requestOps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RetryableError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_RetryableError():
    TypeOnly<old.RetryableError<any>>;
declare function use_current_ClassDeclaration_RetryableError(
    use: TypeOnly<current.RetryableError<any>>);
use_current_ClassDeclaration_RetryableError(
    get_old_ClassDeclaration_RetryableError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RetryableError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_RetryableError():
    TypeOnly<current.RetryableError<any>>;
declare function use_old_ClassDeclaration_RetryableError(
    use: TypeOnly<old.RetryableError<any>>);
use_old_ClassDeclaration_RetryableError(
    get_current_ClassDeclaration_RetryableError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_runWithRetry": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_runWithRetry():
    TypeOnly<typeof old.runWithRetry>;
declare function use_current_FunctionDeclaration_runWithRetry(
    use: TypeOnly<typeof current.runWithRetry>);
use_current_FunctionDeclaration_runWithRetry(
    get_old_FunctionDeclaration_runWithRetry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_runWithRetry": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_runWithRetry():
    TypeOnly<typeof current.runWithRetry>;
declare function use_old_FunctionDeclaration_runWithRetry(
    use: TypeOnly<typeof old.runWithRetry>);
use_old_FunctionDeclaration_runWithRetry(
    get_current_FunctionDeclaration_runWithRetry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SnapshotExtractor": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SnapshotExtractor():
    TypeOnly<old.SnapshotExtractor>;
declare function use_current_ClassDeclaration_SnapshotExtractor(
    use: TypeOnly<current.SnapshotExtractor>);
use_current_ClassDeclaration_SnapshotExtractor(
    get_old_ClassDeclaration_SnapshotExtractor());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SnapshotExtractor": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SnapshotExtractor():
    TypeOnly<current.SnapshotExtractor>;
declare function use_old_ClassDeclaration_SnapshotExtractor(
    use: TypeOnly<old.SnapshotExtractor>);
use_old_ClassDeclaration_SnapshotExtractor(
    get_current_ClassDeclaration_SnapshotExtractor());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_streamFromMessages": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_streamFromMessages():
    TypeOnly<typeof old.streamFromMessages>;
declare function use_current_FunctionDeclaration_streamFromMessages(
    use: TypeOnly<typeof current.streamFromMessages>);
use_current_FunctionDeclaration_streamFromMessages(
    get_old_FunctionDeclaration_streamFromMessages());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_streamFromMessages": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_streamFromMessages():
    TypeOnly<typeof current.streamFromMessages>;
declare function use_old_FunctionDeclaration_streamFromMessages(
    use: TypeOnly<typeof old.streamFromMessages>);
use_old_FunctionDeclaration_streamFromMessages(
    get_current_FunctionDeclaration_streamFromMessages());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_streamObserver": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_streamObserver():
    TypeOnly<typeof old.streamObserver>;
declare function use_current_FunctionDeclaration_streamObserver(
    use: TypeOnly<typeof current.streamObserver>);
use_current_FunctionDeclaration_streamObserver(
    get_old_FunctionDeclaration_streamObserver());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_streamObserver": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_streamObserver():
    TypeOnly<typeof current.streamObserver>;
declare function use_old_FunctionDeclaration_streamObserver(
    use: TypeOnly<typeof old.streamObserver>);
use_old_FunctionDeclaration_streamObserver(
    get_current_FunctionDeclaration_streamObserver());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryTreeAssembler": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SummaryTreeAssembler():
    TypeOnly<old.SummaryTreeAssembler>;
declare function use_current_ClassDeclaration_SummaryTreeAssembler(
    use: TypeOnly<current.SummaryTreeAssembler>);
use_current_ClassDeclaration_SummaryTreeAssembler(
    get_old_ClassDeclaration_SummaryTreeAssembler());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryTreeAssembler": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SummaryTreeAssembler():
    TypeOnly<current.SummaryTreeAssembler>;
declare function use_old_ClassDeclaration_SummaryTreeAssembler(
    use: TypeOnly<old.SummaryTreeAssembler>);
use_old_ClassDeclaration_SummaryTreeAssembler(
    get_current_ClassDeclaration_SummaryTreeAssembler());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ThrottlingError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ThrottlingError():
    TypeOnly<old.ThrottlingError>;
declare function use_current_ClassDeclaration_ThrottlingError(
    use: TypeOnly<current.ThrottlingError>);
use_current_ClassDeclaration_ThrottlingError(
    get_old_ClassDeclaration_ThrottlingError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ThrottlingError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ThrottlingError():
    TypeOnly<current.ThrottlingError>;
declare function use_old_ClassDeclaration_ThrottlingError(
    use: TypeOnly<old.ThrottlingError>);
use_old_ClassDeclaration_ThrottlingError(
    // @ts-expect-error compatibility expected to be broken
    get_current_ClassDeclaration_ThrottlingError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_UsageError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_UsageError():
    TypeOnly<old.UsageError>;
declare function use_current_ClassDeclaration_UsageError(
    use: TypeOnly<current.UsageError>);
use_current_ClassDeclaration_UsageError(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_UsageError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_UsageError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_UsageError():
    TypeOnly<current.UsageError>;
declare function use_old_ClassDeclaration_UsageError(
    use: TypeOnly<old.UsageError>);
use_old_ClassDeclaration_UsageError(
    get_current_ClassDeclaration_UsageError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_waitForConnectedState": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_waitForConnectedState():
    TypeOnly<typeof old.waitForConnectedState>;
declare function use_current_FunctionDeclaration_waitForConnectedState(
    use: TypeOnly<typeof current.waitForConnectedState>);
use_current_FunctionDeclaration_waitForConnectedState(
    get_old_FunctionDeclaration_waitForConnectedState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_waitForConnectedState": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_waitForConnectedState():
    TypeOnly<typeof current.waitForConnectedState>;
declare function use_old_FunctionDeclaration_waitForConnectedState(
    use: TypeOnly<typeof old.waitForConnectedState>);
use_old_FunctionDeclaration_waitForConnectedState(
    get_current_FunctionDeclaration_waitForConnectedState());
