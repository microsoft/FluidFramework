## API Report File for "@fluidframework/driver-utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { FetchSource } from '@fluidframework/driver-definitions';
import { IAttachment } from '@fluidframework/protocol-definitions';
import { IAuthorizationError } from '@fluidframework/driver-definitions';
import { IBlob } from '@fluidframework/protocol-definitions';
import { ICommittedProposal } from '@fluidframework/protocol-definitions';
import { ICreateBlobResponse } from '@fluidframework/protocol-definitions';
import { IDeltasFetchResult } from '@fluidframework/driver-definitions';
import { IDocumentAttributes } from '@fluidframework/protocol-definitions';
import { IDocumentMessage } from '@fluidframework/protocol-definitions';
import { IDocumentServiceFactory } from '@fluidframework/driver-definitions';
import { IDocumentStorageService } from '@fluidframework/driver-definitions';
import { IDocumentStorageServicePolicies } from '@fluidframework/driver-definitions';
import { IDriverErrorBase } from '@fluidframework/driver-definitions';
import { IFluidErrorBase } from '@fluidframework/telemetry-utils';
import { ILocationRedirectionError } from '@fluidframework/driver-definitions';
import { IRequest } from '@fluidframework/core-interfaces';
import { IResolvedUrl } from '@fluidframework/driver-definitions';
import { ISequencedDocumentMessage } from '@fluidframework/protocol-definitions';
import { ISnapshot } from '@fluidframework/driver-definitions';
import { ISnapshotFetchOptions } from '@fluidframework/driver-definitions';
import { ISnapshotTree } from '@fluidframework/protocol-definitions';
import { IStream } from '@fluidframework/driver-definitions';
import { IStreamResult } from '@fluidframework/driver-definitions';
import { ISummaryContext } from '@fluidframework/driver-definitions';
import { ISummaryHandle } from '@fluidframework/protocol-definitions';
import { ISummaryTree } from '@fluidframework/protocol-definitions';
import { ITelemetryBaseProperties } from '@fluidframework/core-interfaces';
import { ITelemetryErrorEventExt } from '@fluidframework/telemetry-utils';
import { ITelemetryLoggerExt } from '@fluidframework/telemetry-utils';
import { IThrottlingWarning } from '@fluidframework/driver-definitions';
import { ITree } from '@fluidframework/protocol-definitions';
import { ITreeEntry } from '@fluidframework/protocol-definitions';
import { IUrlResolver } from '@fluidframework/driver-definitions';
import { IVersion } from '@fluidframework/protocol-definitions';
import { LoaderCachingPolicy } from '@fluidframework/driver-definitions';
import { LoggingError } from '@fluidframework/telemetry-utils';

// @internal
export function applyStorageCompression(documentServiceFactory: IDocumentServiceFactory, config?: ICompressionStorageConfig | boolean): IDocumentServiceFactory;

// @internal
export class AttachmentTreeEntry {
    constructor(path: string, id: string);
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly mode = FileMode.File;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    readonly type = TreeEntry.Attachment;
    // (undocumented)
    readonly value: IAttachment;
}

// @internal (undocumented)
export class AuthorizationError extends LoggingError implements IAuthorizationError, IFluidErrorBase {
    constructor(message: string, claims: string | undefined, tenantId: string | undefined, props: DriverErrorTelemetryProps);
    // (undocumented)
    readonly canRetry = false;
    // (undocumented)
    readonly claims: string | undefined;
    // (undocumented)
    readonly errorType: "authorizationError";
    // (undocumented)
    readonly tenantId: string | undefined;
}

// @internal (undocumented)
export const blobHeadersBlobName = ".metadata.blobHeaders";

// @internal
export class BlobTreeEntry {
    constructor(path: string, contents: string, encoding?: "utf-8" | "base64");
    // (undocumented)
    readonly mode = FileMode.File;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    readonly type = TreeEntry.Blob;
    // (undocumented)
    readonly value: IBlob;
}

// @internal
export function buildSnapshotTree(entries: ITreeEntry[], blobMap: Map<string, ArrayBufferLike>): ISnapshotTree;

// @internal
export function calculateMaxWaitTime(delayMs: number, error: unknown): number;

// @internal (undocumented)
export function canBeCoalescedByService(message: ISequencedDocumentMessage | IDocumentMessage): boolean;

// @internal
export const canRetryOnError: (error: any) => boolean;

// @internal
export interface CombinedAppAndProtocolSummary extends ISummaryTree {
    // (undocumented)
    tree: {
        [".app"]: ISummaryTree;
        [".protocol"]: ISummaryTree;
    };
}

// @internal
export function convertSummaryTreeToSnapshotITree(summaryTree: ISummaryTree): ITree;

// @internal (undocumented)
export function createGenericNetworkError(message: string, retryInfo: {
    canRetry: boolean;
    retryAfterMs?: number;
}, props: DriverErrorTelemetryProps): ThrottlingError | GenericNetworkError;

// @internal (undocumented)
export const createWriteError: (message: string, props: DriverErrorTelemetryProps) => NonRetryableError<"writeError">;

// @internal (undocumented)
export class DeltaStreamConnectionForbiddenError extends LoggingError implements IDriverErrorBase, IFluidErrorBase {
    constructor(message: string, props: DriverErrorTelemetryProps, storageOnlyReason?: string);
    // (undocumented)
    readonly canRetry = false;
    // (undocumented)
    static readonly errorType: "deltaStreamConnectionForbidden";
    // (undocumented)
    readonly errorType: "deltaStreamConnectionForbidden";
    // (undocumented)
    readonly storageOnlyReason: string | undefined;
}

// @internal (undocumented)
export class DocumentStorageServiceProxy implements IDocumentStorageService {
    constructor(internalStorageService: IDocumentStorageService);
    // (undocumented)
    createBlob(file: ArrayBufferLike): Promise<ICreateBlobResponse>;
    // (undocumented)
    downloadSummary(handle: ISummaryHandle): Promise<ISummaryTree>;
    // (undocumented)
    getSnapshot(snapshotFetchOptions?: ISnapshotFetchOptions): Promise<ISnapshot>;
    // (undocumented)
    getSnapshotTree(version?: IVersion, scenarioName?: string): Promise<ISnapshotTree | null>;
    // (undocumented)
    getVersions(versionId: string | null, count: number, scenarioName?: string, fetchSource?: FetchSource): Promise<IVersion[]>;
    // (undocumented)
    protected readonly internalStorageService: IDocumentStorageService;
    set policies(policies: IDocumentStorageServicePolicies | undefined);
    // (undocumented)
    get policies(): IDocumentStorageServicePolicies | undefined;
    // (undocumented)
    readBlob(blobId: string): Promise<ArrayBufferLike>;
    // (undocumented)
    uploadSummaryWithContext(summary: ISummaryTree, context: ISummaryContext): Promise<string>;
}

// @internal
export type DriverErrorTelemetryProps = ITelemetryBaseProperties & {
    driverVersion: string | undefined;
};

// @internal (undocumented)
export const emptyMessageStream: IStream<ISequencedDocumentMessage[]>;

// @internal
export class FluidInvalidSchemaError extends LoggingError implements IDriverErrorBase, IFluidErrorBase {
    constructor(message: string, props: DriverErrorTelemetryProps);
    // (undocumented)
    readonly canRetry = false;
    // (undocumented)
    readonly errorType: "fluidInvalidSchema";
}

// @internal
export class GenericNetworkError extends LoggingError implements IDriverErrorBase, IFluidErrorBase {
    constructor(message: string, canRetry: boolean, props: DriverErrorTelemetryProps);
    // (undocumented)
    readonly canRetry: boolean;
    readonly errorType: "genericNetworkError";
}

// @internal
export function getDocAttributesFromProtocolSummary(protocolSummary: ISummaryTree): IDocumentAttributes;

// @internal
export function getQuorumValuesFromProtocolSummary(protocolSummary: ISummaryTree): [string, ICommittedProposal][];

// @internal
export const getRetryDelayFromError: (error: any) => number | undefined;

// @internal
export const getRetryDelaySecondsFromError: (error: any) => number | undefined;

// @public (undocumented)
export interface ICompressionStorageConfig {
    // (undocumented)
    algorithm: SummaryCompressionAlgorithm;
    // (undocumented)
    minSizeToCompress: number;
}

// @internal
export class InsecureUrlResolver implements IUrlResolver {
    constructor(hostUrl: string, ordererUrl: string, storageUrl: string, deltaStreamUrl: string, tenantId: string, bearer: string, isForNodeTest?: boolean);
    // (undocumented)
    createCreateNewRequest(fileName?: string): IRequest;
    // (undocumented)
    getAbsoluteUrl(resolvedUrl: IResolvedUrl, relativeUrl: string): Promise<string>;
    // (undocumented)
    resolve(request: IRequest): Promise<IResolvedUrl | undefined>;
}

// @internal
export interface IProgress {
    cancel?: AbortSignal;
    onRetry?(delayInMs: number, error: any): void;
}

// @internal
export function isCombinedAppAndProtocolSummary(summary: ISummaryTree | undefined, ...optionalRootTrees: string[]): summary is CombinedAppAndProtocolSummary;

// @internal
export function isInstanceOfISnapshot(obj: ISnapshotTree | ISnapshot | undefined): obj is ISnapshot;

// @internal
export function isOnline(): OnlineStatus;

// @internal
export function isRuntimeMessage(message: {
    type: string;
}): boolean;

// @internal (undocumented)
export class LocationRedirectionError extends LoggingError implements ILocationRedirectionError, IFluidErrorBase {
    constructor(message: string, redirectUrl: IResolvedUrl, props: DriverErrorTelemetryProps);
    // (undocumented)
    readonly canRetry = false;
    // (undocumented)
    readonly errorType: "locationRedirection";
    // (undocumented)
    readonly redirectUrl: IResolvedUrl;
}

// @internal (undocumented)
export function logNetworkFailure(logger: ITelemetryLoggerExt, event: ITelemetryErrorEventExt, error?: any): void;

// @internal (undocumented)
export enum MessageType2 {
    // (undocumented)
    Accept = "accept"
}

// @internal (undocumented)
export class NetworkErrorBasic<T extends string> extends LoggingError implements IFluidErrorBase {
    constructor(message: string, errorType: T, canRetry: boolean, props: DriverErrorTelemetryProps);
    // (undocumented)
    readonly canRetry: boolean;
    // (undocumented)
    readonly errorType: T;
}

// @internal (undocumented)
export class NonRetryableError<T extends string> extends NetworkErrorBasic<T> {
    constructor(message: string, errorType: T, props: DriverErrorTelemetryProps);
    // (undocumented)
    readonly errorType: T;
}

// @internal (undocumented)
export enum OnlineStatus {
    // (undocumented)
    Offline = 0,
    // (undocumented)
    Online = 1,
    // (undocumented)
    Unknown = 2
}

// @internal
export class ParallelRequests<T> {
    constructor(from: number, to: number | undefined, payloadSize: number, logger: ITelemetryLoggerExt, requestCallback: (request: number, from: number, to: number, strongTo: boolean, props: ITelemetryBaseProperties) => Promise<{
        partial: boolean;
        cancel: boolean;
        payload: T[];
    }>, responseCallback: (payload: T[]) => void);
    // (undocumented)
    cancel(): void;
    // (undocumented)
    get canceled(): boolean;
    // (undocumented)
    run(concurrency: number): Promise<void>;
}

// @internal (undocumented)
export class PrefetchDocumentStorageService extends DocumentStorageServiceProxy {
    // (undocumented)
    getSnapshotTree(version?: IVersion): Promise<ISnapshotTree | null>;
    // (undocumented)
    get policies(): {
        caching: LoaderCachingPolicy;
        maximumCacheDurationMs?: 432000000 | undefined;
    } | undefined;
    // (undocumented)
    readBlob(blobId: string): Promise<ArrayBufferLike>;
    // (undocumented)
    stopPrefetch(): void;
}

// @internal
export class Queue<T> implements IStream<T> {
    // (undocumented)
    protected pushCore(value: Promise<IStreamResult<T>>): void;
    // (undocumented)
    pushDone(): void;
    // (undocumented)
    pushError(error: any): void;
    // (undocumented)
    pushValue(value: T): void;
    // (undocumented)
    read(): Promise<IStreamResult<T>>;
}

// @alpha (undocumented)
export class RateLimiter {
    constructor(maxRequests: number);
    // (undocumented)
    protected acquire(): Promise<void>;
    // (undocumented)
    protected readonly release: () => void;
    // (undocumented)
    schedule<T>(work: () => Promise<T>): Promise<T>;
    // (undocumented)
    get waitQueueLength(): number;
}

// @internal
export function readAndParse<T>(storage: Pick<IDocumentStorageService, "readBlob">, id: string): Promise<T>;

// @internal
export function requestOps(get: (from: number, to: number, telemetryProps: ITelemetryBaseProperties) => Promise<IDeltasFetchResult>, concurrency: number, fromTotal: number, toTotal: number | undefined, payloadSize: number, logger: ITelemetryLoggerExt, signal?: AbortSignal, scenarioName?: string): IStream<ISequencedDocumentMessage[]>;

// @internal (undocumented)
export class RetryableError<T extends string> extends NetworkErrorBasic<T> {
    constructor(message: string, errorType: T, props: DriverErrorTelemetryProps);
    // (undocumented)
    readonly errorType: T;
}

// @internal (undocumented)
export function runWithRetry<T>(api: (cancel?: AbortSignal) => Promise<T>, fetchCallName: string, logger: ITelemetryLoggerExt, progress: IProgress): Promise<T>;

// @internal (undocumented)
export function streamFromMessages(messagesArg: Promise<ISequencedDocumentMessage[]>): IStream<ISequencedDocumentMessage[]>;

// @internal (undocumented)
export function streamObserver<T>(stream: IStream<T>, handler: (value: IStreamResult<T>) => void): IStream<T>;

// @public (undocumented)
export enum SummaryCompressionAlgorithm {
    // (undocumented)
    LZ4 = 1,
    // (undocumented)
    None = 0
}

// @internal
export class ThrottlingError extends LoggingError implements IThrottlingWarning, IFluidErrorBase {
    constructor(message: string, retryAfterSeconds: number, props: DriverErrorTelemetryProps);
    // (undocumented)
    readonly canRetry = true;
    // (undocumented)
    readonly errorType: "throttlingError";
    // (undocumented)
    readonly retryAfterSeconds: number;
}

// @internal
export class TreeTreeEntry {
    constructor(path: string, value: ITree);
    // (undocumented)
    readonly mode = FileMode.Directory;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    readonly type = TreeEntry.Tree;
    // (undocumented)
    readonly value: ITree;
}

// @internal
export class UsageError extends LoggingError implements IDriverErrorBase, IFluidErrorBase {
    constructor(message: string);
    // (undocumented)
    readonly canRetry = false;
    // (undocumented)
    readonly errorType: "usageError";
}

// (No @packageDocumentation comment for this package)

```
