{"version":3,"file":"deltas.js","sourceRoot":"","sources":["../src/deltas.ts"],"names":[],"mappings":"AAAA;;;GAGG;AA0DH,MAAM,CAAC,MAAM,YAAY,GAA8B,cAAc,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IDisposable, IEventProvider, IEvent, IErrorEvent } from \"@fluidframework/common-definitions\";\nimport {\n    ConnectionMode,\n    IClientConfiguration,\n    IClientDetails,\n    IDocumentMessage,\n    IProcessMessageResult,\n    ISequencedDocumentMessage,\n    ISignalClient,\n    ISignalMessage,\n    ITokenClaims,\n    MessageType,\n} from \"@fluidframework/protocol-definitions\";\n\n/**\n * Contract representing the result of a newly established connection to the server for syncing deltas\n */\nexport interface IConnectionDetails {\n    clientId: string;\n    claims: ITokenClaims;\n    existing: boolean;\n    mode: ConnectionMode;\n    version: string;\n    initialClients: ISignalClient[];\n    maxMessageSize: number;\n    serviceConfiguration: IClientConfiguration;\n    /**\n     * Last known sequence number to ordering service at the time of connection\n     * It may lap actual last sequence number (quite a bit, if container  is very active).\n     * But it's best information for client to figure out how far it is behind, at least\n     * for \"read\" connections. \"write\" connections may use own \"join\" op to similar information,\n     * that is likely to be more up-to-date.\n     */\n    checkpointSequenceNumber: number | undefined;\n}\n\n/**\n * Interface used to define a strategy for handling incoming delta messages\n */\nexport interface IDeltaHandlerStrategy {\n    /**\n     * Processes the message.\n     */\n    process: (message: ISequencedDocumentMessage) => IProcessMessageResult;\n\n    /**\n     * Processes the signal.\n     */\n    processSignal: (message: ISignalMessage) => void;\n}\n\ndeclare module \"@fluidframework/core-interfaces\" {\n    // eslint-disable-next-line @typescript-eslint/no-empty-interface\n    interface IFluidObject extends Readonly<Partial<IProvideDeltaSender>> { }\n}\n\nexport const IDeltaSender: keyof IProvideDeltaSender = \"IDeltaSender\";\n\nexport interface IProvideDeltaSender {\n    readonly IDeltaSender: IDeltaSender;\n}\n\n/**\n * Contract supporting delivery of outbound messages to the server\n */\nexport interface IDeltaSender extends IProvideDeltaSender {\n    /**\n     * Submits the given delta returning the client sequence number for the message. Contents is the actual\n     * contents of the message. appData is optional metadata that can be attached to the op by the app.\n     *\n     * If batch is set to true then the submit will be batched - and as a result guaranteed to be ordered sequentially\n     * in the global sequencing space. The batch will be flushed either when flush is called or when a non-batched\n     * op is submitted.\n     */\n    submit(type: MessageType, contents: any, batch: boolean, metadata: any): number;\n\n    /**\n     * Flush all pending messages through the outbound queue\n     */\n    flush(): void;\n}\n\n/** Events emitted by the Delta Manager */\nexport interface IDeltaManagerEvents extends IEvent {\n    (event: \"prepareSend\", listener: (messageBuffer: any[]) => void);\n    (event: \"submitOp\", listener: (message: IDocumentMessage) => void);\n    (event: \"beforeOpProcessing\", listener: (message: ISequencedDocumentMessage) => void);\n    (event: \"op\", listener: (message: ISequencedDocumentMessage, processingTime: number) => void);\n    (event: \"allSentOpsAckd\", listener: () => void);\n    (event: \"pong\" | \"processTime\", listener: (latency: number) => void);\n    (event: \"connect\", listener: (details: IConnectionDetails, opsBehind?: number) => void);\n    (event: \"disconnect\", listener: (reason: string) => void);\n    (event: \"readonly\", listener: (readonly: boolean) => void);\n}\n\n/**\n * Manages the transmission of ops between the runtime and storage.\n */\nexport interface IDeltaManager<T, U> extends IEventProvider<IDeltaManagerEvents>, IDeltaSender, IDisposable {\n    /** The queue of inbound delta messages */\n    readonly inbound: IDeltaQueue<T>;\n\n    /** The queue of outbound delta messages */\n    readonly outbound: IDeltaQueue<U[]>;\n\n    /** The queue of inbound delta signals */\n    readonly inboundSignal: IDeltaQueue<ISignalMessage>;\n\n    /** The current minimum sequence number */\n    readonly minimumSequenceNumber: number;\n\n    /** The last sequence number processed by the delta manager */\n    readonly lastSequenceNumber: number;\n\n    /** The latest sequence number the delta manager is aware of */\n    readonly lastKnownSeqNumber: number;\n\n    /** The initial sequence number set when attaching the op handler */\n    readonly initialSequenceNumber: number;\n\n    /**\n     * Tells if  current connection has checkpoint information.\n     * I.e. we know how far behind the client was at the time of establishing connection\n     */\n    readonly hasCheckpointSequenceNumber: boolean;\n\n    /** Details of client */\n    readonly clientDetails: IClientDetails;\n\n    /** Protocol version being used to communicate with the service */\n    readonly version: string;\n\n    /** Max message size allowed to the delta manager */\n    readonly maxMessageSize: number;\n\n    /** Service configuration provided by the service. */\n    readonly serviceConfiguration: IClientConfiguration | undefined;\n\n    /** Flag to indicate whether the client can write or not. */\n    readonly active: boolean;\n\n    /**\n     * Tells if container is in read-only mode.\n     * Data stores should listen for \"readonly\" notifications and disallow user making changes to data stores.\n     * Readonly state can be because of no storage write permission,\n     * or due to host forcing readonly mode for container.\n     *\n     * We do not differentiate here between no write access to storage vs. host disallowing changes to container -\n     * in all cases container runtime and data stores should respect readonly state and not allow local changes.\n     *\n     * It is undefined if we have not yet established websocket connection\n     * and do not know if user has write access to a file.\n     */\n    readonly readonly?: boolean;\n\n    /** Terminate the connection to storage */\n    close(): void;\n\n    /** Submit a signal to the service to be broadcast to other connected clients, but not persisted */\n    submitSignal(content: any): void;\n}\n\n/** Events emitted by a Delta Queue */\nexport interface IDeltaQueueEvents<T> extends IErrorEvent {\n    (event: \"push\" | \"op\", listener: (task: T) => void);\n    (event: \"idle\", listener: () => void);\n}\n\n/**\n * Queue of ops to be sent to or processed from storage\n */\nexport interface IDeltaQueue<T> extends IEventProvider<IDeltaQueueEvents<T>>, IDisposable {\n    /**\n     * Flag indicating whether or not the queue was paused\n     */\n    paused: boolean;\n\n    /**\n     * The number of messages remaining in the queue\n     */\n    length: number;\n\n    /**\n     * Flag indicating whether or not the queue is idle\n     */\n    idle: boolean;\n\n    /**\n     * Pauses processing on the queue\n     * @returns A promise which resolves when processing has been paused.\n     */\n    pause(): Promise<void>;\n\n    /**\n     * Resumes processing on the queue\n     */\n    resume(): void;\n\n    /**\n     * Peeks at the next message in the queue\n     */\n    peek(): T | undefined;\n\n    /**\n     * Returns all the items in the queue as an array. Does not remove them from the queue.\n     */\n    toArray(): T[];\n}\n"]}