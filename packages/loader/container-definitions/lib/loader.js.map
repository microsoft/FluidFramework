{"version":3,"file":"loader.js","sourceRoot":"","sources":["../src/loader.ts"],"names":[],"mappings":"AAAA;;;GAGG;AA4NH;;GAEG;AACH,MAAM,CAAN,IAAY,YAuBX;AAvBD,WAAY,YAAY;IACpB;;OAEG;IACH,qCAAqB,CAAA;IAErB,sDAAsC,CAAA;IACtC,sDAAsC,CAAA;IAEtC;;OAEG;IACH,+BAAe,CAAA;IACf,6CAA6B,CAAA;IAC7B,wDAAwC,CAAA;IAExC;;;;;OAKG;IACH,mCAAmB,CAAA;AACvB,CAAC,EAvBW,YAAY,KAAZ,YAAY,QAuBvB","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    IRequest,\n    IResponse,\n    IFluidRouter,\n    IFluidCodeDetails,\n    IFluidPackage,\n    IProvideFluidCodeDetailsComparer,\n} from \"@fluidframework/core-interfaces\";\nimport {\n    IClientDetails,\n    IDocumentMessage,\n    IPendingProposal,\n    IQuorum,\n    ISequencedDocumentMessage,\n} from \"@fluidframework/protocol-definitions\";\nimport { IResolvedUrl } from \"@fluidframework/driver-definitions\";\nimport { IEvent, IEventProvider } from \"@fluidframework/common-definitions\";\nimport { IDeltaManager } from \"./deltas\";\nimport { ICriticalContainerError, ContainerWarning } from \"./error\";\nimport { IFluidModule } from \"./fluidModule\";\nimport { AttachState } from \"./runtime\";\n\n/**\n * Code loading interface\n */\nexport interface ICodeLoader extends Partial<IProvideFluidCodeDetailsComparer> {\n    /**\n     * Loads the package specified by code details and returns a promise to its entry point exports.\n     */\n    load(source: IFluidCodeDetails): Promise<IFluidModule>;\n}\n\n/**\n* The interface returned from a IFluidCodeResolver which represents IFluidCodeDetails\n * that have been resolved and are ready to load\n */\nexport interface IResolvedFluidCodeDetails extends IFluidCodeDetails {\n    /**\n     * A resolved version of the Fluid package. All Fluid browser file entries should be absolute urls.\n     */\n    readonly resolvedPackage: Readonly<IFluidPackage>;\n    /**\n     * If not undefined, this id will be used to cache the entry point for the code package\n     */\n    readonly resolvedPackageCacheId: string | undefined;\n}\n\n/**\n * Fluid code resolvers take a Fluid code details, and resolve the\n * full Fluid package including absolute urls for the browser file entries.\n * The Fluid code resolver is coupled to a specific cdn and knows how to resolve\n * the code detail for loading from that cdn. This include resolving to the most recent\n * version of package that supports the provided code details.\n */\nexport interface IFluidCodeResolver {\n    /**\n     * Resolves a Fluid code details into a form that can be loaded\n     * @param details - The Fluid code details to resolve\n     * @returns - A IResolvedFluidCodeDetails where the\n     *            resolvedPackage's Fluid file entries are absolute urls, and\n     *            an optional resolvedPackageCacheId if the loaded package should be\n     *            cached.\n     */\n    resolveCodeDetails(details: IFluidCodeDetails): Promise<IResolvedFluidCodeDetails>;\n}\n\n/**\n * Code AllowListing Interface\n */\nexport interface ICodeAllowList {\n    testSource(source: IResolvedFluidCodeDetails): Promise<boolean>;\n}\n\n/**\n * Events emitted by the Container \"upwards\" to the Loader and Host\n */\nexport interface IContainerEvents extends IEvent {\n    (event: \"readonly\", listener: (readonly: boolean) => void): void;\n    (event: \"connected\", listener: (clientId: string) => void);\n    /**\n     * @param opsBehind - number of ops this client is behind (if present).\n     */\n    (event: \"connect\", listener: (opsBehind?: number) => void);\n    (event: \"codeDetailsProposed\", listener: (codeDetails: IFluidCodeDetails, proposal: IPendingProposal) => void);\n    (event: \"contextDisposed\" | \"contextChanged\",\n        listener: (codeDetails: IFluidCodeDetails, previousCodeDetails: IFluidCodeDetails | undefined) => void);\n    (event: \"disconnected\" | \"attaching\" | \"attached\", listener: () => void);\n    (event: \"closed\", listener: (error?: ICriticalContainerError) => void);\n    (event: \"warning\", listener: (error: ContainerWarning) => void);\n    (event: \"op\", listener: (message: ISequencedDocumentMessage) => void);\n}\n\n/**\n * The Host's view of the Container and its connection to storage\n */\nexport interface IContainer extends IEventProvider<IContainerEvents>, IFluidRouter {\n\n    /**\n     * The Delta Manager supporting the op stream for this Container\n     */\n    deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;\n\n    /**\n     * The collection of write clients which were connected as of the current sequence number.\n     * Also contains a map of key-value pairs that must be agreed upon by all clients before being accepted.\n     */\n    getQuorum(): IQuorum;\n\n    /**\n     * Represents the resolved url to the Container\n     */\n    resolvedUrl: IResolvedUrl | undefined;\n\n    /**\n     * Indicates the attachment state of the container to a host service.\n     */\n    readonly attachState: AttachState;\n\n    /**\n     * The current code details for the container's runtime\n     */\n    readonly codeDetails: IFluidCodeDetails | undefined\n\n    /**\n     * Returns true if the container has been closed, otherwise false\n     */\n    readonly closed: boolean;\n\n    /**\n     * Closes the container\n     */\n    close(error?: ICriticalContainerError): void;\n\n    /**\n     * Propose new code details that define the code to be loaded\n     * for this container's runtime. The returned promise will\n     * be true when the proposal is accepted, and false if\n     * the proposal is rejected.\n     */\n    proposeCodeDetails(codeDetails: IFluidCodeDetails): Promise<boolean>\n\n    /**\n     * Attaches the Container to the Container specified by the given Request.\n     *\n     * TODO - in the case of failure options should give a retry policy. Or some continuation function\n     * that allows attachment to a secondary document.\n     */\n    attach(request: IRequest): Promise<void>;\n\n    /**\n     * Extract the snapshot from the detached container.\n     */\n    serialize(): string;\n\n    /**\n     * Get an absolute url for a provided container-relative request url.\n     * If the container is not attached, this will return undefined.\n     *\n     * @param relativeUrl - A container-relative request URL\n     */\n    getAbsoluteUrl(relativeUrl: string): Promise<string | undefined>;\n\n    /**\n     * Issue a request against the container for a resource.\n     * @param request - The request to be issued against the container\n     */\n    request(request: IRequest): Promise<IResponse>;\n}\n\n/**\n * The Host's view of the Loader, used for loading Containers\n */\nexport interface ILoader extends IFluidRouter {\n    /**\n     * Resolves the resource specified by the URL + headers contained in the request object\n     * to the underlying container that will resolve the request.\n     *\n     * An analogy for this is resolve is a DNS resolve of a Fluid container. Request then executes\n     * a request against the server found from the resolve step.\n     */\n    resolve(request: IRequest): Promise<IContainer>;\n\n    /**\n     * Creates a new container using the specified chaincode but in an unattached state. While unattached all\n     * updates will only be local until the user explicitly attaches the container to a service provider.\n     */\n    createDetachedContainer(codeDetails: IFluidCodeDetails): Promise<IContainer>;\n\n    /**\n     * Creates a new container using the specified snapshot but in an unattached state. While unattached all\n     * updates will only be local until the user explicitly attaches the container to a service provider.\n     */\n    rehydrateDetachedContainerFromSnapshot(snapshot: string): Promise<IContainer>;\n}\n\nexport type ILoaderOptions = {\n    [key in string | number]: any;\n} & {\n    /**\n     * Affects the behavior of the Container when a new code proposal\n     * is accepted that the current loaded code does not satisfy.\n     * True to reload the context without closing the container, or\n     * false to only close the container.\n     * Defaults to false.\n     */\n    hotSwapContext?: boolean;\n\n    /**\n     * Set caching behavior for the loader.  If true, we will load a container from cache if one\n     * with the same id/version exists or create a new container and cache it if it does not. If\n     * false, always load a new container and don't cache it. If the container has already been\n     * closed, it will not be cached.  A cache option in the LoaderHeader for an individual\n     * request will override the Loader's value.\n     * Defaults to true.\n     */\n    cache?: boolean;\n};\n\n/**\n * Accepted header keys for requests coming to the Loader\n */\nexport enum LoaderHeader {\n    /**\n     * Override the Loader's default caching behavior for this container.\n     */\n    cache = \"fluid-cache\",\n\n    clientDetails = \"fluid-client-details\",\n    executionContext = \"execution-context\",\n\n    /**\n     * Start the container in a paused, unconnected state. Defaults to false\n     */\n    pause = \"pause\",\n    reconnect = \"fluid-reconnect\",\n    sequenceNumber = \"fluid-sequence-number\",\n\n    /**\n     * One of the following:\n     * null or \"null\": use ops, no snapshots\n     * undefined: fetch latest snapshot\n     * otherwise, version sha to load snapshot\n     */\n    version = \"version\",\n}\n\n/**\n * Set of Request Headers that the Loader understands and may inspect or modify\n */\nexport interface ILoaderHeader {\n    [LoaderHeader.cache]: boolean;\n    [LoaderHeader.clientDetails]: IClientDetails;\n    [LoaderHeader.pause]: boolean;\n    [LoaderHeader.executionContext]: string;\n    [LoaderHeader.sequenceNumber]: number;\n    [LoaderHeader.reconnect]: boolean;\n    [LoaderHeader.version]: string | undefined | null;\n}\n\ndeclare module \"@fluidframework/core-interfaces\" {\n    // eslint-disable-next-line @typescript-eslint/no-empty-interface\n    export interface IRequestHeader extends Partial<ILoaderHeader> { }\n}\n"]}