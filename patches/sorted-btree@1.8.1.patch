diff --git a/b+tree.d.ts b/b+tree.d.ts
index 93693ebe42f9467d8920e0ea7dc667c85dfba4f6..8e69e75052032cef362562f070456292714baede 100644
--- a/b+tree.d.ts
+++ b/b+tree.d.ts
@@ -1,6 +1,6 @@
 import { ISortedMap, ISortedMapF, ISortedSet } from './interfaces';
 export { ISetSource, ISetSink, ISet, ISetF, ISortedSetSource, ISortedSet, ISortedSetF, IMapSource, IMapSink, IMap, IMapF, ISortedMapSource, ISortedMap, ISortedMapF } from './interfaces';
-export declare type EditRangeResult<V, R = number> = {
+export type EditRangeResult<V, R = number> = {
     value?: V;
     break?: R;
     delete?: boolean;
@@ -8,7 +8,7 @@ export declare type EditRangeResult<V, R = number> = {
 /**
  * Types that BTree supports by default
  */
-export declare type DefaultComparable = number | string | Date | boolean | null | undefined | (number | string)[] | {
+export type DefaultComparable = number | string | Date | boolean | null | undefined | (number | string)[] | {
     valueOf: () => number | string | Date | boolean | null | undefined | (number | string)[];
 };
 /**
@@ -103,7 +103,7 @@ export declare function simpleComparator(a: (number | string)[], b: (number | st
  *
  * @author David Piepgrass
  */
-export default class BTree<K = any, V = any> implements ISortedMapF<K, V>, ISortedMap<K, V> {
+export declare class BTree<K = any, V = any> implements ISortedMapF<K, V>, ISortedMap<K, V> {
     private _root;
     _size: number;
     _maxNodeSize: number;
diff --git a/b+tree.js b/b+tree.js
index 17ae8f1d6b4c4ccccb9a46fded056dae8e371fb1..42902224481cd1c1482fdd58f784d1331c219daf 100644
--- a/b+tree.js
+++ b/b+tree.js
@@ -1,21 +1,6 @@
 "use strict";
-var __extends = (this && this.__extends) || (function () {
-    var extendStatics = function (d, b) {
-        extendStatics = Object.setPrototypeOf ||
-            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
-            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
-        return extendStatics(d, b);
-    };
-    return function (d, b) {
-        if (typeof b !== "function" && b !== null)
-            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
-        extendStatics(d, b);
-        function __() { this.constructor = d; }
-        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
-    };
-})();
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.EmptyBTree = exports.asSet = exports.simpleComparator = exports.defaultComparator = void 0;
+exports.EmptyBTree = exports.asSet = exports.BTree = exports.simpleComparator = exports.defaultComparator = void 0;
 /**
  * Compares DefaultComparables to form a strict partial ordering.
  *
@@ -30,15 +15,15 @@ exports.EmptyBTree = exports.asSet = exports.simpleComparator = exports.defaultC
 function defaultComparator(a, b) {
     // Special case finite numbers first for performance.
     // Note that the trick of using 'a - b' and checking for NaN to detect non-numbers
-    // does not work if the strings are numeric (ex: "5"). This would leading most 
+    // does not work if the strings are numeric (ex: "5"). This would leading most
     // comparison functions using that approach to fail to have transitivity.
     if (Number.isFinite(a) && Number.isFinite(b)) {
         return a - b;
     }
     // The default < and > operators are not totally ordered. To allow types to be mixed
     // in a single collection, compare types and order values of different types by type.
-    var ta = typeof a;
-    var tb = typeof b;
+    let ta = typeof a;
+    let tb = typeof b;
     if (ta !== tb) {
         return ta < tb ? -1 : 1;
     }
@@ -57,7 +42,7 @@ function defaultComparator(a, b) {
             return ta < tb ? -1 : 1;
         }
     }
-    // a and b are now the same type, and will be a number, string or array 
+    // a and b are now the same type, and will be a number, string or array
     // (which we assume holds numbers or strings), or something unsupported.
     if (a < b)
         return -1;
@@ -144,7 +129,7 @@ exports.simpleComparator = simpleComparator;
  *
  * @author David Piepgrass
  */
-var BTree = /** @class */ (function () {
+class BTree {
     /**
      * Initializes an empty B+ tree.
      * @param compare Custom function to compare pairs of elements in the tree.
@@ -153,7 +138,7 @@ var BTree = /** @class */ (function () {
      * @param maxNodeSize Branching factor (maximum items or children per node)
      *   Must be in range 4..256. If undefined or <4 then default is used; if >256 then 256.
      */
-    function BTree(entries, compare, maxNodeSize) {
+    constructor(entries, compare, maxNodeSize) {
         this._root = EmptyLeaf;
         this._size = 0;
         this._maxNodeSize = maxNodeSize >= 4 ? Math.min(maxNodeSize, 256) : 32;
@@ -161,31 +146,19 @@ var BTree = /** @class */ (function () {
         if (entries)
             this.setPairs(entries);
     }
-    Object.defineProperty(BTree.prototype, "size", {
-        /////////////////////////////////////////////////////////////////////////////
-        // ES6 Map<K,V> methods /////////////////////////////////////////////////////
-        /** Gets the number of key-value pairs in the tree. */
-        get: function () { return this._size; },
-        enumerable: false,
-        configurable: true
-    });
-    Object.defineProperty(BTree.prototype, "length", {
-        /** Gets the number of key-value pairs in the tree. */
-        get: function () { return this._size; },
-        enumerable: false,
-        configurable: true
-    });
-    Object.defineProperty(BTree.prototype, "isEmpty", {
-        /** Returns true iff the tree contains no key-value pairs. */
-        get: function () { return this._size === 0; },
-        enumerable: false,
-        configurable: true
-    });
+    /////////////////////////////////////////////////////////////////////////////
+    // ES6 Map<K,V> methods /////////////////////////////////////////////////////
+    /** Gets the number of key-value pairs in the tree. */
+    get size() { return this._size; }
+    /** Gets the number of key-value pairs in the tree. */
+    get length() { return this._size; }
+    /** Returns true iff the tree contains no key-value pairs. */
+    get isEmpty() { return this._size === 0; }
     /** Releases the tree so that its size is 0. */
-    BTree.prototype.clear = function () {
+    clear() {
         this._root = EmptyLeaf;
         this._size = 0;
-    };
+    }
     /** Runs a function for each key-value pair, in order from smallest to
      *  largest key. For compatibility with ES6 Map, the argument order to
      *  the callback is backwards: value first, then key. Call forEachPair
@@ -194,12 +167,11 @@ var BTree = /** @class */ (function () {
      *        value for each callback.
      * @returns the number of values that were sent to the callback,
      *        or the R value if the callback returned {break:R}. */
-    BTree.prototype.forEach = function (callback, thisArg) {
-        var _this = this;
+    forEach(callback, thisArg) {
         if (thisArg !== undefined)
             callback = callback.bind(thisArg);
-        return this.forEachPair(function (k, v) { return callback(v, k, _this); });
-    };
+        return this.forEachPair((k, v) => callback(v, k, this));
+    }
     /** Runs a function for each key-value pair, in order from smallest to
      *  largest key. The callback can return {break:R} (where R is any value
      *  except undefined) to stop immediately and return R from forEachPair.
@@ -214,19 +186,19 @@ var BTree = /** @class */ (function () {
      * @returns the number of pairs sent to the callback (plus initialCounter,
      *        if you provided one). If the callback returned {break:R} then
      *        the R value is returned instead. */
-    BTree.prototype.forEachPair = function (callback, initialCounter) {
+    forEachPair(callback, initialCounter) {
         var low = this.minKey(), high = this.maxKey();
         return this.forRange(low, high, true, callback, initialCounter);
-    };
+    }
     /**
      * Finds a pair in the tree and returns the associated value.
      * @param defaultValue a value to return if the key was not found.
      * @returns the value, or defaultValue if the key was not found.
      * @description Computational complexity: O(log size)
      */
-    BTree.prototype.get = function (key, defaultValue) {
+    get(key, defaultValue) {
         return this._root.get(key, defaultValue, this);
-    };
+    }
     /**
      * Adds or overwrites a key-value pair in the B+ tree.
      * @param key the key is used to determine the sort order of
@@ -241,7 +213,7 @@ var BTree = /** @class */ (function () {
      * as well as the value. This has no effect unless the new key
      * has data that does not affect its sort order.
      */
-    BTree.prototype.set = function (key, value, overwrite) {
+    set(key, value, overwrite) {
         if (this._root.isShared)
             this._root = this._root.clone();
         var result = this._root.set(key, value, overwrite, this);
@@ -250,7 +222,7 @@ var BTree = /** @class */ (function () {
         // Root node has split, so create a new root node.
         this._root = new BNodeInternal([this._root, result]);
         return true;
-    };
+    }
     /**
      * Returns true if the key exists in the B+ tree, false if not.
      * Use get() for best performance; use has() if you need to
@@ -258,27 +230,27 @@ var BTree = /** @class */ (function () {
      * @param key Key to detect
      * @description Computational complexity: O(log size)
      */
-    BTree.prototype.has = function (key) {
+    has(key) {
         return this.forRange(key, key, true, undefined) !== 0;
-    };
+    }
     /**
      * Removes a single key-value pair from the B+ tree.
      * @param key Key to find
      * @returns true if a pair was found and removed, false otherwise.
      * @description Computational complexity: O(log size)
      */
-    BTree.prototype.delete = function (key) {
+    delete(key) {
         return this.editRange(key, key, true, DeleteRange) !== 0;
-    };
-    BTree.prototype.with = function (key, value, overwrite) {
-        var nu = this.clone();
+    }
+    with(key, value, overwrite) {
+        let nu = this.clone();
         return nu.set(key, value, overwrite) || overwrite ? nu : this;
-    };
+    }
     /** Returns a copy of the tree with the specified key-value pairs set. */
-    BTree.prototype.withPairs = function (pairs, overwrite) {
-        var nu = this.clone();
+    withPairs(pairs, overwrite) {
+        let nu = this.clone();
         return nu.setPairs(pairs, overwrite) !== 0 || overwrite ? nu : this;
-    };
+    }
     /** Returns a copy of the tree with the specified keys present.
      *  @param keys The keys to add. If a key is already present in the tree,
      *         neither the existing key nor the existing value is modified.
@@ -287,67 +259,67 @@ var BTree = /** @class */ (function () {
      *  node(s) leading to existing keys are cloned even if the collection is
      *  ultimately unchanged.
     */
-    BTree.prototype.withKeys = function (keys, returnThisIfUnchanged) {
-        var nu = this.clone(), changed = false;
+    withKeys(keys, returnThisIfUnchanged) {
+        let nu = this.clone(), changed = false;
         for (var i = 0; i < keys.length; i++)
             changed = nu.set(keys[i], undefined, false) || changed;
         return returnThisIfUnchanged && !changed ? this : nu;
-    };
+    }
     /** Returns a copy of the tree with the specified key removed.
      * @param returnThisIfUnchanged if true, returns this if the key didn't exist.
      *  Performance note: due to the architecture of this class, node(s) leading
      *  to where the key would have been stored are cloned even when the key
      *  turns out not to exist and the collection is unchanged.
      */
-    BTree.prototype.without = function (key, returnThisIfUnchanged) {
+    without(key, returnThisIfUnchanged) {
         return this.withoutRange(key, key, true, returnThisIfUnchanged);
-    };
+    }
     /** Returns a copy of the tree with the specified keys removed.
      * @param returnThisIfUnchanged if true, returns this if none of the keys
      *  existed. Performance note: due to the architecture of this class,
      *  node(s) leading to where the key would have been stored are cloned
      *  even when the key turns out not to exist.
      */
-    BTree.prototype.withoutKeys = function (keys, returnThisIfUnchanged) {
-        var nu = this.clone();
+    withoutKeys(keys, returnThisIfUnchanged) {
+        let nu = this.clone();
         return nu.deleteKeys(keys) || !returnThisIfUnchanged ? nu : this;
-    };
+    }
     /** Returns a copy of the tree with the specified range of keys removed. */
-    BTree.prototype.withoutRange = function (low, high, includeHigh, returnThisIfUnchanged) {
-        var nu = this.clone();
+    withoutRange(low, high, includeHigh, returnThisIfUnchanged) {
+        let nu = this.clone();
         if (nu.deleteRange(low, high, includeHigh) === 0 && returnThisIfUnchanged)
             return this;
         return nu;
-    };
+    }
     /** Returns a copy of the tree with pairs removed whenever the callback
      *  function returns false. `where()` is a synonym for this method. */
-    BTree.prototype.filter = function (callback, returnThisIfUnchanged) {
+    filter(callback, returnThisIfUnchanged) {
         var nu = this.greedyClone();
         var del;
-        nu.editAll(function (k, v, i) {
+        nu.editAll((k, v, i) => {
             if (!callback(k, v, i))
                 return del = Delete;
         });
         if (!del && returnThisIfUnchanged)
             return this;
         return nu;
-    };
+    }
     /** Returns a copy of the tree with all values altered by a callback function. */
-    BTree.prototype.mapValues = function (callback) {
+    mapValues(callback) {
         var tmp = {};
         var nu = this.greedyClone();
-        nu.editAll(function (k, v, i) {
+        nu.editAll((k, v, i) => {
             return tmp.value = callback(v, k, i), tmp;
         });
         return nu;
-    };
-    BTree.prototype.reduce = function (callback, initialValue) {
-        var i = 0, p = initialValue;
+    }
+    reduce(callback, initialValue) {
+        let i = 0, p = initialValue;
         var it = this.entries(this.minKey(), ReusedArray), next;
         while (!(next = it.next()).done)
             p = callback(p, next.value, i++, this);
         return p;
-    };
+    }
     /////////////////////////////////////////////////////////////////////////////
     // Iterator methods /////////////////////////////////////////////////////////
     /** Returns an iterator that provides items in order (ascending order if
@@ -358,14 +330,14 @@ var BTree = /** @class */ (function () {
      *  @param reusedArray Optional array used repeatedly to store key-value
      *         pairs, to avoid creating a new array on every iteration.
      */
-    BTree.prototype.entries = function (lowestKey, reusedArray) {
+    entries(lowestKey, reusedArray) {
         var info = this.findPath(lowestKey);
         if (info === undefined)
             return iterator();
-        var nodequeue = info.nodequeue, nodeindex = info.nodeindex, leaf = info.leaf;
+        var { nodequeue, nodeindex, leaf } = info;
         var state = reusedArray !== undefined ? 1 : 0;
         var i = (lowestKey === undefined ? -1 : leaf.indexOf(lowestKey, 0, this._compare) - 1);
-        return iterator(function () {
+        return iterator(() => {
             jump: for (;;) {
                 switch (state) {
                     case 0:
@@ -402,7 +374,7 @@ var BTree = /** @class */ (function () {
                 }
             }
         });
-    };
+    }
     /** Returns an iterator that provides items in reversed order.
      *  @param highestKey Key at which to start iterating, or undefined to
      *         start at maxKey(). If the specified key doesn't exist then iteration
@@ -412,20 +384,20 @@ var BTree = /** @class */ (function () {
      *  @param skipHighest Iff this flag is true and the highestKey exists in the
      *         collection, the pair matching highestKey is skipped, not iterated.
      */
-    BTree.prototype.entriesReversed = function (highestKey, reusedArray, skipHighest) {
+    entriesReversed(highestKey, reusedArray, skipHighest) {
         if (highestKey === undefined) {
             highestKey = this.maxKey();
             skipHighest = undefined;
             if (highestKey === undefined)
                 return iterator(); // collection is empty
         }
-        var _a = this.findPath(highestKey) || this.findPath(this.maxKey()), nodequeue = _a.nodequeue, nodeindex = _a.nodeindex, leaf = _a.leaf;
+        var { nodequeue, nodeindex, leaf } = this.findPath(highestKey) || this.findPath(this.maxKey());
         check(!nodequeue[0] || leaf === nodequeue[0][nodeindex[0]], "wat!");
         var i = leaf.indexOf(highestKey, 0, this._compare);
         if (!skipHighest && i < leaf.keys.length && this._compare(leaf.keys[i], highestKey) <= 0)
             i++;
         var state = reusedArray !== undefined ? 1 : 0;
-        return iterator(function () {
+        return iterator(() => {
             jump: for (;;) {
                 switch (state) {
                     case 0:
@@ -462,7 +434,7 @@ var BTree = /** @class */ (function () {
                 }
             }
         });
-    };
+    }
     /* Used by entries() and entriesReversed() to prepare to start iterating.
      * It develops a "node queue" for each non-leaf level of the tree.
      * Levels are numbered "bottom-up" so that level 0 is a list of leaf
@@ -472,7 +444,7 @@ var BTree = /** @class */ (function () {
      * such that nodequeue[L-1] === nodequeue[L][nodeindex[L]].children.
      * (However inside this function the order is reversed.)
      */
-    BTree.prototype.findPath = function (key) {
+    findPath(key) {
         var nextnode = this._root;
         var nodequeue, nodeindex;
         if (nextnode.isLeaf) {
@@ -490,8 +462,8 @@ var BTree = /** @class */ (function () {
             nodequeue.reverse();
             nodeindex.reverse();
         }
-        return { nodequeue: nodequeue, nodeindex: nodeindex, leaf: nextnode };
-    };
+        return { nodequeue, nodeindex, leaf: nextnode };
+    }
     /**
      * Computes the differences between `this` and `other`.
      * For efficiency, the diff is returned via invocations of supplied handlers.
@@ -505,7 +477,7 @@ var BTree = /** @class */ (function () {
      * @param onlyOther Callback invoked for all keys only present in `other`.
      * @param different Callback invoked for all keys with differing values.
      */
-    BTree.prototype.diffAgainst = function (other, onlyThis, onlyOther, different) {
+    diffAgainst(other, onlyThis, onlyOther, different) {
         if (other._compare !== this._compare) {
             throw new Error("Tree comparators are not the same.");
         }
@@ -525,36 +497,36 @@ var BTree = /** @class */ (function () {
         //    - If either cursor points to a key/value pair:
         //      - If thisCursor === otherCursor and the values differ, it is a Different.
         //      - If thisCursor > otherCursor and otherCursor is at a key/value pair, it is an OnlyOther.
-        //      - If thisCursor < otherCursor and thisCursor is at a key/value pair, it is an OnlyThis as long as the most recent 
-        //        cursor step was *not* otherCursor advancing from a tie. The extra condition avoids erroneous OnlyOther calls 
+        //      - If thisCursor < otherCursor and thisCursor is at a key/value pair, it is an OnlyThis as long as the most recent
+        //        cursor step was *not* otherCursor advancing from a tie. The extra condition avoids erroneous OnlyOther calls
         //        that would occur due to otherCursor being the "leader".
         //    - Otherwise, if both cursors point to nodes, compare them. If they are equal by reference (shared), skip
         //      both cursors to the next node in the walk.
         // - Once one cursor has finished stepping, any remaining steps (if any) are taken and key/value pairs are logged
         //   as OnlyOther (if otherCursor is stepping) or OnlyThis (if thisCursor is stepping).
-        // This algorithm gives the critical guarantee that all locations (both nodes and key/value pairs) in both trees that 
+        // This algorithm gives the critical guarantee that all locations (both nodes and key/value pairs) in both trees that
         // are identical by value (and possibly by reference) will be visited *at the same time* by the cursors.
         // This removes the possibility of emitting incorrect diffs, as well as allowing for skipping shared nodes.
-        var _compare = this._compare;
-        var thisCursor = BTree.makeDiffCursor(this);
-        var otherCursor = BTree.makeDiffCursor(other);
+        const { _compare } = this;
+        const thisCursor = BTree.makeDiffCursor(this);
+        const otherCursor = BTree.makeDiffCursor(other);
         // It doesn't matter how thisSteppedLast is initialized.
         // Step order is only used when either cursor is at a leaf, and cursors always start at a node.
-        var thisSuccess = true, otherSuccess = true, prevCursorOrder = BTree.compare(thisCursor, otherCursor, _compare);
+        let thisSuccess = true, otherSuccess = true, prevCursorOrder = BTree.compare(thisCursor, otherCursor, _compare);
         while (thisSuccess && otherSuccess) {
-            var cursorOrder = BTree.compare(thisCursor, otherCursor, _compare);
-            var thisLeaf = thisCursor.leaf, thisInternalSpine = thisCursor.internalSpine, thisLevelIndices = thisCursor.levelIndices;
-            var otherLeaf = otherCursor.leaf, otherInternalSpine = otherCursor.internalSpine, otherLevelIndices = otherCursor.levelIndices;
+            const cursorOrder = BTree.compare(thisCursor, otherCursor, _compare);
+            const { leaf: thisLeaf, internalSpine: thisInternalSpine, levelIndices: thisLevelIndices } = thisCursor;
+            const { leaf: otherLeaf, internalSpine: otherInternalSpine, levelIndices: otherLevelIndices } = otherCursor;
             if (thisLeaf || otherLeaf) {
                 // If the cursors were at the same location last step, then there is no work to be done.
                 if (prevCursorOrder !== 0) {
                     if (cursorOrder === 0) {
                         if (thisLeaf && otherLeaf && different) {
                             // Equal keys, check for modifications
-                            var valThis = thisLeaf.values[thisLevelIndices[thisLevelIndices.length - 1]];
-                            var valOther = otherLeaf.values[otherLevelIndices[otherLevelIndices.length - 1]];
+                            const valThis = thisLeaf.values[thisLevelIndices[thisLevelIndices.length - 1]];
+                            const valOther = otherLeaf.values[otherLevelIndices[otherLevelIndices.length - 1]];
                             if (!Object.is(valThis, valOther)) {
-                                var result = different(thisCursor.currentKey, valThis, valOther);
+                                const result = different(thisCursor.currentKey, valThis, valOther);
                                 if (result && result.break)
                                     return result.break;
                             }
@@ -566,16 +538,16 @@ var BTree = /** @class */ (function () {
                         // 2. thisCursor stepped last and leapfrogged otherCursor
                         // Either of these cases is an "only other"
                         if (otherLeaf && onlyOther) {
-                            var otherVal = otherLeaf.values[otherLevelIndices[otherLevelIndices.length - 1]];
-                            var result = onlyOther(otherCursor.currentKey, otherVal);
+                            const otherVal = otherLeaf.values[otherLevelIndices[otherLevelIndices.length - 1]];
+                            const result = onlyOther(otherCursor.currentKey, otherVal);
                             if (result && result.break)
                                 return result.break;
                         }
                     }
                     else if (onlyThis) {
                         if (thisLeaf && prevCursorOrder !== 0) {
-                            var valThis = thisLeaf.values[thisLevelIndices[thisLevelIndices.length - 1]];
-                            var result = onlyThis(thisCursor.currentKey, valThis);
+                            const valThis = thisLeaf.values[thisLevelIndices[thisLevelIndices.length - 1]];
+                            const result = onlyThis(thisCursor.currentKey, valThis);
                             if (result && result.break)
                                 return result.break;
                         }
@@ -583,10 +555,10 @@ var BTree = /** @class */ (function () {
                 }
             }
             else if (!thisLeaf && !otherLeaf && cursorOrder === 0) {
-                var lastThis = thisInternalSpine.length - 1;
-                var lastOther = otherInternalSpine.length - 1;
-                var nodeThis = thisInternalSpine[lastThis][thisLevelIndices[lastThis]];
-                var nodeOther = otherInternalSpine[lastOther][otherLevelIndices[lastOther]];
+                const lastThis = thisInternalSpine.length - 1;
+                const lastOther = otherInternalSpine.length - 1;
+                const nodeThis = thisInternalSpine[lastThis][thisLevelIndices[lastThis]];
+                const nodeOther = otherInternalSpine[lastOther][otherLevelIndices[lastOther]];
                 if (nodeOther === nodeThis) {
                     prevCursorOrder = 0;
                     thisSuccess = BTree.step(thisCursor, true);
@@ -606,11 +578,11 @@ var BTree = /** @class */ (function () {
             return BTree.finishCursorWalk(thisCursor, otherCursor, _compare, onlyThis);
         if (otherSuccess && onlyOther)
             return BTree.finishCursorWalk(otherCursor, thisCursor, _compare, onlyOther);
-    };
+    }
     ///////////////////////////////////////////////////////////////////////////
     // Helper methods for diffAgainst /////////////////////////////////////////
-    BTree.finishCursorWalk = function (cursor, cursorFinished, compareKeys, callback) {
-        var compared = BTree.compare(cursor, cursorFinished, compareKeys);
+    static finishCursorWalk(cursor, cursorFinished, compareKeys, callback) {
+        const compared = BTree.compare(cursor, cursorFinished, compareKeys);
         if (compared === 0) {
             if (!BTree.step(cursor))
                 return undefined;
@@ -619,25 +591,25 @@ var BTree = /** @class */ (function () {
             check(false, "cursor walk terminated early");
         }
         return BTree.stepToEnd(cursor, callback);
-    };
-    BTree.stepToEnd = function (cursor, callback) {
-        var canStep = true;
+    }
+    static stepToEnd(cursor, callback) {
+        let canStep = true;
         while (canStep) {
-            var leaf = cursor.leaf, levelIndices = cursor.levelIndices, currentKey = cursor.currentKey;
+            const { leaf, levelIndices, currentKey } = cursor;
             if (leaf) {
-                var value = leaf.values[levelIndices[levelIndices.length - 1]];
-                var result = callback(currentKey, value);
+                const value = leaf.values[levelIndices[levelIndices.length - 1]];
+                const result = callback(currentKey, value);
                 if (result && result.break)
                     return result.break;
             }
             canStep = BTree.step(cursor);
         }
         return undefined;
-    };
-    BTree.makeDiffCursor = function (tree) {
-        var _root = tree._root, height = tree.height;
+    }
+    static makeDiffCursor(tree) {
+        const { _root, height } = tree;
         return { height: height, internalSpine: [[_root]], levelIndices: [0], leaf: undefined, currentKey: _root.maxKey() };
-    };
+    }
     /**
      * Advances the cursor to the next step in the walk of its tree.
      * Cursors are walked backwards in sort order, as this allows them to leverage maxKey() in order to be compared in O(1).
@@ -645,21 +617,21 @@ var BTree = /** @class */ (function () {
      * @param stepToNode If true, the cursor will be advanced to the next node (skipping values)
      * @returns true if the step was completed and false if the step would have caused the cursor to move beyond the end of the tree.
      */
-    BTree.step = function (cursor, stepToNode) {
-        var internalSpine = cursor.internalSpine, levelIndices = cursor.levelIndices, leaf = cursor.leaf;
+    static step(cursor, stepToNode) {
+        const { internalSpine, levelIndices, leaf } = cursor;
         if (stepToNode === true || leaf) {
-            var levelsLength = levelIndices.length;
+            const levelsLength = levelIndices.length;
             // Step to the next node only if:
             // - We are explicitly directed to via stepToNode, or
             // - There are no key/value pairs left to step to in this leaf
             if (stepToNode === true || levelIndices[levelsLength - 1] === 0) {
-                var spineLength = internalSpine.length;
+                const spineLength = internalSpine.length;
                 // Root is leaf
                 if (spineLength === 0)
                     return false;
                 // Walk back up the tree until we find a new subtree to descend into
-                var nodeLevelIndex = spineLength - 1;
-                var levelIndexWalkBack = nodeLevelIndex;
+                const nodeLevelIndex = spineLength - 1;
+                let levelIndexWalkBack = nodeLevelIndex;
                 while (levelIndexWalkBack >= 0) {
                     if (levelIndices[levelIndexWalkBack] > 0) {
                         if (levelIndexWalkBack < levelsLength - 1) {
@@ -681,40 +653,40 @@ var BTree = /** @class */ (function () {
             }
             else {
                 // Move to new leaf value
-                var valueIndex = --levelIndices[levelsLength - 1];
+                const valueIndex = --levelIndices[levelsLength - 1];
                 cursor.currentKey = leaf.keys[valueIndex];
                 return true;
             }
         }
         else { // Cursor does not point to a value in a leaf, so move downwards
-            var nextLevel = internalSpine.length;
-            var currentLevel = nextLevel - 1;
-            var node = internalSpine[currentLevel][levelIndices[currentLevel]];
+            const nextLevel = internalSpine.length;
+            const currentLevel = nextLevel - 1;
+            const node = internalSpine[currentLevel][levelIndices[currentLevel]];
             if (node.isLeaf) {
                 // Entering into a leaf. Set the cursor to point at the last key/value pair.
                 cursor.leaf = node;
-                var valueIndex = levelIndices[nextLevel] = node.values.length - 1;
+                const valueIndex = levelIndices[nextLevel] = node.values.length - 1;
                 cursor.currentKey = node.keys[valueIndex];
             }
             else {
-                var children = node.children;
+                const children = node.children;
                 internalSpine[nextLevel] = children;
-                var childIndex = children.length - 1;
+                const childIndex = children.length - 1;
                 levelIndices[nextLevel] = childIndex;
                 cursor.currentKey = children[childIndex].maxKey();
             }
             return true;
         }
-    };
+    }
     /**
      * Compares the two cursors. Returns a value indicating which cursor is ahead in a walk.
      * Note that cursors are advanced in reverse sorting order.
      */
-    BTree.compare = function (cursorA, cursorB, compareKeys) {
-        var heightA = cursorA.height, currentKeyA = cursorA.currentKey, levelIndicesA = cursorA.levelIndices;
-        var heightB = cursorB.height, currentKeyB = cursorB.currentKey, levelIndicesB = cursorB.levelIndices;
+    static compare(cursorA, cursorB, compareKeys) {
+        const { height: heightA, currentKey: currentKeyA, levelIndices: levelIndicesA } = cursorA;
+        const { height: heightB, currentKey: currentKeyB, levelIndices: levelIndicesB } = cursorB;
         // Reverse the comparison order, as cursors are advanced in reverse sorting order
-        var keyComparison = compareKeys(currentKeyB, currentKeyA);
+        const keyComparison = compareKeys(currentKeyB, currentKeyA);
         if (keyComparison !== 0) {
             return keyComparison;
         }
@@ -723,142 +695,137 @@ var BTree = /** @class */ (function () {
         // To accomplish this, a cursor that is on an internal node at depth D1 with maxKey X is considered "behind" a cursor on an
         // internal node at depth D2 with maxKey Y, when D1 < D2. Thus, always walking the cursor that is "behind" will allow the cursor
         // at shallower depth (but equal maxKey) to "catch up" and land on shared nodes.
-        var heightMin = heightA < heightB ? heightA : heightB;
-        var depthANormalized = levelIndicesA.length - (heightA - heightMin);
-        var depthBNormalized = levelIndicesB.length - (heightB - heightMin);
+        const heightMin = heightA < heightB ? heightA : heightB;
+        const depthANormalized = levelIndicesA.length - (heightA - heightMin);
+        const depthBNormalized = levelIndicesB.length - (heightB - heightMin);
         return depthANormalized - depthBNormalized;
-    };
+    }
     // End of helper methods for diffAgainst //////////////////////////////////
     ///////////////////////////////////////////////////////////////////////////
     /** Returns a new iterator for iterating the keys of each pair in ascending order.
      *  @param firstKey: Minimum key to include in the output. */
-    BTree.prototype.keys = function (firstKey) {
+    keys(firstKey) {
         var it = this.entries(firstKey, ReusedArray);
-        return iterator(function () {
+        return iterator(() => {
             var n = it.next();
             if (n.value)
                 n.value = n.value[0];
             return n;
         });
-    };
+    }
     /** Returns a new iterator for iterating the values of each pair in order by key.
      *  @param firstKey: Minimum key whose associated value is included in the output. */
-    BTree.prototype.values = function (firstKey) {
+    values(firstKey) {
         var it = this.entries(firstKey, ReusedArray);
-        return iterator(function () {
+        return iterator(() => {
             var n = it.next();
             if (n.value)
                 n.value = n.value[1];
             return n;
         });
-    };
-    Object.defineProperty(BTree.prototype, "maxNodeSize", {
-        /////////////////////////////////////////////////////////////////////////////
-        // Additional methods ///////////////////////////////////////////////////////
-        /** Returns the maximum number of children/values before nodes will split. */
-        get: function () {
-            return this._maxNodeSize;
-        },
-        enumerable: false,
-        configurable: true
-    });
+    }
+    /////////////////////////////////////////////////////////////////////////////
+    // Additional methods ///////////////////////////////////////////////////////
+    /** Returns the maximum number of children/values before nodes will split. */
+    get maxNodeSize() {
+        return this._maxNodeSize;
+    }
     /** Gets the lowest key in the tree. Complexity: O(log size) */
-    BTree.prototype.minKey = function () { return this._root.minKey(); };
+    minKey() { return this._root.minKey(); }
     /** Gets the highest key in the tree. Complexity: O(1) */
-    BTree.prototype.maxKey = function () { return this._root.maxKey(); };
+    maxKey() { return this._root.maxKey(); }
     /** Quickly clones the tree by marking the root node as shared.
      *  Both copies remain editable. When you modify either copy, any
      *  nodes that are shared (or potentially shared) between the two
      *  copies are cloned so that the changes do not affect other copies.
      *  This is known as copy-on-write behavior, or "lazy copying". */
-    BTree.prototype.clone = function () {
+    clone() {
         this._root.isShared = true;
         var result = new BTree(undefined, this._compare, this._maxNodeSize);
         result._root = this._root;
         result._size = this._size;
         return result;
-    };
+    }
     /** Performs a greedy clone, immediately duplicating any nodes that are
      *  not currently marked as shared, in order to avoid marking any
      *  additional nodes as shared.
      *  @param force Clone all nodes, even shared ones.
      */
-    BTree.prototype.greedyClone = function (force) {
+    greedyClone(force) {
         var result = new BTree(undefined, this._compare, this._maxNodeSize);
         result._root = this._root.greedyClone(force);
         result._size = this._size;
         return result;
-    };
+    }
     /** Gets an array filled with the contents of the tree, sorted by key */
-    BTree.prototype.toArray = function (maxLength) {
-        if (maxLength === void 0) { maxLength = 0x7FFFFFFF; }
-        var min = this.minKey(), max = this.maxKey();
+    toArray(maxLength = 0x7FFFFFFF) {
+        let min = this.minKey(), max = this.maxKey();
         if (min !== undefined)
             return this.getRange(min, max, true, maxLength);
         return [];
-    };
+    }
     /** Gets an array of all keys, sorted */
-    BTree.prototype.keysArray = function () {
+    keysArray() {
         var results = [];
-        this._root.forRange(this.minKey(), this.maxKey(), true, false, this, 0, function (k, v) { results.push(k); });
+        this._root.forRange(this.minKey(), this.maxKey(), true, false, this, 0, (k, v) => { results.push(k); });
         return results;
-    };
+    }
     /** Gets an array of all values, sorted by key */
-    BTree.prototype.valuesArray = function () {
+    valuesArray() {
         var results = [];
-        this._root.forRange(this.minKey(), this.maxKey(), true, false, this, 0, function (k, v) { results.push(v); });
+        this._root.forRange(this.minKey(), this.maxKey(), true, false, this, 0, (k, v) => { results.push(v); });
         return results;
-    };
+    }
     /** Gets a string representing the tree's data based on toArray(). */
-    BTree.prototype.toString = function () {
+    toString() {
         return this.toArray().toString();
-    };
+    }
     /** Stores a key-value pair only if the key doesn't already exist in the tree.
      * @returns true if a new key was added
     */
-    BTree.prototype.setIfNotPresent = function (key, value) {
+    setIfNotPresent(key, value) {
         return this.set(key, value, false);
-    };
+    }
     /** Returns the next pair whose key is larger than the specified key (or undefined if there is none).
      * If key === undefined, this function returns the lowest pair.
      * @param key The key to search for.
      * @param reusedArray Optional array used repeatedly to store key-value pairs, to
      * avoid creating a new array on every iteration.
      */
-    BTree.prototype.nextHigherPair = function (key, reusedArray) {
+    nextHigherPair(key, reusedArray) {
         reusedArray = reusedArray || [];
         if (key === undefined) {
             return this._root.minPair(reusedArray);
         }
         return this._root.getPairOrNextHigher(key, this._compare, false, reusedArray);
-    };
+    }
     /** Returns the next key larger than the specified key, or undefined if there is none.
      *  Also, nextHigherKey(undefined) returns the lowest key.
      */
-    BTree.prototype.nextHigherKey = function (key) {
+    nextHigherKey(key) {
         var p = this.nextHigherPair(key, ReusedArray);
         return p && p[0];
-    };
+    }
     /** Returns the next pair whose key is smaller than the specified key (or undefined if there is none).
      *  If key === undefined, this function returns the highest pair.
      * @param key The key to search for.
      * @param reusedArray Optional array used repeatedly to store key-value pairs, to
      *        avoid creating a new array each time you call this method.
      */
-    BTree.prototype.nextLowerPair = function (key, reusedArray) {
+    nextLowerPair(key, reusedArray) {
         reusedArray = reusedArray || [];
         if (key === undefined) {
             return this._root.maxPair(reusedArray);
         }
         return this._root.getPairOrNextLower(key, this._compare, false, reusedArray);
-    };
+    }
     /** Returns the next key smaller than the specified key, or undefined if there is none.
      *  Also, nextLowerKey(undefined) returns the highest key.
      */
-    BTree.prototype.nextLowerKey = function (key) {
+    nextLowerKey(key) {
         var p = this.nextLowerPair(key, ReusedArray);
         return p && p[0];
-    };
+    }
     /** Returns the key-value pair associated with the supplied key if it exists
      *  or the pair associated with the next lower pair otherwise. If there is no
      *  next lower pair, undefined is returned.
@@ -866,9 +833,9 @@ var BTree = /** @class */ (function () {
      * @param reusedArray Optional array used repeatedly to store key-value pairs, to
      *        avoid creating a new array each time you call this method.
      * */
-    BTree.prototype.getPairOrNextLower = function (key, reusedArray) {
+    getPairOrNextLower(key, reusedArray) {
         return this._root.getPairOrNextLower(key, this._compare, true, reusedArray || []);
-    };
+    }
     /** Returns the key-value pair associated with the supplied key if it exists
      *  or the pair associated with the next lower pair otherwise. If there is no
      *  next lower pair, undefined is returned.
@@ -876,15 +843,15 @@ var BTree = /** @class */ (function () {
      * @param reusedArray Optional array used repeatedly to store key-value pairs, to
      *        avoid creating a new array each time you call this method.
      * */
-    BTree.prototype.getPairOrNextHigher = function (key, reusedArray) {
+    getPairOrNextHigher(key, reusedArray) {
         return this._root.getPairOrNextHigher(key, this._compare, true, reusedArray || []);
-    };
+    }
     /** Edits the value associated with a key in the tree, if it already exists.
      * @returns true if the key existed, false if not.
     */
-    BTree.prototype.changeIfPresent = function (key, value) {
-        return this.editRange(key, key, true, function (k, v) { return ({ value: value }); }) !== 0;
-    };
+    changeIfPresent(key, value) {
+        return this.editRange(key, key, true, (k, v) => ({ value })) !== 0;
+    }
     /**
      * Builds an array of pairs from the specified range of keys, sorted by key.
      * Each returned pair is also an array: pair[0] is the key, pair[1] is the value.
@@ -897,15 +864,14 @@ var BTree = /** @class */ (function () {
      *                  the array reaches this size.
      * @description Computational complexity: O(result.length + log size)
      */
-    BTree.prototype.getRange = function (low, high, includeHigh, maxLength) {
-        if (maxLength === void 0) { maxLength = 0x3FFFFFF; }
+    getRange(low, high, includeHigh, maxLength = 0x3FFFFFF) {
         var results = [];
-        this._root.forRange(low, high, includeHigh, false, this, 0, function (k, v) {
+        this._root.forRange(low, high, includeHigh, false, this, 0, (k, v) => {
             results.push([k, v]);
             return results.length > maxLength ? Break : undefined;
         });
         return results;
-    };
+    }
     /** Adds all pairs from a list of key-value pairs.
      * @param pairs Pairs to add to this tree. If there are duplicate keys,
      *        later pairs currently overwrite earlier ones (e.g. [[0,1],[0,7]]
@@ -915,13 +881,13 @@ var BTree = /** @class */ (function () {
      * @returns The number of pairs added to the collection.
      * @description Computational complexity: O(pairs.length * log(size + pairs.length))
      */
-    BTree.prototype.setPairs = function (pairs, overwrite) {
+    setPairs(pairs, overwrite) {
         var added = 0;
         for (var i = 0; i < pairs.length; i++)
             if (this.set(pairs[i][0], pairs[i][1], overwrite))
                 added++;
         return added;
-    };
+    }
     /**
      * Scans the specified range of keys, in ascending order by key.
      * Note: the callback `onFound` must not insert or remove items in the
@@ -939,10 +905,10 @@ var BTree = /** @class */ (function () {
      *        `{break:R}` to stop early.
      * @description Computational complexity: O(number of items scanned + log size)
      */
-    BTree.prototype.forRange = function (low, high, includeHigh, onFound, initialCounter) {
+    forRange(low, high, includeHigh, onFound, initialCounter) {
         var r = this._root.forRange(low, high, includeHigh, false, this, initialCounter || 0, onFound);
         return typeof r === "number" ? r : r.break;
-    };
+    }
     /**
      * Scans and potentially modifies values for a subsequence of keys.
      * Note: the callback `onFound` should ideally be a pure function.
@@ -972,7 +938,7 @@ var BTree = /** @class */ (function () {
      *   nodes are copied before `onFound` is called. This takes O(n) time
      *   where n is proportional to the amount of shared data scanned.
      */
-    BTree.prototype.editRange = function (low, high, includeHigh, onFound, initialCounter) {
+    editRange(low, high, includeHigh, onFound, initialCounter) {
         var root = this._root;
         if (root.isShared)
             this._root = root = root.clone();
@@ -981,7 +947,7 @@ var BTree = /** @class */ (function () {
             return typeof r === "number" ? r : r.break;
         }
         finally {
-            var isShared = void 0;
+            let isShared;
             while (root.keys.length <= 1 && !root.isLeaf) {
                 isShared || (isShared = root.isShared);
                 this._root = root = root.keys.length === 0 ? EmptyLeaf :
@@ -992,11 +958,11 @@ var BTree = /** @class */ (function () {
                 root.isShared = true;
             }
         }
-    };
+    }
     /** Same as `editRange` except that the callback is called for all pairs. */
-    BTree.prototype.editAll = function (onFound, initialCounter) {
+    editAll(onFound, initialCounter) {
         return this.editRange(this.minKey(), this.maxKey(), true, onFound, initialCounter);
-    };
+    }
     /**
      * Removes a range of key-value pairs from the B+ tree.
      * @param low The first key scanned will be greater than or equal to `low`.
@@ -1005,47 +971,43 @@ var BTree = /** @class */ (function () {
      * @returns The number of key-value pairs that were deleted.
      * @description Computational complexity: O(log size + number of items deleted)
      */
-    BTree.prototype.deleteRange = function (low, high, includeHigh) {
+    deleteRange(low, high, includeHigh) {
         return this.editRange(low, high, includeHigh, DeleteRange);
-    };
+    }
     /** Deletes a series of keys from the collection. */
-    BTree.prototype.deleteKeys = function (keys) {
+    deleteKeys(keys) {
         for (var i = 0, r = 0; i < keys.length; i++)
             if (this.delete(keys[i]))
                 r++;
         return r;
-    };
-    Object.defineProperty(BTree.prototype, "height", {
-        /** Gets the height of the tree: the number of internal nodes between the
-         *  BTree object and its leaf nodes (zero if there are no internal nodes). */
-        get: function () {
-            var node = this._root;
-            var height = -1;
-            while (node) {
-                height++;
-                node = node.isLeaf ? undefined : node.children[0];
-            }
-            return height;
-        },
-        enumerable: false,
-        configurable: true
-    });
+    }
+    /** Gets the height of the tree: the number of internal nodes between the
+     *  BTree object and its leaf nodes (zero if there are no internal nodes). */
+    get height() {
+        let node = this._root;
+        let height = -1;
+        while (node) {
+            height++;
+            node = node.isLeaf ? undefined : node.children[0];
+        }
+        return height;
+    }
     /** Makes the object read-only to ensure it is not accidentally modified.
      *  Freezing does not have to be permanent; unfreeze() reverses the effect.
      *  This is accomplished by replacing mutator functions with a function
      *  that throws an Error. Compared to using a property (e.g. this.isFrozen)
      *  this implementation gives better performance in non-frozen BTrees.
      */
-    BTree.prototype.freeze = function () {
+    freeze() {
         var t = this;
-        // Note: all other mutators ultimately call set() or editRange() 
+        // Note: all other mutators ultimately call set() or editRange()
         //       so we don't need to override those others.
         t.clear = t.set = t.editRange = function () {
             throw new Error("Attempted to modify a frozen BTree");
         };
-    };
+    }
     /** Ensures mutations are allowed, reversing the effect of freeze(). */
-    BTree.prototype.unfreeze = function () {
+    unfreeze() {
         // @ts-ignore "The operand of a 'delete' operator must be optional."
         //            (wrong: delete does not affect the prototype.)
         delete this.clear;
@@ -1053,27 +1015,22 @@ var BTree = /** @class */ (function () {
         delete this.set;
         // @ts-ignore
         delete this.editRange;
-    };
-    Object.defineProperty(BTree.prototype, "isFrozen", {
-        /** Returns true if the tree appears to be frozen. */
-        get: function () {
-            return this.hasOwnProperty('editRange');
-        },
-        enumerable: false,
-        configurable: true
-    });
+    }
+    /** Returns true if the tree appears to be frozen. */
+    get isFrozen() {
+        return this.hasOwnProperty('editRange');
+    }
     /** Scans the tree for signs of serious bugs (e.g. this.size doesn't match
      *  number of elements, internal nodes not caching max element properly...)
      *  Computational complexity: O(number of nodes), i.e. O(size). This method
      *  skips the most expensive test - whether all keys are sorted - but it
      *  does check that maxKey() of the children of internal nodes are sorted. */
-    BTree.prototype.checkValid = function () {
+    checkValid() {
         var size = this._root.checkValid(0, this, 0);
         check(size === this.size, "size mismatch: counted ", size, "but stored", this.size);
-    };
-    return BTree;
-}());
-exports.default = BTree;
+    }
+}
+exports.BTree = BTree;
 /** A TypeScript helper function that simply returns its argument, typed as
  *  `ISortedSet<K>` if the BTree implements it, as it does if `V extends undefined`.
  *  If `V` cannot be `undefined`, it returns `unknown` instead. Or at least, that
@@ -1088,35 +1045,29 @@ if (Symbol && Symbol.iterator) // iterator is equivalent to entries()
 BTree.prototype.where = BTree.prototype.filter;
 BTree.prototype.setRange = BTree.prototype.setPairs;
 BTree.prototype.add = BTree.prototype.set; // for compatibility with ISetSink<K>
-function iterator(next) {
-    if (next === void 0) { next = (function () { return ({ done: true, value: undefined }); }); }
-    var result = { next: next };
+function iterator(next = (() => ({ done: true, value: undefined }))) {
+    var result = { next };
     if (Symbol && Symbol.iterator)
         result[Symbol.iterator] = function () { return this; };
     return result;
 }
 /** Leaf node / base class. **************************************************/
-var BNode = /** @class */ (function () {
-    function BNode(keys, values) {
-        if (keys === void 0) { keys = []; }
+class BNode {
+    get isLeaf() { return this.children === undefined; }
+    constructor(keys = [], values) {
         this.keys = keys;
         this.values = values || undefVals;
         this.isShared = undefined;
     }
-    Object.defineProperty(BNode.prototype, "isLeaf", {
-        get: function () { return this.children === undefined; },
-        enumerable: false,
-        configurable: true
-    });
     ///////////////////////////////////////////////////////////////////////////
     // Shared methods /////////////////////////////////////////////////////////
-    BNode.prototype.maxKey = function () {
+    maxKey() {
         return this.keys[this.keys.length - 1];
-    };
+    }
     // If key not found, returns i^failXor where i is the insertion index.
     // Callers that don't care whether there was a match will set failXor=0.
-    BNode.prototype.indexOf = function (key, failXor, cmp) {
-        var keys = this.keys;
+    indexOf(key, failXor, cmp) {
+        const keys = this.keys;
         var lo = 0, hi = keys.length, mid = hi >> 1;
         while (lo < hi) {
             var c = cmp(keys[mid], key);
@@ -1180,73 +1131,73 @@ var BNode = /** @class */ (function () {
             throw new Error("BTree: NaN was used as a key");
         }
         return c === 0 ? i : i ^ failXor;*/
-    };
+    }
     /////////////////////////////////////////////////////////////////////////////
     // Leaf Node: misc //////////////////////////////////////////////////////////
-    BNode.prototype.minKey = function () {
+    minKey() {
         return this.keys[0];
-    };
-    BNode.prototype.minPair = function (reusedArray) {
+    }
+    minPair(reusedArray) {
         if (this.keys.length === 0)
             return undefined;
         reusedArray[0] = this.keys[0];
         reusedArray[1] = this.values[0];
         return reusedArray;
-    };
-    BNode.prototype.maxPair = function (reusedArray) {
+    }
+    maxPair(reusedArray) {
         if (this.keys.length === 0)
             return undefined;
-        var lastIndex = this.keys.length - 1;
+        const lastIndex = this.keys.length - 1;
         reusedArray[0] = this.keys[lastIndex];
         reusedArray[1] = this.values[lastIndex];
         return reusedArray;
-    };
-    BNode.prototype.clone = function () {
+    }
+    clone() {
         var v = this.values;
         return new BNode(this.keys.slice(0), v === undefVals ? v : v.slice(0));
-    };
-    BNode.prototype.greedyClone = function (force) {
+    }
+    greedyClone(force) {
         return this.isShared && !force ? this : this.clone();
-    };
-    BNode.prototype.get = function (key, defaultValue, tree) {
+    }
+    get(key, defaultValue, tree) {
         var i = this.indexOf(key, -1, tree._compare);
         return i < 0 ? defaultValue : this.values[i];
-    };
-    BNode.prototype.getPairOrNextLower = function (key, compare, inclusive, reusedArray) {
+    }
+    getPairOrNextLower(key, compare, inclusive, reusedArray) {
         var i = this.indexOf(key, -1, compare);
-        var indexOrLower = i < 0 ? ~i - 1 : (inclusive ? i : i - 1);
+        const indexOrLower = i < 0 ? ~i - 1 : (inclusive ? i : i - 1);
         if (indexOrLower >= 0) {
             reusedArray[0] = this.keys[indexOrLower];
             reusedArray[1] = this.values[indexOrLower];
             return reusedArray;
         }
         return undefined;
-    };
-    BNode.prototype.getPairOrNextHigher = function (key, compare, inclusive, reusedArray) {
+    }
+    getPairOrNextHigher(key, compare, inclusive, reusedArray) {
         var i = this.indexOf(key, -1, compare);
-        var indexOrLower = i < 0 ? ~i : (inclusive ? i : i + 1);
-        var keys = this.keys;
+        const indexOrLower = i < 0 ? ~i : (inclusive ? i : i + 1);
+        const keys = this.keys;
         if (indexOrLower < keys.length) {
             reusedArray[0] = keys[indexOrLower];
             reusedArray[1] = this.values[indexOrLower];
             return reusedArray;
         }
         return undefined;
-    };
-    BNode.prototype.checkValid = function (depth, tree, baseIndex) {
+    }
+    checkValid(depth, tree, baseIndex) {
         var kL = this.keys.length, vL = this.values.length;
         check(this.values === undefVals ? kL <= vL : kL === vL, "keys/values length mismatch: depth", depth, "with lengths", kL, vL, "and baseIndex", baseIndex);
         // Note: we don't check for "node too small" because sometimes a node
-        // can legitimately have size 1. This occurs if there is a batch 
+        // can legitimately have size 1. This occurs if there is a batch
         // deletion, leaving a node of size 1, and the siblings are full so
         // it can't be merged with adjacent nodes. However, the parent will
         // verify that the average node size is at least half of the maximum.
         check(depth == 0 || kL > 0, "empty leaf at depth", depth, "and baseIndex", baseIndex);
         return kL;
-    };
+    }
     /////////////////////////////////////////////////////////////////////////////
     // Leaf Node: set & node splitting //////////////////////////////////////////
-    BNode.prototype.set = function (key, value, overwrite, tree) {
+    set(key, value, overwrite, tree) {
         var i = this.indexOf(key, -1, tree._compare);
         if (i < 0) {
             // key does not exist yet
@@ -1277,13 +1228,13 @@ var BNode = /** @class */ (function () {
             }
             return false;
         }
-    };
-    BNode.prototype.reifyValues = function () {
+    }
+    reifyValues() {
         if (this.values === undefVals)
             return this.values = this.values.slice(0, this.keys.length);
         return this.values;
-    };
-    BNode.prototype.insertInLeaf = function (i, key, value, tree) {
+    }
+    insertInLeaf(i, key, value, tree) {
         this.keys.splice(i, 0, key);
         if (this.values === undefVals) {
             while (undefVals.length < tree._maxNodeSize)
@@ -1297,8 +1248,8 @@ var BNode = /** @class */ (function () {
         }
         this.values.splice(i, 0, value);
         return true;
-    };
-    BNode.prototype.takeFromRight = function (rhs) {
+    }
+    takeFromRight(rhs) {
         // Reminder: parent node must update its copy of key for this node
         // assert: neither node is shared
         // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)
@@ -1312,8 +1263,8 @@ var BNode = /** @class */ (function () {
             v.push(rhs.values.shift());
         }
         this.keys.push(rhs.keys.shift());
-    };
-    BNode.prototype.takeFromLeft = function (lhs) {
+    }
+    takeFromLeft(lhs) {
         // Reminder: parent node must update its copy of key for this node
         // assert: neither node is shared
         // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)
@@ -1327,16 +1278,16 @@ var BNode = /** @class */ (function () {
             v.unshift(lhs.values.pop());
         }
         this.keys.unshift(lhs.keys.pop());
-    };
-    BNode.prototype.splitOffRightSide = function () {
+    }
+    splitOffRightSide() {
         // Reminder: parent node must update its copy of key for this node
         var half = this.keys.length >> 1, keys = this.keys.splice(half);
         var values = this.values === undefVals ? undefVals : this.values.splice(half);
         return new BNode(keys, values);
-    };
+    }
     /////////////////////////////////////////////////////////////////////////////
     // Leaf Node: scanning & deletions //////////////////////////////////////////
-    BNode.prototype.forRange = function (low, high, includeHigh, editMode, tree, count, onFound) {
+    forRange(low, high, includeHigh, editMode, tree, count, onFound) {
         var cmp = tree._compare;
         var iLow, iHigh;
         if (high === low) {
@@ -1383,9 +1334,9 @@ var BNode = /** @class */ (function () {
         else
             count += iHigh - iLow;
         return count;
-    };
+    }
     /** Adds entire contents of right-hand sibling (rhs is left unchanged) */
-    BNode.prototype.mergeSibling = function (rhs, _) {
+    mergeSibling(rhs, _) {
         this.keys.push.apply(this.keys, rhs.keys);
         if (this.values === undefVals) {
             if (rhs.values === undefVals)
@@ -1393,79 +1344,75 @@ var BNode = /** @class */ (function () {
             this.values = this.values.slice(0, this.keys.length);
         }
         this.values.push.apply(this.values, rhs.reifyValues());
-    };
-    return BNode;
-}());
+    }
+}
 /** Internal node (non-leaf node) ********************************************/
-var BNodeInternal = /** @class */ (function (_super) {
-    __extends(BNodeInternal, _super);
+class BNodeInternal extends BNode {
     /**
      * This does not mark `children` as shared, so it is the responsibility of the caller
      * to ensure children are either marked shared, or aren't included in another tree.
      */
-    function BNodeInternal(children, keys) {
-        var _this = this;
+    constructor(children, keys) {
         if (!keys) {
             keys = [];
             for (var i = 0; i < children.length; i++)
                 keys[i] = children[i].maxKey();
         }
-        _this = _super.call(this, keys) || this;
-        _this.children = children;
-        return _this;
+        super(keys);
+        this.children = children;
     }
-    BNodeInternal.prototype.clone = function () {
+    clone() {
         var children = this.children.slice(0);
         for (var i = 0; i < children.length; i++)
             children[i].isShared = true;
         return new BNodeInternal(children, this.keys.slice(0));
-    };
-    BNodeInternal.prototype.greedyClone = function (force) {
+    }
+    greedyClone(force) {
         if (this.isShared && !force)
             return this;
         var nu = new BNodeInternal(this.children.slice(0), this.keys.slice(0));
         for (var i = 0; i < nu.children.length; i++)
             nu.children[i] = nu.children[i].greedyClone(force);
         return nu;
-    };
-    BNodeInternal.prototype.minKey = function () {
+    }
+    minKey() {
         return this.children[0].minKey();
-    };
-    BNodeInternal.prototype.minPair = function (reusedArray) {
+    }
+    minPair(reusedArray) {
         return this.children[0].minPair(reusedArray);
-    };
-    BNodeInternal.prototype.maxPair = function (reusedArray) {
+    }
+    maxPair(reusedArray) {
         return this.children[this.children.length - 1].maxPair(reusedArray);
-    };
-    BNodeInternal.prototype.get = function (key, defaultValue, tree) {
+    }
+    get(key, defaultValue, tree) {
         var i = this.indexOf(key, 0, tree._compare), children = this.children;
         return i < children.length ? children[i].get(key, defaultValue, tree) : undefined;
-    };
-    BNodeInternal.prototype.getPairOrNextLower = function (key, compare, inclusive, reusedArray) {
+    }
+    getPairOrNextLower(key, compare, inclusive, reusedArray) {
         var i = this.indexOf(key, 0, compare), children = this.children;
         if (i >= children.length)
             return this.maxPair(reusedArray);
-        var result = children[i].getPairOrNextLower(key, compare, inclusive, reusedArray);
+        const result = children[i].getPairOrNextLower(key, compare, inclusive, reusedArray);
         if (result === undefined && i > 0) {
             return children[i - 1].maxPair(reusedArray);
         }
         return result;
-    };
-    BNodeInternal.prototype.getPairOrNextHigher = function (key, compare, inclusive, reusedArray) {
+    }
+    getPairOrNextHigher(key, compare, inclusive, reusedArray) {
         var i = this.indexOf(key, 0, compare), children = this.children, length = children.length;
         if (i >= length)
             return undefined;
-        var result = children[i].getPairOrNextHigher(key, compare, inclusive, reusedArray);
+        const result = children[i].getPairOrNextHigher(key, compare, inclusive, reusedArray);
         if (result === undefined && i < length - 1) {
             return children[i + 1].minPair(reusedArray);
         }
         return result;
-    };
-    BNodeInternal.prototype.checkValid = function (depth, tree, baseIndex) {
-        var kL = this.keys.length, cL = this.children.length;
+    }
+    checkValid(depth, tree, baseIndex) {
+        let kL = this.keys.length, cL = this.children.length;
         check(kL === cL, "keys/children length mismatch: depth", depth, "lengths", kL, cL, "baseIndex", baseIndex);
         check(kL > 1 || depth > 0, "internal node has length", kL, "at depth", depth, "baseIndex", baseIndex);
-        var size = 0, c = this.children, k = this.keys, childSize = 0;
+        let size = 0, c = this.children, k = this.keys, childSize = 0;
         for (var i = 0; i < cL; i++) {
             size += c[i].checkValid(depth + 1, tree, baseIndex + size);
             childSize += c[i].keys.length;
@@ -1478,14 +1425,14 @@ var BNodeInternal = /** @class */ (function (_super) {
         }
         // 2020/08: BTree doesn't always avoid grossly undersized nodes,
         // but AFAIK such nodes are pretty harmless, so accept them.
-        var toofew = childSize === 0; // childSize < (tree.maxNodeSize >> 1)*cL;
+        let toofew = childSize === 0; // childSize < (tree.maxNodeSize >> 1)*cL;
         if (toofew || childSize > tree.maxNodeSize * cL)
             check(false, toofew ? "too few" : "too many", "children (", childSize, size, ") at depth", depth, "maxNodeSize:", tree.maxNodeSize, "children.length:", cL, "baseIndex:", baseIndex);
         return size;
-    };
+    }
     /////////////////////////////////////////////////////////////////////////////
     // Internal Node: set & node splitting //////////////////////////////////////
-    BNodeInternal.prototype.set = function (key, value, overwrite, tree) {
+    set(key, value, overwrite, tree) {
         var c = this.children, max = tree._maxNodeSize, cmp = tree._compare;
         var i = Math.min(this.indexOf(key, 0, cmp), c.length - 1), child = c[i];
         if (child.isShared)
@@ -1529,45 +1476,45 @@ var BNodeInternal = /** @class */ (function (_super) {
             target.insert(i + 1, result);
             return newRightSibling;
         }
-    };
+    }
     /**
      * Inserts `child` at index `i`.
      * This does not mark `child` as shared, so it is the responsibility of the caller
      * to ensure that either child is marked shared, or it is not included in another tree.
      */
-    BNodeInternal.prototype.insert = function (i, child) {
+    insert(i, child) {
         this.children.splice(i, 0, child);
         this.keys.splice(i, 0, child.maxKey());
-    };
+    }
     /**
      * Split this node.
      * Modifies this to remove the second half of the items, returning a separate node containing them.
      */
-    BNodeInternal.prototype.splitOffRightSide = function () {
+    splitOffRightSide() {
         // assert !this.isShared;
         var half = this.children.length >> 1;
         return new BNodeInternal(this.children.splice(half), this.keys.splice(half));
-    };
-    BNodeInternal.prototype.takeFromRight = function (rhs) {
+    }
+    takeFromRight(rhs) {
         // Reminder: parent node must update its copy of key for this node
         // assert: neither node is shared
         // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)
         this.keys.push(rhs.keys.shift());
         this.children.push(rhs.children.shift());
-    };
-    BNodeInternal.prototype.takeFromLeft = function (lhs) {
+    }
+    takeFromLeft(lhs) {
         // Reminder: parent node must update its copy of key for this node
         // assert: neither node is shared
         // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)
         this.keys.unshift(lhs.keys.pop());
         this.children.unshift(lhs.children.pop());
-    };
+    }
     /////////////////////////////////////////////////////////////////////////////
     // Internal Node: scanning & deletions //////////////////////////////////////
-    // Note: `count` is the next value of the third argument to `onFound`. 
+    // Note: `count` is the next value of the third argument to `onFound`.
     //       A leaf node's `forRange` function returns a new value for this counter,
     //       unless the operation is to stop early.
-    BNodeInternal.prototype.forRange = function (low, high, includeHigh, editMode, tree, count, onFound) {
+    forRange(low, high, includeHigh, editMode, tree, count, onFound) {
         var cmp = tree._compare;
         var keys = this.keys, children = this.children;
         var iLow = this.indexOf(low, 0, cmp), i = iLow;
@@ -1616,9 +1563,9 @@ var BNodeInternal = /** @class */ (function (_super) {
             }
         }
         return count;
-    };
+    }
     /** Merges child i with child i+1 if their combined size is not too large */
-    BNodeInternal.prototype.tryMerge = function (i, maxSize) {
+    tryMerge(i, maxSize) {
         var children = this.children;
         if (i >= 0 && i + 1 < children.length) {
             if (children[i].keys.length + children[i + 1].keys.length <= maxSize) {
@@ -1632,17 +1579,17 @@ var BNodeInternal = /** @class */ (function (_super) {
             }
         }
         return false;
-    };
+    }
     /**
      * Move children from `rhs` into this.
      * `rhs` must be part of this tree, and be removed from it after this call
      * (otherwise isShared for its children could be incorrect).
      */
-    BNodeInternal.prototype.mergeSibling = function (rhs, maxNodeSize) {
+    mergeSibling(rhs, maxNodeSize) {
         // assert !this.isShared;
         var oldLength = this.keys.length;
         this.keys.push.apply(this.keys, rhs.keys);
-        var rhsChildren = rhs.children;
+        const rhsChildren = rhs.children;
         this.children.push.apply(this.children, rhsChildren);
         if (rhs.isShared && !this.isShared) {
             // All children of a shared node are implicitly shared, and since their new
@@ -1654,9 +1601,8 @@ var BNodeInternal = /** @class */ (function (_super) {
         // they may need to be merged too (but only the oldLength-1 and its
         // right sibling should need this).
         this.tryMerge(oldLength - 1, maxNodeSize);
-    };
-    return BNodeInternal;
-}(BNode));
+    }
+}
 // Optimization: this array of `undefined`s is used instead of a normal
 // array of values in nodes where `undefined` is the only value.
 // Its length is extended to max node size on first use; since it can
@@ -1669,24 +1615,20 @@ var BNodeInternal = /** @class */ (function (_super) {
 // Reading outside the bounds of an array is relatively slow because it
 // has the side effect of scanning the prototype chain.
 var undefVals = [];
-var Delete = { delete: true }, DeleteRange = function () { return Delete; };
-var Break = { break: true };
-var EmptyLeaf = (function () {
+const Delete = { delete: true }, DeleteRange = () => Delete;
+const Break = { break: true };
+const EmptyLeaf = (function () {
     var n = new BNode();
     n.isShared = true;
     return n;
 })();
-var EmptyArray = [];
-var ReusedArray = []; // assumed thread-local
-function check(fact) {
-    var args = [];
-    for (var _i = 1; _i < arguments.length; _i++) {
-        args[_i - 1] = arguments[_i];
-    }
+const EmptyArray = [];
+const ReusedArray = []; // assumed thread-local
+function check(fact, ...args) {
     if (!fact) {
         args.unshift('B+ tree'); // at beginning of message
         throw new Error(args.join(' '));
     }
 }
 /** A BTree frozen in the empty state. */
-exports.EmptyBTree = (function () { var t = new BTree(); t.freeze(); return t; })();
+exports.EmptyBTree = (() => { let t = new BTree(); t.freeze(); return t; })();
diff --git a/b+tree.ts b/b+tree.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9f81d50897606e7c43f1edeb898a8dbae888c55f
--- /dev/null
+++ b/b+tree.ts
@@ -0,0 +1,1865 @@
+// B+ tree by David Piepgrass. License: MIT
+import { ISortedMap, ISortedMapF, ISortedSet } from './interfaces';
+
+export {
+  ISetSource, ISetSink, ISet, ISetF, ISortedSetSource, ISortedSet, ISortedSetF,
+  IMapSource, IMapSink, IMap, IMapF, ISortedMapSource, ISortedMap, ISortedMapF
+} from './interfaces';
+
+export type EditRangeResult<V,R=number> = {value?:V, break?:R, delete?:boolean};
+
+type index = number;
+
+// Informative microbenchmarks & stuff:
+// http://www.jayconrod.com/posts/52/a-tour-of-v8-object-representation (very educational)
+// https://blog.mozilla.org/luke/2012/10/02/optimizing-javascript-variable-access/ (local vars are faster than properties)
+// http://benediktmeurer.de/2017/12/13/an-introduction-to-speculative-optimization-in-v8/ (other stuff)
+// https://jsperf.com/js-in-operator-vs-alternatives (avoid 'in' operator; `.p!==undefined` faster than `hasOwnProperty('p')` in all browsers)
+// https://jsperf.com/instanceof-vs-typeof-vs-constructor-vs-member (speed of type tests varies wildly across browsers)
+// https://jsperf.com/detecting-arrays-new (a.constructor===Array is best across browsers, assuming a is an object)
+// https://jsperf.com/shallow-cloning-methods (a constructor is faster than Object.create; hand-written clone faster than Object.assign)
+// https://jsperf.com/ways-to-fill-an-array (slice-and-replace is fastest)
+// https://jsperf.com/math-min-max-vs-ternary-vs-if (Math.min/max is slow on Edge)
+// https://jsperf.com/array-vs-property-access-speed (v.x/v.y is faster than a[0]/a[1] in major browsers IF hidden class is constant)
+// https://jsperf.com/detect-not-null-or-undefined (`x==null` slightly slower than `x===null||x===undefined` on all browsers)
+// Overall, microbenchmarks suggest Firefox is the fastest browser for JavaScript and Edge is the slowest.
+// Lessons from https://v8project.blogspot.com/2017/09/elements-kinds-in-v8.html:
+//   - Avoid holes in arrays. Avoid `new Array(N)`, it will be "holey" permanently.
+//   - Don't read outside bounds of an array (it scans prototype chain).
+//   - Small integer arrays are stored differently from doubles
+//   - Adding non-numbers to an array deoptimizes it permanently into a general array
+//   - Objects can be used like arrays (e.g. have length property) but are slower
+//   - V8 source (NewElementsCapacity in src/objects.h): arrays grow by 50% + 16 elements
+
+/**
+ * Types that BTree supports by default
+ */
+export type DefaultComparable = number | string | Date | boolean | null | undefined | (number | string)[] |
+               { valueOf: () => number | string | Date | boolean | null | undefined | (number | string)[] };
+
+/**
+ * Compares DefaultComparables to form a strict partial ordering.
+ *
+ * Handles +/-0 and NaN like Map: NaN is equal to NaN, and -0 is equal to +0.
+ *
+ * Arrays are compared using '<' and '>', which may cause unexpected equality:
+ * for example [1] will be considered equal to ['1'].
+ *
+ * Two objects with equal valueOf compare the same, but compare unequal to
+ * primitives that have the same value.
+ */
+export function defaultComparator(a: DefaultComparable, b: DefaultComparable): number {
+  // Special case finite numbers first for performance.
+  // Note that the trick of using 'a - b' and checking for NaN to detect non-numbers
+  // does not work if the strings are numeric (ex: "5"). This would leading most
+  // comparison functions using that approach to fail to have transitivity.
+  if (Number.isFinite(a as any) && Number.isFinite(b as any)) {
+    return a as number - (b as number);
+  }
+
+  // The default < and > operators are not totally ordered. To allow types to be mixed
+  // in a single collection, compare types and order values of different types by type.
+  let ta = typeof a;
+  let tb = typeof b;
+  if (ta !== tb) {
+    return ta < tb ? -1 : 1;
+  }
+
+  if (ta === 'object') {
+    // standardized JavaScript bug: null is not an object, but typeof says it is
+    if (a === null)
+      return b === null ? 0 : -1;
+    else if (b === null)
+      return 1;
+
+    a = a!.valueOf() as DefaultComparable;
+    b = b!.valueOf() as DefaultComparable;
+    ta = typeof a;
+    tb = typeof b;
+    // Deal with the two valueOf()s producing different types
+    if (ta !== tb) {
+      return ta < tb ? -1 : 1;
+    }
+  }
+
+  // a and b are now the same type, and will be a number, string or array
+  // (which we assume holds numbers or strings), or something unsupported.
+  if (a! < b!) return -1;
+  if (a! > b!) return 1;
+  if (a === b) return 0;
+
+  // Order NaN less than other numbers
+  if (Number.isNaN(a as any))
+    return Number.isNaN(b as any) ? 0 : -1;
+  else if (Number.isNaN(b as any))
+    return 1;
+  // This could be two objects (e.g. [7] and ['7']) that aren't ordered
+  return Array.isArray(a) ? 0 : Number.NaN;
+};
+
+/**
+ * Compares items using the < and > operators. This function is probably slightly
+ * faster than the defaultComparator for Dates and strings, but has not been benchmarked.
+ * Unlike defaultComparator, this comparator doesn't support mixed types correctly,
+ * i.e. use it with `BTree<string>` or `BTree<number>` but not `BTree<string|number>`.
+ *
+ * NaN is not supported.
+ *
+ * Note: null is treated like 0 when compared with numbers or Date, but in general
+ *   null is not ordered with respect to strings (neither greater nor less), and
+ *   undefined is not ordered with other types.
+ */
+export function simpleComparator(a: string, b:string): number;
+export function simpleComparator(a: number|null, b:number|null): number;
+export function simpleComparator(a: Date|null, b:Date|null): number;
+export function simpleComparator(a: (number|string)[], b:(number|string)[]): number;
+export function simpleComparator(a: any, b: any): number {
+  return a > b ? 1 : a < b ? -1 : 0;
+};
+
+/**
+ * A reasonably fast collection of key-value pairs with a powerful API.
+ * Largely compatible with the standard Map. BTree is a B+ tree data structure,
+ * so the collection is sorted by key.
+ *
+ * B+ trees tend to use memory more efficiently than hashtables such as the
+ * standard Map, especially when the collection contains a large number of
+ * items. However, maintaining the sort order makes them modestly slower:
+ * O(log size) rather than O(1). This B+ tree implementation supports O(1)
+ * fast cloning. It also supports freeze(), which can be used to ensure that
+ * a BTree is not changed accidentally.
+ *
+ * Confusingly, the ES6 Map.forEach(c) method calls c(value,key) instead of
+ * c(key,value), in contrast to other methods such as set() and entries()
+ * which put the key first. I can only assume that the order was reversed on
+ * the theory that users would usually want to examine values and ignore keys.
+ * BTree's forEach() therefore works the same way, but a second method
+ * `.forEachPair((key,value)=>{...})` is provided which sends you the key
+ * first and the value second; this method is slightly faster because it is
+ * the "native" for-each method for this class.
+ *
+ * Out of the box, BTree supports keys that are numbers, strings, arrays of
+ * numbers/strings, Date, and objects that have a valueOf() method returning a
+ * number or string. Other data types, such as arrays of Date or custom
+ * objects, require a custom comparator, which you must pass as the second
+ * argument to the constructor (the first argument is an optional list of
+ * initial items). Symbols cannot be used as keys because they are unordered
+ * (one Symbol is never "greater" or "less" than another).
+ *
+ * @example
+ * Given a {name: string, age: number} object, you can create a tree sorted by
+ * name and then by age like this:
+ *
+ *     var tree = new BTree(undefined, (a, b) => {
+ *       if (a.name > b.name)
+ *         return 1; // Return a number >0 when a > b
+ *       else if (a.name < b.name)
+ *         return -1; // Return a number <0 when a < b
+ *       else // names are equal (or incomparable)
+ *         return a.age - b.age; // Return >0 when a.age > b.age
+ *     });
+ *
+ *     tree.set({name:"Bill", age:17}, "happy");
+ *     tree.set({name:"Fran", age:40}, "busy & stressed");
+ *     tree.set({name:"Bill", age:55}, "recently laid off");
+ *     tree.forEachPair((k, v) => {
+ *       console.log(`Name: ${k.name} Age: ${k.age} Status: ${v}`);
+ *     });
+ *
+ * @description
+ * The "range" methods (`forEach, forRange, editRange`) will return the number
+ * of elements that were scanned. In addition, the callback can return {break:R}
+ * to stop early and return R from the outer function.
+ *
+ * - TODO: Test performance of preallocating values array at max size
+ * - TODO: Add fast initialization when a sorted array is provided to constructor
+ *
+ * For more documentation see https://github.com/qwertie/btree-typescript
+ *
+ * Are you a C# developer? You might like the similar data structures I made for C#:
+ * BDictionary, BList, etc. See http://core.loyc.net/collections/
+ *
+ * @author David Piepgrass
+ */
+export class BTree<K=any, V=any> implements ISortedMapF<K,V>, ISortedMap<K,V>
+{
+  private _root: BNode<K, V> = EmptyLeaf as BNode<K,V>;
+  _size: number = 0;
+  _maxNodeSize: number;
+
+  /**
+   * provides a total order over keys (and a strict partial order over the type K)
+   * @returns a negative value if a < b, 0 if a === b and a positive value if a > b
+   */
+  _compare: (a:K, b:K) => number;
+
+  /**
+   * Initializes an empty B+ tree.
+   * @param compare Custom function to compare pairs of elements in the tree.
+   *   If not specified, defaultComparator will be used which is valid as long as K extends DefaultComparable.
+   * @param entries A set of key-value pairs to initialize the tree
+   * @param maxNodeSize Branching factor (maximum items or children per node)
+   *   Must be in range 4..256. If undefined or <4 then default is used; if >256 then 256.
+   */
+  public constructor(entries?: [K,V][], compare?: (a: K, b: K) => number, maxNodeSize?: number) {
+    this._maxNodeSize = maxNodeSize! >= 4 ? Math.min(maxNodeSize!, 256) : 32;
+    this._compare = compare || defaultComparator as any as (a: K, b: K) => number;
+    if (entries)
+      this.setPairs(entries);
+  }
+
+  /////////////////////////////////////////////////////////////////////////////
+  // ES6 Map<K,V> methods /////////////////////////////////////////////////////
+
+  /** Gets the number of key-value pairs in the tree. */
+  get size() { return this._size; }
+  /** Gets the number of key-value pairs in the tree. */
+  get length() { return this._size; }
+  /** Returns true iff the tree contains no key-value pairs. */
+  get isEmpty() { return this._size === 0; }
+
+  /** Releases the tree so that its size is 0. */
+  clear() {
+    this._root = EmptyLeaf as BNode<K,V>;
+    this._size = 0;
+  }
+
+  forEach(callback: (v:V, k:K, tree:BTree<K,V>) => void, thisArg?: any): number;
+
+  /** Runs a function for each key-value pair, in order from smallest to
+   *  largest key. For compatibility with ES6 Map, the argument order to
+   *  the callback is backwards: value first, then key. Call forEachPair
+   *  instead to receive the key as the first argument.
+   * @param thisArg If provided, this parameter is assigned as the `this`
+   *        value for each callback.
+   * @returns the number of values that were sent to the callback,
+   *        or the R value if the callback returned {break:R}. */
+  forEach<R=number>(callback: (v:V, k:K, tree:BTree<K,V>) => {break?:R}|void, thisArg?: any): R|number {
+    if (thisArg !== undefined)
+      callback = callback.bind(thisArg);
+    return this.forEachPair((k, v) => callback(v, k, this));
+  }
+
+  /** Runs a function for each key-value pair, in order from smallest to
+   *  largest key. The callback can return {break:R} (where R is any value
+   *  except undefined) to stop immediately and return R from forEachPair.
+   * @param onFound A function that is called for each key-value pair. This
+   *        function can return {break:R} to stop early with result R.
+   *        The reason that you must return {break:R} instead of simply R
+   *        itself is for consistency with editRange(), which allows
+   *        multiple actions, not just breaking.
+   * @param initialCounter This is the value of the third argument of
+   *        `onFound` the first time it is called. The counter increases
+   *        by one each time `onFound` is called. Default value: 0
+   * @returns the number of pairs sent to the callback (plus initialCounter,
+   *        if you provided one). If the callback returned {break:R} then
+   *        the R value is returned instead. */
+  forEachPair<R=number>(callback: (k:K, v:V, counter:number) => {break?:R}|void, initialCounter?: number): R|number {
+    var low = this.minKey(), high = this.maxKey();
+    return this.forRange(low!, high!, true, callback, initialCounter);
+  }
+
+  /**
+   * Finds a pair in the tree and returns the associated value.
+   * @param defaultValue a value to return if the key was not found.
+   * @returns the value, or defaultValue if the key was not found.
+   * @description Computational complexity: O(log size)
+   */
+  get(key: K, defaultValue?: V): V | undefined {
+    return this._root.get(key, defaultValue, this);
+  }
+
+  /**
+   * Adds or overwrites a key-value pair in the B+ tree.
+   * @param key the key is used to determine the sort order of
+   *        data in the tree.
+   * @param value data to associate with the key (optional)
+   * @param overwrite Whether to overwrite an existing key-value pair
+   *        (default: true). If this is false and there is an existing
+   *        key-value pair then this method has no effect.
+   * @returns true if a new key-value pair was added.
+   * @description Computational complexity: O(log size)
+   * Note: when overwriting a previous entry, the key is updated
+   * as well as the value. This has no effect unless the new key
+   * has data that does not affect its sort order.
+   */
+  set(key: K, value: V, overwrite?: boolean): boolean {
+    if (this._root.isShared)
+      this._root = this._root.clone();
+    var result = this._root.set(key, value, overwrite, this);
+    if (result === true || result === false)
+      return result;
+    // Root node has split, so create a new root node.
+    this._root = new BNodeInternal<K,V>([this._root, result]);
+    return true;
+  }
+
+  /**
+   * Returns true if the key exists in the B+ tree, false if not.
+   * Use get() for best performance; use has() if you need to
+   * distinguish between "undefined value" and "key not present".
+   * @param key Key to detect
+   * @description Computational complexity: O(log size)
+   */
+  has(key: K): boolean {
+    return this.forRange(key, key, true, undefined) !== 0;
+  }
+
+  /**
+   * Removes a single key-value pair from the B+ tree.
+   * @param key Key to find
+   * @returns true if a pair was found and removed, false otherwise.
+   * @description Computational complexity: O(log size)
+   */
+  delete(key: K): boolean {
+    return this.editRange(key, key, true, DeleteRange) !== 0;
+  }
+
+  /////////////////////////////////////////////////////////////////////////////
+  // Clone-mutators ///////////////////////////////////////////////////////////
+
+  /** Returns a copy of the tree with the specified key set (the value is undefined). */
+  with(key: K): BTree<K,V|undefined>;
+  /** Returns a copy of the tree with the specified key-value pair set. */
+  with<V2>(key: K, value: V2, overwrite?: boolean): BTree<K,V|V2>;
+  with<V2>(key: K, value?: V2, overwrite?: boolean): BTree<K,V|V2|undefined> {
+    let nu = this.clone() as BTree<K,V|V2|undefined>;
+    return nu.set(key, value, overwrite) || overwrite ? nu : this;
+  }
+
+  /** Returns a copy of the tree with the specified key-value pairs set. */
+  withPairs<V2>(pairs: [K,V|V2][], overwrite: boolean): BTree<K,V|V2> {
+    let nu = this.clone() as BTree<K,V|V2>;
+    return nu.setPairs(pairs, overwrite) !== 0 || overwrite ? nu : this;
+  }
+
+  /** Returns a copy of the tree with the specified keys present.
+   *  @param keys The keys to add. If a key is already present in the tree,
+   *         neither the existing key nor the existing value is modified.
+   *  @param returnThisIfUnchanged if true, returns this if all keys already
+   *  existed. Performance note: due to the architecture of this class, all
+   *  node(s) leading to existing keys are cloned even if the collection is
+   *  ultimately unchanged.
+  */
+  withKeys(keys: K[], returnThisIfUnchanged?: boolean): BTree<K,V|undefined> {
+    let nu = this.clone() as BTree<K,V|undefined>, changed = false;
+    for (var i = 0; i < keys.length; i++)
+      changed = nu.set(keys[i], undefined, false) || changed;
+    return returnThisIfUnchanged && !changed ? this : nu;
+  }
+
+  /** Returns a copy of the tree with the specified key removed.
+   * @param returnThisIfUnchanged if true, returns this if the key didn't exist.
+   *  Performance note: due to the architecture of this class, node(s) leading
+   *  to where the key would have been stored are cloned even when the key
+   *  turns out not to exist and the collection is unchanged.
+   */
+  without(key: K, returnThisIfUnchanged?: boolean): BTree<K,V> {
+    return this.withoutRange(key, key, true, returnThisIfUnchanged);
+  }
+
+  /** Returns a copy of the tree with the specified keys removed.
+   * @param returnThisIfUnchanged if true, returns this if none of the keys
+   *  existed. Performance note: due to the architecture of this class,
+   *  node(s) leading to where the key would have been stored are cloned
+   *  even when the key turns out not to exist.
+   */
+  withoutKeys(keys: K[], returnThisIfUnchanged?: boolean): BTree<K,V> {
+    let nu = this.clone();
+    return nu.deleteKeys(keys) || !returnThisIfUnchanged ? nu : this;
+  }
+
+  /** Returns a copy of the tree with the specified range of keys removed. */
+  withoutRange(low: K, high: K, includeHigh: boolean, returnThisIfUnchanged?: boolean): BTree<K,V> {
+    let nu = this.clone();
+    if (nu.deleteRange(low, high, includeHigh) === 0 && returnThisIfUnchanged)
+      return this;
+    return nu;
+  }
+
+  /** Returns a copy of the tree with pairs removed whenever the callback
+   *  function returns false. `where()` is a synonym for this method. */
+  filter(callback: (k:K,v:V,counter:number) => boolean, returnThisIfUnchanged?: boolean): BTree<K,V> {
+    var nu = this.greedyClone();
+    var del: any;
+    nu.editAll((k,v,i) => {
+      if (!callback(k, v, i)) return del = Delete;
+    });
+    if (!del && returnThisIfUnchanged)
+      return this;
+    return nu;
+  }
+
+  /** Returns a copy of the tree with all values altered by a callback function. */
+  mapValues<R>(callback: (v:V,k:K,counter:number) => R): BTree<K,R> {
+    var tmp = {} as {value:R};
+    var nu = this.greedyClone();
+    nu.editAll((k,v,i) => {
+      return tmp.value = callback(v, k, i), tmp as any;
+    });
+    return nu as any as BTree<K,R>;
+  }
+
+  /** Performs a reduce operation like the `reduce` method of `Array`.
+   *  It is used to combine all pairs into a single value, or perform
+   *  conversions. `reduce` is best understood by example. For example,
+   *  `tree.reduce((P, pair) => P * pair[0], 1)` multiplies all keys
+   *  together. It means "start with P=1, and for each pair multiply
+   *  it by the key in pair[0]". Another example would be converting
+   *  the tree to a Map (in this example, note that M.set returns M):
+   *
+   *  var M = tree.reduce((M, pair) => M.set(pair[0],pair[1]), new Map())
+   *
+   *  **Note**: the same array is sent to the callback on every iteration.
+   */
+  reduce<R>(callback: (previous:R,currentPair:[K,V],counter:number,tree:BTree<K,V>) => R, initialValue: R): R;
+  reduce<R>(callback: (previous:R|undefined,currentPair:[K,V],counter:number,tree:BTree<K,V>) => R): R|undefined;
+  reduce<R>(callback: (previous:R|undefined,currentPair:[K,V],counter:number,tree:BTree<K,V>) => R, initialValue?: R): R|undefined {
+    let i = 0, p = initialValue;
+    var it = this.entries(this.minKey(), ReusedArray), next;
+    while (!(next = it.next()).done)
+      p = callback(p, next.value, i++, this);
+    return p;
+  }
+
+  /////////////////////////////////////////////////////////////////////////////
+  // Iterator methods /////////////////////////////////////////////////////////
+
+  /** Returns an iterator that provides items in order (ascending order if
+   *  the collection's comparator uses ascending order, as is the default.)
+   *  @param lowestKey First key to be iterated, or undefined to start at
+   *         minKey(). If the specified key doesn't exist then iteration
+   *         starts at the next higher key (according to the comparator).
+   *  @param reusedArray Optional array used repeatedly to store key-value
+   *         pairs, to avoid creating a new array on every iteration.
+   */
+  entries(lowestKey?: K, reusedArray?: (K|V)[]): IterableIterator<[K,V]> {
+    var info = this.findPath(lowestKey);
+    if (info === undefined) return iterator<[K,V]>();
+    var {nodequeue, nodeindex, leaf} = info;
+    var state = reusedArray !== undefined ? 1 : 0;
+    var i = (lowestKey === undefined ? -1 : leaf.indexOf(lowestKey, 0, this._compare) - 1);
+
+    return iterator<[K,V]>(() => {
+      jump: for (;;) {
+        switch(state) {
+          case 0:
+            if (++i < leaf.keys.length)
+              return {done: false, value: [leaf.keys[i], leaf.values[i]]};
+            state = 2;
+            continue;
+          case 1:
+            if (++i < leaf.keys.length) {
+              reusedArray![0] = leaf.keys[i], reusedArray![1] = leaf.values[i];
+              return {done: false, value: reusedArray as [K,V]};
+            }
+            state = 2;
+          case 2:
+            // Advance to the next leaf node
+            for (var level = -1;;) {
+              if (++level >= nodequeue.length) {
+                state = 3; continue jump;
+              }
+              if (++nodeindex[level] < nodequeue[level].length)
+                break;
+            }
+            for (; level > 0; level--) {
+              nodequeue[level-1] = (nodequeue[level][nodeindex[level]] as BNodeInternal<K,V>).children;
+              nodeindex[level-1] = 0;
+            }
+            leaf = nodequeue[0][nodeindex[0]];
+            i = -1;
+            state = reusedArray !== undefined ? 1 : 0;
+            continue;
+          case 3:
+            return {done: true, value: undefined};
+        }
+      }
+    });
+  }
+
+  /** Returns an iterator that provides items in reversed order.
+   *  @param highestKey Key at which to start iterating, or undefined to
+   *         start at maxKey(). If the specified key doesn't exist then iteration
+   *         starts at the next lower key (according to the comparator).
+   *  @param reusedArray Optional array used repeatedly to store key-value
+   *         pairs, to avoid creating a new array on every iteration.
+   *  @param skipHighest Iff this flag is true and the highestKey exists in the
+   *         collection, the pair matching highestKey is skipped, not iterated.
+   */
+  entriesReversed(highestKey?: K, reusedArray?: (K|V)[], skipHighest?: boolean): IterableIterator<[K,V]> {
+    if (highestKey === undefined) {
+      highestKey = this.maxKey();
+      skipHighest = undefined;
+      if (highestKey === undefined)
+        return iterator<[K,V]>(); // collection is empty
+    }
+    var {nodequeue,nodeindex,leaf} = this.findPath(highestKey) || this.findPath(this.maxKey())!;
+    check(!nodequeue[0] || leaf === nodequeue[0][nodeindex[0]], "wat!");
+    var i = leaf.indexOf(highestKey, 0, this._compare);
+    if (!skipHighest && i < leaf.keys.length && this._compare(leaf.keys[i], highestKey) <= 0)
+      i++;
+    var state = reusedArray !== undefined ? 1 : 0;
+
+    return iterator<[K,V]>(() => {
+      jump: for (;;) {
+        switch(state) {
+          case 0:
+            if (--i >= 0)
+              return {done: false, value: [leaf.keys[i], leaf.values[i]]};
+            state = 2;
+            continue;
+          case 1:
+            if (--i >= 0) {
+              reusedArray![0] = leaf.keys[i], reusedArray![1] = leaf.values[i];
+              return {done: false, value: reusedArray as [K,V]};
+            }
+            state = 2;
+          case 2:
+            // Advance to the next leaf node
+            for (var level = -1;;) {
+              if (++level >= nodequeue.length) {
+                state = 3; continue jump;
+              }
+              if (--nodeindex[level] >= 0)
+                break;
+            }
+            for (; level > 0; level--) {
+              nodequeue[level-1] = (nodequeue[level][nodeindex[level]] as BNodeInternal<K,V>).children;
+              nodeindex[level-1] = nodequeue[level-1].length-1;
+            }
+            leaf = nodequeue[0][nodeindex[0]];
+            i = leaf.keys.length;
+            state = reusedArray !== undefined ? 1 : 0;
+            continue;
+          case 3:
+            return {done: true, value: undefined};
+        }
+      }
+    });
+  }
+
+  /* Used by entries() and entriesReversed() to prepare to start iterating.
+   * It develops a "node queue" for each non-leaf level of the tree.
+   * Levels are numbered "bottom-up" so that level 0 is a list of leaf
+   * nodes from a low-level non-leaf node. The queue at a given level L
+   * consists of nodequeue[L] which is the children of a BNodeInternal,
+   * and nodeindex[L], the current index within that child list, such
+   * such that nodequeue[L-1] === nodequeue[L][nodeindex[L]].children.
+   * (However inside this function the order is reversed.)
+   */
+  private findPath(key?: K): { nodequeue: BNode<K,V>[][], nodeindex: number[], leaf: BNode<K,V> } | undefined
+  {
+    var nextnode = this._root;
+    var nodequeue: BNode<K,V>[][], nodeindex: number[];
+
+    if (nextnode.isLeaf) {
+      nodequeue = EmptyArray, nodeindex = EmptyArray; // avoid allocations
+    } else {
+      nodequeue = [], nodeindex = [];
+      for (var d = 0; !nextnode.isLeaf; d++) {
+        nodequeue[d] = (nextnode as BNodeInternal<K,V>).children;
+        nodeindex[d] = key === undefined ? 0 : nextnode.indexOf(key, 0, this._compare);
+        if (nodeindex[d] >= nodequeue[d].length)
+          return; // first key > maxKey()
+        nextnode = nodequeue[d][nodeindex[d]];
+      }
+      nodequeue.reverse();
+      nodeindex.reverse();
+    }
+    return {nodequeue, nodeindex, leaf:nextnode};
+  }
+
+  /**
+   * Computes the differences between `this` and `other`.
+   * For efficiency, the diff is returned via invocations of supplied handlers.
+   * The computation is optimized for the case in which the two trees have large amounts
+   * of shared data (obtained by calling the `clone` or `with` APIs) and will avoid
+   * any iteration of shared state.
+   * The handlers can cause computation to early exit by returning {break: R}.
+   * Neither of the collections should be changed during the comparison process (in your callbacks), as this method assumes they will not be mutated.
+   * @param other The tree to compute a diff against.
+   * @param onlyThis Callback invoked for all keys only present in `this`.
+   * @param onlyOther Callback invoked for all keys only present in `other`.
+   * @param different Callback invoked for all keys with differing values.
+   */
+  diffAgainst<R>(
+    other: BTree<K, V>,
+    onlyThis?: (k: K, v: V) => { break?: R } | void,
+    onlyOther?: (k: K, v: V) => { break?: R } | void,
+    different?: (k: K, vThis: V, vOther: V) => { break?: R} | void
+  ): R | undefined {
+    if (other._compare !== this._compare) {
+      throw new Error("Tree comparators are not the same.");
+    }
+
+    if (this.isEmpty || other.isEmpty) {
+      if (this.isEmpty && other.isEmpty)
+        return undefined;
+      // If one tree is empty, everything will be an onlyThis/onlyOther.
+      if (this.isEmpty)
+        return onlyOther === undefined ? undefined : BTree.stepToEnd(BTree.makeDiffCursor(other), onlyOther);
+      return onlyThis === undefined ? undefined : BTree.stepToEnd(BTree.makeDiffCursor(this), onlyThis);
+    }
+
+    // Cursor-based diff algorithm is as follows:
+    // - Until neither cursor has navigated to the end of the tree, do the following:
+    //  - If the `this` cursor is "behind" the `other` cursor (strictly <, via compare), advance it.
+    //  - Otherwise, advance the `other` cursor.
+    //  - Any time a cursor is stepped, perform the following:
+    //    - If either cursor points to a key/value pair:
+    //      - If thisCursor === otherCursor and the values differ, it is a Different.
+    //      - If thisCursor > otherCursor and otherCursor is at a key/value pair, it is an OnlyOther.
+    //      - If thisCursor < otherCursor and thisCursor is at a key/value pair, it is an OnlyThis as long as the most recent
+    //        cursor step was *not* otherCursor advancing from a tie. The extra condition avoids erroneous OnlyOther calls
+    //        that would occur due to otherCursor being the "leader".
+    //    - Otherwise, if both cursors point to nodes, compare them. If they are equal by reference (shared), skip
+    //      both cursors to the next node in the walk.
+    // - Once one cursor has finished stepping, any remaining steps (if any) are taken and key/value pairs are logged
+    //   as OnlyOther (if otherCursor is stepping) or OnlyThis (if thisCursor is stepping).
+    // This algorithm gives the critical guarantee that all locations (both nodes and key/value pairs) in both trees that
+    // are identical by value (and possibly by reference) will be visited *at the same time* by the cursors.
+    // This removes the possibility of emitting incorrect diffs, as well as allowing for skipping shared nodes.
+    const { _compare } = this;
+    const thisCursor = BTree.makeDiffCursor(this);
+    const otherCursor = BTree.makeDiffCursor(other);
+    // It doesn't matter how thisSteppedLast is initialized.
+    // Step order is only used when either cursor is at a leaf, and cursors always start at a node.
+    let thisSuccess = true, otherSuccess = true, prevCursorOrder = BTree.compare(thisCursor, otherCursor, _compare);
+    while (thisSuccess && otherSuccess) {
+      const cursorOrder = BTree.compare(thisCursor, otherCursor, _compare);
+      const { leaf: thisLeaf, internalSpine: thisInternalSpine, levelIndices: thisLevelIndices } = thisCursor;
+      const { leaf: otherLeaf, internalSpine: otherInternalSpine, levelIndices: otherLevelIndices } = otherCursor;
+      if (thisLeaf || otherLeaf) {
+        // If the cursors were at the same location last step, then there is no work to be done.
+        if (prevCursorOrder !== 0) {
+          if (cursorOrder === 0) {
+            if (thisLeaf && otherLeaf && different) {
+              // Equal keys, check for modifications
+              const valThis = thisLeaf.values[thisLevelIndices[thisLevelIndices.length - 1]];
+              const valOther = otherLeaf.values[otherLevelIndices[otherLevelIndices.length - 1]];
+              if (!Object.is(valThis, valOther)) {
+                const result = different(thisCursor.currentKey, valThis, valOther);
+                if (result && result.break)
+                  return result.break;
+              }
+            }
+          } else if (cursorOrder > 0) {
+            // If this is the case, we know that either:
+            // 1. otherCursor stepped last from a starting position that trailed thisCursor, and is still behind, or
+            // 2. thisCursor stepped last and leapfrogged otherCursor
+            // Either of these cases is an "only other"
+            if (otherLeaf && onlyOther) {
+              const otherVal = otherLeaf.values[otherLevelIndices[otherLevelIndices.length - 1]];
+              const result = onlyOther(otherCursor.currentKey, otherVal);
+              if (result && result.break)
+                return result.break;
+            }
+          } else if (onlyThis) {
+            if (thisLeaf && prevCursorOrder !== 0) {
+              const valThis = thisLeaf.values[thisLevelIndices[thisLevelIndices.length - 1]];
+              const result = onlyThis(thisCursor.currentKey, valThis);
+              if (result && result.break)
+                return result.break;
+            }
+          }
+        }
+      } else if (!thisLeaf && !otherLeaf && cursorOrder === 0) {
+        const lastThis = thisInternalSpine.length - 1;
+        const lastOther = otherInternalSpine.length - 1;
+        const nodeThis = thisInternalSpine[lastThis][thisLevelIndices[lastThis]];
+        const nodeOther = otherInternalSpine[lastOther][otherLevelIndices[lastOther]];
+        if (nodeOther === nodeThis) {
+          prevCursorOrder = 0;
+          thisSuccess = BTree.step(thisCursor, true);
+          otherSuccess = BTree.step(otherCursor, true);
+          continue;
+        }
+      }
+      prevCursorOrder = cursorOrder;
+      if (cursorOrder < 0) {
+        thisSuccess = BTree.step(thisCursor);
+      } else {
+        otherSuccess = BTree.step(otherCursor);
+      }
+    }
+
+    if (thisSuccess && onlyThis)
+      return BTree.finishCursorWalk(thisCursor, otherCursor, _compare, onlyThis);
+    if (otherSuccess && onlyOther)
+      return BTree.finishCursorWalk(otherCursor, thisCursor, _compare, onlyOther);
+  }
+
+  ///////////////////////////////////////////////////////////////////////////
+  // Helper methods for diffAgainst /////////////////////////////////////////
+
+  private static finishCursorWalk<K, V, R>(
+    cursor: DiffCursor<K, V>,
+    cursorFinished: DiffCursor<K, V>,
+    compareKeys: (a: K, b: K) => number,
+    callback: (k: K, v: V) => { break?: R } | void
+  ): R | undefined {
+    const compared = BTree.compare(cursor, cursorFinished, compareKeys);
+    if (compared === 0) {
+      if (!BTree.step(cursor))
+        return undefined;
+    } else if (compared < 0) {
+      check(false, "cursor walk terminated early");
+    }
+    return BTree.stepToEnd(cursor, callback);
+  }
+
+  private static stepToEnd<K, V, R>(
+    cursor: DiffCursor<K, V>,
+    callback: (k: K, v: V) => { break?: R } | void
+  ): R | undefined {
+    let canStep: boolean = true;
+    while (canStep) {
+      const { leaf, levelIndices, currentKey } = cursor;
+      if (leaf) {
+        const value = leaf.values[levelIndices[levelIndices.length - 1]];
+        const result = callback(currentKey, value);
+        if (result && result.break)
+          return result.break;
+      }
+      canStep = BTree.step(cursor);
+    }
+    return undefined;
+  }
+
+  private static makeDiffCursor<K, V>(tree: BTree<K, V>): DiffCursor<K, V> {
+    const { _root, height } = tree;
+    return { height: height, internalSpine: [[_root]], levelIndices: [0], leaf: undefined, currentKey: _root.maxKey() };
+  }
+
+  /**
+   * Advances the cursor to the next step in the walk of its tree.
+   * Cursors are walked backwards in sort order, as this allows them to leverage maxKey() in order to be compared in O(1).
+   * @param cursor The cursor to step
+   * @param stepToNode If true, the cursor will be advanced to the next node (skipping values)
+   * @returns true if the step was completed and false if the step would have caused the cursor to move beyond the end of the tree.
+   */
+  private static step<K, V>(cursor: DiffCursor<K, V>, stepToNode?: boolean): boolean {
+    const { internalSpine, levelIndices, leaf } = cursor;
+    if (stepToNode === true || leaf) {
+      const levelsLength = levelIndices.length;
+      // Step to the next node only if:
+      // - We are explicitly directed to via stepToNode, or
+      // - There are no key/value pairs left to step to in this leaf
+      if (stepToNode === true || levelIndices[levelsLength - 1] === 0) {
+        const spineLength = internalSpine.length;
+        // Root is leaf
+        if (spineLength === 0)
+          return false;
+        // Walk back up the tree until we find a new subtree to descend into
+        const nodeLevelIndex = spineLength - 1;
+        let levelIndexWalkBack = nodeLevelIndex;
+        while (levelIndexWalkBack >= 0) {
+          if (levelIndices[levelIndexWalkBack] > 0) {
+            if (levelIndexWalkBack < levelsLength - 1) {
+              // Remove leaf state from cursor
+              cursor.leaf = undefined;
+              levelIndices.pop();
+            }
+            // If we walked upwards past any internal node, slice them out
+            if (levelIndexWalkBack < nodeLevelIndex)
+              cursor.internalSpine = internalSpine.slice(0, levelIndexWalkBack + 1);
+            // Move to new internal node
+            cursor.currentKey = internalSpine[levelIndexWalkBack][--levelIndices[levelIndexWalkBack]].maxKey();
+            return true;
+          }
+          levelIndexWalkBack--;
+        }
+        // Cursor is in the far left leaf of the tree, no more nodes to enumerate
+        return false;
+      } else {
+        // Move to new leaf value
+        const valueIndex = --levelIndices[levelsLength - 1];
+        cursor.currentKey = (leaf as unknown as BNode<K, V>).keys[valueIndex];
+        return true;
+      }
+    } else { // Cursor does not point to a value in a leaf, so move downwards
+      const nextLevel = internalSpine.length;
+      const currentLevel = nextLevel - 1;
+      const node = internalSpine[currentLevel][levelIndices[currentLevel]];
+      if (node.isLeaf) {
+        // Entering into a leaf. Set the cursor to point at the last key/value pair.
+        cursor.leaf = node;
+        const valueIndex = levelIndices[nextLevel] = node.values.length - 1;
+        cursor.currentKey = node.keys[valueIndex];
+      } else {
+        const children = (node as BNodeInternal<K,V>).children;
+        internalSpine[nextLevel] = children;
+        const childIndex = children.length - 1;
+        levelIndices[nextLevel] = childIndex;
+        cursor.currentKey = children[childIndex].maxKey();
+      }
+      return true;
+    }
+  }
+
+  /**
+   * Compares the two cursors. Returns a value indicating which cursor is ahead in a walk.
+   * Note that cursors are advanced in reverse sorting order.
+   */
+  private static compare<K, V>(cursorA: DiffCursor<K, V>, cursorB: DiffCursor<K, V>, compareKeys: (a: K, b: K) => number): number {
+    const { height: heightA, currentKey: currentKeyA, levelIndices: levelIndicesA } = cursorA;
+    const { height: heightB, currentKey: currentKeyB, levelIndices: levelIndicesB } = cursorB;
+    // Reverse the comparison order, as cursors are advanced in reverse sorting order
+    const keyComparison = compareKeys(currentKeyB, currentKeyA);
+    if (keyComparison !== 0) {
+      return keyComparison;
+    }
+
+    // Normalize depth values relative to the shortest tree.
+    // This ensures that concurrent cursor walks of trees of differing heights can reliably land on shared nodes at the same time.
+    // To accomplish this, a cursor that is on an internal node at depth D1 with maxKey X is considered "behind" a cursor on an
+    // internal node at depth D2 with maxKey Y, when D1 < D2. Thus, always walking the cursor that is "behind" will allow the cursor
+    // at shallower depth (but equal maxKey) to "catch up" and land on shared nodes.
+    const heightMin = heightA < heightB ? heightA : heightB;
+    const depthANormalized = levelIndicesA.length - (heightA - heightMin);
+    const depthBNormalized = levelIndicesB.length - (heightB - heightMin);
+    return depthANormalized - depthBNormalized;
+  }
+
+  // End of helper methods for diffAgainst //////////////////////////////////
+  ///////////////////////////////////////////////////////////////////////////
+
+  /** Returns a new iterator for iterating the keys of each pair in ascending order.
+   *  @param firstKey: Minimum key to include in the output. */
+  keys(firstKey?: K): IterableIterator<K> {
+    var it = this.entries(firstKey, ReusedArray);
+    return iterator<K>(() => {
+      var n: IteratorResult<any> = it.next();
+      if (n.value) n.value = n.value[0];
+      return n;
+    });
+  }
+
+  /** Returns a new iterator for iterating the values of each pair in order by key.
+   *  @param firstKey: Minimum key whose associated value is included in the output. */
+  values(firstKey?: K): IterableIterator<V> {
+    var it = this.entries(firstKey, ReusedArray);
+    return iterator<V>(() => {
+      var n: IteratorResult<any> = it.next();
+      if (n.value) n.value = n.value[1];
+      return n;
+    });
+  }
+
+  /////////////////////////////////////////////////////////////////////////////
+  // Additional methods ///////////////////////////////////////////////////////
+
+  /** Returns the maximum number of children/values before nodes will split. */
+  get maxNodeSize() {
+    return this._maxNodeSize;
+  }
+
+  /** Gets the lowest key in the tree. Complexity: O(log size) */
+  minKey(): K | undefined { return this._root.minKey(); }
+
+  /** Gets the highest key in the tree. Complexity: O(1) */
+  maxKey(): K | undefined { return this._root.maxKey(); }
+
+  /** Quickly clones the tree by marking the root node as shared.
+   *  Both copies remain editable. When you modify either copy, any
+   *  nodes that are shared (or potentially shared) between the two
+   *  copies are cloned so that the changes do not affect other copies.
+   *  This is known as copy-on-write behavior, or "lazy copying". */
+  clone(): BTree<K,V> {
+    this._root.isShared = true;
+    var result = new BTree<K,V>(undefined, this._compare, this._maxNodeSize);
+    result._root = this._root;
+    result._size = this._size;
+    return result;
+  }
+
+  /** Performs a greedy clone, immediately duplicating any nodes that are
+   *  not currently marked as shared, in order to avoid marking any
+   *  additional nodes as shared.
+   *  @param force Clone all nodes, even shared ones.
+   */
+  greedyClone(force?: boolean): BTree<K,V> {
+    var result = new BTree<K,V>(undefined, this._compare, this._maxNodeSize);
+    result._root = this._root.greedyClone(force);
+    result._size = this._size;
+    return result;
+  }
+
+  /** Gets an array filled with the contents of the tree, sorted by key */
+  toArray(maxLength: number = 0x7FFFFFFF): [K,V][] {
+    let min = this.minKey(), max = this.maxKey();
+    if (min !== undefined)
+      return this.getRange(min, max!, true, maxLength)
+    return [];
+  }
+
+  /** Gets an array of all keys, sorted */
+  keysArray() {
+    var results: K[] = [];
+    this._root.forRange(this.minKey()!, this.maxKey()!, true, false, this, 0,
+      (k,v) => { results.push(k); });
+    return results;
+  }
+
+  /** Gets an array of all values, sorted by key */
+  valuesArray() {
+    var results: V[] = [];
+    this._root.forRange(this.minKey()!, this.maxKey()!, true, false, this, 0,
+      (k,v) => { results.push(v); });
+    return results;
+  }
+
+  /** Gets a string representing the tree's data based on toArray(). */
+  toString() {
+    return this.toArray().toString();
+  }
+
+  /** Stores a key-value pair only if the key doesn't already exist in the tree.
+   * @returns true if a new key was added
+  */
+  setIfNotPresent(key: K, value: V): boolean {
+    return this.set(key, value, false);
+  }
+
+  /** Returns the next pair whose key is larger than the specified key (or undefined if there is none).
+   * If key === undefined, this function returns the lowest pair.
+   * @param key The key to search for.
+   * @param reusedArray Optional array used repeatedly to store key-value pairs, to
+   * avoid creating a new array on every iteration.
+   */
+  nextHigherPair(key: K|undefined, reusedArray?: [K,V]): [K,V]|undefined {
+    reusedArray = reusedArray || ([] as unknown as [K,V]);
+    if (key === undefined) {
+      return this._root.minPair(reusedArray);
+    }
+    return this._root.getPairOrNextHigher(key, this._compare, false, reusedArray);
+  }
+
+  /** Returns the next key larger than the specified key, or undefined if there is none.
+   *  Also, nextHigherKey(undefined) returns the lowest key.
+   */
+  nextHigherKey(key: K|undefined): K|undefined {
+    var p = this.nextHigherPair(key, ReusedArray as [K,V]);
+    return p && p[0];
+  }
+
+  /** Returns the next pair whose key is smaller than the specified key (or undefined if there is none).
+   *  If key === undefined, this function returns the highest pair.
+   * @param key The key to search for.
+   * @param reusedArray Optional array used repeatedly to store key-value pairs, to
+   *        avoid creating a new array each time you call this method.
+   */
+  nextLowerPair(key: K|undefined, reusedArray?: [K,V]): [K,V]|undefined {
+    reusedArray = reusedArray || ([] as unknown as [K,V]);
+    if (key === undefined) {
+      return this._root.maxPair(reusedArray);
+    }
+    return this._root.getPairOrNextLower(key, this._compare, false, reusedArray);
+  }
+
+  /** Returns the next key smaller than the specified key, or undefined if there is none.
+   *  Also, nextLowerKey(undefined) returns the highest key.
+   */
+  nextLowerKey(key: K|undefined): K|undefined {
+    var p = this.nextLowerPair(key, ReusedArray as [K,V]);
+    return p && p[0];
+  }
+
+  /** Returns the key-value pair associated with the supplied key if it exists
+   *  or the pair associated with the next lower pair otherwise. If there is no
+   *  next lower pair, undefined is returned.
+   * @param key The key to search for.
+   * @param reusedArray Optional array used repeatedly to store key-value pairs, to
+   *        avoid creating a new array each time you call this method.
+   * */
+  getPairOrNextLower(key: K, reusedArray?: [K,V]): [K,V]|undefined {
+    return this._root.getPairOrNextLower(key, this._compare, true, reusedArray || ([] as unknown as [K,V]));
+  }
+
+  /** Returns the key-value pair associated with the supplied key if it exists
+   *  or the pair associated with the next lower pair otherwise. If there is no
+   *  next lower pair, undefined is returned.
+   * @param key The key to search for.
+   * @param reusedArray Optional array used repeatedly to store key-value pairs, to
+   *        avoid creating a new array each time you call this method.
+   * */
+  getPairOrNextHigher(key: K, reusedArray?: [K,V]): [K,V]|undefined {
+    return this._root.getPairOrNextHigher(key, this._compare, true, reusedArray || ([] as unknown as [K,V]));
+  }
+
+  /** Edits the value associated with a key in the tree, if it already exists.
+   * @returns true if the key existed, false if not.
+  */
+  changeIfPresent(key: K, value: V): boolean {
+    return this.editRange(key, key, true, (k,v) => ({value})) !== 0;
+  }
+
+  /**
+   * Builds an array of pairs from the specified range of keys, sorted by key.
+   * Each returned pair is also an array: pair[0] is the key, pair[1] is the value.
+   * @param low The first key in the array will be greater than or equal to `low`.
+   * @param high This method returns when a key larger than this is reached.
+   * @param includeHigh If the `high` key is present, its pair will be included
+   *        in the output if and only if this parameter is true. Note: if the
+   *        `low` key is present, it is always included in the output.
+   * @param maxLength Length limit. getRange will stop scanning the tree when
+   *                  the array reaches this size.
+   * @description Computational complexity: O(result.length + log size)
+   */
+  getRange(low: K, high: K, includeHigh?: boolean, maxLength: number = 0x3FFFFFF): [K,V][] {
+    var results: [K,V][] = [];
+    this._root.forRange(low, high, includeHigh, false, this, 0, (k,v) => {
+      results.push([k,v])
+      return results.length > maxLength ? Break : undefined;
+    });
+    return results;
+  }
+
+  /** Adds all pairs from a list of key-value pairs.
+   * @param pairs Pairs to add to this tree. If there are duplicate keys,
+   *        later pairs currently overwrite earlier ones (e.g. [[0,1],[0,7]]
+   *        associates 0 with 7.)
+   * @param overwrite Whether to overwrite pairs that already exist (if false,
+   *        pairs[i] is ignored when the key pairs[i][0] already exists.)
+   * @returns The number of pairs added to the collection.
+   * @description Computational complexity: O(pairs.length * log(size + pairs.length))
+   */
+  setPairs(pairs: [K,V][], overwrite?: boolean): number {
+    var added = 0;
+    for (var i = 0; i < pairs.length; i++)
+      if (this.set(pairs[i][0], pairs[i][1], overwrite))
+        added++;
+    return added;
+  }
+
+  forRange(low: K, high: K, includeHigh: boolean, onFound?: (k:K,v:V,counter:number) => void, initialCounter?: number): number;
+
+  /**
+   * Scans the specified range of keys, in ascending order by key.
+   * Note: the callback `onFound` must not insert or remove items in the
+   * collection. Doing so may cause incorrect data to be sent to the
+   * callback afterward.
+   * @param low The first key scanned will be greater than or equal to `low`.
+   * @param high Scanning stops when a key larger than this is reached.
+   * @param includeHigh If the `high` key is present, `onFound` is called for
+   *        that final pair if and only if this parameter is true.
+   * @param onFound A function that is called for each key-value pair. This
+   *        function can return {break:R} to stop early with result R.
+   * @param initialCounter Initial third argument of onFound. This value
+   *        increases by one each time `onFound` is called. Default: 0
+   * @returns The number of values found, or R if the callback returned
+   *        `{break:R}` to stop early.
+   * @description Computational complexity: O(number of items scanned + log size)
+   */
+  forRange<R=number>(low: K, high: K, includeHigh: boolean, onFound?: (k:K,v:V,counter:number) => {break?:R}|void, initialCounter?: number): R|number {
+    var r = this._root.forRange(low, high, includeHigh, false, this, initialCounter || 0, onFound);
+    return typeof r === "number" ? r : r.break!;
+  }
+
+  /**
+   * Scans and potentially modifies values for a subsequence of keys.
+   * Note: the callback `onFound` should ideally be a pure function.
+   *   Specfically, it must not insert items, call clone(), or change
+   *   the collection except via return value; out-of-band editing may
+   *   cause an exception or may cause incorrect data to be sent to
+   *   the callback (duplicate or missed items). It must not cause a
+   *   clone() of the collection, otherwise the clone could be modified
+   *   by changes requested by the callback.
+   * @param low The first key scanned will be greater than or equal to `low`.
+   * @param high Scanning stops when a key larger than this is reached.
+   * @param includeHigh If the `high` key is present, `onFound` is called for
+   *        that final pair if and only if this parameter is true.
+   * @param onFound A function that is called for each key-value pair. This
+   *        function can return `{value:v}` to change the value associated
+   *        with the current key, `{delete:true}` to delete the current pair,
+   *        `{break:R}` to stop early with result R, or it can return nothing
+   *        (undefined or {}) to cause no effect and continue iterating.
+   *        `{break:R}` can be combined with one of the other two commands.
+   *        The third argument `counter` is the number of items iterated
+   *        previously; it equals 0 when `onFound` is called the first time.
+   * @returns The number of values scanned, or R if the callback returned
+   *        `{break:R}` to stop early.
+   * @description
+   *   Computational complexity: O(number of items scanned + log size)
+   *   Note: if the tree has been cloned with clone(), any shared
+   *   nodes are copied before `onFound` is called. This takes O(n) time
+   *   where n is proportional to the amount of shared data scanned.
+   */
+  editRange<R=V>(low: K, high: K, includeHigh: boolean, onFound: (k:K,v:V,counter:number) => EditRangeResult<V,R>|void, initialCounter?: number): R|number {
+    var root = this._root;
+    if (root.isShared)
+      this._root = root = root.clone();
+    try {
+      var r = root.forRange(low, high, includeHigh, true, this, initialCounter || 0, onFound);
+      return typeof r === "number" ? r : r.break!;
+    } finally {
+      let isShared;
+      while (root.keys.length <= 1 && !root.isLeaf) {
+        isShared ||= root.isShared;
+        this._root = root = root.keys.length === 0 ? EmptyLeaf :
+                    (root as any as BNodeInternal<K,V>).children[0];
+      }
+      // If any ancestor of the new root was shared, the new root must also be shared
+      if (isShared) {
+        root.isShared = true;
+      }
+    }
+  }
+
+  /** Same as `editRange` except that the callback is called for all pairs. */
+  editAll<R=V>(onFound: (k:K,v:V,counter:number) => EditRangeResult<V,R>|void, initialCounter?: number): R|number {
+    return this.editRange(this.minKey()!, this.maxKey()!, true, onFound, initialCounter);
+  }
+
+  /**
+   * Removes a range of key-value pairs from the B+ tree.
+   * @param low The first key scanned will be greater than or equal to `low`.
+   * @param high Scanning stops when a key larger than this is reached.
+   * @param includeHigh Specifies whether the `high` key, if present, is deleted.
+   * @returns The number of key-value pairs that were deleted.
+   * @description Computational complexity: O(log size + number of items deleted)
+   */
+  deleteRange(low: K, high: K, includeHigh: boolean): number {
+    return this.editRange(low, high, includeHigh, DeleteRange);
+  }
+
+  /** Deletes a series of keys from the collection. */
+  deleteKeys(keys: K[]): number {
+    for (var i = 0, r = 0; i < keys.length; i++)
+      if (this.delete(keys[i]))
+        r++;
+    return r;
+  }
+
+  /** Gets the height of the tree: the number of internal nodes between the
+   *  BTree object and its leaf nodes (zero if there are no internal nodes). */
+  get height(): number {
+    let node: BNode<K, V> | undefined = this._root;
+    let height = -1;
+    while (node) {
+      height++;
+      node = node.isLeaf ? undefined : (node as unknown as BNodeInternal<K, V>).children[0];
+    }
+    return height;
+  }
+
+  /** Makes the object read-only to ensure it is not accidentally modified.
+   *  Freezing does not have to be permanent; unfreeze() reverses the effect.
+   *  This is accomplished by replacing mutator functions with a function
+   *  that throws an Error. Compared to using a property (e.g. this.isFrozen)
+   *  this implementation gives better performance in non-frozen BTrees.
+   */
+  freeze() {
+    var t = this as any;
+    // Note: all other mutators ultimately call set() or editRange()
+    //       so we don't need to override those others.
+    t.clear = t.set = t.editRange = function() {
+      throw new Error("Attempted to modify a frozen BTree");
+    };
+  }
+
+  /** Ensures mutations are allowed, reversing the effect of freeze(). */
+  unfreeze() {
+    // @ts-ignore "The operand of a 'delete' operator must be optional."
+    //            (wrong: delete does not affect the prototype.)
+    delete this.clear;
+    // @ts-ignore
+    delete this.set;
+    // @ts-ignore
+    delete this.editRange;
+  }
+
+  /** Returns true if the tree appears to be frozen. */
+  get isFrozen() {
+    return this.hasOwnProperty('editRange');
+  }
+
+  /** Scans the tree for signs of serious bugs (e.g. this.size doesn't match
+   *  number of elements, internal nodes not caching max element properly...)
+   *  Computational complexity: O(number of nodes), i.e. O(size). This method
+   *  skips the most expensive test - whether all keys are sorted - but it
+   *  does check that maxKey() of the children of internal nodes are sorted. */
+  checkValid() {
+    var size = this._root.checkValid(0, this, 0);
+    check(size === this.size, "size mismatch: counted ", size, "but stored", this.size);
+  }
+}
+
+/** A TypeScript helper function that simply returns its argument, typed as
+ *  `ISortedSet<K>` if the BTree implements it, as it does if `V extends undefined`.
+ *  If `V` cannot be `undefined`, it returns `unknown` instead. Or at least, that
+ *  was the intention, but TypeScript is acting weird and may return `ISortedSet<K>`
+ *  even if `V` can't be `undefined` (discussion: btree-typescript issue #14) */
+export function asSet<K,V>(btree: BTree<K,V>): undefined extends V ? ISortedSet<K> : unknown {
+  return btree as any;
+}
+
+declare const Symbol: any;
+if (Symbol && Symbol.iterator) // iterator is equivalent to entries()
+  (BTree as any).prototype[Symbol.iterator] = BTree.prototype.entries;
+(BTree as any).prototype.where = BTree.prototype.filter;
+(BTree as any).prototype.setRange = BTree.prototype.setPairs;
+(BTree as any).prototype.add = BTree.prototype.set; // for compatibility with ISetSink<K>
+
+function iterator<T>(next: () => IteratorResult<T> = (() => ({ done:true, value:undefined }))): IterableIterator<T> {
+  var result: any = { next };
+  if (Symbol && Symbol.iterator)
+    result[Symbol.iterator] = function() { return this; };
+  return result;
+}
+
+
+/** Leaf node / base class. **************************************************/
+class BNode<K,V> {
+  // If this is an internal node, _keys[i] is the highest key in children[i].
+  keys: K[];
+  values: V[];
+  // True if this node might be within multiple `BTree`s (or have multiple parents).
+  // If so, it must be cloned before being mutated to avoid changing an unrelated tree.
+  // This is transitive: if it's true, children are also shared even if `isShared!=true`
+  // in those children. (Certain operations will propagate isShared=true to children.)
+  isShared: true | undefined;
+  get isLeaf() { return (this as any).children === undefined; }
+
+  constructor(keys: K[] = [], values?: V[]) {
+    this.keys = keys;
+    this.values = values || undefVals as any[];
+    this.isShared = undefined;
+  }
+
+  ///////////////////////////////////////////////////////////////////////////
+  // Shared methods /////////////////////////////////////////////////////////
+
+  maxKey() {
+    return this.keys[this.keys.length-1];
+  }
+
+  // If key not found, returns i^failXor where i is the insertion index.
+  // Callers that don't care whether there was a match will set failXor=0.
+  indexOf(key: K, failXor: number, cmp: (a:K, b:K) => number): index {
+    const keys = this.keys;
+    var lo = 0, hi = keys.length, mid = hi >> 1;
+    while(lo < hi) {
+      var c = cmp(keys[mid], key);
+      if (c < 0)
+        lo = mid + 1;
+      else if (c > 0) // key < keys[mid]
+        hi = mid;
+      else if (c === 0)
+        return mid;
+      else {
+        // c is NaN or otherwise invalid
+        if (key === key) // at least the search key is not NaN
+          return keys.length;
+        else
+          throw new Error("BTree: NaN was used as a key");
+      }
+      mid = (lo + hi) >> 1;
+    }
+    return mid ^ failXor;
+
+    // Unrolled version: benchmarks show same speed, not worth using
+    /*var i = 1, c: number = 0, sum = 0;
+    if (keys.length >= 4) {
+      i = 3;
+      if (keys.length >= 8) {
+        i = 7;
+        if (keys.length >= 16) {
+          i = 15;
+          if (keys.length >= 32) {
+            i = 31;
+            if (keys.length >= 64) {
+              i = 127;
+              i += (c = i < keys.length ? cmp(keys[i], key) : 1) < 0 ? 64 : -64;
+              sum += c;
+              i += (c = i < keys.length ? cmp(keys[i], key) : 1) < 0 ? 32 : -32;
+              sum += c;
+            }
+            i += (c = i < keys.length ? cmp(keys[i], key) : 1) < 0 ? 16 : -16;
+            sum += c;
+          }
+          i += (c = i < keys.length ? cmp(keys[i], key) : 1) < 0 ? 8 : -8;
+          sum += c;
+        }
+        i += (c = i < keys.length ? cmp(keys[i], key) : 1) < 0 ? 4 : -4;
+        sum += c;
+      }
+      i += (c = i < keys.length ? cmp(keys[i], key) : 1) < 0 ? 2 : -2;
+      sum += c;
+    }
+    i += (c = i < keys.length ? cmp(keys[i], key) : 1) < 0 ? 1 : -1;
+    c = i < keys.length ? cmp(keys[i], key) : 1;
+    sum += c;
+    if (c < 0) {
+      ++i;
+      c = i < keys.length ? cmp(keys[i], key) : 1;
+      sum += c;
+    }
+    if (sum !== sum) {
+      if (key === key) // at least the search key is not NaN
+        return keys.length ^ failXor;
+      else
+        throw new Error("BTree: NaN was used as a key");
+    }
+    return c === 0 ? i : i ^ failXor;*/
+  }
+
+  /////////////////////////////////////////////////////////////////////////////
+  // Leaf Node: misc //////////////////////////////////////////////////////////
+
+  minKey(): K | undefined {
+    return this.keys[0];
+  }
+
+  minPair(reusedArray: [K,V]): [K,V] | undefined {
+    if (this.keys.length === 0)
+      return undefined;
+    reusedArray[0] = this.keys[0];
+    reusedArray[1] = this.values[0];
+    return reusedArray;
+  }
+
+  maxPair(reusedArray: [K,V]): [K,V] | undefined {
+    if (this.keys.length === 0)
+      return undefined;
+    const lastIndex = this.keys.length - 1;
+    reusedArray[0] = this.keys[lastIndex];
+    reusedArray[1] = this.values[lastIndex];
+    return reusedArray;
+  }
+
+  clone(): BNode<K,V> {
+    var v = this.values;
+    return new BNode<K,V>(this.keys.slice(0), v === undefVals ? v : v.slice(0));
+  }
+
+  greedyClone(force?: boolean): BNode<K,V> {
+    return this.isShared && !force ? this : this.clone();
+  }
+
+  get(key: K, defaultValue: V|undefined, tree: BTree<K,V>): V|undefined {
+    var i = this.indexOf(key, -1, tree._compare);
+    return i < 0 ? defaultValue : this.values[i];
+  }
+
+  getPairOrNextLower(key: K, compare: (a: K, b: K) => number, inclusive: boolean, reusedArray: [K,V]): [K,V]|undefined {
+    var i = this.indexOf(key, -1, compare);
+    const indexOrLower = i < 0 ? ~i - 1 : (inclusive ? i : i - 1);
+    if (indexOrLower >= 0) {
+      reusedArray[0] = this.keys[indexOrLower];
+      reusedArray[1] = this.values[indexOrLower];
+      return reusedArray;
+    }
+    return undefined;
+  }
+
+  getPairOrNextHigher(key: K, compare: (a: K, b: K) => number, inclusive: boolean, reusedArray: [K,V]): [K,V]|undefined {
+    var i = this.indexOf(key, -1, compare);
+    const indexOrLower = i < 0 ? ~i : (inclusive ? i : i + 1);
+    const keys = this.keys;
+    if (indexOrLower < keys.length) {
+      reusedArray[0] = keys[indexOrLower];
+      reusedArray[1] = this.values[indexOrLower];
+      return reusedArray;
+    }
+    return undefined;
+  }
+
+  checkValid(depth: number, tree: BTree<K,V>, baseIndex: number): number {
+    var kL = this.keys.length, vL = this.values.length;
+    check(this.values === undefVals ? kL <= vL : kL === vL,
+      "keys/values length mismatch: depth", depth, "with lengths", kL, vL, "and baseIndex", baseIndex);
+    // Note: we don't check for "node too small" because sometimes a node
+    // can legitimately have size 1. This occurs if there is a batch
+    // deletion, leaving a node of size 1, and the siblings are full so
+    // it can't be merged with adjacent nodes. However, the parent will
+    // verify that the average node size is at least half of the maximum.
+    check(depth == 0 || kL > 0, "empty leaf at depth", depth, "and baseIndex", baseIndex);
+    return kL;
+  }
+
+  /////////////////////////////////////////////////////////////////////////////
+  // Leaf Node: set & node splitting //////////////////////////////////////////
+
+  set(key: K, value: V, overwrite: boolean|undefined, tree: BTree<K,V>): boolean|BNode<K,V> {
+    var i = this.indexOf(key, -1, tree._compare);
+    if (i < 0) {
+      // key does not exist yet
+      i = ~i;
+      tree._size++;
+
+      if (this.keys.length < tree._maxNodeSize) {
+        return this.insertInLeaf(i, key, value, tree);
+      } else {
+        // This leaf node is full and must split
+        var newRightSibling = this.splitOffRightSide(), target: BNode<K,V> = this;
+        if (i > this.keys.length) {
+          i -= this.keys.length;
+          target = newRightSibling;
+        }
+        target.insertInLeaf(i, key, value, tree);
+        return newRightSibling;
+      }
+    } else {
+      // Key already exists
+      if (overwrite !== false) {
+        if (value !== undefined)
+          this.reifyValues();
+        // usually this is a no-op, but some users may wish to edit the key
+        this.keys[i] = key;
+        this.values[i] = value;
+      }
+      return false;
+    }
+  }
+
+  reifyValues() {
+    if (this.values === undefVals)
+      return this.values = this.values.slice(0, this.keys.length);
+    return this.values;
+  }
+
+  insertInLeaf(i: index, key: K, value: V, tree: BTree<K,V>) {
+    this.keys.splice(i, 0, key);
+    if (this.values === undefVals) {
+      while (undefVals.length < tree._maxNodeSize)
+        undefVals.push(undefined);
+      if (value === undefined) {
+        return true;
+      } else {
+        this.values = undefVals.slice(0, this.keys.length - 1);
+      }
+    }
+    this.values.splice(i, 0, value);
+    return true;
+  }
+
+  takeFromRight(rhs: BNode<K,V>) {
+    // Reminder: parent node must update its copy of key for this node
+    // assert: neither node is shared
+    // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)
+    var v = this.values;
+    if (rhs.values === undefVals) {
+      if (v !== undefVals)
+        v.push(undefined as any);
+    } else {
+      v = this.reifyValues();
+      v.push(rhs.values.shift()!);
+    }
+    this.keys.push(rhs.keys.shift()!);
+  }
+
+  takeFromLeft(lhs: BNode<K,V>) {
+    // Reminder: parent node must update its copy of key for this node
+    // assert: neither node is shared
+    // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)
+    var v = this.values;
+    if (lhs.values === undefVals) {
+      if (v !== undefVals)
+        v.unshift(undefined as any);
+    } else {
+      v = this.reifyValues();
+      v.unshift(lhs.values.pop()!);
+    }
+    this.keys.unshift(lhs.keys.pop()!);
+  }
+
+  splitOffRightSide(): BNode<K,V> {
+    // Reminder: parent node must update its copy of key for this node
+    var half = this.keys.length >> 1, keys = this.keys.splice(half);
+    var values = this.values === undefVals ? undefVals : this.values.splice(half);
+    return new BNode<K,V>(keys, values);
+  }
+
+  /////////////////////////////////////////////////////////////////////////////
+  // Leaf Node: scanning & deletions //////////////////////////////////////////
+
+  forRange<R>(low: K, high: K, includeHigh: boolean|undefined, editMode: boolean, tree: BTree<K,V>, count: number,
+              onFound?: (k:K, v:V, counter:number) => EditRangeResult<V,R>|void): EditRangeResult<V,R>|number {
+    var cmp = tree._compare;
+    var iLow, iHigh;
+    if (high === low) {
+      if (!includeHigh)
+        return count;
+      iHigh = (iLow = this.indexOf(low, -1, cmp)) + 1;
+      if (iLow < 0)
+        return count;
+    } else {
+      iLow = this.indexOf(low, 0, cmp);
+      iHigh = this.indexOf(high, -1, cmp);
+      if (iHigh < 0)
+        iHigh = ~iHigh;
+      else if (includeHigh === true)
+        iHigh++;
+    }
+    var keys = this.keys, values = this.values;
+    if (onFound !== undefined) {
+      for(var i = iLow; i < iHigh; i++) {
+        var key = keys[i];
+        var result = onFound(key, values[i], count++);
+        if (result !== undefined) {
+          if (editMode === true) {
+            if (key !== keys[i] || this.isShared === true)
+              throw new Error("BTree illegally changed or cloned in editRange");
+            if (result.delete) {
+              this.keys.splice(i, 1);
+              if (this.values !== undefVals)
+                this.values.splice(i, 1);
+              tree._size--;
+              i--;
+              iHigh--;
+            } else if (result.hasOwnProperty('value')) {
+              values![i] = result.value!;
+            }
+          }
+          if (result.break !== undefined)
+            return result;
+        }
+      }
+    } else
+      count += iHigh - iLow;
+    return count;
+  }
+
+  /** Adds entire contents of right-hand sibling (rhs is left unchanged) */
+  mergeSibling(rhs: BNode<K,V>, _: number) {
+    this.keys.push.apply(this.keys, rhs.keys);
+    if (this.values === undefVals) {
+      if (rhs.values === undefVals)
+        return;
+      this.values = this.values.slice(0, this.keys.length);
+    }
+    this.values.push.apply(this.values, rhs.reifyValues());
+  }
+}
+
+/** Internal node (non-leaf node) ********************************************/
+class BNodeInternal<K,V> extends BNode<K,V> {
+  // Note: conventionally B+ trees have one fewer key than the number of
+  // children, but I find it easier to keep the array lengths equal: each
+  // keys[i] caches the value of children[i].maxKey().
+  children: BNode<K,V>[];
+
+  /**
+   * This does not mark `children` as shared, so it is the responsibility of the caller
+   * to ensure children are either marked shared, or aren't included in another tree.
+   */
+  constructor(children: BNode<K,V>[], keys?: K[]) {
+    if (!keys) {
+      keys = [];
+      for (var i = 0; i < children.length; i++)
+        keys[i] = children[i].maxKey();
+    }
+    super(keys);
+    this.children = children;
+  }
+
+  override clone(): BNode<K,V> {
+    var children = this.children.slice(0);
+    for (var i = 0; i < children.length; i++)
+      children[i].isShared = true;
+    return new BNodeInternal<K,V>(children, this.keys.slice(0));
+  }
+
+  override greedyClone(force?: boolean): BNode<K,V> {
+    if (this.isShared && !force)
+      return this;
+    var nu = new BNodeInternal<K,V>(this.children.slice(0), this.keys.slice(0));
+    for (var i = 0; i < nu.children.length; i++)
+      nu.children[i] = nu.children[i].greedyClone(force);
+    return nu;
+  }
+
+  override minKey() {
+    return this.children[0].minKey();
+  }
+
+  override minPair(reusedArray: [K,V]): [K,V] | undefined {
+    return this.children[0].minPair(reusedArray);
+  }
+
+  override maxPair(reusedArray: [K,V]): [K,V] | undefined {
+    return this.children[this.children.length - 1].maxPair(reusedArray);
+  }
+
+  override get(key: K, defaultValue: V|undefined, tree: BTree<K,V>): V|undefined {
+    var i = this.indexOf(key, 0, tree._compare), children = this.children;
+    return i < children.length ? children[i].get(key, defaultValue, tree) : undefined;
+  }
+
+  override getPairOrNextLower(key: K, compare: (a: K, b: K) => number, inclusive: boolean, reusedArray: [K,V]): [K,V]|undefined {
+    var i = this.indexOf(key, 0, compare), children = this.children;
+    if (i >= children.length)
+      return this.maxPair(reusedArray);
+    const result = children[i].getPairOrNextLower(key, compare, inclusive, reusedArray);
+    if (result === undefined && i > 0) {
+      return children[i - 1].maxPair(reusedArray);
+    }
+    return result;
+  }
+
+  override getPairOrNextHigher(key: K, compare: (a: K, b: K) => number, inclusive: boolean, reusedArray: [K,V]): [K,V]|undefined {
+    var i = this.indexOf(key, 0, compare), children = this.children, length = children.length;
+    if (i >= length)
+      return undefined;
+    const result = children[i].getPairOrNextHigher(key, compare, inclusive, reusedArray);
+    if (result === undefined && i < length - 1) {
+      return children[i + 1].minPair(reusedArray);
+    }
+    return result;
+  }
+
+  override checkValid(depth: number, tree: BTree<K,V>, baseIndex: number): number {
+    let kL = this.keys.length, cL = this.children.length;
+    check(kL === cL, "keys/children length mismatch: depth", depth, "lengths", kL, cL, "baseIndex", baseIndex);
+    check(kL > 1 || depth > 0, "internal node has length", kL, "at depth", depth, "baseIndex", baseIndex);
+    let size = 0, c = this.children, k = this.keys, childSize = 0;
+    for (var i = 0; i < cL; i++) {
+      size += c[i].checkValid(depth + 1, tree, baseIndex + size);
+      childSize += c[i].keys.length;
+      check(size >= childSize, "wtf", baseIndex); // no way this will ever fail
+      check(i === 0 || c[i-1].constructor === c[i].constructor, "type mismatch, baseIndex:", baseIndex);
+      if (c[i].maxKey() != k[i])
+        check(false, "keys[", i, "] =", k[i], "is wrong, should be ", c[i].maxKey(), "at depth", depth, "baseIndex", baseIndex);
+      if (!(i === 0 || tree._compare(k[i-1], k[i]) < 0))
+        check(false, "sort violation at depth", depth, "index", i, "keys", k[i-1], k[i]);
+    }
+    // 2020/08: BTree doesn't always avoid grossly undersized nodes,
+    // but AFAIK such nodes are pretty harmless, so accept them.
+    let toofew = childSize === 0; // childSize < (tree.maxNodeSize >> 1)*cL;
+    if (toofew || childSize > tree.maxNodeSize*cL)
+      check(false, toofew ? "too few" : "too many", "children (", childSize, size, ") at depth", depth, "maxNodeSize:", tree.maxNodeSize, "children.length:", cL, "baseIndex:", baseIndex);
+    return size;
+  }
+
+  /////////////////////////////////////////////////////////////////////////////
+  // Internal Node: set & node splitting //////////////////////////////////////
+
+  override set(key: K, value: V, overwrite: boolean|undefined, tree: BTree<K,V>): boolean|BNodeInternal<K,V> {
+    var c = this.children, max = tree._maxNodeSize, cmp = tree._compare;
+    var i = Math.min(this.indexOf(key, 0, cmp), c.length - 1), child = c[i];
+
+    if (child.isShared)
+      c[i] = child = child.clone();
+    if (child.keys.length >= max) {
+      // child is full; inserting anything else will cause a split.
+      // Shifting an item to the left or right sibling may avoid a split.
+      // We can do a shift if the adjacent node is not full and if the
+      // current key can still be placed in the same node after the shift.
+      var other: BNode<K,V>;
+      if (i > 0 && (other = c[i-1]).keys.length < max && cmp(child.keys[0], key) < 0) {
+        if (other.isShared)
+          c[i-1] = other = other.clone();
+        other.takeFromRight(child);
+        this.keys[i-1] = other.maxKey();
+      } else if ((other = c[i+1]) !== undefined && other.keys.length < max && cmp(child.maxKey(), key) < 0) {
+        if (other.isShared)
+          c[i+1] = other = other.clone();
+        other.takeFromLeft(child);
+        this.keys[i] = c[i].maxKey();
+      }
+    }
+
+    var result = child.set(key, value, overwrite, tree);
+    if (result === false)
+      return false;
+    this.keys[i] = child.maxKey();
+    if (result === true)
+      return true;
+
+    // The child has split and `result` is a new right child... does it fit?
+    if (this.keys.length < max) { // yes
+      this.insert(i+1, result);
+      return true;
+    } else { // no, we must split also
+      var newRightSibling = this.splitOffRightSide(), target: BNodeInternal<K,V> = this;
+      if (cmp(result.maxKey(), this.maxKey()) > 0) {
+        target = newRightSibling;
+        i -= this.keys.length;
+      }
+      target.insert(i+1, result);
+      return newRightSibling;
+    }
+  }
+
+  /**
+   * Inserts `child` at index `i`.
+   * This does not mark `child` as shared, so it is the responsibility of the caller
+   * to ensure that either child is marked shared, or it is not included in another tree.
+   */
+  insert(i: index, child: BNode<K,V>) {
+    this.children.splice(i, 0, child);
+    this.keys.splice(i, 0, child.maxKey());
+  }
+
+  /**
+   * Split this node.
+   * Modifies this to remove the second half of the items, returning a separate node containing them.
+   */
+  override splitOffRightSide() {
+    // assert !this.isShared;
+    var half = this.children.length >> 1;
+    return new BNodeInternal<K,V>(this.children.splice(half), this.keys.splice(half));
+  }
+
+  override takeFromRight(rhs: BNode<K,V>) {
+    // Reminder: parent node must update its copy of key for this node
+    // assert: neither node is shared
+    // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)
+    this.keys.push(rhs.keys.shift()!);
+    this.children.push((rhs as BNodeInternal<K,V>).children.shift()!);
+  }
+
+  override takeFromLeft(lhs: BNode<K,V>) {
+    // Reminder: parent node must update its copy of key for this node
+    // assert: neither node is shared
+    // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)
+    this.keys.unshift(lhs.keys.pop()!);
+    this.children.unshift((lhs as BNodeInternal<K,V>).children.pop()!);
+  }
+
+  /////////////////////////////////////////////////////////////////////////////
+  // Internal Node: scanning & deletions //////////////////////////////////////
+
+  // Note: `count` is the next value of the third argument to `onFound`.
+  //       A leaf node's `forRange` function returns a new value for this counter,
+  //       unless the operation is to stop early.
+  override forRange<R>(low: K, high: K, includeHigh: boolean|undefined, editMode: boolean, tree: BTree<K,V>, count: number,
+    onFound?: (k:K, v:V, counter:number) => EditRangeResult<V,R>|void): EditRangeResult<V,R>|number
+  {
+    var cmp = tree._compare;
+    var keys = this.keys, children = this.children;
+    var iLow = this.indexOf(low, 0, cmp), i = iLow;
+    var iHigh = Math.min(high === low ? iLow : this.indexOf(high, 0, cmp), keys.length-1);
+    if (!editMode) {
+      // Simple case
+      for(; i <= iHigh; i++) {
+        var result = children[i].forRange(low, high, includeHigh, editMode, tree, count, onFound);
+        if (typeof result !== 'number')
+          return result;
+        count = result;
+      }
+    } else if (i <= iHigh) {
+      try {
+        for (; i <= iHigh; i++) {
+          if (children[i].isShared)
+            children[i] = children[i].clone();
+          var result = children[i].forRange(low, high, includeHigh, editMode, tree, count, onFound);
+          // Note: if children[i] is empty then keys[i]=undefined.
+          //       This is an invalid state, but it is fixed below.
+          keys[i] = children[i].maxKey();
+          if (typeof result !== 'number')
+            return result;
+          count = result;
+        }
+      } finally {
+        // Deletions may have occurred, so look for opportunities to merge nodes.
+        var half = tree._maxNodeSize >> 1;
+        if (iLow > 0)
+          iLow--;
+        for (i = iHigh; i >= iLow; i--) {
+          if (children[i].keys.length <= half) {
+            if (children[i].keys.length !== 0) {
+              this.tryMerge(i, tree._maxNodeSize);
+            } else { // child is empty! delete it!
+              keys.splice(i, 1);
+              children.splice(i, 1);
+            }
+          }
+        }
+        if (children.length !== 0 && children[0].keys.length === 0)
+          check(false, "emptiness bug");
+      }
+    }
+    return count;
+  }
+
+  /** Merges child i with child i+1 if their combined size is not too large */
+  tryMerge(i: index, maxSize: number): boolean {
+    var children = this.children;
+    if (i >= 0 && i + 1 < children.length) {
+      if (children[i].keys.length + children[i+1].keys.length <= maxSize) {
+        if (children[i].isShared) // cloned already UNLESS i is outside scan range
+          children[i] = children[i].clone();
+        children[i].mergeSibling(children[i+1], maxSize);
+        children.splice(i + 1, 1);
+        this.keys.splice(i + 1, 1);
+        this.keys[i] = children[i].maxKey();
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Move children from `rhs` into this.
+   * `rhs` must be part of this tree, and be removed from it after this call
+   * (otherwise isShared for its children could be incorrect).
+   */
+  override mergeSibling(rhs: BNode<K,V>, maxNodeSize: number) {
+    // assert !this.isShared;
+    var oldLength = this.keys.length;
+    this.keys.push.apply(this.keys, rhs.keys);
+    const rhsChildren = (rhs as any as BNodeInternal<K,V>).children;
+    this.children.push.apply(this.children, rhsChildren);
+
+    if (rhs.isShared && !this.isShared) {
+      // All children of a shared node are implicitly shared, and since their new
+      // parent is not shared, they must now be explicitly marked as shared.
+      for (var i = 0; i < rhsChildren.length; i++)
+        rhsChildren[i].isShared = true;
+    }
+
+    // If our children are themselves almost empty due to a mass-delete,
+    // they may need to be merged too (but only the oldLength-1 and its
+    // right sibling should need this).
+    this.tryMerge(oldLength-1, maxNodeSize);
+  }
+}
+
+/**
+ * A walkable pointer into a BTree for computing efficient diffs between trees with shared data.
+ * - A cursor points to either a key/value pair (KVP) or a node (which can be either a leaf or an internal node).
+ *    As a consequence, a cursor cannot be created for an empty tree.
+ * - A cursor can be walked forwards using `step`. A cursor can be compared to another cursor to
+ *    determine which is ahead in advancement.
+ * - A cursor is valid only for the tree it was created from, and only until the first edit made to
+ *    that tree since the cursor's creation.
+ * - A cursor contains a key for the current location, which is the maxKey when the cursor points to a node
+ *    and a key corresponding to a value when pointing to a leaf.
+ * - Leaf is only populated if the cursor points to a KVP. If this is the case, levelIndices.length === internalSpine.length + 1
+ *    and levelIndices[levelIndices.length - 1] is the index of the value.
+ */
+type DiffCursor<K,V> = { height: number, internalSpine: BNode<K,V>[][], levelIndices: number[], leaf: BNode<K,V> | undefined, currentKey: K };
+
+// Optimization: this array of `undefined`s is used instead of a normal
+// array of values in nodes where `undefined` is the only value.
+// Its length is extended to max node size on first use; since it can
+// be shared between trees with different maximums, its length can only
+// increase, never decrease. Its type should be undefined[] but strangely
+// TypeScript won't allow the comparison V[] === undefined[]. To prevent
+// users from making this array too large, BTree has a maximum node size.
+//
+// FAQ: undefVals[i] is already undefined, so why increase the array size?
+// Reading outside the bounds of an array is relatively slow because it
+// has the side effect of scanning the prototype chain.
+var undefVals: any[] = [];
+
+const Delete = {delete: true}, DeleteRange = () => Delete;
+const Break = {break: true};
+const EmptyLeaf = (function() {
+  var n = new BNode<any,any>(); n.isShared = true; return n;
+})();
+const EmptyArray: any[] = [];
+const ReusedArray: any[] = []; // assumed thread-local
+
+function check(fact: boolean, ...args: any[]) {
+  if (!fact) {
+    args.unshift('B+ tree'); // at beginning of message
+    throw new Error(args.join(' '));
+  }
+}
+
+/** A BTree frozen in the empty state. */
+export const EmptyBTree = (() => { let t = new BTree(); t.freeze(); return t; })();
diff --git a/benchmarks.ts b/benchmarks.ts
new file mode 100644
index 0000000000000000000000000000000000000000..153f5db86f017ce4b2194650e094c0a2e9a4bc78
--- /dev/null
+++ b/benchmarks.ts
@@ -0,0 +1,356 @@
+#!/usr/bin/env ts-node
+import { BTree, IMap} from '.';
+import SortedArray from './sorted-array';
+// Note: The `bintrees` package also includes a `BinTree` type which turned
+// out to be an unbalanced binary tree. It is faster than `RBTree` for
+// randomized data, but it becomes extremely slow when filled with sorted
+// data, so it's not usually a good choice.
+import {RBTree} from 'bintrees';
+const SortedSet = require("collections/sorted-set");         // Bad type definition: missing 'length'
+const SortedMap = require("collections/sorted-map");         // No type definitions available
+const functionalTree = require("functional-red-black-tree"); // No type definitions available
+
+class Timer {
+  start = Date.now();
+  ms() { return Date.now() - this.start; }
+  restart() { var ms = this.ms(); this.start += ms; return ms; }
+}
+
+function randInt(max: number) { return Math.random() * max | 0; }
+
+function swap(keys: any[], i: number, j: number) {
+  var tmp = keys[i];
+  keys[i] = keys[j];
+  keys[j] = tmp;
+}
+
+function makeArray(size: number, randomOrder: boolean, spacing = 10) {
+  var keys: number[] = [], i, n;
+  for (i = 0, n = 0; i < size; i++, n += 1 + randInt(spacing))
+    keys[i] = n;
+  if (randomOrder)
+    for (i = 0; i < size; i++)
+      swap(keys, i, randInt(size));
+  return keys;
+}
+
+function measure<T=void>(message: (t:T) => string, callback: () => T, minMillisec: number = 600, log = console.log) {
+  var timer = new Timer(), counter = 0, ms;
+  do {
+    var result = callback();
+    counter++;
+  } while ((ms = timer.ms()) < minMillisec);
+  ms /= counter;
+  log((Math.round(ms * 10) / 10) + "\t" + message(result));
+  return result;
+}
+
+console.log("Benchmark results (milliseconds with integer keys/values)");
+console.log("---------------------------------------------------------");
+
+console.log();
+console.log("### Insertions at random locations: sorted-btree vs the competition ###");
+
+for (let size of [1000, 10000, 100000, 1000000]) {
+  console.log();
+  var keys = makeArray(size, true);
+
+  measure(map => `Insert ${map.size} pairs in sorted-btree's BTree`, () => {
+    let map = new BTree();
+    for (let k of keys)
+      map.set(k, k);
+    return map;
+  });
+  measure(map => `Insert ${map.size} pairs in sorted-btree's BTree set (no values)`, () => {
+    let map = new BTree();
+    for (let k of keys)
+      map.set(k, undefined);
+    return map;
+  });
+  measure(map => `Insert ${map.length} pairs in collections' SortedMap`, () => {
+    let map = new SortedMap();
+    for (let k of keys)
+      map.set(k, k);
+    return map;
+  });
+  measure(set => `Insert ${set.length} pairs in collections' SortedSet (no values)`, () => {
+    let set = new SortedSet();
+    for (let k of keys)
+      set.push(k);
+    return set;
+  });
+  measure(set => `Insert ${set.length} pairs in functional-red-black-tree`, () => {
+    let set = functionalTree();
+    for (let k of keys)
+      set = set.insert(k, k);
+    return set;
+  });
+  measure(set => `Insert ${set.size} pairs in bintrees' RBTree (no values)`, () => {
+    let set = new RBTree((a: any, b: any) => a - b);
+    for (let k of keys)
+      set.insert(k);
+    return set;
+  });
+  //measure(set => `Insert ${set.size} pairs in bintrees' BinTree (no values)`, () => {
+  //  let set = new BinTree((a: any, b: any) => a - b);
+  //  for (let k of keys)
+  //    set.insert(k);
+  //  return set;
+  //});
+}
+
+console.log();
+console.log("### Insert in order, delete: sorted-btree vs the competition ###");
+
+for (let size of [9999, 1000, 10000, 100000, 1000000]) {
+  var log = (size === 9999 ? () => {} : console.log);
+  log();
+  var keys = makeArray(size, false), i;
+
+  let btree = measure(tree => `Insert ${tree.size} sorted pairs in B+ tree`, () => {
+    let tree = new BTree();
+    for (let k of keys)
+      tree.set(k, k * 10);
+    return tree;
+  }, 600, log);
+  let btreeSet = measure(tree => `Insert ${tree.size} sorted keys in B+ tree set (no values)`, () => {
+    let tree = new BTree();
+    for (let k of keys)
+      tree.set(k, undefined);
+    return tree;
+  }, 600, log);
+  // Another tree for the bulk-delete test
+  let btreeSet2 = btreeSet.greedyClone();
+
+  let sMap = measure(map => `Insert ${map.length} sorted pairs in collections' SortedMap`, () => {
+    let map = new SortedMap();
+    for (let k of keys)
+      map.set(k, k * 10);
+    return map;
+  }, 600, log);
+  let sSet = measure(set => `Insert ${set.length} sorted keys in collections' SortedSet (no values)`, () => {
+    let set = new SortedSet();
+    for (let k of keys)
+      set.push(k);
+    return set;
+  }, 600, log);
+  let fTree = measure(map => `Insert ${map.length} sorted pairs in functional-red-black-tree`, () => {
+    let map = functionalTree();
+    for (let k of keys)
+      map = map.insert(k, k * 10);
+    return map;
+  }, 600, log);
+  let rbTree = measure(set => `Insert ${set.size} sorted keys in bintrees' RBTree (no values)`, () => {
+    let set = new RBTree((a: any, b: any) => a - b);
+    for (let k of keys)
+      set.insert(k);
+    return set;
+  }, 600, log);
+  //let binTree = measure(set => `Insert ${set.size} sorted keys in bintrees' BinTree (no values)`, () => {
+  //  let set = new BinTree((a: any, b: any) => a - b);
+  //  for (let k of keys)
+  //    set.insert(k);
+  //  return set;
+  //});
+
+  // Bug fix: can't use measure() for deletions because the
+  //          trees aren't the same on the second iteration
+  var timer = new Timer();
+
+  for (i = 0; i < keys.length; i += 2)
+    btree.delete(keys[i]);
+  log(`${timer.restart()}\tDelete every second item in B+ tree`);
+
+  for (i = 0; i < keys.length; i += 2)
+    btreeSet.delete(keys[i]);
+  log(`${timer.restart()}\tDelete every second item in B+ tree set`);
+
+  btreeSet2.editRange(btreeSet2.minKey(), btreeSet2.maxKey(), true, (k,v,i) => {
+    if ((i & 1) === 0) return {delete:true};
+  });
+  log(`${timer.restart()}\tBulk-delete every second item in B+ tree set`);
+
+  for (i = 0; i < keys.length; i += 2)
+    sMap.delete(keys[i]);
+  log(`${timer.restart()}\tDelete every second item in collections' SortedMap`);
+
+  for (i = 0; i < keys.length; i += 2)
+    sSet.delete(keys[i]);
+  log(`${timer.restart()}\tDelete every second item in collections' SortedSet`);
+
+  for (i = 0; i < keys.length; i += 2)
+    fTree = fTree.remove(keys[i]);
+  log(`${timer.restart()}\tDelete every second item in functional-red-black-tree`);
+
+  for (i = 0; i < keys.length; i += 2)
+    rbTree.remove(keys[i]);
+  log(`${timer.restart()}\tDelete every second item in bintrees' RBTree`);
+}
+
+console.log();
+console.log("### Insertions at random locations: sorted-btree vs Array vs Map ###");
+
+for (let size of [9999, 1000, 10000, 100000, 1000000]) {
+  // Don't print anything in the first iteration (warm up the optimizer)
+  var log = (size === 9999 ? () => {} : console.log);
+  var keys = makeArray(size, true);
+  log();
+
+  if (size <= 100000) {
+    measure(list => `Insert ${list.size} pairs in sorted array`, () => {
+      let list = new SortedArray();
+      for (let k of keys)
+        list.set(k, k);
+      return list;
+    }, 600, log);
+  } else {
+    log(`SLOW!\tInsert ${size} pairs in sorted array`);
+  }
+
+  measure(tree => `Insert ${tree.size} pairs in B+ tree`, () => {
+    let tree = new BTree();
+    for (let k of keys)
+      tree.set(k, k);
+    return tree;
+  }, 600, log);
+
+  measure(map => `Insert ${map.size} pairs in ES6 Map (hashtable)`, () => {
+    let map = new Map();
+    for (let k of keys)
+      map.set(k, k);
+    return map;
+  }, 600, log);
+}
+
+console.log();
+console.log("### Insert in order, scan, delete: sorted-btree vs Array vs Map ###");
+
+for (let size of [1000, 10000, 100000, 1000000]) {
+  console.log();
+  var keys = makeArray(size, false), i;
+
+  var list = measure(list => `Insert ${list.size} sorted pairs in array`, () => {
+    let list = new SortedArray();
+    for (let k of keys)
+      list.set(k, k * 10);
+    return list;
+  });
+
+  let tree = measure(tree => `Insert ${tree.size} sorted pairs in B+ tree`, () => {
+    let tree = new BTree();
+    for (let k of keys)
+      tree.set(k, k * 10);
+    return tree;
+  });
+
+  let map = measure(map => `Insert ${map.size} sorted pairs in Map hashtable`, () => {
+    let map = new Map();
+    for (let k of keys)
+      map.set(k, k * 10);
+    return map;
+  });
+
+  measure(sum => `Sum of all values with forEach in sorted array: ${sum}`, () => {
+    var sum = 0;
+    list.getArray().forEach(pair => sum += pair[1]);
+    return sum;
+  });
+  measure(sum => `Sum of all values with forEachPair in B+ tree: ${sum}`, () => {
+    var sum = 0;
+    tree.forEachPair((k, v) => sum += v);
+    return sum;
+  });
+  measure(sum => `Sum of all values with forEach in B+ tree: ${sum}`, () => {
+    var sum = 0;
+    tree.forEach(v => sum += v);
+    return sum;
+  });
+  measure(sum => `Sum of all values with iterator in B+ tree: ${sum}`, () => {
+    var sum = 0;
+    // entries() (instead of values()) with reused pair should be fastest
+    // (not using for-of because tsc is in ES5 mode w/o --downlevelIteration)
+    for (var it = tree.entries(undefined, []), next = it.next(); !next.done; next = it.next())
+      sum += next.value[1];
+    return sum;
+  });
+  measure(sum => `Sum of all values with forEach in Map: ${sum}`, () => {
+    var sum = 0;
+    map.forEach(v => sum += v);
+    return sum;
+  });
+
+  if (keys.length <= 100000) {
+    measure(() => `Delete every second item in sorted array`, () => {
+      for (i = keys.length-1; i >= 0; i -= 2)
+        list.delete(keys[i]);
+    });
+  } else
+    console.log(`SLOW!\tDelete every second item in sorted array`);
+
+  measure(() => `Delete every second item in B+ tree`, () => {
+    for (i = keys.length-1; i >= 0; i -= 2)
+      tree.delete(keys[i]);
+  });
+
+  measure(() => `Delete every second item in Map hashtable`, () => {
+    for (i = keys.length-1; i >= 0; i -= 2)
+      map.delete(keys[i]);
+  });
+}
+
+console.log();
+console.log("### Measure effect of max node size ###");
+{
+  console.log();
+  var keys = makeArray(100000, true);
+  var timer = new Timer();
+  for (let nodeSize = 10; nodeSize <= 80; nodeSize += 2) {
+    let tree = new BTree([], undefined, nodeSize);
+    for (let i = 0; i < keys.length; i++)
+      tree.set(keys[i], undefined);
+    console.log(`${timer.restart()}\tInsert ${tree.size} keys in B+tree with node size ${tree.maxNodeSize}`);
+  }
+}
+
+console.log();
+console.log("### Delta between B+ trees");
+{
+  console.log();
+  const sizes = [100, 1000, 10000, 100000, 1000000];
+
+  sizes.forEach((size, i) => {
+    for (let j = i; j < sizes.length; j++) {
+      const tree = new BTree();
+      for (let k of makeArray(size, true))
+        tree.set(k, k * 10);
+
+      const otherSize = sizes[j];
+      const otherTree = new BTree();
+      for (let k of makeArray(otherSize, true))
+        otherTree.set(k, k * 10);
+
+      measure(() => `Delta between B+ trees with ${size} nodes and B+tree with ${otherSize} nodes`, () => {
+        tree.diffAgainst(otherTree);
+      });
+    }
+  })
+
+  console.log();
+  sizes.forEach((size, i) => {
+    for (let j = 0; j < sizes.length; j++) {
+      const otherSize = sizes[j];
+      const keys = makeArray(size + otherSize, true);
+      const tree = new BTree();
+      for (let k of keys.slice(0, size))
+        tree.set(k, k * 10);
+
+      const otherTree = tree.clone();
+      for (let k of keys.slice(size))
+        tree.set(k, k * 10);
+
+      measure(() => `Delta between B+ trees with ${size} nodes and cheap cloned B+tree with ${otherSize} additional nodes`, () => {
+        tree.diffAgainst(otherTree);
+      });
+    }
+  })
+}
diff --git a/dist/b+tree.d.ts b/dist/b+tree.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8e69e75052032cef362562f070456292714baede
--- /dev/null
+++ b/dist/b+tree.d.ts
@@ -0,0 +1,466 @@
+import { ISortedMap, ISortedMapF, ISortedSet } from './interfaces';
+export { ISetSource, ISetSink, ISet, ISetF, ISortedSetSource, ISortedSet, ISortedSetF, IMapSource, IMapSink, IMap, IMapF, ISortedMapSource, ISortedMap, ISortedMapF } from './interfaces';
+export type EditRangeResult<V, R = number> = {
+    value?: V;
+    break?: R;
+    delete?: boolean;
+};
+/**
+ * Types that BTree supports by default
+ */
+export type DefaultComparable = number | string | Date | boolean | null | undefined | (number | string)[] | {
+    valueOf: () => number | string | Date | boolean | null | undefined | (number | string)[];
+};
+/**
+ * Compares DefaultComparables to form a strict partial ordering.
+ *
+ * Handles +/-0 and NaN like Map: NaN is equal to NaN, and -0 is equal to +0.
+ *
+ * Arrays are compared using '<' and '>', which may cause unexpected equality:
+ * for example [1] will be considered equal to ['1'].
+ *
+ * Two objects with equal valueOf compare the same, but compare unequal to
+ * primitives that have the same value.
+ */
+export declare function defaultComparator(a: DefaultComparable, b: DefaultComparable): number;
+/**
+ * Compares items using the < and > operators. This function is probably slightly
+ * faster than the defaultComparator for Dates and strings, but has not been benchmarked.
+ * Unlike defaultComparator, this comparator doesn't support mixed types correctly,
+ * i.e. use it with `BTree<string>` or `BTree<number>` but not `BTree<string|number>`.
+ *
+ * NaN is not supported.
+ *
+ * Note: null is treated like 0 when compared with numbers or Date, but in general
+ *   null is not ordered with respect to strings (neither greater nor less), and
+ *   undefined is not ordered with other types.
+ */
+export declare function simpleComparator(a: string, b: string): number;
+export declare function simpleComparator(a: number | null, b: number | null): number;
+export declare function simpleComparator(a: Date | null, b: Date | null): number;
+export declare function simpleComparator(a: (number | string)[], b: (number | string)[]): number;
+/**
+ * A reasonably fast collection of key-value pairs with a powerful API.
+ * Largely compatible with the standard Map. BTree is a B+ tree data structure,
+ * so the collection is sorted by key.
+ *
+ * B+ trees tend to use memory more efficiently than hashtables such as the
+ * standard Map, especially when the collection contains a large number of
+ * items. However, maintaining the sort order makes them modestly slower:
+ * O(log size) rather than O(1). This B+ tree implementation supports O(1)
+ * fast cloning. It also supports freeze(), which can be used to ensure that
+ * a BTree is not changed accidentally.
+ *
+ * Confusingly, the ES6 Map.forEach(c) method calls c(value,key) instead of
+ * c(key,value), in contrast to other methods such as set() and entries()
+ * which put the key first. I can only assume that the order was reversed on
+ * the theory that users would usually want to examine values and ignore keys.
+ * BTree's forEach() therefore works the same way, but a second method
+ * `.forEachPair((key,value)=>{...})` is provided which sends you the key
+ * first and the value second; this method is slightly faster because it is
+ * the "native" for-each method for this class.
+ *
+ * Out of the box, BTree supports keys that are numbers, strings, arrays of
+ * numbers/strings, Date, and objects that have a valueOf() method returning a
+ * number or string. Other data types, such as arrays of Date or custom
+ * objects, require a custom comparator, which you must pass as the second
+ * argument to the constructor (the first argument is an optional list of
+ * initial items). Symbols cannot be used as keys because they are unordered
+ * (one Symbol is never "greater" or "less" than another).
+ *
+ * @example
+ * Given a {name: string, age: number} object, you can create a tree sorted by
+ * name and then by age like this:
+ *
+ *     var tree = new BTree(undefined, (a, b) => {
+ *       if (a.name > b.name)
+ *         return 1; // Return a number >0 when a > b
+ *       else if (a.name < b.name)
+ *         return -1; // Return a number <0 when a < b
+ *       else // names are equal (or incomparable)
+ *         return a.age - b.age; // Return >0 when a.age > b.age
+ *     });
+ *
+ *     tree.set({name:"Bill", age:17}, "happy");
+ *     tree.set({name:"Fran", age:40}, "busy & stressed");
+ *     tree.set({name:"Bill", age:55}, "recently laid off");
+ *     tree.forEachPair((k, v) => {
+ *       console.log(`Name: ${k.name} Age: ${k.age} Status: ${v}`);
+ *     });
+ *
+ * @description
+ * The "range" methods (`forEach, forRange, editRange`) will return the number
+ * of elements that were scanned. In addition, the callback can return {break:R}
+ * to stop early and return R from the outer function.
+ *
+ * - TODO: Test performance of preallocating values array at max size
+ * - TODO: Add fast initialization when a sorted array is provided to constructor
+ *
+ * For more documentation see https://github.com/qwertie/btree-typescript
+ *
+ * Are you a C# developer? You might like the similar data structures I made for C#:
+ * BDictionary, BList, etc. See http://core.loyc.net/collections/
+ *
+ * @author David Piepgrass
+ */
+export declare class BTree<K = any, V = any> implements ISortedMapF<K, V>, ISortedMap<K, V> {
+    private _root;
+    _size: number;
+    _maxNodeSize: number;
+    /**
+     * provides a total order over keys (and a strict partial order over the type K)
+     * @returns a negative value if a < b, 0 if a === b and a positive value if a > b
+     */
+    _compare: (a: K, b: K) => number;
+    /**
+     * Initializes an empty B+ tree.
+     * @param compare Custom function to compare pairs of elements in the tree.
+     *   If not specified, defaultComparator will be used which is valid as long as K extends DefaultComparable.
+     * @param entries A set of key-value pairs to initialize the tree
+     * @param maxNodeSize Branching factor (maximum items or children per node)
+     *   Must be in range 4..256. If undefined or <4 then default is used; if >256 then 256.
+     */
+    constructor(entries?: [K, V][], compare?: (a: K, b: K) => number, maxNodeSize?: number);
+    /** Gets the number of key-value pairs in the tree. */
+    get size(): number;
+    /** Gets the number of key-value pairs in the tree. */
+    get length(): number;
+    /** Returns true iff the tree contains no key-value pairs. */
+    get isEmpty(): boolean;
+    /** Releases the tree so that its size is 0. */
+    clear(): void;
+    forEach(callback: (v: V, k: K, tree: BTree<K, V>) => void, thisArg?: any): number;
+    /** Runs a function for each key-value pair, in order from smallest to
+     *  largest key. The callback can return {break:R} (where R is any value
+     *  except undefined) to stop immediately and return R from forEachPair.
+     * @param onFound A function that is called for each key-value pair. This
+     *        function can return {break:R} to stop early with result R.
+     *        The reason that you must return {break:R} instead of simply R
+     *        itself is for consistency with editRange(), which allows
+     *        multiple actions, not just breaking.
+     * @param initialCounter This is the value of the third argument of
+     *        `onFound` the first time it is called. The counter increases
+     *        by one each time `onFound` is called. Default value: 0
+     * @returns the number of pairs sent to the callback (plus initialCounter,
+     *        if you provided one). If the callback returned {break:R} then
+     *        the R value is returned instead. */
+    forEachPair<R = number>(callback: (k: K, v: V, counter: number) => {
+        break?: R;
+    } | void, initialCounter?: number): R | number;
+    /**
+     * Finds a pair in the tree and returns the associated value.
+     * @param defaultValue a value to return if the key was not found.
+     * @returns the value, or defaultValue if the key was not found.
+     * @description Computational complexity: O(log size)
+     */
+    get(key: K, defaultValue?: V): V | undefined;
+    /**
+     * Adds or overwrites a key-value pair in the B+ tree.
+     * @param key the key is used to determine the sort order of
+     *        data in the tree.
+     * @param value data to associate with the key (optional)
+     * @param overwrite Whether to overwrite an existing key-value pair
+     *        (default: true). If this is false and there is an existing
+     *        key-value pair then this method has no effect.
+     * @returns true if a new key-value pair was added.
+     * @description Computational complexity: O(log size)
+     * Note: when overwriting a previous entry, the key is updated
+     * as well as the value. This has no effect unless the new key
+     * has data that does not affect its sort order.
+     */
+    set(key: K, value: V, overwrite?: boolean): boolean;
+    /**
+     * Returns true if the key exists in the B+ tree, false if not.
+     * Use get() for best performance; use has() if you need to
+     * distinguish between "undefined value" and "key not present".
+     * @param key Key to detect
+     * @description Computational complexity: O(log size)
+     */
+    has(key: K): boolean;
+    /**
+     * Removes a single key-value pair from the B+ tree.
+     * @param key Key to find
+     * @returns true if a pair was found and removed, false otherwise.
+     * @description Computational complexity: O(log size)
+     */
+    delete(key: K): boolean;
+    /** Returns a copy of the tree with the specified key set (the value is undefined). */
+    with(key: K): BTree<K, V | undefined>;
+    /** Returns a copy of the tree with the specified key-value pair set. */
+    with<V2>(key: K, value: V2, overwrite?: boolean): BTree<K, V | V2>;
+    /** Returns a copy of the tree with the specified key-value pairs set. */
+    withPairs<V2>(pairs: [K, V | V2][], overwrite: boolean): BTree<K, V | V2>;
+    /** Returns a copy of the tree with the specified keys present.
+     *  @param keys The keys to add. If a key is already present in the tree,
+     *         neither the existing key nor the existing value is modified.
+     *  @param returnThisIfUnchanged if true, returns this if all keys already
+     *  existed. Performance note: due to the architecture of this class, all
+     *  node(s) leading to existing keys are cloned even if the collection is
+     *  ultimately unchanged.
+    */
+    withKeys(keys: K[], returnThisIfUnchanged?: boolean): BTree<K, V | undefined>;
+    /** Returns a copy of the tree with the specified key removed.
+     * @param returnThisIfUnchanged if true, returns this if the key didn't exist.
+     *  Performance note: due to the architecture of this class, node(s) leading
+     *  to where the key would have been stored are cloned even when the key
+     *  turns out not to exist and the collection is unchanged.
+     */
+    without(key: K, returnThisIfUnchanged?: boolean): BTree<K, V>;
+    /** Returns a copy of the tree with the specified keys removed.
+     * @param returnThisIfUnchanged if true, returns this if none of the keys
+     *  existed. Performance note: due to the architecture of this class,
+     *  node(s) leading to where the key would have been stored are cloned
+     *  even when the key turns out not to exist.
+     */
+    withoutKeys(keys: K[], returnThisIfUnchanged?: boolean): BTree<K, V>;
+    /** Returns a copy of the tree with the specified range of keys removed. */
+    withoutRange(low: K, high: K, includeHigh: boolean, returnThisIfUnchanged?: boolean): BTree<K, V>;
+    /** Returns a copy of the tree with pairs removed whenever the callback
+     *  function returns false. `where()` is a synonym for this method. */
+    filter(callback: (k: K, v: V, counter: number) => boolean, returnThisIfUnchanged?: boolean): BTree<K, V>;
+    /** Returns a copy of the tree with all values altered by a callback function. */
+    mapValues<R>(callback: (v: V, k: K, counter: number) => R): BTree<K, R>;
+    /** Performs a reduce operation like the `reduce` method of `Array`.
+     *  It is used to combine all pairs into a single value, or perform
+     *  conversions. `reduce` is best understood by example. For example,
+     *  `tree.reduce((P, pair) => P * pair[0], 1)` multiplies all keys
+     *  together. It means "start with P=1, and for each pair multiply
+     *  it by the key in pair[0]". Another example would be converting
+     *  the tree to a Map (in this example, note that M.set returns M):
+     *
+     *  var M = tree.reduce((M, pair) => M.set(pair[0],pair[1]), new Map())
+     *
+     *  **Note**: the same array is sent to the callback on every iteration.
+     */
+    reduce<R>(callback: (previous: R, currentPair: [K, V], counter: number, tree: BTree<K, V>) => R, initialValue: R): R;
+    reduce<R>(callback: (previous: R | undefined, currentPair: [K, V], counter: number, tree: BTree<K, V>) => R): R | undefined;
+    /** Returns an iterator that provides items in order (ascending order if
+     *  the collection's comparator uses ascending order, as is the default.)
+     *  @param lowestKey First key to be iterated, or undefined to start at
+     *         minKey(). If the specified key doesn't exist then iteration
+     *         starts at the next higher key (according to the comparator).
+     *  @param reusedArray Optional array used repeatedly to store key-value
+     *         pairs, to avoid creating a new array on every iteration.
+     */
+    entries(lowestKey?: K, reusedArray?: (K | V)[]): IterableIterator<[K, V]>;
+    /** Returns an iterator that provides items in reversed order.
+     *  @param highestKey Key at which to start iterating, or undefined to
+     *         start at maxKey(). If the specified key doesn't exist then iteration
+     *         starts at the next lower key (according to the comparator).
+     *  @param reusedArray Optional array used repeatedly to store key-value
+     *         pairs, to avoid creating a new array on every iteration.
+     *  @param skipHighest Iff this flag is true and the highestKey exists in the
+     *         collection, the pair matching highestKey is skipped, not iterated.
+     */
+    entriesReversed(highestKey?: K, reusedArray?: (K | V)[], skipHighest?: boolean): IterableIterator<[K, V]>;
+    private findPath;
+    /**
+     * Computes the differences between `this` and `other`.
+     * For efficiency, the diff is returned via invocations of supplied handlers.
+     * The computation is optimized for the case in which the two trees have large amounts
+     * of shared data (obtained by calling the `clone` or `with` APIs) and will avoid
+     * any iteration of shared state.
+     * The handlers can cause computation to early exit by returning {break: R}.
+     * Neither of the collections should be changed during the comparison process (in your callbacks), as this method assumes they will not be mutated.
+     * @param other The tree to compute a diff against.
+     * @param onlyThis Callback invoked for all keys only present in `this`.
+     * @param onlyOther Callback invoked for all keys only present in `other`.
+     * @param different Callback invoked for all keys with differing values.
+     */
+    diffAgainst<R>(other: BTree<K, V>, onlyThis?: (k: K, v: V) => {
+        break?: R;
+    } | void, onlyOther?: (k: K, v: V) => {
+        break?: R;
+    } | void, different?: (k: K, vThis: V, vOther: V) => {
+        break?: R;
+    } | void): R | undefined;
+    private static finishCursorWalk;
+    private static stepToEnd;
+    private static makeDiffCursor;
+    /**
+     * Advances the cursor to the next step in the walk of its tree.
+     * Cursors are walked backwards in sort order, as this allows them to leverage maxKey() in order to be compared in O(1).
+     * @param cursor The cursor to step
+     * @param stepToNode If true, the cursor will be advanced to the next node (skipping values)
+     * @returns true if the step was completed and false if the step would have caused the cursor to move beyond the end of the tree.
+     */
+    private static step;
+    /**
+     * Compares the two cursors. Returns a value indicating which cursor is ahead in a walk.
+     * Note that cursors are advanced in reverse sorting order.
+     */
+    private static compare;
+    /** Returns a new iterator for iterating the keys of each pair in ascending order.
+     *  @param firstKey: Minimum key to include in the output. */
+    keys(firstKey?: K): IterableIterator<K>;
+    /** Returns a new iterator for iterating the values of each pair in order by key.
+     *  @param firstKey: Minimum key whose associated value is included in the output. */
+    values(firstKey?: K): IterableIterator<V>;
+    /** Returns the maximum number of children/values before nodes will split. */
+    get maxNodeSize(): number;
+    /** Gets the lowest key in the tree. Complexity: O(log size) */
+    minKey(): K | undefined;
+    /** Gets the highest key in the tree. Complexity: O(1) */
+    maxKey(): K | undefined;
+    /** Quickly clones the tree by marking the root node as shared.
+     *  Both copies remain editable. When you modify either copy, any
+     *  nodes that are shared (or potentially shared) between the two
+     *  copies are cloned so that the changes do not affect other copies.
+     *  This is known as copy-on-write behavior, or "lazy copying". */
+    clone(): BTree<K, V>;
+    /** Performs a greedy clone, immediately duplicating any nodes that are
+     *  not currently marked as shared, in order to avoid marking any
+     *  additional nodes as shared.
+     *  @param force Clone all nodes, even shared ones.
+     */
+    greedyClone(force?: boolean): BTree<K, V>;
+    /** Gets an array filled with the contents of the tree, sorted by key */
+    toArray(maxLength?: number): [K, V][];
+    /** Gets an array of all keys, sorted */
+    keysArray(): K[];
+    /** Gets an array of all values, sorted by key */
+    valuesArray(): V[];
+    /** Gets a string representing the tree's data based on toArray(). */
+    toString(): string;
+    /** Stores a key-value pair only if the key doesn't already exist in the tree.
+     * @returns true if a new key was added
+    */
+    setIfNotPresent(key: K, value: V): boolean;
+    /** Returns the next pair whose key is larger than the specified key (or undefined if there is none).
+     * If key === undefined, this function returns the lowest pair.
+     * @param key The key to search for.
+     * @param reusedArray Optional array used repeatedly to store key-value pairs, to
+     * avoid creating a new array on every iteration.
+     */
+    nextHigherPair(key: K | undefined, reusedArray?: [K, V]): [K, V] | undefined;
+    /** Returns the next key larger than the specified key, or undefined if there is none.
+     *  Also, nextHigherKey(undefined) returns the lowest key.
+     */
+    nextHigherKey(key: K | undefined): K | undefined;
+    /** Returns the next pair whose key is smaller than the specified key (or undefined if there is none).
+     *  If key === undefined, this function returns the highest pair.
+     * @param key The key to search for.
+     * @param reusedArray Optional array used repeatedly to store key-value pairs, to
+     *        avoid creating a new array each time you call this method.
+     */
+    nextLowerPair(key: K | undefined, reusedArray?: [K, V]): [K, V] | undefined;
+    /** Returns the next key smaller than the specified key, or undefined if there is none.
+     *  Also, nextLowerKey(undefined) returns the highest key.
+     */
+    nextLowerKey(key: K | undefined): K | undefined;
+    /** Returns the key-value pair associated with the supplied key if it exists
+     *  or the pair associated with the next lower pair otherwise. If there is no
+     *  next lower pair, undefined is returned.
+     * @param key The key to search for.
+     * @param reusedArray Optional array used repeatedly to store key-value pairs, to
+     *        avoid creating a new array each time you call this method.
+     * */
+    getPairOrNextLower(key: K, reusedArray?: [K, V]): [K, V] | undefined;
+    /** Returns the key-value pair associated with the supplied key if it exists
+     *  or the pair associated with the next lower pair otherwise. If there is no
+     *  next lower pair, undefined is returned.
+     * @param key The key to search for.
+     * @param reusedArray Optional array used repeatedly to store key-value pairs, to
+     *        avoid creating a new array each time you call this method.
+     * */
+    getPairOrNextHigher(key: K, reusedArray?: [K, V]): [K, V] | undefined;
+    /** Edits the value associated with a key in the tree, if it already exists.
+     * @returns true if the key existed, false if not.
+    */
+    changeIfPresent(key: K, value: V): boolean;
+    /**
+     * Builds an array of pairs from the specified range of keys, sorted by key.
+     * Each returned pair is also an array: pair[0] is the key, pair[1] is the value.
+     * @param low The first key in the array will be greater than or equal to `low`.
+     * @param high This method returns when a key larger than this is reached.
+     * @param includeHigh If the `high` key is present, its pair will be included
+     *        in the output if and only if this parameter is true. Note: if the
+     *        `low` key is present, it is always included in the output.
+     * @param maxLength Length limit. getRange will stop scanning the tree when
+     *                  the array reaches this size.
+     * @description Computational complexity: O(result.length + log size)
+     */
+    getRange(low: K, high: K, includeHigh?: boolean, maxLength?: number): [K, V][];
+    /** Adds all pairs from a list of key-value pairs.
+     * @param pairs Pairs to add to this tree. If there are duplicate keys,
+     *        later pairs currently overwrite earlier ones (e.g. [[0,1],[0,7]]
+     *        associates 0 with 7.)
+     * @param overwrite Whether to overwrite pairs that already exist (if false,
+     *        pairs[i] is ignored when the key pairs[i][0] already exists.)
+     * @returns The number of pairs added to the collection.
+     * @description Computational complexity: O(pairs.length * log(size + pairs.length))
+     */
+    setPairs(pairs: [K, V][], overwrite?: boolean): number;
+    forRange(low: K, high: K, includeHigh: boolean, onFound?: (k: K, v: V, counter: number) => void, initialCounter?: number): number;
+    /**
+     * Scans and potentially modifies values for a subsequence of keys.
+     * Note: the callback `onFound` should ideally be a pure function.
+     *   Specfically, it must not insert items, call clone(), or change
+     *   the collection except via return value; out-of-band editing may
+     *   cause an exception or may cause incorrect data to be sent to
+     *   the callback (duplicate or missed items). It must not cause a
+     *   clone() of the collection, otherwise the clone could be modified
+     *   by changes requested by the callback.
+     * @param low The first key scanned will be greater than or equal to `low`.
+     * @param high Scanning stops when a key larger than this is reached.
+     * @param includeHigh If the `high` key is present, `onFound` is called for
+     *        that final pair if and only if this parameter is true.
+     * @param onFound A function that is called for each key-value pair. This
+     *        function can return `{value:v}` to change the value associated
+     *        with the current key, `{delete:true}` to delete the current pair,
+     *        `{break:R}` to stop early with result R, or it can return nothing
+     *        (undefined or {}) to cause no effect and continue iterating.
+     *        `{break:R}` can be combined with one of the other two commands.
+     *        The third argument `counter` is the number of items iterated
+     *        previously; it equals 0 when `onFound` is called the first time.
+     * @returns The number of values scanned, or R if the callback returned
+     *        `{break:R}` to stop early.
+     * @description
+     *   Computational complexity: O(number of items scanned + log size)
+     *   Note: if the tree has been cloned with clone(), any shared
+     *   nodes are copied before `onFound` is called. This takes O(n) time
+     *   where n is proportional to the amount of shared data scanned.
+     */
+    editRange<R = V>(low: K, high: K, includeHigh: boolean, onFound: (k: K, v: V, counter: number) => EditRangeResult<V, R> | void, initialCounter?: number): R | number;
+    /** Same as `editRange` except that the callback is called for all pairs. */
+    editAll<R = V>(onFound: (k: K, v: V, counter: number) => EditRangeResult<V, R> | void, initialCounter?: number): R | number;
+    /**
+     * Removes a range of key-value pairs from the B+ tree.
+     * @param low The first key scanned will be greater than or equal to `low`.
+     * @param high Scanning stops when a key larger than this is reached.
+     * @param includeHigh Specifies whether the `high` key, if present, is deleted.
+     * @returns The number of key-value pairs that were deleted.
+     * @description Computational complexity: O(log size + number of items deleted)
+     */
+    deleteRange(low: K, high: K, includeHigh: boolean): number;
+    /** Deletes a series of keys from the collection. */
+    deleteKeys(keys: K[]): number;
+    /** Gets the height of the tree: the number of internal nodes between the
+     *  BTree object and its leaf nodes (zero if there are no internal nodes). */
+    get height(): number;
+    /** Makes the object read-only to ensure it is not accidentally modified.
+     *  Freezing does not have to be permanent; unfreeze() reverses the effect.
+     *  This is accomplished by replacing mutator functions with a function
+     *  that throws an Error. Compared to using a property (e.g. this.isFrozen)
+     *  this implementation gives better performance in non-frozen BTrees.
+     */
+    freeze(): void;
+    /** Ensures mutations are allowed, reversing the effect of freeze(). */
+    unfreeze(): void;
+    /** Returns true if the tree appears to be frozen. */
+    get isFrozen(): boolean;
+    /** Scans the tree for signs of serious bugs (e.g. this.size doesn't match
+     *  number of elements, internal nodes not caching max element properly...)
+     *  Computational complexity: O(number of nodes), i.e. O(size). This method
+     *  skips the most expensive test - whether all keys are sorted - but it
+     *  does check that maxKey() of the children of internal nodes are sorted. */
+    checkValid(): void;
+}
+/** A TypeScript helper function that simply returns its argument, typed as
+ *  `ISortedSet<K>` if the BTree implements it, as it does if `V extends undefined`.
+ *  If `V` cannot be `undefined`, it returns `unknown` instead. Or at least, that
+ *  was the intention, but TypeScript is acting weird and may return `ISortedSet<K>`
+ *  even if `V` can't be `undefined` (discussion: btree-typescript issue #14) */
+export declare function asSet<K, V>(btree: BTree<K, V>): undefined extends V ? ISortedSet<K> : unknown;
+/** A BTree frozen in the empty state. */
+export declare const EmptyBTree: BTree<any, any>;
diff --git a/dist/b+tree.js b/dist/b+tree.js
new file mode 100644
index 0000000000000000000000000000000000000000..42902224481cd1c1482fdd58f784d1331c219daf
--- /dev/null
+++ b/dist/b+tree.js
@@ -0,0 +1,1634 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.EmptyBTree = exports.asSet = exports.BTree = exports.simpleComparator = exports.defaultComparator = void 0;
+/**
+ * Compares DefaultComparables to form a strict partial ordering.
+ *
+ * Handles +/-0 and NaN like Map: NaN is equal to NaN, and -0 is equal to +0.
+ *
+ * Arrays are compared using '<' and '>', which may cause unexpected equality:
+ * for example [1] will be considered equal to ['1'].
+ *
+ * Two objects with equal valueOf compare the same, but compare unequal to
+ * primitives that have the same value.
+ */
+function defaultComparator(a, b) {
+    // Special case finite numbers first for performance.
+    // Note that the trick of using 'a - b' and checking for NaN to detect non-numbers
+    // does not work if the strings are numeric (ex: "5"). This would leading most
+    // comparison functions using that approach to fail to have transitivity.
+    if (Number.isFinite(a) && Number.isFinite(b)) {
+        return a - b;
+    }
+    // The default < and > operators are not totally ordered. To allow types to be mixed
+    // in a single collection, compare types and order values of different types by type.
+    let ta = typeof a;
+    let tb = typeof b;
+    if (ta !== tb) {
+        return ta < tb ? -1 : 1;
+    }
+    if (ta === 'object') {
+        // standardized JavaScript bug: null is not an object, but typeof says it is
+        if (a === null)
+            return b === null ? 0 : -1;
+        else if (b === null)
+            return 1;
+        a = a.valueOf();
+        b = b.valueOf();
+        ta = typeof a;
+        tb = typeof b;
+        // Deal with the two valueOf()s producing different types
+        if (ta !== tb) {
+            return ta < tb ? -1 : 1;
+        }
+    }
+    // a and b are now the same type, and will be a number, string or array
+    // (which we assume holds numbers or strings), or something unsupported.
+    if (a < b)
+        return -1;
+    if (a > b)
+        return 1;
+    if (a === b)
+        return 0;
+    // Order NaN less than other numbers
+    if (Number.isNaN(a))
+        return Number.isNaN(b) ? 0 : -1;
+    else if (Number.isNaN(b))
+        return 1;
+    // This could be two objects (e.g. [7] and ['7']) that aren't ordered
+    return Array.isArray(a) ? 0 : Number.NaN;
+}
+exports.defaultComparator = defaultComparator;
+;
+function simpleComparator(a, b) {
+    return a > b ? 1 : a < b ? -1 : 0;
+}
+exports.simpleComparator = simpleComparator;
+;
+/**
+ * A reasonably fast collection of key-value pairs with a powerful API.
+ * Largely compatible with the standard Map. BTree is a B+ tree data structure,
+ * so the collection is sorted by key.
+ *
+ * B+ trees tend to use memory more efficiently than hashtables such as the
+ * standard Map, especially when the collection contains a large number of
+ * items. However, maintaining the sort order makes them modestly slower:
+ * O(log size) rather than O(1). This B+ tree implementation supports O(1)
+ * fast cloning. It also supports freeze(), which can be used to ensure that
+ * a BTree is not changed accidentally.
+ *
+ * Confusingly, the ES6 Map.forEach(c) method calls c(value,key) instead of
+ * c(key,value), in contrast to other methods such as set() and entries()
+ * which put the key first. I can only assume that the order was reversed on
+ * the theory that users would usually want to examine values and ignore keys.
+ * BTree's forEach() therefore works the same way, but a second method
+ * `.forEachPair((key,value)=>{...})` is provided which sends you the key
+ * first and the value second; this method is slightly faster because it is
+ * the "native" for-each method for this class.
+ *
+ * Out of the box, BTree supports keys that are numbers, strings, arrays of
+ * numbers/strings, Date, and objects that have a valueOf() method returning a
+ * number or string. Other data types, such as arrays of Date or custom
+ * objects, require a custom comparator, which you must pass as the second
+ * argument to the constructor (the first argument is an optional list of
+ * initial items). Symbols cannot be used as keys because they are unordered
+ * (one Symbol is never "greater" or "less" than another).
+ *
+ * @example
+ * Given a {name: string, age: number} object, you can create a tree sorted by
+ * name and then by age like this:
+ *
+ *     var tree = new BTree(undefined, (a, b) => {
+ *       if (a.name > b.name)
+ *         return 1; // Return a number >0 when a > b
+ *       else if (a.name < b.name)
+ *         return -1; // Return a number <0 when a < b
+ *       else // names are equal (or incomparable)
+ *         return a.age - b.age; // Return >0 when a.age > b.age
+ *     });
+ *
+ *     tree.set({name:"Bill", age:17}, "happy");
+ *     tree.set({name:"Fran", age:40}, "busy & stressed");
+ *     tree.set({name:"Bill", age:55}, "recently laid off");
+ *     tree.forEachPair((k, v) => {
+ *       console.log(`Name: ${k.name} Age: ${k.age} Status: ${v}`);
+ *     });
+ *
+ * @description
+ * The "range" methods (`forEach, forRange, editRange`) will return the number
+ * of elements that were scanned. In addition, the callback can return {break:R}
+ * to stop early and return R from the outer function.
+ *
+ * - TODO: Test performance of preallocating values array at max size
+ * - TODO: Add fast initialization when a sorted array is provided to constructor
+ *
+ * For more documentation see https://github.com/qwertie/btree-typescript
+ *
+ * Are you a C# developer? You might like the similar data structures I made for C#:
+ * BDictionary, BList, etc. See http://core.loyc.net/collections/
+ *
+ * @author David Piepgrass
+ */
+class BTree {
+    /**
+     * Initializes an empty B+ tree.
+     * @param compare Custom function to compare pairs of elements in the tree.
+     *   If not specified, defaultComparator will be used which is valid as long as K extends DefaultComparable.
+     * @param entries A set of key-value pairs to initialize the tree
+     * @param maxNodeSize Branching factor (maximum items or children per node)
+     *   Must be in range 4..256. If undefined or <4 then default is used; if >256 then 256.
+     */
+    constructor(entries, compare, maxNodeSize) {
+        this._root = EmptyLeaf;
+        this._size = 0;
+        this._maxNodeSize = maxNodeSize >= 4 ? Math.min(maxNodeSize, 256) : 32;
+        this._compare = compare || defaultComparator;
+        if (entries)
+            this.setPairs(entries);
+    }
+    /////////////////////////////////////////////////////////////////////////////
+    // ES6 Map<K,V> methods /////////////////////////////////////////////////////
+    /** Gets the number of key-value pairs in the tree. */
+    get size() { return this._size; }
+    /** Gets the number of key-value pairs in the tree. */
+    get length() { return this._size; }
+    /** Returns true iff the tree contains no key-value pairs. */
+    get isEmpty() { return this._size === 0; }
+    /** Releases the tree so that its size is 0. */
+    clear() {
+        this._root = EmptyLeaf;
+        this._size = 0;
+    }
+    /** Runs a function for each key-value pair, in order from smallest to
+     *  largest key. For compatibility with ES6 Map, the argument order to
+     *  the callback is backwards: value first, then key. Call forEachPair
+     *  instead to receive the key as the first argument.
+     * @param thisArg If provided, this parameter is assigned as the `this`
+     *        value for each callback.
+     * @returns the number of values that were sent to the callback,
+     *        or the R value if the callback returned {break:R}. */
+    forEach(callback, thisArg) {
+        if (thisArg !== undefined)
+            callback = callback.bind(thisArg);
+        return this.forEachPair((k, v) => callback(v, k, this));
+    }
+    /** Runs a function for each key-value pair, in order from smallest to
+     *  largest key. The callback can return {break:R} (where R is any value
+     *  except undefined) to stop immediately and return R from forEachPair.
+     * @param onFound A function that is called for each key-value pair. This
+     *        function can return {break:R} to stop early with result R.
+     *        The reason that you must return {break:R} instead of simply R
+     *        itself is for consistency with editRange(), which allows
+     *        multiple actions, not just breaking.
+     * @param initialCounter This is the value of the third argument of
+     *        `onFound` the first time it is called. The counter increases
+     *        by one each time `onFound` is called. Default value: 0
+     * @returns the number of pairs sent to the callback (plus initialCounter,
+     *        if you provided one). If the callback returned {break:R} then
+     *        the R value is returned instead. */
+    forEachPair(callback, initialCounter) {
+        var low = this.minKey(), high = this.maxKey();
+        return this.forRange(low, high, true, callback, initialCounter);
+    }
+    /**
+     * Finds a pair in the tree and returns the associated value.
+     * @param defaultValue a value to return if the key was not found.
+     * @returns the value, or defaultValue if the key was not found.
+     * @description Computational complexity: O(log size)
+     */
+    get(key, defaultValue) {
+        return this._root.get(key, defaultValue, this);
+    }
+    /**
+     * Adds or overwrites a key-value pair in the B+ tree.
+     * @param key the key is used to determine the sort order of
+     *        data in the tree.
+     * @param value data to associate with the key (optional)
+     * @param overwrite Whether to overwrite an existing key-value pair
+     *        (default: true). If this is false and there is an existing
+     *        key-value pair then this method has no effect.
+     * @returns true if a new key-value pair was added.
+     * @description Computational complexity: O(log size)
+     * Note: when overwriting a previous entry, the key is updated
+     * as well as the value. This has no effect unless the new key
+     * has data that does not affect its sort order.
+     */
+    set(key, value, overwrite) {
+        if (this._root.isShared)
+            this._root = this._root.clone();
+        var result = this._root.set(key, value, overwrite, this);
+        if (result === true || result === false)
+            return result;
+        // Root node has split, so create a new root node.
+        this._root = new BNodeInternal([this._root, result]);
+        return true;
+    }
+    /**
+     * Returns true if the key exists in the B+ tree, false if not.
+     * Use get() for best performance; use has() if you need to
+     * distinguish between "undefined value" and "key not present".
+     * @param key Key to detect
+     * @description Computational complexity: O(log size)
+     */
+    has(key) {
+        return this.forRange(key, key, true, undefined) !== 0;
+    }
+    /**
+     * Removes a single key-value pair from the B+ tree.
+     * @param key Key to find
+     * @returns true if a pair was found and removed, false otherwise.
+     * @description Computational complexity: O(log size)
+     */
+    delete(key) {
+        return this.editRange(key, key, true, DeleteRange) !== 0;
+    }
+    with(key, value, overwrite) {
+        let nu = this.clone();
+        return nu.set(key, value, overwrite) || overwrite ? nu : this;
+    }
+    /** Returns a copy of the tree with the specified key-value pairs set. */
+    withPairs(pairs, overwrite) {
+        let nu = this.clone();
+        return nu.setPairs(pairs, overwrite) !== 0 || overwrite ? nu : this;
+    }
+    /** Returns a copy of the tree with the specified keys present.
+     *  @param keys The keys to add. If a key is already present in the tree,
+     *         neither the existing key nor the existing value is modified.
+     *  @param returnThisIfUnchanged if true, returns this if all keys already
+     *  existed. Performance note: due to the architecture of this class, all
+     *  node(s) leading to existing keys are cloned even if the collection is
+     *  ultimately unchanged.
+    */
+    withKeys(keys, returnThisIfUnchanged) {
+        let nu = this.clone(), changed = false;
+        for (var i = 0; i < keys.length; i++)
+            changed = nu.set(keys[i], undefined, false) || changed;
+        return returnThisIfUnchanged && !changed ? this : nu;
+    }
+    /** Returns a copy of the tree with the specified key removed.
+     * @param returnThisIfUnchanged if true, returns this if the key didn't exist.
+     *  Performance note: due to the architecture of this class, node(s) leading
+     *  to where the key would have been stored are cloned even when the key
+     *  turns out not to exist and the collection is unchanged.
+     */
+    without(key, returnThisIfUnchanged) {
+        return this.withoutRange(key, key, true, returnThisIfUnchanged);
+    }
+    /** Returns a copy of the tree with the specified keys removed.
+     * @param returnThisIfUnchanged if true, returns this if none of the keys
+     *  existed. Performance note: due to the architecture of this class,
+     *  node(s) leading to where the key would have been stored are cloned
+     *  even when the key turns out not to exist.
+     */
+    withoutKeys(keys, returnThisIfUnchanged) {
+        let nu = this.clone();
+        return nu.deleteKeys(keys) || !returnThisIfUnchanged ? nu : this;
+    }
+    /** Returns a copy of the tree with the specified range of keys removed. */
+    withoutRange(low, high, includeHigh, returnThisIfUnchanged) {
+        let nu = this.clone();
+        if (nu.deleteRange(low, high, includeHigh) === 0 && returnThisIfUnchanged)
+            return this;
+        return nu;
+    }
+    /** Returns a copy of the tree with pairs removed whenever the callback
+     *  function returns false. `where()` is a synonym for this method. */
+    filter(callback, returnThisIfUnchanged) {
+        var nu = this.greedyClone();
+        var del;
+        nu.editAll((k, v, i) => {
+            if (!callback(k, v, i))
+                return del = Delete;
+        });
+        if (!del && returnThisIfUnchanged)
+            return this;
+        return nu;
+    }
+    /** Returns a copy of the tree with all values altered by a callback function. */
+    mapValues(callback) {
+        var tmp = {};
+        var nu = this.greedyClone();
+        nu.editAll((k, v, i) => {
+            return tmp.value = callback(v, k, i), tmp;
+        });
+        return nu;
+    }
+    reduce(callback, initialValue) {
+        let i = 0, p = initialValue;
+        var it = this.entries(this.minKey(), ReusedArray), next;
+        while (!(next = it.next()).done)
+            p = callback(p, next.value, i++, this);
+        return p;
+    }
+    /////////////////////////////////////////////////////////////////////////////
+    // Iterator methods /////////////////////////////////////////////////////////
+    /** Returns an iterator that provides items in order (ascending order if
+     *  the collection's comparator uses ascending order, as is the default.)
+     *  @param lowestKey First key to be iterated, or undefined to start at
+     *         minKey(). If the specified key doesn't exist then iteration
+     *         starts at the next higher key (according to the comparator).
+     *  @param reusedArray Optional array used repeatedly to store key-value
+     *         pairs, to avoid creating a new array on every iteration.
+     */
+    entries(lowestKey, reusedArray) {
+        var info = this.findPath(lowestKey);
+        if (info === undefined)
+            return iterator();
+        var { nodequeue, nodeindex, leaf } = info;
+        var state = reusedArray !== undefined ? 1 : 0;
+        var i = (lowestKey === undefined ? -1 : leaf.indexOf(lowestKey, 0, this._compare) - 1);
+        return iterator(() => {
+            jump: for (;;) {
+                switch (state) {
+                    case 0:
+                        if (++i < leaf.keys.length)
+                            return { done: false, value: [leaf.keys[i], leaf.values[i]] };
+                        state = 2;
+                        continue;
+                    case 1:
+                        if (++i < leaf.keys.length) {
+                            reusedArray[0] = leaf.keys[i], reusedArray[1] = leaf.values[i];
+                            return { done: false, value: reusedArray };
+                        }
+                        state = 2;
+                    case 2:
+                        // Advance to the next leaf node
+                        for (var level = -1;;) {
+                            if (++level >= nodequeue.length) {
+                                state = 3;
+                                continue jump;
+                            }
+                            if (++nodeindex[level] < nodequeue[level].length)
+                                break;
+                        }
+                        for (; level > 0; level--) {
+                            nodequeue[level - 1] = nodequeue[level][nodeindex[level]].children;
+                            nodeindex[level - 1] = 0;
+                        }
+                        leaf = nodequeue[0][nodeindex[0]];
+                        i = -1;
+                        state = reusedArray !== undefined ? 1 : 0;
+                        continue;
+                    case 3:
+                        return { done: true, value: undefined };
+                }
+            }
+        });
+    }
+    /** Returns an iterator that provides items in reversed order.
+     *  @param highestKey Key at which to start iterating, or undefined to
+     *         start at maxKey(). If the specified key doesn't exist then iteration
+     *         starts at the next lower key (according to the comparator).
+     *  @param reusedArray Optional array used repeatedly to store key-value
+     *         pairs, to avoid creating a new array on every iteration.
+     *  @param skipHighest Iff this flag is true and the highestKey exists in the
+     *         collection, the pair matching highestKey is skipped, not iterated.
+     */
+    entriesReversed(highestKey, reusedArray, skipHighest) {
+        if (highestKey === undefined) {
+            highestKey = this.maxKey();
+            skipHighest = undefined;
+            if (highestKey === undefined)
+                return iterator(); // collection is empty
+        }
+        var { nodequeue, nodeindex, leaf } = this.findPath(highestKey) || this.findPath(this.maxKey());
+        check(!nodequeue[0] || leaf === nodequeue[0][nodeindex[0]], "wat!");
+        var i = leaf.indexOf(highestKey, 0, this._compare);
+        if (!skipHighest && i < leaf.keys.length && this._compare(leaf.keys[i], highestKey) <= 0)
+            i++;
+        var state = reusedArray !== undefined ? 1 : 0;
+        return iterator(() => {
+            jump: for (;;) {
+                switch (state) {
+                    case 0:
+                        if (--i >= 0)
+                            return { done: false, value: [leaf.keys[i], leaf.values[i]] };
+                        state = 2;
+                        continue;
+                    case 1:
+                        if (--i >= 0) {
+                            reusedArray[0] = leaf.keys[i], reusedArray[1] = leaf.values[i];
+                            return { done: false, value: reusedArray };
+                        }
+                        state = 2;
+                    case 2:
+                        // Advance to the next leaf node
+                        for (var level = -1;;) {
+                            if (++level >= nodequeue.length) {
+                                state = 3;
+                                continue jump;
+                            }
+                            if (--nodeindex[level] >= 0)
+                                break;
+                        }
+                        for (; level > 0; level--) {
+                            nodequeue[level - 1] = nodequeue[level][nodeindex[level]].children;
+                            nodeindex[level - 1] = nodequeue[level - 1].length - 1;
+                        }
+                        leaf = nodequeue[0][nodeindex[0]];
+                        i = leaf.keys.length;
+                        state = reusedArray !== undefined ? 1 : 0;
+                        continue;
+                    case 3:
+                        return { done: true, value: undefined };
+                }
+            }
+        });
+    }
+    /* Used by entries() and entriesReversed() to prepare to start iterating.
+     * It develops a "node queue" for each non-leaf level of the tree.
+     * Levels are numbered "bottom-up" so that level 0 is a list of leaf
+     * nodes from a low-level non-leaf node. The queue at a given level L
+     * consists of nodequeue[L] which is the children of a BNodeInternal,
+     * and nodeindex[L], the current index within that child list, such
+     * such that nodequeue[L-1] === nodequeue[L][nodeindex[L]].children.
+     * (However inside this function the order is reversed.)
+     */
+    findPath(key) {
+        var nextnode = this._root;
+        var nodequeue, nodeindex;
+        if (nextnode.isLeaf) {
+            nodequeue = EmptyArray, nodeindex = EmptyArray; // avoid allocations
+        }
+        else {
+            nodequeue = [], nodeindex = [];
+            for (var d = 0; !nextnode.isLeaf; d++) {
+                nodequeue[d] = nextnode.children;
+                nodeindex[d] = key === undefined ? 0 : nextnode.indexOf(key, 0, this._compare);
+                if (nodeindex[d] >= nodequeue[d].length)
+                    return; // first key > maxKey()
+                nextnode = nodequeue[d][nodeindex[d]];
+            }
+            nodequeue.reverse();
+            nodeindex.reverse();
+        }
+        return { nodequeue, nodeindex, leaf: nextnode };
+    }
+    /**
+     * Computes the differences between `this` and `other`.
+     * For efficiency, the diff is returned via invocations of supplied handlers.
+     * The computation is optimized for the case in which the two trees have large amounts
+     * of shared data (obtained by calling the `clone` or `with` APIs) and will avoid
+     * any iteration of shared state.
+     * The handlers can cause computation to early exit by returning {break: R}.
+     * Neither of the collections should be changed during the comparison process (in your callbacks), as this method assumes they will not be mutated.
+     * @param other The tree to compute a diff against.
+     * @param onlyThis Callback invoked for all keys only present in `this`.
+     * @param onlyOther Callback invoked for all keys only present in `other`.
+     * @param different Callback invoked for all keys with differing values.
+     */
+    diffAgainst(other, onlyThis, onlyOther, different) {
+        if (other._compare !== this._compare) {
+            throw new Error("Tree comparators are not the same.");
+        }
+        if (this.isEmpty || other.isEmpty) {
+            if (this.isEmpty && other.isEmpty)
+                return undefined;
+            // If one tree is empty, everything will be an onlyThis/onlyOther.
+            if (this.isEmpty)
+                return onlyOther === undefined ? undefined : BTree.stepToEnd(BTree.makeDiffCursor(other), onlyOther);
+            return onlyThis === undefined ? undefined : BTree.stepToEnd(BTree.makeDiffCursor(this), onlyThis);
+        }
+        // Cursor-based diff algorithm is as follows:
+        // - Until neither cursor has navigated to the end of the tree, do the following:
+        //  - If the `this` cursor is "behind" the `other` cursor (strictly <, via compare), advance it.
+        //  - Otherwise, advance the `other` cursor.
+        //  - Any time a cursor is stepped, perform the following:
+        //    - If either cursor points to a key/value pair:
+        //      - If thisCursor === otherCursor and the values differ, it is a Different.
+        //      - If thisCursor > otherCursor and otherCursor is at a key/value pair, it is an OnlyOther.
+        //      - If thisCursor < otherCursor and thisCursor is at a key/value pair, it is an OnlyThis as long as the most recent
+        //        cursor step was *not* otherCursor advancing from a tie. The extra condition avoids erroneous OnlyOther calls
+        //        that would occur due to otherCursor being the "leader".
+        //    - Otherwise, if both cursors point to nodes, compare them. If they are equal by reference (shared), skip
+        //      both cursors to the next node in the walk.
+        // - Once one cursor has finished stepping, any remaining steps (if any) are taken and key/value pairs are logged
+        //   as OnlyOther (if otherCursor is stepping) or OnlyThis (if thisCursor is stepping).
+        // This algorithm gives the critical guarantee that all locations (both nodes and key/value pairs) in both trees that
+        // are identical by value (and possibly by reference) will be visited *at the same time* by the cursors.
+        // This removes the possibility of emitting incorrect diffs, as well as allowing for skipping shared nodes.
+        const { _compare } = this;
+        const thisCursor = BTree.makeDiffCursor(this);
+        const otherCursor = BTree.makeDiffCursor(other);
+        // It doesn't matter how thisSteppedLast is initialized.
+        // Step order is only used when either cursor is at a leaf, and cursors always start at a node.
+        let thisSuccess = true, otherSuccess = true, prevCursorOrder = BTree.compare(thisCursor, otherCursor, _compare);
+        while (thisSuccess && otherSuccess) {
+            const cursorOrder = BTree.compare(thisCursor, otherCursor, _compare);
+            const { leaf: thisLeaf, internalSpine: thisInternalSpine, levelIndices: thisLevelIndices } = thisCursor;
+            const { leaf: otherLeaf, internalSpine: otherInternalSpine, levelIndices: otherLevelIndices } = otherCursor;
+            if (thisLeaf || otherLeaf) {
+                // If the cursors were at the same location last step, then there is no work to be done.
+                if (prevCursorOrder !== 0) {
+                    if (cursorOrder === 0) {
+                        if (thisLeaf && otherLeaf && different) {
+                            // Equal keys, check for modifications
+                            const valThis = thisLeaf.values[thisLevelIndices[thisLevelIndices.length - 1]];
+                            const valOther = otherLeaf.values[otherLevelIndices[otherLevelIndices.length - 1]];
+                            if (!Object.is(valThis, valOther)) {
+                                const result = different(thisCursor.currentKey, valThis, valOther);
+                                if (result && result.break)
+                                    return result.break;
+                            }
+                        }
+                    }
+                    else if (cursorOrder > 0) {
+                        // If this is the case, we know that either:
+                        // 1. otherCursor stepped last from a starting position that trailed thisCursor, and is still behind, or
+                        // 2. thisCursor stepped last and leapfrogged otherCursor
+                        // Either of these cases is an "only other"
+                        if (otherLeaf && onlyOther) {
+                            const otherVal = otherLeaf.values[otherLevelIndices[otherLevelIndices.length - 1]];
+                            const result = onlyOther(otherCursor.currentKey, otherVal);
+                            if (result && result.break)
+                                return result.break;
+                        }
+                    }
+                    else if (onlyThis) {
+                        if (thisLeaf && prevCursorOrder !== 0) {
+                            const valThis = thisLeaf.values[thisLevelIndices[thisLevelIndices.length - 1]];
+                            const result = onlyThis(thisCursor.currentKey, valThis);
+                            if (result && result.break)
+                                return result.break;
+                        }
+                    }
+                }
+            }
+            else if (!thisLeaf && !otherLeaf && cursorOrder === 0) {
+                const lastThis = thisInternalSpine.length - 1;
+                const lastOther = otherInternalSpine.length - 1;
+                const nodeThis = thisInternalSpine[lastThis][thisLevelIndices[lastThis]];
+                const nodeOther = otherInternalSpine[lastOther][otherLevelIndices[lastOther]];
+                if (nodeOther === nodeThis) {
+                    prevCursorOrder = 0;
+                    thisSuccess = BTree.step(thisCursor, true);
+                    otherSuccess = BTree.step(otherCursor, true);
+                    continue;
+                }
+            }
+            prevCursorOrder = cursorOrder;
+            if (cursorOrder < 0) {
+                thisSuccess = BTree.step(thisCursor);
+            }
+            else {
+                otherSuccess = BTree.step(otherCursor);
+            }
+        }
+        if (thisSuccess && onlyThis)
+            return BTree.finishCursorWalk(thisCursor, otherCursor, _compare, onlyThis);
+        if (otherSuccess && onlyOther)
+            return BTree.finishCursorWalk(otherCursor, thisCursor, _compare, onlyOther);
+    }
+    ///////////////////////////////////////////////////////////////////////////
+    // Helper methods for diffAgainst /////////////////////////////////////////
+    static finishCursorWalk(cursor, cursorFinished, compareKeys, callback) {
+        const compared = BTree.compare(cursor, cursorFinished, compareKeys);
+        if (compared === 0) {
+            if (!BTree.step(cursor))
+                return undefined;
+        }
+        else if (compared < 0) {
+            check(false, "cursor walk terminated early");
+        }
+        return BTree.stepToEnd(cursor, callback);
+    }
+    static stepToEnd(cursor, callback) {
+        let canStep = true;
+        while (canStep) {
+            const { leaf, levelIndices, currentKey } = cursor;
+            if (leaf) {
+                const value = leaf.values[levelIndices[levelIndices.length - 1]];
+                const result = callback(currentKey, value);
+                if (result && result.break)
+                    return result.break;
+            }
+            canStep = BTree.step(cursor);
+        }
+        return undefined;
+    }
+    static makeDiffCursor(tree) {
+        const { _root, height } = tree;
+        return { height: height, internalSpine: [[_root]], levelIndices: [0], leaf: undefined, currentKey: _root.maxKey() };
+    }
+    /**
+     * Advances the cursor to the next step in the walk of its tree.
+     * Cursors are walked backwards in sort order, as this allows them to leverage maxKey() in order to be compared in O(1).
+     * @param cursor The cursor to step
+     * @param stepToNode If true, the cursor will be advanced to the next node (skipping values)
+     * @returns true if the step was completed and false if the step would have caused the cursor to move beyond the end of the tree.
+     */
+    static step(cursor, stepToNode) {
+        const { internalSpine, levelIndices, leaf } = cursor;
+        if (stepToNode === true || leaf) {
+            const levelsLength = levelIndices.length;
+            // Step to the next node only if:
+            // - We are explicitly directed to via stepToNode, or
+            // - There are no key/value pairs left to step to in this leaf
+            if (stepToNode === true || levelIndices[levelsLength - 1] === 0) {
+                const spineLength = internalSpine.length;
+                // Root is leaf
+                if (spineLength === 0)
+                    return false;
+                // Walk back up the tree until we find a new subtree to descend into
+                const nodeLevelIndex = spineLength - 1;
+                let levelIndexWalkBack = nodeLevelIndex;
+                while (levelIndexWalkBack >= 0) {
+                    if (levelIndices[levelIndexWalkBack] > 0) {
+                        if (levelIndexWalkBack < levelsLength - 1) {
+                            // Remove leaf state from cursor
+                            cursor.leaf = undefined;
+                            levelIndices.pop();
+                        }
+                        // If we walked upwards past any internal node, slice them out
+                        if (levelIndexWalkBack < nodeLevelIndex)
+                            cursor.internalSpine = internalSpine.slice(0, levelIndexWalkBack + 1);
+                        // Move to new internal node
+                        cursor.currentKey = internalSpine[levelIndexWalkBack][--levelIndices[levelIndexWalkBack]].maxKey();
+                        return true;
+                    }
+                    levelIndexWalkBack--;
+                }
+                // Cursor is in the far left leaf of the tree, no more nodes to enumerate
+                return false;
+            }
+            else {
+                // Move to new leaf value
+                const valueIndex = --levelIndices[levelsLength - 1];
+                cursor.currentKey = leaf.keys[valueIndex];
+                return true;
+            }
+        }
+        else { // Cursor does not point to a value in a leaf, so move downwards
+            const nextLevel = internalSpine.length;
+            const currentLevel = nextLevel - 1;
+            const node = internalSpine[currentLevel][levelIndices[currentLevel]];
+            if (node.isLeaf) {
+                // Entering into a leaf. Set the cursor to point at the last key/value pair.
+                cursor.leaf = node;
+                const valueIndex = levelIndices[nextLevel] = node.values.length - 1;
+                cursor.currentKey = node.keys[valueIndex];
+            }
+            else {
+                const children = node.children;
+                internalSpine[nextLevel] = children;
+                const childIndex = children.length - 1;
+                levelIndices[nextLevel] = childIndex;
+                cursor.currentKey = children[childIndex].maxKey();
+            }
+            return true;
+        }
+    }
+    /**
+     * Compares the two cursors. Returns a value indicating which cursor is ahead in a walk.
+     * Note that cursors are advanced in reverse sorting order.
+     */
+    static compare(cursorA, cursorB, compareKeys) {
+        const { height: heightA, currentKey: currentKeyA, levelIndices: levelIndicesA } = cursorA;
+        const { height: heightB, currentKey: currentKeyB, levelIndices: levelIndicesB } = cursorB;
+        // Reverse the comparison order, as cursors are advanced in reverse sorting order
+        const keyComparison = compareKeys(currentKeyB, currentKeyA);
+        if (keyComparison !== 0) {
+            return keyComparison;
+        }
+        // Normalize depth values relative to the shortest tree.
+        // This ensures that concurrent cursor walks of trees of differing heights can reliably land on shared nodes at the same time.
+        // To accomplish this, a cursor that is on an internal node at depth D1 with maxKey X is considered "behind" a cursor on an
+        // internal node at depth D2 with maxKey Y, when D1 < D2. Thus, always walking the cursor that is "behind" will allow the cursor
+        // at shallower depth (but equal maxKey) to "catch up" and land on shared nodes.
+        const heightMin = heightA < heightB ? heightA : heightB;
+        const depthANormalized = levelIndicesA.length - (heightA - heightMin);
+        const depthBNormalized = levelIndicesB.length - (heightB - heightMin);
+        return depthANormalized - depthBNormalized;
+    }
+    // End of helper methods for diffAgainst //////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////////
+    /** Returns a new iterator for iterating the keys of each pair in ascending order.
+     *  @param firstKey: Minimum key to include in the output. */
+    keys(firstKey) {
+        var it = this.entries(firstKey, ReusedArray);
+        return iterator(() => {
+            var n = it.next();
+            if (n.value)
+                n.value = n.value[0];
+            return n;
+        });
+    }
+    /** Returns a new iterator for iterating the values of each pair in order by key.
+     *  @param firstKey: Minimum key whose associated value is included in the output. */
+    values(firstKey) {
+        var it = this.entries(firstKey, ReusedArray);
+        return iterator(() => {
+            var n = it.next();
+            if (n.value)
+                n.value = n.value[1];
+            return n;
+        });
+    }
+    /////////////////////////////////////////////////////////////////////////////
+    // Additional methods ///////////////////////////////////////////////////////
+    /** Returns the maximum number of children/values before nodes will split. */
+    get maxNodeSize() {
+        return this._maxNodeSize;
+    }
+    /** Gets the lowest key in the tree. Complexity: O(log size) */
+    minKey() { return this._root.minKey(); }
+    /** Gets the highest key in the tree. Complexity: O(1) */
+    maxKey() { return this._root.maxKey(); }
+    /** Quickly clones the tree by marking the root node as shared.
+     *  Both copies remain editable. When you modify either copy, any
+     *  nodes that are shared (or potentially shared) between the two
+     *  copies are cloned so that the changes do not affect other copies.
+     *  This is known as copy-on-write behavior, or "lazy copying". */
+    clone() {
+        this._root.isShared = true;
+        var result = new BTree(undefined, this._compare, this._maxNodeSize);
+        result._root = this._root;
+        result._size = this._size;
+        return result;
+    }
+    /** Performs a greedy clone, immediately duplicating any nodes that are
+     *  not currently marked as shared, in order to avoid marking any
+     *  additional nodes as shared.
+     *  @param force Clone all nodes, even shared ones.
+     */
+    greedyClone(force) {
+        var result = new BTree(undefined, this._compare, this._maxNodeSize);
+        result._root = this._root.greedyClone(force);
+        result._size = this._size;
+        return result;
+    }
+    /** Gets an array filled with the contents of the tree, sorted by key */
+    toArray(maxLength = 0x7FFFFFFF) {
+        let min = this.minKey(), max = this.maxKey();
+        if (min !== undefined)
+            return this.getRange(min, max, true, maxLength);
+        return [];
+    }
+    /** Gets an array of all keys, sorted */
+    keysArray() {
+        var results = [];
+        this._root.forRange(this.minKey(), this.maxKey(), true, false, this, 0, (k, v) => { results.push(k); });
+        return results;
+    }
+    /** Gets an array of all values, sorted by key */
+    valuesArray() {
+        var results = [];
+        this._root.forRange(this.minKey(), this.maxKey(), true, false, this, 0, (k, v) => { results.push(v); });
+        return results;
+    }
+    /** Gets a string representing the tree's data based on toArray(). */
+    toString() {
+        return this.toArray().toString();
+    }
+    /** Stores a key-value pair only if the key doesn't already exist in the tree.
+     * @returns true if a new key was added
+    */
+    setIfNotPresent(key, value) {
+        return this.set(key, value, false);
+    }
+    /** Returns the next pair whose key is larger than the specified key (or undefined if there is none).
+     * If key === undefined, this function returns the lowest pair.
+     * @param key The key to search for.
+     * @param reusedArray Optional array used repeatedly to store key-value pairs, to
+     * avoid creating a new array on every iteration.
+     */
+    nextHigherPair(key, reusedArray) {
+        reusedArray = reusedArray || [];
+        if (key === undefined) {
+            return this._root.minPair(reusedArray);
+        }
+        return this._root.getPairOrNextHigher(key, this._compare, false, reusedArray);
+    }
+    /** Returns the next key larger than the specified key, or undefined if there is none.
+     *  Also, nextHigherKey(undefined) returns the lowest key.
+     */
+    nextHigherKey(key) {
+        var p = this.nextHigherPair(key, ReusedArray);
+        return p && p[0];
+    }
+    /** Returns the next pair whose key is smaller than the specified key (or undefined if there is none).
+     *  If key === undefined, this function returns the highest pair.
+     * @param key The key to search for.
+     * @param reusedArray Optional array used repeatedly to store key-value pairs, to
+     *        avoid creating a new array each time you call this method.
+     */
+    nextLowerPair(key, reusedArray) {
+        reusedArray = reusedArray || [];
+        if (key === undefined) {
+            return this._root.maxPair(reusedArray);
+        }
+        return this._root.getPairOrNextLower(key, this._compare, false, reusedArray);
+    }
+    /** Returns the next key smaller than the specified key, or undefined if there is none.
+     *  Also, nextLowerKey(undefined) returns the highest key.
+     */
+    nextLowerKey(key) {
+        var p = this.nextLowerPair(key, ReusedArray);
+        return p && p[0];
+    }
+    /** Returns the key-value pair associated with the supplied key if it exists
+     *  or the pair associated with the next lower pair otherwise. If there is no
+     *  next lower pair, undefined is returned.
+     * @param key The key to search for.
+     * @param reusedArray Optional array used repeatedly to store key-value pairs, to
+     *        avoid creating a new array each time you call this method.
+     * */
+    getPairOrNextLower(key, reusedArray) {
+        return this._root.getPairOrNextLower(key, this._compare, true, reusedArray || []);
+    }
+    /** Returns the key-value pair associated with the supplied key if it exists
+     *  or the pair associated with the next lower pair otherwise. If there is no
+     *  next lower pair, undefined is returned.
+     * @param key The key to search for.
+     * @param reusedArray Optional array used repeatedly to store key-value pairs, to
+     *        avoid creating a new array each time you call this method.
+     * */
+    getPairOrNextHigher(key, reusedArray) {
+        return this._root.getPairOrNextHigher(key, this._compare, true, reusedArray || []);
+    }
+    /** Edits the value associated with a key in the tree, if it already exists.
+     * @returns true if the key existed, false if not.
+    */
+    changeIfPresent(key, value) {
+        return this.editRange(key, key, true, (k, v) => ({ value })) !== 0;
+    }
+    /**
+     * Builds an array of pairs from the specified range of keys, sorted by key.
+     * Each returned pair is also an array: pair[0] is the key, pair[1] is the value.
+     * @param low The first key in the array will be greater than or equal to `low`.
+     * @param high This method returns when a key larger than this is reached.
+     * @param includeHigh If the `high` key is present, its pair will be included
+     *        in the output if and only if this parameter is true. Note: if the
+     *        `low` key is present, it is always included in the output.
+     * @param maxLength Length limit. getRange will stop scanning the tree when
+     *                  the array reaches this size.
+     * @description Computational complexity: O(result.length + log size)
+     */
+    getRange(low, high, includeHigh, maxLength = 0x3FFFFFF) {
+        var results = [];
+        this._root.forRange(low, high, includeHigh, false, this, 0, (k, v) => {
+            results.push([k, v]);
+            return results.length > maxLength ? Break : undefined;
+        });
+        return results;
+    }
+    /** Adds all pairs from a list of key-value pairs.
+     * @param pairs Pairs to add to this tree. If there are duplicate keys,
+     *        later pairs currently overwrite earlier ones (e.g. [[0,1],[0,7]]
+     *        associates 0 with 7.)
+     * @param overwrite Whether to overwrite pairs that already exist (if false,
+     *        pairs[i] is ignored when the key pairs[i][0] already exists.)
+     * @returns The number of pairs added to the collection.
+     * @description Computational complexity: O(pairs.length * log(size + pairs.length))
+     */
+    setPairs(pairs, overwrite) {
+        var added = 0;
+        for (var i = 0; i < pairs.length; i++)
+            if (this.set(pairs[i][0], pairs[i][1], overwrite))
+                added++;
+        return added;
+    }
+    /**
+     * Scans the specified range of keys, in ascending order by key.
+     * Note: the callback `onFound` must not insert or remove items in the
+     * collection. Doing so may cause incorrect data to be sent to the
+     * callback afterward.
+     * @param low The first key scanned will be greater than or equal to `low`.
+     * @param high Scanning stops when a key larger than this is reached.
+     * @param includeHigh If the `high` key is present, `onFound` is called for
+     *        that final pair if and only if this parameter is true.
+     * @param onFound A function that is called for each key-value pair. This
+     *        function can return {break:R} to stop early with result R.
+     * @param initialCounter Initial third argument of onFound. This value
+     *        increases by one each time `onFound` is called. Default: 0
+     * @returns The number of values found, or R if the callback returned
+     *        `{break:R}` to stop early.
+     * @description Computational complexity: O(number of items scanned + log size)
+     */
+    forRange(low, high, includeHigh, onFound, initialCounter) {
+        var r = this._root.forRange(low, high, includeHigh, false, this, initialCounter || 0, onFound);
+        return typeof r === "number" ? r : r.break;
+    }
+    /**
+     * Scans and potentially modifies values for a subsequence of keys.
+     * Note: the callback `onFound` should ideally be a pure function.
+     *   Specfically, it must not insert items, call clone(), or change
+     *   the collection except via return value; out-of-band editing may
+     *   cause an exception or may cause incorrect data to be sent to
+     *   the callback (duplicate or missed items). It must not cause a
+     *   clone() of the collection, otherwise the clone could be modified
+     *   by changes requested by the callback.
+     * @param low The first key scanned will be greater than or equal to `low`.
+     * @param high Scanning stops when a key larger than this is reached.
+     * @param includeHigh If the `high` key is present, `onFound` is called for
+     *        that final pair if and only if this parameter is true.
+     * @param onFound A function that is called for each key-value pair. This
+     *        function can return `{value:v}` to change the value associated
+     *        with the current key, `{delete:true}` to delete the current pair,
+     *        `{break:R}` to stop early with result R, or it can return nothing
+     *        (undefined or {}) to cause no effect and continue iterating.
+     *        `{break:R}` can be combined with one of the other two commands.
+     *        The third argument `counter` is the number of items iterated
+     *        previously; it equals 0 when `onFound` is called the first time.
+     * @returns The number of values scanned, or R if the callback returned
+     *        `{break:R}` to stop early.
+     * @description
+     *   Computational complexity: O(number of items scanned + log size)
+     *   Note: if the tree has been cloned with clone(), any shared
+     *   nodes are copied before `onFound` is called. This takes O(n) time
+     *   where n is proportional to the amount of shared data scanned.
+     */
+    editRange(low, high, includeHigh, onFound, initialCounter) {
+        var root = this._root;
+        if (root.isShared)
+            this._root = root = root.clone();
+        try {
+            var r = root.forRange(low, high, includeHigh, true, this, initialCounter || 0, onFound);
+            return typeof r === "number" ? r : r.break;
+        }
+        finally {
+            let isShared;
+            while (root.keys.length <= 1 && !root.isLeaf) {
+                isShared || (isShared = root.isShared);
+                this._root = root = root.keys.length === 0 ? EmptyLeaf :
+                    root.children[0];
+            }
+            // If any ancestor of the new root was shared, the new root must also be shared
+            if (isShared) {
+                root.isShared = true;
+            }
+        }
+    }
+    /** Same as `editRange` except that the callback is called for all pairs. */
+    editAll(onFound, initialCounter) {
+        return this.editRange(this.minKey(), this.maxKey(), true, onFound, initialCounter);
+    }
+    /**
+     * Removes a range of key-value pairs from the B+ tree.
+     * @param low The first key scanned will be greater than or equal to `low`.
+     * @param high Scanning stops when a key larger than this is reached.
+     * @param includeHigh Specifies whether the `high` key, if present, is deleted.
+     * @returns The number of key-value pairs that were deleted.
+     * @description Computational complexity: O(log size + number of items deleted)
+     */
+    deleteRange(low, high, includeHigh) {
+        return this.editRange(low, high, includeHigh, DeleteRange);
+    }
+    /** Deletes a series of keys from the collection. */
+    deleteKeys(keys) {
+        for (var i = 0, r = 0; i < keys.length; i++)
+            if (this.delete(keys[i]))
+                r++;
+        return r;
+    }
+    /** Gets the height of the tree: the number of internal nodes between the
+     *  BTree object and its leaf nodes (zero if there are no internal nodes). */
+    get height() {
+        let node = this._root;
+        let height = -1;
+        while (node) {
+            height++;
+            node = node.isLeaf ? undefined : node.children[0];
+        }
+        return height;
+    }
+    /** Makes the object read-only to ensure it is not accidentally modified.
+     *  Freezing does not have to be permanent; unfreeze() reverses the effect.
+     *  This is accomplished by replacing mutator functions with a function
+     *  that throws an Error. Compared to using a property (e.g. this.isFrozen)
+     *  this implementation gives better performance in non-frozen BTrees.
+     */
+    freeze() {
+        var t = this;
+        // Note: all other mutators ultimately call set() or editRange()
+        //       so we don't need to override those others.
+        t.clear = t.set = t.editRange = function () {
+            throw new Error("Attempted to modify a frozen BTree");
+        };
+    }
+    /** Ensures mutations are allowed, reversing the effect of freeze(). */
+    unfreeze() {
+        // @ts-ignore "The operand of a 'delete' operator must be optional."
+        //            (wrong: delete does not affect the prototype.)
+        delete this.clear;
+        // @ts-ignore
+        delete this.set;
+        // @ts-ignore
+        delete this.editRange;
+    }
+    /** Returns true if the tree appears to be frozen. */
+    get isFrozen() {
+        return this.hasOwnProperty('editRange');
+    }
+    /** Scans the tree for signs of serious bugs (e.g. this.size doesn't match
+     *  number of elements, internal nodes not caching max element properly...)
+     *  Computational complexity: O(number of nodes), i.e. O(size). This method
+     *  skips the most expensive test - whether all keys are sorted - but it
+     *  does check that maxKey() of the children of internal nodes are sorted. */
+    checkValid() {
+        var size = this._root.checkValid(0, this, 0);
+        check(size === this.size, "size mismatch: counted ", size, "but stored", this.size);
+    }
+}
+exports.BTree = BTree;
+/** A TypeScript helper function that simply returns its argument, typed as
+ *  `ISortedSet<K>` if the BTree implements it, as it does if `V extends undefined`.
+ *  If `V` cannot be `undefined`, it returns `unknown` instead. Or at least, that
+ *  was the intention, but TypeScript is acting weird and may return `ISortedSet<K>`
+ *  even if `V` can't be `undefined` (discussion: btree-typescript issue #14) */
+function asSet(btree) {
+    return btree;
+}
+exports.asSet = asSet;
+if (Symbol && Symbol.iterator) // iterator is equivalent to entries()
+    BTree.prototype[Symbol.iterator] = BTree.prototype.entries;
+BTree.prototype.where = BTree.prototype.filter;
+BTree.prototype.setRange = BTree.prototype.setPairs;
+BTree.prototype.add = BTree.prototype.set; // for compatibility with ISetSink<K>
+function iterator(next = (() => ({ done: true, value: undefined }))) {
+    var result = { next };
+    if (Symbol && Symbol.iterator)
+        result[Symbol.iterator] = function () { return this; };
+    return result;
+}
+/** Leaf node / base class. **************************************************/
+class BNode {
+    get isLeaf() { return this.children === undefined; }
+    constructor(keys = [], values) {
+        this.keys = keys;
+        this.values = values || undefVals;
+        this.isShared = undefined;
+    }
+    ///////////////////////////////////////////////////////////////////////////
+    // Shared methods /////////////////////////////////////////////////////////
+    maxKey() {
+        return this.keys[this.keys.length - 1];
+    }
+    // If key not found, returns i^failXor where i is the insertion index.
+    // Callers that don't care whether there was a match will set failXor=0.
+    indexOf(key, failXor, cmp) {
+        const keys = this.keys;
+        var lo = 0, hi = keys.length, mid = hi >> 1;
+        while (lo < hi) {
+            var c = cmp(keys[mid], key);
+            if (c < 0)
+                lo = mid + 1;
+            else if (c > 0) // key < keys[mid]
+                hi = mid;
+            else if (c === 0)
+                return mid;
+            else {
+                // c is NaN or otherwise invalid
+                if (key === key) // at least the search key is not NaN
+                    return keys.length;
+                else
+                    throw new Error("BTree: NaN was used as a key");
+            }
+            mid = (lo + hi) >> 1;
+        }
+        return mid ^ failXor;
+        // Unrolled version: benchmarks show same speed, not worth using
+        /*var i = 1, c: number = 0, sum = 0;
+        if (keys.length >= 4) {
+          i = 3;
+          if (keys.length >= 8) {
+            i = 7;
+            if (keys.length >= 16) {
+              i = 15;
+              if (keys.length >= 32) {
+                i = 31;
+                if (keys.length >= 64) {
+                  i = 127;
+                  i += (c = i < keys.length ? cmp(keys[i], key) : 1) < 0 ? 64 : -64;
+                  sum += c;
+                  i += (c = i < keys.length ? cmp(keys[i], key) : 1) < 0 ? 32 : -32;
+                  sum += c;
+                }
+                i += (c = i < keys.length ? cmp(keys[i], key) : 1) < 0 ? 16 : -16;
+                sum += c;
+              }
+              i += (c = i < keys.length ? cmp(keys[i], key) : 1) < 0 ? 8 : -8;
+              sum += c;
+            }
+            i += (c = i < keys.length ? cmp(keys[i], key) : 1) < 0 ? 4 : -4;
+            sum += c;
+          }
+          i += (c = i < keys.length ? cmp(keys[i], key) : 1) < 0 ? 2 : -2;
+          sum += c;
+        }
+        i += (c = i < keys.length ? cmp(keys[i], key) : 1) < 0 ? 1 : -1;
+        c = i < keys.length ? cmp(keys[i], key) : 1;
+        sum += c;
+        if (c < 0) {
+          ++i;
+          c = i < keys.length ? cmp(keys[i], key) : 1;
+          sum += c;
+        }
+        if (sum !== sum) {
+          if (key === key) // at least the search key is not NaN
+            return keys.length ^ failXor;
+          else
+            throw new Error("BTree: NaN was used as a key");
+        }
+        return c === 0 ? i : i ^ failXor;*/
+    }
+    /////////////////////////////////////////////////////////////////////////////
+    // Leaf Node: misc //////////////////////////////////////////////////////////
+    minKey() {
+        return this.keys[0];
+    }
+    minPair(reusedArray) {
+        if (this.keys.length === 0)
+            return undefined;
+        reusedArray[0] = this.keys[0];
+        reusedArray[1] = this.values[0];
+        return reusedArray;
+    }
+    maxPair(reusedArray) {
+        if (this.keys.length === 0)
+            return undefined;
+        const lastIndex = this.keys.length - 1;
+        reusedArray[0] = this.keys[lastIndex];
+        reusedArray[1] = this.values[lastIndex];
+        return reusedArray;
+    }
+    clone() {
+        var v = this.values;
+        return new BNode(this.keys.slice(0), v === undefVals ? v : v.slice(0));
+    }
+    greedyClone(force) {
+        return this.isShared && !force ? this : this.clone();
+    }
+    get(key, defaultValue, tree) {
+        var i = this.indexOf(key, -1, tree._compare);
+        return i < 0 ? defaultValue : this.values[i];
+    }
+    getPairOrNextLower(key, compare, inclusive, reusedArray) {
+        var i = this.indexOf(key, -1, compare);
+        const indexOrLower = i < 0 ? ~i - 1 : (inclusive ? i : i - 1);
+        if (indexOrLower >= 0) {
+            reusedArray[0] = this.keys[indexOrLower];
+            reusedArray[1] = this.values[indexOrLower];
+            return reusedArray;
+        }
+        return undefined;
+    }
+    getPairOrNextHigher(key, compare, inclusive, reusedArray) {
+        var i = this.indexOf(key, -1, compare);
+        const indexOrLower = i < 0 ? ~i : (inclusive ? i : i + 1);
+        const keys = this.keys;
+        if (indexOrLower < keys.length) {
+            reusedArray[0] = keys[indexOrLower];
+            reusedArray[1] = this.values[indexOrLower];
+            return reusedArray;
+        }
+        return undefined;
+    }
+    checkValid(depth, tree, baseIndex) {
+        var kL = this.keys.length, vL = this.values.length;
+        check(this.values === undefVals ? kL <= vL : kL === vL, "keys/values length mismatch: depth", depth, "with lengths", kL, vL, "and baseIndex", baseIndex);
+        // Note: we don't check for "node too small" because sometimes a node
+        // can legitimately have size 1. This occurs if there is a batch
+        // deletion, leaving a node of size 1, and the siblings are full so
+        // it can't be merged with adjacent nodes. However, the parent will
+        // verify that the average node size is at least half of the maximum.
+        check(depth == 0 || kL > 0, "empty leaf at depth", depth, "and baseIndex", baseIndex);
+        return kL;
+    }
+    /////////////////////////////////////////////////////////////////////////////
+    // Leaf Node: set & node splitting //////////////////////////////////////////
+    set(key, value, overwrite, tree) {
+        var i = this.indexOf(key, -1, tree._compare);
+        if (i < 0) {
+            // key does not exist yet
+            i = ~i;
+            tree._size++;
+            if (this.keys.length < tree._maxNodeSize) {
+                return this.insertInLeaf(i, key, value, tree);
+            }
+            else {
+                // This leaf node is full and must split
+                var newRightSibling = this.splitOffRightSide(), target = this;
+                if (i > this.keys.length) {
+                    i -= this.keys.length;
+                    target = newRightSibling;
+                }
+                target.insertInLeaf(i, key, value, tree);
+                return newRightSibling;
+            }
+        }
+        else {
+            // Key already exists
+            if (overwrite !== false) {
+                if (value !== undefined)
+                    this.reifyValues();
+                // usually this is a no-op, but some users may wish to edit the key
+                this.keys[i] = key;
+                this.values[i] = value;
+            }
+            return false;
+        }
+    }
+    reifyValues() {
+        if (this.values === undefVals)
+            return this.values = this.values.slice(0, this.keys.length);
+        return this.values;
+    }
+    insertInLeaf(i, key, value, tree) {
+        this.keys.splice(i, 0, key);
+        if (this.values === undefVals) {
+            while (undefVals.length < tree._maxNodeSize)
+                undefVals.push(undefined);
+            if (value === undefined) {
+                return true;
+            }
+            else {
+                this.values = undefVals.slice(0, this.keys.length - 1);
+            }
+        }
+        this.values.splice(i, 0, value);
+        return true;
+    }
+    takeFromRight(rhs) {
+        // Reminder: parent node must update its copy of key for this node
+        // assert: neither node is shared
+        // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)
+        var v = this.values;
+        if (rhs.values === undefVals) {
+            if (v !== undefVals)
+                v.push(undefined);
+        }
+        else {
+            v = this.reifyValues();
+            v.push(rhs.values.shift());
+        }
+        this.keys.push(rhs.keys.shift());
+    }
+    takeFromLeft(lhs) {
+        // Reminder: parent node must update its copy of key for this node
+        // assert: neither node is shared
+        // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)
+        var v = this.values;
+        if (lhs.values === undefVals) {
+            if (v !== undefVals)
+                v.unshift(undefined);
+        }
+        else {
+            v = this.reifyValues();
+            v.unshift(lhs.values.pop());
+        }
+        this.keys.unshift(lhs.keys.pop());
+    }
+    splitOffRightSide() {
+        // Reminder: parent node must update its copy of key for this node
+        var half = this.keys.length >> 1, keys = this.keys.splice(half);
+        var values = this.values === undefVals ? undefVals : this.values.splice(half);
+        return new BNode(keys, values);
+    }
+    /////////////////////////////////////////////////////////////////////////////
+    // Leaf Node: scanning & deletions //////////////////////////////////////////
+    forRange(low, high, includeHigh, editMode, tree, count, onFound) {
+        var cmp = tree._compare;
+        var iLow, iHigh;
+        if (high === low) {
+            if (!includeHigh)
+                return count;
+            iHigh = (iLow = this.indexOf(low, -1, cmp)) + 1;
+            if (iLow < 0)
+                return count;
+        }
+        else {
+            iLow = this.indexOf(low, 0, cmp);
+            iHigh = this.indexOf(high, -1, cmp);
+            if (iHigh < 0)
+                iHigh = ~iHigh;
+            else if (includeHigh === true)
+                iHigh++;
+        }
+        var keys = this.keys, values = this.values;
+        if (onFound !== undefined) {
+            for (var i = iLow; i < iHigh; i++) {
+                var key = keys[i];
+                var result = onFound(key, values[i], count++);
+                if (result !== undefined) {
+                    if (editMode === true) {
+                        if (key !== keys[i] || this.isShared === true)
+                            throw new Error("BTree illegally changed or cloned in editRange");
+                        if (result.delete) {
+                            this.keys.splice(i, 1);
+                            if (this.values !== undefVals)
+                                this.values.splice(i, 1);
+                            tree._size--;
+                            i--;
+                            iHigh--;
+                        }
+                        else if (result.hasOwnProperty('value')) {
+                            values[i] = result.value;
+                        }
+                    }
+                    if (result.break !== undefined)
+                        return result;
+                }
+            }
+        }
+        else
+            count += iHigh - iLow;
+        return count;
+    }
+    /** Adds entire contents of right-hand sibling (rhs is left unchanged) */
+    mergeSibling(rhs, _) {
+        this.keys.push.apply(this.keys, rhs.keys);
+        if (this.values === undefVals) {
+            if (rhs.values === undefVals)
+                return;
+            this.values = this.values.slice(0, this.keys.length);
+        }
+        this.values.push.apply(this.values, rhs.reifyValues());
+    }
+}
+/** Internal node (non-leaf node) ********************************************/
+class BNodeInternal extends BNode {
+    /**
+     * This does not mark `children` as shared, so it is the responsibility of the caller
+     * to ensure children are either marked shared, or aren't included in another tree.
+     */
+    constructor(children, keys) {
+        if (!keys) {
+            keys = [];
+            for (var i = 0; i < children.length; i++)
+                keys[i] = children[i].maxKey();
+        }
+        super(keys);
+        this.children = children;
+    }
+    clone() {
+        var children = this.children.slice(0);
+        for (var i = 0; i < children.length; i++)
+            children[i].isShared = true;
+        return new BNodeInternal(children, this.keys.slice(0));
+    }
+    greedyClone(force) {
+        if (this.isShared && !force)
+            return this;
+        var nu = new BNodeInternal(this.children.slice(0), this.keys.slice(0));
+        for (var i = 0; i < nu.children.length; i++)
+            nu.children[i] = nu.children[i].greedyClone(force);
+        return nu;
+    }
+    minKey() {
+        return this.children[0].minKey();
+    }
+    minPair(reusedArray) {
+        return this.children[0].minPair(reusedArray);
+    }
+    maxPair(reusedArray) {
+        return this.children[this.children.length - 1].maxPair(reusedArray);
+    }
+    get(key, defaultValue, tree) {
+        var i = this.indexOf(key, 0, tree._compare), children = this.children;
+        return i < children.length ? children[i].get(key, defaultValue, tree) : undefined;
+    }
+    getPairOrNextLower(key, compare, inclusive, reusedArray) {
+        var i = this.indexOf(key, 0, compare), children = this.children;
+        if (i >= children.length)
+            return this.maxPair(reusedArray);
+        const result = children[i].getPairOrNextLower(key, compare, inclusive, reusedArray);
+        if (result === undefined && i > 0) {
+            return children[i - 1].maxPair(reusedArray);
+        }
+        return result;
+    }
+    getPairOrNextHigher(key, compare, inclusive, reusedArray) {
+        var i = this.indexOf(key, 0, compare), children = this.children, length = children.length;
+        if (i >= length)
+            return undefined;
+        const result = children[i].getPairOrNextHigher(key, compare, inclusive, reusedArray);
+        if (result === undefined && i < length - 1) {
+            return children[i + 1].minPair(reusedArray);
+        }
+        return result;
+    }
+    checkValid(depth, tree, baseIndex) {
+        let kL = this.keys.length, cL = this.children.length;
+        check(kL === cL, "keys/children length mismatch: depth", depth, "lengths", kL, cL, "baseIndex", baseIndex);
+        check(kL > 1 || depth > 0, "internal node has length", kL, "at depth", depth, "baseIndex", baseIndex);
+        let size = 0, c = this.children, k = this.keys, childSize = 0;
+        for (var i = 0; i < cL; i++) {
+            size += c[i].checkValid(depth + 1, tree, baseIndex + size);
+            childSize += c[i].keys.length;
+            check(size >= childSize, "wtf", baseIndex); // no way this will ever fail
+            check(i === 0 || c[i - 1].constructor === c[i].constructor, "type mismatch, baseIndex:", baseIndex);
+            if (c[i].maxKey() != k[i])
+                check(false, "keys[", i, "] =", k[i], "is wrong, should be ", c[i].maxKey(), "at depth", depth, "baseIndex", baseIndex);
+            if (!(i === 0 || tree._compare(k[i - 1], k[i]) < 0))
+                check(false, "sort violation at depth", depth, "index", i, "keys", k[i - 1], k[i]);
+        }
+        // 2020/08: BTree doesn't always avoid grossly undersized nodes,
+        // but AFAIK such nodes are pretty harmless, so accept them.
+        let toofew = childSize === 0; // childSize < (tree.maxNodeSize >> 1)*cL;
+        if (toofew || childSize > tree.maxNodeSize * cL)
+            check(false, toofew ? "too few" : "too many", "children (", childSize, size, ") at depth", depth, "maxNodeSize:", tree.maxNodeSize, "children.length:", cL, "baseIndex:", baseIndex);
+        return size;
+    }
+    /////////////////////////////////////////////////////////////////////////////
+    // Internal Node: set & node splitting //////////////////////////////////////
+    set(key, value, overwrite, tree) {
+        var c = this.children, max = tree._maxNodeSize, cmp = tree._compare;
+        var i = Math.min(this.indexOf(key, 0, cmp), c.length - 1), child = c[i];
+        if (child.isShared)
+            c[i] = child = child.clone();
+        if (child.keys.length >= max) {
+            // child is full; inserting anything else will cause a split.
+            // Shifting an item to the left or right sibling may avoid a split.
+            // We can do a shift if the adjacent node is not full and if the
+            // current key can still be placed in the same node after the shift.
+            var other;
+            if (i > 0 && (other = c[i - 1]).keys.length < max && cmp(child.keys[0], key) < 0) {
+                if (other.isShared)
+                    c[i - 1] = other = other.clone();
+                other.takeFromRight(child);
+                this.keys[i - 1] = other.maxKey();
+            }
+            else if ((other = c[i + 1]) !== undefined && other.keys.length < max && cmp(child.maxKey(), key) < 0) {
+                if (other.isShared)
+                    c[i + 1] = other = other.clone();
+                other.takeFromLeft(child);
+                this.keys[i] = c[i].maxKey();
+            }
+        }
+        var result = child.set(key, value, overwrite, tree);
+        if (result === false)
+            return false;
+        this.keys[i] = child.maxKey();
+        if (result === true)
+            return true;
+        // The child has split and `result` is a new right child... does it fit?
+        if (this.keys.length < max) { // yes
+            this.insert(i + 1, result);
+            return true;
+        }
+        else { // no, we must split also
+            var newRightSibling = this.splitOffRightSide(), target = this;
+            if (cmp(result.maxKey(), this.maxKey()) > 0) {
+                target = newRightSibling;
+                i -= this.keys.length;
+            }
+            target.insert(i + 1, result);
+            return newRightSibling;
+        }
+    }
+    /**
+     * Inserts `child` at index `i`.
+     * This does not mark `child` as shared, so it is the responsibility of the caller
+     * to ensure that either child is marked shared, or it is not included in another tree.
+     */
+    insert(i, child) {
+        this.children.splice(i, 0, child);
+        this.keys.splice(i, 0, child.maxKey());
+    }
+    /**
+     * Split this node.
+     * Modifies this to remove the second half of the items, returning a separate node containing them.
+     */
+    splitOffRightSide() {
+        // assert !this.isShared;
+        var half = this.children.length >> 1;
+        return new BNodeInternal(this.children.splice(half), this.keys.splice(half));
+    }
+    takeFromRight(rhs) {
+        // Reminder: parent node must update its copy of key for this node
+        // assert: neither node is shared
+        // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)
+        this.keys.push(rhs.keys.shift());
+        this.children.push(rhs.children.shift());
+    }
+    takeFromLeft(lhs) {
+        // Reminder: parent node must update its copy of key for this node
+        // assert: neither node is shared
+        // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)
+        this.keys.unshift(lhs.keys.pop());
+        this.children.unshift(lhs.children.pop());
+    }
+    /////////////////////////////////////////////////////////////////////////////
+    // Internal Node: scanning & deletions //////////////////////////////////////
+    // Note: `count` is the next value of the third argument to `onFound`.
+    //       A leaf node's `forRange` function returns a new value for this counter,
+    //       unless the operation is to stop early.
+    forRange(low, high, includeHigh, editMode, tree, count, onFound) {
+        var cmp = tree._compare;
+        var keys = this.keys, children = this.children;
+        var iLow = this.indexOf(low, 0, cmp), i = iLow;
+        var iHigh = Math.min(high === low ? iLow : this.indexOf(high, 0, cmp), keys.length - 1);
+        if (!editMode) {
+            // Simple case
+            for (; i <= iHigh; i++) {
+                var result = children[i].forRange(low, high, includeHigh, editMode, tree, count, onFound);
+                if (typeof result !== 'number')
+                    return result;
+                count = result;
+            }
+        }
+        else if (i <= iHigh) {
+            try {
+                for (; i <= iHigh; i++) {
+                    if (children[i].isShared)
+                        children[i] = children[i].clone();
+                    var result = children[i].forRange(low, high, includeHigh, editMode, tree, count, onFound);
+                    // Note: if children[i] is empty then keys[i]=undefined.
+                    //       This is an invalid state, but it is fixed below.
+                    keys[i] = children[i].maxKey();
+                    if (typeof result !== 'number')
+                        return result;
+                    count = result;
+                }
+            }
+            finally {
+                // Deletions may have occurred, so look for opportunities to merge nodes.
+                var half = tree._maxNodeSize >> 1;
+                if (iLow > 0)
+                    iLow--;
+                for (i = iHigh; i >= iLow; i--) {
+                    if (children[i].keys.length <= half) {
+                        if (children[i].keys.length !== 0) {
+                            this.tryMerge(i, tree._maxNodeSize);
+                        }
+                        else { // child is empty! delete it!
+                            keys.splice(i, 1);
+                            children.splice(i, 1);
+                        }
+                    }
+                }
+                if (children.length !== 0 && children[0].keys.length === 0)
+                    check(false, "emptiness bug");
+            }
+        }
+        return count;
+    }
+    /** Merges child i with child i+1 if their combined size is not too large */
+    tryMerge(i, maxSize) {
+        var children = this.children;
+        if (i >= 0 && i + 1 < children.length) {
+            if (children[i].keys.length + children[i + 1].keys.length <= maxSize) {
+                if (children[i].isShared) // cloned already UNLESS i is outside scan range
+                    children[i] = children[i].clone();
+                children[i].mergeSibling(children[i + 1], maxSize);
+                children.splice(i + 1, 1);
+                this.keys.splice(i + 1, 1);
+                this.keys[i] = children[i].maxKey();
+                return true;
+            }
+        }
+        return false;
+    }
+    /**
+     * Move children from `rhs` into this.
+     * `rhs` must be part of this tree, and be removed from it after this call
+     * (otherwise isShared for its children could be incorrect).
+     */
+    mergeSibling(rhs, maxNodeSize) {
+        // assert !this.isShared;
+        var oldLength = this.keys.length;
+        this.keys.push.apply(this.keys, rhs.keys);
+        const rhsChildren = rhs.children;
+        this.children.push.apply(this.children, rhsChildren);
+        if (rhs.isShared && !this.isShared) {
+            // All children of a shared node are implicitly shared, and since their new
+            // parent is not shared, they must now be explicitly marked as shared.
+            for (var i = 0; i < rhsChildren.length; i++)
+                rhsChildren[i].isShared = true;
+        }
+        // If our children are themselves almost empty due to a mass-delete,
+        // they may need to be merged too (but only the oldLength-1 and its
+        // right sibling should need this).
+        this.tryMerge(oldLength - 1, maxNodeSize);
+    }
+}
+// Optimization: this array of `undefined`s is used instead of a normal
+// array of values in nodes where `undefined` is the only value.
+// Its length is extended to max node size on first use; since it can
+// be shared between trees with different maximums, its length can only
+// increase, never decrease. Its type should be undefined[] but strangely
+// TypeScript won't allow the comparison V[] === undefined[]. To prevent
+// users from making this array too large, BTree has a maximum node size.
+//
+// FAQ: undefVals[i] is already undefined, so why increase the array size?
+// Reading outside the bounds of an array is relatively slow because it
+// has the side effect of scanning the prototype chain.
+var undefVals = [];
+const Delete = { delete: true }, DeleteRange = () => Delete;
+const Break = { break: true };
+const EmptyLeaf = (function () {
+    var n = new BNode();
+    n.isShared = true;
+    return n;
+})();
+const EmptyArray = [];
+const ReusedArray = []; // assumed thread-local
+function check(fact, ...args) {
+    if (!fact) {
+        args.unshift('B+ tree'); // at beginning of message
+        throw new Error(args.join(' '));
+    }
+}
+/** A BTree frozen in the empty state. */
+exports.EmptyBTree = (() => { let t = new BTree(); t.freeze(); return t; })();
diff --git a/dist/interfaces.d.ts b/dist/interfaces.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..82d4f8a7de4337f7d967c8a407e128eed0eecb27
--- /dev/null
+++ b/dist/interfaces.d.ts
@@ -0,0 +1,269 @@
+/** Read-only set interface (subinterface of IMapSource<K,any>).
+ *  The word "set" usually means that each item in the collection is unique
+ *  (appears only once, based on a definition of equality used by the
+ *  collection.) Objects conforming to this interface aren't guaranteed not
+ *  to contain duplicates, but as an example, BTree<K,V> implements this
+ *  interface and does not allow duplicates. */
+export interface ISetSource<K = any> {
+    /** Returns the number of key/value pairs in the map object. */
+    size: number;
+    /** Returns a boolean asserting whether the key exists in the map object or not. */
+    has(key: K): boolean;
+    /** Returns a new iterator for iterating the items in the set (the order is implementation-dependent). */
+    keys(): IterableIterator<K>;
+}
+/** Read-only map interface (i.e. a source of key-value pairs). */
+export interface IMapSource<K = any, V = any> extends ISetSource<K> {
+    /** Returns the number of key/value pairs in the map object. */
+    size: number;
+    /** Returns the value associated to the key, or undefined if there is none. */
+    get(key: K): V | undefined;
+    /** Returns a boolean asserting whether the key exists in the map object or not. */
+    has(key: K): boolean;
+    /** Calls callbackFn once for each key-value pair present in the map object.
+     *  The ES6 Map class sends the value to the callback before the key, so
+     *  this interface must do likewise. */
+    forEach(callbackFn: (v: V, k: K, map: IMapSource<K, V>) => void, thisArg: any): void;
+    /** Returns an iterator that provides all key-value pairs from the collection (as arrays of length 2). */
+    entries(): IterableIterator<[K, V]>;
+    /** Returns a new iterator for iterating the keys of each pair. */
+    keys(): IterableIterator<K>;
+    /** Returns a new iterator for iterating the values of each pair. */
+    values(): IterableIterator<V>;
+}
+/** Write-only set interface (the set cannot be queried, but items can be added to it.)
+ *  @description Note: BTree<K,V> does not officially implement this interface,
+ *               but BTree<K> can be used as an instance of ISetSink<K>. */
+export interface ISetSink<K = any> {
+    /** Adds the specified item to the set, if it was not in the set already. */
+    add(key: K): any;
+    /** Returns true if an element in the map object existed and has been
+     *  removed, or false if the element did not exist. */
+    delete(key: K): boolean;
+    /** Removes everything so that the set is empty. */
+    clear(): void;
+}
+/** Write-only map interface (i.e. a drain into which key-value pairs can be "sunk") */
+export interface IMapSink<K = any, V = any> {
+    /** Returns true if an element in the map object existed and has been
+     *  removed, or false if the element did not exist. */
+    delete(key: K): boolean;
+    /** Sets the value for the key in the map object (the return value is
+     *  boolean in BTree but Map returns the Map itself.) */
+    set(key: K, value: V): any;
+    /** Removes all key/value pairs from the IMap object. */
+    clear(): void;
+}
+/** Set interface.
+ *  @description Note: BTree<K,V> does not officially implement this interface,
+ *               but BTree<K> can be used as an instance of ISet<K>. */
+export interface ISet<K = any> extends ISetSource<K>, ISetSink<K> {
+}
+/** An interface compatible with ES6 Map and BTree. This interface does not
+ *  describe the complete interface of either class, but merely the common
+ *  interface shared by both. */
+export interface IMap<K = any, V = any> extends IMapSource<K, V>, IMapSink<K, V> {
+}
+/** An data source that provides read-only access to a set of items called
+ *  "keys" in sorted order. This is a subinterface of ISortedMapSource. */
+export interface ISortedSetSource<K = any> extends ISetSource<K> {
+    /** Gets the lowest key in the collection. */
+    minKey(): K | undefined;
+    /** Gets the highest key in the collection. */
+    maxKey(): K | undefined;
+    /** Returns the next key larger than the specified key (or undefined if there is none).
+     *  Also, nextHigherKey(undefined) returns the lowest key. */
+    nextHigherKey(key?: K): K | undefined;
+    /** Returns the next key smaller than the specified key (or undefined if there is none).
+     *  Also, nextLowerKey(undefined) returns the highest key. */
+    nextLowerKey(key?: K): K | undefined;
+    /** Calls `callback` on the specified range of keys, in ascending order by key.
+     * @param low The first key scanned will be greater than or equal to `low`.
+     * @param high Scanning stops when a key larger than this is reached.
+     * @param includeHigh If the `high` key is present in the map, `onFound` is called
+     *        for that final pair if and only if this parameter is true.
+     * @param onFound A function that is called for each key pair. Because this
+     *        is a subinterface of ISortedMapSource, if there is a value
+     *        associated with the key, it is passed as the second parameter.
+     * @param initialCounter Initial third argument of `onFound`. This value
+     *        increases by one each time `onFound` is called. Default: 0
+     * @returns Number of pairs found and the number of times `onFound` was called.
+     */
+    forRange(low: K, high: K, includeHigh: boolean, onFound?: (k: K, v: any, counter: number) => void, initialCounter?: number): number;
+    /** Returns a new iterator for iterating the keys of each pair in ascending order.
+     *  @param firstKey: Minimum key to include in the output. */
+    keys(firstKey?: K): IterableIterator<K>;
+}
+/** An data source that provides read-only access to items in sorted order. */
+export interface ISortedMapSource<K = any, V = any> extends IMapSource<K, V>, ISortedSetSource<K> {
+    /** Returns the next pair whose key is larger than the specified key (or undefined
+     *  if there is none). If key === undefined, this function returns the lowest pair. */
+    nextHigherPair(key?: K): [K, V] | undefined;
+    /** Returns the next pair whose key is smaller than the specified key (or undefined
+     *  if there is none). If key === undefined, this function returns the highest pair. */
+    nextLowerPair(key?: K): [K, V] | undefined;
+    /** Builds an array of pairs from the specified range of keys, sorted by key.
+     * Each returned pair is also an array: pair[0] is the key, pair[1] is the value.
+     * @param low The first key in the array will be greater than or equal to `low`.
+     * @param high This method returns when a key larger than this is reached.
+     * @param includeHigh If the `high` key is present in the map, its pair will be
+     *        included in the output if and only if this parameter is true. Note:
+     *        if the `low` key is present, it is always included in the output.
+     * @param maxLength Maximum length of the returned array (default: unlimited)
+     * @description Computational complexity: O(result.length + log size)
+     */
+    getRange(low: K, high: K, includeHigh?: boolean, maxLength?: number): [K, V][];
+    /** Calls `callback` on the specified range of keys, in ascending order by key.
+     * @param low The first key scanned will be greater than or equal to `low`.
+     * @param high Scanning stops when a key larger than this is reached.
+     * @param includeHigh If the `high` key is present in the map, `onFound` is called
+     *        for that final pair if and only if this parameter is true.
+     * @param onFound A function that is called for each key-value pair.
+     * @param initialCounter Initial third argument of onFound. This value
+     *        increases by one each time `onFound` is called. Default: 0
+     * @returns Number of pairs found and the number of times `callback` was called.
+     */
+    forRange(low: K, high: K, includeHigh: boolean, onFound?: (k: K, v: V, counter: number) => void, initialCounter?: number): number;
+    /** Returns an iterator that provides items in order by key.
+     *  @param firstKey: Minimum key to include in the output. */
+    entries(firstKey?: K): IterableIterator<[K, V]>;
+    /** Returns a new iterator for iterating the keys of each pair in ascending order.
+     *  @param firstKey: Minimum key to include in the output. */
+    keys(firstKey?: K): IterableIterator<K>;
+    /** Returns a new iterator for iterating the values of each pair in order by key.
+     *  @param firstKey: Minimum key whose associated value is included in the output. */
+    values(firstKey?: K): IterableIterator<V>;
+    /** Performs a reduce operation like the `reduce` method of `Array`.
+     *  It is used to combine all pairs into a single value, or perform conversions. */
+    reduce<R>(callback: (previous: R, currentPair: [K, V], counter: number, tree: IMapF<K, V>) => R, initialValue: R): R;
+    /** Performs a reduce operation like the `reduce` method of `Array`.
+     *  It is used to combine all pairs into a single value, or perform conversions. */
+    reduce<R>(callback: (previous: R | undefined, currentPair: [K, V], counter: number, tree: IMapF<K, V>) => R): R | undefined;
+}
+/** An interface for a set of keys (the combination of ISortedSetSource<K> and ISetSink<K>) */
+export interface ISortedSet<K = any> extends ISortedSetSource<K>, ISetSink<K> {
+}
+/** An interface for a sorted map (dictionary),
+ *  not including functional/persistent methods. */
+export interface ISortedMap<K = any, V = any> extends IMap<K, V>, ISortedMapSource<K, V> {
+    /** Adds or overwrites a key-value pair in the sorted map.
+     * @param key the key is used to determine the sort order of data in the tree.
+     * @param value data to associate with the key
+     * @param overwrite Whether to overwrite an existing key-value pair
+     *        (default: true). If this is false and there is an existing
+     *        key-value pair then the call to this method has no effect.
+     * @returns true if a new key-value pair was added, false if the key
+     *        already existed. */
+    set(key: K, value: V, overwrite?: boolean): boolean;
+    /** Adds all pairs from a list of key-value pairs.
+     * @param pairs Pairs to add to this tree. If there are duplicate keys,
+     *        later pairs currently overwrite earlier ones (e.g. [[0,1],[0,7]]
+     *        associates 0 with 7.)
+     * @param overwrite Whether to overwrite pairs that already exist (if false,
+     *        pairs[i] is ignored when the key pairs[i][0] already exists.)
+     * @returns The number of pairs added to the collection.
+     */
+    setPairs(pairs: [K, V][], overwrite?: boolean): number;
+    /** Deletes a series of keys from the collection. */
+    deleteKeys(keys: K[]): number;
+    /** Removes a range of key-value pairs from the B+ tree.
+     * @param low The first key deleted will be greater than or equal to `low`.
+     * @param high Deleting stops when a key larger than this is reached.
+     * @param includeHigh Specifies whether the `high` key, if present, is deleted.
+     * @returns The number of key-value pairs that were deleted. */
+    deleteRange(low: K, high: K, includeHigh: boolean): number;
+    entries(firstKey?: K): IterableIterator<[K, V]>;
+    keys(firstKey?: K): IterableIterator<K>;
+    values(firstKey?: K): IterableIterator<V>;
+}
+/** An interface for a functional set, in which the set object could be read-only
+ *  but new versions of the set can be created by calling "with" or "without"
+ *  methods to add or remove keys. This is a subinterface of IMapF<K,V>,
+ *  so the items in the set may be referred to as "keys". */
+export interface ISetF<K = any> extends ISetSource<K> {
+    /** Returns a copy of the set with the specified key included.
+     *  @description You might wonder why this method accepts only one key
+     *  instead of `...keys: K[]`. The reason is that the derived interface
+     *  IMapF expects the second parameter to be a value. Therefore
+     *  withKeys() is provided to set multiple keys at once. */
+    with(key: K): ISetF<K>;
+    /** Returns a copy of the set with the specified key removed. */
+    without(key: K): ISetF<K>;
+    /** Returns a copy of the tree with all the keys in the specified array present.
+     *  @param keys The keys to add.
+     *  @param returnThisIfUnchanged If true, the method returns `this` when
+     *         all of the keys are already present in the collection. The
+     *         default value may be true or false depending on the concrete
+     *         implementation of the interface (in BTree, the default is false.) */
+    withKeys(keys: K[], returnThisIfUnchanged?: boolean): ISetF<K>;
+    /** Returns a copy of the tree with all the keys in the specified array removed. */
+    withoutKeys(keys: K[], returnThisIfUnchanged?: boolean): ISetF<K>;
+    /** Returns a copy of the tree with items removed whenever the callback
+     *  function returns false.
+     *  @param callback A function to call for each item in the set.
+     *         The second parameter to `callback` exists because ISetF
+     *         is a subinterface of IMapF. If the object is a map, v
+     *         is the value associated with the key, otherwise v could be
+     *         undefined or another copy of the third parameter (counter). */
+    filter(callback: (k: K, v: any, counter: number) => boolean, returnThisIfUnchanged?: boolean): ISetF<K>;
+}
+/** An interface for a functional map, in which the map object could be read-only
+ *  but new versions of the map can be created by calling "with" or "without"
+ *  methods to add or remove keys or key-value pairs.
+ */
+export interface IMapF<K = any, V = any> extends IMapSource<K, V>, ISetF<K> {
+    /** Returns a copy of the tree with the specified key set (the value is undefined). */
+    with(key: K): IMapF<K, V | undefined>;
+    /** Returns a copy of the tree with the specified key-value pair set. */
+    with<V2>(key: K, value: V2, overwrite?: boolean): IMapF<K, V | V2>;
+    /** Returns a copy of the tree with the specified key-value pairs set. */
+    withPairs<V2>(pairs: [K, V | V2][], overwrite: boolean): IMapF<K, V | V2>;
+    /** Returns a copy of the tree with all the keys in the specified array present.
+     *  @param keys The keys to add. If a key is already present in the tree,
+     *         neither the existing key nor the existing value is modified.
+     *  @param returnThisIfUnchanged If true, the method returns `this` when
+     *         all of the keys are already present in the collection. The
+     *         default value may be true or false depending on the concrete
+     *         implementation of the interface (in BTree, the default is false.) */
+    withKeys(keys: K[], returnThisIfUnchanged?: boolean): IMapF<K, V | undefined>;
+    /** Returns a copy of the tree with all values altered by a callback function. */
+    mapValues<R>(callback: (v: V, k: K, counter: number) => R): IMapF<K, R>;
+    /** Performs a reduce operation like the `reduce` method of `Array`.
+     *  It is used to combine all pairs into a single value, or perform conversions. */
+    reduce<R>(callback: (previous: R, currentPair: [K, V], counter: number, tree: IMapF<K, V>) => R, initialValue: R): R;
+    /** Performs a reduce operation like the `reduce` method of `Array`.
+     *  It is used to combine all pairs into a single value, or perform conversions. */
+    reduce<R>(callback: (previous: R | undefined, currentPair: [K, V], counter: number, tree: IMapF<K, V>) => R): R | undefined;
+    without(key: K): IMapF<K, V>;
+    withoutKeys(keys: K[], returnThisIfUnchanged?: boolean): IMapF<K, V>;
+    /** Returns a copy of the tree with pairs removed whenever the callback
+     *  function returns false. */
+    filter(callback: (k: K, v: V, counter: number) => boolean, returnThisIfUnchanged?: boolean): IMapF<K, V>;
+}
+/** An interface for a functional sorted set: a functional set in which the
+ *  keys (items) are sorted. This is a subinterface of ISortedMapF. */
+export interface ISortedSetF<K = any> extends ISetF<K>, ISortedSetSource<K> {
+    keys(firstKey?: K): IterableIterator<K>;
+}
+export interface ISortedMapF<K = any, V = any> extends ISortedSetF<K>, IMapF<K, V>, ISortedMapSource<K, V> {
+    /** Returns a copy of the tree with the specified range of keys removed. */
+    withoutRange(low: K, high: K, includeHigh: boolean, returnThisIfUnchanged?: boolean): ISortedMapF<K, V>;
+    entries(firstKey?: K): IterableIterator<[K, V]>;
+    keys(firstKey?: K): IterableIterator<K>;
+    values(firstKey?: K): IterableIterator<V>;
+    forRange(low: K, high: K, includeHigh: boolean, onFound?: (k: K, v: V, counter: number) => void, initialCounter?: number): number;
+    with(key: K): ISortedMapF<K, V | undefined>;
+    with<V2>(key: K, value: V2, overwrite?: boolean): ISortedMapF<K, V | V2>;
+    withKeys(keys: K[], returnThisIfUnchanged?: boolean): ISortedMapF<K, V | undefined>;
+    withPairs<V2>(pairs: [K, V | V2][], overwrite: boolean): ISortedMapF<K, V | V2>;
+    mapValues<R>(callback: (v: V, k: K, counter: number) => R): ISortedMapF<K, R>;
+    without(key: K): ISortedMapF<K, V>;
+    withoutKeys(keys: K[], returnThisIfUnchanged?: boolean): ISortedMapF<K, V>;
+    filter(callback: (k: K, v: any, counter: number) => boolean, returnThisIfUnchanged?: boolean): ISortedMapF<K, V>;
+}
+export interface ISortedMapConstructor<K, V> {
+    new (entries?: [K, V][], compare?: (a: K, b: K) => number): ISortedMap<K, V>;
+}
+export interface ISortedMapFConstructor<K, V> {
+    new (entries?: [K, V][], compare?: (a: K, b: K) => number): ISortedMapF<K, V>;
+}
diff --git a/dist/interfaces.js b/dist/interfaces.js
new file mode 100644
index 0000000000000000000000000000000000000000..c8ad2e549bdc6801e0d1c80b0308d4b9bd4985ce
--- /dev/null
+++ b/dist/interfaces.js
@@ -0,0 +1,2 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
diff --git a/dist/sorted-array.d.ts b/dist/sorted-array.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c79d8cbcb603025d00cd8cd7490782c511dd0f42
--- /dev/null
+++ b/dist/sorted-array.d.ts
@@ -0,0 +1,22 @@
+import { IMap } from './interfaces';
+/** A super-inefficient sorted list for testing purposes */
+export default class SortedArray<K = any, V = any> implements IMap<K, V> {
+    a: [K, V][];
+    cmp: (a: K, b: K) => number;
+    constructor(entries?: [K, V][], compare?: (a: K, b: K) => number);
+    get size(): number;
+    get(key: K, defaultValue?: V): V | undefined;
+    set(key: K, value: V, overwrite?: boolean): boolean;
+    has(key: K): boolean;
+    delete(key: K): boolean;
+    clear(): void;
+    getArray(): [K, V][];
+    minKey(): K | undefined;
+    maxKey(): K | undefined;
+    forEach(callbackFn: (v: V, k: K, list: SortedArray<K, V>) => void): void;
+    [Symbol.iterator](): IterableIterator<[K, V]>;
+    entries(): IterableIterator<[K, V]>;
+    keys(): IterableIterator<K>;
+    values(): IterableIterator<V>;
+    indexOf(key: K, failXor: number): number;
+}
diff --git a/dist/sorted-array.js b/dist/sorted-array.js
new file mode 100644
index 0000000000000000000000000000000000000000..5c0a9d2381d2457118088cfe769ea8486e90e4d7
--- /dev/null
+++ b/dist/sorted-array.js
@@ -0,0 +1,63 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+/** A super-inefficient sorted list for testing purposes */
+class SortedArray {
+    constructor(entries, compare) {
+        this.cmp = compare || ((a, b) => a < b ? -1 : a > b ? 1 : a === b ? 0 : a - b);
+        this.a = [];
+        if (entries !== undefined)
+            for (var e of entries)
+                this.set(e[0], e[1]);
+    }
+    get size() { return this.a.length; }
+    get(key, defaultValue) {
+        var pair = this.a[this.indexOf(key, -1)];
+        return pair === undefined ? defaultValue : pair[1];
+    }
+    set(key, value, overwrite) {
+        var i = this.indexOf(key, -1);
+        if (i <= -1)
+            this.a.splice(~i, 0, [key, value]);
+        else
+            this.a[i] = [key, value];
+        return i <= -1;
+    }
+    has(key) {
+        return this.indexOf(key, -1) >= 0;
+    }
+    delete(key) {
+        var i = this.indexOf(key, -1);
+        if (i > -1)
+            this.a.splice(i, 1);
+        return i > -1;
+    }
+    clear() { this.a = []; }
+    getArray() { return this.a; }
+    minKey() { return this.a[0][0]; }
+    maxKey() { return this.a[this.a.length - 1][0]; }
+    forEach(callbackFn) {
+        this.a.forEach(pair => callbackFn(pair[1], pair[0], this));
+    }
+    // a.values() used to implement IMap<K,V> but it's not actually available in Node v10.4
+    [Symbol.iterator]() { return this.a.values(); }
+    entries() { return this.a.values(); }
+    keys() { return this.a.map(pair => pair[0]).values(); }
+    values() { return this.a.map(pair => pair[1]).values(); }
+    indexOf(key, failXor) {
+        var lo = 0, hi = this.a.length, mid = hi >> 1;
+        while (lo < hi) {
+            var c = this.cmp(this.a[mid][0], key);
+            if (c < 0)
+                lo = mid + 1;
+            else if (c > 0) // keys[mid] > key
+                hi = mid;
+            else if (c === 0)
+                return mid;
+            else
+                throw new Error("Problem: compare failed");
+            mid = (lo + hi) >> 1;
+        }
+        return mid ^ failXor;
+    }
+}
+exports.default = SortedArray;
diff --git a/sorted-array.js b/sorted-array.js
index bf7c25ee36a0d3766502c347ddbb93e2d4791a73..5c0a9d2381d2457118088cfe769ea8486e90e4d7 100644
--- a/sorted-array.js
+++ b/sorted-array.js
@@ -1,56 +1,49 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 /** A super-inefficient sorted list for testing purposes */
-var SortedArray = /** @class */ (function () {
-    function SortedArray(entries, compare) {
-        this.cmp = compare || (function (a, b) { return a < b ? -1 : a > b ? 1 : a === b ? 0 : a - b; });
+class SortedArray {
+    constructor(entries, compare) {
+        this.cmp = compare || ((a, b) => a < b ? -1 : a > b ? 1 : a === b ? 0 : a - b);
         this.a = [];
         if (entries !== undefined)
-            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
-                var e = entries_1[_i];
+            for (var e of entries)
                 this.set(e[0], e[1]);
-            }
     }
-    Object.defineProperty(SortedArray.prototype, "size", {
-        get: function () { return this.a.length; },
-        enumerable: false,
-        configurable: true
-    });
-    SortedArray.prototype.get = function (key, defaultValue) {
+    get size() { return this.a.length; }
+    get(key, defaultValue) {
         var pair = this.a[this.indexOf(key, -1)];
         return pair === undefined ? defaultValue : pair[1];
-    };
-    SortedArray.prototype.set = function (key, value, overwrite) {
+    }
+    set(key, value, overwrite) {
         var i = this.indexOf(key, -1);
         if (i <= -1)
             this.a.splice(~i, 0, [key, value]);
         else
             this.a[i] = [key, value];
         return i <= -1;
-    };
-    SortedArray.prototype.has = function (key) {
+    }
+    has(key) {
         return this.indexOf(key, -1) >= 0;
-    };
-    SortedArray.prototype.delete = function (key) {
+    }
+    delete(key) {
         var i = this.indexOf(key, -1);
         if (i > -1)
             this.a.splice(i, 1);
         return i > -1;
-    };
-    SortedArray.prototype.clear = function () { this.a = []; };
-    SortedArray.prototype.getArray = function () { return this.a; };
-    SortedArray.prototype.minKey = function () { return this.a[0][0]; };
-    SortedArray.prototype.maxKey = function () { return this.a[this.a.length - 1][0]; };
-    SortedArray.prototype.forEach = function (callbackFn) {
-        var _this = this;
-        this.a.forEach(function (pair) { return callbackFn(pair[1], pair[0], _this); });
-    };
+    }
+    clear() { this.a = []; }
+    getArray() { return this.a; }
+    minKey() { return this.a[0][0]; }
+    maxKey() { return this.a[this.a.length - 1][0]; }
+    forEach(callbackFn) {
+        this.a.forEach(pair => callbackFn(pair[1], pair[0], this));
+    }
     // a.values() used to implement IMap<K,V> but it's not actually available in Node v10.4
-    SortedArray.prototype[Symbol.iterator] = function () { return this.a.values(); };
-    SortedArray.prototype.entries = function () { return this.a.values(); };
-    SortedArray.prototype.keys = function () { return this.a.map(function (pair) { return pair[0]; }).values(); };
-    SortedArray.prototype.values = function () { return this.a.map(function (pair) { return pair[1]; }).values(); };
-    SortedArray.prototype.indexOf = function (key, failXor) {
+    [Symbol.iterator]() { return this.a.values(); }
+    entries() { return this.a.values(); }
+    keys() { return this.a.map(pair => pair[0]).values(); }
+    values() { return this.a.map(pair => pair[1]).values(); }
+    indexOf(key, failXor) {
         var lo = 0, hi = this.a.length, mid = hi >> 1;
         while (lo < hi) {
             var c = this.cmp(this.a[mid][0], key);
@@ -65,7 +58,6 @@ var SortedArray = /** @class */ (function () {
             mid = (lo + hi) >> 1;
         }
         return mid ^ failXor;
-    };
-    return SortedArray;
-}());
+    }
+}
 exports.default = SortedArray;
diff --git a/tsconfig.json b/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..c234033d45c82118e39311b417504a8552dc0f6a
--- /dev/null
+++ b/tsconfig.json
@@ -0,0 +1,20 @@
+{ // TypeScript configuration file: provides options to the TypeScript
+  // compiler (tsc) and makes VSCode recognize this folder as a TS project,
+  // enabling the VSCode build tasks "tsc: build" and "tsc: watch".
+  "compilerOptions": {
+    "target": "es2020",            // Compatible with older browsers
+    "module": "node16",       // Compatible with both Node.js and browser
+    "moduleResolution": "node16", // Tell tsc to look in node_modules for modules
+    "sourceMap": false,         // Whether to create *.js.map files
+    "jsx": "react",             // Causes inline XML (JSX code) to be expanded
+    "strict": true,             // Strict types, eg. prohibits `var x=0; x=null`
+    "alwaysStrict": true,       // Enable JavaScript's "use strict" mode
+    "esModuleInterop": true,    // CommonJS import behavior similar to Babel/mjs
+    "declaration": true,        // Generate d.ts files
+    // Note: BTree does not rely on ES6 runtime APIs, just compile-time interfaces
+    "lib": ["es6"],             // APIs expected to exist at runtime
+    "downlevelIteration": false, // for-of loops and yield statement in ES5
+  },
+  "include": ["**/*.ts"],
+  "exclude": ["node_modules", "tests", "b+tree.test.ts"],
+}