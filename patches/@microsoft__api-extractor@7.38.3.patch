diff --git a/lib/aedoc/PackageDocComment.js.map b/lib/aedoc/PackageDocComment.js.map
index 46fffb20e324a6b8b6873beed6af43f7f384017b..44cbd46cb8b1d88ce0433fa7b3c5948f04379da5 100644
--- a/lib/aedoc/PackageDocComment.js.map
+++ b/lib/aedoc/PackageDocComment.js.map
@@ -1 +1 @@
-{"version":3,"file":"PackageDocComment.js","sourceRoot":"","sources":["../../src/aedoc/PackageDocComment.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,+CAAiC;AAIjC,MAAa,iBAAiB;IAC5B;;OAEG;IACI,MAAM,CAAC,mBAAmB,CAC/B,UAAyB,EACzB,SAAoB;QAEpB,oFAAoF;QACpF,mFAAmF;QACnF,6BAA6B;QAC7B,EAAE;QACF,sFAAsF;QACtF,uFAAuF;QACvF,+DAA+D;QAC/D,EAAE;QACF,kGAAkG;QAClG,wFAAwF;QACxF,8FAA8F;QAC9F,eAAe;QACf,IAAI,mBAAmB,GAA6B,SAAS,CAAC,CAAC,eAAe;QAE9E,KAAK,MAAM,YAAY,IAAI,EAAE,CAAC,uBAAuB,CAAC,UAAU,CAAC,IAAI,EAAE,UAAU,CAAC,YAAY,EAAE,CAAC,IAAI,EAAE,EAAE;YACvG,IAAI,YAAY,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,sBAAsB,EAAE;gBAC9D,MAAM,WAAW,GAAW,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC;gBAE1F,uCAAuC;gBACvC,IAAI,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;oBAClC,oEAAoE;oBACpE,wDAAwD;oBACxD,IAAI,yBAAyB,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;wBAC/C,mBAAmB,GAAG,YAAY,CAAC;qBACpC;oBACD,MAAM;iBACP;aACF;SACF;QAED,IAAI,CAAC,mBAAmB,EAAE;YACxB,uFAAuF;YACvF,8FAA8F;YAC9F,KAAK,MAAM,SAAS,IAAI,UAAU,CAAC,UAAU,EAAE;gBAC7C,MAAM,MAAM,GAAsB,EAAE,CAAC;gBACrC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,uBAAuB,CAAC,UAAU,CAAC,IAAI,EAAE,SAAS,CAAC,YAAY,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBAC9F,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,wBAAwB,CAAC,UAAU,CAAC,IAAI,EAAE,SAAS,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBAEzF,KAAK,MAAM,YAAY,IAAI,MAAM,EAAE;oBACjC,MAAM,WAAW,GAAW,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC;oBAE1F,IAAI,yBAAyB,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;wBAC/C,SAAS,CAAC,aAAa,CAAC,2BAA2B,0EAEjD,qFAAqF,EACrF,UAAU,EACV,YAAY,CAAC,GAAG,CACjB,CAAC;wBACF,MAAM;qBACP;iBACF;aACF;SACF;QAED,OAAO,mBAAmB,CAAC;IAC7B,CAAC;CACF;AAhED,8CAgEC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\nimport type { Collector } from '../collector/Collector';\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\n\nexport class PackageDocComment {\n  /**\n   * For the given source file, see if it starts with a TSDoc comment containing the `@packageDocumentation` tag.\n   */\n  public static tryFindInSourceFile(\n    sourceFile: ts.SourceFile,\n    collector: Collector\n  ): ts.TextRange | undefined {\n    // The @packageDocumentation comment is special because it is not attached to an AST\n    // definition.  Instead, it is part of the \"trivia\" tokens that the compiler treats\n    // as irrelevant white space.\n    //\n    // WARNING: If the comment doesn't precede an export statement, the compiler will omit\n    // it from the *.d.ts file, and API Extractor won't find it.  If this happens, you need\n    // to rearrange your statements to ensure it is passed through.\n    //\n    // This implementation assumes that the \"@packageDocumentation\" will be in the first TSDoc comment\n    // that appears in the entry point *.d.ts file.  We could possibly look in other places,\n    // but the above warning suggests enforcing a standardized layout.  This design choice is open\n    // to feedback.\n    let packageCommentRange: ts.TextRange | undefined = undefined; // empty string\n\n    for (const commentRange of ts.getLeadingCommentRanges(sourceFile.text, sourceFile.getFullStart()) || []) {\n      if (commentRange.kind === ts.SyntaxKind.MultiLineCommentTrivia) {\n        const commentBody: string = sourceFile.text.substring(commentRange.pos, commentRange.end);\n\n        // Choose the first JSDoc-style comment\n        if (/^\\s*\\/\\*\\*/.test(commentBody)) {\n          // But only if it looks like it's trying to be @packageDocumentation\n          // (The TSDoc parser will validate this more rigorously)\n          if (/\\@packageDocumentation/i.test(commentBody)) {\n            packageCommentRange = commentRange;\n          }\n          break;\n        }\n      }\n    }\n\n    if (!packageCommentRange) {\n      // If we didn't find the @packageDocumentation tag in the expected place, is it in some\n      // wrong place?  This sanity check helps people to figure out why there comment isn't working.\n      for (const statement of sourceFile.statements) {\n        const ranges: ts.CommentRange[] = [];\n        ranges.push(...(ts.getLeadingCommentRanges(sourceFile.text, statement.getFullStart()) || []));\n        ranges.push(...(ts.getTrailingCommentRanges(sourceFile.text, statement.getEnd()) || []));\n\n        for (const commentRange of ranges) {\n          const commentBody: string = sourceFile.text.substring(commentRange.pos, commentRange.end);\n\n          if (/\\@packageDocumentation/i.test(commentBody)) {\n            collector.messageRouter.addAnalyzerIssueForPosition(\n              ExtractorMessageId.MisplacedPackageTag,\n              'The @packageDocumentation comment must appear at the top of entry point *.d.ts file',\n              sourceFile,\n              commentRange.pos\n            );\n            break;\n          }\n        }\n      }\n    }\n\n    return packageCommentRange;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"PackageDocComment.js","sourceRoot":"","sources":["../../src/aedoc/PackageDocComment.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,+CAAiC;AAIjC,MAAa,iBAAiB;IAC5B;;OAEG;IACI,MAAM,CAAC,mBAAmB,CAC/B,UAAyB,EACzB,SAAoB;QAEpB,oFAAoF;QACpF,mFAAmF;QACnF,6BAA6B;QAC7B,EAAE;QACF,sFAAsF;QACtF,uFAAuF;QACvF,+DAA+D;QAC/D,EAAE;QACF,kGAAkG;QAClG,wFAAwF;QACxF,8FAA8F;QAC9F,eAAe;QACf,IAAI,mBAAmB,GAA6B,SAAS,CAAC,CAAC,eAAe;QAE9E,KAAK,MAAM,YAAY,IAAI,EAAE,CAAC,uBAAuB,CAAC,UAAU,CAAC,IAAI,EAAE,UAAU,CAAC,YAAY,EAAE,CAAC,IAAI,EAAE,EAAE;YACvG,IAAI,YAAY,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,sBAAsB,EAAE;gBAC9D,MAAM,WAAW,GAAW,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC;gBAE1F,uCAAuC;gBACvC,IAAI,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;oBAClC,oEAAoE;oBACpE,wDAAwD;oBACxD,IAAI,yBAAyB,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;wBAC/C,mBAAmB,GAAG,YAAY,CAAC;qBACpC;oBACD,MAAM;iBACP;aACF;SACF;QAED,IAAI,CAAC,mBAAmB,EAAE;YACxB,uFAAuF;YACvF,8FAA8F;YAC9F,KAAK,MAAM,SAAS,IAAI,UAAU,CAAC,UAAU,EAAE;gBAC7C,MAAM,MAAM,GAAsB,EAAE,CAAC;gBACrC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,uBAAuB,CAAC,UAAU,CAAC,IAAI,EAAE,SAAS,CAAC,YAAY,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBAC9F,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,wBAAwB,CAAC,UAAU,CAAC,IAAI,EAAE,SAAS,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBAEzF,KAAK,MAAM,YAAY,IAAI,MAAM,EAAE;oBACjC,MAAM,WAAW,GAAW,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC;oBAE1F,IAAI,yBAAyB,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;wBAC/C,SAAS,CAAC,aAAa,CAAC,2BAA2B,0EAEjD,qFAAqF,EACrF,UAAU,EACV,YAAY,CAAC,GAAG,CACjB,CAAC;wBACF,MAAM;qBACP;iBACF;aACF;SACF;QAED,OAAO,mBAAmB,CAAC;IAC7B,CAAC;CACF;AAhED,8CAgEC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport type { Collector } from '../collector/Collector';\r\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\r\n\r\nexport class PackageDocComment {\r\n  /**\r\n   * For the given source file, see if it starts with a TSDoc comment containing the `@packageDocumentation` tag.\r\n   */\r\n  public static tryFindInSourceFile(\r\n    sourceFile: ts.SourceFile,\r\n    collector: Collector\r\n  ): ts.TextRange | undefined {\r\n    // The @packageDocumentation comment is special because it is not attached to an AST\r\n    // definition.  Instead, it is part of the \"trivia\" tokens that the compiler treats\r\n    // as irrelevant white space.\r\n    //\r\n    // WARNING: If the comment doesn't precede an export statement, the compiler will omit\r\n    // it from the *.d.ts file, and API Extractor won't find it.  If this happens, you need\r\n    // to rearrange your statements to ensure it is passed through.\r\n    //\r\n    // This implementation assumes that the \"@packageDocumentation\" will be in the first TSDoc comment\r\n    // that appears in the entry point *.d.ts file.  We could possibly look in other places,\r\n    // but the above warning suggests enforcing a standardized layout.  This design choice is open\r\n    // to feedback.\r\n    let packageCommentRange: ts.TextRange | undefined = undefined; // empty string\r\n\r\n    for (const commentRange of ts.getLeadingCommentRanges(sourceFile.text, sourceFile.getFullStart()) || []) {\r\n      if (commentRange.kind === ts.SyntaxKind.MultiLineCommentTrivia) {\r\n        const commentBody: string = sourceFile.text.substring(commentRange.pos, commentRange.end);\r\n\r\n        // Choose the first JSDoc-style comment\r\n        if (/^\\s*\\/\\*\\*/.test(commentBody)) {\r\n          // But only if it looks like it's trying to be @packageDocumentation\r\n          // (The TSDoc parser will validate this more rigorously)\r\n          if (/\\@packageDocumentation/i.test(commentBody)) {\r\n            packageCommentRange = commentRange;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!packageCommentRange) {\r\n      // If we didn't find the @packageDocumentation tag in the expected place, is it in some\r\n      // wrong place?  This sanity check helps people to figure out why there comment isn't working.\r\n      for (const statement of sourceFile.statements) {\r\n        const ranges: ts.CommentRange[] = [];\r\n        ranges.push(...(ts.getLeadingCommentRanges(sourceFile.text, statement.getFullStart()) || []));\r\n        ranges.push(...(ts.getTrailingCommentRanges(sourceFile.text, statement.getEnd()) || []));\r\n\r\n        for (const commentRange of ranges) {\r\n          const commentBody: string = sourceFile.text.substring(commentRange.pos, commentRange.end);\r\n\r\n          if (/\\@packageDocumentation/i.test(commentBody)) {\r\n            collector.messageRouter.addAnalyzerIssueForPosition(\r\n              ExtractorMessageId.MisplacedPackageTag,\r\n              'The @packageDocumentation comment must appear at the top of entry point *.d.ts file',\r\n              sourceFile,\r\n              commentRange.pos\r\n            );\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return packageCommentRange;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/AstDeclaration.js.map b/lib/analyzer/AstDeclaration.js.map
index 858a1e22c30e08d4783fd2f3d78cccd5da043e90..8904ced198541f8b509ef1b318486e0abdb5cfce 100644
--- a/lib/analyzer/AstDeclaration.js.map
+++ b/lib/analyzer/AstDeclaration.js.map
@@ -1 +1 @@
-{"version":3,"file":"AstDeclaration.js","sourceRoot":"","sources":["../../src/analyzer/AstDeclaration.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,+CAAiC;AAEjC,iCAA8B;AAC9B,oEAA6D;AAY7D;;;;;;;;;;;;;;;;GAgBG;AACH,MAAa,cAAc;IAqCzB,YAAmB,OAA+B;QARlD,4FAA4F;QAC3E,sBAAiB,GAAqB,EAAE,CAAC;QAEzC,sCAAiC,GAAmB,IAAI,GAAG,EAAa,CAAC;QAE1F,gDAAgD;QACxC,oBAAe,GAA8C,SAAS,CAAC;QAG7E,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC;QACvC,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;QAE7B,IAAI,CAAC,SAAS,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;QAE9C,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,IAAI,CAAC,MAAM,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;SACtC;QAED,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC,wBAAwB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAEnE,oDAAoD;QACpD,EAAE;QACF,qCAAqC;QACrC,EAAE;QACF,MAAM,eAAe,GAAmC,EAAE,CAAC,oBAAoB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAClG,IAAI,eAAe,EAAE;YACnB,IAAI,EAAE,CAAC,mBAAmB,CAAC,eAAe,CAAC,EAAE;gBAC3C,sCAAsC;gBACtC,IAAI,CAAC,aAAa,IAAI,EAAE,CAAC,aAAa,CAAC,OAAO,CAAC;aAChD;SACF;IACH,CAAC;IAED;;;;OAIG;IACH,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,EAAE,CAAC;IAC/D,CAAC;IAED;;;;;;;;;;;;;OAaG;IACH,IAAW,qBAAqB;QAC9B,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,iCAAiC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IACpF,CAAC;IAED;;;;OAIG;IACI,kBAAkB,CAAC,KAAqB;QAC7C,IAAI,KAAK,CAAC,MAAM,KAAK,IAAI,EAAE;YACzB,MAAM,IAAI,iCAAa,CAAC,qCAAqC,CAAC,CAAC;SAChE;QAED,IAAI,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE;YAC3B,MAAM,IAAI,iCAAa,CAAC,gEAAgE,CAAC,CAAC;SAC3F;QAED,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACrC,CAAC;IAED;;;OAGG;IACI,OAAO,CAAC,SAAiB,EAAE;QAChC,MAAM,eAAe,GAAW,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACrE,IAAI,MAAM,GAAW,MAAM,GAAG,KAAK,IAAI,CAAC,SAAS,CAAC,SAAS,KAAK,eAAe,GAAG,CAAC;QACnF,IAAI,IAAI,CAAC,SAAS,CAAC,eAAe,EAAE;YAClC,MAAM,IAAI,YAAY,CAAC;SACxB;QACD,MAAM,IAAI,IAAI,CAAC;QAEf,KAAK,MAAM,mBAAmB,IAAI,IAAI,CAAC,iCAAiC,CAAC,MAAM,EAAE,EAAE;YACjF,MAAM,IAAI,MAAM,GAAG,UAAU,mBAAmB,CAAC,SAAS,IAAI,CAAC;SAChE;QAED,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjC,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC;SACxC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;OAGG;IACI,WAAW,CAAC,SAAiB,EAAE;QACpC,MAAM,IAAI,GAAS,IAAI,WAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC9C,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IAC9B,CAAC;IAED;;;;OAIG;IACI,0BAA0B,CAAC,mBAA8B;QAC9D,IAAI,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE;YAC3B,MAAM,IAAI,iCAAa,CAAC,wEAAwE,CAAC,CAAC;SACnG;QAED,KAAK,IAAI,OAAO,GAA+B,IAAI,EAAE,OAAO,EAAE,OAAO,GAAG,OAAO,CAAC,MAAM,EAAE;YACtF,0EAA0E;YAC1E,IAAI,OAAO,CAAC,iCAAiC,CAAC,GAAG,CAAC,mBAAmB,CAAC,EAAE;gBACtE,OAAO;aACR;YACD,0CAA0C;YAC1C,IAAI,mBAAmB,KAAK,OAAO,CAAC,SAAS,EAAE;gBAC7C,OAAO;aACR;SACF;QAED,IAAI,CAAC,iCAAiC,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC;IAClE,CAAC;IAED;;;OAGG;IACI,2BAA2B,CAAC,MAAgD;QACjF,MAAM,CAAC,IAAI,CAAC,CAAC;QACb,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjC,KAAK,CAAC,2BAA2B,CAAC,MAAM,CAAC,CAAC;SAC3C;IACH,CAAC;IAED;;;;;OAKG;IACI,oBAAoB,CAAC,IAAY;QACtC,iCAAiC;QACjC,EAAE;QACF,mEAAmE;QACnE,EAAE;QACF,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,IAAI,IAAI,CAAC,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAAE;YACnE,OAAO,EAAE,CAAC;SACX;QAED,IAAI,IAAI,CAAC,eAAe,KAAK,SAAS,EAAE;YACtC,yBAAyB;YACzB,MAAM,cAAc,GAAkC,IAAI,GAAG,EAA4B,CAAC;YAE1F,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,iBAAiB,EAAE;gBAC1C,MAAM,SAAS,GAAW,KAAK,CAAC,SAAS,CAAC,SAAS,CAAC;gBACpD,IAAI,KAAK,GAAiC,cAAc,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBACxE,IAAI,KAAK,KAAK,SAAS,EAAE;oBACvB,KAAK,GAAG,EAAE,CAAC;oBACX,cAAc,CAAC,GAAG,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;iBACtC;gBACD,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aACnB;YACD,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;SACvC;QAED,OAAO,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;IAC9C,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,qBAAqB,CAAC,IAAmB;QACrD,uBAAuB;QACvB,QAAQ,IAAI,EAAE;YACZ,KAAK,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC;YACjC,KAAK,EAAE,CAAC,UAAU,CAAC,gBAAgB,CAAC;YACpC,KAAK,EAAE,CAAC,UAAU,CAAC,kBAAkB,CAAC,CAAC,sCAAsC;YAC7E,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,oCAAoC;YACpE,KAAK,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC;YACnC,KAAK,EAAE,CAAC,UAAU,CAAC,UAAU,CAAC;YAC9B,KAAK,EAAE,CAAC,UAAU,CAAC,mBAAmB,CAAC,CAAC,iCAAiC;YACzE,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW,CAAC;YAC/B,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW,CAAC;YAC/B,KAAK,EAAE,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC,mCAAmC;YACtE,KAAK,EAAE,CAAC,UAAU,CAAC,oBAAoB,CAAC;YACxC,KAAK,EAAE,CAAC,UAAU,CAAC,iBAAiB,CAAC;YACrC,KAAK,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC;YACnC,KAAK,EAAE,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC,sDAAsD;YAC5F,KAAK,EAAE,CAAC,UAAU,CAAC,mBAAmB,CAAC;YACvC,KAAK,EAAE,CAAC,UAAU,CAAC,iBAAiB,CAAC;YACrC,KAAK,EAAE,CAAC,UAAU,CAAC,oBAAoB,CAAC,CAAC,0CAA0C;YACnF,KAAK,EAAE,CAAC,UAAU,CAAC,mBAAmB;gBACpC,OAAO,IAAI,CAAC;YAEd,gHAAgH;YAChH,0CAA0C;YAE1C,gGAAgG;YAChG,8FAA8F;YAC9F,4FAA4F;YAC5F,gGAAgG;YAChG,0DAA0D;SAC3D;QAED,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AAvPD,wCAuPC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\nimport type { AstSymbol } from './AstSymbol';\nimport { Span } from './Span';\nimport { InternalError } from '@rushstack/node-core-library';\nimport type { AstEntity } from './AstEntity';\n\n/**\n * Constructor options for AstDeclaration\n */\nexport interface IAstDeclarationOptions {\n  readonly declaration: ts.Declaration;\n  readonly astSymbol: AstSymbol;\n  readonly parent: AstDeclaration | undefined;\n}\n\n/**\n * The AstDeclaration and AstSymbol classes are API Extractor's equivalent of the compiler's\n * ts.Declaration and ts.Symbol objects.  They are created by the `AstSymbolTable` class.\n *\n * @remarks\n * The AstDeclaration represents one or more syntax components of a symbol.  Usually there is\n * only one AstDeclaration per AstSymbol, but certain TypeScript constructs can have multiple\n * declarations (e.g. overloaded functions, merged declarations, etc.).\n *\n * Because of this, the `AstDeclaration` manages the parent/child nesting hierarchy (e.g. with\n * declaration merging, each declaration has its own children) and becomes the main focus\n * of analyzing AEDoc and emitting *.d.ts files.\n *\n * The AstDeclarations correspond to items from the compiler's ts.Node hierarchy, but\n * omitting/skipping any nodes that don't match the AstDeclaration.isSupportedSyntaxKind()\n * criteria.  This simplification makes the other API Extractor stages easier to implement.\n */\nexport class AstDeclaration {\n  public readonly declaration: ts.Declaration;\n\n  public readonly astSymbol: AstSymbol;\n\n  /**\n   * The parent, if this object is nested inside another AstDeclaration.\n   */\n  public readonly parent: AstDeclaration | undefined;\n\n  /**\n   * A bit set of TypeScript modifiers such as \"private\", \"protected\", etc.\n   */\n  public readonly modifierFlags: ts.ModifierFlags;\n\n  /**\n   * Additional information that is calculated later by the `Collector`.  The actual type is `DeclarationMetadata`,\n   * but we declare it as `unknown` because consumers must obtain this object by calling\n   * `Collector.fetchDeclarationMetadata()`.\n   */\n  public declarationMetadata: unknown;\n\n  /**\n   * Additional information that is calculated later by the `Collector`.  The actual type is `ApiItemMetadata`,\n   * but we declare it as `unknown` because consumers must obtain this object by calling\n   * `Collector.fetchApiItemMetadata()`.\n   */\n  public apiItemMetadata: unknown;\n\n  // NOTE: This array becomes immutable after astSymbol.analyze() sets astSymbol.analyzed=true\n  private readonly _analyzedChildren: AstDeclaration[] = [];\n\n  private readonly _analyzedReferencedAstEntitiesSet: Set<AstEntity> = new Set<AstEntity>();\n\n  // Reverse lookup used by findChildrenWithName()\n  private _childrenByName: Map<string, AstDeclaration[]> | undefined = undefined;\n\n  public constructor(options: IAstDeclarationOptions) {\n    this.declaration = options.declaration;\n    this.astSymbol = options.astSymbol;\n    this.parent = options.parent;\n\n    this.astSymbol._notifyDeclarationAttach(this);\n\n    if (this.parent) {\n      this.parent._notifyChildAttach(this);\n    }\n\n    this.modifierFlags = ts.getCombinedModifierFlags(this.declaration);\n\n    // Check for ECMAScript private fields, for example:\n    //\n    //    class Person { #name: string; }\n    //\n    const declarationName: ts.DeclarationName | undefined = ts.getNameOfDeclaration(this.declaration);\n    if (declarationName) {\n      if (ts.isPrivateIdentifier(declarationName)) {\n        // eslint-disable-next-line no-bitwise\n        this.modifierFlags |= ts.ModifierFlags.Private;\n      }\n    }\n  }\n\n  /**\n   * Returns the children for this AstDeclaration.\n   * @remarks\n   * The collection will be empty until AstSymbol.analyzed is true.\n   */\n  public get children(): ReadonlyArray<AstDeclaration> {\n    return this.astSymbol.analyzed ? this._analyzedChildren : [];\n  }\n\n  /**\n   * Returns the AstEntity objects referenced by this node.\n   * @remarks\n   * NOTE: The collection will be empty until AstSymbol.analyzed is true.\n   *\n   * Since we assume references are always collected by a traversal starting at the\n   * root of the nesting declarations, this array omits the following items because they\n   * would be redundant:\n   * - symbols corresponding to parents of this declaration (e.g. a method that returns its own class)\n   * - symbols already listed in the referencedAstSymbols property for parents of this declaration\n   *   (e.g. a method that returns its own class's base class)\n   * - symbols that are referenced only by nested children of this declaration\n   *   (e.g. if a method returns an enum, this doesn't imply that the method's class references that enum)\n   */\n  public get referencedAstEntities(): ReadonlyArray<AstEntity> {\n    return this.astSymbol.analyzed ? [...this._analyzedReferencedAstEntitiesSet] : [];\n  }\n\n  /**\n   * This is an internal callback used when the AstSymbolTable attaches a new\n   * child AstDeclaration to this object.\n   * @internal\n   */\n  public _notifyChildAttach(child: AstDeclaration): void {\n    if (child.parent !== this) {\n      throw new InternalError('Invalid call to notifyChildAttach()');\n    }\n\n    if (this.astSymbol.analyzed) {\n      throw new InternalError('_notifyChildAttach() called after analysis is already complete');\n    }\n\n    this._analyzedChildren.push(child);\n  }\n\n  /**\n   * Returns a diagnostic dump of the tree, which reports the hierarchy of\n   * AstDefinition objects.\n   */\n  public getDump(indent: string = ''): string {\n    const declarationKind: string = ts.SyntaxKind[this.declaration.kind];\n    let result: string = indent + `+ ${this.astSymbol.localName} (${declarationKind})`;\n    if (this.astSymbol.nominalAnalysis) {\n      result += ' (nominal)';\n    }\n    result += '\\n';\n\n    for (const referencedAstEntity of this._analyzedReferencedAstEntitiesSet.values()) {\n      result += indent + `  ref: ${referencedAstEntity.localName}\\n`;\n    }\n\n    for (const child of this.children) {\n      result += child.getDump(indent + '  ');\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns a diagnostic dump using Span.getDump(), which reports the detailed\n   * compiler structure.\n   */\n  public getSpanDump(indent: string = ''): string {\n    const span: Span = new Span(this.declaration);\n    return span.getDump(indent);\n  }\n\n  /**\n   * This is an internal callback used when AstSymbolTable.analyze() discovers a new\n   * type reference associated with this declaration.\n   * @internal\n   */\n  public _notifyReferencedAstEntity(referencedAstEntity: AstEntity): void {\n    if (this.astSymbol.analyzed) {\n      throw new InternalError('_notifyReferencedAstEntity() called after analysis is already complete');\n    }\n\n    for (let current: AstDeclaration | undefined = this; current; current = current.parent) {\n      // Don't add references to symbols that are already referenced by a parent\n      if (current._analyzedReferencedAstEntitiesSet.has(referencedAstEntity)) {\n        return;\n      }\n      // Don't add the symbols of parents either\n      if (referencedAstEntity === current.astSymbol) {\n        return;\n      }\n    }\n\n    this._analyzedReferencedAstEntitiesSet.add(referencedAstEntity);\n  }\n\n  /**\n   * Visits all the current declaration and all children recursively in a depth-first traversal,\n   * and performs the specified action for each one.\n   */\n  public forEachDeclarationRecursive(action: (astDeclaration: AstDeclaration) => void): void {\n    action(this);\n    for (const child of this.children) {\n      child.forEachDeclarationRecursive(action);\n    }\n  }\n\n  /**\n   * Returns the list of child declarations whose `AstSymbol.localName` matches the provided `name`.\n   *\n   * @remarks\n   * This is an efficient O(1) lookup.\n   */\n  public findChildrenWithName(name: string): ReadonlyArray<AstDeclaration> {\n    // The children property returns:\n    //\n    //    return this.astSymbol.analyzed ? this._analyzedChildren : [];\n    //\n    if (!this.astSymbol.analyzed || this._analyzedChildren.length === 0) {\n      return [];\n    }\n\n    if (this._childrenByName === undefined) {\n      // Build the lookup table\n      const childrenByName: Map<string, AstDeclaration[]> = new Map<string, AstDeclaration[]>();\n\n      for (const child of this._analyzedChildren) {\n        const childName: string = child.astSymbol.localName;\n        let array: AstDeclaration[] | undefined = childrenByName.get(childName);\n        if (array === undefined) {\n          array = [];\n          childrenByName.set(childName, array);\n        }\n        array.push(child);\n      }\n      this._childrenByName = childrenByName;\n    }\n\n    return this._childrenByName.get(name) || [];\n  }\n\n  /**\n   * This function determines which ts.Node kinds will generate an AstDeclaration.\n   * These correspond to the definitions that we can add AEDoc to.\n   */\n  public static isSupportedSyntaxKind(kind: ts.SyntaxKind): boolean {\n    // (alphabetical order)\n    switch (kind) {\n      case ts.SyntaxKind.CallSignature:\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.ConstructSignature: // Example: \"new(x: number): IMyClass\"\n      case ts.SyntaxKind.Constructor: // Example: \"constructor(x: number)\"\n      case ts.SyntaxKind.EnumDeclaration:\n      case ts.SyntaxKind.EnumMember:\n      case ts.SyntaxKind.FunctionDeclaration: // Example: \"(x: number): number\"\n      case ts.SyntaxKind.GetAccessor:\n      case ts.SyntaxKind.SetAccessor:\n      case ts.SyntaxKind.IndexSignature: // Example: \"[key: string]: string\"\n      case ts.SyntaxKind.InterfaceDeclaration:\n      case ts.SyntaxKind.MethodDeclaration:\n      case ts.SyntaxKind.MethodSignature:\n      case ts.SyntaxKind.ModuleDeclaration: // Used for both \"module\" and \"namespace\" declarations\n      case ts.SyntaxKind.PropertyDeclaration:\n      case ts.SyntaxKind.PropertySignature:\n      case ts.SyntaxKind.TypeAliasDeclaration: // Example: \"type Shape = Circle | Square\"\n      case ts.SyntaxKind.VariableDeclaration:\n        return true;\n\n      // NOTE: Prior to TypeScript 3.7, in the emitted .d.ts files, the compiler would merge a GetAccessor/SetAccessor\n      // pair into a single PropertyDeclaration.\n\n      // NOTE: In contexts where a source file is treated as a module, we do create \"nominal analysis\"\n      // AstSymbol objects corresponding to a ts.SyntaxKind.SourceFile node.  However, a source file\n      // is NOT considered a nesting structure, and it does NOT act as a root for the declarations\n      // appearing in the file.  This is because the *.d.ts generator is in the business of rolling up\n      // source files, and thus wants to ignore them in general.\n    }\n\n    return false;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"AstDeclaration.js","sourceRoot":"","sources":["../../src/analyzer/AstDeclaration.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport type { AstSymbol } from './AstSymbol';\r\nimport { Span } from './Span';\r\nimport { InternalError } from '@rushstack/node-core-library';\r\nimport type { AstEntity } from './AstEntity';\r\n\r\n/**\r\n * Constructor options for AstDeclaration\r\n */\r\nexport interface IAstDeclarationOptions {\r\n  readonly declaration: ts.Declaration;\r\n  readonly astSymbol: AstSymbol;\r\n  readonly parent: AstDeclaration | undefined;\r\n}\r\n\r\n/**\r\n * The AstDeclaration and AstSymbol classes are API Extractor's equivalent of the compiler's\r\n * ts.Declaration and ts.Symbol objects.  They are created by the `AstSymbolTable` class.\r\n *\r\n * @remarks\r\n * The AstDeclaration represents one or more syntax components of a symbol.  Usually there is\r\n * only one AstDeclaration per AstSymbol, but certain TypeScript constructs can have multiple\r\n * declarations (e.g. overloaded functions, merged declarations, etc.).\r\n *\r\n * Because of this, the `AstDeclaration` manages the parent/child nesting hierarchy (e.g. with\r\n * declaration merging, each declaration has its own children) and becomes the main focus\r\n * of analyzing AEDoc and emitting *.d.ts files.\r\n *\r\n * The AstDeclarations correspond to items from the compiler's ts.Node hierarchy, but\r\n * omitting/skipping any nodes that don't match the AstDeclaration.isSupportedSyntaxKind()\r\n * criteria.  This simplification makes the other API Extractor stages easier to implement.\r\n */\r\nexport class AstDeclaration {\r\n  public readonly declaration: ts.Declaration;\r\n\r\n  public readonly astSymbol: AstSymbol;\r\n\r\n  /**\r\n   * The parent, if this object is nested inside another AstDeclaration.\r\n   */\r\n  public readonly parent: AstDeclaration | undefined;\r\n\r\n  /**\r\n   * A bit set of TypeScript modifiers such as \"private\", \"protected\", etc.\r\n   */\r\n  public readonly modifierFlags: ts.ModifierFlags;\r\n\r\n  /**\r\n   * Additional information that is calculated later by the `Collector`.  The actual type is `DeclarationMetadata`,\r\n   * but we declare it as `unknown` because consumers must obtain this object by calling\r\n   * `Collector.fetchDeclarationMetadata()`.\r\n   */\r\n  public declarationMetadata: unknown;\r\n\r\n  /**\r\n   * Additional information that is calculated later by the `Collector`.  The actual type is `ApiItemMetadata`,\r\n   * but we declare it as `unknown` because consumers must obtain this object by calling\r\n   * `Collector.fetchApiItemMetadata()`.\r\n   */\r\n  public apiItemMetadata: unknown;\r\n\r\n  // NOTE: This array becomes immutable after astSymbol.analyze() sets astSymbol.analyzed=true\r\n  private readonly _analyzedChildren: AstDeclaration[] = [];\r\n\r\n  private readonly _analyzedReferencedAstEntitiesSet: Set<AstEntity> = new Set<AstEntity>();\r\n\r\n  // Reverse lookup used by findChildrenWithName()\r\n  private _childrenByName: Map<string, AstDeclaration[]> | undefined = undefined;\r\n\r\n  public constructor(options: IAstDeclarationOptions) {\r\n    this.declaration = options.declaration;\r\n    this.astSymbol = options.astSymbol;\r\n    this.parent = options.parent;\r\n\r\n    this.astSymbol._notifyDeclarationAttach(this);\r\n\r\n    if (this.parent) {\r\n      this.parent._notifyChildAttach(this);\r\n    }\r\n\r\n    this.modifierFlags = ts.getCombinedModifierFlags(this.declaration);\r\n\r\n    // Check for ECMAScript private fields, for example:\r\n    //\r\n    //    class Person { #name: string; }\r\n    //\r\n    const declarationName: ts.DeclarationName | undefined = ts.getNameOfDeclaration(this.declaration);\r\n    if (declarationName) {\r\n      if (ts.isPrivateIdentifier(declarationName)) {\r\n        // eslint-disable-next-line no-bitwise\r\n        this.modifierFlags |= ts.ModifierFlags.Private;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the children for this AstDeclaration.\r\n   * @remarks\r\n   * The collection will be empty until AstSymbol.analyzed is true.\r\n   */\r\n  public get children(): ReadonlyArray<AstDeclaration> {\r\n    return this.astSymbol.analyzed ? this._analyzedChildren : [];\r\n  }\r\n\r\n  /**\r\n   * Returns the AstEntity objects referenced by this node.\r\n   * @remarks\r\n   * NOTE: The collection will be empty until AstSymbol.analyzed is true.\r\n   *\r\n   * Since we assume references are always collected by a traversal starting at the\r\n   * root of the nesting declarations, this array omits the following items because they\r\n   * would be redundant:\r\n   * - symbols corresponding to parents of this declaration (e.g. a method that returns its own class)\r\n   * - symbols already listed in the referencedAstSymbols property for parents of this declaration\r\n   *   (e.g. a method that returns its own class's base class)\r\n   * - symbols that are referenced only by nested children of this declaration\r\n   *   (e.g. if a method returns an enum, this doesn't imply that the method's class references that enum)\r\n   */\r\n  public get referencedAstEntities(): ReadonlyArray<AstEntity> {\r\n    return this.astSymbol.analyzed ? [...this._analyzedReferencedAstEntitiesSet] : [];\r\n  }\r\n\r\n  /**\r\n   * This is an internal callback used when the AstSymbolTable attaches a new\r\n   * child AstDeclaration to this object.\r\n   * @internal\r\n   */\r\n  public _notifyChildAttach(child: AstDeclaration): void {\r\n    if (child.parent !== this) {\r\n      throw new InternalError('Invalid call to notifyChildAttach()');\r\n    }\r\n\r\n    if (this.astSymbol.analyzed) {\r\n      throw new InternalError('_notifyChildAttach() called after analysis is already complete');\r\n    }\r\n\r\n    this._analyzedChildren.push(child);\r\n  }\r\n\r\n  /**\r\n   * Returns a diagnostic dump of the tree, which reports the hierarchy of\r\n   * AstDefinition objects.\r\n   */\r\n  public getDump(indent: string = ''): string {\r\n    const declarationKind: string = ts.SyntaxKind[this.declaration.kind];\r\n    let result: string = indent + `+ ${this.astSymbol.localName} (${declarationKind})`;\r\n    if (this.astSymbol.nominalAnalysis) {\r\n      result += ' (nominal)';\r\n    }\r\n    result += '\\n';\r\n\r\n    for (const referencedAstEntity of this._analyzedReferencedAstEntitiesSet.values()) {\r\n      result += indent + `  ref: ${referencedAstEntity.localName}\\n`;\r\n    }\r\n\r\n    for (const child of this.children) {\r\n      result += child.getDump(indent + '  ');\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a diagnostic dump using Span.getDump(), which reports the detailed\r\n   * compiler structure.\r\n   */\r\n  public getSpanDump(indent: string = ''): string {\r\n    const span: Span = new Span(this.declaration);\r\n    return span.getDump(indent);\r\n  }\r\n\r\n  /**\r\n   * This is an internal callback used when AstSymbolTable.analyze() discovers a new\r\n   * type reference associated with this declaration.\r\n   * @internal\r\n   */\r\n  public _notifyReferencedAstEntity(referencedAstEntity: AstEntity): void {\r\n    if (this.astSymbol.analyzed) {\r\n      throw new InternalError('_notifyReferencedAstEntity() called after analysis is already complete');\r\n    }\r\n\r\n    for (let current: AstDeclaration | undefined = this; current; current = current.parent) {\r\n      // Don't add references to symbols that are already referenced by a parent\r\n      if (current._analyzedReferencedAstEntitiesSet.has(referencedAstEntity)) {\r\n        return;\r\n      }\r\n      // Don't add the symbols of parents either\r\n      if (referencedAstEntity === current.astSymbol) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    this._analyzedReferencedAstEntitiesSet.add(referencedAstEntity);\r\n  }\r\n\r\n  /**\r\n   * Visits all the current declaration and all children recursively in a depth-first traversal,\r\n   * and performs the specified action for each one.\r\n   */\r\n  public forEachDeclarationRecursive(action: (astDeclaration: AstDeclaration) => void): void {\r\n    action(this);\r\n    for (const child of this.children) {\r\n      child.forEachDeclarationRecursive(action);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the list of child declarations whose `AstSymbol.localName` matches the provided `name`.\r\n   *\r\n   * @remarks\r\n   * This is an efficient O(1) lookup.\r\n   */\r\n  public findChildrenWithName(name: string): ReadonlyArray<AstDeclaration> {\r\n    // The children property returns:\r\n    //\r\n    //    return this.astSymbol.analyzed ? this._analyzedChildren : [];\r\n    //\r\n    if (!this.astSymbol.analyzed || this._analyzedChildren.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    if (this._childrenByName === undefined) {\r\n      // Build the lookup table\r\n      const childrenByName: Map<string, AstDeclaration[]> = new Map<string, AstDeclaration[]>();\r\n\r\n      for (const child of this._analyzedChildren) {\r\n        const childName: string = child.astSymbol.localName;\r\n        let array: AstDeclaration[] | undefined = childrenByName.get(childName);\r\n        if (array === undefined) {\r\n          array = [];\r\n          childrenByName.set(childName, array);\r\n        }\r\n        array.push(child);\r\n      }\r\n      this._childrenByName = childrenByName;\r\n    }\r\n\r\n    return this._childrenByName.get(name) || [];\r\n  }\r\n\r\n  /**\r\n   * This function determines which ts.Node kinds will generate an AstDeclaration.\r\n   * These correspond to the definitions that we can add AEDoc to.\r\n   */\r\n  public static isSupportedSyntaxKind(kind: ts.SyntaxKind): boolean {\r\n    // (alphabetical order)\r\n    switch (kind) {\r\n      case ts.SyntaxKind.CallSignature:\r\n      case ts.SyntaxKind.ClassDeclaration:\r\n      case ts.SyntaxKind.ConstructSignature: // Example: \"new(x: number): IMyClass\"\r\n      case ts.SyntaxKind.Constructor: // Example: \"constructor(x: number)\"\r\n      case ts.SyntaxKind.EnumDeclaration:\r\n      case ts.SyntaxKind.EnumMember:\r\n      case ts.SyntaxKind.FunctionDeclaration: // Example: \"(x: number): number\"\r\n      case ts.SyntaxKind.GetAccessor:\r\n      case ts.SyntaxKind.SetAccessor:\r\n      case ts.SyntaxKind.IndexSignature: // Example: \"[key: string]: string\"\r\n      case ts.SyntaxKind.InterfaceDeclaration:\r\n      case ts.SyntaxKind.MethodDeclaration:\r\n      case ts.SyntaxKind.MethodSignature:\r\n      case ts.SyntaxKind.ModuleDeclaration: // Used for both \"module\" and \"namespace\" declarations\r\n      case ts.SyntaxKind.PropertyDeclaration:\r\n      case ts.SyntaxKind.PropertySignature:\r\n      case ts.SyntaxKind.TypeAliasDeclaration: // Example: \"type Shape = Circle | Square\"\r\n      case ts.SyntaxKind.VariableDeclaration:\r\n        return true;\r\n\r\n      // NOTE: Prior to TypeScript 3.7, in the emitted .d.ts files, the compiler would merge a GetAccessor/SetAccessor\r\n      // pair into a single PropertyDeclaration.\r\n\r\n      // NOTE: In contexts where a source file is treated as a module, we do create \"nominal analysis\"\r\n      // AstSymbol objects corresponding to a ts.SyntaxKind.SourceFile node.  However, a source file\r\n      // is NOT considered a nesting structure, and it does NOT act as a root for the declarations\r\n      // appearing in the file.  This is because the *.d.ts generator is in the business of rolling up\r\n      // source files, and thus wants to ignore them in general.\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/AstEntity.js.map b/lib/analyzer/AstEntity.js.map
index 388313f7089b6e0e8625cf53f373d7eccd029def..a9520c263f75031026fcf1e2c18efa0ef24157ca 100644
--- a/lib/analyzer/AstEntity.js.map
+++ b/lib/analyzer/AstEntity.js.map
@@ -1 +1 @@
-{"version":3,"file":"AstEntity.js","sourceRoot":"","sources":["../../src/analyzer/AstEntity.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D;;;;;;;;;;;;;GAaG;AACH,MAAsB,SAAS;CAY9B;AAZD,8BAYC;AAED;;;;;;;;;;;;;GAaG;AACH,MAAsB,kBAAmB,SAAQ,SAAS;CAAG;AAA7D,gDAA6D","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/**\n * `AstEntity` is the abstract base class for analyzer objects that can become a `CollectorEntity`.\n *\n * @remarks\n *\n * The subclasses are:\n * ```\n * - AstEntity\n *   - AstSymbol\n *   - AstSyntheticEntity\n *     - AstImport\n *     - AstNamespaceImport\n * ```\n */\nexport abstract class AstEntity {\n  /**\n   * The original name of the symbol, as exported from the module (i.e. source file)\n   * containing the original TypeScript definition.  Constructs such as\n   * `import { X as Y } from` may introduce other names that differ from the local name.\n   *\n   * @remarks\n   * For the most part, `localName` corresponds to `followedSymbol.name`, but there\n   * are some edge cases.  For example, the ts.Symbol.name for `export default class X { }`\n   * is actually `\"default\"`, not `\"X\"`.\n   */\n  public abstract readonly localName: string;\n}\n\n/**\n * `AstSyntheticEntity` is the abstract base class for analyzer objects whose emitted declarations\n * are not text transformations performed by the `Span` helper.\n *\n * @remarks\n * Most of API Extractor's output is produced by using the using the `Span` utility to regurgitate strings from\n * the input .d.ts files.  If we need to rename an identifier, the `Span` visitor can pick out an interesting\n * node and rewrite its string, but otherwise the transformation operates on dumb text and not compiler concepts.\n * (Historically we did this because the compiler's emitter was an internal API, but it still has some advantages,\n * for example preserving syntaxes generated by an older compiler to avoid incompatibilities.)\n *\n * This strategy does not work for cases where the output looks very different from the input.  Today these\n * cases are always kinds of `import` statements, but that may change in the future.\n */\nexport abstract class AstSyntheticEntity extends AstEntity {}\n"]}
\ No newline at end of file
+{"version":3,"file":"AstEntity.js","sourceRoot":"","sources":["../../src/analyzer/AstEntity.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D;;;;;;;;;;;;;GAaG;AACH,MAAsB,SAAS;CAY9B;AAZD,8BAYC;AAED;;;;;;;;;;;;;GAaG;AACH,MAAsB,kBAAmB,SAAQ,SAAS;CAAG;AAA7D,gDAA6D","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/**\r\n * `AstEntity` is the abstract base class for analyzer objects that can become a `CollectorEntity`.\r\n *\r\n * @remarks\r\n *\r\n * The subclasses are:\r\n * ```\r\n * - AstEntity\r\n *   - AstSymbol\r\n *   - AstSyntheticEntity\r\n *     - AstImport\r\n *     - AstNamespaceImport\r\n * ```\r\n */\r\nexport abstract class AstEntity {\r\n  /**\r\n   * The original name of the symbol, as exported from the module (i.e. source file)\r\n   * containing the original TypeScript definition.  Constructs such as\r\n   * `import { X as Y } from` may introduce other names that differ from the local name.\r\n   *\r\n   * @remarks\r\n   * For the most part, `localName` corresponds to `followedSymbol.name`, but there\r\n   * are some edge cases.  For example, the ts.Symbol.name for `export default class X { }`\r\n   * is actually `\"default\"`, not `\"X\"`.\r\n   */\r\n  public abstract readonly localName: string;\r\n}\r\n\r\n/**\r\n * `AstSyntheticEntity` is the abstract base class for analyzer objects whose emitted declarations\r\n * are not text transformations performed by the `Span` helper.\r\n *\r\n * @remarks\r\n * Most of API Extractor's output is produced by using the using the `Span` utility to regurgitate strings from\r\n * the input .d.ts files.  If we need to rename an identifier, the `Span` visitor can pick out an interesting\r\n * node and rewrite its string, but otherwise the transformation operates on dumb text and not compiler concepts.\r\n * (Historically we did this because the compiler's emitter was an internal API, but it still has some advantages,\r\n * for example preserving syntaxes generated by an older compiler to avoid incompatibilities.)\r\n *\r\n * This strategy does not work for cases where the output looks very different from the input.  Today these\r\n * cases are always kinds of `import` statements, but that may change in the future.\r\n */\r\nexport abstract class AstSyntheticEntity extends AstEntity {}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/AstImport.js.map b/lib/analyzer/AstImport.js.map
index 6043903e4d4caffaf3d015f115fa65c2685cb029..788aabe87b7fa5b3f6e505cefc3f5d24fa508a70 100644
--- a/lib/analyzer/AstImport.js.map
+++ b/lib/analyzer/AstImport.js.map
@@ -1 +1 @@
-{"version":3,"file":"AstImport.js","sourceRoot":"","sources":["../../src/analyzer/AstImport.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAG3D,oEAA6D;AAC7D,2CAAiD;AAEjD;;GAEG;AACH,IAAY,aAyBX;AAzBD,WAAY,aAAa;IACvB;;OAEG;IACH,mEAAa,CAAA;IAEb;;OAEG;IACH,+DAAW,CAAA;IAEX;;OAEG;IACH,6DAAU,CAAA;IAEV;;OAEG;IACH,iEAAY,CAAA;IAEZ;;OAEG;IACH,6DAAU,CAAA;AACZ,CAAC,EAzBW,aAAa,GAAb,qBAAa,KAAb,qBAAa,QAyBxB;AAkBD;;;GAGG;AACH,MAAa,SAAU,SAAQ,8BAAkB;IA+D/C,YAAmB,OAA0B;QAC3C,KAAK,EAAE,CAAC;QAER,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACrC,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACrC,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QAErC,sGAAsG;QACtG,IAAI,CAAC,oBAAoB,GAAG,OAAO,CAAC,UAAU,CAAC;QAE/C,IAAI,CAAC,GAAG,GAAG,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IACvC,CAAC;IAED,oBAAoB;IACpB,IAAW,SAAS;QAClB,WAAW;QACX,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,MAAM,CAAC,OAA0B;QAC7C,QAAQ,OAAO,CAAC,UAAU,EAAE;YAC1B,KAAK,aAAa,CAAC,aAAa;gBAC9B,OAAO,GAAG,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,EAAE,CAAC;YACvD,KAAK,aAAa,CAAC,WAAW;gBAC5B,OAAO,GAAG,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,EAAE,CAAC;YACvD,KAAK,aAAa,CAAC,UAAU;gBAC3B,OAAO,GAAG,OAAO,CAAC,UAAU,IAAI,CAAC;YACnC,KAAK,aAAa,CAAC,YAAY;gBAC7B,OAAO,GAAG,OAAO,CAAC,UAAU,IAAI,CAAC;YACnC,KAAK,aAAa,CAAC,UAAU,CAAC,CAAC;gBAC7B,MAAM,MAAM,GAAW,CAAC,OAAO,CAAC,UAAU;oBACxC,CAAC,CAAC,GAAG,CAAC,2BAA2B;oBACjC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,+BAA+B;wBAClE,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;wBAClC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC;gBACvB,OAAO,GAAG,OAAO,CAAC,UAAU,IAAI,MAAM,EAAE,CAAC;aAC1C;YACD;gBACE,MAAM,IAAI,iCAAa,CAAC,uBAAuB,CAAC,CAAC;SACpD;IACH,CAAC;CACF;AA3GD,8BA2GC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { AstSymbol } from './AstSymbol';\nimport { InternalError } from '@rushstack/node-core-library';\nimport { AstSyntheticEntity } from './AstEntity';\n\n/**\n * Indicates the import kind for an `AstImport`.\n */\nexport enum AstImportKind {\n  /**\n   * An import statement such as `import X from \"y\";`.\n   */\n  DefaultImport,\n\n  /**\n   * An import statement such as `import { X } from \"y\";`.\n   */\n  NamedImport,\n\n  /**\n   * An import statement such as `import * as x from \"y\";`.\n   */\n  StarImport,\n\n  /**\n   * An import statement such as `import x = require(\"y\");`.\n   */\n  EqualsImport,\n\n  /**\n   * An import statement such as `interface foo { foo: import(\"bar\").a.b.c }`.\n   */\n  ImportType\n}\n\n/**\n * Constructor parameters for AstImport\n *\n * @privateRemarks\n * Our naming convention is to use I____Parameters for constructor options and\n * I____Options for general function options.  However the word \"parameters\" is\n * confusingly similar to the terminology for function parameters modeled by API Extractor,\n * so we use I____Options for both cases in this code base.\n */\nexport interface IAstImportOptions {\n  readonly importKind: AstImportKind;\n  readonly modulePath: string;\n  readonly exportName: string;\n  readonly isTypeOnly: boolean;\n}\n\n/**\n * For a symbol that was imported from an external package, this tracks the import\n * statement that was used to reach it.\n */\nexport class AstImport extends AstSyntheticEntity {\n  public readonly importKind: AstImportKind;\n\n  /**\n   * The name of the external package (and possibly module path) that this definition\n   * was imported from.\n   *\n   * Example: \"@rushstack/node-core-library/lib/FileSystem\"\n   */\n  public readonly modulePath: string;\n\n  /**\n   * The name of the symbol being imported.\n   *\n   * @remarks\n   *\n   * The name depends on the type of import:\n   *\n   * ```ts\n   * // For AstImportKind.DefaultImport style, exportName would be \"X\" in this example:\n   * import X from \"y\";\n   *\n   * // For AstImportKind.NamedImport style, exportName would be \"X\" in this example:\n   * import { X } from \"y\";\n   *\n   * // For AstImportKind.StarImport style, exportName would be \"x\" in this example:\n   * import * as x from \"y\";\n   *\n   * // For AstImportKind.EqualsImport style, exportName would be \"x\" in this example:\n   * import x = require(\"y\");\n   *\n   * // For AstImportKind.ImportType style, exportName would be \"a.b.c\" in this example:\n   * interface foo { foo: import('bar').a.b.c };\n   * ```\n   */\n  public readonly exportName: string;\n\n  /**\n   * Whether it is a type-only import, for example:\n   *\n   * ```ts\n   * import type { X } from \"y\";\n   * ```\n   *\n   * This is set to true ONLY if the type-only form is used in *every* reference to this AstImport.\n   */\n  public isTypeOnlyEverywhere: boolean;\n\n  /**\n   * If this import statement refers to an API from an external package that is tracked by API Extractor\n   * (according to `PackageMetadataManager.isAedocSupportedFor()`), then this property will return the\n   * corresponding AstSymbol.  Otherwise, it is undefined.\n   */\n  public astSymbol: AstSymbol | undefined;\n\n  /**\n   * If modulePath and exportName are defined, then this is a dictionary key\n   * that combines them with a colon (\":\").\n   *\n   * Example: \"@rushstack/node-core-library/lib/FileSystem:FileSystem\"\n   */\n  public readonly key: string;\n\n  public constructor(options: IAstImportOptions) {\n    super();\n\n    this.importKind = options.importKind;\n    this.modulePath = options.modulePath;\n    this.exportName = options.exportName;\n\n    // We start with this assumption, but it may get changed later if non-type-only import is encountered.\n    this.isTypeOnlyEverywhere = options.isTypeOnly;\n\n    this.key = AstImport.getKey(options);\n  }\n\n  /** {@inheritdoc} */\n  public get localName(): string {\n    // abstract\n    return this.exportName;\n  }\n\n  /**\n   * Calculates the lookup key used with `AstImport.key`\n   */\n  public static getKey(options: IAstImportOptions): string {\n    switch (options.importKind) {\n      case AstImportKind.DefaultImport:\n        return `${options.modulePath}:${options.exportName}`;\n      case AstImportKind.NamedImport:\n        return `${options.modulePath}:${options.exportName}`;\n      case AstImportKind.StarImport:\n        return `${options.modulePath}:*`;\n      case AstImportKind.EqualsImport:\n        return `${options.modulePath}:=`;\n      case AstImportKind.ImportType: {\n        const subKey: string = !options.exportName\n          ? '*' // Equivalent to StarImport\n          : options.exportName.includes('.') // Equivalent to a named export\n          ? options.exportName.split('.')[0]\n          : options.exportName;\n        return `${options.modulePath}:${subKey}`;\n      }\n      default:\n        throw new InternalError('Unknown AstImportKind');\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"AstImport.js","sourceRoot":"","sources":["../../src/analyzer/AstImport.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAG3D,oEAA6D;AAC7D,2CAAiD;AAEjD;;GAEG;AACH,IAAY,aAyBX;AAzBD,WAAY,aAAa;IACvB;;OAEG;IACH,mEAAa,CAAA;IAEb;;OAEG;IACH,+DAAW,CAAA;IAEX;;OAEG;IACH,6DAAU,CAAA;IAEV;;OAEG;IACH,iEAAY,CAAA;IAEZ;;OAEG;IACH,6DAAU,CAAA;AACZ,CAAC,EAzBW,aAAa,GAAb,qBAAa,KAAb,qBAAa,QAyBxB;AAkBD;;;GAGG;AACH,MAAa,SAAU,SAAQ,8BAAkB;IA+D/C,YAAmB,OAA0B;QAC3C,KAAK,EAAE,CAAC;QAER,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACrC,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACrC,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QAErC,sGAAsG;QACtG,IAAI,CAAC,oBAAoB,GAAG,OAAO,CAAC,UAAU,CAAC;QAE/C,IAAI,CAAC,GAAG,GAAG,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IACvC,CAAC;IAED,oBAAoB;IACpB,IAAW,SAAS;QAClB,WAAW;QACX,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,MAAM,CAAC,OAA0B;QAC7C,QAAQ,OAAO,CAAC,UAAU,EAAE;YAC1B,KAAK,aAAa,CAAC,aAAa;gBAC9B,OAAO,GAAG,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,EAAE,CAAC;YACvD,KAAK,aAAa,CAAC,WAAW;gBAC5B,OAAO,GAAG,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,EAAE,CAAC;YACvD,KAAK,aAAa,CAAC,UAAU;gBAC3B,OAAO,GAAG,OAAO,CAAC,UAAU,IAAI,CAAC;YACnC,KAAK,aAAa,CAAC,YAAY;gBAC7B,OAAO,GAAG,OAAO,CAAC,UAAU,IAAI,CAAC;YACnC,KAAK,aAAa,CAAC,UAAU,CAAC,CAAC;gBAC7B,MAAM,MAAM,GAAW,CAAC,OAAO,CAAC,UAAU;oBACxC,CAAC,CAAC,GAAG,CAAC,2BAA2B;oBACjC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,+BAA+B;wBAClE,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;wBAClC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC;gBACvB,OAAO,GAAG,OAAO,CAAC,UAAU,IAAI,MAAM,EAAE,CAAC;aAC1C;YACD;gBACE,MAAM,IAAI,iCAAa,CAAC,uBAAuB,CAAC,CAAC;SACpD;IACH,CAAC;CACF;AA3GD,8BA2GC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport type { AstSymbol } from './AstSymbol';\r\nimport { InternalError } from '@rushstack/node-core-library';\r\nimport { AstSyntheticEntity } from './AstEntity';\r\n\r\n/**\r\n * Indicates the import kind for an `AstImport`.\r\n */\r\nexport enum AstImportKind {\r\n  /**\r\n   * An import statement such as `import X from \"y\";`.\r\n   */\r\n  DefaultImport,\r\n\r\n  /**\r\n   * An import statement such as `import { X } from \"y\";`.\r\n   */\r\n  NamedImport,\r\n\r\n  /**\r\n   * An import statement such as `import * as x from \"y\";`.\r\n   */\r\n  StarImport,\r\n\r\n  /**\r\n   * An import statement such as `import x = require(\"y\");`.\r\n   */\r\n  EqualsImport,\r\n\r\n  /**\r\n   * An import statement such as `interface foo { foo: import(\"bar\").a.b.c }`.\r\n   */\r\n  ImportType\r\n}\r\n\r\n/**\r\n * Constructor parameters for AstImport\r\n *\r\n * @privateRemarks\r\n * Our naming convention is to use I____Parameters for constructor options and\r\n * I____Options for general function options.  However the word \"parameters\" is\r\n * confusingly similar to the terminology for function parameters modeled by API Extractor,\r\n * so we use I____Options for both cases in this code base.\r\n */\r\nexport interface IAstImportOptions {\r\n  readonly importKind: AstImportKind;\r\n  readonly modulePath: string;\r\n  readonly exportName: string;\r\n  readonly isTypeOnly: boolean;\r\n}\r\n\r\n/**\r\n * For a symbol that was imported from an external package, this tracks the import\r\n * statement that was used to reach it.\r\n */\r\nexport class AstImport extends AstSyntheticEntity {\r\n  public readonly importKind: AstImportKind;\r\n\r\n  /**\r\n   * The name of the external package (and possibly module path) that this definition\r\n   * was imported from.\r\n   *\r\n   * Example: \"@rushstack/node-core-library/lib/FileSystem\"\r\n   */\r\n  public readonly modulePath: string;\r\n\r\n  /**\r\n   * The name of the symbol being imported.\r\n   *\r\n   * @remarks\r\n   *\r\n   * The name depends on the type of import:\r\n   *\r\n   * ```ts\r\n   * // For AstImportKind.DefaultImport style, exportName would be \"X\" in this example:\r\n   * import X from \"y\";\r\n   *\r\n   * // For AstImportKind.NamedImport style, exportName would be \"X\" in this example:\r\n   * import { X } from \"y\";\r\n   *\r\n   * // For AstImportKind.StarImport style, exportName would be \"x\" in this example:\r\n   * import * as x from \"y\";\r\n   *\r\n   * // For AstImportKind.EqualsImport style, exportName would be \"x\" in this example:\r\n   * import x = require(\"y\");\r\n   *\r\n   * // For AstImportKind.ImportType style, exportName would be \"a.b.c\" in this example:\r\n   * interface foo { foo: import('bar').a.b.c };\r\n   * ```\r\n   */\r\n  public readonly exportName: string;\r\n\r\n  /**\r\n   * Whether it is a type-only import, for example:\r\n   *\r\n   * ```ts\r\n   * import type { X } from \"y\";\r\n   * ```\r\n   *\r\n   * This is set to true ONLY if the type-only form is used in *every* reference to this AstImport.\r\n   */\r\n  public isTypeOnlyEverywhere: boolean;\r\n\r\n  /**\r\n   * If this import statement refers to an API from an external package that is tracked by API Extractor\r\n   * (according to `PackageMetadataManager.isAedocSupportedFor()`), then this property will return the\r\n   * corresponding AstSymbol.  Otherwise, it is undefined.\r\n   */\r\n  public astSymbol: AstSymbol | undefined;\r\n\r\n  /**\r\n   * If modulePath and exportName are defined, then this is a dictionary key\r\n   * that combines them with a colon (\":\").\r\n   *\r\n   * Example: \"@rushstack/node-core-library/lib/FileSystem:FileSystem\"\r\n   */\r\n  public readonly key: string;\r\n\r\n  public constructor(options: IAstImportOptions) {\r\n    super();\r\n\r\n    this.importKind = options.importKind;\r\n    this.modulePath = options.modulePath;\r\n    this.exportName = options.exportName;\r\n\r\n    // We start with this assumption, but it may get changed later if non-type-only import is encountered.\r\n    this.isTypeOnlyEverywhere = options.isTypeOnly;\r\n\r\n    this.key = AstImport.getKey(options);\r\n  }\r\n\r\n  /** {@inheritdoc} */\r\n  public get localName(): string {\r\n    // abstract\r\n    return this.exportName;\r\n  }\r\n\r\n  /**\r\n   * Calculates the lookup key used with `AstImport.key`\r\n   */\r\n  public static getKey(options: IAstImportOptions): string {\r\n    switch (options.importKind) {\r\n      case AstImportKind.DefaultImport:\r\n        return `${options.modulePath}:${options.exportName}`;\r\n      case AstImportKind.NamedImport:\r\n        return `${options.modulePath}:${options.exportName}`;\r\n      case AstImportKind.StarImport:\r\n        return `${options.modulePath}:*`;\r\n      case AstImportKind.EqualsImport:\r\n        return `${options.modulePath}:=`;\r\n      case AstImportKind.ImportType: {\r\n        const subKey: string = !options.exportName\r\n          ? '*' // Equivalent to StarImport\r\n          : options.exportName.includes('.') // Equivalent to a named export\r\n          ? options.exportName.split('.')[0]\r\n          : options.exportName;\r\n        return `${options.modulePath}:${subKey}`;\r\n      }\r\n      default:\r\n        throw new InternalError('Unknown AstImportKind');\r\n    }\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/AstModule.js.map b/lib/analyzer/AstModule.js.map
index 2882be333206d781b6ddefde61ae91eeb11adb9b..7d8271e7d92e1c08421ebccde0bf8d891fe4c008 100644
--- a/lib/analyzer/AstModule.js.map
+++ b/lib/analyzer/AstModule.js.map
@@ -1 +1 @@
-{"version":3,"file":"AstModule.js","sourceRoot":"","sources":["../../src/analyzer/AstModule.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAO3D;;GAEG;AACH,MAAa,mBAAmB;IAAhC;QACkB,0BAAqB,GAA2B,IAAI,GAAG,EAAqB,CAAC;QAC7E,gCAA2B,GAAmB,IAAI,GAAG,EAAa,CAAC;IACrF,CAAC;CAAA;AAHD,kDAGC;AAiBD;;GAEG;AACH,MAAa,SAAS;IAkCpB,YAAmB,OAA0B;QAC3C,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACrC,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,YAAY,CAAC;QAEzC,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,CAAC;QAErD,IAAI,CAAC,mBAAmB,GAAG,IAAI,GAAG,EAAa,CAAC;QAEhD,IAAI,CAAC,sBAAsB,GAAG,IAAI,GAAG,EAAqB,CAAC;QAE3D,IAAI,CAAC,mBAAmB,GAAG,SAAS,CAAC;IACvC,CAAC;IAED;;OAEG;IACH,IAAW,UAAU;QACnB,OAAO,IAAI,CAAC,kBAAkB,KAAK,SAAS,CAAC;IAC/C,CAAC;CACF;AArDD,8BAqDC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type * as ts from 'typescript';\n\nimport type { AstSymbol } from './AstSymbol';\nimport type { AstEntity } from './AstEntity';\n\n/**\n * Represents information collected by {@link AstSymbolTable.fetchAstModuleExportInfo}\n */\nexport class AstModuleExportInfo {\n  public readonly exportedLocalEntities: Map<string, AstEntity> = new Map<string, AstEntity>();\n  public readonly starExportedExternalModules: Set<AstModule> = new Set<AstModule>();\n}\n\n/**\n * Constructor parameters for AstModule\n *\n * @privateRemarks\n * Our naming convention is to use I____Parameters for constructor options and\n * I____Options for general function options.  However the word \"parameters\" is\n * confusingly similar to the terminology for function parameters modeled by API Extractor,\n * so we use I____Options for both cases in this code base.\n */\nexport interface IAstModuleOptions {\n  sourceFile: ts.SourceFile;\n  moduleSymbol: ts.Symbol;\n  externalModulePath: string | undefined;\n}\n\n/**\n * An internal data structure that represents a source file that is analyzed by AstSymbolTable.\n */\nexport class AstModule {\n  /**\n   * The source file that declares this TypeScript module.  In most cases, the source file's\n   * top-level exports constitute the module.\n   */\n  public readonly sourceFile: ts.SourceFile;\n\n  /**\n   * The symbol for the module.  Typically this corresponds to ts.SourceFile itself, however\n   * in some cases the ts.SourceFile may contain multiple modules declared using the `module` keyword.\n   */\n  public readonly moduleSymbol: ts.Symbol;\n\n  /**\n   * Example:  \"@rushstack/node-core-library/lib/FileSystem\"\n   * but never: \"./FileSystem\"\n   */\n  public readonly externalModulePath: string | undefined;\n\n  /**\n   * A list of other `AstModule` objects that appear in `export * from \"___\";` statements.\n   */\n  public readonly starExportedModules: Set<AstModule>;\n\n  /**\n   * A partial map of entities exported by this module.  The key is the exported name.\n   */\n  public readonly cachedExportedEntities: Map<string, AstEntity>; // exportName --> entity\n\n  /**\n   * Additional state calculated by `AstSymbolTable.fetchWorkingPackageModule()`.\n   */\n  public astModuleExportInfo: AstModuleExportInfo | undefined;\n\n  public constructor(options: IAstModuleOptions) {\n    this.sourceFile = options.sourceFile;\n    this.moduleSymbol = options.moduleSymbol;\n\n    this.externalModulePath = options.externalModulePath;\n\n    this.starExportedModules = new Set<AstModule>();\n\n    this.cachedExportedEntities = new Map<string, AstSymbol>();\n\n    this.astModuleExportInfo = undefined;\n  }\n\n  /**\n   * If false, then this source file is part of the working package being processed by the `Collector`.\n   */\n  public get isExternal(): boolean {\n    return this.externalModulePath !== undefined;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"AstModule.js","sourceRoot":"","sources":["../../src/analyzer/AstModule.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAO3D;;GAEG;AACH,MAAa,mBAAmB;IAAhC;QACkB,0BAAqB,GAA2B,IAAI,GAAG,EAAqB,CAAC;QAC7E,gCAA2B,GAAmB,IAAI,GAAG,EAAa,CAAC;IACrF,CAAC;CAAA;AAHD,kDAGC;AAiBD;;GAEG;AACH,MAAa,SAAS;IAkCpB,YAAmB,OAA0B;QAC3C,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACrC,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,YAAY,CAAC;QAEzC,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,CAAC;QAErD,IAAI,CAAC,mBAAmB,GAAG,IAAI,GAAG,EAAa,CAAC;QAEhD,IAAI,CAAC,sBAAsB,GAAG,IAAI,GAAG,EAAqB,CAAC;QAE3D,IAAI,CAAC,mBAAmB,GAAG,SAAS,CAAC;IACvC,CAAC;IAED;;OAEG;IACH,IAAW,UAAU;QACnB,OAAO,IAAI,CAAC,kBAAkB,KAAK,SAAS,CAAC;IAC/C,CAAC;CACF;AArDD,8BAqDC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport type * as ts from 'typescript';\r\n\r\nimport type { AstSymbol } from './AstSymbol';\r\nimport type { AstEntity } from './AstEntity';\r\n\r\n/**\r\n * Represents information collected by {@link AstSymbolTable.fetchAstModuleExportInfo}\r\n */\r\nexport class AstModuleExportInfo {\r\n  public readonly exportedLocalEntities: Map<string, AstEntity> = new Map<string, AstEntity>();\r\n  public readonly starExportedExternalModules: Set<AstModule> = new Set<AstModule>();\r\n}\r\n\r\n/**\r\n * Constructor parameters for AstModule\r\n *\r\n * @privateRemarks\r\n * Our naming convention is to use I____Parameters for constructor options and\r\n * I____Options for general function options.  However the word \"parameters\" is\r\n * confusingly similar to the terminology for function parameters modeled by API Extractor,\r\n * so we use I____Options for both cases in this code base.\r\n */\r\nexport interface IAstModuleOptions {\r\n  sourceFile: ts.SourceFile;\r\n  moduleSymbol: ts.Symbol;\r\n  externalModulePath: string | undefined;\r\n}\r\n\r\n/**\r\n * An internal data structure that represents a source file that is analyzed by AstSymbolTable.\r\n */\r\nexport class AstModule {\r\n  /**\r\n   * The source file that declares this TypeScript module.  In most cases, the source file's\r\n   * top-level exports constitute the module.\r\n   */\r\n  public readonly sourceFile: ts.SourceFile;\r\n\r\n  /**\r\n   * The symbol for the module.  Typically this corresponds to ts.SourceFile itself, however\r\n   * in some cases the ts.SourceFile may contain multiple modules declared using the `module` keyword.\r\n   */\r\n  public readonly moduleSymbol: ts.Symbol;\r\n\r\n  /**\r\n   * Example:  \"@rushstack/node-core-library/lib/FileSystem\"\r\n   * but never: \"./FileSystem\"\r\n   */\r\n  public readonly externalModulePath: string | undefined;\r\n\r\n  /**\r\n   * A list of other `AstModule` objects that appear in `export * from \"___\";` statements.\r\n   */\r\n  public readonly starExportedModules: Set<AstModule>;\r\n\r\n  /**\r\n   * A partial map of entities exported by this module.  The key is the exported name.\r\n   */\r\n  public readonly cachedExportedEntities: Map<string, AstEntity>; // exportName --> entity\r\n\r\n  /**\r\n   * Additional state calculated by `AstSymbolTable.fetchWorkingPackageModule()`.\r\n   */\r\n  public astModuleExportInfo: AstModuleExportInfo | undefined;\r\n\r\n  public constructor(options: IAstModuleOptions) {\r\n    this.sourceFile = options.sourceFile;\r\n    this.moduleSymbol = options.moduleSymbol;\r\n\r\n    this.externalModulePath = options.externalModulePath;\r\n\r\n    this.starExportedModules = new Set<AstModule>();\r\n\r\n    this.cachedExportedEntities = new Map<string, AstSymbol>();\r\n\r\n    this.astModuleExportInfo = undefined;\r\n  }\r\n\r\n  /**\r\n   * If false, then this source file is part of the working package being processed by the `Collector`.\r\n   */\r\n  public get isExternal(): boolean {\r\n    return this.externalModulePath !== undefined;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/AstNamespaceImport.js.map b/lib/analyzer/AstNamespaceImport.js.map
index f36bac75142dd401c2494918945701b72943bffd..56a3080409a853db1bc9150c86a007e4ec6ad316 100644
--- a/lib/analyzer/AstNamespaceImport.js.map
+++ b/lib/analyzer/AstNamespaceImport.js.map
@@ -1 +1 @@
-{"version":3,"file":"AstNamespaceImport.js","sourceRoot":"","sources":["../../src/analyzer/AstNamespaceImport.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAK3D,2CAAiD;AAUjD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BG;AACH,MAAa,kBAAmB,SAAQ,8BAAkB;IA6BxD,YAAmB,OAAmC;QACpD,KAAK,EAAE,CAAC;QA7BV;;;WAGG;QACI,aAAQ,GAAY,KAAK,CAAC;QA0B/B,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;QAC3C,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC;QACvC,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAC/B,CAAC;IAED,oBAAoB;IACpB,IAAW,SAAS;QAClB,WAAW;QACX,OAAO,IAAI,CAAC,aAAa,CAAC;IAC5B,CAAC;IAEM,wBAAwB,CAAC,SAAoB;QAClD,MAAM,mBAAmB,GAAwB,SAAS,CAAC,cAAc,CAAC,wBAAwB,CAChG,IAAI,CAAC,SAAS,CACf,CAAC;QACF,OAAO,mBAAmB,CAAC;IAC7B,CAAC;CACF;AAjDD,gDAiDC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type * as ts from 'typescript';\n\nimport type { AstModule, AstModuleExportInfo } from './AstModule';\nimport { AstSyntheticEntity } from './AstEntity';\nimport type { Collector } from '../collector/Collector';\n\nexport interface IAstNamespaceImportOptions {\n  readonly astModule: AstModule;\n  readonly namespaceName: string;\n  readonly declaration: ts.Declaration;\n  readonly symbol: ts.Symbol;\n}\n\n/**\n * `AstNamespaceImport` represents a namespace that is created implicitly by a statement\n * such as `import * as example from \"./file\";`\n *\n * @remarks\n *\n * A typical input looks like this:\n * ```ts\n * // Suppose that example.ts exports two functions f1() and f2().\n * import * as example from \"./file\";\n * export { example };\n * ```\n *\n * API Extractor's .d.ts rollup will transform it into an explicit namespace, like this:\n * ```ts\n * declare f1(): void;\n * declare f2(): void;\n *\n * declare namespace example {\n *   export {\n *     f1,\n *     f2\n *   }\n * }\n * ```\n *\n * The current implementation does not attempt to relocate f1()/f2() to be inside the `namespace`\n * because other type signatures may reference them directly (without using the namespace qualifier).\n * The `declare namespace example` is a synthetic construct represented by `AstNamespaceImport`.\n */\nexport class AstNamespaceImport extends AstSyntheticEntity {\n  /**\n   * Returns true if the AstSymbolTable.analyze() was called for this object.\n   * See that function for details.\n   */\n  public analyzed: boolean = false;\n\n  /**\n   * For example, if the original statement was `import * as example from \"./file\";`\n   * then `astModule` refers to the `./file.d.ts` file.\n   */\n  public readonly astModule: AstModule;\n\n  /**\n   * For example, if the original statement was `import * as example from \"./file\";`\n   * then `namespaceName` would be `example`.\n   */\n  public readonly namespaceName: string;\n\n  /**\n   * The original `ts.SyntaxKind.NamespaceImport` which can be used as a location for error messages.\n   */\n  public readonly declaration: ts.Declaration;\n\n  /**\n   * The original `ts.SymbolFlags.Namespace` symbol.\n   */\n  public readonly symbol: ts.Symbol;\n\n  public constructor(options: IAstNamespaceImportOptions) {\n    super();\n    this.astModule = options.astModule;\n    this.namespaceName = options.namespaceName;\n    this.declaration = options.declaration;\n    this.symbol = options.symbol;\n  }\n\n  /** {@inheritdoc} */\n  public get localName(): string {\n    // abstract\n    return this.namespaceName;\n  }\n\n  public fetchAstModuleExportInfo(collector: Collector): AstModuleExportInfo {\n    const astModuleExportInfo: AstModuleExportInfo = collector.astSymbolTable.fetchAstModuleExportInfo(\n      this.astModule\n    );\n    return astModuleExportInfo;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"AstNamespaceImport.js","sourceRoot":"","sources":["../../src/analyzer/AstNamespaceImport.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAK3D,2CAAiD;AAUjD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BG;AACH,MAAa,kBAAmB,SAAQ,8BAAkB;IA6BxD,YAAmB,OAAmC;QACpD,KAAK,EAAE,CAAC;QA7BV;;;WAGG;QACI,aAAQ,GAAY,KAAK,CAAC;QA0B/B,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;QAC3C,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC;QACvC,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAC/B,CAAC;IAED,oBAAoB;IACpB,IAAW,SAAS;QAClB,WAAW;QACX,OAAO,IAAI,CAAC,aAAa,CAAC;IAC5B,CAAC;IAEM,wBAAwB,CAAC,SAAoB;QAClD,MAAM,mBAAmB,GAAwB,SAAS,CAAC,cAAc,CAAC,wBAAwB,CAChG,IAAI,CAAC,SAAS,CACf,CAAC;QACF,OAAO,mBAAmB,CAAC;IAC7B,CAAC;CACF;AAjDD,gDAiDC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport type * as ts from 'typescript';\r\n\r\nimport type { AstModule, AstModuleExportInfo } from './AstModule';\r\nimport { AstSyntheticEntity } from './AstEntity';\r\nimport type { Collector } from '../collector/Collector';\r\n\r\nexport interface IAstNamespaceImportOptions {\r\n  readonly astModule: AstModule;\r\n  readonly namespaceName: string;\r\n  readonly declaration: ts.Declaration;\r\n  readonly symbol: ts.Symbol;\r\n}\r\n\r\n/**\r\n * `AstNamespaceImport` represents a namespace that is created implicitly by a statement\r\n * such as `import * as example from \"./file\";`\r\n *\r\n * @remarks\r\n *\r\n * A typical input looks like this:\r\n * ```ts\r\n * // Suppose that example.ts exports two functions f1() and f2().\r\n * import * as example from \"./file\";\r\n * export { example };\r\n * ```\r\n *\r\n * API Extractor's .d.ts rollup will transform it into an explicit namespace, like this:\r\n * ```ts\r\n * declare f1(): void;\r\n * declare f2(): void;\r\n *\r\n * declare namespace example {\r\n *   export {\r\n *     f1,\r\n *     f2\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * The current implementation does not attempt to relocate f1()/f2() to be inside the `namespace`\r\n * because other type signatures may reference them directly (without using the namespace qualifier).\r\n * The `declare namespace example` is a synthetic construct represented by `AstNamespaceImport`.\r\n */\r\nexport class AstNamespaceImport extends AstSyntheticEntity {\r\n  /**\r\n   * Returns true if the AstSymbolTable.analyze() was called for this object.\r\n   * See that function for details.\r\n   */\r\n  public analyzed: boolean = false;\r\n\r\n  /**\r\n   * For example, if the original statement was `import * as example from \"./file\";`\r\n   * then `astModule` refers to the `./file.d.ts` file.\r\n   */\r\n  public readonly astModule: AstModule;\r\n\r\n  /**\r\n   * For example, if the original statement was `import * as example from \"./file\";`\r\n   * then `namespaceName` would be `example`.\r\n   */\r\n  public readonly namespaceName: string;\r\n\r\n  /**\r\n   * The original `ts.SyntaxKind.NamespaceImport` which can be used as a location for error messages.\r\n   */\r\n  public readonly declaration: ts.Declaration;\r\n\r\n  /**\r\n   * The original `ts.SymbolFlags.Namespace` symbol.\r\n   */\r\n  public readonly symbol: ts.Symbol;\r\n\r\n  public constructor(options: IAstNamespaceImportOptions) {\r\n    super();\r\n    this.astModule = options.astModule;\r\n    this.namespaceName = options.namespaceName;\r\n    this.declaration = options.declaration;\r\n    this.symbol = options.symbol;\r\n  }\r\n\r\n  /** {@inheritdoc} */\r\n  public get localName(): string {\r\n    // abstract\r\n    return this.namespaceName;\r\n  }\r\n\r\n  public fetchAstModuleExportInfo(collector: Collector): AstModuleExportInfo {\r\n    const astModuleExportInfo: AstModuleExportInfo = collector.astSymbolTable.fetchAstModuleExportInfo(\r\n      this.astModule\r\n    );\r\n    return astModuleExportInfo;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/AstReferenceResolver.js.map b/lib/analyzer/AstReferenceResolver.js.map
index f5196e2542d437fca93b96727fbd0e94e5b97cad..ef2754e685578047f51bbe612214da18bd65618d 100644
--- a/lib/analyzer/AstReferenceResolver.js.map
+++ b/lib/analyzer/AstReferenceResolver.js.map
@@ -1 +1 @@
-{"version":3,"file":"AstReferenceResolver.js","sourceRoot":"","sources":["../../src/analyzer/AstReferenceResolver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\nimport * as tsdoc from '@microsoft/tsdoc';\n\nimport type { AstSymbolTable } from './AstSymbolTable';\nimport type { AstEntity } from './AstEntity';\nimport type { AstDeclaration } from './AstDeclaration';\nimport type { WorkingPackage } from '../collector/WorkingPackage';\nimport type { AstModule } from './AstModule';\nimport type { Collector } from '../collector/Collector';\nimport type { DeclarationMetadata } from '../collector/DeclarationMetadata';\nimport { AstSymbol } from './AstSymbol';\n\n/**\n * Used by `AstReferenceResolver` to report a failed resolution.\n *\n * @privateRemarks\n * This class is similar to an `Error` object, but the intent of `ResolverFailure` is to describe\n * why a reference could not be resolved.  This information could be used to throw an actual `Error` object,\n * but normally it is handed off to the `MessageRouter` instead.\n */\nexport class ResolverFailure {\n  /**\n   * Details about why the failure occurred.\n   */\n  public readonly reason: string;\n\n  public constructor(reason: string) {\n    this.reason = reason;\n  }\n}\n\n/**\n * This resolves a TSDoc declaration reference by walking the `AstSymbolTable` compiler state.\n *\n * @remarks\n *\n * This class is analogous to `ModelReferenceResolver` from the `@microsoft/api-extractor-model` project,\n * which resolves declaration references by walking the hierarchy loaded from an .api.json file.\n */\nexport class AstReferenceResolver {\n  private readonly _collector: Collector;\n  private readonly _astSymbolTable: AstSymbolTable;\n  private readonly _workingPackage: WorkingPackage;\n\n  public constructor(collector: Collector) {\n    this._collector = collector;\n    this._astSymbolTable = collector.astSymbolTable;\n    this._workingPackage = collector.workingPackage;\n  }\n\n  public resolve(declarationReference: tsdoc.DocDeclarationReference): AstDeclaration | ResolverFailure {\n    // Is it referring to the working package?\n    if (\n      declarationReference.packageName !== undefined &&\n      declarationReference.packageName !== this._workingPackage.name\n    ) {\n      return new ResolverFailure('External package references are not supported');\n    }\n\n    // Is it a path-based import?\n    if (declarationReference.importPath) {\n      return new ResolverFailure('Import paths are not supported');\n    }\n\n    const astModule: AstModule = this._astSymbolTable.fetchAstModuleFromWorkingPackage(\n      this._workingPackage.entryPointSourceFile\n    );\n\n    if (declarationReference.memberReferences.length === 0) {\n      return new ResolverFailure('Package references are not supported');\n    }\n\n    const rootMemberReference: tsdoc.DocMemberReference = declarationReference.memberReferences[0];\n\n    const exportName: string | ResolverFailure = this._getMemberReferenceIdentifier(rootMemberReference);\n    if (exportName instanceof ResolverFailure) {\n      return exportName;\n    }\n\n    const rootAstEntity: AstEntity | undefined = this._astSymbolTable.tryGetExportOfAstModule(\n      exportName,\n      astModule\n    );\n\n    if (rootAstEntity === undefined) {\n      return new ResolverFailure(\n        `The package \"${this._workingPackage.name}\" does not have an export \"${exportName}\"`\n      );\n    }\n\n    if (!(rootAstEntity instanceof AstSymbol)) {\n      return new ResolverFailure('This type of declaration is not supported yet by the resolver');\n    }\n\n    let currentDeclaration: AstDeclaration | ResolverFailure = this._selectDeclaration(\n      rootAstEntity.astDeclarations,\n      rootMemberReference,\n      rootAstEntity.localName\n    );\n\n    if (currentDeclaration instanceof ResolverFailure) {\n      return currentDeclaration;\n    }\n\n    for (let index: number = 1; index < declarationReference.memberReferences.length; ++index) {\n      const memberReference: tsdoc.DocMemberReference = declarationReference.memberReferences[index];\n\n      const memberName: string | ResolverFailure = this._getMemberReferenceIdentifier(memberReference);\n      if (memberName instanceof ResolverFailure) {\n        return memberName;\n      }\n\n      const matchingChildren: ReadonlyArray<AstDeclaration> =\n        currentDeclaration.findChildrenWithName(memberName);\n      if (matchingChildren.length === 0) {\n        return new ResolverFailure(`No member was found with name \"${memberName}\"`);\n      }\n\n      const selectedDeclaration: AstDeclaration | ResolverFailure = this._selectDeclaration(\n        matchingChildren,\n        memberReference,\n        memberName\n      );\n\n      if (selectedDeclaration instanceof ResolverFailure) {\n        return selectedDeclaration;\n      }\n\n      currentDeclaration = selectedDeclaration;\n    }\n\n    return currentDeclaration;\n  }\n\n  private _getMemberReferenceIdentifier(memberReference: tsdoc.DocMemberReference): string | ResolverFailure {\n    if (memberReference.memberSymbol !== undefined) {\n      return new ResolverFailure('ECMAScript symbol selectors are not supported');\n    }\n    if (memberReference.memberIdentifier === undefined) {\n      return new ResolverFailure('The member identifier is missing in the root member reference');\n    }\n    return memberReference.memberIdentifier.identifier;\n  }\n\n  private _selectDeclaration(\n    astDeclarations: ReadonlyArray<AstDeclaration>,\n    memberReference: tsdoc.DocMemberReference,\n    astSymbolName: string\n  ): AstDeclaration | ResolverFailure {\n    const memberSelector: tsdoc.DocMemberSelector | undefined = memberReference.selector;\n\n    if (memberSelector === undefined) {\n      if (astDeclarations.length === 1) {\n        return astDeclarations[0];\n      } else {\n        // If we found multiple matches, but the extra ones are all ancillary declarations,\n        // then return the main declaration.\n        const nonAncillaryMatch: AstDeclaration | undefined =\n          this._tryDisambiguateAncillaryMatches(astDeclarations);\n        if (nonAncillaryMatch) {\n          return nonAncillaryMatch;\n        }\n\n        return new ResolverFailure(\n          `The reference is ambiguous because \"${astSymbolName}\"` +\n            ` has more than one declaration; you need to add a TSDoc member reference selector`\n        );\n      }\n    }\n\n    switch (memberSelector.selectorKind) {\n      case tsdoc.SelectorKind.System:\n        return this._selectUsingSystemSelector(astDeclarations, memberSelector, astSymbolName);\n      case tsdoc.SelectorKind.Index:\n        return this._selectUsingIndexSelector(astDeclarations, memberSelector, astSymbolName);\n    }\n\n    return new ResolverFailure(`The selector \"${memberSelector.selector}\" is not a supported selector type`);\n  }\n\n  private _selectUsingSystemSelector(\n    astDeclarations: ReadonlyArray<AstDeclaration>,\n    memberSelector: tsdoc.DocMemberSelector,\n    astSymbolName: string\n  ): AstDeclaration | ResolverFailure {\n    const selectorName: string = memberSelector.selector;\n\n    let selectorSyntaxKind: ts.SyntaxKind;\n\n    switch (selectorName) {\n      case 'class':\n        selectorSyntaxKind = ts.SyntaxKind.ClassDeclaration;\n        break;\n      case 'enum':\n        selectorSyntaxKind = ts.SyntaxKind.EnumDeclaration;\n        break;\n      case 'function':\n        selectorSyntaxKind = ts.SyntaxKind.FunctionDeclaration;\n        break;\n      case 'interface':\n        selectorSyntaxKind = ts.SyntaxKind.InterfaceDeclaration;\n        break;\n      case 'namespace':\n        selectorSyntaxKind = ts.SyntaxKind.ModuleDeclaration;\n        break;\n      case 'type':\n        selectorSyntaxKind = ts.SyntaxKind.TypeAliasDeclaration;\n        break;\n      case 'variable':\n        selectorSyntaxKind = ts.SyntaxKind.VariableDeclaration;\n        break;\n      default:\n        return new ResolverFailure(`Unsupported system selector \"${selectorName}\"`);\n    }\n\n    const matches: AstDeclaration[] = astDeclarations.filter(\n      (x) => x.declaration.kind === selectorSyntaxKind\n    );\n    if (matches.length === 0) {\n      return new ResolverFailure(\n        `A declaration for \"${astSymbolName}\" was not found that matches the` +\n          ` TSDoc selector \"${selectorName}\"`\n      );\n    }\n    if (matches.length > 1) {\n      // If we found multiple matches, but the extra ones are all ancillary declarations,\n      // then return the main declaration.\n      const nonAncillaryMatch: AstDeclaration | undefined = this._tryDisambiguateAncillaryMatches(matches);\n      if (nonAncillaryMatch) {\n        return nonAncillaryMatch;\n      }\n\n      return new ResolverFailure(\n        `More than one declaration \"${astSymbolName}\" matches the TSDoc selector \"${selectorName}\"`\n      );\n    }\n    return matches[0];\n  }\n\n  private _selectUsingIndexSelector(\n    astDeclarations: ReadonlyArray<AstDeclaration>,\n    memberSelector: tsdoc.DocMemberSelector,\n    astSymbolName: string\n  ): AstDeclaration | ResolverFailure {\n    const selectorOverloadIndex: number = parseInt(memberSelector.selector, 10);\n\n    const matches: AstDeclaration[] = [];\n    for (const astDeclaration of astDeclarations) {\n      const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n      if (overloadIndex === selectorOverloadIndex) {\n        matches.push(astDeclaration);\n      }\n    }\n\n    if (matches.length === 0) {\n      return new ResolverFailure(\n        `An overload for \"${astSymbolName}\" was not found that matches the` +\n          ` TSDoc selector \":${selectorOverloadIndex}\"`\n      );\n    }\n    if (matches.length > 1) {\n      // If we found multiple matches, but the extra ones are all ancillary declarations,\n      // then return the main declaration.\n      const nonAncillaryMatch: AstDeclaration | undefined = this._tryDisambiguateAncillaryMatches(matches);\n      if (nonAncillaryMatch) {\n        return nonAncillaryMatch;\n      }\n\n      return new ResolverFailure(\n        `More than one declaration for \"${astSymbolName}\" matches the` +\n          ` TSDoc selector \":${selectorOverloadIndex}\"`\n      );\n    }\n    return matches[0];\n  }\n\n  /**\n   * This resolves an ambiguous match in the case where the extra matches are all ancillary declarations,\n   * except for one match that is the main declaration.\n   */\n  private _tryDisambiguateAncillaryMatches(\n    matches: ReadonlyArray<AstDeclaration>\n  ): AstDeclaration | undefined {\n    let result: AstDeclaration | undefined = undefined;\n\n    for (const match of matches) {\n      const declarationMetadata: DeclarationMetadata = this._collector.fetchDeclarationMetadata(match);\n      if (!declarationMetadata.isAncillary) {\n        if (result) {\n          return undefined; // more than one match\n        }\n        result = match;\n      }\n    }\n    return result;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"AstReferenceResolver.js","sourceRoot":"","sources":["../../src/analyzer/AstReferenceResolver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport * as tsdoc from '@microsoft/tsdoc';\r\n\r\nimport type { AstSymbolTable } from './AstSymbolTable';\r\nimport type { AstEntity } from './AstEntity';\r\nimport type { AstDeclaration } from './AstDeclaration';\r\nimport type { WorkingPackage } from '../collector/WorkingPackage';\r\nimport type { AstModule } from './AstModule';\r\nimport type { Collector } from '../collector/Collector';\r\nimport type { DeclarationMetadata } from '../collector/DeclarationMetadata';\r\nimport { AstSymbol } from './AstSymbol';\r\n\r\n/**\r\n * Used by `AstReferenceResolver` to report a failed resolution.\r\n *\r\n * @privateRemarks\r\n * This class is similar to an `Error` object, but the intent of `ResolverFailure` is to describe\r\n * why a reference could not be resolved.  This information could be used to throw an actual `Error` object,\r\n * but normally it is handed off to the `MessageRouter` instead.\r\n */\r\nexport class ResolverFailure {\r\n  /**\r\n   * Details about why the failure occurred.\r\n   */\r\n  public readonly reason: string;\r\n\r\n  public constructor(reason: string) {\r\n    this.reason = reason;\r\n  }\r\n}\r\n\r\n/**\r\n * This resolves a TSDoc declaration reference by walking the `AstSymbolTable` compiler state.\r\n *\r\n * @remarks\r\n *\r\n * This class is analogous to `ModelReferenceResolver` from the `@microsoft/api-extractor-model` project,\r\n * which resolves declaration references by walking the hierarchy loaded from an .api.json file.\r\n */\r\nexport class AstReferenceResolver {\r\n  private readonly _collector: Collector;\r\n  private readonly _astSymbolTable: AstSymbolTable;\r\n  private readonly _workingPackage: WorkingPackage;\r\n\r\n  public constructor(collector: Collector) {\r\n    this._collector = collector;\r\n    this._astSymbolTable = collector.astSymbolTable;\r\n    this._workingPackage = collector.workingPackage;\r\n  }\r\n\r\n  public resolve(declarationReference: tsdoc.DocDeclarationReference): AstDeclaration | ResolverFailure {\r\n    // Is it referring to the working package?\r\n    if (\r\n      declarationReference.packageName !== undefined &&\r\n      declarationReference.packageName !== this._workingPackage.name\r\n    ) {\r\n      return new ResolverFailure('External package references are not supported');\r\n    }\r\n\r\n    // Is it a path-based import?\r\n    if (declarationReference.importPath) {\r\n      return new ResolverFailure('Import paths are not supported');\r\n    }\r\n\r\n    const astModule: AstModule = this._astSymbolTable.fetchAstModuleFromWorkingPackage(\r\n      this._workingPackage.entryPointSourceFile\r\n    );\r\n\r\n    if (declarationReference.memberReferences.length === 0) {\r\n      return new ResolverFailure('Package references are not supported');\r\n    }\r\n\r\n    const rootMemberReference: tsdoc.DocMemberReference = declarationReference.memberReferences[0];\r\n\r\n    const exportName: string | ResolverFailure = this._getMemberReferenceIdentifier(rootMemberReference);\r\n    if (exportName instanceof ResolverFailure) {\r\n      return exportName;\r\n    }\r\n\r\n    const rootAstEntity: AstEntity | undefined = this._astSymbolTable.tryGetExportOfAstModule(\r\n      exportName,\r\n      astModule\r\n    );\r\n\r\n    if (rootAstEntity === undefined) {\r\n      return new ResolverFailure(\r\n        `The package \"${this._workingPackage.name}\" does not have an export \"${exportName}\"`\r\n      );\r\n    }\r\n\r\n    if (!(rootAstEntity instanceof AstSymbol)) {\r\n      return new ResolverFailure('This type of declaration is not supported yet by the resolver');\r\n    }\r\n\r\n    let currentDeclaration: AstDeclaration | ResolverFailure = this._selectDeclaration(\r\n      rootAstEntity.astDeclarations,\r\n      rootMemberReference,\r\n      rootAstEntity.localName\r\n    );\r\n\r\n    if (currentDeclaration instanceof ResolverFailure) {\r\n      return currentDeclaration;\r\n    }\r\n\r\n    for (let index: number = 1; index < declarationReference.memberReferences.length; ++index) {\r\n      const memberReference: tsdoc.DocMemberReference = declarationReference.memberReferences[index];\r\n\r\n      const memberName: string | ResolverFailure = this._getMemberReferenceIdentifier(memberReference);\r\n      if (memberName instanceof ResolverFailure) {\r\n        return memberName;\r\n      }\r\n\r\n      const matchingChildren: ReadonlyArray<AstDeclaration> =\r\n        currentDeclaration.findChildrenWithName(memberName);\r\n      if (matchingChildren.length === 0) {\r\n        return new ResolverFailure(`No member was found with name \"${memberName}\"`);\r\n      }\r\n\r\n      const selectedDeclaration: AstDeclaration | ResolverFailure = this._selectDeclaration(\r\n        matchingChildren,\r\n        memberReference,\r\n        memberName\r\n      );\r\n\r\n      if (selectedDeclaration instanceof ResolverFailure) {\r\n        return selectedDeclaration;\r\n      }\r\n\r\n      currentDeclaration = selectedDeclaration;\r\n    }\r\n\r\n    return currentDeclaration;\r\n  }\r\n\r\n  private _getMemberReferenceIdentifier(memberReference: tsdoc.DocMemberReference): string | ResolverFailure {\r\n    if (memberReference.memberSymbol !== undefined) {\r\n      return new ResolverFailure('ECMAScript symbol selectors are not supported');\r\n    }\r\n    if (memberReference.memberIdentifier === undefined) {\r\n      return new ResolverFailure('The member identifier is missing in the root member reference');\r\n    }\r\n    return memberReference.memberIdentifier.identifier;\r\n  }\r\n\r\n  private _selectDeclaration(\r\n    astDeclarations: ReadonlyArray<AstDeclaration>,\r\n    memberReference: tsdoc.DocMemberReference,\r\n    astSymbolName: string\r\n  ): AstDeclaration | ResolverFailure {\r\n    const memberSelector: tsdoc.DocMemberSelector | undefined = memberReference.selector;\r\n\r\n    if (memberSelector === undefined) {\r\n      if (astDeclarations.length === 1) {\r\n        return astDeclarations[0];\r\n      } else {\r\n        // If we found multiple matches, but the extra ones are all ancillary declarations,\r\n        // then return the main declaration.\r\n        const nonAncillaryMatch: AstDeclaration | undefined =\r\n          this._tryDisambiguateAncillaryMatches(astDeclarations);\r\n        if (nonAncillaryMatch) {\r\n          return nonAncillaryMatch;\r\n        }\r\n\r\n        return new ResolverFailure(\r\n          `The reference is ambiguous because \"${astSymbolName}\"` +\r\n            ` has more than one declaration; you need to add a TSDoc member reference selector`\r\n        );\r\n      }\r\n    }\r\n\r\n    switch (memberSelector.selectorKind) {\r\n      case tsdoc.SelectorKind.System:\r\n        return this._selectUsingSystemSelector(astDeclarations, memberSelector, astSymbolName);\r\n      case tsdoc.SelectorKind.Index:\r\n        return this._selectUsingIndexSelector(astDeclarations, memberSelector, astSymbolName);\r\n    }\r\n\r\n    return new ResolverFailure(`The selector \"${memberSelector.selector}\" is not a supported selector type`);\r\n  }\r\n\r\n  private _selectUsingSystemSelector(\r\n    astDeclarations: ReadonlyArray<AstDeclaration>,\r\n    memberSelector: tsdoc.DocMemberSelector,\r\n    astSymbolName: string\r\n  ): AstDeclaration | ResolverFailure {\r\n    const selectorName: string = memberSelector.selector;\r\n\r\n    let selectorSyntaxKind: ts.SyntaxKind;\r\n\r\n    switch (selectorName) {\r\n      case 'class':\r\n        selectorSyntaxKind = ts.SyntaxKind.ClassDeclaration;\r\n        break;\r\n      case 'enum':\r\n        selectorSyntaxKind = ts.SyntaxKind.EnumDeclaration;\r\n        break;\r\n      case 'function':\r\n        selectorSyntaxKind = ts.SyntaxKind.FunctionDeclaration;\r\n        break;\r\n      case 'interface':\r\n        selectorSyntaxKind = ts.SyntaxKind.InterfaceDeclaration;\r\n        break;\r\n      case 'namespace':\r\n        selectorSyntaxKind = ts.SyntaxKind.ModuleDeclaration;\r\n        break;\r\n      case 'type':\r\n        selectorSyntaxKind = ts.SyntaxKind.TypeAliasDeclaration;\r\n        break;\r\n      case 'variable':\r\n        selectorSyntaxKind = ts.SyntaxKind.VariableDeclaration;\r\n        break;\r\n      default:\r\n        return new ResolverFailure(`Unsupported system selector \"${selectorName}\"`);\r\n    }\r\n\r\n    const matches: AstDeclaration[] = astDeclarations.filter(\r\n      (x) => x.declaration.kind === selectorSyntaxKind\r\n    );\r\n    if (matches.length === 0) {\r\n      return new ResolverFailure(\r\n        `A declaration for \"${astSymbolName}\" was not found that matches the` +\r\n          ` TSDoc selector \"${selectorName}\"`\r\n      );\r\n    }\r\n    if (matches.length > 1) {\r\n      // If we found multiple matches, but the extra ones are all ancillary declarations,\r\n      // then return the main declaration.\r\n      const nonAncillaryMatch: AstDeclaration | undefined = this._tryDisambiguateAncillaryMatches(matches);\r\n      if (nonAncillaryMatch) {\r\n        return nonAncillaryMatch;\r\n      }\r\n\r\n      return new ResolverFailure(\r\n        `More than one declaration \"${astSymbolName}\" matches the TSDoc selector \"${selectorName}\"`\r\n      );\r\n    }\r\n    return matches[0];\r\n  }\r\n\r\n  private _selectUsingIndexSelector(\r\n    astDeclarations: ReadonlyArray<AstDeclaration>,\r\n    memberSelector: tsdoc.DocMemberSelector,\r\n    astSymbolName: string\r\n  ): AstDeclaration | ResolverFailure {\r\n    const selectorOverloadIndex: number = parseInt(memberSelector.selector, 10);\r\n\r\n    const matches: AstDeclaration[] = [];\r\n    for (const astDeclaration of astDeclarations) {\r\n      const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\r\n      if (overloadIndex === selectorOverloadIndex) {\r\n        matches.push(astDeclaration);\r\n      }\r\n    }\r\n\r\n    if (matches.length === 0) {\r\n      return new ResolverFailure(\r\n        `An overload for \"${astSymbolName}\" was not found that matches the` +\r\n          ` TSDoc selector \":${selectorOverloadIndex}\"`\r\n      );\r\n    }\r\n    if (matches.length > 1) {\r\n      // If we found multiple matches, but the extra ones are all ancillary declarations,\r\n      // then return the main declaration.\r\n      const nonAncillaryMatch: AstDeclaration | undefined = this._tryDisambiguateAncillaryMatches(matches);\r\n      if (nonAncillaryMatch) {\r\n        return nonAncillaryMatch;\r\n      }\r\n\r\n      return new ResolverFailure(\r\n        `More than one declaration for \"${astSymbolName}\" matches the` +\r\n          ` TSDoc selector \":${selectorOverloadIndex}\"`\r\n      );\r\n    }\r\n    return matches[0];\r\n  }\r\n\r\n  /**\r\n   * This resolves an ambiguous match in the case where the extra matches are all ancillary declarations,\r\n   * except for one match that is the main declaration.\r\n   */\r\n  private _tryDisambiguateAncillaryMatches(\r\n    matches: ReadonlyArray<AstDeclaration>\r\n  ): AstDeclaration | undefined {\r\n    let result: AstDeclaration | undefined = undefined;\r\n\r\n    for (const match of matches) {\r\n      const declarationMetadata: DeclarationMetadata = this._collector.fetchDeclarationMetadata(match);\r\n      if (!declarationMetadata.isAncillary) {\r\n        if (result) {\r\n          return undefined; // more than one match\r\n        }\r\n        result = match;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/AstSymbol.js.map b/lib/analyzer/AstSymbol.js.map
index eaa705a4408e9afefb40eed8b7628ab84505d556..c3edfa9c0400cf9b439eba00bdd6df416d1cfd97 100644
--- a/lib/analyzer/AstSymbol.js.map
+++ b/lib/analyzer/AstSymbol.js.map
@@ -1 +1 @@
-{"version":3,"file":"AstSymbol.js","sourceRoot":"","sources":["../../src/analyzer/AstSymbol.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAI3D,oEAA6D;AAC7D,2CAAwC;AAcxC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgCG;AACH,MAAa,SAAU,SAAQ,qBAAS;IA6DtC,YAAmB,OAA0B;QAC3C,KAAK,EAAE,CAAC;QALV,sDAAsD;QACtD,qDAAqD;QAC7C,cAAS,GAAY,KAAK,CAAC;QAKjC,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;QAC7C,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACrC,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC;QAC/C,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC;QAC/C,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,IAAI,IAAI,CAAC;QACnD,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;IAC7B,CAAC;IAED;;;;;;;OAOG;IACH,IAAW,eAAe;QACxB,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAED;;;;;;OAMG;IACH,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC;IACtC,CAAC;IAED;;;;OAIG;IACI,wBAAwB,CAAC,cAA8B;QAC5D,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,MAAM,IAAI,iCAAa,CAAC,sEAAsE,CAAC,CAAC;SACjG;QACD,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IAC7C,CAAC;IAED;;;;OAIG;IACI,eAAe;QACpB,IAAI,IAAI,CAAC,eAAe,EAAE;YACxB,MAAM,IAAI,iCAAa,CAAC,iEAAiE,CAAC,CAAC;SAC5F;QACD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;IACxB,CAAC;IAED;;OAEG;IACI,2BAA2B,CAAC,MAAgD;QACjF,KAAK,MAAM,cAAc,IAAI,IAAI,CAAC,eAAe,EAAE;YACjD,cAAc,CAAC,2BAA2B,CAAC,MAAM,CAAC,CAAC;SACpD;IACH,CAAC;CACF;AAhID,8BAgIC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type * as ts from 'typescript';\nimport type { AstDeclaration } from './AstDeclaration';\nimport { InternalError } from '@rushstack/node-core-library';\nimport { AstEntity } from './AstEntity';\n\n/**\n * Constructor options for AstSymbol\n */\nexport interface IAstSymbolOptions {\n  readonly followedSymbol: ts.Symbol;\n  readonly localName: string;\n  readonly isExternal: boolean;\n  readonly nominalAnalysis: boolean;\n  readonly parentAstSymbol: AstSymbol | undefined;\n  readonly rootAstSymbol: AstSymbol | undefined;\n}\n\n/**\n * The AstDeclaration and AstSymbol classes are API Extractor's equivalent of the compiler's\n * ts.Declaration and ts.Symbol objects.  They are created by the `AstSymbolTable` class.\n *\n * @remarks\n * The AstSymbol represents the ts.Symbol information for an AstDeclaration.  For example,\n * if a method has 3 overloads, each overloaded signature will have its own AstDeclaration,\n * but they will all share a common AstSymbol.\n *\n * For nested definitions, the AstSymbol has a unique parent (i.e. AstSymbol.rootAstSymbol),\n * but the parent/children for each AstDeclaration may be different.  Consider this example:\n *\n * ```ts\n * export namespace N {\n *   export function f(): void { }\n * }\n *\n * export interface N {\n *   g(): void;\n * }\n * ```\n *\n * Note how the parent/child relationships are different for the symbol tree versus\n * the declaration tree, and the declaration tree has two roots:\n *\n * ```\n * AstSymbol tree:            AstDeclaration tree:\n * - N                        - N (namespace)\n *   - f                        - f\n *   - g                      - N (interface)\n *                              - g\n * ```\n */\nexport class AstSymbol extends AstEntity {\n  /** {@inheritdoc} */\n  public readonly localName: string; // abstract\n\n  /**\n   * If true, then the `followedSymbol` (i.e. original declaration) of this symbol\n   * is not part of the working package.  The working package may still export this symbol,\n   * but if so it should be emitted as an alias such as `export { X } from \"package1\";`.\n   */\n  public readonly isExternal: boolean;\n\n  /**\n   * The compiler symbol where this type was defined, after following any aliases.\n   *\n   * @remarks\n   * This is a normal form that can be reached from any symbol alias by calling\n   * `TypeScriptHelpers.followAliases()`.  It can be compared to determine whether two\n   * symbols refer to the same underlying type.\n   */\n  public readonly followedSymbol: ts.Symbol;\n\n  /**\n   * If true, then this AstSymbol represents a foreign object whose structure will be\n   * ignored.  The AstDeclaration objects will not have any parent or children, and its references\n   * will not be analyzed.\n   *\n   * Nominal symbols are tracked e.g. when they are reexported by the working package.\n   */\n  public readonly nominalAnalysis: boolean;\n\n  /**\n   * Returns the symbol of the parent of this AstSymbol, or undefined if there is no parent.\n   * @remarks\n   * If a symbol has multiple declarations, we assume (as an axiom) that their parent\n   * declarations will belong to the same symbol.  This means that the \"parent\" of a\n   * symbol is a well-defined concept.  However, the \"children\" of a symbol are not very\n   * meaningful, because different declarations may have different nested members,\n   * so we usually need to traverse declarations to find children.\n   */\n  public readonly parentAstSymbol: AstSymbol | undefined;\n\n  /**\n   * Returns the symbol of the root of the AstDeclaration hierarchy.\n   * @remarks\n   * NOTE: If this AstSymbol is the root, then rootAstSymbol will point to itself.\n   */\n  public readonly rootAstSymbol: AstSymbol;\n\n  /**\n   * Additional information that is calculated later by the `Collector`.  The actual type is `SymbolMetadata`,\n   * but we declare it as `unknown` because consumers must obtain this object by calling\n   * `Collector.fetchSymbolMetadata()`.\n   */\n  public symbolMetadata: unknown;\n\n  private readonly _astDeclarations: AstDeclaration[];\n\n  // This flag is unused if this is not the root symbol.\n  // Being \"analyzed\" is a property of the root symbol.\n  private _analyzed: boolean = false;\n\n  public constructor(options: IAstSymbolOptions) {\n    super();\n\n    this.followedSymbol = options.followedSymbol;\n    this.localName = options.localName;\n    this.isExternal = options.isExternal;\n    this.nominalAnalysis = options.nominalAnalysis;\n    this.parentAstSymbol = options.parentAstSymbol;\n    this.rootAstSymbol = options.rootAstSymbol || this;\n    this._astDeclarations = [];\n  }\n\n  /**\n   * The one or more declarations for this symbol.\n   * @remarks\n   * For example, if this symbol is a method, then the declarations might be\n   * various method overloads.  If this symbol is a namespace, then the declarations\n   * might be separate namespace blocks with the same name that get combined via\n   * declaration merging.\n   */\n  public get astDeclarations(): ReadonlyArray<AstDeclaration> {\n    return this._astDeclarations;\n  }\n\n  /**\n   * Returns true if the AstSymbolTable.analyze() was called for this object.\n   * See that function for details.\n   * @remarks\n   * AstSymbolTable.analyze() is always performed on the root AstSymbol.  This function\n   * returns true if-and-only-if the root symbol was analyzed.\n   */\n  public get analyzed(): boolean {\n    return this.rootAstSymbol._analyzed;\n  }\n\n  /**\n   * This is an internal callback used when the AstSymbolTable attaches a new\n   * AstDeclaration to this object.\n   * @internal\n   */\n  public _notifyDeclarationAttach(astDeclaration: AstDeclaration): void {\n    if (this.analyzed) {\n      throw new InternalError('_notifyDeclarationAttach() called after analysis is already complete');\n    }\n    this._astDeclarations.push(astDeclaration);\n  }\n\n  /**\n   * This is an internal callback used when the AstSymbolTable.analyze()\n   * has processed this object.\n   * @internal\n   */\n  public _notifyAnalyzed(): void {\n    if (this.parentAstSymbol) {\n      throw new InternalError('_notifyAnalyzed() called for an AstSymbol which is not the root');\n    }\n    this._analyzed = true;\n  }\n\n  /**\n   * Helper that calls AstDeclaration.forEachDeclarationRecursive() for each AstDeclaration.\n   */\n  public forEachDeclarationRecursive(action: (astDeclaration: AstDeclaration) => void): void {\n    for (const astDeclaration of this.astDeclarations) {\n      astDeclaration.forEachDeclarationRecursive(action);\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"AstSymbol.js","sourceRoot":"","sources":["../../src/analyzer/AstSymbol.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAI3D,oEAA6D;AAC7D,2CAAwC;AAcxC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgCG;AACH,MAAa,SAAU,SAAQ,qBAAS;IA6DtC,YAAmB,OAA0B;QAC3C,KAAK,EAAE,CAAC;QALV,sDAAsD;QACtD,qDAAqD;QAC7C,cAAS,GAAY,KAAK,CAAC;QAKjC,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;QAC7C,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACrC,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC;QAC/C,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC;QAC/C,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,IAAI,IAAI,CAAC;QACnD,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;IAC7B,CAAC;IAED;;;;;;;OAOG;IACH,IAAW,eAAe;QACxB,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAED;;;;;;OAMG;IACH,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC;IACtC,CAAC;IAED;;;;OAIG;IACI,wBAAwB,CAAC,cAA8B;QAC5D,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,MAAM,IAAI,iCAAa,CAAC,sEAAsE,CAAC,CAAC;SACjG;QACD,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IAC7C,CAAC;IAED;;;;OAIG;IACI,eAAe;QACpB,IAAI,IAAI,CAAC,eAAe,EAAE;YACxB,MAAM,IAAI,iCAAa,CAAC,iEAAiE,CAAC,CAAC;SAC5F;QACD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;IACxB,CAAC;IAED;;OAEG;IACI,2BAA2B,CAAC,MAAgD;QACjF,KAAK,MAAM,cAAc,IAAI,IAAI,CAAC,eAAe,EAAE;YACjD,cAAc,CAAC,2BAA2B,CAAC,MAAM,CAAC,CAAC;SACpD;IACH,CAAC;CACF;AAhID,8BAgIC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport type * as ts from 'typescript';\r\nimport type { AstDeclaration } from './AstDeclaration';\r\nimport { InternalError } from '@rushstack/node-core-library';\r\nimport { AstEntity } from './AstEntity';\r\n\r\n/**\r\n * Constructor options for AstSymbol\r\n */\r\nexport interface IAstSymbolOptions {\r\n  readonly followedSymbol: ts.Symbol;\r\n  readonly localName: string;\r\n  readonly isExternal: boolean;\r\n  readonly nominalAnalysis: boolean;\r\n  readonly parentAstSymbol: AstSymbol | undefined;\r\n  readonly rootAstSymbol: AstSymbol | undefined;\r\n}\r\n\r\n/**\r\n * The AstDeclaration and AstSymbol classes are API Extractor's equivalent of the compiler's\r\n * ts.Declaration and ts.Symbol objects.  They are created by the `AstSymbolTable` class.\r\n *\r\n * @remarks\r\n * The AstSymbol represents the ts.Symbol information for an AstDeclaration.  For example,\r\n * if a method has 3 overloads, each overloaded signature will have its own AstDeclaration,\r\n * but they will all share a common AstSymbol.\r\n *\r\n * For nested definitions, the AstSymbol has a unique parent (i.e. AstSymbol.rootAstSymbol),\r\n * but the parent/children for each AstDeclaration may be different.  Consider this example:\r\n *\r\n * ```ts\r\n * export namespace N {\r\n *   export function f(): void { }\r\n * }\r\n *\r\n * export interface N {\r\n *   g(): void;\r\n * }\r\n * ```\r\n *\r\n * Note how the parent/child relationships are different for the symbol tree versus\r\n * the declaration tree, and the declaration tree has two roots:\r\n *\r\n * ```\r\n * AstSymbol tree:            AstDeclaration tree:\r\n * - N                        - N (namespace)\r\n *   - f                        - f\r\n *   - g                      - N (interface)\r\n *                              - g\r\n * ```\r\n */\r\nexport class AstSymbol extends AstEntity {\r\n  /** {@inheritdoc} */\r\n  public readonly localName: string; // abstract\r\n\r\n  /**\r\n   * If true, then the `followedSymbol` (i.e. original declaration) of this symbol\r\n   * is not part of the working package.  The working package may still export this symbol,\r\n   * but if so it should be emitted as an alias such as `export { X } from \"package1\";`.\r\n   */\r\n  public readonly isExternal: boolean;\r\n\r\n  /**\r\n   * The compiler symbol where this type was defined, after following any aliases.\r\n   *\r\n   * @remarks\r\n   * This is a normal form that can be reached from any symbol alias by calling\r\n   * `TypeScriptHelpers.followAliases()`.  It can be compared to determine whether two\r\n   * symbols refer to the same underlying type.\r\n   */\r\n  public readonly followedSymbol: ts.Symbol;\r\n\r\n  /**\r\n   * If true, then this AstSymbol represents a foreign object whose structure will be\r\n   * ignored.  The AstDeclaration objects will not have any parent or children, and its references\r\n   * will not be analyzed.\r\n   *\r\n   * Nominal symbols are tracked e.g. when they are reexported by the working package.\r\n   */\r\n  public readonly nominalAnalysis: boolean;\r\n\r\n  /**\r\n   * Returns the symbol of the parent of this AstSymbol, or undefined if there is no parent.\r\n   * @remarks\r\n   * If a symbol has multiple declarations, we assume (as an axiom) that their parent\r\n   * declarations will belong to the same symbol.  This means that the \"parent\" of a\r\n   * symbol is a well-defined concept.  However, the \"children\" of a symbol are not very\r\n   * meaningful, because different declarations may have different nested members,\r\n   * so we usually need to traverse declarations to find children.\r\n   */\r\n  public readonly parentAstSymbol: AstSymbol | undefined;\r\n\r\n  /**\r\n   * Returns the symbol of the root of the AstDeclaration hierarchy.\r\n   * @remarks\r\n   * NOTE: If this AstSymbol is the root, then rootAstSymbol will point to itself.\r\n   */\r\n  public readonly rootAstSymbol: AstSymbol;\r\n\r\n  /**\r\n   * Additional information that is calculated later by the `Collector`.  The actual type is `SymbolMetadata`,\r\n   * but we declare it as `unknown` because consumers must obtain this object by calling\r\n   * `Collector.fetchSymbolMetadata()`.\r\n   */\r\n  public symbolMetadata: unknown;\r\n\r\n  private readonly _astDeclarations: AstDeclaration[];\r\n\r\n  // This flag is unused if this is not the root symbol.\r\n  // Being \"analyzed\" is a property of the root symbol.\r\n  private _analyzed: boolean = false;\r\n\r\n  public constructor(options: IAstSymbolOptions) {\r\n    super();\r\n\r\n    this.followedSymbol = options.followedSymbol;\r\n    this.localName = options.localName;\r\n    this.isExternal = options.isExternal;\r\n    this.nominalAnalysis = options.nominalAnalysis;\r\n    this.parentAstSymbol = options.parentAstSymbol;\r\n    this.rootAstSymbol = options.rootAstSymbol || this;\r\n    this._astDeclarations = [];\r\n  }\r\n\r\n  /**\r\n   * The one or more declarations for this symbol.\r\n   * @remarks\r\n   * For example, if this symbol is a method, then the declarations might be\r\n   * various method overloads.  If this symbol is a namespace, then the declarations\r\n   * might be separate namespace blocks with the same name that get combined via\r\n   * declaration merging.\r\n   */\r\n  public get astDeclarations(): ReadonlyArray<AstDeclaration> {\r\n    return this._astDeclarations;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the AstSymbolTable.analyze() was called for this object.\r\n   * See that function for details.\r\n   * @remarks\r\n   * AstSymbolTable.analyze() is always performed on the root AstSymbol.  This function\r\n   * returns true if-and-only-if the root symbol was analyzed.\r\n   */\r\n  public get analyzed(): boolean {\r\n    return this.rootAstSymbol._analyzed;\r\n  }\r\n\r\n  /**\r\n   * This is an internal callback used when the AstSymbolTable attaches a new\r\n   * AstDeclaration to this object.\r\n   * @internal\r\n   */\r\n  public _notifyDeclarationAttach(astDeclaration: AstDeclaration): void {\r\n    if (this.analyzed) {\r\n      throw new InternalError('_notifyDeclarationAttach() called after analysis is already complete');\r\n    }\r\n    this._astDeclarations.push(astDeclaration);\r\n  }\r\n\r\n  /**\r\n   * This is an internal callback used when the AstSymbolTable.analyze()\r\n   * has processed this object.\r\n   * @internal\r\n   */\r\n  public _notifyAnalyzed(): void {\r\n    if (this.parentAstSymbol) {\r\n      throw new InternalError('_notifyAnalyzed() called for an AstSymbol which is not the root');\r\n    }\r\n    this._analyzed = true;\r\n  }\r\n\r\n  /**\r\n   * Helper that calls AstDeclaration.forEachDeclarationRecursive() for each AstDeclaration.\r\n   */\r\n  public forEachDeclarationRecursive(action: (astDeclaration: AstDeclaration) => void): void {\r\n    for (const astDeclaration of this.astDeclarations) {\r\n      astDeclaration.forEachDeclarationRecursive(action);\r\n    }\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/AstSymbolTable.js.map b/lib/analyzer/AstSymbolTable.js.map
index e51ed8cef0ff6a65cf5821161cc33eb3239bf9f3..ac91e0712fb8a2d5264e762b6efae96922902594 100644
--- a/lib/analyzer/AstSymbolTable.js.map
+++ b/lib/analyzer/AstSymbolTable.js.map
@@ -1 +1 @@
-{"version":3,"file":"AstSymbolTable.js","sourceRoot":"","sources":["../../src/analyzer/AstSymbolTable.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/* eslint-disable no-bitwise */ // for ts.SymbolFlags\n\nimport * as ts from 'typescript';\nimport { type PackageJsonLookup, InternalError } from '@rushstack/node-core-library';\n\nimport { AstDeclaration } from './AstDeclaration';\nimport { TypeScriptHelpers } from './TypeScriptHelpers';\nimport { AstSymbol } from './AstSymbol';\nimport type { AstModule, AstModuleExportInfo } from './AstModule';\nimport { PackageMetadataManager } from './PackageMetadataManager';\nimport { ExportAnalyzer } from './ExportAnalyzer';\nimport type { AstEntity } from './AstEntity';\nimport { AstNamespaceImport } from './AstNamespaceImport';\nimport type { MessageRouter } from '../collector/MessageRouter';\nimport { TypeScriptInternals, type IGlobalVariableAnalyzer } from './TypeScriptInternals';\nimport { SyntaxHelpers } from './SyntaxHelpers';\nimport { SourceFileLocationFormatter } from './SourceFileLocationFormatter';\n\n/**\n * Options for `AstSymbolTable._fetchAstSymbol()`\n */\nexport interface IFetchAstSymbolOptions {\n  /**\n   * The symbol after any symbol aliases have been followed using TypeScriptHelpers.followAliases()\n   */\n  followedSymbol: ts.Symbol;\n  /**\n   * True if followedSymbol is not part of the working package\n   */\n  isExternal: boolean;\n\n  /**\n   * If true, symbols with AstSymbol.nominalAnalysis=true will be returned.\n   * Otherwise `undefined` will be returned for such symbols.\n   */\n  includeNominalAnalysis: boolean;\n\n  /**\n   * True while populating the `AstSymbolTable`; false if we're doing a passive lookup\n   * without adding anything new to the table\n   */\n  addIfMissing: boolean;\n\n  /**\n   * A hint to help `_fetchAstSymbol()` determine the `AstSymbol.localName`.\n   */\n  localName?: string;\n}\n\n/**\n * AstSymbolTable is the workhorse that builds AstSymbol and AstDeclaration objects.\n * It maintains a cache of already constructed objects.  AstSymbolTable constructs\n * AstModule objects, but otherwise the state that it maintains is agnostic of\n * any particular entry point.  (For example, it does not track whether a given AstSymbol\n * is \"exported\" or not.)\n *\n * Internally, AstSymbolTable relies on ExportAnalyzer to crawl import statements and determine where symbols\n * are declared (i.e. the AstImport information needed to import them).\n */\nexport class AstSymbolTable {\n  private readonly _program: ts.Program;\n  private readonly _typeChecker: ts.TypeChecker;\n  private readonly _messageRouter: MessageRouter;\n  private readonly _globalVariableAnalyzer: IGlobalVariableAnalyzer;\n  private readonly _packageMetadataManager: PackageMetadataManager;\n  private readonly _exportAnalyzer: ExportAnalyzer;\n  private readonly _alreadyWarnedGlobalNames: Set<string>;\n\n  /**\n   * A mapping from ts.Symbol --> AstSymbol\n   * NOTE: The AstSymbol.followedSymbol will always be a lookup key, but additional keys\n   * are possible.\n   *\n   * After following type aliases, we use this map to look up the corresponding AstSymbol.\n   */\n  private readonly _astSymbolsBySymbol: Map<ts.Symbol, AstSymbol> = new Map<ts.Symbol, AstSymbol>();\n\n  /**\n   * A mapping from ts.Declaration --> AstDeclaration\n   */\n  private readonly _astDeclarationsByDeclaration: Map<ts.Node, AstDeclaration> = new Map<\n    ts.Node,\n    AstDeclaration\n  >();\n\n  // Note that this is a mapping from specific AST nodes that we analyzed, based on the underlying symbol\n  // for that node.\n  private readonly _entitiesByNode: Map<ts.Identifier | ts.ImportTypeNode, AstEntity | undefined> = new Map<\n    ts.Identifier,\n    AstEntity | undefined\n  >();\n\n  public constructor(\n    program: ts.Program,\n    typeChecker: ts.TypeChecker,\n    packageJsonLookup: PackageJsonLookup,\n    bundledPackageNames: ReadonlySet<string>,\n    messageRouter: MessageRouter\n  ) {\n    this._program = program;\n    this._typeChecker = typeChecker;\n    this._messageRouter = messageRouter;\n    this._globalVariableAnalyzer = TypeScriptInternals.getGlobalVariableAnalyzer(program);\n    this._packageMetadataManager = new PackageMetadataManager(packageJsonLookup, messageRouter);\n\n    this._exportAnalyzer = new ExportAnalyzer(this._program, this._typeChecker, bundledPackageNames, {\n      analyze: this.analyze.bind(this),\n      fetchAstSymbol: this._fetchAstSymbol.bind(this)\n    });\n\n    this._alreadyWarnedGlobalNames = new Set<string>();\n  }\n\n  /**\n   * Used to analyze an entry point that belongs to the working package.\n   */\n  public fetchAstModuleFromWorkingPackage(sourceFile: ts.SourceFile): AstModule {\n    return this._exportAnalyzer.fetchAstModuleFromSourceFile(sourceFile, undefined, false);\n  }\n\n  /**\n   * This crawls the specified entry point and collects the full set of exported AstSymbols.\n   */\n  public fetchAstModuleExportInfo(astModule: AstModule): AstModuleExportInfo {\n    return this._exportAnalyzer.fetchAstModuleExportInfo(astModule);\n  }\n\n  /**\n   * Attempts to retrieve an export by name from the specified `AstModule`.\n   * Returns undefined if no match was found.\n   */\n  public tryGetExportOfAstModule(exportName: string, astModule: AstModule): AstEntity | undefined {\n    return this._exportAnalyzer.tryGetExportOfAstModule(exportName, astModule);\n  }\n\n  /**\n   * Ensures that AstSymbol.analyzed is true for the provided symbol.  The operation\n   * starts from the root symbol and then fills out all children of all declarations, and\n   * also calculates AstDeclaration.referencedAstSymbols for all declarations.\n   * If the symbol is not imported, any non-imported references are also analyzed.\n   *\n   * @remarks\n   * This is an expensive operation, so we only perform it for top-level exports of an\n   * the AstModule.  For example, if some code references a nested class inside\n   * a namespace from another library, we do not analyze any of that class's siblings\n   * or members.  (We do always construct its parents however, since AstDefinition.parent\n   * is immutable, and needed e.g. to calculate release tag inheritance.)\n   */\n  public analyze(astEntity: AstEntity): void {\n    if (astEntity instanceof AstSymbol) {\n      return this._analyzeAstSymbol(astEntity);\n    }\n\n    if (astEntity instanceof AstNamespaceImport) {\n      return this._analyzeAstNamespaceImport(astEntity);\n    }\n  }\n\n  /**\n   * For a given astDeclaration, this efficiently finds the child corresponding to the\n   * specified ts.Node.  It is assumed that AstDeclaration.isSupportedSyntaxKind() would return true for\n   * that node type, and that the node is an immediate child of the provided AstDeclaration.\n   */\n  // NOTE: This could be a method of AstSymbol if it had a backpointer to its AstSymbolTable.\n  public getChildAstDeclarationByNode(node: ts.Node, parentAstDeclaration: AstDeclaration): AstDeclaration {\n    if (!parentAstDeclaration.astSymbol.analyzed) {\n      throw new Error('getChildDeclarationByNode() cannot be used for an AstSymbol that was not analyzed');\n    }\n\n    const childAstDeclaration: AstDeclaration | undefined = this._astDeclarationsByDeclaration.get(node);\n    if (!childAstDeclaration) {\n      throw new Error('Child declaration not found for the specified node');\n    }\n    if (childAstDeclaration.parent !== parentAstDeclaration) {\n      throw new InternalError('The found child is not attached to the parent AstDeclaration');\n    }\n\n    return childAstDeclaration;\n  }\n\n  /**\n   * For a given ts.Identifier that is part of an AstSymbol that we analyzed, return the AstEntity that\n   * it refers to.  Returns undefined if it doesn't refer to anything interesting.\n   * @remarks\n   * Throws an Error if the ts.Identifier is not part of node tree that was analyzed.\n   */\n  public tryGetEntityForNode(identifier: ts.Identifier | ts.ImportTypeNode): AstEntity | undefined {\n    if (!this._entitiesByNode.has(identifier)) {\n      throw new InternalError('tryGetEntityForIdentifier() called for an identifier that was not analyzed');\n    }\n    return this._entitiesByNode.get(identifier);\n  }\n\n  /**\n   * Builds an AstSymbol.localName for a given ts.Symbol.  In the current implementation, the localName is\n   * a TypeScript-like expression that may be a string literal or ECMAScript symbol expression.\n   *\n   * ```ts\n   * class X {\n   *   // localName=\"identifier\"\n   *   public identifier: number = 1;\n   *   // localName=\"\\\"identifier\\\"\"\n   *   public \"quoted string!\": number = 2;\n   *   // localName=\"[MyNamespace.MySymbol]\"\n   *   public [MyNamespace.MySymbol]: number = 3;\n   * }\n   * ```\n   */\n  public static getLocalNameForSymbol(symbol: ts.Symbol): string {\n    // TypeScript binds well-known ECMAScript symbols like \"[Symbol.iterator]\" as \"__@iterator\".\n    // Decode it back into \"[Symbol.iterator]\".\n    const wellKnownSymbolName: string | undefined = TypeScriptHelpers.tryDecodeWellKnownSymbolName(\n      symbol.escapedName\n    );\n    if (wellKnownSymbolName) {\n      return wellKnownSymbolName;\n    }\n\n    const isUniqueSymbol: boolean = TypeScriptHelpers.isUniqueSymbolName(symbol.escapedName);\n\n    // We will try to obtain the name from a declaration; otherwise we'll fall back to the symbol name.\n    let unquotedName: string = symbol.name;\n\n    for (const declaration of symbol.declarations || []) {\n      // Handle cases such as \"export default class X { }\" where the symbol name is \"default\"\n      // but the local name is \"X\".\n      const localSymbol: ts.Symbol | undefined = TypeScriptInternals.tryGetLocalSymbol(declaration);\n      if (localSymbol) {\n        unquotedName = localSymbol.name;\n      }\n\n      // If it is a non-well-known symbol, then return the late-bound name.  For example, \"X.Y.z\" in this example:\n      //\n      //   namespace X {\n      //     export namespace Y {\n      //       export const z: unique symbol = Symbol(\"z\");\n      //     }\n      //  }\n      //\n      //  class C {\n      //    public [X.Y.z](): void { }\n      //  }\n      //\n      if (isUniqueSymbol) {\n        const declarationName: ts.DeclarationName | undefined = ts.getNameOfDeclaration(declaration);\n        if (declarationName && ts.isComputedPropertyName(declarationName)) {\n          const lateBoundName: string | undefined = TypeScriptHelpers.tryGetLateBoundName(declarationName);\n          if (lateBoundName) {\n            // Here the string may contain an expression such as \"[X.Y.z]\".  Names starting with \"[\" are always\n            // expressions.  If a string literal contains those characters, the code below will JSON.stringify() it\n            // to avoid a collision.\n            return lateBoundName;\n          }\n        }\n      }\n    }\n\n    // Otherwise that name may come from a quoted string or pseudonym like `__constructor`.\n    // If the string is not a safe identifier, then we must add quotes.\n    // Note that if it was quoted but did not need to be quoted, here we will remove the quotes.\n    if (!SyntaxHelpers.isSafeUnquotedMemberIdentifier(unquotedName)) {\n      // For API Extractor's purposes, a canonical form is more appropriate than trying to reflect whatever\n      // appeared in the source code.  The code is not even guaranteed to be consistent, for example:\n      //\n      //   class X {\n      //     public \"f1\"(x: string): void;\n      //     public f1(x: boolean): void;\n      //     public 'f1'(x: string | boolean): void { }\n      //   }\n      return JSON.stringify(unquotedName);\n    }\n\n    return unquotedName;\n  }\n\n  private _analyzeAstNamespaceImport(astNamespaceImport: AstNamespaceImport): void {\n    if (astNamespaceImport.analyzed) {\n      return;\n    }\n\n    // mark before actual analyzing, to handle module cyclic reexport\n    astNamespaceImport.analyzed = true;\n\n    const exportedLocalEntities: Map<string, AstEntity> = this.fetchAstModuleExportInfo(\n      astNamespaceImport.astModule\n    ).exportedLocalEntities;\n\n    for (const exportedEntity of exportedLocalEntities.values()) {\n      this.analyze(exportedEntity);\n    }\n  }\n\n  private _analyzeAstSymbol(astSymbol: AstSymbol): void {\n    if (astSymbol.analyzed) {\n      return;\n    }\n\n    if (astSymbol.nominalAnalysis) {\n      // We don't analyze nominal symbols\n      astSymbol._notifyAnalyzed();\n      return;\n    }\n\n    // Start at the root of the tree\n    const rootAstSymbol: AstSymbol = astSymbol.rootAstSymbol;\n\n    // Calculate the full child tree for each definition\n    for (const astDeclaration of rootAstSymbol.astDeclarations) {\n      this._analyzeChildTree(astDeclaration.declaration, astDeclaration);\n    }\n\n    rootAstSymbol._notifyAnalyzed();\n\n    if (!astSymbol.isExternal) {\n      // If this symbol is non-external (i.e. it belongs to the working package), then we also analyze any\n      // referencedAstSymbols that are non-external.  For example, this ensures that forgotten exports\n      // get analyzed.\n      rootAstSymbol.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\n        for (const referencedAstEntity of astDeclaration.referencedAstEntities) {\n          // Walk up to the root of the tree, looking for any imports along the way\n          if (referencedAstEntity instanceof AstSymbol) {\n            if (!referencedAstEntity.isExternal) {\n              this._analyzeAstSymbol(referencedAstEntity);\n            }\n          }\n\n          if (referencedAstEntity instanceof AstNamespaceImport) {\n            if (!referencedAstEntity.astModule.isExternal) {\n              this._analyzeAstNamespaceImport(referencedAstEntity);\n            }\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Used by analyze to recursively analyze the entire child tree.\n   */\n  private _analyzeChildTree(node: ts.Node, governingAstDeclaration: AstDeclaration): void {\n    switch (node.kind) {\n      case ts.SyntaxKind.JSDocComment: // Skip JSDoc comments - TS considers @param tags TypeReference nodes\n        return;\n\n      // Is this a reference to another AstSymbol?\n      case ts.SyntaxKind.TypeReference: // general type references\n      case ts.SyntaxKind.ExpressionWithTypeArguments: // special case for e.g. the \"extends\" keyword\n      case ts.SyntaxKind.ComputedPropertyName: // used for EcmaScript \"symbols\", e.g. \"[toPrimitive]\".\n      case ts.SyntaxKind.TypeQuery: // represents for \"typeof X\" as a type\n        {\n          // Sometimes the type reference will involve multiple identifiers, e.g. \"a.b.C\".\n          // In this case, we only need to worry about importing the first identifier,\n          // so do a depth-first search for it:\n          const identifierNode: ts.Identifier | undefined = TypeScriptHelpers.findFirstChildNode(\n            node,\n            ts.SyntaxKind.Identifier\n          );\n\n          if (identifierNode) {\n            let referencedAstEntity: AstEntity | undefined = this._entitiesByNode.get(identifierNode);\n            if (!referencedAstEntity) {\n              const symbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(identifierNode);\n              if (!symbol) {\n                throw new Error('Symbol not found for identifier: ' + identifierNode.getText());\n              }\n\n              // Normally we expect getSymbolAtLocation() to take us to a declaration within the same source\n              // file, or else to an explicit \"import\" statement within the same source file.  But in certain\n              // situations (e.g. a global variable) the symbol will refer to a declaration in some other\n              // source file.  We'll call that case a \"displaced symbol\".\n              //\n              // For more info, see this discussion:\n              // https://github.com/microsoft/rushstack/issues/1765#issuecomment-595559849\n              let displacedSymbol: boolean = true;\n              for (const declaration of symbol.declarations || []) {\n                if (declaration.getSourceFile() === identifierNode.getSourceFile()) {\n                  displacedSymbol = false;\n                  break;\n                }\n              }\n\n              if (displacedSymbol) {\n                if (this._globalVariableAnalyzer.hasGlobalName(identifierNode.text)) {\n                  // If the displaced symbol is a global variable, then API Extractor simply ignores it.\n                  // Ambient declarations typically describe the runtime environment (provided by an API consumer),\n                  // so we don't bother analyzing them as an API contract.  (There are probably some packages\n                  // that include interesting global variables in their API, but API Extractor doesn't support\n                  // that yet; it would be a feature request.)\n\n                  if (this._messageRouter.showDiagnostics) {\n                    if (!this._alreadyWarnedGlobalNames.has(identifierNode.text)) {\n                      this._alreadyWarnedGlobalNames.add(identifierNode.text);\n                      this._messageRouter.logDiagnostic(\n                        `Ignoring reference to global variable \"${identifierNode.text}\"` +\n                          ` in ` +\n                          SourceFileLocationFormatter.formatDeclaration(identifierNode)\n                      );\n                    }\n                  }\n                } else {\n                  // If you encounter this, please report a bug with a repro.  We're interested to know\n                  // how it can occur.\n                  throw new InternalError(`Unable to follow symbol for \"${identifierNode.text}\"`);\n                }\n              } else {\n                referencedAstEntity = this._exportAnalyzer.fetchReferencedAstEntity(\n                  symbol,\n                  governingAstDeclaration.astSymbol.isExternal\n                );\n\n                this._entitiesByNode.set(identifierNode, referencedAstEntity);\n              }\n            }\n\n            if (referencedAstEntity) {\n              governingAstDeclaration._notifyReferencedAstEntity(referencedAstEntity);\n            }\n          }\n        }\n        break;\n\n      // Is this the identifier for the governingAstDeclaration?\n      case ts.SyntaxKind.Identifier:\n        {\n          const identifierNode: ts.Identifier = node as ts.Identifier;\n          if (!this._entitiesByNode.has(identifierNode)) {\n            const symbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(identifierNode);\n\n            let referencedAstEntity: AstEntity | undefined = undefined;\n\n            if (symbol === governingAstDeclaration.astSymbol.followedSymbol) {\n              referencedAstEntity = this._fetchEntityForNode(identifierNode, governingAstDeclaration);\n            }\n\n            this._entitiesByNode.set(identifierNode, referencedAstEntity);\n          }\n        }\n        break;\n\n      case ts.SyntaxKind.ImportType:\n        {\n          const importTypeNode: ts.ImportTypeNode = node as ts.ImportTypeNode;\n          let referencedAstEntity: AstEntity | undefined = this._entitiesByNode.get(importTypeNode);\n\n          if (!this._entitiesByNode.has(importTypeNode)) {\n            referencedAstEntity = this._fetchEntityForNode(importTypeNode, governingAstDeclaration);\n\n            if (!referencedAstEntity) {\n              // This should never happen\n              throw new Error('Failed to fetch entity for import() type node: ' + importTypeNode.getText());\n            }\n\n            this._entitiesByNode.set(importTypeNode, referencedAstEntity);\n          }\n\n          if (referencedAstEntity) {\n            governingAstDeclaration._notifyReferencedAstEntity(referencedAstEntity);\n          }\n        }\n        break;\n    }\n\n    // Is this node declaring a new AstSymbol?\n    const newGoverningAstDeclaration: AstDeclaration | undefined = this._fetchAstDeclaration(\n      node,\n      governingAstDeclaration.astSymbol.isExternal\n    );\n\n    for (const childNode of node.getChildren()) {\n      this._analyzeChildTree(childNode, newGoverningAstDeclaration || governingAstDeclaration);\n    }\n  }\n\n  private _fetchEntityForNode(\n    node: ts.Identifier | ts.ImportTypeNode,\n    governingAstDeclaration: AstDeclaration\n  ): AstEntity | undefined {\n    let referencedAstEntity: AstEntity | undefined = this._entitiesByNode.get(node);\n    if (!referencedAstEntity) {\n      if (node.kind === ts.SyntaxKind.ImportType) {\n        referencedAstEntity = this._exportAnalyzer.fetchReferencedAstEntityFromImportTypeNode(\n          node,\n          governingAstDeclaration.astSymbol.isExternal\n        );\n      } else {\n        const symbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(node);\n        if (!symbol) {\n          throw new Error('Symbol not found for identifier: ' + node.getText());\n        }\n\n        referencedAstEntity = this._exportAnalyzer.fetchReferencedAstEntity(\n          symbol,\n          governingAstDeclaration.astSymbol.isExternal\n        );\n      }\n\n      this._entitiesByNode.set(node, referencedAstEntity);\n    }\n    return referencedAstEntity;\n  }\n\n  private _fetchAstDeclaration(node: ts.Node, isExternal: boolean): AstDeclaration | undefined {\n    if (!AstDeclaration.isSupportedSyntaxKind(node.kind)) {\n      return undefined;\n    }\n\n    const symbol: ts.Symbol | undefined = TypeScriptHelpers.getSymbolForDeclaration(\n      node as ts.Declaration,\n      this._typeChecker\n    );\n    if (!symbol) {\n      throw new InternalError('Unable to find symbol for node');\n    }\n\n    const astSymbol: AstSymbol | undefined = this._fetchAstSymbol({\n      followedSymbol: symbol,\n      isExternal: isExternal,\n      includeNominalAnalysis: true,\n      addIfMissing: true\n    });\n\n    if (!astSymbol) {\n      return undefined;\n    }\n\n    const astDeclaration: AstDeclaration | undefined = this._astDeclarationsByDeclaration.get(node);\n\n    if (!astDeclaration) {\n      throw new InternalError('Unable to find constructed AstDeclaration');\n    }\n\n    return astDeclaration;\n  }\n\n  private _fetchAstSymbol(options: IFetchAstSymbolOptions): AstSymbol | undefined {\n    const followedSymbol: ts.Symbol = options.followedSymbol;\n\n    // Filter out symbols representing constructs that we don't care about\n    const arbitraryDeclaration: ts.Declaration | undefined =\n      TypeScriptHelpers.tryGetADeclaration(followedSymbol);\n    if (!arbitraryDeclaration) {\n      return undefined;\n    }\n\n    if (\n      followedSymbol.flags &\n      (ts.SymbolFlags.TypeParameter | ts.SymbolFlags.TypeLiteral | ts.SymbolFlags.Transient)\n    ) {\n      if (!TypeScriptInternals.isLateBoundSymbol(followedSymbol)) {\n        return undefined;\n      }\n    }\n\n    // API Extractor doesn't analyze ambient declarations at all\n    if (TypeScriptHelpers.isAmbient(followedSymbol, this._typeChecker)) {\n      // We make a special exemption for ambient declarations that appear in a source file containing\n      // an \"export=\" declaration that allows them to be imported as non-ambient.\n      if (!this._exportAnalyzer.isImportableAmbientSourceFile(arbitraryDeclaration.getSourceFile())) {\n        return undefined;\n      }\n    }\n\n    // Make sure followedSymbol isn't an alias for something else\n    if (TypeScriptHelpers.isFollowableAlias(followedSymbol, this._typeChecker)) {\n      // We expect the caller to have already followed any aliases\n      throw new InternalError('AstSymbolTable._fetchAstSymbol() cannot be called with a symbol alias');\n    }\n\n    let astSymbol: AstSymbol | undefined = this._astSymbolsBySymbol.get(followedSymbol);\n\n    if (!astSymbol) {\n      // None of the above lookups worked, so create a new entry...\n      let nominalAnalysis: boolean = false;\n\n      if (options.isExternal) {\n        // If the file is from an external package that does not support AEDoc, normally we ignore it completely.\n        // But in some cases (e.g. checking star exports of an external package) we need an AstSymbol to\n        // represent it, but we don't need to analyze its sibling/children.\n        const followedSymbolSourceFileName: string = arbitraryDeclaration.getSourceFile().fileName;\n\n        if (!this._packageMetadataManager.isAedocSupportedFor(followedSymbolSourceFileName)) {\n          nominalAnalysis = true;\n\n          if (!options.includeNominalAnalysis) {\n            return undefined;\n          }\n        }\n      }\n\n      let parentAstSymbol: AstSymbol | undefined = undefined;\n\n      if (!nominalAnalysis) {\n        for (const declaration of followedSymbol.declarations || []) {\n          if (!AstDeclaration.isSupportedSyntaxKind(declaration.kind)) {\n            throw new InternalError(\n              `The \"${followedSymbol.name}\" symbol has a` +\n                ` ts.SyntaxKind.${ts.SyntaxKind[declaration.kind]} declaration which is not (yet?)` +\n                ` supported by API Extractor`\n            );\n          }\n        }\n\n        // We always fetch the entire chain of parents for each declaration.\n        // (Children/siblings are only analyzed on demand.)\n\n        // Key assumptions behind this squirrely logic:\n        //\n        // IF a given symbol has two declarations D1 and D2; AND\n        // If D1 has a parent P1, then\n        // - D2 will also have a parent P2; AND\n        // - P1 and P2's symbol will be the same\n        // - but P1 and P2 may be different (e.g. merged namespaces containing merged interfaces)\n\n        // Is there a parent AstSymbol?  First we check to see if there is a parent declaration:\n        if (arbitraryDeclaration) {\n          const arbitraryParentDeclaration: ts.Node | undefined =\n            this._tryFindFirstAstDeclarationParent(arbitraryDeclaration);\n\n          if (arbitraryParentDeclaration) {\n            const parentSymbol: ts.Symbol = TypeScriptHelpers.getSymbolForDeclaration(\n              arbitraryParentDeclaration as ts.Declaration,\n              this._typeChecker\n            );\n\n            parentAstSymbol = this._fetchAstSymbol({\n              followedSymbol: parentSymbol,\n              isExternal: options.isExternal,\n              includeNominalAnalysis: false,\n              addIfMissing: true\n            });\n            if (!parentAstSymbol) {\n              throw new InternalError('Unable to construct a parent AstSymbol for ' + followedSymbol.name);\n            }\n          }\n        }\n      }\n\n      const localName: string | undefined =\n        options.localName || AstSymbolTable.getLocalNameForSymbol(followedSymbol);\n\n      astSymbol = new AstSymbol({\n        followedSymbol: followedSymbol,\n        localName: localName,\n        isExternal: options.isExternal,\n        nominalAnalysis: nominalAnalysis,\n        parentAstSymbol: parentAstSymbol,\n        rootAstSymbol: parentAstSymbol ? parentAstSymbol.rootAstSymbol : undefined\n      });\n\n      this._astSymbolsBySymbol.set(followedSymbol, astSymbol);\n\n      // Okay, now while creating the declarations we will wire them up to the\n      // their corresponding parent declarations\n      for (const declaration of followedSymbol.declarations || []) {\n        let parentAstDeclaration: AstDeclaration | undefined = undefined;\n        if (parentAstSymbol) {\n          const parentDeclaration: ts.Node | undefined = this._tryFindFirstAstDeclarationParent(declaration);\n\n          if (!parentDeclaration) {\n            throw new InternalError('Missing parent declaration');\n          }\n\n          parentAstDeclaration = this._astDeclarationsByDeclaration.get(parentDeclaration);\n          if (!parentAstDeclaration) {\n            throw new InternalError('Missing parent AstDeclaration');\n          }\n        }\n\n        const astDeclaration: AstDeclaration = new AstDeclaration({\n          declaration,\n          astSymbol,\n          parent: parentAstDeclaration\n        });\n\n        this._astDeclarationsByDeclaration.set(declaration, astDeclaration);\n      }\n    }\n\n    if (options.isExternal !== astSymbol.isExternal) {\n      throw new InternalError(\n        `Cannot assign isExternal=${options.isExternal} for` +\n          ` the symbol ${astSymbol.localName} because it was previously registered` +\n          ` with isExternal=${astSymbol.isExternal}`\n      );\n    }\n\n    return astSymbol;\n  }\n\n  /**\n   * Returns the first parent satisfying isAstDeclaration(), or undefined if none is found.\n   */\n  private _tryFindFirstAstDeclarationParent(node: ts.Node): ts.Node | undefined {\n    let currentNode: ts.Node | undefined = node.parent;\n    while (currentNode) {\n      if (AstDeclaration.isSupportedSyntaxKind(currentNode.kind)) {\n        return currentNode;\n      }\n      currentNode = currentNode.parent;\n    }\n    return undefined;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"AstSymbolTable.js","sourceRoot":"","sources":["../../src/analyzer/AstSymbolTable.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* eslint-disable no-bitwise */ // for ts.SymbolFlags\r\n\r\nimport * as ts from 'typescript';\r\nimport { type PackageJsonLookup, InternalError } from '@rushstack/node-core-library';\r\n\r\nimport { AstDeclaration } from './AstDeclaration';\r\nimport { TypeScriptHelpers } from './TypeScriptHelpers';\r\nimport { AstSymbol } from './AstSymbol';\r\nimport type { AstModule, AstModuleExportInfo } from './AstModule';\r\nimport { PackageMetadataManager } from './PackageMetadataManager';\r\nimport { ExportAnalyzer } from './ExportAnalyzer';\r\nimport type { AstEntity } from './AstEntity';\r\nimport { AstNamespaceImport } from './AstNamespaceImport';\r\nimport type { MessageRouter } from '../collector/MessageRouter';\r\nimport { TypeScriptInternals, type IGlobalVariableAnalyzer } from './TypeScriptInternals';\r\nimport { SyntaxHelpers } from './SyntaxHelpers';\r\nimport { SourceFileLocationFormatter } from './SourceFileLocationFormatter';\r\n\r\n/**\r\n * Options for `AstSymbolTable._fetchAstSymbol()`\r\n */\r\nexport interface IFetchAstSymbolOptions {\r\n  /**\r\n   * The symbol after any symbol aliases have been followed using TypeScriptHelpers.followAliases()\r\n   */\r\n  followedSymbol: ts.Symbol;\r\n  /**\r\n   * True if followedSymbol is not part of the working package\r\n   */\r\n  isExternal: boolean;\r\n\r\n  /**\r\n   * If true, symbols with AstSymbol.nominalAnalysis=true will be returned.\r\n   * Otherwise `undefined` will be returned for such symbols.\r\n   */\r\n  includeNominalAnalysis: boolean;\r\n\r\n  /**\r\n   * True while populating the `AstSymbolTable`; false if we're doing a passive lookup\r\n   * without adding anything new to the table\r\n   */\r\n  addIfMissing: boolean;\r\n\r\n  /**\r\n   * A hint to help `_fetchAstSymbol()` determine the `AstSymbol.localName`.\r\n   */\r\n  localName?: string;\r\n}\r\n\r\n/**\r\n * AstSymbolTable is the workhorse that builds AstSymbol and AstDeclaration objects.\r\n * It maintains a cache of already constructed objects.  AstSymbolTable constructs\r\n * AstModule objects, but otherwise the state that it maintains is agnostic of\r\n * any particular entry point.  (For example, it does not track whether a given AstSymbol\r\n * is \"exported\" or not.)\r\n *\r\n * Internally, AstSymbolTable relies on ExportAnalyzer to crawl import statements and determine where symbols\r\n * are declared (i.e. the AstImport information needed to import them).\r\n */\r\nexport class AstSymbolTable {\r\n  private readonly _program: ts.Program;\r\n  private readonly _typeChecker: ts.TypeChecker;\r\n  private readonly _messageRouter: MessageRouter;\r\n  private readonly _globalVariableAnalyzer: IGlobalVariableAnalyzer;\r\n  private readonly _packageMetadataManager: PackageMetadataManager;\r\n  private readonly _exportAnalyzer: ExportAnalyzer;\r\n  private readonly _alreadyWarnedGlobalNames: Set<string>;\r\n\r\n  /**\r\n   * A mapping from ts.Symbol --> AstSymbol\r\n   * NOTE: The AstSymbol.followedSymbol will always be a lookup key, but additional keys\r\n   * are possible.\r\n   *\r\n   * After following type aliases, we use this map to look up the corresponding AstSymbol.\r\n   */\r\n  private readonly _astSymbolsBySymbol: Map<ts.Symbol, AstSymbol> = new Map<ts.Symbol, AstSymbol>();\r\n\r\n  /**\r\n   * A mapping from ts.Declaration --> AstDeclaration\r\n   */\r\n  private readonly _astDeclarationsByDeclaration: Map<ts.Node, AstDeclaration> = new Map<\r\n    ts.Node,\r\n    AstDeclaration\r\n  >();\r\n\r\n  // Note that this is a mapping from specific AST nodes that we analyzed, based on the underlying symbol\r\n  // for that node.\r\n  private readonly _entitiesByNode: Map<ts.Identifier | ts.ImportTypeNode, AstEntity | undefined> = new Map<\r\n    ts.Identifier,\r\n    AstEntity | undefined\r\n  >();\r\n\r\n  public constructor(\r\n    program: ts.Program,\r\n    typeChecker: ts.TypeChecker,\r\n    packageJsonLookup: PackageJsonLookup,\r\n    bundledPackageNames: ReadonlySet<string>,\r\n    messageRouter: MessageRouter\r\n  ) {\r\n    this._program = program;\r\n    this._typeChecker = typeChecker;\r\n    this._messageRouter = messageRouter;\r\n    this._globalVariableAnalyzer = TypeScriptInternals.getGlobalVariableAnalyzer(program);\r\n    this._packageMetadataManager = new PackageMetadataManager(packageJsonLookup, messageRouter);\r\n\r\n    this._exportAnalyzer = new ExportAnalyzer(this._program, this._typeChecker, bundledPackageNames, {\r\n      analyze: this.analyze.bind(this),\r\n      fetchAstSymbol: this._fetchAstSymbol.bind(this)\r\n    });\r\n\r\n    this._alreadyWarnedGlobalNames = new Set<string>();\r\n  }\r\n\r\n  /**\r\n   * Used to analyze an entry point that belongs to the working package.\r\n   */\r\n  public fetchAstModuleFromWorkingPackage(sourceFile: ts.SourceFile): AstModule {\r\n    return this._exportAnalyzer.fetchAstModuleFromSourceFile(sourceFile, undefined, false);\r\n  }\r\n\r\n  /**\r\n   * This crawls the specified entry point and collects the full set of exported AstSymbols.\r\n   */\r\n  public fetchAstModuleExportInfo(astModule: AstModule): AstModuleExportInfo {\r\n    return this._exportAnalyzer.fetchAstModuleExportInfo(astModule);\r\n  }\r\n\r\n  /**\r\n   * Attempts to retrieve an export by name from the specified `AstModule`.\r\n   * Returns undefined if no match was found.\r\n   */\r\n  public tryGetExportOfAstModule(exportName: string, astModule: AstModule): AstEntity | undefined {\r\n    return this._exportAnalyzer.tryGetExportOfAstModule(exportName, astModule);\r\n  }\r\n\r\n  /**\r\n   * Ensures that AstSymbol.analyzed is true for the provided symbol.  The operation\r\n   * starts from the root symbol and then fills out all children of all declarations, and\r\n   * also calculates AstDeclaration.referencedAstSymbols for all declarations.\r\n   * If the symbol is not imported, any non-imported references are also analyzed.\r\n   *\r\n   * @remarks\r\n   * This is an expensive operation, so we only perform it for top-level exports of an\r\n   * the AstModule.  For example, if some code references a nested class inside\r\n   * a namespace from another library, we do not analyze any of that class's siblings\r\n   * or members.  (We do always construct its parents however, since AstDefinition.parent\r\n   * is immutable, and needed e.g. to calculate release tag inheritance.)\r\n   */\r\n  public analyze(astEntity: AstEntity): void {\r\n    if (astEntity instanceof AstSymbol) {\r\n      return this._analyzeAstSymbol(astEntity);\r\n    }\r\n\r\n    if (astEntity instanceof AstNamespaceImport) {\r\n      return this._analyzeAstNamespaceImport(astEntity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For a given astDeclaration, this efficiently finds the child corresponding to the\r\n   * specified ts.Node.  It is assumed that AstDeclaration.isSupportedSyntaxKind() would return true for\r\n   * that node type, and that the node is an immediate child of the provided AstDeclaration.\r\n   */\r\n  // NOTE: This could be a method of AstSymbol if it had a backpointer to its AstSymbolTable.\r\n  public getChildAstDeclarationByNode(node: ts.Node, parentAstDeclaration: AstDeclaration): AstDeclaration {\r\n    if (!parentAstDeclaration.astSymbol.analyzed) {\r\n      throw new Error('getChildDeclarationByNode() cannot be used for an AstSymbol that was not analyzed');\r\n    }\r\n\r\n    const childAstDeclaration: AstDeclaration | undefined = this._astDeclarationsByDeclaration.get(node);\r\n    if (!childAstDeclaration) {\r\n      throw new Error('Child declaration not found for the specified node');\r\n    }\r\n    if (childAstDeclaration.parent !== parentAstDeclaration) {\r\n      throw new InternalError('The found child is not attached to the parent AstDeclaration');\r\n    }\r\n\r\n    return childAstDeclaration;\r\n  }\r\n\r\n  /**\r\n   * For a given ts.Identifier that is part of an AstSymbol that we analyzed, return the AstEntity that\r\n   * it refers to.  Returns undefined if it doesn't refer to anything interesting.\r\n   * @remarks\r\n   * Throws an Error if the ts.Identifier is not part of node tree that was analyzed.\r\n   */\r\n  public tryGetEntityForNode(identifier: ts.Identifier | ts.ImportTypeNode): AstEntity | undefined {\r\n    if (!this._entitiesByNode.has(identifier)) {\r\n      throw new InternalError('tryGetEntityForIdentifier() called for an identifier that was not analyzed');\r\n    }\r\n    return this._entitiesByNode.get(identifier);\r\n  }\r\n\r\n  /**\r\n   * Builds an AstSymbol.localName for a given ts.Symbol.  In the current implementation, the localName is\r\n   * a TypeScript-like expression that may be a string literal or ECMAScript symbol expression.\r\n   *\r\n   * ```ts\r\n   * class X {\r\n   *   // localName=\"identifier\"\r\n   *   public identifier: number = 1;\r\n   *   // localName=\"\\\"identifier\\\"\"\r\n   *   public \"quoted string!\": number = 2;\r\n   *   // localName=\"[MyNamespace.MySymbol]\"\r\n   *   public [MyNamespace.MySymbol]: number = 3;\r\n   * }\r\n   * ```\r\n   */\r\n  public static getLocalNameForSymbol(symbol: ts.Symbol): string {\r\n    // TypeScript binds well-known ECMAScript symbols like \"[Symbol.iterator]\" as \"__@iterator\".\r\n    // Decode it back into \"[Symbol.iterator]\".\r\n    const wellKnownSymbolName: string | undefined = TypeScriptHelpers.tryDecodeWellKnownSymbolName(\r\n      symbol.escapedName\r\n    );\r\n    if (wellKnownSymbolName) {\r\n      return wellKnownSymbolName;\r\n    }\r\n\r\n    const isUniqueSymbol: boolean = TypeScriptHelpers.isUniqueSymbolName(symbol.escapedName);\r\n\r\n    // We will try to obtain the name from a declaration; otherwise we'll fall back to the symbol name.\r\n    let unquotedName: string = symbol.name;\r\n\r\n    for (const declaration of symbol.declarations || []) {\r\n      // Handle cases such as \"export default class X { }\" where the symbol name is \"default\"\r\n      // but the local name is \"X\".\r\n      const localSymbol: ts.Symbol | undefined = TypeScriptInternals.tryGetLocalSymbol(declaration);\r\n      if (localSymbol) {\r\n        unquotedName = localSymbol.name;\r\n      }\r\n\r\n      // If it is a non-well-known symbol, then return the late-bound name.  For example, \"X.Y.z\" in this example:\r\n      //\r\n      //   namespace X {\r\n      //     export namespace Y {\r\n      //       export const z: unique symbol = Symbol(\"z\");\r\n      //     }\r\n      //  }\r\n      //\r\n      //  class C {\r\n      //    public [X.Y.z](): void { }\r\n      //  }\r\n      //\r\n      if (isUniqueSymbol) {\r\n        const declarationName: ts.DeclarationName | undefined = ts.getNameOfDeclaration(declaration);\r\n        if (declarationName && ts.isComputedPropertyName(declarationName)) {\r\n          const lateBoundName: string | undefined = TypeScriptHelpers.tryGetLateBoundName(declarationName);\r\n          if (lateBoundName) {\r\n            // Here the string may contain an expression such as \"[X.Y.z]\".  Names starting with \"[\" are always\r\n            // expressions.  If a string literal contains those characters, the code below will JSON.stringify() it\r\n            // to avoid a collision.\r\n            return lateBoundName;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Otherwise that name may come from a quoted string or pseudonym like `__constructor`.\r\n    // If the string is not a safe identifier, then we must add quotes.\r\n    // Note that if it was quoted but did not need to be quoted, here we will remove the quotes.\r\n    if (!SyntaxHelpers.isSafeUnquotedMemberIdentifier(unquotedName)) {\r\n      // For API Extractor's purposes, a canonical form is more appropriate than trying to reflect whatever\r\n      // appeared in the source code.  The code is not even guaranteed to be consistent, for example:\r\n      //\r\n      //   class X {\r\n      //     public \"f1\"(x: string): void;\r\n      //     public f1(x: boolean): void;\r\n      //     public 'f1'(x: string | boolean): void { }\r\n      //   }\r\n      return JSON.stringify(unquotedName);\r\n    }\r\n\r\n    return unquotedName;\r\n  }\r\n\r\n  private _analyzeAstNamespaceImport(astNamespaceImport: AstNamespaceImport): void {\r\n    if (astNamespaceImport.analyzed) {\r\n      return;\r\n    }\r\n\r\n    // mark before actual analyzing, to handle module cyclic reexport\r\n    astNamespaceImport.analyzed = true;\r\n\r\n    const exportedLocalEntities: Map<string, AstEntity> = this.fetchAstModuleExportInfo(\r\n      astNamespaceImport.astModule\r\n    ).exportedLocalEntities;\r\n\r\n    for (const exportedEntity of exportedLocalEntities.values()) {\r\n      this.analyze(exportedEntity);\r\n    }\r\n  }\r\n\r\n  private _analyzeAstSymbol(astSymbol: AstSymbol): void {\r\n    if (astSymbol.analyzed) {\r\n      return;\r\n    }\r\n\r\n    if (astSymbol.nominalAnalysis) {\r\n      // We don't analyze nominal symbols\r\n      astSymbol._notifyAnalyzed();\r\n      return;\r\n    }\r\n\r\n    // Start at the root of the tree\r\n    const rootAstSymbol: AstSymbol = astSymbol.rootAstSymbol;\r\n\r\n    // Calculate the full child tree for each definition\r\n    for (const astDeclaration of rootAstSymbol.astDeclarations) {\r\n      this._analyzeChildTree(astDeclaration.declaration, astDeclaration);\r\n    }\r\n\r\n    rootAstSymbol._notifyAnalyzed();\r\n\r\n    if (!astSymbol.isExternal) {\r\n      // If this symbol is non-external (i.e. it belongs to the working package), then we also analyze any\r\n      // referencedAstSymbols that are non-external.  For example, this ensures that forgotten exports\r\n      // get analyzed.\r\n      rootAstSymbol.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\r\n        for (const referencedAstEntity of astDeclaration.referencedAstEntities) {\r\n          // Walk up to the root of the tree, looking for any imports along the way\r\n          if (referencedAstEntity instanceof AstSymbol) {\r\n            if (!referencedAstEntity.isExternal) {\r\n              this._analyzeAstSymbol(referencedAstEntity);\r\n            }\r\n          }\r\n\r\n          if (referencedAstEntity instanceof AstNamespaceImport) {\r\n            if (!referencedAstEntity.astModule.isExternal) {\r\n              this._analyzeAstNamespaceImport(referencedAstEntity);\r\n            }\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Used by analyze to recursively analyze the entire child tree.\r\n   */\r\n  private _analyzeChildTree(node: ts.Node, governingAstDeclaration: AstDeclaration): void {\r\n    switch (node.kind) {\r\n      case ts.SyntaxKind.JSDocComment: // Skip JSDoc comments - TS considers @param tags TypeReference nodes\r\n        return;\r\n\r\n      // Is this a reference to another AstSymbol?\r\n      case ts.SyntaxKind.TypeReference: // general type references\r\n      case ts.SyntaxKind.ExpressionWithTypeArguments: // special case for e.g. the \"extends\" keyword\r\n      case ts.SyntaxKind.ComputedPropertyName: // used for EcmaScript \"symbols\", e.g. \"[toPrimitive]\".\r\n      case ts.SyntaxKind.TypeQuery: // represents for \"typeof X\" as a type\r\n        {\r\n          // Sometimes the type reference will involve multiple identifiers, e.g. \"a.b.C\".\r\n          // In this case, we only need to worry about importing the first identifier,\r\n          // so do a depth-first search for it:\r\n          const identifierNode: ts.Identifier | undefined = TypeScriptHelpers.findFirstChildNode(\r\n            node,\r\n            ts.SyntaxKind.Identifier\r\n          );\r\n\r\n          if (identifierNode) {\r\n            let referencedAstEntity: AstEntity | undefined = this._entitiesByNode.get(identifierNode);\r\n            if (!referencedAstEntity) {\r\n              const symbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(identifierNode);\r\n              if (!symbol) {\r\n                throw new Error('Symbol not found for identifier: ' + identifierNode.getText());\r\n              }\r\n\r\n              // Normally we expect getSymbolAtLocation() to take us to a declaration within the same source\r\n              // file, or else to an explicit \"import\" statement within the same source file.  But in certain\r\n              // situations (e.g. a global variable) the symbol will refer to a declaration in some other\r\n              // source file.  We'll call that case a \"displaced symbol\".\r\n              //\r\n              // For more info, see this discussion:\r\n              // https://github.com/microsoft/rushstack/issues/1765#issuecomment-595559849\r\n              let displacedSymbol: boolean = true;\r\n              for (const declaration of symbol.declarations || []) {\r\n                if (declaration.getSourceFile() === identifierNode.getSourceFile()) {\r\n                  displacedSymbol = false;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              if (displacedSymbol) {\r\n                if (this._globalVariableAnalyzer.hasGlobalName(identifierNode.text)) {\r\n                  // If the displaced symbol is a global variable, then API Extractor simply ignores it.\r\n                  // Ambient declarations typically describe the runtime environment (provided by an API consumer),\r\n                  // so we don't bother analyzing them as an API contract.  (There are probably some packages\r\n                  // that include interesting global variables in their API, but API Extractor doesn't support\r\n                  // that yet; it would be a feature request.)\r\n\r\n                  if (this._messageRouter.showDiagnostics) {\r\n                    if (!this._alreadyWarnedGlobalNames.has(identifierNode.text)) {\r\n                      this._alreadyWarnedGlobalNames.add(identifierNode.text);\r\n                      this._messageRouter.logDiagnostic(\r\n                        `Ignoring reference to global variable \"${identifierNode.text}\"` +\r\n                          ` in ` +\r\n                          SourceFileLocationFormatter.formatDeclaration(identifierNode)\r\n                      );\r\n                    }\r\n                  }\r\n                } else {\r\n                  // If you encounter this, please report a bug with a repro.  We're interested to know\r\n                  // how it can occur.\r\n                  throw new InternalError(`Unable to follow symbol for \"${identifierNode.text}\"`);\r\n                }\r\n              } else {\r\n                referencedAstEntity = this._exportAnalyzer.fetchReferencedAstEntity(\r\n                  symbol,\r\n                  governingAstDeclaration.astSymbol.isExternal\r\n                );\r\n\r\n                this._entitiesByNode.set(identifierNode, referencedAstEntity);\r\n              }\r\n            }\r\n\r\n            if (referencedAstEntity) {\r\n              governingAstDeclaration._notifyReferencedAstEntity(referencedAstEntity);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n\r\n      // Is this the identifier for the governingAstDeclaration?\r\n      case ts.SyntaxKind.Identifier:\r\n        {\r\n          const identifierNode: ts.Identifier = node as ts.Identifier;\r\n          if (!this._entitiesByNode.has(identifierNode)) {\r\n            const symbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(identifierNode);\r\n\r\n            let referencedAstEntity: AstEntity | undefined = undefined;\r\n\r\n            if (symbol === governingAstDeclaration.astSymbol.followedSymbol) {\r\n              referencedAstEntity = this._fetchEntityForNode(identifierNode, governingAstDeclaration);\r\n            }\r\n\r\n            this._entitiesByNode.set(identifierNode, referencedAstEntity);\r\n          }\r\n        }\r\n        break;\r\n\r\n      case ts.SyntaxKind.ImportType:\r\n        {\r\n          const importTypeNode: ts.ImportTypeNode = node as ts.ImportTypeNode;\r\n          let referencedAstEntity: AstEntity | undefined = this._entitiesByNode.get(importTypeNode);\r\n\r\n          if (!this._entitiesByNode.has(importTypeNode)) {\r\n            referencedAstEntity = this._fetchEntityForNode(importTypeNode, governingAstDeclaration);\r\n\r\n            if (!referencedAstEntity) {\r\n              // This should never happen\r\n              throw new Error('Failed to fetch entity for import() type node: ' + importTypeNode.getText());\r\n            }\r\n\r\n            this._entitiesByNode.set(importTypeNode, referencedAstEntity);\r\n          }\r\n\r\n          if (referencedAstEntity) {\r\n            governingAstDeclaration._notifyReferencedAstEntity(referencedAstEntity);\r\n          }\r\n        }\r\n        break;\r\n    }\r\n\r\n    // Is this node declaring a new AstSymbol?\r\n    const newGoverningAstDeclaration: AstDeclaration | undefined = this._fetchAstDeclaration(\r\n      node,\r\n      governingAstDeclaration.astSymbol.isExternal\r\n    );\r\n\r\n    for (const childNode of node.getChildren()) {\r\n      this._analyzeChildTree(childNode, newGoverningAstDeclaration || governingAstDeclaration);\r\n    }\r\n  }\r\n\r\n  private _fetchEntityForNode(\r\n    node: ts.Identifier | ts.ImportTypeNode,\r\n    governingAstDeclaration: AstDeclaration\r\n  ): AstEntity | undefined {\r\n    let referencedAstEntity: AstEntity | undefined = this._entitiesByNode.get(node);\r\n    if (!referencedAstEntity) {\r\n      if (node.kind === ts.SyntaxKind.ImportType) {\r\n        referencedAstEntity = this._exportAnalyzer.fetchReferencedAstEntityFromImportTypeNode(\r\n          node,\r\n          governingAstDeclaration.astSymbol.isExternal\r\n        );\r\n      } else {\r\n        const symbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(node);\r\n        if (!symbol) {\r\n          throw new Error('Symbol not found for identifier: ' + node.getText());\r\n        }\r\n\r\n        referencedAstEntity = this._exportAnalyzer.fetchReferencedAstEntity(\r\n          symbol,\r\n          governingAstDeclaration.astSymbol.isExternal\r\n        );\r\n      }\r\n\r\n      this._entitiesByNode.set(node, referencedAstEntity);\r\n    }\r\n    return referencedAstEntity;\r\n  }\r\n\r\n  private _fetchAstDeclaration(node: ts.Node, isExternal: boolean): AstDeclaration | undefined {\r\n    if (!AstDeclaration.isSupportedSyntaxKind(node.kind)) {\r\n      return undefined;\r\n    }\r\n\r\n    const symbol: ts.Symbol | undefined = TypeScriptHelpers.getSymbolForDeclaration(\r\n      node as ts.Declaration,\r\n      this._typeChecker\r\n    );\r\n    if (!symbol) {\r\n      throw new InternalError('Unable to find symbol for node');\r\n    }\r\n\r\n    const astSymbol: AstSymbol | undefined = this._fetchAstSymbol({\r\n      followedSymbol: symbol,\r\n      isExternal: isExternal,\r\n      includeNominalAnalysis: true,\r\n      addIfMissing: true\r\n    });\r\n\r\n    if (!astSymbol) {\r\n      return undefined;\r\n    }\r\n\r\n    const astDeclaration: AstDeclaration | undefined = this._astDeclarationsByDeclaration.get(node);\r\n\r\n    if (!astDeclaration) {\r\n      throw new InternalError('Unable to find constructed AstDeclaration');\r\n    }\r\n\r\n    return astDeclaration;\r\n  }\r\n\r\n  private _fetchAstSymbol(options: IFetchAstSymbolOptions): AstSymbol | undefined {\r\n    const followedSymbol: ts.Symbol = options.followedSymbol;\r\n\r\n    // Filter out symbols representing constructs that we don't care about\r\n    const arbitraryDeclaration: ts.Declaration | undefined =\r\n      TypeScriptHelpers.tryGetADeclaration(followedSymbol);\r\n    if (!arbitraryDeclaration) {\r\n      return undefined;\r\n    }\r\n\r\n    if (\r\n      followedSymbol.flags &\r\n      (ts.SymbolFlags.TypeParameter | ts.SymbolFlags.TypeLiteral | ts.SymbolFlags.Transient)\r\n    ) {\r\n      if (!TypeScriptInternals.isLateBoundSymbol(followedSymbol)) {\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    // API Extractor doesn't analyze ambient declarations at all\r\n    if (TypeScriptHelpers.isAmbient(followedSymbol, this._typeChecker)) {\r\n      // We make a special exemption for ambient declarations that appear in a source file containing\r\n      // an \"export=\" declaration that allows them to be imported as non-ambient.\r\n      if (!this._exportAnalyzer.isImportableAmbientSourceFile(arbitraryDeclaration.getSourceFile())) {\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    // Make sure followedSymbol isn't an alias for something else\r\n    if (TypeScriptHelpers.isFollowableAlias(followedSymbol, this._typeChecker)) {\r\n      // We expect the caller to have already followed any aliases\r\n      throw new InternalError('AstSymbolTable._fetchAstSymbol() cannot be called with a symbol alias');\r\n    }\r\n\r\n    let astSymbol: AstSymbol | undefined = this._astSymbolsBySymbol.get(followedSymbol);\r\n\r\n    if (!astSymbol) {\r\n      // None of the above lookups worked, so create a new entry...\r\n      let nominalAnalysis: boolean = false;\r\n\r\n      if (options.isExternal) {\r\n        // If the file is from an external package that does not support AEDoc, normally we ignore it completely.\r\n        // But in some cases (e.g. checking star exports of an external package) we need an AstSymbol to\r\n        // represent it, but we don't need to analyze its sibling/children.\r\n        const followedSymbolSourceFileName: string = arbitraryDeclaration.getSourceFile().fileName;\r\n\r\n        if (!this._packageMetadataManager.isAedocSupportedFor(followedSymbolSourceFileName)) {\r\n          nominalAnalysis = true;\r\n\r\n          if (!options.includeNominalAnalysis) {\r\n            return undefined;\r\n          }\r\n        }\r\n      }\r\n\r\n      let parentAstSymbol: AstSymbol | undefined = undefined;\r\n\r\n      if (!nominalAnalysis) {\r\n        for (const declaration of followedSymbol.declarations || []) {\r\n          if (!AstDeclaration.isSupportedSyntaxKind(declaration.kind)) {\r\n            throw new InternalError(\r\n              `The \"${followedSymbol.name}\" symbol has a` +\r\n                ` ts.SyntaxKind.${ts.SyntaxKind[declaration.kind]} declaration which is not (yet?)` +\r\n                ` supported by API Extractor`\r\n            );\r\n          }\r\n        }\r\n\r\n        // We always fetch the entire chain of parents for each declaration.\r\n        // (Children/siblings are only analyzed on demand.)\r\n\r\n        // Key assumptions behind this squirrely logic:\r\n        //\r\n        // IF a given symbol has two declarations D1 and D2; AND\r\n        // If D1 has a parent P1, then\r\n        // - D2 will also have a parent P2; AND\r\n        // - P1 and P2's symbol will be the same\r\n        // - but P1 and P2 may be different (e.g. merged namespaces containing merged interfaces)\r\n\r\n        // Is there a parent AstSymbol?  First we check to see if there is a parent declaration:\r\n        if (arbitraryDeclaration) {\r\n          const arbitraryParentDeclaration: ts.Node | undefined =\r\n            this._tryFindFirstAstDeclarationParent(arbitraryDeclaration);\r\n\r\n          if (arbitraryParentDeclaration) {\r\n            const parentSymbol: ts.Symbol = TypeScriptHelpers.getSymbolForDeclaration(\r\n              arbitraryParentDeclaration as ts.Declaration,\r\n              this._typeChecker\r\n            );\r\n\r\n            parentAstSymbol = this._fetchAstSymbol({\r\n              followedSymbol: parentSymbol,\r\n              isExternal: options.isExternal,\r\n              includeNominalAnalysis: false,\r\n              addIfMissing: true\r\n            });\r\n            if (!parentAstSymbol) {\r\n              throw new InternalError('Unable to construct a parent AstSymbol for ' + followedSymbol.name);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const localName: string | undefined =\r\n        options.localName || AstSymbolTable.getLocalNameForSymbol(followedSymbol);\r\n\r\n      astSymbol = new AstSymbol({\r\n        followedSymbol: followedSymbol,\r\n        localName: localName,\r\n        isExternal: options.isExternal,\r\n        nominalAnalysis: nominalAnalysis,\r\n        parentAstSymbol: parentAstSymbol,\r\n        rootAstSymbol: parentAstSymbol ? parentAstSymbol.rootAstSymbol : undefined\r\n      });\r\n\r\n      this._astSymbolsBySymbol.set(followedSymbol, astSymbol);\r\n\r\n      // Okay, now while creating the declarations we will wire them up to the\r\n      // their corresponding parent declarations\r\n      for (const declaration of followedSymbol.declarations || []) {\r\n        let parentAstDeclaration: AstDeclaration | undefined = undefined;\r\n        if (parentAstSymbol) {\r\n          const parentDeclaration: ts.Node | undefined = this._tryFindFirstAstDeclarationParent(declaration);\r\n\r\n          if (!parentDeclaration) {\r\n            throw new InternalError('Missing parent declaration');\r\n          }\r\n\r\n          parentAstDeclaration = this._astDeclarationsByDeclaration.get(parentDeclaration);\r\n          if (!parentAstDeclaration) {\r\n            throw new InternalError('Missing parent AstDeclaration');\r\n          }\r\n        }\r\n\r\n        const astDeclaration: AstDeclaration = new AstDeclaration({\r\n          declaration,\r\n          astSymbol,\r\n          parent: parentAstDeclaration\r\n        });\r\n\r\n        this._astDeclarationsByDeclaration.set(declaration, astDeclaration);\r\n      }\r\n    }\r\n\r\n    if (options.isExternal !== astSymbol.isExternal) {\r\n      throw new InternalError(\r\n        `Cannot assign isExternal=${options.isExternal} for` +\r\n          ` the symbol ${astSymbol.localName} because it was previously registered` +\r\n          ` with isExternal=${astSymbol.isExternal}`\r\n      );\r\n    }\r\n\r\n    return astSymbol;\r\n  }\r\n\r\n  /**\r\n   * Returns the first parent satisfying isAstDeclaration(), or undefined if none is found.\r\n   */\r\n  private _tryFindFirstAstDeclarationParent(node: ts.Node): ts.Node | undefined {\r\n    let currentNode: ts.Node | undefined = node.parent;\r\n    while (currentNode) {\r\n      if (AstDeclaration.isSupportedSyntaxKind(currentNode.kind)) {\r\n        return currentNode;\r\n      }\r\n      currentNode = currentNode.parent;\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/ExportAnalyzer.js.map b/lib/analyzer/ExportAnalyzer.js.map
index 2f6a7c029c2558e02884f5ef2f69d45ab34eadd0..b55689fc6fea34368b523b6b13c7f2a0d4798e7c 100644
--- a/lib/analyzer/ExportAnalyzer.js.map
+++ b/lib/analyzer/ExportAnalyzer.js.map
@@ -1 +1 @@
-{"version":3,"file":"ExportAnalyzer.js","sourceRoot":"","sources":["../../src/analyzer/ExportAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\nimport { InternalError } from '@rushstack/node-core-library';\n\nimport { TypeScriptHelpers } from './TypeScriptHelpers';\nimport { AstSymbol } from './AstSymbol';\nimport { AstImport, type IAstImportOptions, AstImportKind } from './AstImport';\nimport { AstModule, AstModuleExportInfo } from './AstModule';\nimport { TypeScriptInternals } from './TypeScriptInternals';\nimport { SourceFileLocationFormatter } from './SourceFileLocationFormatter';\nimport type { IFetchAstSymbolOptions } from './AstSymbolTable';\nimport type { AstEntity } from './AstEntity';\nimport { AstNamespaceImport } from './AstNamespaceImport';\nimport { SyntaxHelpers } from './SyntaxHelpers';\n\n/**\n * Exposes the minimal APIs from AstSymbolTable that are needed by ExportAnalyzer.\n *\n * In particular, we want ExportAnalyzer to be able to call AstSymbolTable._fetchAstSymbol() even though it\n * is a very private API that should not be exposed to any other components.\n */\nexport interface IAstSymbolTable {\n  fetchAstSymbol(options: IFetchAstSymbolOptions): AstSymbol | undefined;\n\n  analyze(astEntity: AstEntity): void;\n}\n\n/**\n * Used with ExportAnalyzer.fetchAstModuleBySourceFile() to provide contextual information about how the source file\n * was imported.\n */\ninterface IAstModuleReference {\n  /**\n   * For example, if we are following a statement like `import { X } from 'some-package'`, this will be the\n   * string `\"some-package\"`.\n   */\n  moduleSpecifier: string;\n\n  /**\n   * For example, if we are following a statement like `import { X } from 'some-package'`, this will be the\n   * symbol for `X`.\n   */\n  moduleSpecifierSymbol: ts.Symbol;\n}\n\n/**\n * The ExportAnalyzer is an internal part of AstSymbolTable that has been moved out into its own source file\n * because it is a complex and mostly self-contained algorithm.\n *\n * Its job is to build up AstModule objects by crawling import statements to discover where declarations come from.\n * This is conceptually the same as the compiler's own TypeChecker.getExportsOfModule(), except that when\n * ExportAnalyzer encounters a declaration that was imported from an external package, it remembers how it was imported\n * (i.e. the AstImport object).  Today the compiler API does not expose this information, which is crucial for\n * generating .d.ts rollups.\n */\nexport class ExportAnalyzer {\n  private readonly _program: ts.Program;\n  private readonly _typeChecker: ts.TypeChecker;\n  private readonly _bundledPackageNames: ReadonlySet<string>;\n  private readonly _astSymbolTable: IAstSymbolTable;\n\n  private readonly _astModulesByModuleSymbol: Map<ts.Symbol, AstModule> = new Map<ts.Symbol, AstModule>();\n\n  // Used with isImportableAmbientSourceFile()\n  private readonly _importableAmbientSourceFiles: Set<ts.SourceFile> = new Set<ts.SourceFile>();\n\n  private readonly _astImportsByKey: Map<string, AstImport> = new Map<string, AstImport>();\n  private readonly _astNamespaceImportByModule: Map<AstModule, AstNamespaceImport> = new Map();\n\n  public constructor(\n    program: ts.Program,\n    typeChecker: ts.TypeChecker,\n    bundledPackageNames: ReadonlySet<string>,\n    astSymbolTable: IAstSymbolTable\n  ) {\n    this._program = program;\n    this._typeChecker = typeChecker;\n    this._bundledPackageNames = bundledPackageNames;\n    this._astSymbolTable = astSymbolTable;\n  }\n\n  /**\n   * For a given source file, this analyzes all of its exports and produces an AstModule object.\n   *\n   * @param moduleReference - contextual information about the import statement that took us to this source file.\n   * or `undefined` if this source file is the initial entry point\n   * @param isExternal - whether the given `moduleReference` is external.\n   */\n  public fetchAstModuleFromSourceFile(\n    sourceFile: ts.SourceFile,\n    moduleReference: IAstModuleReference | undefined,\n    isExternal: boolean\n  ): AstModule {\n    const moduleSymbol: ts.Symbol = this._getModuleSymbolFromSourceFile(sourceFile, moduleReference);\n\n    // Don't traverse into a module that we already processed before:\n    // The compiler allows m1 to have \"export * from 'm2'\" and \"export * from 'm3'\",\n    // even if m2 and m3 both have \"export * from 'm4'\".\n    let astModule: AstModule | undefined = this._astModulesByModuleSymbol.get(moduleSymbol);\n    if (!astModule) {\n      // (If moduleReference === undefined, then this is the entry point of the local project being analyzed.)\n      const externalModulePath: string | undefined =\n        moduleReference !== undefined && isExternal ? moduleReference.moduleSpecifier : undefined;\n\n      astModule = new AstModule({ sourceFile, moduleSymbol, externalModulePath });\n\n      this._astModulesByModuleSymbol.set(moduleSymbol, astModule);\n\n      if (astModule.isExternal) {\n        // It's an external package, so do the special simplified analysis that doesn't crawl into referenced modules\n        for (const exportedSymbol of this._typeChecker.getExportsOfModule(moduleSymbol)) {\n          if (externalModulePath === undefined) {\n            throw new InternalError(\n              'Failed assertion: externalModulePath=undefined but astModule.isExternal=true'\n            );\n          }\n\n          const followedSymbol: ts.Symbol = TypeScriptHelpers.followAliases(\n            exportedSymbol,\n            this._typeChecker\n          );\n\n          // Ignore virtual symbols that don't have any declarations\n          const arbitraryDeclaration: ts.Declaration | undefined =\n            TypeScriptHelpers.tryGetADeclaration(followedSymbol);\n          if (arbitraryDeclaration) {\n            const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol({\n              followedSymbol: followedSymbol,\n              isExternal: astModule.isExternal,\n              includeNominalAnalysis: true,\n              addIfMissing: true\n            });\n\n            if (!astSymbol) {\n              throw new Error(\n                `Unsupported export ${JSON.stringify(exportedSymbol.name)}:\\n` +\n                  SourceFileLocationFormatter.formatDeclaration(arbitraryDeclaration)\n              );\n            }\n\n            astModule.cachedExportedEntities.set(exportedSymbol.name, astSymbol);\n          }\n        }\n      } else {\n        // The module is part of the local project, so do the full analysis\n\n        if (moduleSymbol.exports) {\n          // The \"export * from 'module-name';\" declarations are all attached to a single virtual symbol\n          // whose name is InternalSymbolName.ExportStar\n          const exportStarSymbol: ts.Symbol | undefined = moduleSymbol.exports.get(\n            ts.InternalSymbolName.ExportStar\n          );\n          if (exportStarSymbol) {\n            for (const exportStarDeclaration of exportStarSymbol.getDeclarations() || []) {\n              if (ts.isExportDeclaration(exportStarDeclaration)) {\n                const starExportedModule: AstModule | undefined = this._fetchSpecifierAstModule(\n                  exportStarDeclaration,\n                  exportStarSymbol\n                );\n\n                if (starExportedModule !== undefined) {\n                  astModule.starExportedModules.add(starExportedModule);\n                }\n              } else {\n                // Ignore ExportDeclaration nodes that don't match the expected pattern\n                // TODO: Should we report a warning?\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return astModule;\n  }\n\n  /**\n   * Retrieves the symbol for the module corresponding to the ts.SourceFile that is being imported/exported.\n   *\n   * @remarks\n   * The `module` keyword can be used to declare multiple TypeScript modules inside a single source file.\n   * (This is a deprecated construct and mainly used for typings such as `@types/node`.)  In this situation,\n   * `moduleReference` helps us to fish out the correct module symbol.\n   */\n  private _getModuleSymbolFromSourceFile(\n    sourceFile: ts.SourceFile,\n    moduleReference: IAstModuleReference | undefined\n  ): ts.Symbol {\n    const moduleSymbol: ts.Symbol | undefined = TypeScriptInternals.tryGetSymbolForDeclaration(\n      sourceFile,\n      this._typeChecker\n    );\n    if (moduleSymbol !== undefined) {\n      // This is the normal case.  The SourceFile acts is a module and has a symbol.\n      return moduleSymbol;\n    }\n\n    if (moduleReference !== undefined) {\n      // But there is also an elaborate case where the source file contains one or more \"module\" declarations,\n      // and our moduleReference took us to one of those.\n\n      // eslint-disable-next-line no-bitwise\n      if ((moduleReference.moduleSpecifierSymbol.flags & ts.SymbolFlags.Alias) !== 0) {\n        // Follow the import/export declaration to one hop the exported item inside the target module\n        let followedSymbol: ts.Symbol | undefined = TypeScriptInternals.getImmediateAliasedSymbol(\n          moduleReference.moduleSpecifierSymbol,\n          this._typeChecker\n        );\n\n        if (followedSymbol === undefined) {\n          // This is a workaround for a compiler bug where getImmediateAliasedSymbol() sometimes returns undefined\n          followedSymbol = this._typeChecker.getAliasedSymbol(moduleReference.moduleSpecifierSymbol);\n        }\n\n        if (followedSymbol !== undefined && followedSymbol !== moduleReference.moduleSpecifierSymbol) {\n          // The parent of the exported symbol will be the module that we're importing from\n          const parent: ts.Symbol | undefined = TypeScriptInternals.getSymbolParent(followedSymbol);\n          if (parent !== undefined) {\n            // Make sure the thing we found is a module\n            // eslint-disable-next-line no-bitwise\n            if ((parent.flags & ts.SymbolFlags.ValueModule) !== 0) {\n              // Record that that this is an ambient module that can also be imported from\n              this._importableAmbientSourceFiles.add(sourceFile);\n              return parent;\n            }\n          }\n        }\n      }\n    }\n\n    throw new InternalError('Unable to determine module for: ' + sourceFile.fileName);\n  }\n\n  /**\n   * Implementation of {@link AstSymbolTable.fetchAstModuleExportInfo}.\n   */\n  public fetchAstModuleExportInfo(entryPointAstModule: AstModule): AstModuleExportInfo {\n    if (entryPointAstModule.isExternal) {\n      throw new Error('fetchAstModuleExportInfo() is not supported for external modules');\n    }\n\n    if (entryPointAstModule.astModuleExportInfo === undefined) {\n      const astModuleExportInfo: AstModuleExportInfo = new AstModuleExportInfo();\n\n      this._collectAllExportsRecursive(astModuleExportInfo, entryPointAstModule, new Set<AstModule>());\n\n      entryPointAstModule.astModuleExportInfo = astModuleExportInfo;\n    }\n    return entryPointAstModule.astModuleExportInfo;\n  }\n\n  /**\n   * Returns true if the module specifier refers to an external package.  Ignores packages listed in the\n   * \"bundledPackages\" setting from the api-extractor.json config file.\n   */\n  private _isExternalModulePath(\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration | ts.ImportTypeNode,\n    moduleSpecifier: string\n  ): boolean {\n    const specifier: ts.TypeNode | ts.Expression | undefined = ts.isImportTypeNode(importOrExportDeclaration)\n      ? importOrExportDeclaration.argument\n      : importOrExportDeclaration.moduleSpecifier;\n    const mode: ts.ModuleKind.CommonJS | ts.ModuleKind.ESNext | undefined =\n      specifier && ts.isStringLiteralLike(specifier)\n        ? TypeScriptInternals.getModeForUsageLocation(importOrExportDeclaration.getSourceFile(), specifier)\n        : undefined;\n\n    const resolvedModule: ts.ResolvedModuleFull | undefined = TypeScriptInternals.getResolvedModule(\n      importOrExportDeclaration.getSourceFile(),\n      moduleSpecifier,\n      mode\n    );\n\n    if (resolvedModule === undefined) {\n      // The TS compiler API `getResolvedModule` cannot resolve ambient modules. Thus, to match API Extractor's\n      // previous behavior, simply treat all ambient modules as external. This bug is tracked by\n      // https://github.com/microsoft/rushstack/issues/3335.\n      return true;\n    }\n\n    // Either something like `jquery` or `@microsoft/api-extractor`.\n    const packageName: string | undefined = resolvedModule.packageId?.name;\n    if (packageName !== undefined && this._bundledPackageNames.has(packageName)) {\n      return false;\n    }\n\n    if (resolvedModule.isExternalLibraryImport === undefined) {\n      // This presumably means the compiler couldn't figure out whether the module was external, but we're not\n      // sure how this can happen.\n      throw new InternalError(\n        `Cannot determine whether the module ${JSON.stringify(moduleSpecifier)} is external\\n` +\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\n      );\n    }\n\n    return resolvedModule.isExternalLibraryImport;\n  }\n\n  /**\n   * Returns true if when we analyzed sourceFile, we found that it contains an \"export=\" statement that allows\n   * it to behave /either/ as an ambient module /or/ as a regular importable module.  In this case,\n   * `AstSymbolTable._fetchAstSymbol()` will analyze its symbols even though `TypeScriptHelpers.isAmbient()`\n   * returns true.\n   */\n  public isImportableAmbientSourceFile(sourceFile: ts.SourceFile): boolean {\n    return this._importableAmbientSourceFiles.has(sourceFile);\n  }\n\n  private _collectAllExportsRecursive(\n    astModuleExportInfo: AstModuleExportInfo,\n    astModule: AstModule,\n    visitedAstModules: Set<AstModule>\n  ): void {\n    if (visitedAstModules.has(astModule)) {\n      return;\n    }\n    visitedAstModules.add(astModule);\n\n    if (astModule.isExternal) {\n      astModuleExportInfo.starExportedExternalModules.add(astModule);\n    } else {\n      // Fetch each of the explicit exports for this module\n      if (astModule.moduleSymbol.exports) {\n        astModule.moduleSymbol.exports.forEach((exportSymbol, exportName) => {\n          switch (exportName) {\n            case ts.InternalSymbolName.ExportStar:\n            case ts.InternalSymbolName.ExportEquals:\n              break;\n            default:\n              // Don't collect the \"export default\" symbol unless this is the entry point module\n              if (exportName !== ts.InternalSymbolName.Default || visitedAstModules.size === 1) {\n                if (!astModuleExportInfo.exportedLocalEntities.has(exportSymbol.name)) {\n                  const astEntity: AstEntity = this._getExportOfAstModule(exportSymbol.name, astModule);\n\n                  if (astEntity instanceof AstSymbol && !astEntity.isExternal) {\n                    this._astSymbolTable.analyze(astEntity);\n                  }\n\n                  if (astEntity instanceof AstNamespaceImport && !astEntity.astModule.isExternal) {\n                    this._astSymbolTable.analyze(astEntity);\n                  }\n\n                  astModuleExportInfo.exportedLocalEntities.set(exportSymbol.name, astEntity);\n                }\n              }\n              break;\n          }\n        });\n      }\n\n      for (const starExportedModule of astModule.starExportedModules) {\n        this._collectAllExportsRecursive(astModuleExportInfo, starExportedModule, visitedAstModules);\n      }\n    }\n  }\n\n  /**\n   * For a given symbol (which was encountered in the specified sourceFile), this fetches the AstEntity that it\n   * refers to.  For example, if a particular interface describes the return value of a function, this API can help\n   * us determine a TSDoc declaration reference for that symbol (if the symbol is exported).\n   */\n  public fetchReferencedAstEntity(\n    symbol: ts.Symbol,\n    referringModuleIsExternal: boolean\n  ): AstEntity | undefined {\n    // eslint-disable-next-line no-bitwise\n    if ((symbol.flags & ts.SymbolFlags.FunctionScopedVariable) !== 0) {\n      // If a symbol refers back to part of its own definition, don't follow that rabbit hole\n      // Example:\n      //\n      // function f(x: number): typeof x {\n      //    return 123;\n      // }\n      return undefined;\n    }\n\n    let current: ts.Symbol = symbol;\n\n    if (referringModuleIsExternal) {\n      current = TypeScriptHelpers.followAliases(symbol, this._typeChecker);\n    } else {\n      for (;;) {\n        // Is this symbol an import/export that we need to follow to find the real declaration?\n        for (const declaration of current.declarations || []) {\n          let matchedAstEntity: AstEntity | undefined;\n          matchedAstEntity = this._tryMatchExportDeclaration(declaration, current);\n          if (matchedAstEntity !== undefined) {\n            return matchedAstEntity;\n          }\n          matchedAstEntity = this._tryMatchImportDeclaration(declaration, current);\n          if (matchedAstEntity !== undefined) {\n            return matchedAstEntity;\n          }\n        }\n\n        // eslint-disable-next-line no-bitwise\n        if (!(current.flags & ts.SymbolFlags.Alias)) {\n          break;\n        }\n\n        const currentAlias: ts.Symbol = TypeScriptInternals.getImmediateAliasedSymbol(\n          current,\n          this._typeChecker\n        );\n        // Stop if we reach the end of the chain\n        if (!currentAlias || currentAlias === current) {\n          break;\n        }\n\n        current = currentAlias;\n      }\n    }\n\n    // Otherwise, assume it is a normal declaration\n    const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol({\n      followedSymbol: current,\n      isExternal: referringModuleIsExternal,\n      includeNominalAnalysis: false,\n      addIfMissing: true\n    });\n\n    return astSymbol;\n  }\n\n  public fetchReferencedAstEntityFromImportTypeNode(\n    node: ts.ImportTypeNode,\n    referringModuleIsExternal: boolean\n  ): AstEntity | undefined {\n    const externalModulePath: string | undefined = this._tryGetExternalModulePath(node);\n\n    if (externalModulePath) {\n      let exportName: string;\n      if (node.qualifier) {\n        // Example input:\n        //   import('api-extractor-lib1-test').Lib1GenericType<number>\n        //\n        // Extracted qualifier:\n        //   Lib1GenericType\n        exportName = node.qualifier.getText().trim();\n      } else {\n        // Example input:\n        //   import('api-extractor-lib1-test')\n        //\n        // Extracted qualifier:\n        //   apiExtractorLib1Test\n\n        exportName = SyntaxHelpers.makeCamelCaseIdentifier(externalModulePath);\n      }\n\n      return this._fetchAstImport(undefined, {\n        importKind: AstImportKind.ImportType,\n        exportName: exportName,\n        modulePath: externalModulePath,\n        isTypeOnly: false\n      });\n    }\n\n    // Internal reference: AstSymbol\n    const rightMostToken: ts.Identifier | ts.ImportTypeNode = node.qualifier\n      ? node.qualifier.kind === ts.SyntaxKind.QualifiedName\n        ? node.qualifier.right\n        : node.qualifier\n      : node;\n\n    // There is no symbol property in a ImportTypeNode, obtain the associated export symbol\n    const exportSymbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(rightMostToken);\n    if (!exportSymbol) {\n      throw new InternalError(\n        `Symbol not found for identifier: ${node.getText()}\\n` +\n          SourceFileLocationFormatter.formatDeclaration(node)\n      );\n    }\n\n    let followedSymbol: ts.Symbol = exportSymbol;\n    for (;;) {\n      const referencedAstEntity: AstEntity | undefined = this.fetchReferencedAstEntity(\n        followedSymbol,\n        referringModuleIsExternal\n      );\n\n      if (referencedAstEntity) {\n        return referencedAstEntity;\n      }\n\n      const followedSymbolNode: ts.Node | ts.ImportTypeNode | undefined =\n        followedSymbol.declarations && (followedSymbol.declarations[0] as ts.Node | undefined);\n\n      if (followedSymbolNode && followedSymbolNode.kind === ts.SyntaxKind.ImportType) {\n        return this.fetchReferencedAstEntityFromImportTypeNode(\n          followedSymbolNode as ts.ImportTypeNode,\n          referringModuleIsExternal\n        );\n      }\n\n      // eslint-disable-next-line no-bitwise\n      if (!(followedSymbol.flags & ts.SymbolFlags.Alias)) {\n        break;\n      }\n\n      const currentAlias: ts.Symbol = this._typeChecker.getAliasedSymbol(followedSymbol);\n      if (!currentAlias || currentAlias === followedSymbol) {\n        break;\n      }\n\n      followedSymbol = currentAlias;\n    }\n\n    const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol({\n      followedSymbol: followedSymbol,\n      isExternal: referringModuleIsExternal,\n      includeNominalAnalysis: false,\n      addIfMissing: true\n    });\n\n    return astSymbol;\n  }\n\n  private _tryMatchExportDeclaration(\n    declaration: ts.Declaration,\n    declarationSymbol: ts.Symbol\n  ): AstEntity | undefined {\n    const exportDeclaration: ts.ExportDeclaration | undefined =\n      TypeScriptHelpers.findFirstParent<ts.ExportDeclaration>(declaration, ts.SyntaxKind.ExportDeclaration);\n\n    if (exportDeclaration) {\n      let exportName: string | undefined = undefined;\n\n      if (declaration.kind === ts.SyntaxKind.ExportSpecifier) {\n        // EXAMPLE:\n        // \"export { A } from './file-a';\"\n        //\n        // ExportDeclaration:\n        //   ExportKeyword:  pre=[export] sep=[ ]\n        //   NamedExports:\n        //     FirstPunctuation:  pre=[{] sep=[ ]\n        //     SyntaxList:\n        //       ExportSpecifier:  <------------- declaration\n        //         Identifier:  pre=[A] sep=[ ]\n        //     CloseBraceToken:  pre=[}] sep=[ ]\n        //   FromKeyword:  pre=[from] sep=[ ]\n        //   StringLiteral:  pre=['./file-a']\n        //   SemicolonToken:  pre=[;]\n\n        // Example: \" ExportName as RenamedName\"\n        const exportSpecifier: ts.ExportSpecifier = declaration as ts.ExportSpecifier;\n        exportName = (exportSpecifier.propertyName || exportSpecifier.name).getText().trim();\n      } else if (declaration.kind === ts.SyntaxKind.NamespaceExport) {\n        // EXAMPLE:\n        // \"export * as theLib from 'the-lib';\"\n        //\n        // ExportDeclaration:\n        //   ExportKeyword:  pre=[export] sep=[ ]\n        //   NamespaceExport:\n        //     AsteriskToken:  pre=[*] sep=[ ]\n        //     AsKeyword:  pre=[as] sep=[ ]\n        //     Identifier:  pre=[theLib] sep=[ ]\n        //   FromKeyword:  pre=[from] sep=[ ]\n        //   StringLiteral:  pre=['the-lib']\n        //   SemicolonToken:  pre=[;]\n\n        // Issue tracking this feature: https://github.com/microsoft/rushstack/issues/2780\n        throw new Error(\n          `The \"export * as ___\" syntax is not supported yet; as a workaround,` +\n            ` use \"import * as ___\" with a separate \"export { ___ }\" declaration\\n` +\n            SourceFileLocationFormatter.formatDeclaration(declaration)\n        );\n      } else {\n        throw new InternalError(\n          `Unimplemented export declaration kind: ${declaration.getText()}\\n` +\n            SourceFileLocationFormatter.formatDeclaration(declaration)\n        );\n      }\n\n      // Ignore \"export { A }\" without a module specifier\n      if (exportDeclaration.moduleSpecifier) {\n        const externalModulePath: string | undefined = this._tryGetExternalModulePath(exportDeclaration);\n\n        if (externalModulePath !== undefined) {\n          return this._fetchAstImport(declarationSymbol, {\n            importKind: AstImportKind.NamedImport,\n            modulePath: externalModulePath,\n            exportName: exportName,\n            isTypeOnly: false\n          });\n        }\n\n        return this._getExportOfSpecifierAstModule(exportName, exportDeclaration, declarationSymbol);\n      }\n    }\n\n    return undefined;\n  }\n\n  private _tryMatchImportDeclaration(\n    declaration: ts.Declaration,\n    declarationSymbol: ts.Symbol\n  ): AstEntity | undefined {\n    const importDeclaration: ts.ImportDeclaration | undefined =\n      TypeScriptHelpers.findFirstParent<ts.ImportDeclaration>(declaration, ts.SyntaxKind.ImportDeclaration);\n\n    if (importDeclaration) {\n      const externalModulePath: string | undefined = this._tryGetExternalModulePath(importDeclaration);\n\n      if (declaration.kind === ts.SyntaxKind.NamespaceImport) {\n        // EXAMPLE:\n        // \"import * as theLib from 'the-lib';\"\n        //\n        // ImportDeclaration:\n        //   ImportKeyword:  pre=[import] sep=[ ]\n        //   ImportClause:\n        //     NamespaceImport:  <------------- declaration\n        //       AsteriskToken:  pre=[*] sep=[ ]\n        //       AsKeyword:  pre=[as] sep=[ ]\n        //       Identifier:  pre=[theLib] sep=[ ]\n        //   FromKeyword:  pre=[from] sep=[ ]\n        //   StringLiteral:  pre=['the-lib']\n        //   SemicolonToken:  pre=[;]\n\n        if (externalModulePath === undefined) {\n          const astModule: AstModule = this._fetchSpecifierAstModule(importDeclaration, declarationSymbol);\n          let namespaceImport: AstNamespaceImport | undefined =\n            this._astNamespaceImportByModule.get(astModule);\n          if (namespaceImport === undefined) {\n            namespaceImport = new AstNamespaceImport({\n              namespaceName: declarationSymbol.name,\n              astModule: astModule,\n              declaration: declaration,\n              symbol: declarationSymbol\n            });\n            this._astNamespaceImportByModule.set(astModule, namespaceImport);\n          }\n          return namespaceImport;\n        }\n\n        // Here importSymbol=undefined because {@inheritDoc} and such are not going to work correctly for\n        // a package or source file.\n        return this._fetchAstImport(undefined, {\n          importKind: AstImportKind.StarImport,\n          exportName: declarationSymbol.name,\n          modulePath: externalModulePath,\n          isTypeOnly: ExportAnalyzer._getIsTypeOnly(importDeclaration)\n        });\n      }\n\n      if (declaration.kind === ts.SyntaxKind.ImportSpecifier) {\n        // EXAMPLE:\n        // \"import { A, B } from 'the-lib';\"\n        //\n        // ImportDeclaration:\n        //   ImportKeyword:  pre=[import] sep=[ ]\n        //   ImportClause:\n        //     NamedImports:\n        //       FirstPunctuation:  pre=[{] sep=[ ]\n        //       SyntaxList:\n        //         ImportSpecifier:  <------------- declaration\n        //           Identifier:  pre=[A]\n        //         CommaToken:  pre=[,] sep=[ ]\n        //         ImportSpecifier:\n        //           Identifier:  pre=[B] sep=[ ]\n        //       CloseBraceToken:  pre=[}] sep=[ ]\n        //   FromKeyword:  pre=[from] sep=[ ]\n        //   StringLiteral:  pre=['the-lib']\n        //   SemicolonToken:  pre=[;]\n\n        // Example: \" ExportName as RenamedName\"\n        const importSpecifier: ts.ImportSpecifier = declaration as ts.ImportSpecifier;\n        const exportName: string = (importSpecifier.propertyName || importSpecifier.name).getText().trim();\n\n        if (externalModulePath !== undefined) {\n          return this._fetchAstImport(declarationSymbol, {\n            importKind: AstImportKind.NamedImport,\n            modulePath: externalModulePath,\n            exportName: exportName,\n            isTypeOnly: ExportAnalyzer._getIsTypeOnly(importDeclaration)\n          });\n        }\n\n        return this._getExportOfSpecifierAstModule(exportName, importDeclaration, declarationSymbol);\n      } else if (declaration.kind === ts.SyntaxKind.ImportClause) {\n        // EXAMPLE:\n        // \"import A, { B } from './A';\"\n        //\n        // ImportDeclaration:\n        //   ImportKeyword:  pre=[import] sep=[ ]\n        //   ImportClause:  <------------- declaration (referring to A)\n        //     Identifier:  pre=[A]\n        //     CommaToken:  pre=[,] sep=[ ]\n        //     NamedImports:\n        //       FirstPunctuation:  pre=[{] sep=[ ]\n        //       SyntaxList:\n        //         ImportSpecifier:\n        //           Identifier:  pre=[B] sep=[ ]\n        //       CloseBraceToken:  pre=[}] sep=[ ]\n        //   FromKeyword:  pre=[from] sep=[ ]\n        //   StringLiteral:  pre=['./A']\n        //   SemicolonToken:  pre=[;]\n\n        const importClause: ts.ImportClause = declaration as ts.ImportClause;\n        const exportName: string = importClause.name\n          ? importClause.name.getText().trim()\n          : ts.InternalSymbolName.Default;\n\n        if (externalModulePath !== undefined) {\n          return this._fetchAstImport(declarationSymbol, {\n            importKind: AstImportKind.DefaultImport,\n            modulePath: externalModulePath,\n            exportName,\n            isTypeOnly: ExportAnalyzer._getIsTypeOnly(importDeclaration)\n          });\n        }\n\n        return this._getExportOfSpecifierAstModule(\n          ts.InternalSymbolName.Default,\n          importDeclaration,\n          declarationSymbol\n        );\n      } else {\n        throw new InternalError(\n          `Unimplemented import declaration kind: ${declaration.getText()}\\n` +\n            SourceFileLocationFormatter.formatDeclaration(declaration)\n        );\n      }\n    }\n\n    if (ts.isImportEqualsDeclaration(declaration)) {\n      // EXAMPLE:\n      // import myLib = require('my-lib');\n      //\n      // ImportEqualsDeclaration:\n      //   ImportKeyword:  pre=[import] sep=[ ]\n      //   Identifier:  pre=[myLib] sep=[ ]\n      //   FirstAssignment:  pre=[=] sep=[ ]\n      //   ExternalModuleReference:\n      //     RequireKeyword:  pre=[require]\n      //     OpenParenToken:  pre=[(]\n      //     StringLiteral:  pre=['my-lib']\n      //     CloseParenToken:  pre=[)]\n      //   SemicolonToken:  pre=[;]\n      if (ts.isExternalModuleReference(declaration.moduleReference)) {\n        if (ts.isStringLiteralLike(declaration.moduleReference.expression)) {\n          const variableName: string = TypeScriptInternals.getTextOfIdentifierOrLiteral(declaration.name);\n          const externalModuleName: string = TypeScriptInternals.getTextOfIdentifierOrLiteral(\n            declaration.moduleReference.expression\n          );\n\n          return this._fetchAstImport(declarationSymbol, {\n            importKind: AstImportKind.EqualsImport,\n            modulePath: externalModuleName,\n            exportName: variableName,\n            isTypeOnly: false\n          });\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  private static _getIsTypeOnly(importDeclaration: ts.ImportDeclaration): boolean {\n    if (importDeclaration.importClause) {\n      return !!importDeclaration.importClause.isTypeOnly;\n    }\n    return false;\n  }\n\n  private _getExportOfSpecifierAstModule(\n    exportName: string,\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration,\n    exportSymbol: ts.Symbol\n  ): AstEntity {\n    const specifierAstModule: AstModule = this._fetchSpecifierAstModule(\n      importOrExportDeclaration,\n      exportSymbol\n    );\n    const astEntity: AstEntity = this._getExportOfAstModule(exportName, specifierAstModule);\n    return astEntity;\n  }\n\n  private _getExportOfAstModule(exportName: string, astModule: AstModule): AstEntity {\n    const visitedAstModules: Set<AstModule> = new Set<AstModule>();\n    const astEntity: AstEntity | undefined = this._tryGetExportOfAstModule(\n      exportName,\n      astModule,\n      visitedAstModules\n    );\n    if (astEntity === undefined) {\n      throw new InternalError(\n        `Unable to analyze the export ${JSON.stringify(exportName)} in\\n` + astModule.sourceFile.fileName\n      );\n    }\n    return astEntity;\n  }\n\n  /**\n   * Implementation of {@link AstSymbolTable.tryGetExportOfAstModule}.\n   */\n  public tryGetExportOfAstModule(exportName: string, astModule: AstModule): AstEntity | undefined {\n    const visitedAstModules: Set<AstModule> = new Set<AstModule>();\n    return this._tryGetExportOfAstModule(exportName, astModule, visitedAstModules);\n  }\n\n  private _tryGetExportOfAstModule(\n    exportName: string,\n    astModule: AstModule,\n    visitedAstModules: Set<AstModule>\n  ): AstEntity | undefined {\n    if (visitedAstModules.has(astModule)) {\n      return undefined;\n    }\n    visitedAstModules.add(astModule);\n\n    let astEntity: AstEntity | undefined = astModule.cachedExportedEntities.get(exportName);\n    if (astEntity !== undefined) {\n      return astEntity;\n    }\n\n    // Try the explicit exports\n    const escapedExportName: ts.__String = ts.escapeLeadingUnderscores(exportName);\n    if (astModule.moduleSymbol.exports) {\n      const exportSymbol: ts.Symbol | undefined = astModule.moduleSymbol.exports.get(escapedExportName);\n      if (exportSymbol) {\n        astEntity = this.fetchReferencedAstEntity(exportSymbol, astModule.isExternal);\n\n        if (astEntity !== undefined) {\n          astModule.cachedExportedEntities.set(exportName, astEntity); // cache for next time\n          return astEntity;\n        }\n      }\n    }\n\n    // Try each of the star imports\n    for (const starExportedModule of astModule.starExportedModules) {\n      astEntity = this._tryGetExportOfAstModule(exportName, starExportedModule, visitedAstModules);\n\n      if (astEntity !== undefined) {\n        if (starExportedModule.externalModulePath !== undefined) {\n          // This entity was obtained from an external module, so return an AstImport instead\n          const astSymbol: AstSymbol = astEntity as AstSymbol;\n          return this._fetchAstImport(astSymbol.followedSymbol, {\n            importKind: AstImportKind.NamedImport,\n            modulePath: starExportedModule.externalModulePath,\n            exportName: exportName,\n            isTypeOnly: false\n          });\n        }\n\n        return astEntity;\n      }\n    }\n\n    return undefined;\n  }\n\n  private _tryGetExternalModulePath(\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration | ts.ImportTypeNode\n  ): string | undefined {\n    const moduleSpecifier: string = this._getModuleSpecifier(importOrExportDeclaration);\n    if (this._isExternalModulePath(importOrExportDeclaration, moduleSpecifier)) {\n      return moduleSpecifier;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Given an ImportDeclaration of the form `export { X } from \"___\";`, this interprets the module specifier (`\"___\"`)\n   * and fetches the corresponding AstModule object.\n   */\n  private _fetchSpecifierAstModule(\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration,\n    exportSymbol: ts.Symbol\n  ): AstModule {\n    const moduleSpecifier: string = this._getModuleSpecifier(importOrExportDeclaration);\n    const mode: ts.ModuleKind.CommonJS | ts.ModuleKind.ESNext | undefined =\n      importOrExportDeclaration.moduleSpecifier &&\n      ts.isStringLiteralLike(importOrExportDeclaration.moduleSpecifier)\n        ? TypeScriptInternals.getModeForUsageLocation(\n            importOrExportDeclaration.getSourceFile(),\n            importOrExportDeclaration.moduleSpecifier\n          )\n        : undefined;\n    const resolvedModule: ts.ResolvedModuleFull | undefined = TypeScriptInternals.getResolvedModule(\n      importOrExportDeclaration.getSourceFile(),\n      moduleSpecifier,\n      mode\n    );\n\n    if (resolvedModule === undefined) {\n      // Encountered in https://github.com/microsoft/rushstack/issues/1914.\n      //\n      // It's also possible for this to occur with ambient modules. However, in practice this doesn't happen\n      // as API Extractor treats all ambient modules as external per the logic in `_isExternalModulePath`, and\n      // thus this code path is never reached for ambient modules.\n      throw new InternalError(\n        `getResolvedModule() could not resolve module name ${JSON.stringify(moduleSpecifier)}\\n` +\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\n      );\n    }\n\n    // Map the filename back to the corresponding SourceFile. This circuitous approach is needed because\n    // we have no way to access the compiler's internal resolveExternalModuleName() function\n    const moduleSourceFile: ts.SourceFile | undefined = this._program.getSourceFile(\n      resolvedModule.resolvedFileName\n    );\n    if (!moduleSourceFile) {\n      // This should not happen, since getResolvedModule() specifically looks up names that the compiler\n      // found in export declarations for this source file\n      throw new InternalError(\n        `getSourceFile() failed to locate ${JSON.stringify(resolvedModule.resolvedFileName)}\\n` +\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\n      );\n    }\n\n    const isExternal: boolean = this._isExternalModulePath(importOrExportDeclaration, moduleSpecifier);\n    const moduleReference: IAstModuleReference = {\n      moduleSpecifier: moduleSpecifier,\n      moduleSpecifierSymbol: exportSymbol\n    };\n    const specifierAstModule: AstModule = this.fetchAstModuleFromSourceFile(\n      moduleSourceFile,\n      moduleReference,\n      isExternal\n    );\n\n    return specifierAstModule;\n  }\n\n  private _fetchAstImport(importSymbol: ts.Symbol | undefined, options: IAstImportOptions): AstImport {\n    const key: string = AstImport.getKey(options);\n\n    let astImport: AstImport | undefined = this._astImportsByKey.get(key);\n\n    if (!astImport) {\n      astImport = new AstImport(options);\n      this._astImportsByKey.set(key, astImport);\n\n      if (importSymbol) {\n        const followedSymbol: ts.Symbol = TypeScriptHelpers.followAliases(importSymbol, this._typeChecker);\n\n        astImport.astSymbol = this._astSymbolTable.fetchAstSymbol({\n          followedSymbol: followedSymbol,\n          isExternal: true,\n          includeNominalAnalysis: false,\n          addIfMissing: true\n        });\n      }\n    } else {\n      // If we encounter at least one import that does not use the type-only form,\n      // then the .d.ts rollup will NOT use \"import type\".\n      if (!options.isTypeOnly) {\n        astImport.isTypeOnlyEverywhere = false;\n      }\n    }\n\n    return astImport;\n  }\n\n  private _getModuleSpecifier(\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration | ts.ImportTypeNode\n  ): string {\n    // The name of the module, which could be like \"./SomeLocalFile' or like 'external-package/entry/point'\n    const moduleSpecifier: string | undefined =\n      TypeScriptHelpers.getModuleSpecifier(importOrExportDeclaration);\n\n    if (!moduleSpecifier) {\n      throw new InternalError(\n        'Unable to parse module specifier\\n' +\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\n      );\n    }\n\n    return moduleSpecifier;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ExportAnalyzer.js","sourceRoot":"","sources":["../../src/analyzer/ExportAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { InternalError } from '@rushstack/node-core-library';\r\n\r\nimport { TypeScriptHelpers } from './TypeScriptHelpers';\r\nimport { AstSymbol } from './AstSymbol';\r\nimport { AstImport, type IAstImportOptions, AstImportKind } from './AstImport';\r\nimport { AstModule, AstModuleExportInfo } from './AstModule';\r\nimport { TypeScriptInternals } from './TypeScriptInternals';\r\nimport { SourceFileLocationFormatter } from './SourceFileLocationFormatter';\r\nimport type { IFetchAstSymbolOptions } from './AstSymbolTable';\r\nimport type { AstEntity } from './AstEntity';\r\nimport { AstNamespaceImport } from './AstNamespaceImport';\r\nimport { SyntaxHelpers } from './SyntaxHelpers';\r\n\r\n/**\r\n * Exposes the minimal APIs from AstSymbolTable that are needed by ExportAnalyzer.\r\n *\r\n * In particular, we want ExportAnalyzer to be able to call AstSymbolTable._fetchAstSymbol() even though it\r\n * is a very private API that should not be exposed to any other components.\r\n */\r\nexport interface IAstSymbolTable {\r\n  fetchAstSymbol(options: IFetchAstSymbolOptions): AstSymbol | undefined;\r\n\r\n  analyze(astEntity: AstEntity): void;\r\n}\r\n\r\n/**\r\n * Used with ExportAnalyzer.fetchAstModuleBySourceFile() to provide contextual information about how the source file\r\n * was imported.\r\n */\r\ninterface IAstModuleReference {\r\n  /**\r\n   * For example, if we are following a statement like `import { X } from 'some-package'`, this will be the\r\n   * string `\"some-package\"`.\r\n   */\r\n  moduleSpecifier: string;\r\n\r\n  /**\r\n   * For example, if we are following a statement like `import { X } from 'some-package'`, this will be the\r\n   * symbol for `X`.\r\n   */\r\n  moduleSpecifierSymbol: ts.Symbol;\r\n}\r\n\r\n/**\r\n * The ExportAnalyzer is an internal part of AstSymbolTable that has been moved out into its own source file\r\n * because it is a complex and mostly self-contained algorithm.\r\n *\r\n * Its job is to build up AstModule objects by crawling import statements to discover where declarations come from.\r\n * This is conceptually the same as the compiler's own TypeChecker.getExportsOfModule(), except that when\r\n * ExportAnalyzer encounters a declaration that was imported from an external package, it remembers how it was imported\r\n * (i.e. the AstImport object).  Today the compiler API does not expose this information, which is crucial for\r\n * generating .d.ts rollups.\r\n */\r\nexport class ExportAnalyzer {\r\n  private readonly _program: ts.Program;\r\n  private readonly _typeChecker: ts.TypeChecker;\r\n  private readonly _bundledPackageNames: ReadonlySet<string>;\r\n  private readonly _astSymbolTable: IAstSymbolTable;\r\n\r\n  private readonly _astModulesByModuleSymbol: Map<ts.Symbol, AstModule> = new Map<ts.Symbol, AstModule>();\r\n\r\n  // Used with isImportableAmbientSourceFile()\r\n  private readonly _importableAmbientSourceFiles: Set<ts.SourceFile> = new Set<ts.SourceFile>();\r\n\r\n  private readonly _astImportsByKey: Map<string, AstImport> = new Map<string, AstImport>();\r\n  private readonly _astNamespaceImportByModule: Map<AstModule, AstNamespaceImport> = new Map();\r\n\r\n  public constructor(\r\n    program: ts.Program,\r\n    typeChecker: ts.TypeChecker,\r\n    bundledPackageNames: ReadonlySet<string>,\r\n    astSymbolTable: IAstSymbolTable\r\n  ) {\r\n    this._program = program;\r\n    this._typeChecker = typeChecker;\r\n    this._bundledPackageNames = bundledPackageNames;\r\n    this._astSymbolTable = astSymbolTable;\r\n  }\r\n\r\n  /**\r\n   * For a given source file, this analyzes all of its exports and produces an AstModule object.\r\n   *\r\n   * @param moduleReference - contextual information about the import statement that took us to this source file.\r\n   * or `undefined` if this source file is the initial entry point\r\n   * @param isExternal - whether the given `moduleReference` is external.\r\n   */\r\n  public fetchAstModuleFromSourceFile(\r\n    sourceFile: ts.SourceFile,\r\n    moduleReference: IAstModuleReference | undefined,\r\n    isExternal: boolean\r\n  ): AstModule {\r\n    const moduleSymbol: ts.Symbol = this._getModuleSymbolFromSourceFile(sourceFile, moduleReference);\r\n\r\n    // Don't traverse into a module that we already processed before:\r\n    // The compiler allows m1 to have \"export * from 'm2'\" and \"export * from 'm3'\",\r\n    // even if m2 and m3 both have \"export * from 'm4'\".\r\n    let astModule: AstModule | undefined = this._astModulesByModuleSymbol.get(moduleSymbol);\r\n    if (!astModule) {\r\n      // (If moduleReference === undefined, then this is the entry point of the local project being analyzed.)\r\n      const externalModulePath: string | undefined =\r\n        moduleReference !== undefined && isExternal ? moduleReference.moduleSpecifier : undefined;\r\n\r\n      astModule = new AstModule({ sourceFile, moduleSymbol, externalModulePath });\r\n\r\n      this._astModulesByModuleSymbol.set(moduleSymbol, astModule);\r\n\r\n      if (astModule.isExternal) {\r\n        // It's an external package, so do the special simplified analysis that doesn't crawl into referenced modules\r\n        for (const exportedSymbol of this._typeChecker.getExportsOfModule(moduleSymbol)) {\r\n          if (externalModulePath === undefined) {\r\n            throw new InternalError(\r\n              'Failed assertion: externalModulePath=undefined but astModule.isExternal=true'\r\n            );\r\n          }\r\n\r\n          const followedSymbol: ts.Symbol = TypeScriptHelpers.followAliases(\r\n            exportedSymbol,\r\n            this._typeChecker\r\n          );\r\n\r\n          // Ignore virtual symbols that don't have any declarations\r\n          const arbitraryDeclaration: ts.Declaration | undefined =\r\n            TypeScriptHelpers.tryGetADeclaration(followedSymbol);\r\n          if (arbitraryDeclaration) {\r\n            const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol({\r\n              followedSymbol: followedSymbol,\r\n              isExternal: astModule.isExternal,\r\n              includeNominalAnalysis: true,\r\n              addIfMissing: true\r\n            });\r\n\r\n            if (!astSymbol) {\r\n              throw new Error(\r\n                `Unsupported export ${JSON.stringify(exportedSymbol.name)}:\\n` +\r\n                  SourceFileLocationFormatter.formatDeclaration(arbitraryDeclaration)\r\n              );\r\n            }\r\n\r\n            astModule.cachedExportedEntities.set(exportedSymbol.name, astSymbol);\r\n          }\r\n        }\r\n      } else {\r\n        // The module is part of the local project, so do the full analysis\r\n\r\n        if (moduleSymbol.exports) {\r\n          // The \"export * from 'module-name';\" declarations are all attached to a single virtual symbol\r\n          // whose name is InternalSymbolName.ExportStar\r\n          const exportStarSymbol: ts.Symbol | undefined = moduleSymbol.exports.get(\r\n            ts.InternalSymbolName.ExportStar\r\n          );\r\n          if (exportStarSymbol) {\r\n            for (const exportStarDeclaration of exportStarSymbol.getDeclarations() || []) {\r\n              if (ts.isExportDeclaration(exportStarDeclaration)) {\r\n                const starExportedModule: AstModule | undefined = this._fetchSpecifierAstModule(\r\n                  exportStarDeclaration,\r\n                  exportStarSymbol\r\n                );\r\n\r\n                if (starExportedModule !== undefined) {\r\n                  astModule.starExportedModules.add(starExportedModule);\r\n                }\r\n              } else {\r\n                // Ignore ExportDeclaration nodes that don't match the expected pattern\r\n                // TODO: Should we report a warning?\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return astModule;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the symbol for the module corresponding to the ts.SourceFile that is being imported/exported.\r\n   *\r\n   * @remarks\r\n   * The `module` keyword can be used to declare multiple TypeScript modules inside a single source file.\r\n   * (This is a deprecated construct and mainly used for typings such as `@types/node`.)  In this situation,\r\n   * `moduleReference` helps us to fish out the correct module symbol.\r\n   */\r\n  private _getModuleSymbolFromSourceFile(\r\n    sourceFile: ts.SourceFile,\r\n    moduleReference: IAstModuleReference | undefined\r\n  ): ts.Symbol {\r\n    const moduleSymbol: ts.Symbol | undefined = TypeScriptInternals.tryGetSymbolForDeclaration(\r\n      sourceFile,\r\n      this._typeChecker\r\n    );\r\n    if (moduleSymbol !== undefined) {\r\n      // This is the normal case.  The SourceFile acts is a module and has a symbol.\r\n      return moduleSymbol;\r\n    }\r\n\r\n    if (moduleReference !== undefined) {\r\n      // But there is also an elaborate case where the source file contains one or more \"module\" declarations,\r\n      // and our moduleReference took us to one of those.\r\n\r\n      // eslint-disable-next-line no-bitwise\r\n      if ((moduleReference.moduleSpecifierSymbol.flags & ts.SymbolFlags.Alias) !== 0) {\r\n        // Follow the import/export declaration to one hop the exported item inside the target module\r\n        let followedSymbol: ts.Symbol | undefined = TypeScriptInternals.getImmediateAliasedSymbol(\r\n          moduleReference.moduleSpecifierSymbol,\r\n          this._typeChecker\r\n        );\r\n\r\n        if (followedSymbol === undefined) {\r\n          // This is a workaround for a compiler bug where getImmediateAliasedSymbol() sometimes returns undefined\r\n          followedSymbol = this._typeChecker.getAliasedSymbol(moduleReference.moduleSpecifierSymbol);\r\n        }\r\n\r\n        if (followedSymbol !== undefined && followedSymbol !== moduleReference.moduleSpecifierSymbol) {\r\n          // The parent of the exported symbol will be the module that we're importing from\r\n          const parent: ts.Symbol | undefined = TypeScriptInternals.getSymbolParent(followedSymbol);\r\n          if (parent !== undefined) {\r\n            // Make sure the thing we found is a module\r\n            // eslint-disable-next-line no-bitwise\r\n            if ((parent.flags & ts.SymbolFlags.ValueModule) !== 0) {\r\n              // Record that that this is an ambient module that can also be imported from\r\n              this._importableAmbientSourceFiles.add(sourceFile);\r\n              return parent;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    throw new InternalError('Unable to determine module for: ' + sourceFile.fileName);\r\n  }\r\n\r\n  /**\r\n   * Implementation of {@link AstSymbolTable.fetchAstModuleExportInfo}.\r\n   */\r\n  public fetchAstModuleExportInfo(entryPointAstModule: AstModule): AstModuleExportInfo {\r\n    if (entryPointAstModule.isExternal) {\r\n      throw new Error('fetchAstModuleExportInfo() is not supported for external modules');\r\n    }\r\n\r\n    if (entryPointAstModule.astModuleExportInfo === undefined) {\r\n      const astModuleExportInfo: AstModuleExportInfo = new AstModuleExportInfo();\r\n\r\n      this._collectAllExportsRecursive(astModuleExportInfo, entryPointAstModule, new Set<AstModule>());\r\n\r\n      entryPointAstModule.astModuleExportInfo = astModuleExportInfo;\r\n    }\r\n    return entryPointAstModule.astModuleExportInfo;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the module specifier refers to an external package.  Ignores packages listed in the\r\n   * \"bundledPackages\" setting from the api-extractor.json config file.\r\n   */\r\n  private _isExternalModulePath(\r\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration | ts.ImportTypeNode,\r\n    moduleSpecifier: string\r\n  ): boolean {\r\n    const specifier: ts.TypeNode | ts.Expression | undefined = ts.isImportTypeNode(importOrExportDeclaration)\r\n      ? importOrExportDeclaration.argument\r\n      : importOrExportDeclaration.moduleSpecifier;\r\n    const mode: ts.ModuleKind.CommonJS | ts.ModuleKind.ESNext | undefined =\r\n      specifier && ts.isStringLiteralLike(specifier)\r\n        ? TypeScriptInternals.getModeForUsageLocation(importOrExportDeclaration.getSourceFile(), specifier)\r\n        : undefined;\r\n\r\n    const resolvedModule: ts.ResolvedModuleFull | undefined = TypeScriptInternals.getResolvedModule(\r\n      importOrExportDeclaration.getSourceFile(),\r\n      moduleSpecifier,\r\n      mode\r\n    );\r\n\r\n    if (resolvedModule === undefined) {\r\n      // The TS compiler API `getResolvedModule` cannot resolve ambient modules. Thus, to match API Extractor's\r\n      // previous behavior, simply treat all ambient modules as external. This bug is tracked by\r\n      // https://github.com/microsoft/rushstack/issues/3335.\r\n      return true;\r\n    }\r\n\r\n    // Either something like `jquery` or `@microsoft/api-extractor`.\r\n    const packageName: string | undefined = resolvedModule.packageId?.name;\r\n    if (packageName !== undefined && this._bundledPackageNames.has(packageName)) {\r\n      return false;\r\n    }\r\n\r\n    if (resolvedModule.isExternalLibraryImport === undefined) {\r\n      // This presumably means the compiler couldn't figure out whether the module was external, but we're not\r\n      // sure how this can happen.\r\n      throw new InternalError(\r\n        `Cannot determine whether the module ${JSON.stringify(moduleSpecifier)} is external\\n` +\r\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\r\n      );\r\n    }\r\n\r\n    return resolvedModule.isExternalLibraryImport;\r\n  }\r\n\r\n  /**\r\n   * Returns true if when we analyzed sourceFile, we found that it contains an \"export=\" statement that allows\r\n   * it to behave /either/ as an ambient module /or/ as a regular importable module.  In this case,\r\n   * `AstSymbolTable._fetchAstSymbol()` will analyze its symbols even though `TypeScriptHelpers.isAmbient()`\r\n   * returns true.\r\n   */\r\n  public isImportableAmbientSourceFile(sourceFile: ts.SourceFile): boolean {\r\n    return this._importableAmbientSourceFiles.has(sourceFile);\r\n  }\r\n\r\n  private _collectAllExportsRecursive(\r\n    astModuleExportInfo: AstModuleExportInfo,\r\n    astModule: AstModule,\r\n    visitedAstModules: Set<AstModule>\r\n  ): void {\r\n    if (visitedAstModules.has(astModule)) {\r\n      return;\r\n    }\r\n    visitedAstModules.add(astModule);\r\n\r\n    if (astModule.isExternal) {\r\n      astModuleExportInfo.starExportedExternalModules.add(astModule);\r\n    } else {\r\n      // Fetch each of the explicit exports for this module\r\n      if (astModule.moduleSymbol.exports) {\r\n        astModule.moduleSymbol.exports.forEach((exportSymbol, exportName) => {\r\n          switch (exportName) {\r\n            case ts.InternalSymbolName.ExportStar:\r\n            case ts.InternalSymbolName.ExportEquals:\r\n              break;\r\n            default:\r\n              // Don't collect the \"export default\" symbol unless this is the entry point module\r\n              if (exportName !== ts.InternalSymbolName.Default || visitedAstModules.size === 1) {\r\n                if (!astModuleExportInfo.exportedLocalEntities.has(exportSymbol.name)) {\r\n                  const astEntity: AstEntity = this._getExportOfAstModule(exportSymbol.name, astModule);\r\n\r\n                  if (astEntity instanceof AstSymbol && !astEntity.isExternal) {\r\n                    this._astSymbolTable.analyze(astEntity);\r\n                  }\r\n\r\n                  if (astEntity instanceof AstNamespaceImport && !astEntity.astModule.isExternal) {\r\n                    this._astSymbolTable.analyze(astEntity);\r\n                  }\r\n\r\n                  astModuleExportInfo.exportedLocalEntities.set(exportSymbol.name, astEntity);\r\n                }\r\n              }\r\n              break;\r\n          }\r\n        });\r\n      }\r\n\r\n      for (const starExportedModule of astModule.starExportedModules) {\r\n        this._collectAllExportsRecursive(astModuleExportInfo, starExportedModule, visitedAstModules);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For a given symbol (which was encountered in the specified sourceFile), this fetches the AstEntity that it\r\n   * refers to.  For example, if a particular interface describes the return value of a function, this API can help\r\n   * us determine a TSDoc declaration reference for that symbol (if the symbol is exported).\r\n   */\r\n  public fetchReferencedAstEntity(\r\n    symbol: ts.Symbol,\r\n    referringModuleIsExternal: boolean\r\n  ): AstEntity | undefined {\r\n    // eslint-disable-next-line no-bitwise\r\n    if ((symbol.flags & ts.SymbolFlags.FunctionScopedVariable) !== 0) {\r\n      // If a symbol refers back to part of its own definition, don't follow that rabbit hole\r\n      // Example:\r\n      //\r\n      // function f(x: number): typeof x {\r\n      //    return 123;\r\n      // }\r\n      return undefined;\r\n    }\r\n\r\n    let current: ts.Symbol = symbol;\r\n\r\n    if (referringModuleIsExternal) {\r\n      current = TypeScriptHelpers.followAliases(symbol, this._typeChecker);\r\n    } else {\r\n      for (;;) {\r\n        // Is this symbol an import/export that we need to follow to find the real declaration?\r\n        for (const declaration of current.declarations || []) {\r\n          let matchedAstEntity: AstEntity | undefined;\r\n          matchedAstEntity = this._tryMatchExportDeclaration(declaration, current);\r\n          if (matchedAstEntity !== undefined) {\r\n            return matchedAstEntity;\r\n          }\r\n          matchedAstEntity = this._tryMatchImportDeclaration(declaration, current);\r\n          if (matchedAstEntity !== undefined) {\r\n            return matchedAstEntity;\r\n          }\r\n        }\r\n\r\n        // eslint-disable-next-line no-bitwise\r\n        if (!(current.flags & ts.SymbolFlags.Alias)) {\r\n          break;\r\n        }\r\n\r\n        const currentAlias: ts.Symbol = TypeScriptInternals.getImmediateAliasedSymbol(\r\n          current,\r\n          this._typeChecker\r\n        );\r\n        // Stop if we reach the end of the chain\r\n        if (!currentAlias || currentAlias === current) {\r\n          break;\r\n        }\r\n\r\n        current = currentAlias;\r\n      }\r\n    }\r\n\r\n    // Otherwise, assume it is a normal declaration\r\n    const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol({\r\n      followedSymbol: current,\r\n      isExternal: referringModuleIsExternal,\r\n      includeNominalAnalysis: false,\r\n      addIfMissing: true\r\n    });\r\n\r\n    return astSymbol;\r\n  }\r\n\r\n  public fetchReferencedAstEntityFromImportTypeNode(\r\n    node: ts.ImportTypeNode,\r\n    referringModuleIsExternal: boolean\r\n  ): AstEntity | undefined {\r\n    const externalModulePath: string | undefined = this._tryGetExternalModulePath(node);\r\n\r\n    if (externalModulePath) {\r\n      let exportName: string;\r\n      if (node.qualifier) {\r\n        // Example input:\r\n        //   import('api-extractor-lib1-test').Lib1GenericType<number>\r\n        //\r\n        // Extracted qualifier:\r\n        //   Lib1GenericType\r\n        exportName = node.qualifier.getText().trim();\r\n      } else {\r\n        // Example input:\r\n        //   import('api-extractor-lib1-test')\r\n        //\r\n        // Extracted qualifier:\r\n        //   apiExtractorLib1Test\r\n\r\n        exportName = SyntaxHelpers.makeCamelCaseIdentifier(externalModulePath);\r\n      }\r\n\r\n      return this._fetchAstImport(undefined, {\r\n        importKind: AstImportKind.ImportType,\r\n        exportName: exportName,\r\n        modulePath: externalModulePath,\r\n        isTypeOnly: false\r\n      });\r\n    }\r\n\r\n    // Internal reference: AstSymbol\r\n    const rightMostToken: ts.Identifier | ts.ImportTypeNode = node.qualifier\r\n      ? node.qualifier.kind === ts.SyntaxKind.QualifiedName\r\n        ? node.qualifier.right\r\n        : node.qualifier\r\n      : node;\r\n\r\n    // There is no symbol property in a ImportTypeNode, obtain the associated export symbol\r\n    const exportSymbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(rightMostToken);\r\n    if (!exportSymbol) {\r\n      throw new InternalError(\r\n        `Symbol not found for identifier: ${node.getText()}\\n` +\r\n          SourceFileLocationFormatter.formatDeclaration(node)\r\n      );\r\n    }\r\n\r\n    let followedSymbol: ts.Symbol = exportSymbol;\r\n    for (;;) {\r\n      const referencedAstEntity: AstEntity | undefined = this.fetchReferencedAstEntity(\r\n        followedSymbol,\r\n        referringModuleIsExternal\r\n      );\r\n\r\n      if (referencedAstEntity) {\r\n        return referencedAstEntity;\r\n      }\r\n\r\n      const followedSymbolNode: ts.Node | ts.ImportTypeNode | undefined =\r\n        followedSymbol.declarations && (followedSymbol.declarations[0] as ts.Node | undefined);\r\n\r\n      if (followedSymbolNode && followedSymbolNode.kind === ts.SyntaxKind.ImportType) {\r\n        return this.fetchReferencedAstEntityFromImportTypeNode(\r\n          followedSymbolNode as ts.ImportTypeNode,\r\n          referringModuleIsExternal\r\n        );\r\n      }\r\n\r\n      // eslint-disable-next-line no-bitwise\r\n      if (!(followedSymbol.flags & ts.SymbolFlags.Alias)) {\r\n        break;\r\n      }\r\n\r\n      const currentAlias: ts.Symbol = this._typeChecker.getAliasedSymbol(followedSymbol);\r\n      if (!currentAlias || currentAlias === followedSymbol) {\r\n        break;\r\n      }\r\n\r\n      followedSymbol = currentAlias;\r\n    }\r\n\r\n    const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol({\r\n      followedSymbol: followedSymbol,\r\n      isExternal: referringModuleIsExternal,\r\n      includeNominalAnalysis: false,\r\n      addIfMissing: true\r\n    });\r\n\r\n    return astSymbol;\r\n  }\r\n\r\n  private _tryMatchExportDeclaration(\r\n    declaration: ts.Declaration,\r\n    declarationSymbol: ts.Symbol\r\n  ): AstEntity | undefined {\r\n    const exportDeclaration: ts.ExportDeclaration | undefined =\r\n      TypeScriptHelpers.findFirstParent<ts.ExportDeclaration>(declaration, ts.SyntaxKind.ExportDeclaration);\r\n\r\n    if (exportDeclaration) {\r\n      let exportName: string | undefined = undefined;\r\n\r\n      if (declaration.kind === ts.SyntaxKind.ExportSpecifier) {\r\n        // EXAMPLE:\r\n        // \"export { A } from './file-a';\"\r\n        //\r\n        // ExportDeclaration:\r\n        //   ExportKeyword:  pre=[export] sep=[ ]\r\n        //   NamedExports:\r\n        //     FirstPunctuation:  pre=[{] sep=[ ]\r\n        //     SyntaxList:\r\n        //       ExportSpecifier:  <------------- declaration\r\n        //         Identifier:  pre=[A] sep=[ ]\r\n        //     CloseBraceToken:  pre=[}] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['./file-a']\r\n        //   SemicolonToken:  pre=[;]\r\n\r\n        // Example: \" ExportName as RenamedName\"\r\n        const exportSpecifier: ts.ExportSpecifier = declaration as ts.ExportSpecifier;\r\n        exportName = (exportSpecifier.propertyName || exportSpecifier.name).getText().trim();\r\n      } else if (declaration.kind === ts.SyntaxKind.NamespaceExport) {\r\n        // EXAMPLE:\r\n        // \"export * as theLib from 'the-lib';\"\r\n        //\r\n        // ExportDeclaration:\r\n        //   ExportKeyword:  pre=[export] sep=[ ]\r\n        //   NamespaceExport:\r\n        //     AsteriskToken:  pre=[*] sep=[ ]\r\n        //     AsKeyword:  pre=[as] sep=[ ]\r\n        //     Identifier:  pre=[theLib] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['the-lib']\r\n        //   SemicolonToken:  pre=[;]\r\n\r\n        // Issue tracking this feature: https://github.com/microsoft/rushstack/issues/2780\r\n        throw new Error(\r\n          `The \"export * as ___\" syntax is not supported yet; as a workaround,` +\r\n            ` use \"import * as ___\" with a separate \"export { ___ }\" declaration\\n` +\r\n            SourceFileLocationFormatter.formatDeclaration(declaration)\r\n        );\r\n      } else {\r\n        throw new InternalError(\r\n          `Unimplemented export declaration kind: ${declaration.getText()}\\n` +\r\n            SourceFileLocationFormatter.formatDeclaration(declaration)\r\n        );\r\n      }\r\n\r\n      // Ignore \"export { A }\" without a module specifier\r\n      if (exportDeclaration.moduleSpecifier) {\r\n        const externalModulePath: string | undefined = this._tryGetExternalModulePath(exportDeclaration);\r\n\r\n        if (externalModulePath !== undefined) {\r\n          return this._fetchAstImport(declarationSymbol, {\r\n            importKind: AstImportKind.NamedImport,\r\n            modulePath: externalModulePath,\r\n            exportName: exportName,\r\n            isTypeOnly: false\r\n          });\r\n        }\r\n\r\n        return this._getExportOfSpecifierAstModule(exportName, exportDeclaration, declarationSymbol);\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  private _tryMatchImportDeclaration(\r\n    declaration: ts.Declaration,\r\n    declarationSymbol: ts.Symbol\r\n  ): AstEntity | undefined {\r\n    const importDeclaration: ts.ImportDeclaration | undefined =\r\n      TypeScriptHelpers.findFirstParent<ts.ImportDeclaration>(declaration, ts.SyntaxKind.ImportDeclaration);\r\n\r\n    if (importDeclaration) {\r\n      const externalModulePath: string | undefined = this._tryGetExternalModulePath(importDeclaration);\r\n\r\n      if (declaration.kind === ts.SyntaxKind.NamespaceImport) {\r\n        // EXAMPLE:\r\n        // \"import * as theLib from 'the-lib';\"\r\n        //\r\n        // ImportDeclaration:\r\n        //   ImportKeyword:  pre=[import] sep=[ ]\r\n        //   ImportClause:\r\n        //     NamespaceImport:  <------------- declaration\r\n        //       AsteriskToken:  pre=[*] sep=[ ]\r\n        //       AsKeyword:  pre=[as] sep=[ ]\r\n        //       Identifier:  pre=[theLib] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['the-lib']\r\n        //   SemicolonToken:  pre=[;]\r\n\r\n        if (externalModulePath === undefined) {\r\n          const astModule: AstModule = this._fetchSpecifierAstModule(importDeclaration, declarationSymbol);\r\n          let namespaceImport: AstNamespaceImport | undefined =\r\n            this._astNamespaceImportByModule.get(astModule);\r\n          if (namespaceImport === undefined) {\r\n            namespaceImport = new AstNamespaceImport({\r\n              namespaceName: declarationSymbol.name,\r\n              astModule: astModule,\r\n              declaration: declaration,\r\n              symbol: declarationSymbol\r\n            });\r\n            this._astNamespaceImportByModule.set(astModule, namespaceImport);\r\n          }\r\n          return namespaceImport;\r\n        }\r\n\r\n        // Here importSymbol=undefined because {@inheritDoc} and such are not going to work correctly for\r\n        // a package or source file.\r\n        return this._fetchAstImport(undefined, {\r\n          importKind: AstImportKind.StarImport,\r\n          exportName: declarationSymbol.name,\r\n          modulePath: externalModulePath,\r\n          isTypeOnly: ExportAnalyzer._getIsTypeOnly(importDeclaration)\r\n        });\r\n      }\r\n\r\n      if (declaration.kind === ts.SyntaxKind.ImportSpecifier) {\r\n        // EXAMPLE:\r\n        // \"import { A, B } from 'the-lib';\"\r\n        //\r\n        // ImportDeclaration:\r\n        //   ImportKeyword:  pre=[import] sep=[ ]\r\n        //   ImportClause:\r\n        //     NamedImports:\r\n        //       FirstPunctuation:  pre=[{] sep=[ ]\r\n        //       SyntaxList:\r\n        //         ImportSpecifier:  <------------- declaration\r\n        //           Identifier:  pre=[A]\r\n        //         CommaToken:  pre=[,] sep=[ ]\r\n        //         ImportSpecifier:\r\n        //           Identifier:  pre=[B] sep=[ ]\r\n        //       CloseBraceToken:  pre=[}] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['the-lib']\r\n        //   SemicolonToken:  pre=[;]\r\n\r\n        // Example: \" ExportName as RenamedName\"\r\n        const importSpecifier: ts.ImportSpecifier = declaration as ts.ImportSpecifier;\r\n        const exportName: string = (importSpecifier.propertyName || importSpecifier.name).getText().trim();\r\n\r\n        if (externalModulePath !== undefined) {\r\n          return this._fetchAstImport(declarationSymbol, {\r\n            importKind: AstImportKind.NamedImport,\r\n            modulePath: externalModulePath,\r\n            exportName: exportName,\r\n            isTypeOnly: ExportAnalyzer._getIsTypeOnly(importDeclaration)\r\n          });\r\n        }\r\n\r\n        return this._getExportOfSpecifierAstModule(exportName, importDeclaration, declarationSymbol);\r\n      } else if (declaration.kind === ts.SyntaxKind.ImportClause) {\r\n        // EXAMPLE:\r\n        // \"import A, { B } from './A';\"\r\n        //\r\n        // ImportDeclaration:\r\n        //   ImportKeyword:  pre=[import] sep=[ ]\r\n        //   ImportClause:  <------------- declaration (referring to A)\r\n        //     Identifier:  pre=[A]\r\n        //     CommaToken:  pre=[,] sep=[ ]\r\n        //     NamedImports:\r\n        //       FirstPunctuation:  pre=[{] sep=[ ]\r\n        //       SyntaxList:\r\n        //         ImportSpecifier:\r\n        //           Identifier:  pre=[B] sep=[ ]\r\n        //       CloseBraceToken:  pre=[}] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['./A']\r\n        //   SemicolonToken:  pre=[;]\r\n\r\n        const importClause: ts.ImportClause = declaration as ts.ImportClause;\r\n        const exportName: string = importClause.name\r\n          ? importClause.name.getText().trim()\r\n          : ts.InternalSymbolName.Default;\r\n\r\n        if (externalModulePath !== undefined) {\r\n          return this._fetchAstImport(declarationSymbol, {\r\n            importKind: AstImportKind.DefaultImport,\r\n            modulePath: externalModulePath,\r\n            exportName,\r\n            isTypeOnly: ExportAnalyzer._getIsTypeOnly(importDeclaration)\r\n          });\r\n        }\r\n\r\n        return this._getExportOfSpecifierAstModule(\r\n          ts.InternalSymbolName.Default,\r\n          importDeclaration,\r\n          declarationSymbol\r\n        );\r\n      } else {\r\n        throw new InternalError(\r\n          `Unimplemented import declaration kind: ${declaration.getText()}\\n` +\r\n            SourceFileLocationFormatter.formatDeclaration(declaration)\r\n        );\r\n      }\r\n    }\r\n\r\n    if (ts.isImportEqualsDeclaration(declaration)) {\r\n      // EXAMPLE:\r\n      // import myLib = require('my-lib');\r\n      //\r\n      // ImportEqualsDeclaration:\r\n      //   ImportKeyword:  pre=[import] sep=[ ]\r\n      //   Identifier:  pre=[myLib] sep=[ ]\r\n      //   FirstAssignment:  pre=[=] sep=[ ]\r\n      //   ExternalModuleReference:\r\n      //     RequireKeyword:  pre=[require]\r\n      //     OpenParenToken:  pre=[(]\r\n      //     StringLiteral:  pre=['my-lib']\r\n      //     CloseParenToken:  pre=[)]\r\n      //   SemicolonToken:  pre=[;]\r\n      if (ts.isExternalModuleReference(declaration.moduleReference)) {\r\n        if (ts.isStringLiteralLike(declaration.moduleReference.expression)) {\r\n          const variableName: string = TypeScriptInternals.getTextOfIdentifierOrLiteral(declaration.name);\r\n          const externalModuleName: string = TypeScriptInternals.getTextOfIdentifierOrLiteral(\r\n            declaration.moduleReference.expression\r\n          );\r\n\r\n          return this._fetchAstImport(declarationSymbol, {\r\n            importKind: AstImportKind.EqualsImport,\r\n            modulePath: externalModuleName,\r\n            exportName: variableName,\r\n            isTypeOnly: false\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  private static _getIsTypeOnly(importDeclaration: ts.ImportDeclaration): boolean {\r\n    if (importDeclaration.importClause) {\r\n      return !!importDeclaration.importClause.isTypeOnly;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private _getExportOfSpecifierAstModule(\r\n    exportName: string,\r\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration,\r\n    exportSymbol: ts.Symbol\r\n  ): AstEntity {\r\n    const specifierAstModule: AstModule = this._fetchSpecifierAstModule(\r\n      importOrExportDeclaration,\r\n      exportSymbol\r\n    );\r\n    const astEntity: AstEntity = this._getExportOfAstModule(exportName, specifierAstModule);\r\n    return astEntity;\r\n  }\r\n\r\n  private _getExportOfAstModule(exportName: string, astModule: AstModule): AstEntity {\r\n    const visitedAstModules: Set<AstModule> = new Set<AstModule>();\r\n    const astEntity: AstEntity | undefined = this._tryGetExportOfAstModule(\r\n      exportName,\r\n      astModule,\r\n      visitedAstModules\r\n    );\r\n    if (astEntity === undefined) {\r\n      throw new InternalError(\r\n        `Unable to analyze the export ${JSON.stringify(exportName)} in\\n` + astModule.sourceFile.fileName\r\n      );\r\n    }\r\n    return astEntity;\r\n  }\r\n\r\n  /**\r\n   * Implementation of {@link AstSymbolTable.tryGetExportOfAstModule}.\r\n   */\r\n  public tryGetExportOfAstModule(exportName: string, astModule: AstModule): AstEntity | undefined {\r\n    const visitedAstModules: Set<AstModule> = new Set<AstModule>();\r\n    return this._tryGetExportOfAstModule(exportName, astModule, visitedAstModules);\r\n  }\r\n\r\n  private _tryGetExportOfAstModule(\r\n    exportName: string,\r\n    astModule: AstModule,\r\n    visitedAstModules: Set<AstModule>\r\n  ): AstEntity | undefined {\r\n    if (visitedAstModules.has(astModule)) {\r\n      return undefined;\r\n    }\r\n    visitedAstModules.add(astModule);\r\n\r\n    let astEntity: AstEntity | undefined = astModule.cachedExportedEntities.get(exportName);\r\n    if (astEntity !== undefined) {\r\n      return astEntity;\r\n    }\r\n\r\n    // Try the explicit exports\r\n    const escapedExportName: ts.__String = ts.escapeLeadingUnderscores(exportName);\r\n    if (astModule.moduleSymbol.exports) {\r\n      const exportSymbol: ts.Symbol | undefined = astModule.moduleSymbol.exports.get(escapedExportName);\r\n      if (exportSymbol) {\r\n        astEntity = this.fetchReferencedAstEntity(exportSymbol, astModule.isExternal);\r\n\r\n        if (astEntity !== undefined) {\r\n          astModule.cachedExportedEntities.set(exportName, astEntity); // cache for next time\r\n          return astEntity;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Try each of the star imports\r\n    for (const starExportedModule of astModule.starExportedModules) {\r\n      astEntity = this._tryGetExportOfAstModule(exportName, starExportedModule, visitedAstModules);\r\n\r\n      if (astEntity !== undefined) {\r\n        if (starExportedModule.externalModulePath !== undefined) {\r\n          // This entity was obtained from an external module, so return an AstImport instead\r\n          const astSymbol: AstSymbol = astEntity as AstSymbol;\r\n          return this._fetchAstImport(astSymbol.followedSymbol, {\r\n            importKind: AstImportKind.NamedImport,\r\n            modulePath: starExportedModule.externalModulePath,\r\n            exportName: exportName,\r\n            isTypeOnly: false\r\n          });\r\n        }\r\n\r\n        return astEntity;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  private _tryGetExternalModulePath(\r\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration | ts.ImportTypeNode\r\n  ): string | undefined {\r\n    const moduleSpecifier: string = this._getModuleSpecifier(importOrExportDeclaration);\r\n    if (this._isExternalModulePath(importOrExportDeclaration, moduleSpecifier)) {\r\n      return moduleSpecifier;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Given an ImportDeclaration of the form `export { X } from \"___\";`, this interprets the module specifier (`\"___\"`)\r\n   * and fetches the corresponding AstModule object.\r\n   */\r\n  private _fetchSpecifierAstModule(\r\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration,\r\n    exportSymbol: ts.Symbol\r\n  ): AstModule {\r\n    const moduleSpecifier: string = this._getModuleSpecifier(importOrExportDeclaration);\r\n    const mode: ts.ModuleKind.CommonJS | ts.ModuleKind.ESNext | undefined =\r\n      importOrExportDeclaration.moduleSpecifier &&\r\n      ts.isStringLiteralLike(importOrExportDeclaration.moduleSpecifier)\r\n        ? TypeScriptInternals.getModeForUsageLocation(\r\n            importOrExportDeclaration.getSourceFile(),\r\n            importOrExportDeclaration.moduleSpecifier\r\n          )\r\n        : undefined;\r\n    const resolvedModule: ts.ResolvedModuleFull | undefined = TypeScriptInternals.getResolvedModule(\r\n      importOrExportDeclaration.getSourceFile(),\r\n      moduleSpecifier,\r\n      mode\r\n    );\r\n\r\n    if (resolvedModule === undefined) {\r\n      // Encountered in https://github.com/microsoft/rushstack/issues/1914.\r\n      //\r\n      // It's also possible for this to occur with ambient modules. However, in practice this doesn't happen\r\n      // as API Extractor treats all ambient modules as external per the logic in `_isExternalModulePath`, and\r\n      // thus this code path is never reached for ambient modules.\r\n      throw new InternalError(\r\n        `getResolvedModule() could not resolve module name ${JSON.stringify(moduleSpecifier)}\\n` +\r\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\r\n      );\r\n    }\r\n\r\n    // Map the filename back to the corresponding SourceFile. This circuitous approach is needed because\r\n    // we have no way to access the compiler's internal resolveExternalModuleName() function\r\n    const moduleSourceFile: ts.SourceFile | undefined = this._program.getSourceFile(\r\n      resolvedModule.resolvedFileName\r\n    );\r\n    if (!moduleSourceFile) {\r\n      // This should not happen, since getResolvedModule() specifically looks up names that the compiler\r\n      // found in export declarations for this source file\r\n      throw new InternalError(\r\n        `getSourceFile() failed to locate ${JSON.stringify(resolvedModule.resolvedFileName)}\\n` +\r\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\r\n      );\r\n    }\r\n\r\n    const isExternal: boolean = this._isExternalModulePath(importOrExportDeclaration, moduleSpecifier);\r\n    const moduleReference: IAstModuleReference = {\r\n      moduleSpecifier: moduleSpecifier,\r\n      moduleSpecifierSymbol: exportSymbol\r\n    };\r\n    const specifierAstModule: AstModule = this.fetchAstModuleFromSourceFile(\r\n      moduleSourceFile,\r\n      moduleReference,\r\n      isExternal\r\n    );\r\n\r\n    return specifierAstModule;\r\n  }\r\n\r\n  private _fetchAstImport(importSymbol: ts.Symbol | undefined, options: IAstImportOptions): AstImport {\r\n    const key: string = AstImport.getKey(options);\r\n\r\n    let astImport: AstImport | undefined = this._astImportsByKey.get(key);\r\n\r\n    if (!astImport) {\r\n      astImport = new AstImport(options);\r\n      this._astImportsByKey.set(key, astImport);\r\n\r\n      if (importSymbol) {\r\n        const followedSymbol: ts.Symbol = TypeScriptHelpers.followAliases(importSymbol, this._typeChecker);\r\n\r\n        astImport.astSymbol = this._astSymbolTable.fetchAstSymbol({\r\n          followedSymbol: followedSymbol,\r\n          isExternal: true,\r\n          includeNominalAnalysis: false,\r\n          addIfMissing: true\r\n        });\r\n      }\r\n    } else {\r\n      // If we encounter at least one import that does not use the type-only form,\r\n      // then the .d.ts rollup will NOT use \"import type\".\r\n      if (!options.isTypeOnly) {\r\n        astImport.isTypeOnlyEverywhere = false;\r\n      }\r\n    }\r\n\r\n    return astImport;\r\n  }\r\n\r\n  private _getModuleSpecifier(\r\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration | ts.ImportTypeNode\r\n  ): string {\r\n    // The name of the module, which could be like \"./SomeLocalFile' or like 'external-package/entry/point'\r\n    const moduleSpecifier: string | undefined =\r\n      TypeScriptHelpers.getModuleSpecifier(importOrExportDeclaration);\r\n\r\n    if (!moduleSpecifier) {\r\n      throw new InternalError(\r\n        'Unable to parse module specifier\\n' +\r\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\r\n      );\r\n    }\r\n\r\n    return moduleSpecifier;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/PackageMetadataManager.js.map b/lib/analyzer/PackageMetadataManager.js.map
index 3b24e5989ca2a12bec33dcce9493198d4bab5781..0d772b829f10e681d242605b753bdd74682ab518 100644
--- a/lib/analyzer/PackageMetadataManager.js.map
+++ b/lib/analyzer/PackageMetadataManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"PackageMetadataManager.js","sourceRoot":"","sources":["../../src/analyzer/PackageMetadataManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\n\nimport {\n  type PackageJsonLookup,\n  FileSystem,\n  JsonFile,\n  type NewlineKind,\n  type INodePackageJson,\n  type JsonObject\n} from '@rushstack/node-core-library';\nimport { Extractor } from '../api/Extractor';\nimport type { MessageRouter } from '../collector/MessageRouter';\nimport { ConsoleMessageId } from '../api/ConsoleMessageId';\n\n/**\n * Represents analyzed information for a package.json file.\n * This object is constructed and returned by PackageMetadataManager.\n */\nexport class PackageMetadata {\n  /**\n   * The absolute path to the package.json file being analyzed.\n   */\n  public readonly packageJsonPath: string;\n  /**\n   * The parsed contents of package.json.  Note that PackageJsonLookup\n   * only includes essential fields.\n   */\n  public readonly packageJson: INodePackageJson;\n  /**\n   * If true, then the package's documentation comments can be assumed\n   * to contain API Extractor compatible TSDoc tags.\n   */\n  public readonly aedocSupported: boolean;\n\n  public constructor(packageJsonPath: string, packageJson: INodePackageJson, aedocSupported: boolean) {\n    this.packageJsonPath = packageJsonPath;\n    this.packageJson = packageJson;\n    this.aedocSupported = aedocSupported;\n  }\n}\n\n/**\n * This class maintains a cache of analyzed information obtained from package.json\n * files.  It is built on top of the PackageJsonLookup class.\n *\n * @remarks\n *\n * IMPORTANT: Don't use PackageMetadataManager to analyze source files from the current project:\n * 1. Files such as tsdoc-metadata.json may not have been built yet, and thus may contain incorrect information.\n * 2. The current project is not guaranteed to have a package.json file at all.  For example, API Extractor can\n *    be invoked on a bare .d.ts file.\n *\n * Use ts.program.isSourceFileFromExternalLibrary() to test source files before passing the to PackageMetadataManager.\n */\nexport class PackageMetadataManager {\n  public static tsdocMetadataFilename: string = 'tsdoc-metadata.json';\n\n  private readonly _packageJsonLookup: PackageJsonLookup;\n  private readonly _messageRouter: MessageRouter;\n  private readonly _packageMetadataByPackageJsonPath: Map<string, PackageMetadata> = new Map<\n    string,\n    PackageMetadata\n  >();\n\n  public constructor(packageJsonLookup: PackageJsonLookup, messageRouter: MessageRouter) {\n    this._packageJsonLookup = packageJsonLookup;\n    this._messageRouter = messageRouter;\n  }\n\n  // This feature is still being standardized: https://github.com/microsoft/tsdoc/issues/7\n  // In the future we will use the @microsoft/tsdoc library to read this file.\n  private static _resolveTsdocMetadataPathFromPackageJson(\n    packageFolder: string,\n    packageJson: INodePackageJson\n  ): string {\n    const tsdocMetadataFilename: string = PackageMetadataManager.tsdocMetadataFilename;\n\n    let tsdocMetadataRelativePath: string;\n\n    if (packageJson.tsdocMetadata) {\n      // 1. If package.json contains a field such as \"tsdocMetadata\": \"./path1/path2/tsdoc-metadata.json\",\n      // then that takes precedence.  This convention will be rarely needed, since the other rules below generally\n      // produce a good result.\n      tsdocMetadataRelativePath = packageJson.tsdocMetadata;\n    } else if (packageJson.typings) {\n      // 2. If package.json contains a field such as \"typings\": \"./path1/path2/index.d.ts\", then we look\n      // for the file under \"./path1/path2/tsdoc-metadata.json\"\n      tsdocMetadataRelativePath = path.join(path.dirname(packageJson.typings), tsdocMetadataFilename);\n    } else if (packageJson.main) {\n      // 3. If package.json contains a field such as \"main\": \"./path1/path2/index.js\", then we look for\n      // the file under \"./path1/path2/tsdoc-metadata.json\"\n      tsdocMetadataRelativePath = path.join(path.dirname(packageJson.main), tsdocMetadataFilename);\n    } else {\n      // 4. If none of the above rules apply, then by default we look for the file under \"./tsdoc-metadata.json\"\n      // since the default entry point is \"./index.js\"\n      tsdocMetadataRelativePath = tsdocMetadataFilename;\n    }\n\n    // Always resolve relative to the package folder.\n    const tsdocMetadataPath: string = path.resolve(packageFolder, tsdocMetadataRelativePath);\n    return tsdocMetadataPath;\n  }\n\n  /**\n   * @param tsdocMetadataPath - An explicit path that can be configured in api-extractor.json.\n   * If this parameter is not an empty string, it overrides the normal path calculation.\n   * @returns the absolute path to the TSDoc metadata file\n   */\n  public static resolveTsdocMetadataPath(\n    packageFolder: string,\n    packageJson: INodePackageJson,\n    tsdocMetadataPath?: string\n  ): string {\n    if (tsdocMetadataPath) {\n      return path.resolve(packageFolder, tsdocMetadataPath);\n    }\n    return PackageMetadataManager._resolveTsdocMetadataPathFromPackageJson(packageFolder, packageJson);\n  }\n\n  /**\n   * Writes the TSDoc metadata file to the specified output file.\n   */\n  public static writeTsdocMetadataFile(tsdocMetadataPath: string, newlineKind: NewlineKind): void {\n    const fileObject: JsonObject = {\n      tsdocVersion: '0.12',\n      toolPackages: [\n        {\n          packageName: '@microsoft/api-extractor',\n          packageVersion: Extractor.version\n        }\n      ]\n    };\n\n    const fileContent: string =\n      '// This file is read by tools that parse documentation comments conforming to the TSDoc standard.\\n' +\n      '// It should be published with your NPM package.  It should not be tracked by Git.\\n' +\n      JsonFile.stringify(fileObject);\n\n    FileSystem.writeFile(tsdocMetadataPath, fileContent, {\n      convertLineEndings: newlineKind,\n      ensureFolderExists: true\n    });\n  }\n\n  /**\n   * Finds the package.json in a parent folder of the specified source file, and\n   * returns a PackageMetadata object.  If no package.json was found, then undefined\n   * is returned.  The results are cached.\n   */\n  public tryFetchPackageMetadata(sourceFilePath: string): PackageMetadata | undefined {\n    const packageJsonFilePath: string | undefined =\n      this._packageJsonLookup.tryGetPackageJsonFilePathFor(sourceFilePath);\n    if (!packageJsonFilePath) {\n      return undefined;\n    }\n    let packageMetadata: PackageMetadata | undefined =\n      this._packageMetadataByPackageJsonPath.get(packageJsonFilePath);\n\n    if (!packageMetadata) {\n      const packageJson: INodePackageJson = this._packageJsonLookup.loadNodePackageJson(packageJsonFilePath);\n\n      const packageJsonFolder: string = path.dirname(packageJsonFilePath);\n\n      let aedocSupported: boolean = false;\n\n      const tsdocMetadataPath: string = PackageMetadataManager._resolveTsdocMetadataPathFromPackageJson(\n        packageJsonFolder,\n        packageJson\n      );\n\n      if (FileSystem.exists(tsdocMetadataPath)) {\n        this._messageRouter.logVerbose(\n          ConsoleMessageId.FoundTSDocMetadata,\n          'Found metadata in ' + tsdocMetadataPath\n        );\n        // If the file exists at all, assume it was written by API Extractor\n        aedocSupported = true;\n      }\n\n      packageMetadata = new PackageMetadata(packageJsonFilePath, packageJson, aedocSupported);\n      this._packageMetadataByPackageJsonPath.set(packageJsonFilePath, packageMetadata);\n    }\n\n    return packageMetadata;\n  }\n\n  /**\n   * Returns true if the source file is part of a package whose .d.ts files support AEDoc annotations.\n   */\n  public isAedocSupportedFor(sourceFilePath: string): boolean {\n    const packageMetadata: PackageMetadata | undefined = this.tryFetchPackageMetadata(sourceFilePath);\n    if (!packageMetadata) {\n      return false;\n    }\n    return packageMetadata.aedocSupported;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"PackageMetadataManager.js","sourceRoot":"","sources":["../../src/analyzer/PackageMetadataManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\n\r\nimport {\r\n  type PackageJsonLookup,\r\n  FileSystem,\r\n  JsonFile,\r\n  type NewlineKind,\r\n  type INodePackageJson,\r\n  type JsonObject\r\n} from '@rushstack/node-core-library';\r\nimport { Extractor } from '../api/Extractor';\r\nimport type { MessageRouter } from '../collector/MessageRouter';\r\nimport { ConsoleMessageId } from '../api/ConsoleMessageId';\r\n\r\n/**\r\n * Represents analyzed information for a package.json file.\r\n * This object is constructed and returned by PackageMetadataManager.\r\n */\r\nexport class PackageMetadata {\r\n  /**\r\n   * The absolute path to the package.json file being analyzed.\r\n   */\r\n  public readonly packageJsonPath: string;\r\n  /**\r\n   * The parsed contents of package.json.  Note that PackageJsonLookup\r\n   * only includes essential fields.\r\n   */\r\n  public readonly packageJson: INodePackageJson;\r\n  /**\r\n   * If true, then the package's documentation comments can be assumed\r\n   * to contain API Extractor compatible TSDoc tags.\r\n   */\r\n  public readonly aedocSupported: boolean;\r\n\r\n  public constructor(packageJsonPath: string, packageJson: INodePackageJson, aedocSupported: boolean) {\r\n    this.packageJsonPath = packageJsonPath;\r\n    this.packageJson = packageJson;\r\n    this.aedocSupported = aedocSupported;\r\n  }\r\n}\r\n\r\n/**\r\n * This class maintains a cache of analyzed information obtained from package.json\r\n * files.  It is built on top of the PackageJsonLookup class.\r\n *\r\n * @remarks\r\n *\r\n * IMPORTANT: Don't use PackageMetadataManager to analyze source files from the current project:\r\n * 1. Files such as tsdoc-metadata.json may not have been built yet, and thus may contain incorrect information.\r\n * 2. The current project is not guaranteed to have a package.json file at all.  For example, API Extractor can\r\n *    be invoked on a bare .d.ts file.\r\n *\r\n * Use ts.program.isSourceFileFromExternalLibrary() to test source files before passing the to PackageMetadataManager.\r\n */\r\nexport class PackageMetadataManager {\r\n  public static tsdocMetadataFilename: string = 'tsdoc-metadata.json';\r\n\r\n  private readonly _packageJsonLookup: PackageJsonLookup;\r\n  private readonly _messageRouter: MessageRouter;\r\n  private readonly _packageMetadataByPackageJsonPath: Map<string, PackageMetadata> = new Map<\r\n    string,\r\n    PackageMetadata\r\n  >();\r\n\r\n  public constructor(packageJsonLookup: PackageJsonLookup, messageRouter: MessageRouter) {\r\n    this._packageJsonLookup = packageJsonLookup;\r\n    this._messageRouter = messageRouter;\r\n  }\r\n\r\n  // This feature is still being standardized: https://github.com/microsoft/tsdoc/issues/7\r\n  // In the future we will use the @microsoft/tsdoc library to read this file.\r\n  private static _resolveTsdocMetadataPathFromPackageJson(\r\n    packageFolder: string,\r\n    packageJson: INodePackageJson\r\n  ): string {\r\n    const tsdocMetadataFilename: string = PackageMetadataManager.tsdocMetadataFilename;\r\n\r\n    let tsdocMetadataRelativePath: string;\r\n\r\n    if (packageJson.tsdocMetadata) {\r\n      // 1. If package.json contains a field such as \"tsdocMetadata\": \"./path1/path2/tsdoc-metadata.json\",\r\n      // then that takes precedence.  This convention will be rarely needed, since the other rules below generally\r\n      // produce a good result.\r\n      tsdocMetadataRelativePath = packageJson.tsdocMetadata;\r\n    } else if (packageJson.typings) {\r\n      // 2. If package.json contains a field such as \"typings\": \"./path1/path2/index.d.ts\", then we look\r\n      // for the file under \"./path1/path2/tsdoc-metadata.json\"\r\n      tsdocMetadataRelativePath = path.join(path.dirname(packageJson.typings), tsdocMetadataFilename);\r\n    } else if (packageJson.main) {\r\n      // 3. If package.json contains a field such as \"main\": \"./path1/path2/index.js\", then we look for\r\n      // the file under \"./path1/path2/tsdoc-metadata.json\"\r\n      tsdocMetadataRelativePath = path.join(path.dirname(packageJson.main), tsdocMetadataFilename);\r\n    } else {\r\n      // 4. If none of the above rules apply, then by default we look for the file under \"./tsdoc-metadata.json\"\r\n      // since the default entry point is \"./index.js\"\r\n      tsdocMetadataRelativePath = tsdocMetadataFilename;\r\n    }\r\n\r\n    // Always resolve relative to the package folder.\r\n    const tsdocMetadataPath: string = path.resolve(packageFolder, tsdocMetadataRelativePath);\r\n    return tsdocMetadataPath;\r\n  }\r\n\r\n  /**\r\n   * @param tsdocMetadataPath - An explicit path that can be configured in api-extractor.json.\r\n   * If this parameter is not an empty string, it overrides the normal path calculation.\r\n   * @returns the absolute path to the TSDoc metadata file\r\n   */\r\n  public static resolveTsdocMetadataPath(\r\n    packageFolder: string,\r\n    packageJson: INodePackageJson,\r\n    tsdocMetadataPath?: string\r\n  ): string {\r\n    if (tsdocMetadataPath) {\r\n      return path.resolve(packageFolder, tsdocMetadataPath);\r\n    }\r\n    return PackageMetadataManager._resolveTsdocMetadataPathFromPackageJson(packageFolder, packageJson);\r\n  }\r\n\r\n  /**\r\n   * Writes the TSDoc metadata file to the specified output file.\r\n   */\r\n  public static writeTsdocMetadataFile(tsdocMetadataPath: string, newlineKind: NewlineKind): void {\r\n    const fileObject: JsonObject = {\r\n      tsdocVersion: '0.12',\r\n      toolPackages: [\r\n        {\r\n          packageName: '@microsoft/api-extractor',\r\n          packageVersion: Extractor.version\r\n        }\r\n      ]\r\n    };\r\n\r\n    const fileContent: string =\r\n      '// This file is read by tools that parse documentation comments conforming to the TSDoc standard.\\n' +\r\n      '// It should be published with your NPM package.  It should not be tracked by Git.\\n' +\r\n      JsonFile.stringify(fileObject);\r\n\r\n    FileSystem.writeFile(tsdocMetadataPath, fileContent, {\r\n      convertLineEndings: newlineKind,\r\n      ensureFolderExists: true\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Finds the package.json in a parent folder of the specified source file, and\r\n   * returns a PackageMetadata object.  If no package.json was found, then undefined\r\n   * is returned.  The results are cached.\r\n   */\r\n  public tryFetchPackageMetadata(sourceFilePath: string): PackageMetadata | undefined {\r\n    const packageJsonFilePath: string | undefined =\r\n      this._packageJsonLookup.tryGetPackageJsonFilePathFor(sourceFilePath);\r\n    if (!packageJsonFilePath) {\r\n      return undefined;\r\n    }\r\n    let packageMetadata: PackageMetadata | undefined =\r\n      this._packageMetadataByPackageJsonPath.get(packageJsonFilePath);\r\n\r\n    if (!packageMetadata) {\r\n      const packageJson: INodePackageJson = this._packageJsonLookup.loadNodePackageJson(packageJsonFilePath);\r\n\r\n      const packageJsonFolder: string = path.dirname(packageJsonFilePath);\r\n\r\n      let aedocSupported: boolean = false;\r\n\r\n      const tsdocMetadataPath: string = PackageMetadataManager._resolveTsdocMetadataPathFromPackageJson(\r\n        packageJsonFolder,\r\n        packageJson\r\n      );\r\n\r\n      if (FileSystem.exists(tsdocMetadataPath)) {\r\n        this._messageRouter.logVerbose(\r\n          ConsoleMessageId.FoundTSDocMetadata,\r\n          'Found metadata in ' + tsdocMetadataPath\r\n        );\r\n        // If the file exists at all, assume it was written by API Extractor\r\n        aedocSupported = true;\r\n      }\r\n\r\n      packageMetadata = new PackageMetadata(packageJsonFilePath, packageJson, aedocSupported);\r\n      this._packageMetadataByPackageJsonPath.set(packageJsonFilePath, packageMetadata);\r\n    }\r\n\r\n    return packageMetadata;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the source file is part of a package whose .d.ts files support AEDoc annotations.\r\n   */\r\n  public isAedocSupportedFor(sourceFilePath: string): boolean {\r\n    const packageMetadata: PackageMetadata | undefined = this.tryFetchPackageMetadata(sourceFilePath);\r\n    if (!packageMetadata) {\r\n      return false;\r\n    }\r\n    return packageMetadata.aedocSupported;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/SourceFileLocationFormatter.js.map b/lib/analyzer/SourceFileLocationFormatter.js.map
index c3a35bb86d73b50ba30afa2a2bd42869a476430d..0bc35f99ae694ba54039647b4f8c681cac30b578 100644
--- a/lib/analyzer/SourceFileLocationFormatter.js.map
+++ b/lib/analyzer/SourceFileLocationFormatter.js.map
@@ -1 +1 @@
-{"version":3,"file":"SourceFileLocationFormatter.js","sourceRoot":"","sources":["../../src/analyzer/SourceFileLocationFormatter.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;AAG3D,2CAA6B;AAC7B,oEAA0D;AAQ1D,MAAa,2BAA2B;IACtC;;;OAGG;IACI,MAAM,CAAC,iBAAiB,CAAC,IAAa,EAAE,wBAAiC;QAC9E,MAAM,UAAU,GAAkB,IAAI,CAAC,aAAa,EAAE,CAAC;QACvD,MAAM,gBAAgB,GAAwB,UAAU,CAAC,6BAA6B,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;QAExG,OAAO,2BAA2B,CAAC,UAAU,CAAC,UAAU,CAAC,QAAQ,EAAE;YACjE,cAAc,EAAE,gBAAgB,CAAC,IAAI,GAAG,CAAC;YACzC,gBAAgB,EAAE,gBAAgB,CAAC,SAAS,GAAG,CAAC;YAChD,wBAAwB;SACzB,CAAC,CAAC;IACL,CAAC;IAEM,MAAM,CAAC,UAAU,CAAC,cAAsB,EAAE,OAA0C;QACzF,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,GAAG,EAAE,CAAC;SACd;QAED,IAAI,MAAM,GAAW,EAAE,CAAC;QAExB,yDAAyD;QACzD,IAAI,YAAY,GAAW,cAAc,CAAC;QAE1C,IAAI,OAAO,CAAC,wBAAwB,EAAE;YACpC,4DAA4D;YAC5D,IAAI,wBAAI,CAAC,cAAc,CAAC,cAAc,EAAE,OAAO,CAAC,wBAAwB,CAAC,EAAE;gBACzE,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,wBAAwB,EAAE,cAAc,CAAC,CAAC;aAChF;SACF;QAED,kCAAkC;QAClC,YAAY,GAAG,wBAAI,CAAC,UAAU,CAAC,YAAY,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;QACxD,MAAM,IAAI,YAAY,CAAC;QAEvB,IAAI,OAAO,CAAC,cAAc,EAAE;YAC1B,MAAM,IAAI,IAAI,OAAO,CAAC,cAAc,EAAE,CAAC;YAEvC,IAAI,OAAO,CAAC,gBAAgB,EAAE;gBAC5B,MAAM,IAAI,IAAI,OAAO,CAAC,gBAAgB,EAAE,CAAC;aAC1C;SACF;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AA/CD,kEA+CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type * as ts from 'typescript';\nimport * as path from 'path';\nimport { Path, Text } from '@rushstack/node-core-library';\n\nexport interface ISourceFileLocationFormatOptions {\n  sourceFileLine?: number;\n  sourceFileColumn?: number;\n  workingPackageFolderPath?: string;\n}\n\nexport class SourceFileLocationFormatter {\n  /**\n   * Returns a string such as this, based on the context information in the provided node:\n   *   \"[C:\\Folder\\File.ts#123]\"\n   */\n  public static formatDeclaration(node: ts.Node, workingPackageFolderPath?: string): string {\n    const sourceFile: ts.SourceFile = node.getSourceFile();\n    const lineAndCharacter: ts.LineAndCharacter = sourceFile.getLineAndCharacterOfPosition(node.getStart());\n\n    return SourceFileLocationFormatter.formatPath(sourceFile.fileName, {\n      sourceFileLine: lineAndCharacter.line + 1,\n      sourceFileColumn: lineAndCharacter.character + 1,\n      workingPackageFolderPath\n    });\n  }\n\n  public static formatPath(sourceFilePath: string, options?: ISourceFileLocationFormatOptions): string {\n    if (!options) {\n      options = {};\n    }\n\n    let result: string = '';\n\n    // Make the path relative to the workingPackageFolderPath\n    let scrubbedPath: string = sourceFilePath;\n\n    if (options.workingPackageFolderPath) {\n      // If it's under the working folder, make it a relative path\n      if (Path.isUnderOrEqual(sourceFilePath, options.workingPackageFolderPath)) {\n        scrubbedPath = path.relative(options.workingPackageFolderPath, sourceFilePath);\n      }\n    }\n\n    // Convert it to a Unix-style path\n    scrubbedPath = Text.replaceAll(scrubbedPath, '\\\\', '/');\n    result += scrubbedPath;\n\n    if (options.sourceFileLine) {\n      result += `:${options.sourceFileLine}`;\n\n      if (options.sourceFileColumn) {\n        result += `:${options.sourceFileColumn}`;\n      }\n    }\n\n    return result;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SourceFileLocationFormatter.js","sourceRoot":"","sources":["../../src/analyzer/SourceFileLocationFormatter.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;AAG3D,2CAA6B;AAC7B,oEAA0D;AAQ1D,MAAa,2BAA2B;IACtC;;;OAGG;IACI,MAAM,CAAC,iBAAiB,CAAC,IAAa,EAAE,wBAAiC;QAC9E,MAAM,UAAU,GAAkB,IAAI,CAAC,aAAa,EAAE,CAAC;QACvD,MAAM,gBAAgB,GAAwB,UAAU,CAAC,6BAA6B,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;QAExG,OAAO,2BAA2B,CAAC,UAAU,CAAC,UAAU,CAAC,QAAQ,EAAE;YACjE,cAAc,EAAE,gBAAgB,CAAC,IAAI,GAAG,CAAC;YACzC,gBAAgB,EAAE,gBAAgB,CAAC,SAAS,GAAG,CAAC;YAChD,wBAAwB;SACzB,CAAC,CAAC;IACL,CAAC;IAEM,MAAM,CAAC,UAAU,CAAC,cAAsB,EAAE,OAA0C;QACzF,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,GAAG,EAAE,CAAC;SACd;QAED,IAAI,MAAM,GAAW,EAAE,CAAC;QAExB,yDAAyD;QACzD,IAAI,YAAY,GAAW,cAAc,CAAC;QAE1C,IAAI,OAAO,CAAC,wBAAwB,EAAE;YACpC,4DAA4D;YAC5D,IAAI,wBAAI,CAAC,cAAc,CAAC,cAAc,EAAE,OAAO,CAAC,wBAAwB,CAAC,EAAE;gBACzE,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,wBAAwB,EAAE,cAAc,CAAC,CAAC;aAChF;SACF;QAED,kCAAkC;QAClC,YAAY,GAAG,wBAAI,CAAC,UAAU,CAAC,YAAY,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;QACxD,MAAM,IAAI,YAAY,CAAC;QAEvB,IAAI,OAAO,CAAC,cAAc,EAAE;YAC1B,MAAM,IAAI,IAAI,OAAO,CAAC,cAAc,EAAE,CAAC;YAEvC,IAAI,OAAO,CAAC,gBAAgB,EAAE;gBAC5B,MAAM,IAAI,IAAI,OAAO,CAAC,gBAAgB,EAAE,CAAC;aAC1C;SACF;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AA/CD,kEA+CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport type * as ts from 'typescript';\r\nimport * as path from 'path';\r\nimport { Path, Text } from '@rushstack/node-core-library';\r\n\r\nexport interface ISourceFileLocationFormatOptions {\r\n  sourceFileLine?: number;\r\n  sourceFileColumn?: number;\r\n  workingPackageFolderPath?: string;\r\n}\r\n\r\nexport class SourceFileLocationFormatter {\r\n  /**\r\n   * Returns a string such as this, based on the context information in the provided node:\r\n   *   \"[C:\\Folder\\File.ts#123]\"\r\n   */\r\n  public static formatDeclaration(node: ts.Node, workingPackageFolderPath?: string): string {\r\n    const sourceFile: ts.SourceFile = node.getSourceFile();\r\n    const lineAndCharacter: ts.LineAndCharacter = sourceFile.getLineAndCharacterOfPosition(node.getStart());\r\n\r\n    return SourceFileLocationFormatter.formatPath(sourceFile.fileName, {\r\n      sourceFileLine: lineAndCharacter.line + 1,\r\n      sourceFileColumn: lineAndCharacter.character + 1,\r\n      workingPackageFolderPath\r\n    });\r\n  }\r\n\r\n  public static formatPath(sourceFilePath: string, options?: ISourceFileLocationFormatOptions): string {\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    let result: string = '';\r\n\r\n    // Make the path relative to the workingPackageFolderPath\r\n    let scrubbedPath: string = sourceFilePath;\r\n\r\n    if (options.workingPackageFolderPath) {\r\n      // If it's under the working folder, make it a relative path\r\n      if (Path.isUnderOrEqual(sourceFilePath, options.workingPackageFolderPath)) {\r\n        scrubbedPath = path.relative(options.workingPackageFolderPath, sourceFilePath);\r\n      }\r\n    }\r\n\r\n    // Convert it to a Unix-style path\r\n    scrubbedPath = Text.replaceAll(scrubbedPath, '\\\\', '/');\r\n    result += scrubbedPath;\r\n\r\n    if (options.sourceFileLine) {\r\n      result += `:${options.sourceFileLine}`;\r\n\r\n      if (options.sourceFileColumn) {\r\n        result += `:${options.sourceFileColumn}`;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/Span.js.map b/lib/analyzer/Span.js.map
index a8537143b19843f3b65a6efa87e0fb490f6c70a2..ded3b61ce1f2177c18942792b8d4a7f68873fa92 100644
--- a/lib/analyzer/Span.js.map
+++ b/lib/analyzer/Span.js.map
@@ -1 +1 @@
-{"version":3,"file":"Span.js","sourceRoot":"","sources":["../../src/analyzer/Span.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\nimport { InternalError, Sort } from '@rushstack/node-core-library';\n\nimport { IndentedWriter } from '../generators/IndentedWriter';\n\ninterface IWriteModifiedTextOptions {\n  writer: IndentedWriter;\n  separatorOverride: string | undefined;\n  indentDocCommentState: IndentDocCommentState;\n}\n\nenum IndentDocCommentState {\n  /**\n   * `indentDocComment` was not requested for this subtree.\n   */\n  Inactive = 0,\n  /**\n   * `indentDocComment` was requested and we are looking for the opening `/` `*`\n   */\n  AwaitingOpenDelimiter = 1,\n  /**\n   * `indentDocComment` was requested and we are looking for the closing `*` `/`\n   */\n  AwaitingCloseDelimiter = 2,\n  /**\n   * `indentDocComment` was requested and we have finished indenting the comment.\n   */\n  Done = 3\n}\n\n/**\n * Choices for SpanModification.indentDocComment.\n */\nexport enum IndentDocCommentScope {\n  /**\n   * Do not detect and indent comments.\n   */\n  None = 0,\n\n  /**\n   * Look for one doc comment in the {@link Span.prefix} text only.\n   */\n  PrefixOnly = 1,\n\n  /**\n   * Look for one doc comment potentially distributed across the Span and its children.\n   */\n  SpanAndChildren = 2\n}\n\n/**\n * Specifies various transformations that will be performed by Span.getModifiedText().\n */\nexport class SpanModification {\n  /**\n   * If true, all of the child spans will be omitted from the Span.getModifiedText() output.\n   * @remarks\n   * Also, the modify() operation will not recurse into these spans.\n   */\n  public omitChildren: boolean = false;\n\n  /**\n   * If true, then the Span.separator will be removed from the Span.getModifiedText() output.\n   */\n  public omitSeparatorAfter: boolean = false;\n\n  /**\n   * If true, then Span.getModifiedText() will sort the immediate children according to their Span.sortKey\n   * property.  The separators will also be fixed up to ensure correct indentation.  If the Span.sortKey is undefined\n   * for some items, those items will not be moved, i.e. their array indexes will be unchanged.\n   */\n  public sortChildren: boolean = false;\n\n  /**\n   * Used if the parent span has Span.sortChildren=true.\n   */\n  public sortKey: string | undefined;\n\n  /**\n   * Optionally configures getModifiedText() to search for a \"/*\" doc comment and indent it.\n   * At most one comment is detected.\n   *\n   * @remarks\n   * The indentation can be applied to the `Span.modifier.prefix` only, or it can be applied to the\n   * full subtree of nodes (as needed for `ts.SyntaxKind.JSDocComment` trees).  However the enabled\n   * scopes must not overlap.\n   *\n   * This feature is enabled selectively because (1) we do not want to accidentally match `/*` appearing\n   * in a string literal or other expression that is not a comment, and (2) parsing comments is relatively\n   * expensive.\n   */\n  public indentDocComment: IndentDocCommentScope = IndentDocCommentScope.None;\n\n  private readonly _span: Span;\n  private _prefix: string | undefined;\n  private _suffix: string | undefined;\n\n  public constructor(span: Span) {\n    this._span = span;\n    this.reset();\n  }\n\n  /**\n   * Allows the Span.prefix text to be changed.\n   */\n  public get prefix(): string {\n    return this._prefix !== undefined ? this._prefix : this._span.prefix;\n  }\n\n  public set prefix(value: string) {\n    this._prefix = value;\n  }\n\n  /**\n   * Allows the Span.suffix text to be changed.\n   */\n  public get suffix(): string {\n    return this._suffix !== undefined ? this._suffix : this._span.suffix;\n  }\n\n  public set suffix(value: string) {\n    this._suffix = value;\n  }\n\n  /**\n   * Reverts any modifications made to this object.\n   */\n  public reset(): void {\n    this.omitChildren = false;\n    this.omitSeparatorAfter = false;\n    this.sortChildren = false;\n    this.sortKey = undefined;\n    this._prefix = undefined;\n    this._suffix = undefined;\n    if (this._span.kind === ts.SyntaxKind.JSDocComment) {\n      this.indentDocComment = IndentDocCommentScope.SpanAndChildren;\n    }\n  }\n\n  /**\n   * Effectively deletes the Span from the tree, by skipping its children, skipping its separator,\n   * and setting its prefix/suffix to the empty string.\n   */\n  public skipAll(): void {\n    this.prefix = '';\n    this.suffix = '';\n    this.omitChildren = true;\n    this.omitSeparatorAfter = true;\n  }\n}\n\n/**\n * The Span class provides a simple way to rewrite TypeScript source files\n * based on simple syntax transformations, i.e. without having to process deeper aspects\n * of the underlying grammar.  An example transformation might be deleting JSDoc comments\n * from a source file.\n *\n * @remarks\n * TypeScript's abstract syntax tree (AST) is represented using Node objects.\n * The Node text ignores its surrounding whitespace, and does not have an ordering guarantee.\n * For example, a JSDocComment node can be a child of a FunctionDeclaration node, even though\n * the actual comment precedes the function in the input stream.\n *\n * The Span class is a wrapper for a single Node, that provides access to every character\n * in the input stream, such that Span.getText() will exactly reproduce the corresponding\n * full Node.getText() output.\n *\n * A Span is comprised of these parts, which appear in sequential order:\n * - A prefix\n * - A collection of child spans\n * - A suffix\n * - A separator (e.g. whitespace between this span and the next item in the tree)\n *\n * These parts can be modified via Span.modification.  The modification is applied by\n * calling Span.getModifiedText().\n */\nexport class Span {\n  public readonly node: ts.Node;\n\n  // To improve performance, substrings are not allocated until actually needed\n  public readonly startIndex: number;\n  public readonly endIndex: number;\n\n  public readonly children: Span[];\n\n  public readonly modification: SpanModification;\n\n  private _parent: Span | undefined;\n  private _previousSibling: Span | undefined;\n  private _nextSibling: Span | undefined;\n\n  private _separatorStartIndex: number;\n  private _separatorEndIndex: number;\n\n  public constructor(node: ts.Node) {\n    this.node = node;\n    this.startIndex = node.kind === ts.SyntaxKind.SourceFile ? node.getFullStart() : node.getStart();\n    this.endIndex = node.end;\n    this._separatorStartIndex = 0;\n    this._separatorEndIndex = 0;\n    this.children = [];\n    this.modification = new SpanModification(this);\n\n    let previousChildSpan: Span | undefined = undefined;\n\n    for (const childNode of this.node.getChildren() || []) {\n      const childSpan: Span = new Span(childNode);\n      childSpan._parent = this;\n      childSpan._previousSibling = previousChildSpan;\n\n      if (previousChildSpan) {\n        previousChildSpan._nextSibling = childSpan;\n      }\n\n      this.children.push(childSpan);\n\n      // Normalize the bounds so that a child is never outside its parent\n      if (childSpan.startIndex < this.startIndex) {\n        this.startIndex = childSpan.startIndex;\n      }\n\n      if (childSpan.endIndex > this.endIndex) {\n        // This has never been observed empirically, but here's how we would handle it\n        this.endIndex = childSpan.endIndex;\n        throw new InternalError('Unexpected AST case');\n      }\n\n      if (previousChildSpan) {\n        if (previousChildSpan.endIndex < childSpan.startIndex) {\n          // There is some leftover text after previous child -- assign it as the separator for\n          // the preceding span.  If the preceding span has no suffix, then assign it to the\n          // deepest preceding span with no suffix.  This heuristic simplifies the most\n          // common transformations, and otherwise it can be fished out using getLastInnerSeparator().\n          let separatorRecipient: Span = previousChildSpan;\n          while (separatorRecipient.children.length > 0) {\n            const lastChild: Span = separatorRecipient.children[separatorRecipient.children.length - 1];\n            if (lastChild.endIndex !== separatorRecipient.endIndex) {\n              // There is a suffix, so we cannot push the separator any further down, or else\n              // it would get printed before this suffix.\n              break;\n            }\n            separatorRecipient = lastChild;\n          }\n          separatorRecipient._separatorStartIndex = previousChildSpan.endIndex;\n          separatorRecipient._separatorEndIndex = childSpan.startIndex;\n        }\n      }\n\n      previousChildSpan = childSpan;\n    }\n  }\n\n  public get kind(): ts.SyntaxKind {\n    return this.node.kind;\n  }\n\n  /**\n   * The parent Span, if any.\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\n   * may have a parent in the AST.\n   */\n  public get parent(): Span | undefined {\n    return this._parent;\n  }\n\n  /**\n   * If the current object is this.parent.children[i], then previousSibling corresponds\n   * to this.parent.children[i-1] if it exists.\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\n   * may have a previous sibling in the AST.\n   */\n  public get previousSibling(): Span | undefined {\n    return this._previousSibling;\n  }\n\n  /**\n   * If the current object is this.parent.children[i], then previousSibling corresponds\n   * to this.parent.children[i+1] if it exists.\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\n   * may have a previous sibling in the AST.\n   */\n  public get nextSibling(): Span | undefined {\n    return this._nextSibling;\n  }\n\n  /**\n   * The text associated with the underlying Node, up to its first child.\n   */\n  public get prefix(): string {\n    if (this.children.length) {\n      // Everything up to the first child\n      return this._getSubstring(this.startIndex, this.children[0].startIndex);\n    } else {\n      return this._getSubstring(this.startIndex, this.endIndex);\n    }\n  }\n\n  /**\n   * The text associated with the underlying Node, after its last child.\n   * If there are no children, this is always an empty string.\n   */\n  public get suffix(): string {\n    if (this.children.length) {\n      // Everything after the last child\n      return this._getSubstring(this.children[this.children.length - 1].endIndex, this.endIndex);\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * Whitespace that appeared after this node, and before the \"next\" node in the tree.\n   * Here we mean \"next\" according to an inorder traversal, not necessarily a sibling.\n   */\n  public get separator(): string {\n    return this._getSubstring(this._separatorStartIndex, this._separatorEndIndex);\n  }\n\n  /**\n   * Returns the separator of this Span, or else recursively calls getLastInnerSeparator()\n   * on the last child.\n   */\n  public getLastInnerSeparator(): string {\n    if (this.separator) {\n      return this.separator;\n    }\n    if (this.children.length > 0) {\n      return this.children[this.children.length - 1].getLastInnerSeparator();\n    }\n    return '';\n  }\n\n  /**\n   * Returns the first parent node with the specified  SyntaxKind, or undefined if there is no match.\n   */\n  public findFirstParent(kindToMatch: ts.SyntaxKind): Span | undefined {\n    let current: Span | undefined = this;\n\n    while (current) {\n      if (current.kind === kindToMatch) {\n        return current;\n      }\n      current = current.parent;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Recursively invokes the callback on this Span and all its children.  The callback\n   * can make changes to Span.modification for each node.\n   */\n  public forEach(callback: (span: Span) => void): void {\n    callback(this);\n    for (const child of this.children) {\n      child.forEach(callback);\n    }\n  }\n\n  /**\n   * Returns the original unmodified text represented by this Span.\n   */\n  public getText(): string {\n    let result: string = '';\n    result += this.prefix;\n\n    for (const child of this.children) {\n      result += child.getText();\n    }\n\n    result += this.suffix;\n    result += this.separator;\n\n    return result;\n  }\n\n  /**\n   * Returns the text represented by this Span, after applying all requested modifications.\n   */\n  public getModifiedText(): string {\n    const writer: IndentedWriter = new IndentedWriter();\n    writer.trimLeadingSpaces = true;\n\n    this._writeModifiedText({\n      writer: writer,\n      separatorOverride: undefined,\n      indentDocCommentState: IndentDocCommentState.Inactive\n    });\n\n    return writer.getText();\n  }\n\n  public writeModifiedText(output: IndentedWriter): void {\n    this._writeModifiedText({\n      writer: output,\n      separatorOverride: undefined,\n      indentDocCommentState: IndentDocCommentState.Inactive\n    });\n  }\n\n  /**\n   * Returns a diagnostic dump of the tree, showing the prefix/suffix/separator for\n   * each node.\n   */\n  public getDump(indent: string = ''): string {\n    let result: string = indent + ts.SyntaxKind[this.node.kind] + ': ';\n\n    if (this.prefix) {\n      result += ' pre=[' + this._getTrimmed(this.prefix) + ']';\n    }\n    if (this.suffix) {\n      result += ' suf=[' + this._getTrimmed(this.suffix) + ']';\n    }\n    if (this.separator) {\n      result += ' sep=[' + this._getTrimmed(this.separator) + ']';\n    }\n    result += '\\n';\n\n    for (const child of this.children) {\n      result += child.getDump(indent + '  ');\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns a diagnostic dump of the tree, showing the SpanModification settings for each nodde.\n   */\n  public getModifiedDump(indent: string = ''): string {\n    let result: string = indent + ts.SyntaxKind[this.node.kind] + ': ';\n\n    if (this.prefix) {\n      result += ' pre=[' + this._getTrimmed(this.modification.prefix) + ']';\n    }\n    if (this.suffix) {\n      result += ' suf=[' + this._getTrimmed(this.modification.suffix) + ']';\n    }\n    if (this.separator) {\n      result += ' sep=[' + this._getTrimmed(this.separator) + ']';\n    }\n    if (this.modification.indentDocComment !== IndentDocCommentScope.None) {\n      result += ' indentDocComment=' + IndentDocCommentScope[this.modification.indentDocComment];\n    }\n    if (this.modification.omitChildren) {\n      result += ' omitChildren';\n    }\n    if (this.modification.omitSeparatorAfter) {\n      result += ' omitSeparatorAfter';\n    }\n    if (this.modification.sortChildren) {\n      result += ' sortChildren';\n    }\n    if (this.modification.sortKey !== undefined) {\n      result += ` sortKey=\"${this.modification.sortKey}\"`;\n    }\n    result += '\\n';\n\n    if (!this.modification.omitChildren) {\n      for (const child of this.children) {\n        result += child.getModifiedDump(indent + '  ');\n      }\n    } else {\n      result += `${indent}  (${this.children.length} children)\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Recursive implementation of `getModifiedText()` and `writeModifiedText()`.\n   */\n  private _writeModifiedText(options: IWriteModifiedTextOptions): void {\n    // Apply indentation based on \"{\" and \"}\"\n    if (this.prefix === '{') {\n      options.writer.increaseIndent();\n    } else if (this.prefix === '}') {\n      options.writer.decreaseIndent();\n    }\n\n    if (this.modification.indentDocComment !== IndentDocCommentScope.None) {\n      this._beginIndentDocComment(options);\n    }\n\n    this._write(this.modification.prefix, options);\n\n    if (this.modification.indentDocComment === IndentDocCommentScope.PrefixOnly) {\n      this._endIndentDocComment(options);\n    }\n\n    let sortedSubset: Span[] | undefined;\n\n    if (!this.modification.omitChildren) {\n      if (this.modification.sortChildren) {\n        // We will only sort the items with a sortKey\n        const filtered: Span[] = this.children.filter((x) => x.modification.sortKey !== undefined);\n\n        // Is there at least one of them?\n        if (filtered.length > 1) {\n          sortedSubset = filtered;\n        }\n      }\n    }\n\n    if (sortedSubset) {\n      // This is the complicated special case that sorts an arbitrary subset of the child nodes,\n      // preserving the surrounding nodes.\n\n      const sortedSubsetCount: number = sortedSubset.length;\n      // Remember the separator for the first and last ones\n      const firstSeparator: string = sortedSubset[0].getLastInnerSeparator();\n      const lastSeparator: string = sortedSubset[sortedSubsetCount - 1].getLastInnerSeparator();\n\n      Sort.sortBy(sortedSubset, (x) => x.modification.sortKey);\n\n      const childOptions: IWriteModifiedTextOptions = { ...options };\n\n      let sortedSubsetIndex: number = 0;\n      for (let index: number = 0; index < this.children.length; ++index) {\n        let current: Span;\n\n        // Is this an item that we sorted?\n        if (this.children[index].modification.sortKey === undefined) {\n          // No, take the next item from the original array\n          current = this.children[index];\n          childOptions.separatorOverride = undefined;\n        } else {\n          // Yes, take the next item from the sortedSubset\n          current = sortedSubset[sortedSubsetIndex++];\n\n          if (sortedSubsetIndex < sortedSubsetCount) {\n            childOptions.separatorOverride = firstSeparator;\n          } else {\n            childOptions.separatorOverride = lastSeparator;\n          }\n        }\n\n        current._writeModifiedText(childOptions);\n      }\n    } else {\n      // This is the normal case that does not need to sort children\n      const childrenLength: number = this.children.length;\n\n      if (!this.modification.omitChildren) {\n        if (options.separatorOverride !== undefined) {\n          // Special case where the separatorOverride is passed down to the \"last inner separator\" span\n          for (let i: number = 0; i < childrenLength; ++i) {\n            const child: Span = this.children[i];\n\n            if (\n              // Only the last child inherits the separatorOverride, because only it can contain\n              // the \"last inner separator\" span\n              i < childrenLength - 1 ||\n              // If this.separator is specified, then we will write separatorOverride below, so don't pass it along\n              this.separator\n            ) {\n              const childOptions: IWriteModifiedTextOptions = { ...options };\n              childOptions.separatorOverride = undefined;\n              child._writeModifiedText(childOptions);\n            } else {\n              child._writeModifiedText(options);\n            }\n          }\n        } else {\n          // The normal simple case\n          for (const child of this.children) {\n            child._writeModifiedText(options);\n          }\n        }\n      }\n\n      this._write(this.modification.suffix, options);\n\n      if (options.separatorOverride !== undefined) {\n        if (this.separator || childrenLength === 0) {\n          this._write(options.separatorOverride, options);\n        }\n      } else {\n        if (!this.modification.omitSeparatorAfter) {\n          this._write(this.separator, options);\n        }\n      }\n    }\n\n    if (this.modification.indentDocComment === IndentDocCommentScope.SpanAndChildren) {\n      this._endIndentDocComment(options);\n    }\n  }\n\n  private _beginIndentDocComment(options: IWriteModifiedTextOptions): void {\n    if (options.indentDocCommentState !== IndentDocCommentState.Inactive) {\n      throw new InternalError('indentDocComment cannot be nested');\n    }\n    options.indentDocCommentState = IndentDocCommentState.AwaitingOpenDelimiter;\n  }\n\n  private _endIndentDocComment(options: IWriteModifiedTextOptions): void {\n    if (options.indentDocCommentState === IndentDocCommentState.AwaitingCloseDelimiter) {\n      throw new InternalError('missing \"*/\" delimiter for comment block');\n    }\n    options.indentDocCommentState = IndentDocCommentState.Inactive;\n  }\n\n  /**\n   * Writes one chunk of `text` to the `options.writer`, applying the `indentDocComment` rewriting.\n   */\n  private _write(text: string, options: IWriteModifiedTextOptions): void {\n    let parsedText: string = text;\n\n    if (options.indentDocCommentState === IndentDocCommentState.AwaitingOpenDelimiter) {\n      let index: number = parsedText.indexOf('/*');\n      if (index >= 0) {\n        index += '/*'.length;\n        options.writer.write(parsedText.substring(0, index));\n        parsedText = parsedText.substring(index);\n        options.indentDocCommentState = IndentDocCommentState.AwaitingCloseDelimiter;\n\n        options.writer.increaseIndent(' ');\n      }\n    }\n\n    if (options.indentDocCommentState === IndentDocCommentState.AwaitingCloseDelimiter) {\n      let index: number = parsedText.indexOf('*/');\n      if (index >= 0) {\n        index += '*/'.length;\n        options.writer.write(parsedText.substring(0, index));\n        parsedText = parsedText.substring(index);\n        options.indentDocCommentState = IndentDocCommentState.Done;\n\n        options.writer.decreaseIndent();\n      }\n    }\n\n    options.writer.write(parsedText);\n  }\n\n  private _getTrimmed(text: string): string {\n    const trimmed: string = text.replace(/\\r?\\n/g, '\\\\n');\n\n    if (trimmed.length > 100) {\n      return trimmed.substr(0, 97) + '...';\n    }\n    return trimmed;\n  }\n\n  private _getSubstring(startIndex: number, endIndex: number): string {\n    if (startIndex === endIndex) {\n      return '';\n    }\n    return this.node.getSourceFile().text.substring(startIndex, endIndex);\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"Span.js","sourceRoot":"","sources":["../../src/analyzer/Span.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,+CAAiC;AACjC,oEAAmE;AAEnE,iEAA8D;AAQ9D,IAAK,qBAiBJ;AAjBD,WAAK,qBAAqB;IACxB;;OAEG;IACH,yEAAY,CAAA;IACZ;;OAEG;IACH,mGAAyB,CAAA;IACzB;;OAEG;IACH,qGAA0B,CAAA;IAC1B;;OAEG;IACH,iEAAQ,CAAA;AACV,CAAC,EAjBI,qBAAqB,KAArB,qBAAqB,QAiBzB;AAED;;GAEG;AACH,IAAY,qBAeX;AAfD,WAAY,qBAAqB;IAC/B;;OAEG;IACH,iEAAQ,CAAA;IAER;;OAEG;IACH,6EAAc,CAAA;IAEd;;OAEG;IACH,uFAAmB,CAAA;AACrB,CAAC,EAfW,qBAAqB,GAArB,6BAAqB,KAArB,6BAAqB,QAehC;AAED;;GAEG;AACH,MAAa,gBAAgB;IA4C3B,YAAmB,IAAU;QA3C7B;;;;WAIG;QACI,iBAAY,GAAY,KAAK,CAAC;QAErC;;WAEG;QACI,uBAAkB,GAAY,KAAK,CAAC;QAE3C;;;;WAIG;QACI,iBAAY,GAAY,KAAK,CAAC;QAOrC;;;;;;;;;;;;WAYG;QACI,qBAAgB,GAA0B,qBAAqB,CAAC,IAAI,CAAC;QAO1E,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,KAAK,EAAE,CAAC;IACf,CAAC;IAED;;OAEG;IACH,IAAW,MAAM;QACf,OAAO,IAAI,CAAC,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;IACvE,CAAC;IAED,IAAW,MAAM,CAAC,KAAa;QAC7B,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;IACvB,CAAC;IAED;;OAEG;IACH,IAAW,MAAM;QACf,OAAO,IAAI,CAAC,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;IACvE,CAAC;IAED,IAAW,MAAM,CAAC,KAAa;QAC7B,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;IACvB,CAAC;IAED;;OAEG;IACI,KAAK;QACV,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;QAC1B,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;QAChC,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;QAC1B,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;QACzB,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;QACzB,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;QACzB,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,YAAY,EAAE;YAClD,IAAI,CAAC,gBAAgB,GAAG,qBAAqB,CAAC,eAAe,CAAC;SAC/D;IACH,CAAC;IAED;;;OAGG;IACI,OAAO;QACZ,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QACjB,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QACjB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QACzB,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;IACjC,CAAC;CACF;AAhGD,4CAgGC;AAED;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AACH,MAAa,IAAI;IAkBf,YAAmB,IAAa;QAC9B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;QACjG,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC;QACzB,IAAI,CAAC,oBAAoB,GAAG,CAAC,CAAC;QAC9B,IAAI,CAAC,kBAAkB,GAAG,CAAC,CAAC;QAC5B,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;QACnB,IAAI,CAAC,YAAY,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAE/C,IAAI,iBAAiB,GAAqB,SAAS,CAAC;QAEpD,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,EAAE,EAAE;YACrD,MAAM,SAAS,GAAS,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC;YAC5C,SAAS,CAAC,OAAO,GAAG,IAAI,CAAC;YACzB,SAAS,CAAC,gBAAgB,GAAG,iBAAiB,CAAC;YAE/C,IAAI,iBAAiB,EAAE;gBACrB,iBAAiB,CAAC,YAAY,GAAG,SAAS,CAAC;aAC5C;YAED,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAE9B,mEAAmE;YACnE,IAAI,SAAS,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,EAAE;gBAC1C,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC,UAAU,CAAC;aACxC;YAED,IAAI,SAAS,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,EAAE;gBACtC,8EAA8E;gBAC9E,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC,QAAQ,CAAC;gBACnC,MAAM,IAAI,iCAAa,CAAC,qBAAqB,CAAC,CAAC;aAChD;YAED,IAAI,iBAAiB,EAAE;gBACrB,IAAI,iBAAiB,CAAC,QAAQ,GAAG,SAAS,CAAC,UAAU,EAAE;oBACrD,qFAAqF;oBACrF,kFAAkF;oBAClF,6EAA6E;oBAC7E,4FAA4F;oBAC5F,IAAI,kBAAkB,GAAS,iBAAiB,CAAC;oBACjD,OAAO,kBAAkB,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;wBAC7C,MAAM,SAAS,GAAS,kBAAkB,CAAC,QAAQ,CAAC,kBAAkB,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;wBAC5F,IAAI,SAAS,CAAC,QAAQ,KAAK,kBAAkB,CAAC,QAAQ,EAAE;4BACtD,+EAA+E;4BAC/E,2CAA2C;4BAC3C,MAAM;yBACP;wBACD,kBAAkB,GAAG,SAAS,CAAC;qBAChC;oBACD,kBAAkB,CAAC,oBAAoB,GAAG,iBAAiB,CAAC,QAAQ,CAAC;oBACrE,kBAAkB,CAAC,kBAAkB,GAAG,SAAS,CAAC,UAAU,CAAC;iBAC9D;aACF;YAED,iBAAiB,GAAG,SAAS,CAAC;SAC/B;IACH,CAAC;IAED,IAAW,IAAI;QACb,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;IACxB,CAAC;IAED;;;;OAIG;IACH,IAAW,MAAM;QACf,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAED;;;;;OAKG;IACH,IAAW,eAAe;QACxB,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAED;;;;;OAKG;IACH,IAAW,WAAW;QACpB,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAED;;OAEG;IACH,IAAW,MAAM;QACf,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;YACxB,mCAAmC;YACnC,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;SACzE;aAAM;YACL,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;SAC3D;IACH,CAAC;IAED;;;OAGG;IACH,IAAW,MAAM;QACf,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;YACxB,kCAAkC;YAClC,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;SAC5F;aAAM;YACL,OAAO,EAAE,CAAC;SACX;IACH,CAAC;IAED;;;OAGG;IACH,IAAW,SAAS;QAClB,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,oBAAoB,EAAE,IAAI,CAAC,kBAAkB,CAAC,CAAC;IAChF,CAAC;IAED;;;OAGG;IACI,qBAAqB;QAC1B,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,OAAO,IAAI,CAAC,SAAS,CAAC;SACvB;QACD,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;YAC5B,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,qBAAqB,EAAE,CAAC;SACxE;QACD,OAAO,EAAE,CAAC;IACZ,CAAC;IAED;;OAEG;IACI,eAAe,CAAC,WAA0B;QAC/C,IAAI,OAAO,GAAqB,IAAI,CAAC;QAErC,OAAO,OAAO,EAAE;YACd,IAAI,OAAO,CAAC,IAAI,KAAK,WAAW,EAAE;gBAChC,OAAO,OAAO,CAAC;aAChB;YACD,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC;SAC1B;QAED,OAAO,SAAS,CAAC;IACnB,CAAC;IAED;;;OAGG;IACI,OAAO,CAAC,QAA8B;QAC3C,QAAQ,CAAC,IAAI,CAAC,CAAC;QACf,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;SACzB;IACH,CAAC;IAED;;OAEG;IACI,OAAO;QACZ,IAAI,MAAM,GAAW,EAAE,CAAC;QACxB,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC;QAEtB,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjC,MAAM,IAAI,KAAK,CAAC,OAAO,EAAE,CAAC;SAC3B;QAED,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC;QACtB,MAAM,IAAI,IAAI,CAAC,SAAS,CAAC;QAEzB,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACI,eAAe;QACpB,MAAM,MAAM,GAAmB,IAAI,+BAAc,EAAE,CAAC;QACpD,MAAM,CAAC,iBAAiB,GAAG,IAAI,CAAC;QAEhC,IAAI,CAAC,kBAAkB,CAAC;YACtB,MAAM,EAAE,MAAM;YACd,iBAAiB,EAAE,SAAS;YAC5B,qBAAqB,EAAE,qBAAqB,CAAC,QAAQ;SACtD,CAAC,CAAC;QAEH,OAAO,MAAM,CAAC,OAAO,EAAE,CAAC;IAC1B,CAAC;IAEM,iBAAiB,CAAC,MAAsB;QAC7C,IAAI,CAAC,kBAAkB,CAAC;YACtB,MAAM,EAAE,MAAM;YACd,iBAAiB,EAAE,SAAS;YAC5B,qBAAqB,EAAE,qBAAqB,CAAC,QAAQ;SACtD,CAAC,CAAC;IACL,CAAC;IAED;;;OAGG;IACI,OAAO,CAAC,SAAiB,EAAE;QAChC,IAAI,MAAM,GAAW,MAAM,GAAG,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;QAEnE,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,MAAM,IAAI,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC;SAC1D;QACD,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,MAAM,IAAI,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC;SAC1D;QACD,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,MAAM,IAAI,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,GAAG,CAAC;SAC7D;QACD,MAAM,IAAI,IAAI,CAAC;QAEf,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjC,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC;SACxC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACI,eAAe,CAAC,SAAiB,EAAE;QACxC,IAAI,MAAM,GAAW,MAAM,GAAG,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;QAEnE,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,MAAM,IAAI,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC;SACvE;QACD,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,MAAM,IAAI,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC;SACvE;QACD,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,MAAM,IAAI,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,GAAG,CAAC;SAC7D;QACD,IAAI,IAAI,CAAC,YAAY,CAAC,gBAAgB,KAAK,qBAAqB,CAAC,IAAI,EAAE;YACrE,MAAM,IAAI,oBAAoB,GAAG,qBAAqB,CAAC,IAAI,CAAC,YAAY,CAAC,gBAAgB,CAAC,CAAC;SAC5F;QACD,IAAI,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE;YAClC,MAAM,IAAI,eAAe,CAAC;SAC3B;QACD,IAAI,IAAI,CAAC,YAAY,CAAC,kBAAkB,EAAE;YACxC,MAAM,IAAI,qBAAqB,CAAC;SACjC;QACD,IAAI,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE;YAClC,MAAM,IAAI,eAAe,CAAC;SAC3B;QACD,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,KAAK,SAAS,EAAE;YAC3C,MAAM,IAAI,aAAa,IAAI,CAAC,YAAY,CAAC,OAAO,GAAG,CAAC;SACrD;QACD,MAAM,IAAI,IAAI,CAAC;QAEf,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE;YACnC,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACjC,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC;aAChD;SACF;aAAM;YACL,MAAM,IAAI,GAAG,MAAM,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,cAAc,CAAC;SAC7D;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACK,kBAAkB,CAAC,OAAkC;QAC3D,yCAAyC;QACzC,IAAI,IAAI,CAAC,MAAM,KAAK,GAAG,EAAE;YACvB,OAAO,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC;SACjC;aAAM,IAAI,IAAI,CAAC,MAAM,KAAK,GAAG,EAAE;YAC9B,OAAO,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC;SACjC;QAED,IAAI,IAAI,CAAC,YAAY,CAAC,gBAAgB,KAAK,qBAAqB,CAAC,IAAI,EAAE;YACrE,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,CAAC;SACtC;QAED,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QAE/C,IAAI,IAAI,CAAC,YAAY,CAAC,gBAAgB,KAAK,qBAAqB,CAAC,UAAU,EAAE;YAC3E,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;SACpC;QAED,IAAI,YAAgC,CAAC;QAErC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE;YACnC,IAAI,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE;gBAClC,6CAA6C;gBAC7C,MAAM,QAAQ,GAAW,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,OAAO,KAAK,SAAS,CAAC,CAAC;gBAE3F,iCAAiC;gBACjC,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;oBACvB,YAAY,GAAG,QAAQ,CAAC;iBACzB;aACF;SACF;QAED,IAAI,YAAY,EAAE;YAChB,0FAA0F;YAC1F,oCAAoC;YAEpC,MAAM,iBAAiB,GAAW,YAAY,CAAC,MAAM,CAAC;YACtD,qDAAqD;YACrD,MAAM,cAAc,GAAW,YAAY,CAAC,CAAC,CAAC,CAAC,qBAAqB,EAAE,CAAC;YACvE,MAAM,aAAa,GAAW,YAAY,CAAC,iBAAiB,GAAG,CAAC,CAAC,CAAC,qBAAqB,EAAE,CAAC;YAE1F,wBAAI,CAAC,MAAM,CAAC,YAAY,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;YAEzD,MAAM,YAAY,qBAAmC,OAAO,CAAE,CAAC;YAE/D,IAAI,iBAAiB,GAAW,CAAC,CAAC;YAClC,KAAK,IAAI,KAAK,GAAW,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE,KAAK,EAAE;gBACjE,IAAI,OAAa,CAAC;gBAElB,kCAAkC;gBAClC,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,YAAY,CAAC,OAAO,KAAK,SAAS,EAAE;oBAC3D,iDAAiD;oBACjD,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;oBAC/B,YAAY,CAAC,iBAAiB,GAAG,SAAS,CAAC;iBAC5C;qBAAM;oBACL,gDAAgD;oBAChD,OAAO,GAAG,YAAY,CAAC,iBAAiB,EAAE,CAAC,CAAC;oBAE5C,IAAI,iBAAiB,GAAG,iBAAiB,EAAE;wBACzC,YAAY,CAAC,iBAAiB,GAAG,cAAc,CAAC;qBACjD;yBAAM;wBACL,YAAY,CAAC,iBAAiB,GAAG,aAAa,CAAC;qBAChD;iBACF;gBAED,OAAO,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC;aAC1C;SACF;aAAM;YACL,8DAA8D;YAC9D,MAAM,cAAc,GAAW,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;YAEpD,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE;gBACnC,IAAI,OAAO,CAAC,iBAAiB,KAAK,SAAS,EAAE;oBAC3C,6FAA6F;oBAC7F,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,cAAc,EAAE,EAAE,CAAC,EAAE;wBAC/C,MAAM,KAAK,GAAS,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;wBAErC;wBACE,kFAAkF;wBAClF,kCAAkC;wBAClC,CAAC,GAAG,cAAc,GAAG,CAAC;4BACtB,qGAAqG;4BACrG,IAAI,CAAC,SAAS,EACd;4BACA,MAAM,YAAY,qBAAmC,OAAO,CAAE,CAAC;4BAC/D,YAAY,CAAC,iBAAiB,GAAG,SAAS,CAAC;4BAC3C,KAAK,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC;yBACxC;6BAAM;4BACL,KAAK,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;yBACnC;qBACF;iBACF;qBAAM;oBACL,yBAAyB;oBACzB,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;wBACjC,KAAK,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;qBACnC;iBACF;aACF;YAED,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;YAE/C,IAAI,OAAO,CAAC,iBAAiB,KAAK,SAAS,EAAE;gBAC3C,IAAI,IAAI,CAAC,SAAS,IAAI,cAAc,KAAK,CAAC,EAAE;oBAC1C,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,iBAAiB,EAAE,OAAO,CAAC,CAAC;iBACjD;aACF;iBAAM;gBACL,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,kBAAkB,EAAE;oBACzC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;iBACtC;aACF;SACF;QAED,IAAI,IAAI,CAAC,YAAY,CAAC,gBAAgB,KAAK,qBAAqB,CAAC,eAAe,EAAE;YAChF,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;SACpC;IACH,CAAC;IAEO,sBAAsB,CAAC,OAAkC;QAC/D,IAAI,OAAO,CAAC,qBAAqB,KAAK,qBAAqB,CAAC,QAAQ,EAAE;YACpE,MAAM,IAAI,iCAAa,CAAC,mCAAmC,CAAC,CAAC;SAC9D;QACD,OAAO,CAAC,qBAAqB,GAAG,qBAAqB,CAAC,qBAAqB,CAAC;IAC9E,CAAC;IAEO,oBAAoB,CAAC,OAAkC;QAC7D,IAAI,OAAO,CAAC,qBAAqB,KAAK,qBAAqB,CAAC,sBAAsB,EAAE;YAClF,MAAM,IAAI,iCAAa,CAAC,0CAA0C,CAAC,CAAC;SACrE;QACD,OAAO,CAAC,qBAAqB,GAAG,qBAAqB,CAAC,QAAQ,CAAC;IACjE,CAAC;IAED;;OAEG;IACK,MAAM,CAAC,IAAY,EAAE,OAAkC;QAC7D,IAAI,UAAU,GAAW,IAAI,CAAC;QAE9B,IAAI,OAAO,CAAC,qBAAqB,KAAK,qBAAqB,CAAC,qBAAqB,EAAE;YACjF,IAAI,KAAK,GAAW,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC7C,IAAI,KAAK,IAAI,CAAC,EAAE;gBACd,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC;gBACrB,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;gBACrD,UAAU,GAAG,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;gBACzC,OAAO,CAAC,qBAAqB,GAAG,qBAAqB,CAAC,sBAAsB,CAAC;gBAE7E,OAAO,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;aACpC;SACF;QAED,IAAI,OAAO,CAAC,qBAAqB,KAAK,qBAAqB,CAAC,sBAAsB,EAAE;YAClF,IAAI,KAAK,GAAW,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC7C,IAAI,KAAK,IAAI,CAAC,EAAE;gBACd,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC;gBACrB,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;gBACrD,UAAU,GAAG,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;gBACzC,OAAO,CAAC,qBAAqB,GAAG,qBAAqB,CAAC,IAAI,CAAC;gBAE3D,OAAO,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC;aACjC;SACF;QAED,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IACnC,CAAC;IAEO,WAAW,CAAC,IAAY;QAC9B,MAAM,OAAO,GAAW,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;QAEtD,IAAI,OAAO,CAAC,MAAM,GAAG,GAAG,EAAE;YACxB,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK,CAAC;SACtC;QACD,OAAO,OAAO,CAAC;IACjB,CAAC;IAEO,aAAa,CAAC,UAAkB,EAAE,QAAgB;QACxD,IAAI,UAAU,KAAK,QAAQ,EAAE;YAC3B,OAAO,EAAE,CAAC;SACX;QACD,OAAO,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;IACxE,CAAC;CACF;AA1dD,oBA0dC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { InternalError, Sort } from '@rushstack/node-core-library';\r\n\r\nimport { IndentedWriter } from '../generators/IndentedWriter';\r\n\r\ninterface IWriteModifiedTextOptions {\r\n  writer: IndentedWriter;\r\n  separatorOverride: string | undefined;\r\n  indentDocCommentState: IndentDocCommentState;\r\n}\r\n\r\nenum IndentDocCommentState {\r\n  /**\r\n   * `indentDocComment` was not requested for this subtree.\r\n   */\r\n  Inactive = 0,\r\n  /**\r\n   * `indentDocComment` was requested and we are looking for the opening `/` `*`\r\n   */\r\n  AwaitingOpenDelimiter = 1,\r\n  /**\r\n   * `indentDocComment` was requested and we are looking for the closing `*` `/`\r\n   */\r\n  AwaitingCloseDelimiter = 2,\r\n  /**\r\n   * `indentDocComment` was requested and we have finished indenting the comment.\r\n   */\r\n  Done = 3\r\n}\r\n\r\n/**\r\n * Choices for SpanModification.indentDocComment.\r\n */\r\nexport enum IndentDocCommentScope {\r\n  /**\r\n   * Do not detect and indent comments.\r\n   */\r\n  None = 0,\r\n\r\n  /**\r\n   * Look for one doc comment in the {@link Span.prefix} text only.\r\n   */\r\n  PrefixOnly = 1,\r\n\r\n  /**\r\n   * Look for one doc comment potentially distributed across the Span and its children.\r\n   */\r\n  SpanAndChildren = 2\r\n}\r\n\r\n/**\r\n * Specifies various transformations that will be performed by Span.getModifiedText().\r\n */\r\nexport class SpanModification {\r\n  /**\r\n   * If true, all of the child spans will be omitted from the Span.getModifiedText() output.\r\n   * @remarks\r\n   * Also, the modify() operation will not recurse into these spans.\r\n   */\r\n  public omitChildren: boolean = false;\r\n\r\n  /**\r\n   * If true, then the Span.separator will be removed from the Span.getModifiedText() output.\r\n   */\r\n  public omitSeparatorAfter: boolean = false;\r\n\r\n  /**\r\n   * If true, then Span.getModifiedText() will sort the immediate children according to their Span.sortKey\r\n   * property.  The separators will also be fixed up to ensure correct indentation.  If the Span.sortKey is undefined\r\n   * for some items, those items will not be moved, i.e. their array indexes will be unchanged.\r\n   */\r\n  public sortChildren: boolean = false;\r\n\r\n  /**\r\n   * Used if the parent span has Span.sortChildren=true.\r\n   */\r\n  public sortKey: string | undefined;\r\n\r\n  /**\r\n   * Optionally configures getModifiedText() to search for a \"/*\" doc comment and indent it.\r\n   * At most one comment is detected.\r\n   *\r\n   * @remarks\r\n   * The indentation can be applied to the `Span.modifier.prefix` only, or it can be applied to the\r\n   * full subtree of nodes (as needed for `ts.SyntaxKind.JSDocComment` trees).  However the enabled\r\n   * scopes must not overlap.\r\n   *\r\n   * This feature is enabled selectively because (1) we do not want to accidentally match `/*` appearing\r\n   * in a string literal or other expression that is not a comment, and (2) parsing comments is relatively\r\n   * expensive.\r\n   */\r\n  public indentDocComment: IndentDocCommentScope = IndentDocCommentScope.None;\r\n\r\n  private readonly _span: Span;\r\n  private _prefix: string | undefined;\r\n  private _suffix: string | undefined;\r\n\r\n  public constructor(span: Span) {\r\n    this._span = span;\r\n    this.reset();\r\n  }\r\n\r\n  /**\r\n   * Allows the Span.prefix text to be changed.\r\n   */\r\n  public get prefix(): string {\r\n    return this._prefix !== undefined ? this._prefix : this._span.prefix;\r\n  }\r\n\r\n  public set prefix(value: string) {\r\n    this._prefix = value;\r\n  }\r\n\r\n  /**\r\n   * Allows the Span.suffix text to be changed.\r\n   */\r\n  public get suffix(): string {\r\n    return this._suffix !== undefined ? this._suffix : this._span.suffix;\r\n  }\r\n\r\n  public set suffix(value: string) {\r\n    this._suffix = value;\r\n  }\r\n\r\n  /**\r\n   * Reverts any modifications made to this object.\r\n   */\r\n  public reset(): void {\r\n    this.omitChildren = false;\r\n    this.omitSeparatorAfter = false;\r\n    this.sortChildren = false;\r\n    this.sortKey = undefined;\r\n    this._prefix = undefined;\r\n    this._suffix = undefined;\r\n    if (this._span.kind === ts.SyntaxKind.JSDocComment) {\r\n      this.indentDocComment = IndentDocCommentScope.SpanAndChildren;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Effectively deletes the Span from the tree, by skipping its children, skipping its separator,\r\n   * and setting its prefix/suffix to the empty string.\r\n   */\r\n  public skipAll(): void {\r\n    this.prefix = '';\r\n    this.suffix = '';\r\n    this.omitChildren = true;\r\n    this.omitSeparatorAfter = true;\r\n  }\r\n}\r\n\r\n/**\r\n * The Span class provides a simple way to rewrite TypeScript source files\r\n * based on simple syntax transformations, i.e. without having to process deeper aspects\r\n * of the underlying grammar.  An example transformation might be deleting JSDoc comments\r\n * from a source file.\r\n *\r\n * @remarks\r\n * TypeScript's abstract syntax tree (AST) is represented using Node objects.\r\n * The Node text ignores its surrounding whitespace, and does not have an ordering guarantee.\r\n * For example, a JSDocComment node can be a child of a FunctionDeclaration node, even though\r\n * the actual comment precedes the function in the input stream.\r\n *\r\n * The Span class is a wrapper for a single Node, that provides access to every character\r\n * in the input stream, such that Span.getText() will exactly reproduce the corresponding\r\n * full Node.getText() output.\r\n *\r\n * A Span is comprised of these parts, which appear in sequential order:\r\n * - A prefix\r\n * - A collection of child spans\r\n * - A suffix\r\n * - A separator (e.g. whitespace between this span and the next item in the tree)\r\n *\r\n * These parts can be modified via Span.modification.  The modification is applied by\r\n * calling Span.getModifiedText().\r\n */\r\nexport class Span {\r\n  public readonly node: ts.Node;\r\n\r\n  // To improve performance, substrings are not allocated until actually needed\r\n  public readonly startIndex: number;\r\n  public readonly endIndex: number;\r\n\r\n  public readonly children: Span[];\r\n\r\n  public readonly modification: SpanModification;\r\n\r\n  private _parent: Span | undefined;\r\n  private _previousSibling: Span | undefined;\r\n  private _nextSibling: Span | undefined;\r\n\r\n  private _separatorStartIndex: number;\r\n  private _separatorEndIndex: number;\r\n\r\n  public constructor(node: ts.Node) {\r\n    this.node = node;\r\n    this.startIndex = node.kind === ts.SyntaxKind.SourceFile ? node.getFullStart() : node.getStart();\r\n    this.endIndex = node.end;\r\n    this._separatorStartIndex = 0;\r\n    this._separatorEndIndex = 0;\r\n    this.children = [];\r\n    this.modification = new SpanModification(this);\r\n\r\n    let previousChildSpan: Span | undefined = undefined;\r\n\r\n    for (const childNode of this.node.getChildren() || []) {\r\n      const childSpan: Span = new Span(childNode);\r\n      childSpan._parent = this;\r\n      childSpan._previousSibling = previousChildSpan;\r\n\r\n      if (previousChildSpan) {\r\n        previousChildSpan._nextSibling = childSpan;\r\n      }\r\n\r\n      this.children.push(childSpan);\r\n\r\n      // Normalize the bounds so that a child is never outside its parent\r\n      if (childSpan.startIndex < this.startIndex) {\r\n        this.startIndex = childSpan.startIndex;\r\n      }\r\n\r\n      if (childSpan.endIndex > this.endIndex) {\r\n        // This has never been observed empirically, but here's how we would handle it\r\n        this.endIndex = childSpan.endIndex;\r\n        throw new InternalError('Unexpected AST case');\r\n      }\r\n\r\n      if (previousChildSpan) {\r\n        if (previousChildSpan.endIndex < childSpan.startIndex) {\r\n          // There is some leftover text after previous child -- assign it as the separator for\r\n          // the preceding span.  If the preceding span has no suffix, then assign it to the\r\n          // deepest preceding span with no suffix.  This heuristic simplifies the most\r\n          // common transformations, and otherwise it can be fished out using getLastInnerSeparator().\r\n          let separatorRecipient: Span = previousChildSpan;\r\n          while (separatorRecipient.children.length > 0) {\r\n            const lastChild: Span = separatorRecipient.children[separatorRecipient.children.length - 1];\r\n            if (lastChild.endIndex !== separatorRecipient.endIndex) {\r\n              // There is a suffix, so we cannot push the separator any further down, or else\r\n              // it would get printed before this suffix.\r\n              break;\r\n            }\r\n            separatorRecipient = lastChild;\r\n          }\r\n          separatorRecipient._separatorStartIndex = previousChildSpan.endIndex;\r\n          separatorRecipient._separatorEndIndex = childSpan.startIndex;\r\n        }\r\n      }\r\n\r\n      previousChildSpan = childSpan;\r\n    }\r\n  }\r\n\r\n  public get kind(): ts.SyntaxKind {\r\n    return this.node.kind;\r\n  }\r\n\r\n  /**\r\n   * The parent Span, if any.\r\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\r\n   * may have a parent in the AST.\r\n   */\r\n  public get parent(): Span | undefined {\r\n    return this._parent;\r\n  }\r\n\r\n  /**\r\n   * If the current object is this.parent.children[i], then previousSibling corresponds\r\n   * to this.parent.children[i-1] if it exists.\r\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\r\n   * may have a previous sibling in the AST.\r\n   */\r\n  public get previousSibling(): Span | undefined {\r\n    return this._previousSibling;\r\n  }\r\n\r\n  /**\r\n   * If the current object is this.parent.children[i], then previousSibling corresponds\r\n   * to this.parent.children[i+1] if it exists.\r\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\r\n   * may have a previous sibling in the AST.\r\n   */\r\n  public get nextSibling(): Span | undefined {\r\n    return this._nextSibling;\r\n  }\r\n\r\n  /**\r\n   * The text associated with the underlying Node, up to its first child.\r\n   */\r\n  public get prefix(): string {\r\n    if (this.children.length) {\r\n      // Everything up to the first child\r\n      return this._getSubstring(this.startIndex, this.children[0].startIndex);\r\n    } else {\r\n      return this._getSubstring(this.startIndex, this.endIndex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The text associated with the underlying Node, after its last child.\r\n   * If there are no children, this is always an empty string.\r\n   */\r\n  public get suffix(): string {\r\n    if (this.children.length) {\r\n      // Everything after the last child\r\n      return this._getSubstring(this.children[this.children.length - 1].endIndex, this.endIndex);\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whitespace that appeared after this node, and before the \"next\" node in the tree.\r\n   * Here we mean \"next\" according to an inorder traversal, not necessarily a sibling.\r\n   */\r\n  public get separator(): string {\r\n    return this._getSubstring(this._separatorStartIndex, this._separatorEndIndex);\r\n  }\r\n\r\n  /**\r\n   * Returns the separator of this Span, or else recursively calls getLastInnerSeparator()\r\n   * on the last child.\r\n   */\r\n  public getLastInnerSeparator(): string {\r\n    if (this.separator) {\r\n      return this.separator;\r\n    }\r\n    if (this.children.length > 0) {\r\n      return this.children[this.children.length - 1].getLastInnerSeparator();\r\n    }\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Returns the first parent node with the specified  SyntaxKind, or undefined if there is no match.\r\n   */\r\n  public findFirstParent(kindToMatch: ts.SyntaxKind): Span | undefined {\r\n    let current: Span | undefined = this;\r\n\r\n    while (current) {\r\n      if (current.kind === kindToMatch) {\r\n        return current;\r\n      }\r\n      current = current.parent;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Recursively invokes the callback on this Span and all its children.  The callback\r\n   * can make changes to Span.modification for each node.\r\n   */\r\n  public forEach(callback: (span: Span) => void): void {\r\n    callback(this);\r\n    for (const child of this.children) {\r\n      child.forEach(callback);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the original unmodified text represented by this Span.\r\n   */\r\n  public getText(): string {\r\n    let result: string = '';\r\n    result += this.prefix;\r\n\r\n    for (const child of this.children) {\r\n      result += child.getText();\r\n    }\r\n\r\n    result += this.suffix;\r\n    result += this.separator;\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns the text represented by this Span, after applying all requested modifications.\r\n   */\r\n  public getModifiedText(): string {\r\n    const writer: IndentedWriter = new IndentedWriter();\r\n    writer.trimLeadingSpaces = true;\r\n\r\n    this._writeModifiedText({\r\n      writer: writer,\r\n      separatorOverride: undefined,\r\n      indentDocCommentState: IndentDocCommentState.Inactive\r\n    });\r\n\r\n    return writer.getText();\r\n  }\r\n\r\n  public writeModifiedText(output: IndentedWriter): void {\r\n    this._writeModifiedText({\r\n      writer: output,\r\n      separatorOverride: undefined,\r\n      indentDocCommentState: IndentDocCommentState.Inactive\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns a diagnostic dump of the tree, showing the prefix/suffix/separator for\r\n   * each node.\r\n   */\r\n  public getDump(indent: string = ''): string {\r\n    let result: string = indent + ts.SyntaxKind[this.node.kind] + ': ';\r\n\r\n    if (this.prefix) {\r\n      result += ' pre=[' + this._getTrimmed(this.prefix) + ']';\r\n    }\r\n    if (this.suffix) {\r\n      result += ' suf=[' + this._getTrimmed(this.suffix) + ']';\r\n    }\r\n    if (this.separator) {\r\n      result += ' sep=[' + this._getTrimmed(this.separator) + ']';\r\n    }\r\n    result += '\\n';\r\n\r\n    for (const child of this.children) {\r\n      result += child.getDump(indent + '  ');\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a diagnostic dump of the tree, showing the SpanModification settings for each nodde.\r\n   */\r\n  public getModifiedDump(indent: string = ''): string {\r\n    let result: string = indent + ts.SyntaxKind[this.node.kind] + ': ';\r\n\r\n    if (this.prefix) {\r\n      result += ' pre=[' + this._getTrimmed(this.modification.prefix) + ']';\r\n    }\r\n    if (this.suffix) {\r\n      result += ' suf=[' + this._getTrimmed(this.modification.suffix) + ']';\r\n    }\r\n    if (this.separator) {\r\n      result += ' sep=[' + this._getTrimmed(this.separator) + ']';\r\n    }\r\n    if (this.modification.indentDocComment !== IndentDocCommentScope.None) {\r\n      result += ' indentDocComment=' + IndentDocCommentScope[this.modification.indentDocComment];\r\n    }\r\n    if (this.modification.omitChildren) {\r\n      result += ' omitChildren';\r\n    }\r\n    if (this.modification.omitSeparatorAfter) {\r\n      result += ' omitSeparatorAfter';\r\n    }\r\n    if (this.modification.sortChildren) {\r\n      result += ' sortChildren';\r\n    }\r\n    if (this.modification.sortKey !== undefined) {\r\n      result += ` sortKey=\"${this.modification.sortKey}\"`;\r\n    }\r\n    result += '\\n';\r\n\r\n    if (!this.modification.omitChildren) {\r\n      for (const child of this.children) {\r\n        result += child.getModifiedDump(indent + '  ');\r\n      }\r\n    } else {\r\n      result += `${indent}  (${this.children.length} children)\\n`;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Recursive implementation of `getModifiedText()` and `writeModifiedText()`.\r\n   */\r\n  private _writeModifiedText(options: IWriteModifiedTextOptions): void {\r\n    // Apply indentation based on \"{\" and \"}\"\r\n    if (this.prefix === '{') {\r\n      options.writer.increaseIndent();\r\n    } else if (this.prefix === '}') {\r\n      options.writer.decreaseIndent();\r\n    }\r\n\r\n    if (this.modification.indentDocComment !== IndentDocCommentScope.None) {\r\n      this._beginIndentDocComment(options);\r\n    }\r\n\r\n    this._write(this.modification.prefix, options);\r\n\r\n    if (this.modification.indentDocComment === IndentDocCommentScope.PrefixOnly) {\r\n      this._endIndentDocComment(options);\r\n    }\r\n\r\n    let sortedSubset: Span[] | undefined;\r\n\r\n    if (!this.modification.omitChildren) {\r\n      if (this.modification.sortChildren) {\r\n        // We will only sort the items with a sortKey\r\n        const filtered: Span[] = this.children.filter((x) => x.modification.sortKey !== undefined);\r\n\r\n        // Is there at least one of them?\r\n        if (filtered.length > 1) {\r\n          sortedSubset = filtered;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (sortedSubset) {\r\n      // This is the complicated special case that sorts an arbitrary subset of the child nodes,\r\n      // preserving the surrounding nodes.\r\n\r\n      const sortedSubsetCount: number = sortedSubset.length;\r\n      // Remember the separator for the first and last ones\r\n      const firstSeparator: string = sortedSubset[0].getLastInnerSeparator();\r\n      const lastSeparator: string = sortedSubset[sortedSubsetCount - 1].getLastInnerSeparator();\r\n\r\n      Sort.sortBy(sortedSubset, (x) => x.modification.sortKey);\r\n\r\n      const childOptions: IWriteModifiedTextOptions = { ...options };\r\n\r\n      let sortedSubsetIndex: number = 0;\r\n      for (let index: number = 0; index < this.children.length; ++index) {\r\n        let current: Span;\r\n\r\n        // Is this an item that we sorted?\r\n        if (this.children[index].modification.sortKey === undefined) {\r\n          // No, take the next item from the original array\r\n          current = this.children[index];\r\n          childOptions.separatorOverride = undefined;\r\n        } else {\r\n          // Yes, take the next item from the sortedSubset\r\n          current = sortedSubset[sortedSubsetIndex++];\r\n\r\n          if (sortedSubsetIndex < sortedSubsetCount) {\r\n            childOptions.separatorOverride = firstSeparator;\r\n          } else {\r\n            childOptions.separatorOverride = lastSeparator;\r\n          }\r\n        }\r\n\r\n        current._writeModifiedText(childOptions);\r\n      }\r\n    } else {\r\n      // This is the normal case that does not need to sort children\r\n      const childrenLength: number = this.children.length;\r\n\r\n      if (!this.modification.omitChildren) {\r\n        if (options.separatorOverride !== undefined) {\r\n          // Special case where the separatorOverride is passed down to the \"last inner separator\" span\r\n          for (let i: number = 0; i < childrenLength; ++i) {\r\n            const child: Span = this.children[i];\r\n\r\n            if (\r\n              // Only the last child inherits the separatorOverride, because only it can contain\r\n              // the \"last inner separator\" span\r\n              i < childrenLength - 1 ||\r\n              // If this.separator is specified, then we will write separatorOverride below, so don't pass it along\r\n              this.separator\r\n            ) {\r\n              const childOptions: IWriteModifiedTextOptions = { ...options };\r\n              childOptions.separatorOverride = undefined;\r\n              child._writeModifiedText(childOptions);\r\n            } else {\r\n              child._writeModifiedText(options);\r\n            }\r\n          }\r\n        } else {\r\n          // The normal simple case\r\n          for (const child of this.children) {\r\n            child._writeModifiedText(options);\r\n          }\r\n        }\r\n      }\r\n\r\n      this._write(this.modification.suffix, options);\r\n\r\n      if (options.separatorOverride !== undefined) {\r\n        if (this.separator || childrenLength === 0) {\r\n          this._write(options.separatorOverride, options);\r\n        }\r\n      } else {\r\n        if (!this.modification.omitSeparatorAfter) {\r\n          this._write(this.separator, options);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.modification.indentDocComment === IndentDocCommentScope.SpanAndChildren) {\r\n      this._endIndentDocComment(options);\r\n    }\r\n  }\r\n\r\n  private _beginIndentDocComment(options: IWriteModifiedTextOptions): void {\r\n    if (options.indentDocCommentState !== IndentDocCommentState.Inactive) {\r\n      throw new InternalError('indentDocComment cannot be nested');\r\n    }\r\n    options.indentDocCommentState = IndentDocCommentState.AwaitingOpenDelimiter;\r\n  }\r\n\r\n  private _endIndentDocComment(options: IWriteModifiedTextOptions): void {\r\n    if (options.indentDocCommentState === IndentDocCommentState.AwaitingCloseDelimiter) {\r\n      throw new InternalError('missing \"*/\" delimiter for comment block');\r\n    }\r\n    options.indentDocCommentState = IndentDocCommentState.Inactive;\r\n  }\r\n\r\n  /**\r\n   * Writes one chunk of `text` to the `options.writer`, applying the `indentDocComment` rewriting.\r\n   */\r\n  private _write(text: string, options: IWriteModifiedTextOptions): void {\r\n    let parsedText: string = text;\r\n\r\n    if (options.indentDocCommentState === IndentDocCommentState.AwaitingOpenDelimiter) {\r\n      let index: number = parsedText.indexOf('/*');\r\n      if (index >= 0) {\r\n        index += '/*'.length;\r\n        options.writer.write(parsedText.substring(0, index));\r\n        parsedText = parsedText.substring(index);\r\n        options.indentDocCommentState = IndentDocCommentState.AwaitingCloseDelimiter;\r\n\r\n        options.writer.increaseIndent(' ');\r\n      }\r\n    }\r\n\r\n    if (options.indentDocCommentState === IndentDocCommentState.AwaitingCloseDelimiter) {\r\n      let index: number = parsedText.indexOf('*/');\r\n      if (index >= 0) {\r\n        index += '*/'.length;\r\n        options.writer.write(parsedText.substring(0, index));\r\n        parsedText = parsedText.substring(index);\r\n        options.indentDocCommentState = IndentDocCommentState.Done;\r\n\r\n        options.writer.decreaseIndent();\r\n      }\r\n    }\r\n\r\n    options.writer.write(parsedText);\r\n  }\r\n\r\n  private _getTrimmed(text: string): string {\r\n    const trimmed: string = text.replace(/\\r?\\n/g, '\\\\n');\r\n\r\n    if (trimmed.length > 100) {\r\n      return trimmed.substr(0, 97) + '...';\r\n    }\r\n    return trimmed;\r\n  }\r\n\r\n  private _getSubstring(startIndex: number, endIndex: number): string {\r\n    if (startIndex === endIndex) {\r\n      return '';\r\n    }\r\n    return this.node.getSourceFile().text.substring(startIndex, endIndex);\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/SyntaxHelpers.js.map b/lib/analyzer/SyntaxHelpers.js.map
index 8d4456edeb58e4b9ca858d2c6febe1c14b161c49..23949af7b1e8fccec5bfd91853684f52fe90137d 100644
--- a/lib/analyzer/SyntaxHelpers.js.map
+++ b/lib/analyzer/SyntaxHelpers.js.map
@@ -1 +1 @@
-{"version":3,"file":"SyntaxHelpers.js","sourceRoot":"","sources":["../../src/analyzer/SyntaxHelpers.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,+CAAiC;AAEjC;;GAEG;AACH,MAAa,aAAa;IACxB;;;;;;;;;;;;;;;;OAgBG;IACI,MAAM,CAAC,8BAA8B,CAAC,UAAkB;QAC7D,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;YAC3B,OAAO,KAAK,CAAC,CAAC,kBAAkB;SACjC;QAED,IAAI,CAAC,EAAE,CAAC,iBAAiB,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;YACxE,OAAO,KAAK,CAAC;SACd;QAED,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAClD,IAAI,CAAC,EAAE,CAAC,gBAAgB,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;gBACvE,OAAO,KAAK,CAAC;aACd;SACF;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,uBAAuB,CAAC,KAAa;QACjD,MAAM,KAAK,GAAa,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACvE,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACtB,OAAO,GAAG,CAAC;SACZ;QAED,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YAC7C,IAAI,IAAI,GAAW,KAAK,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAI,IAAI,CAAC,WAAW,EAAE,KAAK,IAAI,EAAE;gBAC/B,2DAA2D;gBAC3D,IAAI,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;aAC3B;YACD,IAAI,CAAC,KAAK,CAAC,EAAE;gBACX,sDAAsD;gBACtD,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;oBAChC,IAAI,GAAG,GAAG,GAAG,IAAI,CAAC;iBACnB;aACF;iBAAM;gBACL,qEAAqE;gBACrE,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;aACrD;YACD,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;SACjB;QACD,OAAO,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACxB,CAAC;CACF;AApED,sCAoEC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\n\n/**\n * Helpers for validating various text string formats.\n */\nexport class SyntaxHelpers {\n  /**\n   * Tests whether the input string is safe to use as an ECMAScript identifier without quotes.\n   *\n   * @remarks\n   * For example:\n   *\n   * ```ts\n   * class X {\n   *   public okay: number = 1;\n   *   public \"not okay!\": number = 2;\n   * }\n   * ```\n   *\n   * A precise check is extremely complicated and highly dependent on the ECMAScript standard version\n   * and how faithfully the interpreter implements it.  To keep things simple, `isSafeUnquotedMemberIdentifier()`\n   * conservatively accepts any identifier that would be valid with ECMAScript 5, and returns false otherwise.\n   */\n  public static isSafeUnquotedMemberIdentifier(identifier: string): boolean {\n    if (identifier.length === 0) {\n      return false; // cannot be empty\n    }\n\n    if (!ts.isIdentifierStart(identifier.charCodeAt(0), ts.ScriptTarget.ES5)) {\n      return false;\n    }\n\n    for (let i: number = 1; i < identifier.length; i++) {\n      if (!ts.isIdentifierPart(identifier.charCodeAt(i), ts.ScriptTarget.ES5)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Given an arbitrary input string, return a regular TypeScript identifier name.\n   *\n   * @remarks\n   * Example input:  \"api-extractor-lib1-test\"\n   * Example output: \"apiExtractorLib1Test\"\n   */\n  public static makeCamelCaseIdentifier(input: string): string {\n    const parts: string[] = input.split(/\\W+/).filter((x) => x.length > 0);\n    if (parts.length === 0) {\n      return '_';\n    }\n\n    for (let i: number = 0; i < parts.length; ++i) {\n      let part: string = parts[i];\n      if (part.toUpperCase() === part) {\n        // Preserve existing case unless the part is all upper-case\n        part = part.toLowerCase();\n      }\n      if (i === 0) {\n        // If the first part starts with a number, prepend \"_\"\n        if (/[0-9]/.test(part.charAt(0))) {\n          part = '_' + part;\n        }\n      } else {\n        // Capitalize the first letter of each part, except for the first one\n        part = part.charAt(0).toUpperCase() + part.slice(1);\n      }\n      parts[i] = part;\n    }\n    return parts.join('');\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SyntaxHelpers.js","sourceRoot":"","sources":["../../src/analyzer/SyntaxHelpers.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,+CAAiC;AAEjC;;GAEG;AACH,MAAa,aAAa;IACxB;;;;;;;;;;;;;;;;OAgBG;IACI,MAAM,CAAC,8BAA8B,CAAC,UAAkB;QAC7D,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;YAC3B,OAAO,KAAK,CAAC,CAAC,kBAAkB;SACjC;QAED,IAAI,CAAC,EAAE,CAAC,iBAAiB,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;YACxE,OAAO,KAAK,CAAC;SACd;QAED,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAClD,IAAI,CAAC,EAAE,CAAC,gBAAgB,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;gBACvE,OAAO,KAAK,CAAC;aACd;SACF;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,uBAAuB,CAAC,KAAa;QACjD,MAAM,KAAK,GAAa,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACvE,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACtB,OAAO,GAAG,CAAC;SACZ;QAED,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YAC7C,IAAI,IAAI,GAAW,KAAK,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAI,IAAI,CAAC,WAAW,EAAE,KAAK,IAAI,EAAE;gBAC/B,2DAA2D;gBAC3D,IAAI,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;aAC3B;YACD,IAAI,CAAC,KAAK,CAAC,EAAE;gBACX,sDAAsD;gBACtD,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;oBAChC,IAAI,GAAG,GAAG,GAAG,IAAI,CAAC;iBACnB;aACF;iBAAM;gBACL,qEAAqE;gBACrE,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;aACrD;YACD,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;SACjB;QACD,OAAO,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACxB,CAAC;CACF;AApED,sCAoEC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\n\r\n/**\r\n * Helpers for validating various text string formats.\r\n */\r\nexport class SyntaxHelpers {\r\n  /**\r\n   * Tests whether the input string is safe to use as an ECMAScript identifier without quotes.\r\n   *\r\n   * @remarks\r\n   * For example:\r\n   *\r\n   * ```ts\r\n   * class X {\r\n   *   public okay: number = 1;\r\n   *   public \"not okay!\": number = 2;\r\n   * }\r\n   * ```\r\n   *\r\n   * A precise check is extremely complicated and highly dependent on the ECMAScript standard version\r\n   * and how faithfully the interpreter implements it.  To keep things simple, `isSafeUnquotedMemberIdentifier()`\r\n   * conservatively accepts any identifier that would be valid with ECMAScript 5, and returns false otherwise.\r\n   */\r\n  public static isSafeUnquotedMemberIdentifier(identifier: string): boolean {\r\n    if (identifier.length === 0) {\r\n      return false; // cannot be empty\r\n    }\r\n\r\n    if (!ts.isIdentifierStart(identifier.charCodeAt(0), ts.ScriptTarget.ES5)) {\r\n      return false;\r\n    }\r\n\r\n    for (let i: number = 1; i < identifier.length; i++) {\r\n      if (!ts.isIdentifierPart(identifier.charCodeAt(i), ts.ScriptTarget.ES5)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Given an arbitrary input string, return a regular TypeScript identifier name.\r\n   *\r\n   * @remarks\r\n   * Example input:  \"api-extractor-lib1-test\"\r\n   * Example output: \"apiExtractorLib1Test\"\r\n   */\r\n  public static makeCamelCaseIdentifier(input: string): string {\r\n    const parts: string[] = input.split(/\\W+/).filter((x) => x.length > 0);\r\n    if (parts.length === 0) {\r\n      return '_';\r\n    }\r\n\r\n    for (let i: number = 0; i < parts.length; ++i) {\r\n      let part: string = parts[i];\r\n      if (part.toUpperCase() === part) {\r\n        // Preserve existing case unless the part is all upper-case\r\n        part = part.toLowerCase();\r\n      }\r\n      if (i === 0) {\r\n        // If the first part starts with a number, prepend \"_\"\r\n        if (/[0-9]/.test(part.charAt(0))) {\r\n          part = '_' + part;\r\n        }\r\n      } else {\r\n        // Capitalize the first letter of each part, except for the first one\r\n        part = part.charAt(0).toUpperCase() + part.slice(1);\r\n      }\r\n      parts[i] = part;\r\n    }\r\n    return parts.join('');\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/TypeScriptHelpers.js.map b/lib/analyzer/TypeScriptHelpers.js.map
index 896062548f52640bdf2c492e736f0dc1afb64eac..e0833316bf63c556aae9e48f3e459d70b4c07adf 100644
--- a/lib/analyzer/TypeScriptHelpers.js.map
+++ b/lib/analyzer/TypeScriptHelpers.js.map
@@ -1 +1 @@
-{"version":3,"file":"TypeScriptHelpers.js","sourceRoot":"","sources":["../../src/analyzer/TypeScriptHelpers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/* eslint-disable no-bitwise */\n\nimport * as ts from 'typescript';\nimport { SourceFileLocationFormatter } from './SourceFileLocationFormatter';\nimport { TypeScriptInternals } from './TypeScriptInternals';\nimport { InternalError } from '@rushstack/node-core-library';\n\nexport class TypeScriptHelpers {\n  // Matches TypeScript's encoded names for well-known ECMAScript symbols like\n  // \"__@iterator\" or \"__@toStringTag\".\n  private static readonly _wellKnownSymbolNameRegExp: RegExp = /^__@(\\w+)$/;\n\n  // Matches TypeScript's encoded names for late-bound symbols derived from `unique symbol` declarations\n  // which have the form of \"__@<variableName>@<symbolId>\", i.e. \"__@someSymbol@12345\".\n  private static readonly _uniqueSymbolNameRegExp: RegExp = /^__@.*@\\d+$/;\n\n  /**\n   * This traverses any symbol aliases to find the original place where an item was defined.\n   * For example, suppose a class is defined as \"export default class MyClass { }\"\n   * but exported from the package's index.ts like this:\n   *\n   *    export { default as _MyClass } from './MyClass';\n   *\n   * In this example, calling followAliases() on the _MyClass symbol will return the\n   * original definition of MyClass, traversing any intermediary places where the\n   * symbol was imported and re-exported.\n   */\n  public static followAliases(symbol: ts.Symbol, typeChecker: ts.TypeChecker): ts.Symbol {\n    let current: ts.Symbol = symbol;\n    for (;;) {\n      if (!(current.flags & ts.SymbolFlags.Alias)) {\n        break;\n      }\n      const currentAlias: ts.Symbol = typeChecker.getAliasedSymbol(current);\n      if (!currentAlias || currentAlias === current) {\n        break;\n      }\n      current = currentAlias;\n    }\n\n    return current;\n  }\n\n  /**\n   * Returns true if TypeScriptHelpers.followAliases() would return something different\n   * from the input `symbol`.\n   */\n  public static isFollowableAlias(symbol: ts.Symbol, typeChecker: ts.TypeChecker): boolean {\n    if (!(symbol.flags & ts.SymbolFlags.Alias)) {\n      return false;\n    }\n\n    const alias: ts.Symbol = typeChecker.getAliasedSymbol(symbol);\n    if (!alias || alias === symbol) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Certain virtual symbols do not have any declarations.  For example, `ts.TypeChecker.getExportsOfModule()` can\n   * sometimes return a \"prototype\" symbol for an object, even though there is no corresponding declaration in the\n   * source code.  API Extractor generally ignores such symbols.\n   */\n  public static tryGetADeclaration(symbol: ts.Symbol): ts.Declaration | undefined {\n    if (symbol.declarations && symbol.declarations.length > 0) {\n      return symbol.declarations[0];\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns true if the specified symbol is an ambient declaration.\n   */\n  public static isAmbient(symbol: ts.Symbol, typeChecker: ts.TypeChecker): boolean {\n    const followedSymbol: ts.Symbol = TypeScriptHelpers.followAliases(symbol, typeChecker);\n\n    if (followedSymbol.declarations && followedSymbol.declarations.length > 0) {\n      const firstDeclaration: ts.Declaration = followedSymbol.declarations[0];\n\n      // Test 1: Are we inside the sinister \"declare global {\" construct?\n      const highestModuleDeclaration: ts.ModuleDeclaration | undefined = TypeScriptHelpers.findHighestParent(\n        firstDeclaration,\n        ts.SyntaxKind.ModuleDeclaration\n      );\n      if (highestModuleDeclaration) {\n        if (highestModuleDeclaration.name.getText().trim() === 'global') {\n          return true;\n        }\n      }\n\n      // Test 2: Otherwise, the main heuristic for ambient declarations is by looking at the\n      // ts.SyntaxKind.SourceFile node to see whether it has a symbol or not (i.e. whether it\n      // is acting as a module or not).\n      const sourceFile: ts.SourceFile = firstDeclaration.getSourceFile();\n\n      if (typeChecker.getSymbolAtLocation(sourceFile)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Same semantics as tryGetSymbolForDeclaration(), but throws an exception if the symbol\n   * cannot be found.\n   */\n  public static getSymbolForDeclaration(declaration: ts.Declaration, checker: ts.TypeChecker): ts.Symbol {\n    const symbol: ts.Symbol | undefined = TypeScriptInternals.tryGetSymbolForDeclaration(\n      declaration,\n      checker\n    );\n    if (!symbol) {\n      throw new InternalError(\n        'Unable to determine semantic information for declaration:\\n' +\n          SourceFileLocationFormatter.formatDeclaration(declaration)\n      );\n    }\n    return symbol;\n  }\n\n  // Return name of the module, which could be like \"./SomeLocalFile' or like 'external-package/entry/point'\n  public static getModuleSpecifier(\n    nodeWithModuleSpecifier: ts.ImportDeclaration | ts.ExportDeclaration | ts.ImportTypeNode\n  ): string | undefined {\n    if (nodeWithModuleSpecifier.kind === ts.SyntaxKind.ImportType) {\n      // As specified internally in typescript:/src/compiler/types.ts#ValidImportTypeNode\n      if (\n        nodeWithModuleSpecifier.argument.kind !== ts.SyntaxKind.LiteralType ||\n        (nodeWithModuleSpecifier.argument as ts.LiteralTypeNode).literal.kind !== ts.SyntaxKind.StringLiteral\n      ) {\n        throw new InternalError(\n          `Invalid ImportTypeNode: ${nodeWithModuleSpecifier.getText()}\\n` +\n            SourceFileLocationFormatter.formatDeclaration(nodeWithModuleSpecifier)\n        );\n      }\n      const literalTypeNode: ts.LiteralTypeNode = nodeWithModuleSpecifier.argument as ts.LiteralTypeNode;\n      const stringLiteral: ts.StringLiteral = literalTypeNode.literal as ts.StringLiteral;\n      return stringLiteral.text.trim();\n    }\n\n    // Node is a declaration\n    if (\n      nodeWithModuleSpecifier.moduleSpecifier &&\n      ts.isStringLiteralLike(nodeWithModuleSpecifier.moduleSpecifier)\n    ) {\n      return TypeScriptInternals.getTextOfIdentifierOrLiteral(nodeWithModuleSpecifier.moduleSpecifier);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Returns an ancestor of \"node\", such that the ancestor, any intermediary nodes,\n   * and the starting node match a list of expected kinds.  Undefined is returned\n   * if there aren't enough ancestors, or if the kinds are incorrect.\n   *\n   * For example, suppose child \"C\" has parents A --> B --> C.\n   *\n   * Calling _matchAncestor(C, [ExportSpecifier, NamedExports, ExportDeclaration])\n   * would return A only if A is of kind ExportSpecifier, B is of kind NamedExports,\n   * and C is of kind ExportDeclaration.\n   *\n   * Calling _matchAncestor(C, [ExportDeclaration]) would return C.\n   */\n  public static matchAncestor<T extends ts.Node>(\n    node: ts.Node,\n    kindsToMatch: ts.SyntaxKind[]\n  ): T | undefined {\n    // (slice(0) clones an array)\n    const reversedParentKinds: ts.SyntaxKind[] = kindsToMatch.slice(0).reverse();\n\n    let current: ts.Node | undefined = undefined;\n\n    for (const parentKind of reversedParentKinds) {\n      if (!current) {\n        // The first time through, start with node\n        current = node;\n      } else {\n        // Then walk the parents\n        current = current.parent;\n      }\n\n      // If we ran out of items, or if the kind doesn't match, then fail\n      if (!current || current.kind !== parentKind) {\n        return undefined;\n      }\n    }\n\n    // If we matched everything, then return the node that matched the last parentKinds item\n    return current as T;\n  }\n\n  /**\n   * Does a depth-first search of the children of the specified node.  Returns the first child\n   * with the specified kind, or undefined if there is no match.\n   */\n  public static findFirstChildNode<T extends ts.Node>(\n    node: ts.Node,\n    kindToMatch: ts.SyntaxKind\n  ): T | undefined {\n    for (const child of node.getChildren()) {\n      if (child.kind === kindToMatch) {\n        return child as T;\n      }\n\n      const recursiveMatch: T | undefined = TypeScriptHelpers.findFirstChildNode(child, kindToMatch);\n      if (recursiveMatch) {\n        return recursiveMatch;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Returns the first parent node with the specified  SyntaxKind, or undefined if there is no match.\n   */\n  public static findFirstParent<T extends ts.Node>(node: ts.Node, kindToMatch: ts.SyntaxKind): T | undefined {\n    let current: ts.Node | undefined = node.parent;\n\n    while (current) {\n      if (current.kind === kindToMatch) {\n        return current as T;\n      }\n      current = current.parent;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Returns the highest parent node with the specified SyntaxKind, or undefined if there is no match.\n   * @remarks\n   * Whereas findFirstParent() returns the first match, findHighestParent() returns the last match.\n   */\n  public static findHighestParent<T extends ts.Node>(\n    node: ts.Node,\n    kindToMatch: ts.SyntaxKind\n  ): T | undefined {\n    let current: ts.Node | undefined = node;\n    let highest: T | undefined = undefined;\n\n    for (;;) {\n      current = TypeScriptHelpers.findFirstParent<T>(current, kindToMatch);\n      if (!current) {\n        break;\n      }\n      highest = current as T;\n    }\n\n    return highest;\n  }\n\n  /**\n   * Decodes the names that the compiler generates for a built-in ECMAScript symbol.\n   *\n   * @remarks\n   * TypeScript binds well-known ECMAScript symbols like `[Symbol.iterator]` as `__@iterator`.\n   * If `name` is of this form, then `tryGetWellKnownSymbolName()` converts it back into e.g. `[Symbol.iterator]`.\n   * If the string does not start with `__@` then `undefined` is returned.\n   */\n  public static tryDecodeWellKnownSymbolName(name: ts.__String): string | undefined {\n    const match: RegExpExecArray | null = TypeScriptHelpers._wellKnownSymbolNameRegExp.exec(name as string);\n    if (match) {\n      const identifier: string = match[1];\n      return `[Symbol.${identifier}]`;\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns whether the provided name was generated for a TypeScript `unique symbol`.\n   */\n  public static isUniqueSymbolName(name: ts.__String): boolean {\n    return TypeScriptHelpers._uniqueSymbolNameRegExp.test(name as string);\n  }\n\n  /**\n   * Derives the string representation of a TypeScript late-bound symbol.\n   */\n  public static tryGetLateBoundName(declarationName: ts.ComputedPropertyName): string | undefined {\n    // Create a node printer that ignores comments and indentation that we can use to convert\n    // declarationName to a string.\n    const printer: ts.Printer = ts.createPrinter(\n      { removeComments: true },\n      {\n        onEmitNode(\n          hint: ts.EmitHint,\n          node: ts.Node,\n          emitCallback: (hint: ts.EmitHint, node: ts.Node) => void\n        ): void {\n          ts.setEmitFlags(declarationName, ts.EmitFlags.NoIndentation | ts.EmitFlags.SingleLine);\n          emitCallback(hint, node);\n        }\n      }\n    );\n    const sourceFile: ts.SourceFile = declarationName.getSourceFile();\n    const text: string = printer.printNode(ts.EmitHint.Unspecified, declarationName, sourceFile);\n    // clean up any emit flags we've set on any nodes in the tree.\n    ts.disposeEmitNodes(sourceFile);\n    return text;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"TypeScriptHelpers.js","sourceRoot":"","sources":["../../src/analyzer/TypeScriptHelpers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* eslint-disable no-bitwise */\r\n\r\nimport * as ts from 'typescript';\r\nimport { SourceFileLocationFormatter } from './SourceFileLocationFormatter';\r\nimport { TypeScriptInternals } from './TypeScriptInternals';\r\nimport { InternalError } from '@rushstack/node-core-library';\r\n\r\nexport class TypeScriptHelpers {\r\n  // Matches TypeScript's encoded names for well-known ECMAScript symbols like\r\n  // \"__@iterator\" or \"__@toStringTag\".\r\n  private static readonly _wellKnownSymbolNameRegExp: RegExp = /^__@(\\w+)$/;\r\n\r\n  // Matches TypeScript's encoded names for late-bound symbols derived from `unique symbol` declarations\r\n  // which have the form of \"__@<variableName>@<symbolId>\", i.e. \"__@someSymbol@12345\".\r\n  private static readonly _uniqueSymbolNameRegExp: RegExp = /^__@.*@\\d+$/;\r\n\r\n  /**\r\n   * This traverses any symbol aliases to find the original place where an item was defined.\r\n   * For example, suppose a class is defined as \"export default class MyClass { }\"\r\n   * but exported from the package's index.ts like this:\r\n   *\r\n   *    export { default as _MyClass } from './MyClass';\r\n   *\r\n   * In this example, calling followAliases() on the _MyClass symbol will return the\r\n   * original definition of MyClass, traversing any intermediary places where the\r\n   * symbol was imported and re-exported.\r\n   */\r\n  public static followAliases(symbol: ts.Symbol, typeChecker: ts.TypeChecker): ts.Symbol {\r\n    let current: ts.Symbol = symbol;\r\n    for (;;) {\r\n      if (!(current.flags & ts.SymbolFlags.Alias)) {\r\n        break;\r\n      }\r\n      const currentAlias: ts.Symbol = typeChecker.getAliasedSymbol(current);\r\n      if (!currentAlias || currentAlias === current) {\r\n        break;\r\n      }\r\n      current = currentAlias;\r\n    }\r\n\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   * Returns true if TypeScriptHelpers.followAliases() would return something different\r\n   * from the input `symbol`.\r\n   */\r\n  public static isFollowableAlias(symbol: ts.Symbol, typeChecker: ts.TypeChecker): boolean {\r\n    if (!(symbol.flags & ts.SymbolFlags.Alias)) {\r\n      return false;\r\n    }\r\n\r\n    const alias: ts.Symbol = typeChecker.getAliasedSymbol(symbol);\r\n    if (!alias || alias === symbol) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Certain virtual symbols do not have any declarations.  For example, `ts.TypeChecker.getExportsOfModule()` can\r\n   * sometimes return a \"prototype\" symbol for an object, even though there is no corresponding declaration in the\r\n   * source code.  API Extractor generally ignores such symbols.\r\n   */\r\n  public static tryGetADeclaration(symbol: ts.Symbol): ts.Declaration | undefined {\r\n    if (symbol.declarations && symbol.declarations.length > 0) {\r\n      return symbol.declarations[0];\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the specified symbol is an ambient declaration.\r\n   */\r\n  public static isAmbient(symbol: ts.Symbol, typeChecker: ts.TypeChecker): boolean {\r\n    const followedSymbol: ts.Symbol = TypeScriptHelpers.followAliases(symbol, typeChecker);\r\n\r\n    if (followedSymbol.declarations && followedSymbol.declarations.length > 0) {\r\n      const firstDeclaration: ts.Declaration = followedSymbol.declarations[0];\r\n\r\n      // Test 1: Are we inside the sinister \"declare global {\" construct?\r\n      const highestModuleDeclaration: ts.ModuleDeclaration | undefined = TypeScriptHelpers.findHighestParent(\r\n        firstDeclaration,\r\n        ts.SyntaxKind.ModuleDeclaration\r\n      );\r\n      if (highestModuleDeclaration) {\r\n        if (highestModuleDeclaration.name.getText().trim() === 'global') {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      // Test 2: Otherwise, the main heuristic for ambient declarations is by looking at the\r\n      // ts.SyntaxKind.SourceFile node to see whether it has a symbol or not (i.e. whether it\r\n      // is acting as a module or not).\r\n      const sourceFile: ts.SourceFile = firstDeclaration.getSourceFile();\r\n\r\n      if (typeChecker.getSymbolAtLocation(sourceFile)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Same semantics as tryGetSymbolForDeclaration(), but throws an exception if the symbol\r\n   * cannot be found.\r\n   */\r\n  public static getSymbolForDeclaration(declaration: ts.Declaration, checker: ts.TypeChecker): ts.Symbol {\r\n    const symbol: ts.Symbol | undefined = TypeScriptInternals.tryGetSymbolForDeclaration(\r\n      declaration,\r\n      checker\r\n    );\r\n    if (!symbol) {\r\n      throw new InternalError(\r\n        'Unable to determine semantic information for declaration:\\n' +\r\n          SourceFileLocationFormatter.formatDeclaration(declaration)\r\n      );\r\n    }\r\n    return symbol;\r\n  }\r\n\r\n  // Return name of the module, which could be like \"./SomeLocalFile' or like 'external-package/entry/point'\r\n  public static getModuleSpecifier(\r\n    nodeWithModuleSpecifier: ts.ImportDeclaration | ts.ExportDeclaration | ts.ImportTypeNode\r\n  ): string | undefined {\r\n    if (nodeWithModuleSpecifier.kind === ts.SyntaxKind.ImportType) {\r\n      // As specified internally in typescript:/src/compiler/types.ts#ValidImportTypeNode\r\n      if (\r\n        nodeWithModuleSpecifier.argument.kind !== ts.SyntaxKind.LiteralType ||\r\n        (nodeWithModuleSpecifier.argument as ts.LiteralTypeNode).literal.kind !== ts.SyntaxKind.StringLiteral\r\n      ) {\r\n        throw new InternalError(\r\n          `Invalid ImportTypeNode: ${nodeWithModuleSpecifier.getText()}\\n` +\r\n            SourceFileLocationFormatter.formatDeclaration(nodeWithModuleSpecifier)\r\n        );\r\n      }\r\n      const literalTypeNode: ts.LiteralTypeNode = nodeWithModuleSpecifier.argument as ts.LiteralTypeNode;\r\n      const stringLiteral: ts.StringLiteral = literalTypeNode.literal as ts.StringLiteral;\r\n      return stringLiteral.text.trim();\r\n    }\r\n\r\n    // Node is a declaration\r\n    if (\r\n      nodeWithModuleSpecifier.moduleSpecifier &&\r\n      ts.isStringLiteralLike(nodeWithModuleSpecifier.moduleSpecifier)\r\n    ) {\r\n      return TypeScriptInternals.getTextOfIdentifierOrLiteral(nodeWithModuleSpecifier.moduleSpecifier);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns an ancestor of \"node\", such that the ancestor, any intermediary nodes,\r\n   * and the starting node match a list of expected kinds.  Undefined is returned\r\n   * if there aren't enough ancestors, or if the kinds are incorrect.\r\n   *\r\n   * For example, suppose child \"C\" has parents A --> B --> C.\r\n   *\r\n   * Calling _matchAncestor(C, [ExportSpecifier, NamedExports, ExportDeclaration])\r\n   * would return A only if A is of kind ExportSpecifier, B is of kind NamedExports,\r\n   * and C is of kind ExportDeclaration.\r\n   *\r\n   * Calling _matchAncestor(C, [ExportDeclaration]) would return C.\r\n   */\r\n  public static matchAncestor<T extends ts.Node>(\r\n    node: ts.Node,\r\n    kindsToMatch: ts.SyntaxKind[]\r\n  ): T | undefined {\r\n    // (slice(0) clones an array)\r\n    const reversedParentKinds: ts.SyntaxKind[] = kindsToMatch.slice(0).reverse();\r\n\r\n    let current: ts.Node | undefined = undefined;\r\n\r\n    for (const parentKind of reversedParentKinds) {\r\n      if (!current) {\r\n        // The first time through, start with node\r\n        current = node;\r\n      } else {\r\n        // Then walk the parents\r\n        current = current.parent;\r\n      }\r\n\r\n      // If we ran out of items, or if the kind doesn't match, then fail\r\n      if (!current || current.kind !== parentKind) {\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    // If we matched everything, then return the node that matched the last parentKinds item\r\n    return current as T;\r\n  }\r\n\r\n  /**\r\n   * Does a depth-first search of the children of the specified node.  Returns the first child\r\n   * with the specified kind, or undefined if there is no match.\r\n   */\r\n  public static findFirstChildNode<T extends ts.Node>(\r\n    node: ts.Node,\r\n    kindToMatch: ts.SyntaxKind\r\n  ): T | undefined {\r\n    for (const child of node.getChildren()) {\r\n      if (child.kind === kindToMatch) {\r\n        return child as T;\r\n      }\r\n\r\n      const recursiveMatch: T | undefined = TypeScriptHelpers.findFirstChildNode(child, kindToMatch);\r\n      if (recursiveMatch) {\r\n        return recursiveMatch;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the first parent node with the specified  SyntaxKind, or undefined if there is no match.\r\n   */\r\n  public static findFirstParent<T extends ts.Node>(node: ts.Node, kindToMatch: ts.SyntaxKind): T | undefined {\r\n    let current: ts.Node | undefined = node.parent;\r\n\r\n    while (current) {\r\n      if (current.kind === kindToMatch) {\r\n        return current as T;\r\n      }\r\n      current = current.parent;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the highest parent node with the specified SyntaxKind, or undefined if there is no match.\r\n   * @remarks\r\n   * Whereas findFirstParent() returns the first match, findHighestParent() returns the last match.\r\n   */\r\n  public static findHighestParent<T extends ts.Node>(\r\n    node: ts.Node,\r\n    kindToMatch: ts.SyntaxKind\r\n  ): T | undefined {\r\n    let current: ts.Node | undefined = node;\r\n    let highest: T | undefined = undefined;\r\n\r\n    for (;;) {\r\n      current = TypeScriptHelpers.findFirstParent<T>(current, kindToMatch);\r\n      if (!current) {\r\n        break;\r\n      }\r\n      highest = current as T;\r\n    }\r\n\r\n    return highest;\r\n  }\r\n\r\n  /**\r\n   * Decodes the names that the compiler generates for a built-in ECMAScript symbol.\r\n   *\r\n   * @remarks\r\n   * TypeScript binds well-known ECMAScript symbols like `[Symbol.iterator]` as `__@iterator`.\r\n   * If `name` is of this form, then `tryGetWellKnownSymbolName()` converts it back into e.g. `[Symbol.iterator]`.\r\n   * If the string does not start with `__@` then `undefined` is returned.\r\n   */\r\n  public static tryDecodeWellKnownSymbolName(name: ts.__String): string | undefined {\r\n    const match: RegExpExecArray | null = TypeScriptHelpers._wellKnownSymbolNameRegExp.exec(name as string);\r\n    if (match) {\r\n      const identifier: string = match[1];\r\n      return `[Symbol.${identifier}]`;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the provided name was generated for a TypeScript `unique symbol`.\r\n   */\r\n  public static isUniqueSymbolName(name: ts.__String): boolean {\r\n    return TypeScriptHelpers._uniqueSymbolNameRegExp.test(name as string);\r\n  }\r\n\r\n  /**\r\n   * Derives the string representation of a TypeScript late-bound symbol.\r\n   */\r\n  public static tryGetLateBoundName(declarationName: ts.ComputedPropertyName): string | undefined {\r\n    // Create a node printer that ignores comments and indentation that we can use to convert\r\n    // declarationName to a string.\r\n    const printer: ts.Printer = ts.createPrinter(\r\n      { removeComments: true },\r\n      {\r\n        onEmitNode(\r\n          hint: ts.EmitHint,\r\n          node: ts.Node,\r\n          emitCallback: (hint: ts.EmitHint, node: ts.Node) => void\r\n        ): void {\r\n          ts.setEmitFlags(declarationName, ts.EmitFlags.NoIndentation | ts.EmitFlags.SingleLine);\r\n          emitCallback(hint, node);\r\n        }\r\n      }\r\n    );\r\n    const sourceFile: ts.SourceFile = declarationName.getSourceFile();\r\n    const text: string = printer.printNode(ts.EmitHint.Unspecified, declarationName, sourceFile);\r\n    // clean up any emit flags we've set on any nodes in the tree.\r\n    ts.disposeEmitNodes(sourceFile);\r\n    return text;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/TypeScriptInternals.js.map b/lib/analyzer/TypeScriptInternals.js.map
index cd5e8dfddeef65ecf19e0b8104b945a200f4a564..f4b67367b83aff4c9913f585be72c94c6fe13436 100644
--- a/lib/analyzer/TypeScriptInternals.js.map
+++ b/lib/analyzer/TypeScriptInternals.js.map
@@ -1 +1 @@
-{"version":3,"file":"TypeScriptInternals.js","sourceRoot":"","sources":["../../src/analyzer/TypeScriptInternals.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport * as ts from 'typescript';\nimport { InternalError } from '@rushstack/node-core-library';\n\n/**\n * Exposes the TypeScript compiler internals for detecting global variable names.\n */\nexport interface IGlobalVariableAnalyzer {\n  hasGlobalName(name: string): boolean;\n}\n\nexport class TypeScriptInternals {\n  public static getImmediateAliasedSymbol(symbol: ts.Symbol, typeChecker: ts.TypeChecker): ts.Symbol {\n    // Compiler internal:\n    // https://github.com/microsoft/TypeScript/blob/v3.2.2/src/compiler/checker.ts\n    return (typeChecker as any).getImmediateAliasedSymbol(symbol); // eslint-disable-line @typescript-eslint/no-explicit-any\n  }\n\n  /**\n   * Returns the Symbol for the provided Declaration.  This is a workaround for a missing\n   * feature of the TypeScript Compiler API.   It is the only apparent way to reach\n   * certain data structures, and seems to always work, but is not officially documented.\n   *\n   * @returns The associated Symbol.  If there is no semantic information (e.g. if the\n   * declaration is an extra semicolon somewhere), then \"undefined\" is returned.\n   */\n  public static tryGetSymbolForDeclaration(\n    declaration: ts.Declaration,\n    checker: ts.TypeChecker\n  ): ts.Symbol | undefined {\n    let symbol: ts.Symbol | undefined = (declaration as any).symbol;\n    if (symbol && symbol.escapedName === ts.InternalSymbolName.Computed) {\n      const name: ts.DeclarationName | undefined = ts.getNameOfDeclaration(declaration);\n      symbol = (name && checker.getSymbolAtLocation(name)) || symbol;\n    }\n    return symbol;\n  }\n\n  /**\n   * Returns whether the provided Symbol is a TypeScript \"late-bound\" Symbol (i.e. was created by the Checker\n   * for a computed property based on its type, rather than by the Binder).\n   */\n  public static isLateBoundSymbol(symbol: ts.Symbol): boolean {\n    if (\n      // eslint-disable-next-line no-bitwise\n      symbol.flags & ts.SymbolFlags.Transient &&\n      (ts as any).getCheckFlags(symbol) === (ts as any).CheckFlags.Late\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Retrieves the comment ranges associated with the specified node.\n   */\n  public static getJSDocCommentRanges(node: ts.Node, text: string): ts.CommentRange[] | undefined {\n    // Compiler internal:\n    // https://github.com/microsoft/TypeScript/blob/v2.4.2/src/compiler/utilities.ts#L616\n\n    return (ts as any).getJSDocCommentRanges.apply(this, arguments);\n  }\n\n  /**\n   * Retrieves the (unescaped) value of an string literal, numeric literal, or identifier.\n   */\n  public static getTextOfIdentifierOrLiteral(\n    node: ts.Identifier | ts.StringLiteralLike | ts.NumericLiteral\n  ): string {\n    // Compiler internal:\n    // https://github.com/microsoft/TypeScript/blob/v3.2.2/src/compiler/utilities.ts#L2721\n\n    return (ts as any).getTextOfIdentifierOrLiteral(node);\n  }\n\n  /**\n   * Retrieves the (cached) module resolution information for a module name that was exported from a SourceFile.\n   * The compiler populates this cache as part of analyzing the source file.\n   */\n  public static getResolvedModule(\n    sourceFile: ts.SourceFile,\n    moduleNameText: string,\n    mode: ts.ModuleKind.CommonJS | ts.ModuleKind.ESNext | undefined\n  ): ts.ResolvedModuleFull | undefined {\n    // Compiler internal:\n    // https://github.com/microsoft/TypeScript/blob/v4.7.2/src/compiler/utilities.ts#L161\n\n    return (ts as any).getResolvedModule(sourceFile, moduleNameText, mode);\n  }\n\n  /**\n   * Gets the mode required for module resolution required with the addition of Node16/nodenext\n   */\n  public static getModeForUsageLocation(\n    file: { impliedNodeFormat?: ts.SourceFile['impliedNodeFormat'] },\n    usage: ts.StringLiteralLike | undefined\n  ): ts.ModuleKind.CommonJS | ts.ModuleKind.ESNext | undefined {\n    // Compiler internal:\n    // https://github.com/microsoft/TypeScript/blob/v4.7.2/src/compiler/program.ts#L568\n\n    return (ts as any).getModeForUsageLocation?.(file, usage);\n  }\n\n  /**\n   * Returns ts.Symbol.parent if it exists.\n   */\n  public static getSymbolParent(symbol: ts.Symbol): ts.Symbol | undefined {\n    return (symbol as any).parent;\n  }\n\n  /**\n   * In an statement like `export default class X { }`, the `Symbol.name` will be `default`\n   * whereas the `localSymbol` is `X`.\n   */\n  public static tryGetLocalSymbol(declaration: ts.Declaration): ts.Symbol | undefined {\n    return (declaration as any).localSymbol;\n  }\n\n  public static getGlobalVariableAnalyzer(program: ts.Program): IGlobalVariableAnalyzer {\n    const anyProgram: any = program;\n    const typeCheckerInstance: any =\n      anyProgram.getDiagnosticsProducingTypeChecker ?? anyProgram.getTypeChecker;\n\n    if (!typeCheckerInstance) {\n      throw new InternalError('Missing Program.getDiagnosticsProducingTypeChecker or Program.getTypeChecker');\n    }\n    const typeChecker: any = typeCheckerInstance();\n    if (!typeChecker.getEmitResolver) {\n      throw new InternalError('Missing TypeChecker.getEmitResolver');\n    }\n    const resolver: any = typeChecker.getEmitResolver();\n    if (!resolver.hasGlobalName) {\n      throw new InternalError('Missing EmitResolver.hasGlobalName');\n    }\n    return resolver;\n  }\n\n  /**\n   * Returns whether a variable is declared with the const keyword\n   */\n  public static isVarConst(node: ts.VariableDeclaration | ts.VariableDeclarationList): boolean {\n    // Compiler internal: https://github.com/microsoft/TypeScript/blob/71286e3d49c10e0e99faac360a6bbd40f12db7b6/src/compiler/utilities.ts#L925\n    return (ts as any).isVarConst(node);\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"TypeScriptInternals.js","sourceRoot":"","sources":["../../src/analyzer/TypeScriptInternals.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\r\nimport * as ts from 'typescript';\r\nimport { InternalError } from '@rushstack/node-core-library';\r\n\r\n/**\r\n * Exposes the TypeScript compiler internals for detecting global variable names.\r\n */\r\nexport interface IGlobalVariableAnalyzer {\r\n  hasGlobalName(name: string): boolean;\r\n}\r\n\r\nexport class TypeScriptInternals {\r\n  public static getImmediateAliasedSymbol(symbol: ts.Symbol, typeChecker: ts.TypeChecker): ts.Symbol {\r\n    // Compiler internal:\r\n    // https://github.com/microsoft/TypeScript/blob/v3.2.2/src/compiler/checker.ts\r\n    return (typeChecker as any).getImmediateAliasedSymbol(symbol); // eslint-disable-line @typescript-eslint/no-explicit-any\r\n  }\r\n\r\n  /**\r\n   * Returns the Symbol for the provided Declaration.  This is a workaround for a missing\r\n   * feature of the TypeScript Compiler API.   It is the only apparent way to reach\r\n   * certain data structures, and seems to always work, but is not officially documented.\r\n   *\r\n   * @returns The associated Symbol.  If there is no semantic information (e.g. if the\r\n   * declaration is an extra semicolon somewhere), then \"undefined\" is returned.\r\n   */\r\n  public static tryGetSymbolForDeclaration(\r\n    declaration: ts.Declaration,\r\n    checker: ts.TypeChecker\r\n  ): ts.Symbol | undefined {\r\n    let symbol: ts.Symbol | undefined = (declaration as any).symbol;\r\n    if (symbol && symbol.escapedName === ts.InternalSymbolName.Computed) {\r\n      const name: ts.DeclarationName | undefined = ts.getNameOfDeclaration(declaration);\r\n      symbol = (name && checker.getSymbolAtLocation(name)) || symbol;\r\n    }\r\n    return symbol;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the provided Symbol is a TypeScript \"late-bound\" Symbol (i.e. was created by the Checker\r\n   * for a computed property based on its type, rather than by the Binder).\r\n   */\r\n  public static isLateBoundSymbol(symbol: ts.Symbol): boolean {\r\n    if (\r\n      // eslint-disable-next-line no-bitwise\r\n      symbol.flags & ts.SymbolFlags.Transient &&\r\n      (ts as any).getCheckFlags(symbol) === (ts as any).CheckFlags.Late\r\n    ) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the comment ranges associated with the specified node.\r\n   */\r\n  public static getJSDocCommentRanges(node: ts.Node, text: string): ts.CommentRange[] | undefined {\r\n    // Compiler internal:\r\n    // https://github.com/microsoft/TypeScript/blob/v2.4.2/src/compiler/utilities.ts#L616\r\n\r\n    return (ts as any).getJSDocCommentRanges.apply(this, arguments);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the (unescaped) value of an string literal, numeric literal, or identifier.\r\n   */\r\n  public static getTextOfIdentifierOrLiteral(\r\n    node: ts.Identifier | ts.StringLiteralLike | ts.NumericLiteral\r\n  ): string {\r\n    // Compiler internal:\r\n    // https://github.com/microsoft/TypeScript/blob/v3.2.2/src/compiler/utilities.ts#L2721\r\n\r\n    return (ts as any).getTextOfIdentifierOrLiteral(node);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the (cached) module resolution information for a module name that was exported from a SourceFile.\r\n   * The compiler populates this cache as part of analyzing the source file.\r\n   */\r\n  public static getResolvedModule(\r\n    sourceFile: ts.SourceFile,\r\n    moduleNameText: string,\r\n    mode: ts.ModuleKind.CommonJS | ts.ModuleKind.ESNext | undefined\r\n  ): ts.ResolvedModuleFull | undefined {\r\n    // Compiler internal:\r\n    // https://github.com/microsoft/TypeScript/blob/v4.7.2/src/compiler/utilities.ts#L161\r\n\r\n    return (ts as any).getResolvedModule(sourceFile, moduleNameText, mode);\r\n  }\r\n\r\n  /**\r\n   * Gets the mode required for module resolution required with the addition of Node16/nodenext\r\n   */\r\n  public static getModeForUsageLocation(\r\n    file: { impliedNodeFormat?: ts.SourceFile['impliedNodeFormat'] },\r\n    usage: ts.StringLiteralLike | undefined\r\n  ): ts.ModuleKind.CommonJS | ts.ModuleKind.ESNext | undefined {\r\n    // Compiler internal:\r\n    // https://github.com/microsoft/TypeScript/blob/v4.7.2/src/compiler/program.ts#L568\r\n\r\n    return (ts as any).getModeForUsageLocation?.(file, usage);\r\n  }\r\n\r\n  /**\r\n   * Returns ts.Symbol.parent if it exists.\r\n   */\r\n  public static getSymbolParent(symbol: ts.Symbol): ts.Symbol | undefined {\r\n    return (symbol as any).parent;\r\n  }\r\n\r\n  /**\r\n   * In an statement like `export default class X { }`, the `Symbol.name` will be `default`\r\n   * whereas the `localSymbol` is `X`.\r\n   */\r\n  public static tryGetLocalSymbol(declaration: ts.Declaration): ts.Symbol | undefined {\r\n    return (declaration as any).localSymbol;\r\n  }\r\n\r\n  public static getGlobalVariableAnalyzer(program: ts.Program): IGlobalVariableAnalyzer {\r\n    const anyProgram: any = program;\r\n    const typeCheckerInstance: any =\r\n      anyProgram.getDiagnosticsProducingTypeChecker ?? anyProgram.getTypeChecker;\r\n\r\n    if (!typeCheckerInstance) {\r\n      throw new InternalError('Missing Program.getDiagnosticsProducingTypeChecker or Program.getTypeChecker');\r\n    }\r\n    const typeChecker: any = typeCheckerInstance();\r\n    if (!typeChecker.getEmitResolver) {\r\n      throw new InternalError('Missing TypeChecker.getEmitResolver');\r\n    }\r\n    const resolver: any = typeChecker.getEmitResolver();\r\n    if (!resolver.hasGlobalName) {\r\n      throw new InternalError('Missing EmitResolver.hasGlobalName');\r\n    }\r\n    return resolver;\r\n  }\r\n\r\n  /**\r\n   * Returns whether a variable is declared with the const keyword\r\n   */\r\n  public static isVarConst(node: ts.VariableDeclaration | ts.VariableDeclarationList): boolean {\r\n    // Compiler internal: https://github.com/microsoft/TypeScript/blob/71286e3d49c10e0e99faac360a6bbd40f12db7b6/src/compiler/utilities.ts#L925\r\n    return (ts as any).isVarConst(node);\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/test/PackageMetadataManager.test.d.ts b/lib/analyzer/test/PackageMetadataManager.test.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a4e3e52e3804775898acb9e9f2f1b7f19178e38f
--- /dev/null
+++ b/lib/analyzer/test/PackageMetadataManager.test.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=PackageMetadataManager.test.d.ts.map
\ No newline at end of file
diff --git a/lib/analyzer/test/PackageMetadataManager.test.d.ts.map b/lib/analyzer/test/PackageMetadataManager.test.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..efa3f72c32e97de0db5f0e602fbc298391c25b9c
--- /dev/null
+++ b/lib/analyzer/test/PackageMetadataManager.test.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"PackageMetadataManager.test.d.ts","sourceRoot":"","sources":["../../../src/analyzer/test/PackageMetadataManager.test.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/lib/analyzer/test/PackageMetadataManager.test.js b/lib/analyzer/test/PackageMetadataManager.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..0076ef197f2ac132f98187d28be156afbdedfeab
--- /dev/null
+++ b/lib/analyzer/test/PackageMetadataManager.test.js
@@ -0,0 +1,124 @@
+"use strict";
+// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
+// See LICENSE in the project root for license information.
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const path = __importStar(require("path"));
+const PackageMetadataManager_1 = require("../PackageMetadataManager");
+const node_core_library_1 = require("@rushstack/node-core-library");
+const packageJsonLookup = new node_core_library_1.PackageJsonLookup();
+function resolveInTestPackage(testPackageName, ...args) {
+    return path.resolve(__dirname, 'test-data/tsdoc-metadata-path-inference', testPackageName, ...args);
+}
+function getPackageMetadata(testPackageName) {
+    const packageFolder = resolveInTestPackage(testPackageName);
+    const packageJson = packageJsonLookup.tryLoadPackageJsonFor(packageFolder);
+    if (!packageJson) {
+        throw new Error('There should be a package.json file in the test package');
+    }
+    return { packageFolder, packageJson };
+}
+// eslint-disable-next-line @typescript-eslint/no-explicit-any
+function firstArgument(mockFn) {
+    return mockFn.mock.calls[0][0];
+}
+/* eslint-disable @typescript-eslint/typedef */
+describe(PackageMetadataManager_1.PackageMetadataManager.name, () => {
+    describe(PackageMetadataManager_1.PackageMetadataManager.writeTsdocMetadataFile.name, () => {
+        const originalWriteFile = node_core_library_1.FileSystem.writeFile;
+        const mockWriteFile = jest.fn();
+        beforeAll(() => {
+            node_core_library_1.FileSystem.writeFile = mockWriteFile;
+        });
+        afterEach(() => {
+            mockWriteFile.mockClear();
+        });
+        afterAll(() => {
+            node_core_library_1.FileSystem.writeFile = originalWriteFile;
+        });
+        it('writes the tsdoc metadata file at the provided path', () => {
+            PackageMetadataManager_1.PackageMetadataManager.writeTsdocMetadataFile('/foo/bar', node_core_library_1.NewlineKind.CrLf);
+            expect(firstArgument(mockWriteFile)).toBe('/foo/bar');
+        });
+    });
+    describe(PackageMetadataManager_1.PackageMetadataManager.resolveTsdocMetadataPath.name, () => {
+        describe('when an empty tsdocMetadataPath is provided', () => {
+            const tsdocMetadataPath = '';
+            describe('given a package.json where the field "tsdocMetadata" is defined', () => {
+                it('outputs the tsdoc metadata path as given by "tsdocMetadata" relative to the folder of package.json', () => {
+                    const { packageFolder, packageJson } = getPackageMetadata('package-inferred-from-tsdoc-metadata');
+                    expect(PackageMetadataManager_1.PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)).toBe(path.resolve(packageFolder, packageJson.tsdocMetadata));
+                });
+            });
+            describe('given a package.json where the field "typings" is defined and "tsdocMetadata" is not defined', () => {
+                it('outputs the tsdoc metadata file "tsdoc-metadata.json" in the same folder as the path of "typings"', () => {
+                    const { packageFolder, packageJson } = getPackageMetadata('package-inferred-from-typings');
+                    expect(PackageMetadataManager_1.PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)).toBe(path.resolve(packageFolder, path.dirname(packageJson.typings), 'tsdoc-metadata.json'));
+                });
+            });
+            describe('given a package.json where the field "main" is defined but not "typings" nor "tsdocMetadata"', () => {
+                it('outputs the tsdoc metadata file "tsdoc-metadata.json" in the same folder as the path of "main"', () => {
+                    const { packageFolder, packageJson } = getPackageMetadata('package-inferred-from-main');
+                    expect(PackageMetadataManager_1.PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)).toBe(path.resolve(packageFolder, path.dirname(packageJson.main), 'tsdoc-metadata.json'));
+                });
+            });
+            describe('given a package.json where the fields "main", "typings" and "tsdocMetadata" are not defined', () => {
+                it('outputs the tsdoc metadata file "tsdoc-metadata.json" in the folder where package.json is located', () => {
+                    const { packageFolder, packageJson } = getPackageMetadata('package-default');
+                    expect(PackageMetadataManager_1.PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)).toBe(path.resolve(packageFolder, 'tsdoc-metadata.json'));
+                });
+            });
+        });
+        describe('when a non-empty tsdocMetadataPath is provided', () => {
+            const tsdocMetadataPath = 'path/to/custom-tsdoc-metadata.json';
+            describe('given a package.json where the field "tsdocMetadata" is defined', () => {
+                it('outputs the tsdoc metadata file at the provided path in the folder where package.json is located', () => {
+                    const { packageFolder, packageJson } = getPackageMetadata('package-inferred-from-tsdocMetadata');
+                    expect(PackageMetadataManager_1.PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)).toBe(path.resolve(packageFolder, tsdocMetadataPath));
+                });
+            });
+            describe('given a package.json where the field "typings" is defined and "tsdocMetadata" is not defined', () => {
+                it('outputs the tsdoc metadata file at the provided path in the folder where package.json is located', () => {
+                    const { packageFolder, packageJson } = getPackageMetadata('package-inferred-from-typings');
+                    expect(PackageMetadataManager_1.PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)).toBe(path.resolve(packageFolder, tsdocMetadataPath));
+                });
+            });
+            describe('given a package.json where the field "main" is defined but not "typings" nor "tsdocMetadata"', () => {
+                it('outputs the tsdoc metadata file at the provided path in the folder where package.json is located', () => {
+                    const { packageFolder, packageJson } = getPackageMetadata('package-inferred-from-main');
+                    expect(PackageMetadataManager_1.PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)).toBe(path.resolve(packageFolder, tsdocMetadataPath));
+                });
+            });
+            describe('given a package.json where the fields "main", "typings" and "tsdocMetadata" are not defined', () => {
+                it('outputs the tsdoc metadata file at the provided path in the folder where package.json is located', () => {
+                    const { packageFolder, packageJson } = getPackageMetadata('package-default');
+                    expect(PackageMetadataManager_1.PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)).toBe(path.resolve(packageFolder, tsdocMetadataPath));
+                });
+            });
+        });
+    });
+});
+/* eslint-enable @typescript-eslint/typedef */
+//# sourceMappingURL=PackageMetadataManager.test.js.map
\ No newline at end of file
diff --git a/lib/analyzer/test/PackageMetadataManager.test.js.map b/lib/analyzer/test/PackageMetadataManager.test.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..5ffde518a96cc7acdeeaf1e2e049edb429d5a919
--- /dev/null
+++ b/lib/analyzer/test/PackageMetadataManager.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"PackageMetadataManager.test.js","sourceRoot":"","sources":["../../../src/analyzer/test/PackageMetadataManager.test.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport { PackageMetadataManager } from '../PackageMetadataManager';\r\nimport {\r\n  FileSystem,\r\n  PackageJsonLookup,\r\n  type INodePackageJson,\r\n  NewlineKind\r\n} from '@rushstack/node-core-library';\r\n\r\nconst packageJsonLookup: PackageJsonLookup = new PackageJsonLookup();\r\n\r\nfunction resolveInTestPackage(testPackageName: string, ...args: string[]): string {\r\n  return path.resolve(__dirname, 'test-data/tsdoc-metadata-path-inference', testPackageName, ...args);\r\n}\r\n\r\nfunction getPackageMetadata(testPackageName: string): {\r\n  packageFolder: string;\r\n  packageJson: INodePackageJson;\r\n} {\r\n  const packageFolder: string = resolveInTestPackage(testPackageName);\r\n  const packageJson: INodePackageJson | undefined = packageJsonLookup.tryLoadPackageJsonFor(packageFolder);\r\n  if (!packageJson) {\r\n    throw new Error('There should be a package.json file in the test package');\r\n  }\r\n  return { packageFolder, packageJson };\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction firstArgument(mockFn: jest.Mock): any {\r\n  return mockFn.mock.calls[0][0];\r\n}\r\n\r\n/* eslint-disable @typescript-eslint/typedef */\r\n\r\ndescribe(PackageMetadataManager.name, () => {\r\n  describe(PackageMetadataManager.writeTsdocMetadataFile.name, () => {\r\n    const originalWriteFile = FileSystem.writeFile;\r\n    const mockWriteFile: jest.Mock = jest.fn();\r\n    beforeAll(() => {\r\n      FileSystem.writeFile = mockWriteFile;\r\n    });\r\n    afterEach(() => {\r\n      mockWriteFile.mockClear();\r\n    });\r\n    afterAll(() => {\r\n      FileSystem.writeFile = originalWriteFile;\r\n    });\r\n\r\n    it('writes the tsdoc metadata file at the provided path', () => {\r\n      PackageMetadataManager.writeTsdocMetadataFile('/foo/bar', NewlineKind.CrLf);\r\n      expect(firstArgument(mockWriteFile)).toBe('/foo/bar');\r\n    });\r\n  });\r\n\r\n  describe(PackageMetadataManager.resolveTsdocMetadataPath.name, () => {\r\n    describe('when an empty tsdocMetadataPath is provided', () => {\r\n      const tsdocMetadataPath: string = '';\r\n      describe('given a package.json where the field \"tsdocMetadata\" is defined', () => {\r\n        it('outputs the tsdoc metadata path as given by \"tsdocMetadata\" relative to the folder of package.json', () => {\r\n          const { packageFolder, packageJson } = getPackageMetadata('package-inferred-from-tsdoc-metadata');\r\n          expect(\r\n            PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)\r\n          ).toBe(path.resolve(packageFolder, packageJson.tsdocMetadata as string));\r\n        });\r\n      });\r\n      describe('given a package.json where the field \"typings\" is defined and \"tsdocMetadata\" is not defined', () => {\r\n        it('outputs the tsdoc metadata file \"tsdoc-metadata.json\" in the same folder as the path of \"typings\"', () => {\r\n          const { packageFolder, packageJson } = getPackageMetadata('package-inferred-from-typings');\r\n          expect(\r\n            PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)\r\n          ).toBe(path.resolve(packageFolder, path.dirname(packageJson.typings!), 'tsdoc-metadata.json'));\r\n        });\r\n      });\r\n      describe('given a package.json where the field \"main\" is defined but not \"typings\" nor \"tsdocMetadata\"', () => {\r\n        it('outputs the tsdoc metadata file \"tsdoc-metadata.json\" in the same folder as the path of \"main\"', () => {\r\n          const { packageFolder, packageJson } = getPackageMetadata('package-inferred-from-main');\r\n          expect(\r\n            PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)\r\n          ).toBe(path.resolve(packageFolder, path.dirname(packageJson.main!), 'tsdoc-metadata.json'));\r\n        });\r\n      });\r\n      describe('given a package.json where the fields \"main\", \"typings\" and \"tsdocMetadata\" are not defined', () => {\r\n        it('outputs the tsdoc metadata file \"tsdoc-metadata.json\" in the folder where package.json is located', () => {\r\n          const { packageFolder, packageJson } = getPackageMetadata('package-default');\r\n          expect(\r\n            PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)\r\n          ).toBe(path.resolve(packageFolder, 'tsdoc-metadata.json'));\r\n        });\r\n      });\r\n    });\r\n    describe('when a non-empty tsdocMetadataPath is provided', () => {\r\n      const tsdocMetadataPath: string = 'path/to/custom-tsdoc-metadata.json';\r\n      describe('given a package.json where the field \"tsdocMetadata\" is defined', () => {\r\n        it('outputs the tsdoc metadata file at the provided path in the folder where package.json is located', () => {\r\n          const { packageFolder, packageJson } = getPackageMetadata('package-inferred-from-tsdocMetadata');\r\n          expect(\r\n            PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)\r\n          ).toBe(path.resolve(packageFolder, tsdocMetadataPath));\r\n        });\r\n      });\r\n      describe('given a package.json where the field \"typings\" is defined and \"tsdocMetadata\" is not defined', () => {\r\n        it('outputs the tsdoc metadata file at the provided path in the folder where package.json is located', () => {\r\n          const { packageFolder, packageJson } = getPackageMetadata('package-inferred-from-typings');\r\n          expect(\r\n            PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)\r\n          ).toBe(path.resolve(packageFolder, tsdocMetadataPath));\r\n        });\r\n      });\r\n      describe('given a package.json where the field \"main\" is defined but not \"typings\" nor \"tsdocMetadata\"', () => {\r\n        it('outputs the tsdoc metadata file at the provided path in the folder where package.json is located', () => {\r\n          const { packageFolder, packageJson } = getPackageMetadata('package-inferred-from-main');\r\n          expect(\r\n            PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)\r\n          ).toBe(path.resolve(packageFolder, tsdocMetadataPath));\r\n        });\r\n      });\r\n      describe('given a package.json where the fields \"main\", \"typings\" and \"tsdocMetadata\" are not defined', () => {\r\n        it('outputs the tsdoc metadata file at the provided path in the folder where package.json is located', () => {\r\n          const { packageFolder, packageJson } = getPackageMetadata('package-default');\r\n          expect(\r\n            PackageMetadataManager.resolveTsdocMetadataPath(packageFolder, packageJson, tsdocMetadataPath)\r\n          ).toBe(path.resolve(packageFolder, tsdocMetadataPath));\r\n        });\r\n      });\r\n    });\r\n  });\r\n});\r\n\r\n/* eslint-enable @typescript-eslint/typedef */\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/test/SyntaxHelpers.test.d.ts b/lib/analyzer/test/SyntaxHelpers.test.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0851c478546da565039d854d527511e1557c80c7
--- /dev/null
+++ b/lib/analyzer/test/SyntaxHelpers.test.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=SyntaxHelpers.test.d.ts.map
\ No newline at end of file
diff --git a/lib/analyzer/test/SyntaxHelpers.test.d.ts.map b/lib/analyzer/test/SyntaxHelpers.test.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..e5b3462e1f41a5c3d98fb3bf2c700c4ed765095f
--- /dev/null
+++ b/lib/analyzer/test/SyntaxHelpers.test.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"SyntaxHelpers.test.d.ts","sourceRoot":"","sources":["../../../src/analyzer/test/SyntaxHelpers.test.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/lib/analyzer/test/SyntaxHelpers.test.js b/lib/analyzer/test/SyntaxHelpers.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..906d4308ca59aad1a1809bf88a8cf79d47d2201b
--- /dev/null
+++ b/lib/analyzer/test/SyntaxHelpers.test.js
@@ -0,0 +1,59 @@
+"use strict";
+// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
+// See LICENSE in the project root for license information.
+Object.defineProperty(exports, "__esModule", { value: true });
+const SyntaxHelpers_1 = require("../SyntaxHelpers");
+describe(SyntaxHelpers_1.SyntaxHelpers.name, () => {
+    it(SyntaxHelpers_1.SyntaxHelpers.makeCamelCaseIdentifier.name, () => {
+        // prettier-ignore
+        const inputs = [
+            '',
+            '@#(&*^',
+            'api-extractor-lib1-test',
+            'one',
+            'one-two',
+            'ONE-TWO',
+            'ONE/two/ /three/FOUR',
+            '01234'
+        ];
+        expect(inputs.map((x) => {
+            return { input: x, output: SyntaxHelpers_1.SyntaxHelpers.makeCamelCaseIdentifier(x) };
+        })).toMatchInlineSnapshot(`
+      Array [
+        Object {
+          "input": "",
+          "output": "_",
+        },
+        Object {
+          "input": "@#(&*^",
+          "output": "_",
+        },
+        Object {
+          "input": "api-extractor-lib1-test",
+          "output": "apiExtractorLib1Test",
+        },
+        Object {
+          "input": "one",
+          "output": "one",
+        },
+        Object {
+          "input": "one-two",
+          "output": "oneTwo",
+        },
+        Object {
+          "input": "ONE-TWO",
+          "output": "oneTwo",
+        },
+        Object {
+          "input": "ONE/two/ /three/FOUR",
+          "output": "oneTwoThreeFour",
+        },
+        Object {
+          "input": "01234",
+          "output": "_01234",
+        },
+      ]
+    `);
+    });
+});
+//# sourceMappingURL=SyntaxHelpers.test.js.map
\ No newline at end of file
diff --git a/lib/analyzer/test/SyntaxHelpers.test.js.map b/lib/analyzer/test/SyntaxHelpers.test.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..38638b1d6bf6974c75f3087d0d17c416d23fda08
--- /dev/null
+++ b/lib/analyzer/test/SyntaxHelpers.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SyntaxHelpers.test.js","sourceRoot":"","sources":["../../../src/analyzer/test/SyntaxHelpers.test.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;AAE3D,oDAAiD;AAEjD,QAAQ,CAAC,6BAAa,CAAC,IAAI,EAAE,GAAG,EAAE;IAChC,EAAE,CAAC,6BAAa,CAAC,uBAAuB,CAAC,IAAI,EAAE,GAAG,EAAE;QAClD,kBAAkB;QAClB,MAAM,MAAM,GAAY;YACtB,EAAE;YACF,QAAQ;YACR,yBAAyB;YACzB,KAAK;YACL,SAAS;YACT,SAAS;YACT,sBAAsB;YACtB,OAAO;SACR,CAAC;QAEF,MAAM,CACJ,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE;YACf,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,MAAM,EAAE,6BAAa,CAAC,uBAAuB,CAAC,CAAC,CAAC,EAAE,CAAC;QACxE,CAAC,CAAC,CACH,CAAC,qBAAqB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAmCvB,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { SyntaxHelpers } from '../SyntaxHelpers';\r\n\r\ndescribe(SyntaxHelpers.name, () => {\r\n  it(SyntaxHelpers.makeCamelCaseIdentifier.name, () => {\r\n    // prettier-ignore\r\n    const inputs:string[] = [\r\n      '',\r\n      '@#(&*^',\r\n      'api-extractor-lib1-test',\r\n      'one',\r\n      'one-two',\r\n      'ONE-TWO',\r\n      'ONE/two/ /three/FOUR',\r\n      '01234'\r\n    ];\r\n\r\n    expect(\r\n      inputs.map((x) => {\r\n        return { input: x, output: SyntaxHelpers.makeCamelCaseIdentifier(x) };\r\n      })\r\n    ).toMatchInlineSnapshot(`\r\n      Array [\r\n        Object {\r\n          \"input\": \"\",\r\n          \"output\": \"_\",\r\n        },\r\n        Object {\r\n          \"input\": \"@#(&*^\",\r\n          \"output\": \"_\",\r\n        },\r\n        Object {\r\n          \"input\": \"api-extractor-lib1-test\",\r\n          \"output\": \"apiExtractorLib1Test\",\r\n        },\r\n        Object {\r\n          \"input\": \"one\",\r\n          \"output\": \"one\",\r\n        },\r\n        Object {\r\n          \"input\": \"one-two\",\r\n          \"output\": \"oneTwo\",\r\n        },\r\n        Object {\r\n          \"input\": \"ONE-TWO\",\r\n          \"output\": \"oneTwo\",\r\n        },\r\n        Object {\r\n          \"input\": \"ONE/two/ /three/FOUR\",\r\n          \"output\": \"oneTwoThreeFour\",\r\n        },\r\n        Object {\r\n          \"input\": \"01234\",\r\n          \"output\": \"_01234\",\r\n        },\r\n      ]\r\n    `);\r\n  });\r\n});\r\n"]}
\ No newline at end of file
diff --git a/lib/analyzer/test/test-data/tsdoc-metadata-path-inference/package-default/package.json b/lib/analyzer/test/test-data/tsdoc-metadata-path-inference/package-default/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..1a58930cee937f94cf9722c60fd4b541d4776567
--- /dev/null
+++ b/lib/analyzer/test/test-data/tsdoc-metadata-path-inference/package-default/package.json
@@ -0,0 +1,4 @@
+{
+  "name": "package-default",
+  "version": "1.0.0"
+}
diff --git a/lib/analyzer/test/test-data/tsdoc-metadata-path-inference/package-inferred-from-main/package.json b/lib/analyzer/test/test-data/tsdoc-metadata-path-inference/package-inferred-from-main/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..30a7f604a9636a014bb74dd2d8e5bfebd615a987
--- /dev/null
+++ b/lib/analyzer/test/test-data/tsdoc-metadata-path-inference/package-inferred-from-main/package.json
@@ -0,0 +1,5 @@
+{
+  "name": "package-inferred-from-main",
+  "version": "1.0.0",
+  "main": "path/to/main.js"
+}
diff --git a/lib/analyzer/test/test-data/tsdoc-metadata-path-inference/package-inferred-from-tsdoc-metadata/package.json b/lib/analyzer/test/test-data/tsdoc-metadata-path-inference/package-inferred-from-tsdoc-metadata/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..fbb048f47ef7db6494f7c03c288012cf75cd0b3d
--- /dev/null
+++ b/lib/analyzer/test/test-data/tsdoc-metadata-path-inference/package-inferred-from-tsdoc-metadata/package.json
@@ -0,0 +1,7 @@
+{
+  "name": "package-inferred-from-tsdoc-metadata",
+  "version": "1.0.0",
+  "main": "path/to/main.js",
+  "typings": "path/to/typings.d.ts",
+  "tsdocMetadata": "path/to/tsdoc-metadata.json"
+}
diff --git a/lib/analyzer/test/test-data/tsdoc-metadata-path-inference/package-inferred-from-typings/package.json b/lib/analyzer/test/test-data/tsdoc-metadata-path-inference/package-inferred-from-typings/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..bb73979d0545cca1081e9701750410c6b7dd0c74
--- /dev/null
+++ b/lib/analyzer/test/test-data/tsdoc-metadata-path-inference/package-inferred-from-typings/package.json
@@ -0,0 +1,6 @@
+{
+  "name": "package-inferred-from-typings",
+  "version": "1.0.0",
+  "main": "path/to/main.js",
+  "typings": "path/to/typings.d.ts"
+}
diff --git a/lib/api/CompilerState.js.map b/lib/api/CompilerState.js.map
index b9ff87b133f80665ae6e9cb19e2a95f2fa89edc4..76983916aa8d4adda3b5131b0928aeee7feb0be4 100644
--- a/lib/api/CompilerState.js.map
+++ b/lib/api/CompilerState.js.map
@@ -1 +1 @@
-{"version":3,"file":"CompilerState.js","sourceRoot":"","sources":["../../src/api/CompilerState.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport * as ts from 'typescript';\nimport colors = require('colors');\n\nimport { JsonFile } from '@rushstack/node-core-library';\n\nimport { ExtractorConfig } from './ExtractorConfig';\nimport type { IExtractorInvokeOptions } from './Extractor';\n\n/**\n * Options for {@link CompilerState.create}\n * @public\n */\nexport interface ICompilerStateCreateOptions {\n  /** {@inheritDoc IExtractorInvokeOptions.typescriptCompilerFolder} */\n  typescriptCompilerFolder?: string;\n\n  /**\n   * Additional .d.ts files to include in the analysis.\n   */\n  additionalEntryPoints?: string[];\n}\n\n/**\n * This class represents the TypeScript compiler state.  This allows an optimization where multiple invocations\n * of API Extractor can reuse the same TypeScript compiler analysis.\n *\n * @public\n */\nexport class CompilerState {\n  /**\n   * The TypeScript compiler's `Program` object, which represents a complete scope of analysis.\n   */\n  public readonly program: unknown;\n\n  private constructor(properties: CompilerState) {\n    this.program = properties.program;\n  }\n\n  /**\n   * Create a compiler state for use with the specified `IExtractorInvokeOptions`.\n   */\n  public static create(\n    extractorConfig: ExtractorConfig,\n    options?: ICompilerStateCreateOptions\n  ): CompilerState {\n    let tsconfig: {} | undefined = extractorConfig.overrideTsconfig;\n    let configBasePath: string = extractorConfig.projectFolder;\n    if (!tsconfig) {\n      // If it wasn't overridden, then load it from disk\n      tsconfig = JsonFile.load(extractorConfig.tsconfigFilePath);\n      configBasePath = path.resolve(path.dirname(extractorConfig.tsconfigFilePath));\n    }\n\n    const commandLine: ts.ParsedCommandLine = ts.parseJsonConfigFileContent(tsconfig, ts.sys, configBasePath);\n\n    if (!commandLine.options.skipLibCheck && extractorConfig.skipLibCheck) {\n      commandLine.options.skipLibCheck = true;\n      console.log(\n        colors.cyan(\n          'API Extractor was invoked with skipLibCheck. This is not recommended and may cause ' +\n            'incorrect type analysis.'\n        )\n      );\n    }\n\n    const inputFilePaths: string[] = commandLine.fileNames.concat(extractorConfig.mainEntryPointFilePath);\n    if (options && options.additionalEntryPoints) {\n      inputFilePaths.push(...options.additionalEntryPoints);\n    }\n\n    // Append the entry points and remove any non-declaration files from the list\n    const analysisFilePaths: string[] = CompilerState._generateFilePathsForAnalysis(inputFilePaths);\n\n    const compilerHost: ts.CompilerHost = CompilerState._createCompilerHost(commandLine, options);\n\n    const program: ts.Program = ts.createProgram(analysisFilePaths, commandLine.options, compilerHost);\n\n    if (commandLine.errors.length > 0) {\n      const errorText: string = ts.flattenDiagnosticMessageText(commandLine.errors[0].messageText, '\\n');\n      throw new Error(`Error parsing tsconfig.json content: ${errorText}`);\n    }\n\n    return new CompilerState({\n      program\n    });\n  }\n\n  /**\n   * Given a list of absolute file paths, return a list containing only the declaration\n   * files.  Duplicates are also eliminated.\n   *\n   * @remarks\n   * The tsconfig.json settings specify the compiler's input (a set of *.ts source files,\n   * plus some *.d.ts declaration files used for legacy typings).  However API Extractor\n   * analyzes the compiler's output (a set of *.d.ts entry point files, plus any legacy\n   * typings).  This requires API Extractor to generate a special file list when it invokes\n   * the compiler.\n   *\n   * Duplicates are removed so that entry points can be appended without worrying whether they\n   * may already appear in the tsconfig.json file list.\n   */\n  private static _generateFilePathsForAnalysis(inputFilePaths: string[]): string[] {\n    const analysisFilePaths: string[] = [];\n\n    const seenFiles: Set<string> = new Set<string>();\n\n    for (const inputFilePath of inputFilePaths) {\n      const inputFileToUpper: string = inputFilePath.toUpperCase();\n      if (!seenFiles.has(inputFileToUpper)) {\n        seenFiles.add(inputFileToUpper);\n\n        if (!path.isAbsolute(inputFilePath)) {\n          throw new Error('Input file is not an absolute path: ' + inputFilePath);\n        }\n\n        if (ExtractorConfig.hasDtsFileExtension(inputFilePath)) {\n          analysisFilePaths.push(inputFilePath);\n        }\n      }\n    }\n\n    return analysisFilePaths;\n  }\n\n  private static _createCompilerHost(\n    commandLine: ts.ParsedCommandLine,\n    options: IExtractorInvokeOptions | undefined\n  ): ts.CompilerHost {\n    // Create a default CompilerHost that we will override\n    const compilerHost: ts.CompilerHost = ts.createCompilerHost(commandLine.options);\n\n    // Save a copy of the original members.  Note that \"compilerHost\" cannot be the copy, because\n    // createCompilerHost() captures that instance in a closure that is used by the members.\n    const defaultCompilerHost: ts.CompilerHost = { ...compilerHost };\n\n    if (options && options.typescriptCompilerFolder) {\n      // Prevent a closure parameter\n      const typescriptCompilerLibFolder: string = path.join(options.typescriptCompilerFolder, 'lib');\n      compilerHost.getDefaultLibLocation = () => typescriptCompilerLibFolder;\n    }\n\n    // Used by compilerHost.fileExists()\n    // .d.ts file path --> whether the file exists\n    const dtsExistsCache: Map<string, boolean> = new Map<string, boolean>();\n\n    // Used by compilerHost.fileExists()\n    // Example: \"c:/folder/file.part.ts\"\n    const fileExtensionRegExp: RegExp = /^(.+)(\\.[a-z0-9_]+)$/i;\n\n    compilerHost.fileExists = (fileName: string): boolean => {\n      // In certain deprecated setups, the compiler may write its output files (.js and .d.ts)\n      // in the same folder as the corresponding input file (.ts or .tsx).  When following imports,\n      // API Extractor wants to analyze the .d.ts file; however recent versions of the compiler engine\n      // will instead choose the .ts file.  To work around this, we hook fileExists() to hide the\n      // existence of those files.\n\n      // Is \"fileName\" a .d.ts file?  The double extension \".d.ts\" needs to be matched specially.\n      if (!ExtractorConfig.hasDtsFileExtension(fileName)) {\n        // It's not a .d.ts file.  Is the file extension a potential source file?\n        const match: RegExpExecArray | null = fileExtensionRegExp.exec(fileName);\n        if (match) {\n          // Example: \"c:/folder/file.part\"\n          const pathWithoutExtension: string = match[1];\n          // Example: \".ts\"\n          const fileExtension: string = match[2];\n\n          switch (fileExtension.toLocaleLowerCase()) {\n            case '.ts':\n            case '.tsx':\n            case '.js':\n            case '.jsx':\n              // Yes, this is a possible source file.  Is there a corresponding .d.ts file in the same folder?\n              const dtsFileName: string = `${pathWithoutExtension}.d.ts`;\n\n              let dtsFileExists: boolean | undefined = dtsExistsCache.get(dtsFileName);\n              if (dtsFileExists === undefined) {\n                dtsFileExists = defaultCompilerHost.fileExists!(dtsFileName);\n                dtsExistsCache.set(dtsFileName, dtsFileExists);\n              }\n\n              if (dtsFileExists) {\n                // fileName is a potential source file and a corresponding .d.ts file exists.\n                // Thus, API Extractor should ignore this file (so the .d.ts file will get analyzed instead).\n                return false;\n              }\n              break;\n          }\n        }\n      }\n\n      // Fall through to the default implementation\n      return defaultCompilerHost.fileExists!(fileName);\n    };\n\n    return compilerHost;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"CompilerState.js","sourceRoot":"","sources":["../../src/api/CompilerState.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as ts from 'typescript';\r\nimport colors = require('colors');\r\n\r\nimport { JsonFile } from '@rushstack/node-core-library';\r\n\r\nimport { ExtractorConfig } from './ExtractorConfig';\r\nimport type { IExtractorInvokeOptions } from './Extractor';\r\n\r\n/**\r\n * Options for {@link CompilerState.create}\r\n * @public\r\n */\r\nexport interface ICompilerStateCreateOptions {\r\n  /** {@inheritDoc IExtractorInvokeOptions.typescriptCompilerFolder} */\r\n  typescriptCompilerFolder?: string;\r\n\r\n  /**\r\n   * Additional .d.ts files to include in the analysis.\r\n   */\r\n  additionalEntryPoints?: string[];\r\n}\r\n\r\n/**\r\n * This class represents the TypeScript compiler state.  This allows an optimization where multiple invocations\r\n * of API Extractor can reuse the same TypeScript compiler analysis.\r\n *\r\n * @public\r\n */\r\nexport class CompilerState {\r\n  /**\r\n   * The TypeScript compiler's `Program` object, which represents a complete scope of analysis.\r\n   */\r\n  public readonly program: unknown;\r\n\r\n  private constructor(properties: CompilerState) {\r\n    this.program = properties.program;\r\n  }\r\n\r\n  /**\r\n   * Create a compiler state for use with the specified `IExtractorInvokeOptions`.\r\n   */\r\n  public static create(\r\n    extractorConfig: ExtractorConfig,\r\n    options?: ICompilerStateCreateOptions\r\n  ): CompilerState {\r\n    let tsconfig: {} | undefined = extractorConfig.overrideTsconfig;\r\n    let configBasePath: string = extractorConfig.projectFolder;\r\n    if (!tsconfig) {\r\n      // If it wasn't overridden, then load it from disk\r\n      tsconfig = JsonFile.load(extractorConfig.tsconfigFilePath);\r\n      configBasePath = path.resolve(path.dirname(extractorConfig.tsconfigFilePath));\r\n    }\r\n\r\n    const commandLine: ts.ParsedCommandLine = ts.parseJsonConfigFileContent(tsconfig, ts.sys, configBasePath);\r\n\r\n    if (!commandLine.options.skipLibCheck && extractorConfig.skipLibCheck) {\r\n      commandLine.options.skipLibCheck = true;\r\n      console.log(\r\n        colors.cyan(\r\n          'API Extractor was invoked with skipLibCheck. This is not recommended and may cause ' +\r\n            'incorrect type analysis.'\r\n        )\r\n      );\r\n    }\r\n\r\n    const inputFilePaths: string[] = commandLine.fileNames.concat(extractorConfig.mainEntryPointFilePath);\r\n    if (options && options.additionalEntryPoints) {\r\n      inputFilePaths.push(...options.additionalEntryPoints);\r\n    }\r\n\r\n    // Append the entry points and remove any non-declaration files from the list\r\n    const analysisFilePaths: string[] = CompilerState._generateFilePathsForAnalysis(inputFilePaths);\r\n\r\n    const compilerHost: ts.CompilerHost = CompilerState._createCompilerHost(commandLine, options);\r\n\r\n    const program: ts.Program = ts.createProgram(analysisFilePaths, commandLine.options, compilerHost);\r\n\r\n    if (commandLine.errors.length > 0) {\r\n      const errorText: string = ts.flattenDiagnosticMessageText(commandLine.errors[0].messageText, '\\n');\r\n      throw new Error(`Error parsing tsconfig.json content: ${errorText}`);\r\n    }\r\n\r\n    return new CompilerState({\r\n      program\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Given a list of absolute file paths, return a list containing only the declaration\r\n   * files.  Duplicates are also eliminated.\r\n   *\r\n   * @remarks\r\n   * The tsconfig.json settings specify the compiler's input (a set of *.ts source files,\r\n   * plus some *.d.ts declaration files used for legacy typings).  However API Extractor\r\n   * analyzes the compiler's output (a set of *.d.ts entry point files, plus any legacy\r\n   * typings).  This requires API Extractor to generate a special file list when it invokes\r\n   * the compiler.\r\n   *\r\n   * Duplicates are removed so that entry points can be appended without worrying whether they\r\n   * may already appear in the tsconfig.json file list.\r\n   */\r\n  private static _generateFilePathsForAnalysis(inputFilePaths: string[]): string[] {\r\n    const analysisFilePaths: string[] = [];\r\n\r\n    const seenFiles: Set<string> = new Set<string>();\r\n\r\n    for (const inputFilePath of inputFilePaths) {\r\n      const inputFileToUpper: string = inputFilePath.toUpperCase();\r\n      if (!seenFiles.has(inputFileToUpper)) {\r\n        seenFiles.add(inputFileToUpper);\r\n\r\n        if (!path.isAbsolute(inputFilePath)) {\r\n          throw new Error('Input file is not an absolute path: ' + inputFilePath);\r\n        }\r\n\r\n        if (ExtractorConfig.hasDtsFileExtension(inputFilePath)) {\r\n          analysisFilePaths.push(inputFilePath);\r\n        }\r\n      }\r\n    }\r\n\r\n    return analysisFilePaths;\r\n  }\r\n\r\n  private static _createCompilerHost(\r\n    commandLine: ts.ParsedCommandLine,\r\n    options: IExtractorInvokeOptions | undefined\r\n  ): ts.CompilerHost {\r\n    // Create a default CompilerHost that we will override\r\n    const compilerHost: ts.CompilerHost = ts.createCompilerHost(commandLine.options);\r\n\r\n    // Save a copy of the original members.  Note that \"compilerHost\" cannot be the copy, because\r\n    // createCompilerHost() captures that instance in a closure that is used by the members.\r\n    const defaultCompilerHost: ts.CompilerHost = { ...compilerHost };\r\n\r\n    if (options && options.typescriptCompilerFolder) {\r\n      // Prevent a closure parameter\r\n      const typescriptCompilerLibFolder: string = path.join(options.typescriptCompilerFolder, 'lib');\r\n      compilerHost.getDefaultLibLocation = () => typescriptCompilerLibFolder;\r\n    }\r\n\r\n    // Used by compilerHost.fileExists()\r\n    // .d.ts file path --> whether the file exists\r\n    const dtsExistsCache: Map<string, boolean> = new Map<string, boolean>();\r\n\r\n    // Used by compilerHost.fileExists()\r\n    // Example: \"c:/folder/file.part.ts\"\r\n    const fileExtensionRegExp: RegExp = /^(.+)(\\.[a-z0-9_]+)$/i;\r\n\r\n    compilerHost.fileExists = (fileName: string): boolean => {\r\n      // In certain deprecated setups, the compiler may write its output files (.js and .d.ts)\r\n      // in the same folder as the corresponding input file (.ts or .tsx).  When following imports,\r\n      // API Extractor wants to analyze the .d.ts file; however recent versions of the compiler engine\r\n      // will instead choose the .ts file.  To work around this, we hook fileExists() to hide the\r\n      // existence of those files.\r\n\r\n      // Is \"fileName\" a .d.ts file?  The double extension \".d.ts\" needs to be matched specially.\r\n      if (!ExtractorConfig.hasDtsFileExtension(fileName)) {\r\n        // It's not a .d.ts file.  Is the file extension a potential source file?\r\n        const match: RegExpExecArray | null = fileExtensionRegExp.exec(fileName);\r\n        if (match) {\r\n          // Example: \"c:/folder/file.part\"\r\n          const pathWithoutExtension: string = match[1];\r\n          // Example: \".ts\"\r\n          const fileExtension: string = match[2];\r\n\r\n          switch (fileExtension.toLocaleLowerCase()) {\r\n            case '.ts':\r\n            case '.tsx':\r\n            case '.js':\r\n            case '.jsx':\r\n              // Yes, this is a possible source file.  Is there a corresponding .d.ts file in the same folder?\r\n              const dtsFileName: string = `${pathWithoutExtension}.d.ts`;\r\n\r\n              let dtsFileExists: boolean | undefined = dtsExistsCache.get(dtsFileName);\r\n              if (dtsFileExists === undefined) {\r\n                dtsFileExists = defaultCompilerHost.fileExists!(dtsFileName);\r\n                dtsExistsCache.set(dtsFileName, dtsFileExists);\r\n              }\r\n\r\n              if (dtsFileExists) {\r\n                // fileName is a potential source file and a corresponding .d.ts file exists.\r\n                // Thus, API Extractor should ignore this file (so the .d.ts file will get analyzed instead).\r\n                return false;\r\n              }\r\n              break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Fall through to the default implementation\r\n      return defaultCompilerHost.fileExists!(fileName);\r\n    };\r\n\r\n    return compilerHost;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/api/ConsoleMessageId.js.map b/lib/api/ConsoleMessageId.js.map
index 2101b254b26e8035d8dab17436be21b4c68dfba0..4007c12dbf6615453941e06f6c4d389bf4596e08 100644
--- a/lib/api/ConsoleMessageId.js.map
+++ b/lib/api/ConsoleMessageId.js.map
@@ -1 +1 @@
-{"version":3,"file":"ConsoleMessageId.js","sourceRoot":"","sources":["../../src/api/ConsoleMessageId.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/**\n * Unique identifiers for console messages reported by API Extractor.\n *\n * @remarks\n *\n * These strings are possible values for the {@link ExtractorMessage.messageId} property\n * when the `ExtractorMessage.category` is {@link ExtractorMessageCategory.Console}.\n *\n * @public\n */\nexport const enum ConsoleMessageId {\n  /**\n   * \"Analysis will use the bundled TypeScript version ___\"\n   */\n  Preamble = 'console-preamble',\n\n  /**\n   * \"The target project appears to use TypeScript ___ which is newer than the bundled compiler engine;\n   * consider upgrading API Extractor.\"\n   */\n  CompilerVersionNotice = 'console-compiler-version-notice',\n\n  /**\n   * \"Using custom TSDoc config from ___\"\n   */\n  UsingCustomTSDocConfig = 'console-using-custom-tsdoc-config',\n\n  /**\n   * \"Found metadata in ___\"\n   */\n  FoundTSDocMetadata = 'console-found-tsdoc-metadata',\n\n  /**\n   * \"Writing: ___\"\n   */\n  WritingDocModelFile = 'console-writing-doc-model-file',\n\n  /**\n   * \"Writing package typings: ___\"\n   */\n  WritingDtsRollup = 'console-writing-dts-rollup',\n\n  /**\n   * \"You have changed the public API signature for this project.\n   * Please copy the file ___ to ___, or perform a local build (which does this automatically).\n   * See the Git repo documentation for more info.\"\n   *\n   * OR\n   *\n   * \"The API report file is missing.\n   * Please copy the file ___ to ___, or perform a local build (which does this automatically).\n   * See the Git repo documentation for more info.\"\n   */\n  ApiReportNotCopied = 'console-api-report-not-copied',\n\n  /**\n   * \"You have changed the public API signature for this project.  Updating ___\"\n   */\n  ApiReportCopied = 'console-api-report-copied',\n\n  /**\n   * \"The API report is up to date: ___\"\n   */\n  ApiReportUnchanged = 'console-api-report-unchanged',\n\n  /**\n   * \"The API report file was missing, so a new file was created. Please add this file to Git: ___\"\n   */\n  ApiReportCreated = 'console-api-report-created',\n\n  /**\n   * \"Unable to create the API report file. Please make sure the target folder exists: ___\"\n   */\n  ApiReportFolderMissing = 'console-api-report-folder-missing',\n\n  /**\n   * Used for the information printed when the \"--diagnostics\" flag is enabled.\n   */\n  Diagnostics = 'console-diagnostics'\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ConsoleMessageId.js","sourceRoot":"","sources":["../../src/api/ConsoleMessageId.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/**\r\n * Unique identifiers for console messages reported by API Extractor.\r\n *\r\n * @remarks\r\n *\r\n * These strings are possible values for the {@link ExtractorMessage.messageId} property\r\n * when the `ExtractorMessage.category` is {@link ExtractorMessageCategory.Console}.\r\n *\r\n * @public\r\n */\r\nexport const enum ConsoleMessageId {\r\n  /**\r\n   * \"Analysis will use the bundled TypeScript version ___\"\r\n   */\r\n  Preamble = 'console-preamble',\r\n\r\n  /**\r\n   * \"The target project appears to use TypeScript ___ which is newer than the bundled compiler engine;\r\n   * consider upgrading API Extractor.\"\r\n   */\r\n  CompilerVersionNotice = 'console-compiler-version-notice',\r\n\r\n  /**\r\n   * \"Using custom TSDoc config from ___\"\r\n   */\r\n  UsingCustomTSDocConfig = 'console-using-custom-tsdoc-config',\r\n\r\n  /**\r\n   * \"Found metadata in ___\"\r\n   */\r\n  FoundTSDocMetadata = 'console-found-tsdoc-metadata',\r\n\r\n  /**\r\n   * \"Writing: ___\"\r\n   */\r\n  WritingDocModelFile = 'console-writing-doc-model-file',\r\n\r\n  /**\r\n   * \"Writing package typings: ___\"\r\n   */\r\n  WritingDtsRollup = 'console-writing-dts-rollup',\r\n\r\n  /**\r\n   * \"You have changed the public API signature for this project.\r\n   * Please copy the file ___ to ___, or perform a local build (which does this automatically).\r\n   * See the Git repo documentation for more info.\"\r\n   *\r\n   * OR\r\n   *\r\n   * \"The API report file is missing.\r\n   * Please copy the file ___ to ___, or perform a local build (which does this automatically).\r\n   * See the Git repo documentation for more info.\"\r\n   */\r\n  ApiReportNotCopied = 'console-api-report-not-copied',\r\n\r\n  /**\r\n   * \"You have changed the public API signature for this project.  Updating ___\"\r\n   */\r\n  ApiReportCopied = 'console-api-report-copied',\r\n\r\n  /**\r\n   * \"The API report is up to date: ___\"\r\n   */\r\n  ApiReportUnchanged = 'console-api-report-unchanged',\r\n\r\n  /**\r\n   * \"The API report file was missing, so a new file was created. Please add this file to Git: ___\"\r\n   */\r\n  ApiReportCreated = 'console-api-report-created',\r\n\r\n  /**\r\n   * \"Unable to create the API report file. Please make sure the target folder exists: ___\"\r\n   */\r\n  ApiReportFolderMissing = 'console-api-report-folder-missing',\r\n\r\n  /**\r\n   * Used for the information printed when the \"--diagnostics\" flag is enabled.\r\n   */\r\n  Diagnostics = 'console-diagnostics'\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/api/Extractor.js.map b/lib/api/Extractor.js.map
index 695e05f51a1c33ecc8d8e7f6f8c6de44b28a3c27..aa2e4c52e26bb1c0333aa864624ada262066b9d7 100644
--- a/lib/api/Extractor.js.map
+++ b/lib/api/Extractor.js.map
@@ -1 +1 @@
-{"version":3,"file":"Extractor.js","sourceRoot":"","sources":["../../src/api/Extractor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport * as ts from 'typescript';\nimport * as resolve from 'resolve';\nimport {\n  FileSystem,\n  type NewlineKind,\n  PackageJsonLookup,\n  type IPackageJson,\n  type INodePackageJson,\n  Path\n} from '@rushstack/node-core-library';\n\nimport { ExtractorConfig } from './ExtractorConfig';\nimport { Collector } from '../collector/Collector';\nimport { DtsRollupGenerator, DtsRollupKind } from '../generators/DtsRollupGenerator';\nimport { ApiModelGenerator } from '../generators/ApiModelGenerator';\nimport type { ApiPackage } from '@microsoft/api-extractor-model';\nimport { ApiReportGenerator } from '../generators/ApiReportGenerator';\nimport { PackageMetadataManager } from '../analyzer/PackageMetadataManager';\nimport { ValidationEnhancer } from '../enhancers/ValidationEnhancer';\nimport { DocCommentEnhancer } from '../enhancers/DocCommentEnhancer';\nimport { CompilerState } from './CompilerState';\nimport type { ExtractorMessage } from './ExtractorMessage';\nimport { MessageRouter } from '../collector/MessageRouter';\nimport { ConsoleMessageId } from './ConsoleMessageId';\nimport { TSDocConfigFile } from '@microsoft/tsdoc-config';\nimport { SourceMapper } from '../collector/SourceMapper';\n\n/**\n * Runtime options for Extractor.\n *\n * @public\n */\nexport interface IExtractorInvokeOptions {\n  /**\n   * An optional TypeScript compiler state.  This allows an optimization where multiple invocations of API Extractor\n   * can reuse the same TypeScript compiler analysis.\n   */\n  compilerState?: CompilerState;\n\n  /**\n   * Indicates that API Extractor is running as part of a local build, e.g. on developer's\n   * machine.\n   *\n   * @remarks\n   * This disables certain validation that would normally be performed for a ship/production build. For example,\n   * the *.api.md report file is automatically updated in a local build.\n   *\n   * The default value is false.\n   */\n  localBuild?: boolean;\n\n  /**\n   * If true, API Extractor will include {@link ExtractorLogLevel.Verbose} messages in its output.\n   */\n  showVerboseMessages?: boolean;\n\n  /**\n   * If true, API Extractor will print diagnostic information used for troubleshooting problems.\n   * These messages will be included as {@link ExtractorLogLevel.Verbose} output.\n   *\n   * @remarks\n   * Setting `showDiagnostics=true` forces `showVerboseMessages=true`.\n   */\n  showDiagnostics?: boolean;\n\n  /**\n   * Specifies an alternate folder path to be used when loading the TypeScript system typings.\n   *\n   * @remarks\n   * API Extractor uses its own TypeScript compiler engine to analyze your project.  If your project\n   * is built with a significantly different TypeScript version, sometimes API Extractor may report compilation\n   * errors due to differences in the system typings (e.g. lib.dom.d.ts).  You can use the \"--typescriptCompilerFolder\"\n   * option to specify the folder path where you installed the TypeScript package, and API Extractor's compiler will\n   * use those system typings instead.\n   */\n  typescriptCompilerFolder?: string;\n\n  /**\n   * An optional callback function that will be called for each `ExtractorMessage` before it is displayed by\n   * API Extractor.  The callback can customize the message, handle it, or discard it.\n   *\n   * @remarks\n   * If a `messageCallback` is not provided, then by default API Extractor will print the messages to\n   * the STDERR/STDOUT console.\n   */\n  messageCallback?: (message: ExtractorMessage) => void;\n}\n\n/**\n * This object represents the outcome of an invocation of API Extractor.\n *\n * @public\n */\nexport class ExtractorResult {\n  /**\n   * The TypeScript compiler state that was used.\n   */\n  public readonly compilerState: CompilerState;\n\n  /**\n   * The API Extractor configuration that was used.\n   */\n  public readonly extractorConfig: ExtractorConfig;\n\n  /**\n   * Whether the invocation of API Extractor was successful.  For example, if `succeeded` is false, then the build task\n   * would normally return a nonzero process exit code, indicating that the operation failed.\n   *\n   * @remarks\n   *\n   * Normally the operation \"succeeds\" if `errorCount` and `warningCount` are both zero.  However if\n   * {@link IExtractorInvokeOptions.localBuild} is `true`, then the operation \"succeeds\" if `errorCount` is zero\n   * (i.e. warnings are ignored).\n   */\n  public readonly succeeded: boolean;\n\n  /**\n   * Returns true if the API report was found to have changed.\n   */\n  public readonly apiReportChanged: boolean;\n\n  /**\n   * Reports the number of errors encountered during analysis.\n   *\n   * @remarks\n   * This does not count exceptions, where unexpected issues prematurely abort the operation.\n   */\n  public readonly errorCount: number;\n\n  /**\n   * Reports the number of warnings encountered during analysis.\n   *\n   * @remarks\n   * This does not count warnings that are emitted in the API report file.\n   */\n  public readonly warningCount: number;\n\n  /** @internal */\n  public constructor(properties: ExtractorResult) {\n    this.compilerState = properties.compilerState;\n    this.extractorConfig = properties.extractorConfig;\n    this.succeeded = properties.succeeded;\n    this.apiReportChanged = properties.apiReportChanged;\n    this.errorCount = properties.errorCount;\n    this.warningCount = properties.warningCount;\n  }\n}\n\n/**\n * The starting point for invoking the API Extractor tool.\n * @public\n */\nexport class Extractor {\n  /**\n   * Returns the version number of the API Extractor NPM package.\n   */\n  public static get version(): string {\n    return Extractor._getPackageJson().version;\n  }\n\n  /**\n   * Returns the package name of the API Extractor NPM package.\n   */\n  public static get packageName(): string {\n    return Extractor._getPackageJson().name;\n  }\n\n  private static _getPackageJson(): IPackageJson {\n    return PackageJsonLookup.loadOwnPackageJson(__dirname);\n  }\n\n  /**\n   * Load the api-extractor.json config file from the specified path, and then invoke API Extractor.\n   */\n  public static loadConfigAndInvoke(\n    configFilePath: string,\n    options?: IExtractorInvokeOptions\n  ): ExtractorResult {\n    const extractorConfig: ExtractorConfig = ExtractorConfig.loadFileAndPrepare(configFilePath);\n\n    return Extractor.invoke(extractorConfig, options);\n  }\n\n  /**\n   * Invoke API Extractor using an already prepared `ExtractorConfig` object.\n   */\n  public static invoke(extractorConfig: ExtractorConfig, options?: IExtractorInvokeOptions): ExtractorResult {\n    if (!options) {\n      options = {};\n    }\n\n    const localBuild: boolean = options.localBuild || false;\n\n    let compilerState: CompilerState | undefined;\n    if (options.compilerState) {\n      compilerState = options.compilerState;\n    } else {\n      compilerState = CompilerState.create(extractorConfig, options);\n    }\n\n    const sourceMapper: SourceMapper = new SourceMapper();\n\n    const messageRouter: MessageRouter = new MessageRouter({\n      workingPackageFolder: extractorConfig.packageFolder,\n      messageCallback: options.messageCallback,\n      messagesConfig: extractorConfig.messages || {},\n      showVerboseMessages: !!options.showVerboseMessages,\n      showDiagnostics: !!options.showDiagnostics,\n      tsdocConfiguration: extractorConfig.tsdocConfiguration,\n      sourceMapper\n    });\n\n    if (extractorConfig.tsdocConfigFile.filePath && !extractorConfig.tsdocConfigFile.fileNotFound) {\n      if (!Path.isEqual(extractorConfig.tsdocConfigFile.filePath, ExtractorConfig._tsdocBaseFilePath)) {\n        messageRouter.logVerbose(\n          ConsoleMessageId.UsingCustomTSDocConfig,\n          'Using custom TSDoc config from ' + extractorConfig.tsdocConfigFile.filePath\n        );\n      }\n    }\n\n    this._checkCompilerCompatibility(extractorConfig, messageRouter);\n\n    if (messageRouter.showDiagnostics) {\n      messageRouter.logDiagnostic('');\n      messageRouter.logDiagnosticHeader('Final prepared ExtractorConfig');\n      messageRouter.logDiagnostic(extractorConfig.getDiagnosticDump());\n      messageRouter.logDiagnosticFooter();\n\n      messageRouter.logDiagnosticHeader('Compiler options');\n      const serializedCompilerOptions: object = MessageRouter.buildJsonDumpObject(\n        (compilerState.program as ts.Program).getCompilerOptions()\n      );\n      messageRouter.logDiagnostic(JSON.stringify(serializedCompilerOptions, undefined, 2));\n      messageRouter.logDiagnosticFooter();\n\n      messageRouter.logDiagnosticHeader('TSDoc configuration');\n      // Convert the TSDocConfiguration into a tsdoc.json representation\n      const combinedConfigFile: TSDocConfigFile = TSDocConfigFile.loadFromParser(\n        extractorConfig.tsdocConfiguration\n      );\n      const serializedTSDocConfig: object = MessageRouter.buildJsonDumpObject(\n        combinedConfigFile.saveToObject()\n      );\n      messageRouter.logDiagnostic(JSON.stringify(serializedTSDocConfig, undefined, 2));\n      messageRouter.logDiagnosticFooter();\n    }\n\n    const collector: Collector = new Collector({\n      program: compilerState.program as ts.Program,\n      messageRouter,\n      extractorConfig: extractorConfig,\n      sourceMapper\n    });\n\n    collector.analyze();\n\n    DocCommentEnhancer.analyze(collector);\n    ValidationEnhancer.analyze(collector);\n\n    const modelBuilder: ApiModelGenerator = new ApiModelGenerator(collector);\n    const apiPackage: ApiPackage = modelBuilder.buildApiPackage();\n\n    if (messageRouter.showDiagnostics) {\n      messageRouter.logDiagnostic(''); // skip a line after any diagnostic messages\n    }\n\n    if (extractorConfig.docModelEnabled) {\n      messageRouter.logVerbose(\n        ConsoleMessageId.WritingDocModelFile,\n        'Writing: ' + extractorConfig.apiJsonFilePath\n      );\n      apiPackage.saveToJsonFile(extractorConfig.apiJsonFilePath, {\n        toolPackage: Extractor.packageName,\n        toolVersion: Extractor.version,\n\n        newlineConversion: extractorConfig.newlineKind,\n        ensureFolderExists: true,\n        testMode: extractorConfig.testMode\n      });\n    }\n\n    let apiReportChanged: boolean = false;\n\n    if (extractorConfig.apiReportEnabled) {\n      const actualApiReportPath: string = extractorConfig.reportTempFilePath;\n      const actualApiReportShortPath: string = extractorConfig._getShortFilePath(\n        extractorConfig.reportTempFilePath\n      );\n\n      const expectedApiReportPath: string = extractorConfig.reportFilePath;\n      const expectedApiReportShortPath: string = extractorConfig._getShortFilePath(\n        extractorConfig.reportFilePath\n      );\n\n      const actualApiReportContent: string = ApiReportGenerator.generateReviewFileContent(collector);\n\n      // Write the actual file\n      FileSystem.writeFile(actualApiReportPath, actualApiReportContent, {\n        ensureFolderExists: true,\n        convertLineEndings: extractorConfig.newlineKind\n      });\n\n      // Compare it against the expected file\n      if (FileSystem.exists(expectedApiReportPath)) {\n        const expectedApiReportContent: string = FileSystem.readFile(expectedApiReportPath);\n\n        if (\n          !ApiReportGenerator.areEquivalentApiFileContents(actualApiReportContent, expectedApiReportContent)\n        ) {\n          apiReportChanged = true;\n\n          if (!localBuild) {\n            // For a production build, issue a warning that will break the CI build.\n            messageRouter.logWarning(\n              ConsoleMessageId.ApiReportNotCopied,\n              'You have changed the public API signature for this project.' +\n                ` Please copy the file \"${actualApiReportShortPath}\" to \"${expectedApiReportShortPath}\",` +\n                ` or perform a local build (which does this automatically).` +\n                ` See the Git repo documentation for more info.`\n            );\n          } else {\n            // For a local build, just copy the file automatically.\n            messageRouter.logWarning(\n              ConsoleMessageId.ApiReportCopied,\n              'You have changed the public API signature for this project.' +\n                ` Updating ${expectedApiReportShortPath}`\n            );\n\n            FileSystem.writeFile(expectedApiReportPath, actualApiReportContent, {\n              ensureFolderExists: true,\n              convertLineEndings: extractorConfig.newlineKind\n            });\n          }\n        } else {\n          messageRouter.logVerbose(\n            ConsoleMessageId.ApiReportUnchanged,\n            `The API report is up to date: ${actualApiReportShortPath}`\n          );\n        }\n      } else {\n        // The target file does not exist, so we are setting up the API review file for the first time.\n        //\n        // NOTE: People sometimes make a mistake where they move a project and forget to update the \"reportFolder\"\n        // setting, which causes a new file to silently get written to the wrong place.  This can be confusing.\n        // Thus we treat the initial creation of the file specially.\n        apiReportChanged = true;\n\n        if (!localBuild) {\n          // For a production build, issue a warning that will break the CI build.\n          messageRouter.logWarning(\n            ConsoleMessageId.ApiReportNotCopied,\n            'The API report file is missing.' +\n              ` Please copy the file \"${actualApiReportShortPath}\" to \"${expectedApiReportShortPath}\",` +\n              ` or perform a local build (which does this automatically).` +\n              ` See the Git repo documentation for more info.`\n          );\n        } else {\n          const expectedApiReportFolder: string = path.dirname(expectedApiReportPath);\n          if (!FileSystem.exists(expectedApiReportFolder)) {\n            messageRouter.logError(\n              ConsoleMessageId.ApiReportFolderMissing,\n              'Unable to create the API report file. Please make sure the target folder exists:\\n' +\n                expectedApiReportFolder\n            );\n          } else {\n            FileSystem.writeFile(expectedApiReportPath, actualApiReportContent, {\n              convertLineEndings: extractorConfig.newlineKind\n            });\n            messageRouter.logWarning(\n              ConsoleMessageId.ApiReportCreated,\n              'The API report file was missing, so a new file was created. Please add this file to Git:\\n' +\n                expectedApiReportPath\n            );\n          }\n        }\n      }\n    }\n\n    if (extractorConfig.rollupEnabled) {\n      Extractor._generateRollupDtsFile(\n        collector,\n        extractorConfig.publicTrimmedFilePath,\n        DtsRollupKind.PublicRelease,\n        extractorConfig.newlineKind\n      );\n      Extractor._generateRollupDtsFile(\n        collector,\n        extractorConfig.alphaTrimmedFilePath,\n        DtsRollupKind.AlphaRelease,\n        extractorConfig.newlineKind\n      );\n      Extractor._generateRollupDtsFile(\n        collector,\n        extractorConfig.betaTrimmedFilePath,\n        DtsRollupKind.BetaRelease,\n        extractorConfig.newlineKind\n      );\n      Extractor._generateRollupDtsFile(\n        collector,\n        extractorConfig.untrimmedFilePath,\n        DtsRollupKind.InternalRelease,\n        extractorConfig.newlineKind\n      );\n    }\n\n    if (extractorConfig.tsdocMetadataEnabled) {\n      // Write the tsdoc-metadata.json file for this project\n      PackageMetadataManager.writeTsdocMetadataFile(\n        extractorConfig.tsdocMetadataFilePath,\n        extractorConfig.newlineKind\n      );\n    }\n\n    // Show all the messages that we collected during analysis\n    messageRouter.handleRemainingNonConsoleMessages();\n\n    // Determine success\n    let succeeded: boolean;\n    if (localBuild) {\n      // For a local build, fail if there were errors (but ignore warnings)\n      succeeded = messageRouter.errorCount === 0;\n    } else {\n      // For a production build, fail if there were any errors or warnings\n      succeeded = messageRouter.errorCount + messageRouter.warningCount === 0;\n    }\n\n    return new ExtractorResult({\n      compilerState,\n      extractorConfig,\n      succeeded,\n      apiReportChanged,\n      errorCount: messageRouter.errorCount,\n      warningCount: messageRouter.warningCount\n    });\n  }\n\n  private static _checkCompilerCompatibility(\n    extractorConfig: ExtractorConfig,\n    messageRouter: MessageRouter\n  ): void {\n    messageRouter.logInfo(\n      ConsoleMessageId.Preamble,\n      `Analysis will use the bundled TypeScript version ${ts.version}`\n    );\n\n    try {\n      const typescriptPath: string = resolve.sync('typescript', {\n        basedir: extractorConfig.projectFolder,\n        preserveSymlinks: false\n      });\n      const packageJsonLookup: PackageJsonLookup = new PackageJsonLookup();\n      const packageJson: INodePackageJson | undefined =\n        packageJsonLookup.tryLoadNodePackageJsonFor(typescriptPath);\n      if (packageJson && packageJson.version && semver.valid(packageJson.version)) {\n        // Consider a newer MINOR release to be incompatible\n        const ourMajor: number = semver.major(ts.version);\n        const ourMinor: number = semver.minor(ts.version);\n\n        const theirMajor: number = semver.major(packageJson.version);\n        const theirMinor: number = semver.minor(packageJson.version);\n\n        if (theirMajor > ourMajor || (theirMajor === ourMajor && theirMinor > ourMinor)) {\n          messageRouter.logInfo(\n            ConsoleMessageId.CompilerVersionNotice,\n            `*** The target project appears to use TypeScript ${packageJson.version} which is newer than the` +\n              ` bundled compiler engine; consider upgrading API Extractor.`\n          );\n        }\n      }\n    } catch (e) {\n      // The compiler detection heuristic is not expected to work in many configurations\n    }\n  }\n\n  private static _generateRollupDtsFile(\n    collector: Collector,\n    outputPath: string,\n    dtsKind: DtsRollupKind,\n    newlineKind: NewlineKind\n  ): void {\n    if (outputPath !== '') {\n      collector.messageRouter.logVerbose(\n        ConsoleMessageId.WritingDtsRollup,\n        `Writing package typings: ${outputPath}`\n      );\n      DtsRollupGenerator.writeTypingsFile(collector, outputPath, dtsKind, newlineKind);\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"Extractor.js","sourceRoot":"","sources":["../../src/api/Extractor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as semver from 'semver';\r\nimport * as ts from 'typescript';\r\nimport * as resolve from 'resolve';\r\nimport {\r\n  FileSystem,\r\n  type NewlineKind,\r\n  PackageJsonLookup,\r\n  type IPackageJson,\r\n  type INodePackageJson,\r\n  Path\r\n} from '@rushstack/node-core-library';\r\n\r\nimport { ExtractorConfig } from './ExtractorConfig';\r\nimport { Collector } from '../collector/Collector';\r\nimport { DtsRollupGenerator, DtsRollupKind } from '../generators/DtsRollupGenerator';\r\nimport { ApiModelGenerator } from '../generators/ApiModelGenerator';\r\nimport type { ApiPackage } from '@microsoft/api-extractor-model';\r\nimport { ApiReportGenerator } from '../generators/ApiReportGenerator';\r\nimport { PackageMetadataManager } from '../analyzer/PackageMetadataManager';\r\nimport { ValidationEnhancer } from '../enhancers/ValidationEnhancer';\r\nimport { DocCommentEnhancer } from '../enhancers/DocCommentEnhancer';\r\nimport { CompilerState } from './CompilerState';\r\nimport type { ExtractorMessage } from './ExtractorMessage';\r\nimport { MessageRouter } from '../collector/MessageRouter';\r\nimport { ConsoleMessageId } from './ConsoleMessageId';\r\nimport { TSDocConfigFile } from '@microsoft/tsdoc-config';\r\nimport { SourceMapper } from '../collector/SourceMapper';\r\n\r\n/**\r\n * Runtime options for Extractor.\r\n *\r\n * @public\r\n */\r\nexport interface IExtractorInvokeOptions {\r\n  /**\r\n   * An optional TypeScript compiler state.  This allows an optimization where multiple invocations of API Extractor\r\n   * can reuse the same TypeScript compiler analysis.\r\n   */\r\n  compilerState?: CompilerState;\r\n\r\n  /**\r\n   * Indicates that API Extractor is running as part of a local build, e.g. on developer's\r\n   * machine.\r\n   *\r\n   * @remarks\r\n   * This disables certain validation that would normally be performed for a ship/production build. For example,\r\n   * the *.api.md report file is automatically updated in a local build.\r\n   *\r\n   * The default value is false.\r\n   */\r\n  localBuild?: boolean;\r\n\r\n  /**\r\n   * If true, API Extractor will include {@link ExtractorLogLevel.Verbose} messages in its output.\r\n   */\r\n  showVerboseMessages?: boolean;\r\n\r\n  /**\r\n   * If true, API Extractor will print diagnostic information used for troubleshooting problems.\r\n   * These messages will be included as {@link ExtractorLogLevel.Verbose} output.\r\n   *\r\n   * @remarks\r\n   * Setting `showDiagnostics=true` forces `showVerboseMessages=true`.\r\n   */\r\n  showDiagnostics?: boolean;\r\n\r\n  /**\r\n   * Specifies an alternate folder path to be used when loading the TypeScript system typings.\r\n   *\r\n   * @remarks\r\n   * API Extractor uses its own TypeScript compiler engine to analyze your project.  If your project\r\n   * is built with a significantly different TypeScript version, sometimes API Extractor may report compilation\r\n   * errors due to differences in the system typings (e.g. lib.dom.d.ts).  You can use the \"--typescriptCompilerFolder\"\r\n   * option to specify the folder path where you installed the TypeScript package, and API Extractor's compiler will\r\n   * use those system typings instead.\r\n   */\r\n  typescriptCompilerFolder?: string;\r\n\r\n  /**\r\n   * An optional callback function that will be called for each `ExtractorMessage` before it is displayed by\r\n   * API Extractor.  The callback can customize the message, handle it, or discard it.\r\n   *\r\n   * @remarks\r\n   * If a `messageCallback` is not provided, then by default API Extractor will print the messages to\r\n   * the STDERR/STDOUT console.\r\n   */\r\n  messageCallback?: (message: ExtractorMessage) => void;\r\n}\r\n\r\n/**\r\n * This object represents the outcome of an invocation of API Extractor.\r\n *\r\n * @public\r\n */\r\nexport class ExtractorResult {\r\n  /**\r\n   * The TypeScript compiler state that was used.\r\n   */\r\n  public readonly compilerState: CompilerState;\r\n\r\n  /**\r\n   * The API Extractor configuration that was used.\r\n   */\r\n  public readonly extractorConfig: ExtractorConfig;\r\n\r\n  /**\r\n   * Whether the invocation of API Extractor was successful.  For example, if `succeeded` is false, then the build task\r\n   * would normally return a nonzero process exit code, indicating that the operation failed.\r\n   *\r\n   * @remarks\r\n   *\r\n   * Normally the operation \"succeeds\" if `errorCount` and `warningCount` are both zero.  However if\r\n   * {@link IExtractorInvokeOptions.localBuild} is `true`, then the operation \"succeeds\" if `errorCount` is zero\r\n   * (i.e. warnings are ignored).\r\n   */\r\n  public readonly succeeded: boolean;\r\n\r\n  /**\r\n   * Returns true if the API report was found to have changed.\r\n   */\r\n  public readonly apiReportChanged: boolean;\r\n\r\n  /**\r\n   * Reports the number of errors encountered during analysis.\r\n   *\r\n   * @remarks\r\n   * This does not count exceptions, where unexpected issues prematurely abort the operation.\r\n   */\r\n  public readonly errorCount: number;\r\n\r\n  /**\r\n   * Reports the number of warnings encountered during analysis.\r\n   *\r\n   * @remarks\r\n   * This does not count warnings that are emitted in the API report file.\r\n   */\r\n  public readonly warningCount: number;\r\n\r\n  /** @internal */\r\n  public constructor(properties: ExtractorResult) {\r\n    this.compilerState = properties.compilerState;\r\n    this.extractorConfig = properties.extractorConfig;\r\n    this.succeeded = properties.succeeded;\r\n    this.apiReportChanged = properties.apiReportChanged;\r\n    this.errorCount = properties.errorCount;\r\n    this.warningCount = properties.warningCount;\r\n  }\r\n}\r\n\r\n/**\r\n * The starting point for invoking the API Extractor tool.\r\n * @public\r\n */\r\nexport class Extractor {\r\n  /**\r\n   * Returns the version number of the API Extractor NPM package.\r\n   */\r\n  public static get version(): string {\r\n    return Extractor._getPackageJson().version;\r\n  }\r\n\r\n  /**\r\n   * Returns the package name of the API Extractor NPM package.\r\n   */\r\n  public static get packageName(): string {\r\n    return Extractor._getPackageJson().name;\r\n  }\r\n\r\n  private static _getPackageJson(): IPackageJson {\r\n    return PackageJsonLookup.loadOwnPackageJson(__dirname);\r\n  }\r\n\r\n  /**\r\n   * Load the api-extractor.json config file from the specified path, and then invoke API Extractor.\r\n   */\r\n  public static loadConfigAndInvoke(\r\n    configFilePath: string,\r\n    options?: IExtractorInvokeOptions\r\n  ): ExtractorResult {\r\n    const extractorConfig: ExtractorConfig = ExtractorConfig.loadFileAndPrepare(configFilePath);\r\n\r\n    return Extractor.invoke(extractorConfig, options);\r\n  }\r\n\r\n  /**\r\n   * Invoke API Extractor using an already prepared `ExtractorConfig` object.\r\n   */\r\n  public static invoke(extractorConfig: ExtractorConfig, options?: IExtractorInvokeOptions): ExtractorResult {\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    const localBuild: boolean = options.localBuild || false;\r\n\r\n    let compilerState: CompilerState | undefined;\r\n    if (options.compilerState) {\r\n      compilerState = options.compilerState;\r\n    } else {\r\n      compilerState = CompilerState.create(extractorConfig, options);\r\n    }\r\n\r\n    const sourceMapper: SourceMapper = new SourceMapper();\r\n\r\n    const messageRouter: MessageRouter = new MessageRouter({\r\n      workingPackageFolder: extractorConfig.packageFolder,\r\n      messageCallback: options.messageCallback,\r\n      messagesConfig: extractorConfig.messages || {},\r\n      showVerboseMessages: !!options.showVerboseMessages,\r\n      showDiagnostics: !!options.showDiagnostics,\r\n      tsdocConfiguration: extractorConfig.tsdocConfiguration,\r\n      sourceMapper\r\n    });\r\n\r\n    if (extractorConfig.tsdocConfigFile.filePath && !extractorConfig.tsdocConfigFile.fileNotFound) {\r\n      if (!Path.isEqual(extractorConfig.tsdocConfigFile.filePath, ExtractorConfig._tsdocBaseFilePath)) {\r\n        messageRouter.logVerbose(\r\n          ConsoleMessageId.UsingCustomTSDocConfig,\r\n          'Using custom TSDoc config from ' + extractorConfig.tsdocConfigFile.filePath\r\n        );\r\n      }\r\n    }\r\n\r\n    this._checkCompilerCompatibility(extractorConfig, messageRouter);\r\n\r\n    if (messageRouter.showDiagnostics) {\r\n      messageRouter.logDiagnostic('');\r\n      messageRouter.logDiagnosticHeader('Final prepared ExtractorConfig');\r\n      messageRouter.logDiagnostic(extractorConfig.getDiagnosticDump());\r\n      messageRouter.logDiagnosticFooter();\r\n\r\n      messageRouter.logDiagnosticHeader('Compiler options');\r\n      const serializedCompilerOptions: object = MessageRouter.buildJsonDumpObject(\r\n        (compilerState.program as ts.Program).getCompilerOptions()\r\n      );\r\n      messageRouter.logDiagnostic(JSON.stringify(serializedCompilerOptions, undefined, 2));\r\n      messageRouter.logDiagnosticFooter();\r\n\r\n      messageRouter.logDiagnosticHeader('TSDoc configuration');\r\n      // Convert the TSDocConfiguration into a tsdoc.json representation\r\n      const combinedConfigFile: TSDocConfigFile = TSDocConfigFile.loadFromParser(\r\n        extractorConfig.tsdocConfiguration\r\n      );\r\n      const serializedTSDocConfig: object = MessageRouter.buildJsonDumpObject(\r\n        combinedConfigFile.saveToObject()\r\n      );\r\n      messageRouter.logDiagnostic(JSON.stringify(serializedTSDocConfig, undefined, 2));\r\n      messageRouter.logDiagnosticFooter();\r\n    }\r\n\r\n    const collector: Collector = new Collector({\r\n      program: compilerState.program as ts.Program,\r\n      messageRouter,\r\n      extractorConfig: extractorConfig,\r\n      sourceMapper\r\n    });\r\n\r\n    collector.analyze();\r\n\r\n    DocCommentEnhancer.analyze(collector);\r\n    ValidationEnhancer.analyze(collector);\r\n\r\n    const modelBuilder: ApiModelGenerator = new ApiModelGenerator(collector);\r\n    const apiPackage: ApiPackage = modelBuilder.buildApiPackage();\r\n\r\n    if (messageRouter.showDiagnostics) {\r\n      messageRouter.logDiagnostic(''); // skip a line after any diagnostic messages\r\n    }\r\n\r\n    if (extractorConfig.docModelEnabled) {\r\n      messageRouter.logVerbose(\r\n        ConsoleMessageId.WritingDocModelFile,\r\n        'Writing: ' + extractorConfig.apiJsonFilePath\r\n      );\r\n      apiPackage.saveToJsonFile(extractorConfig.apiJsonFilePath, {\r\n        toolPackage: Extractor.packageName,\r\n        toolVersion: Extractor.version,\r\n\r\n        newlineConversion: extractorConfig.newlineKind,\r\n        ensureFolderExists: true,\r\n        testMode: extractorConfig.testMode\r\n      });\r\n    }\r\n\r\n    let apiReportChanged: boolean = false;\r\n\r\n    if (extractorConfig.apiReportEnabled) {\r\n      const actualApiReportPath: string = extractorConfig.reportTempFilePath;\r\n      const actualApiReportShortPath: string = extractorConfig._getShortFilePath(\r\n        extractorConfig.reportTempFilePath\r\n      );\r\n\r\n      const expectedApiReportPath: string = extractorConfig.reportFilePath;\r\n      const expectedApiReportShortPath: string = extractorConfig._getShortFilePath(\r\n        extractorConfig.reportFilePath\r\n      );\r\n\r\n      const actualApiReportContent: string = ApiReportGenerator.generateReviewFileContent(collector);\r\n\r\n      // Write the actual file\r\n      FileSystem.writeFile(actualApiReportPath, actualApiReportContent, {\r\n        ensureFolderExists: true,\r\n        convertLineEndings: extractorConfig.newlineKind\r\n      });\r\n\r\n      // Compare it against the expected file\r\n      if (FileSystem.exists(expectedApiReportPath)) {\r\n        const expectedApiReportContent: string = FileSystem.readFile(expectedApiReportPath);\r\n\r\n        if (\r\n          !ApiReportGenerator.areEquivalentApiFileContents(actualApiReportContent, expectedApiReportContent)\r\n        ) {\r\n          apiReportChanged = true;\r\n\r\n          if (!localBuild) {\r\n            // For a production build, issue a warning that will break the CI build.\r\n            messageRouter.logWarning(\r\n              ConsoleMessageId.ApiReportNotCopied,\r\n              'You have changed the public API signature for this project.' +\r\n                ` Please copy the file \"${actualApiReportShortPath}\" to \"${expectedApiReportShortPath}\",` +\r\n                ` or perform a local build (which does this automatically).` +\r\n                ` See the Git repo documentation for more info.`\r\n            );\r\n          } else {\r\n            // For a local build, just copy the file automatically.\r\n            messageRouter.logWarning(\r\n              ConsoleMessageId.ApiReportCopied,\r\n              'You have changed the public API signature for this project.' +\r\n                ` Updating ${expectedApiReportShortPath}`\r\n            );\r\n\r\n            FileSystem.writeFile(expectedApiReportPath, actualApiReportContent, {\r\n              ensureFolderExists: true,\r\n              convertLineEndings: extractorConfig.newlineKind\r\n            });\r\n          }\r\n        } else {\r\n          messageRouter.logVerbose(\r\n            ConsoleMessageId.ApiReportUnchanged,\r\n            `The API report is up to date: ${actualApiReportShortPath}`\r\n          );\r\n        }\r\n      } else {\r\n        // The target file does not exist, so we are setting up the API review file for the first time.\r\n        //\r\n        // NOTE: People sometimes make a mistake where they move a project and forget to update the \"reportFolder\"\r\n        // setting, which causes a new file to silently get written to the wrong place.  This can be confusing.\r\n        // Thus we treat the initial creation of the file specially.\r\n        apiReportChanged = true;\r\n\r\n        if (!localBuild) {\r\n          // For a production build, issue a warning that will break the CI build.\r\n          messageRouter.logWarning(\r\n            ConsoleMessageId.ApiReportNotCopied,\r\n            'The API report file is missing.' +\r\n              ` Please copy the file \"${actualApiReportShortPath}\" to \"${expectedApiReportShortPath}\",` +\r\n              ` or perform a local build (which does this automatically).` +\r\n              ` See the Git repo documentation for more info.`\r\n          );\r\n        } else {\r\n          const expectedApiReportFolder: string = path.dirname(expectedApiReportPath);\r\n          if (!FileSystem.exists(expectedApiReportFolder)) {\r\n            messageRouter.logError(\r\n              ConsoleMessageId.ApiReportFolderMissing,\r\n              'Unable to create the API report file. Please make sure the target folder exists:\\n' +\r\n                expectedApiReportFolder\r\n            );\r\n          } else {\r\n            FileSystem.writeFile(expectedApiReportPath, actualApiReportContent, {\r\n              convertLineEndings: extractorConfig.newlineKind\r\n            });\r\n            messageRouter.logWarning(\r\n              ConsoleMessageId.ApiReportCreated,\r\n              'The API report file was missing, so a new file was created. Please add this file to Git:\\n' +\r\n                expectedApiReportPath\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (extractorConfig.rollupEnabled) {\r\n      Extractor._generateRollupDtsFile(\r\n        collector,\r\n        extractorConfig.publicTrimmedFilePath,\r\n        DtsRollupKind.PublicRelease,\r\n        extractorConfig.newlineKind\r\n      );\r\n      Extractor._generateRollupDtsFile(\r\n        collector,\r\n        extractorConfig.alphaTrimmedFilePath,\r\n        DtsRollupKind.AlphaRelease,\r\n        extractorConfig.newlineKind\r\n      );\r\n      Extractor._generateRollupDtsFile(\r\n        collector,\r\n        extractorConfig.betaTrimmedFilePath,\r\n        DtsRollupKind.BetaRelease,\r\n        extractorConfig.newlineKind\r\n      );\r\n      Extractor._generateRollupDtsFile(\r\n        collector,\r\n        extractorConfig.untrimmedFilePath,\r\n        DtsRollupKind.InternalRelease,\r\n        extractorConfig.newlineKind\r\n      );\r\n    }\r\n\r\n    if (extractorConfig.tsdocMetadataEnabled) {\r\n      // Write the tsdoc-metadata.json file for this project\r\n      PackageMetadataManager.writeTsdocMetadataFile(\r\n        extractorConfig.tsdocMetadataFilePath,\r\n        extractorConfig.newlineKind\r\n      );\r\n    }\r\n\r\n    // Show all the messages that we collected during analysis\r\n    messageRouter.handleRemainingNonConsoleMessages();\r\n\r\n    // Determine success\r\n    let succeeded: boolean;\r\n    if (localBuild) {\r\n      // For a local build, fail if there were errors (but ignore warnings)\r\n      succeeded = messageRouter.errorCount === 0;\r\n    } else {\r\n      // For a production build, fail if there were any errors or warnings\r\n      succeeded = messageRouter.errorCount + messageRouter.warningCount === 0;\r\n    }\r\n\r\n    return new ExtractorResult({\r\n      compilerState,\r\n      extractorConfig,\r\n      succeeded,\r\n      apiReportChanged,\r\n      errorCount: messageRouter.errorCount,\r\n      warningCount: messageRouter.warningCount\r\n    });\r\n  }\r\n\r\n  private static _checkCompilerCompatibility(\r\n    extractorConfig: ExtractorConfig,\r\n    messageRouter: MessageRouter\r\n  ): void {\r\n    messageRouter.logInfo(\r\n      ConsoleMessageId.Preamble,\r\n      `Analysis will use the bundled TypeScript version ${ts.version}`\r\n    );\r\n\r\n    try {\r\n      const typescriptPath: string = resolve.sync('typescript', {\r\n        basedir: extractorConfig.projectFolder,\r\n        preserveSymlinks: false\r\n      });\r\n      const packageJsonLookup: PackageJsonLookup = new PackageJsonLookup();\r\n      const packageJson: INodePackageJson | undefined =\r\n        packageJsonLookup.tryLoadNodePackageJsonFor(typescriptPath);\r\n      if (packageJson && packageJson.version && semver.valid(packageJson.version)) {\r\n        // Consider a newer MINOR release to be incompatible\r\n        const ourMajor: number = semver.major(ts.version);\r\n        const ourMinor: number = semver.minor(ts.version);\r\n\r\n        const theirMajor: number = semver.major(packageJson.version);\r\n        const theirMinor: number = semver.minor(packageJson.version);\r\n\r\n        if (theirMajor > ourMajor || (theirMajor === ourMajor && theirMinor > ourMinor)) {\r\n          messageRouter.logInfo(\r\n            ConsoleMessageId.CompilerVersionNotice,\r\n            `*** The target project appears to use TypeScript ${packageJson.version} which is newer than the` +\r\n              ` bundled compiler engine; consider upgrading API Extractor.`\r\n          );\r\n        }\r\n      }\r\n    } catch (e) {\r\n      // The compiler detection heuristic is not expected to work in many configurations\r\n    }\r\n  }\r\n\r\n  private static _generateRollupDtsFile(\r\n    collector: Collector,\r\n    outputPath: string,\r\n    dtsKind: DtsRollupKind,\r\n    newlineKind: NewlineKind\r\n  ): void {\r\n    if (outputPath !== '') {\r\n      collector.messageRouter.logVerbose(\r\n        ConsoleMessageId.WritingDtsRollup,\r\n        `Writing package typings: ${outputPath}`\r\n      );\r\n      DtsRollupGenerator.writeTypingsFile(collector, outputPath, dtsKind, newlineKind);\r\n    }\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/api/ExtractorConfig.d.ts b/lib/api/ExtractorConfig.d.ts
index c2d95c0819e995e8096e8b5dae118603039c3ed4..7044942276cf1dad94fb584bda1be6cdfff598b2 100644
--- a/lib/api/ExtractorConfig.d.ts
+++ b/lib/api/ExtractorConfig.d.ts
@@ -109,6 +109,7 @@ export declare class ExtractorConfig {
      */
     static readonly _tsdocBaseFilePath: string;
     private static readonly _defaultConfig;
+    /** Match all three flavors for type declaration files (.d.ts, .d.mts, .d.cts) */
     private static readonly _declarationFileExtensionRegExp;
     /** {@inheritDoc IConfigFile.projectFolder} */
     readonly projectFolder: string;
diff --git a/lib/api/ExtractorConfig.d.ts.map b/lib/api/ExtractorConfig.d.ts.map
index 97cc85e0fd49d41c9d56780077280535c1fedfa7..790ebf3f26fa5661e1ce18ef201a46cd079b9dca 100644
--- a/lib/api/ExtractorConfig.d.ts.map
+++ b/lib/api/ExtractorConfig.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"ExtractorConfig.d.ts","sourceRoot":"","sources":["../../src/api/ExtractorConfig.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"ExtractorConfig.d.ts","sourceRoot":"","sources":["../../src/api/ExtractorConfig.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/lib/api/ExtractorConfig.js b/lib/api/ExtractorConfig.js
index 76604a00e7e6a1028db6803ab38bdb45d2b5d395..a77a27a0512cf2ba080f4b75ad599685dc3f65c7 100644
--- a/lib/api/ExtractorConfig.js
+++ b/lib/api/ExtractorConfig.js
@@ -448,11 +448,8 @@ class ExtractorConfig {
                 throw new Error('The "mainEntryPointFilePath" path does not exist: ' + mainEntryPointFilePath);
             }
             const bundledPackages = configObject.bundledPackages || [];
-            for (const bundledPackage of bundledPackages) {
-                if (!node_core_library_1.PackageName.isValidName(bundledPackage)) {
-                    throw new Error(`The "bundledPackages" list contains an invalid package name: "${bundledPackage}"`);
-                }
-            }
+            // Note: we cannot fully validate package name pattern, as the string may be a RegExp pattern.
+            // We won't know if the entries are valid until we can compare them against the package.json "dependencies" contents.
             const tsconfigFilePath = ExtractorConfig._resolvePathWithTokens('tsconfigFilePath', configObject.compiler.tsconfigFilePath, tokenContext);
             if (configObject.compiler.overrideTsconfig === undefined) {
                 if (!tsconfigFilePath) {
@@ -672,6 +669,7 @@ ExtractorConfig.FILENAME = 'api-extractor.json';
  */
 ExtractorConfig._tsdocBaseFilePath = path.resolve(__dirname, '../../extends/tsdoc-base.json');
 ExtractorConfig._defaultConfig = node_core_library_1.JsonFile.load(path.join(__dirname, '../schemas/api-extractor-defaults.json'));
+/** Match all three flavors for type declaration files (.d.ts, .d.mts, .d.cts) */
 ExtractorConfig._declarationFileExtensionRegExp = /\.d\.(c|m)?ts$/i;
 exports.ExtractorConfig = ExtractorConfig;
 //# sourceMappingURL=ExtractorConfig.js.map
\ No newline at end of file
diff --git a/lib/api/ExtractorConfig.js.map b/lib/api/ExtractorConfig.js.map
index 150ed244b28cf68ae18e021addfddf0a92ae8ea1..a8dbbd17fc417f118eb819216d00b2f9258f2852 100644
--- a/lib/api/ExtractorConfig.js.map
+++ b/lib/api/ExtractorConfig.js.map
@@ -1 +1 @@
-{"version":3,"file":"ExtractorConfig.js","sourceRoot":"","sources":["../../src/api/ExtractorConfig.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport * as resolve from 'resolve';\nimport lodash = require('lodash');\nimport {\n  JsonFile,\n  JsonSchema,\n  FileSystem,\n  PackageJsonLookup,\n  type INodePackageJson,\n  PackageName,\n  Text,\n  InternalError,\n  Path,\n  NewlineKind\n} from '@rushstack/node-core-library';\nimport { type IRigConfig, RigConfig } from '@rushstack/rig-package';\n\nimport type { IConfigFile, IExtractorMessagesConfig } from './IConfigFile';\nimport { PackageMetadataManager } from '../analyzer/PackageMetadataManager';\nimport { MessageRouter } from '../collector/MessageRouter';\nimport { EnumMemberOrder } from '@microsoft/api-extractor-model';\nimport { TSDocConfiguration } from '@microsoft/tsdoc';\nimport { TSDocConfigFile } from '@microsoft/tsdoc-config';\n\nimport apiExtractorSchema from '../schemas/api-extractor.schema.json';\n\n/**\n * Tokens used during variable expansion of path fields from api-extractor.json.\n */\ninterface IExtractorConfigTokenContext {\n  /**\n   * The `<unscopedPackageName>` token returns the project's NPM package name, without any NPM scope.\n   * If there is no associated package.json file, then the value is `unknown-package`.\n   *\n   * Example: `my-project`\n   */\n  unscopedPackageName: string;\n\n  /**\n   * The `<packageName>` token returns the project's full NPM package name including any NPM scope.\n   * If there is no associated package.json file, then the value is `unknown-package`.\n   *\n   * Example: `@scope/my-project`\n   */\n  packageName: string;\n\n  /**\n   * The `<projectFolder>` token returns the expanded `\"projectFolder\"` setting from api-extractor.json.\n   */\n  projectFolder: string;\n}\n\n/**\n * Options for {@link ExtractorConfig.tryLoadForFolder}.\n *\n * @public\n */\nexport interface IExtractorConfigLoadForFolderOptions {\n  /**\n   * The folder path to start from when searching for api-extractor.json.\n   */\n  startingFolder: string;\n\n  /**\n   * An already constructed `PackageJsonLookup` cache object to use.  If omitted, a temporary one will\n   * be constructed.\n   */\n  packageJsonLookup?: PackageJsonLookup;\n\n  /**\n   * An already constructed `RigConfig` object.  If omitted, then a new `RigConfig` object will be constructed.\n   */\n  rigConfig?: IRigConfig;\n}\n\n/**\n * Options for {@link ExtractorConfig.prepare}.\n *\n * @public\n */\nexport interface IExtractorConfigPrepareOptions {\n  /**\n   * A configuration object as returned by {@link ExtractorConfig.loadFile}.\n   */\n  configObject: IConfigFile;\n\n  /**\n   * The absolute path of the file that the `configObject` object was loaded from.  This is used for error messages\n   * and when probing for `tsconfig.json`.\n   *\n   * @remarks\n   *\n   * If `configObjectFullPath` and `projectFolderLookupToken` are both unspecified, then the api-extractor.json\n   * config file must explicitly specify a `projectFolder` setting rather than relying on the `<lookup>` token.\n   */\n  configObjectFullPath: string | undefined;\n\n  /**\n   * The parsed package.json file for the working package, or undefined if API Extractor was invoked without\n   * a package.json file.\n   *\n   * @remarks\n   *\n   * If omitted, then the `<unscopedPackageName>` and `<packageName>` tokens will have default values.\n   */\n  packageJson?: INodePackageJson | undefined;\n\n  /**\n   * The absolute path of the file that the `packageJson` object was loaded from, or undefined if API Extractor\n   * was invoked without a package.json file.\n   *\n   * @remarks\n   *\n   * This is used for error messages and when resolving paths found in package.json.\n   *\n   * If `packageJsonFullPath` is specified but `packageJson` is omitted, the file will be loaded automatically.\n   */\n  packageJsonFullPath: string | undefined;\n\n  /**\n   * The default value for the `projectFolder` setting is the `<lookup>` token, which uses a heuristic to guess\n   * an appropriate project folder.  Use `projectFolderLookupValue` to manually specify the `<lookup>` token value\n   * instead.\n   *\n   * @remarks\n   * If the `projectFolder` setting is explicitly specified in api-extractor.json file, it should take precedence\n   * over a value specified via the API.  Thus the `projectFolderLookupToken` option provides a way to override\n   * the default value for `projectFolder` setting while still honoring a manually specified value.\n   */\n  projectFolderLookupToken?: string;\n\n  /**\n   * Allow customization of the tsdoc.json config file.  If omitted, this file will be loaded from its default\n   * location.  If the file does not exist, then the standard definitions will be used from\n   * `@microsoft/api-extractor/extends/tsdoc-base.json`.\n   */\n  tsdocConfigFile?: TSDocConfigFile;\n\n  /**\n   * When preparing the configuration object, folder and file paths referenced in the configuration are checked\n   * for existence, and an error is reported if they are not found.  This option can be used to disable this\n   * check for the main entry point module. This may be useful when preparing a configuration file for an\n   * un-built project.\n   */\n  ignoreMissingEntryPoint?: boolean;\n}\n\ninterface IExtractorConfigParameters {\n  projectFolder: string;\n  packageJson: INodePackageJson | undefined;\n  packageFolder: string | undefined;\n  mainEntryPointFilePath: string;\n  bundledPackages: string[];\n  tsconfigFilePath: string;\n  overrideTsconfig: {} | undefined;\n  skipLibCheck: boolean;\n  apiReportEnabled: boolean;\n  reportFilePath: string;\n  reportTempFilePath: string;\n  apiReportIncludeForgottenExports: boolean;\n  docModelEnabled: boolean;\n  apiJsonFilePath: string;\n  docModelIncludeForgottenExports: boolean;\n  projectFolderUrl: string | undefined;\n  rollupEnabled: boolean;\n  untrimmedFilePath: string;\n  alphaTrimmedFilePath: string;\n  betaTrimmedFilePath: string;\n  publicTrimmedFilePath: string;\n  omitTrimmingComments: boolean;\n  tsdocMetadataEnabled: boolean;\n  tsdocMetadataFilePath: string;\n  tsdocConfigFile: TSDocConfigFile;\n  tsdocConfiguration: TSDocConfiguration;\n  newlineKind: NewlineKind;\n  messages: IExtractorMessagesConfig;\n  testMode: boolean;\n  enumMemberOrder: EnumMemberOrder;\n}\n\n/**\n * The `ExtractorConfig` class loads, validates, interprets, and represents the api-extractor.json config file.\n * @public\n */\nexport class ExtractorConfig {\n  /**\n   * The JSON Schema for API Extractor config file (api-extractor.schema.json).\n   */\n  public static readonly jsonSchema: JsonSchema = JsonSchema.fromLoadedObject(apiExtractorSchema);\n\n  /**\n   * The config file name \"api-extractor.json\".\n   */\n  public static readonly FILENAME: 'api-extractor.json' = 'api-extractor.json';\n\n  /**\n   * The full path to `extends/tsdoc-base.json` which contains the standard TSDoc configuration\n   * for API Extractor.\n   * @internal\n   */\n  public static readonly _tsdocBaseFilePath: string = path.resolve(\n    __dirname,\n    '../../extends/tsdoc-base.json'\n  );\n\n  private static readonly _defaultConfig: Partial<IConfigFile> = JsonFile.load(\n    path.join(__dirname, '../schemas/api-extractor-defaults.json')\n  );\n\n  private static readonly _declarationFileExtensionRegExp: RegExp = /\\.d\\.(c|m)?ts$/i;\n\n  /** {@inheritDoc IConfigFile.projectFolder} */\n  public readonly projectFolder: string;\n\n  /**\n   * The parsed package.json file for the working package, or undefined if API Extractor was invoked without\n   * a package.json file.\n   */\n  public readonly packageJson: INodePackageJson | undefined;\n\n  /**\n   * The absolute path of the folder containing the package.json file for the working package, or undefined\n   * if API Extractor was invoked without a package.json file.\n   */\n  public readonly packageFolder: string | undefined;\n\n  /** {@inheritDoc IConfigFile.mainEntryPointFilePath} */\n  public readonly mainEntryPointFilePath: string;\n\n  /** {@inheritDoc IConfigFile.bundledPackages} */\n  public readonly bundledPackages: string[];\n\n  /** {@inheritDoc IConfigCompiler.tsconfigFilePath} */\n  public readonly tsconfigFilePath: string;\n\n  /** {@inheritDoc IConfigCompiler.overrideTsconfig} */\n  public readonly overrideTsconfig: {} | undefined;\n\n  /** {@inheritDoc IConfigCompiler.skipLibCheck} */\n  public readonly skipLibCheck: boolean;\n\n  /** {@inheritDoc IConfigApiReport.enabled} */\n  public readonly apiReportEnabled: boolean;\n\n  /** The `reportFolder` path combined with the `reportFileName`. */\n  public readonly reportFilePath: string;\n  /** The `reportTempFolder` path combined with the `reportFileName`. */\n  public readonly reportTempFilePath: string;\n  /** {@inheritDoc IConfigApiReport.includeForgottenExports} */\n  public readonly apiReportIncludeForgottenExports: boolean;\n\n  /** {@inheritDoc IConfigDocModel.enabled} */\n  public readonly docModelEnabled: boolean;\n  /** {@inheritDoc IConfigDocModel.apiJsonFilePath} */\n  public readonly apiJsonFilePath: string;\n  /** {@inheritDoc IConfigDocModel.includeForgottenExports} */\n  public readonly docModelIncludeForgottenExports: boolean;\n  /** {@inheritDoc IConfigDocModel.projectFolderUrl} */\n  public readonly projectFolderUrl: string | undefined;\n\n  /** {@inheritDoc IConfigDtsRollup.enabled} */\n  public readonly rollupEnabled: boolean;\n  /** {@inheritDoc IConfigDtsRollup.untrimmedFilePath} */\n  public readonly untrimmedFilePath: string;\n  /** {@inheritDoc IConfigDtsRollup.alphaTrimmedFilePath} */\n  public readonly alphaTrimmedFilePath: string;\n  /** {@inheritDoc IConfigDtsRollup.betaTrimmedFilePath} */\n  public readonly betaTrimmedFilePath: string;\n  /** {@inheritDoc IConfigDtsRollup.publicTrimmedFilePath} */\n  public readonly publicTrimmedFilePath: string;\n  /** {@inheritDoc IConfigDtsRollup.omitTrimmingComments} */\n  public readonly omitTrimmingComments: boolean;\n\n  /** {@inheritDoc IConfigTsdocMetadata.enabled} */\n  public readonly tsdocMetadataEnabled: boolean;\n  /** {@inheritDoc IConfigTsdocMetadata.tsdocMetadataFilePath} */\n  public readonly tsdocMetadataFilePath: string;\n\n  /**\n   * The tsdoc.json configuration that will be used when parsing doc comments.\n   */\n  public readonly tsdocConfigFile: TSDocConfigFile;\n\n  /**\n   * The `TSDocConfiguration` loaded from {@link ExtractorConfig.tsdocConfigFile}.\n   */\n  public readonly tsdocConfiguration: TSDocConfiguration;\n\n  /**\n   * Specifies what type of newlines API Extractor should use when writing output files.  By default, the output files\n   * will be written with Windows-style newlines.\n   */\n  public readonly newlineKind: NewlineKind;\n\n  /** {@inheritDoc IConfigFile.messages} */\n  public readonly messages: IExtractorMessagesConfig;\n\n  /** {@inheritDoc IConfigFile.testMode} */\n  public readonly testMode: boolean;\n\n  /** {@inheritDoc IConfigFile.enumMemberOrder} */\n  public readonly enumMemberOrder: EnumMemberOrder;\n\n  private constructor(parameters: IExtractorConfigParameters) {\n    this.projectFolder = parameters.projectFolder;\n    this.packageJson = parameters.packageJson;\n    this.packageFolder = parameters.packageFolder;\n    this.mainEntryPointFilePath = parameters.mainEntryPointFilePath;\n    this.bundledPackages = parameters.bundledPackages;\n    this.tsconfigFilePath = parameters.tsconfigFilePath;\n    this.overrideTsconfig = parameters.overrideTsconfig;\n    this.skipLibCheck = parameters.skipLibCheck;\n    this.apiReportEnabled = parameters.apiReportEnabled;\n    this.reportFilePath = parameters.reportFilePath;\n    this.reportTempFilePath = parameters.reportTempFilePath;\n    this.apiReportIncludeForgottenExports = parameters.apiReportIncludeForgottenExports;\n    this.docModelEnabled = parameters.docModelEnabled;\n    this.apiJsonFilePath = parameters.apiJsonFilePath;\n    this.docModelIncludeForgottenExports = parameters.docModelIncludeForgottenExports;\n    this.projectFolderUrl = parameters.projectFolderUrl;\n    this.rollupEnabled = parameters.rollupEnabled;\n    this.untrimmedFilePath = parameters.untrimmedFilePath;\n    this.alphaTrimmedFilePath = parameters.alphaTrimmedFilePath;\n    this.betaTrimmedFilePath = parameters.betaTrimmedFilePath;\n    this.publicTrimmedFilePath = parameters.publicTrimmedFilePath;\n    this.omitTrimmingComments = parameters.omitTrimmingComments;\n    this.tsdocMetadataEnabled = parameters.tsdocMetadataEnabled;\n    this.tsdocMetadataFilePath = parameters.tsdocMetadataFilePath;\n    this.tsdocConfigFile = parameters.tsdocConfigFile;\n    this.tsdocConfiguration = parameters.tsdocConfiguration;\n    this.newlineKind = parameters.newlineKind;\n    this.messages = parameters.messages;\n    this.testMode = parameters.testMode;\n    this.enumMemberOrder = parameters.enumMemberOrder;\n  }\n\n  /**\n   * Returns a JSON-like string representing the `ExtractorConfig` state, which can be printed to a console\n   * for diagnostic purposes.\n   *\n   * @remarks\n   * This is used by the \"--diagnostics\" command-line option.  The string is not intended to be deserialized;\n   * its format may be changed at any time.\n   */\n  public getDiagnosticDump(): string {\n    // Handle the simple JSON-serializable properties using buildJsonDumpObject()\n    const result: object = MessageRouter.buildJsonDumpObject(this, {\n      keyNamesToOmit: ['tsdocConfigFile', 'tsdocConfiguration']\n    });\n\n    // Implement custom formatting for tsdocConfigFile and tsdocConfiguration\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (result as any).tsdocConfigFile = {\n      filePath: this.tsdocConfigFile.filePath,\n      log: this.tsdocConfigFile.log.messages.map((x) => x.toString())\n    };\n\n    return JSON.stringify(result, undefined, 2);\n  }\n\n  /**\n   * Returns a simplified file path for use in error messages.\n   * @internal\n   */\n  public _getShortFilePath(absolutePath: string): string {\n    if (!path.isAbsolute(absolutePath)) {\n      throw new InternalError('Expected absolute path: ' + absolutePath);\n    }\n    if (Path.isUnderOrEqual(absolutePath, this.projectFolder)) {\n      return Path.convertToSlashes(path.relative(this.projectFolder, absolutePath));\n    }\n    return absolutePath;\n  }\n\n  /**\n   * Searches for the api-extractor.json config file associated with the specified starting folder,\n   * and loads the file if found.  This lookup supports\n   * {@link https://www.npmjs.com/package/@rushstack/rig-package | rig packages}.\n   *\n   * @remarks\n   * The search will first look for a package.json file in a parent folder of the starting folder;\n   * if found, that will be used as the base folder instead of the starting folder.  If the config\n   * file is not found in `<baseFolder>/api-extractor.json` or `<baseFolder>/config/api-extractor.json`,\n   * then `<baseFolder/config/rig.json` will be checked to see whether a\n   * {@link https://www.npmjs.com/package/@rushstack/rig-package | rig package} is referenced; if so then\n   * the rig's api-extractor.json file will be used instead.  If a config file is found, it will be loaded\n   * and returned with the `IExtractorConfigPrepareOptions` object. Otherwise, `undefined` is returned\n   * to indicate that API Extractor does not appear to be configured for the specified folder.\n   *\n   * @returns An options object that can be passed to {@link ExtractorConfig.prepare}, or `undefined`\n   * if not api-extractor.json file was found.\n   */\n  public static tryLoadForFolder(\n    options: IExtractorConfigLoadForFolderOptions\n  ): IExtractorConfigPrepareOptions | undefined {\n    const packageJsonLookup: PackageJsonLookup = options.packageJsonLookup || new PackageJsonLookup();\n    const startingFolder: string = options.startingFolder;\n\n    // Figure out which project we're in and look for the config file at the project root\n    const packageJsonFullPath: string | undefined =\n      packageJsonLookup.tryGetPackageJsonFilePathFor(startingFolder);\n    const packageFolder: string | undefined = packageJsonFullPath\n      ? path.dirname(packageJsonFullPath)\n      : undefined;\n\n    // If there is no package, then just use the starting folder\n    const baseFolder: string = packageFolder || startingFolder;\n\n    let projectFolderLookupToken: string | undefined = undefined;\n\n    // First try the standard \"config\" subfolder:\n    let configFilename: string = path.join(baseFolder, 'config', ExtractorConfig.FILENAME);\n    if (FileSystem.exists(configFilename)) {\n      if (FileSystem.exists(path.join(baseFolder, ExtractorConfig.FILENAME))) {\n        throw new Error(`Found conflicting ${ExtractorConfig.FILENAME} files in \".\" and \"./config\" folders`);\n      }\n    } else {\n      // Otherwise try the top-level folder\n      configFilename = path.join(baseFolder, ExtractorConfig.FILENAME);\n\n      if (!FileSystem.exists(configFilename)) {\n        // If We didn't find it in <packageFolder>/api-extractor.json or <packageFolder>/config/api-extractor.json\n        // then check for a rig package\n        if (packageFolder) {\n          let rigConfig: IRigConfig;\n          if (options.rigConfig) {\n            // The caller provided an already solved RigConfig.  Double-check that it is for the right project.\n            if (!Path.isEqual(options.rigConfig.projectFolderPath, packageFolder)) {\n              throw new Error(\n                'The provided ILoadForFolderOptions.rigConfig is for the wrong project folder:\\n' +\n                  '\\nExpected path: ' +\n                  packageFolder +\n                  '\\nProvided path: ' +\n                  options.rigConfig.projectFolderOriginalPath\n              );\n            }\n            rigConfig = options.rigConfig;\n          } else {\n            rigConfig = RigConfig.loadForProjectFolder({\n              projectFolderPath: packageFolder\n            });\n          }\n\n          if (rigConfig.rigFound) {\n            configFilename = path.join(rigConfig.getResolvedProfileFolder(), ExtractorConfig.FILENAME);\n\n            // If the \"projectFolder\" setting isn't specified in api-extractor.json, it defaults to the\n            // \"<lookup>\" token which will probe for the tsconfig.json nearest to the api-extractor.json path.\n            // But this won't work if api-extractor.json belongs to the rig.  So instead \"<lookup>\" should be\n            // the \"<packageFolder>\" that referenced the rig.\n            projectFolderLookupToken = packageFolder;\n          }\n        }\n        if (!FileSystem.exists(configFilename)) {\n          // API Extractor does not seem to be configured for this folder\n          return undefined;\n        }\n      }\n    }\n\n    const configObjectFullPath: string = path.resolve(configFilename);\n    const configObject: IConfigFile = ExtractorConfig.loadFile(configObjectFullPath);\n\n    return {\n      configObject,\n      configObjectFullPath,\n      packageJsonFullPath,\n      projectFolderLookupToken\n    };\n  }\n\n  /**\n   * Loads the api-extractor.json config file from the specified file path, and prepares an `ExtractorConfig` object.\n   *\n   * @remarks\n   * Loads the api-extractor.json config file from the specified file path.   If the \"extends\" field is present,\n   * the referenced file(s) will be merged.  For any omitted fields, the API Extractor default values are merged.\n   *\n   * The result is prepared using `ExtractorConfig.prepare()`.\n   */\n  public static loadFileAndPrepare(configJsonFilePath: string): ExtractorConfig {\n    const configObjectFullPath: string = path.resolve(configJsonFilePath);\n    const configObject: IConfigFile = ExtractorConfig.loadFile(configObjectFullPath);\n\n    const packageJsonLookup: PackageJsonLookup = new PackageJsonLookup();\n    const packageJsonFullPath: string | undefined =\n      packageJsonLookup.tryGetPackageJsonFilePathFor(configObjectFullPath);\n\n    const extractorConfig: ExtractorConfig = ExtractorConfig.prepare({\n      configObject,\n      configObjectFullPath,\n      packageJsonFullPath\n    });\n\n    return extractorConfig;\n  }\n\n  /**\n   * Performs only the first half of {@link ExtractorConfig.loadFileAndPrepare}, providing an opportunity to\n   * modify the object before it is passed to {@link ExtractorConfig.prepare}.\n   *\n   * @remarks\n   * Loads the api-extractor.json config file from the specified file path.   If the \"extends\" field is present,\n   * the referenced file(s) will be merged.  For any omitted fields, the API Extractor default values are merged.\n   */\n  public static loadFile(jsonFilePath: string): IConfigFile {\n    // Set to keep track of config files which have been processed.\n    const visitedPaths: Set<string> = new Set<string>();\n\n    let currentConfigFilePath: string = path.resolve(jsonFilePath);\n    let configObject: Partial<IConfigFile> = {};\n\n    try {\n      do {\n        // Check if this file was already processed.\n        if (visitedPaths.has(currentConfigFilePath)) {\n          throw new Error(\n            `The API Extractor \"extends\" setting contains a cycle.` +\n              `  This file is included twice: \"${currentConfigFilePath}\"`\n          );\n        }\n        visitedPaths.add(currentConfigFilePath);\n\n        const currentConfigFolderPath: string = path.dirname(currentConfigFilePath);\n\n        // Load the extractor config defined in extends property.\n        const baseConfig: IConfigFile = JsonFile.load(currentConfigFilePath);\n\n        let extendsField: string = baseConfig.extends || '';\n\n        // Delete the \"extends\" field so it doesn't get merged\n        delete baseConfig.extends;\n\n        if (extendsField) {\n          if (extendsField.match(/^\\.\\.?[\\\\/]/)) {\n            // EXAMPLE:  \"./subfolder/api-extractor-base.json\"\n            extendsField = path.resolve(currentConfigFolderPath, extendsField);\n          } else {\n            // EXAMPLE:  \"my-package/api-extractor-base.json\"\n            //\n            // Resolve \"my-package\" from the perspective of the current folder.\n            try {\n              extendsField = resolve.sync(extendsField, {\n                basedir: currentConfigFolderPath\n              });\n            } catch (e) {\n              throw new Error(`Error resolving NodeJS path \"${extendsField}\": ${(e as Error).message}`);\n            }\n          }\n        }\n\n        // This step has to be performed in advance, since the currentConfigFolderPath information will be lost\n        // after lodash.merge() is performed.\n        ExtractorConfig._resolveConfigFileRelativePaths(baseConfig, currentConfigFolderPath);\n\n        // Merge extractorConfig into baseConfig, mutating baseConfig\n        lodash.merge(baseConfig, configObject);\n        configObject = baseConfig;\n\n        currentConfigFilePath = extendsField;\n      } while (currentConfigFilePath);\n    } catch (e) {\n      throw new Error(`Error loading ${currentConfigFilePath}:\\n` + (e as Error).message);\n    }\n\n    // Lastly, apply the defaults\n    configObject = lodash.merge(lodash.cloneDeep(ExtractorConfig._defaultConfig), configObject);\n\n    ExtractorConfig.jsonSchema.validateObject(configObject, jsonFilePath);\n\n    // The schema validation should ensure that this object conforms to IConfigFile\n    return configObject as IConfigFile;\n  }\n\n  private static _resolveConfigFileRelativePaths(\n    configFile: IConfigFile,\n    currentConfigFolderPath: string\n  ): void {\n    if (configFile.projectFolder) {\n      configFile.projectFolder = ExtractorConfig._resolveConfigFileRelativePath(\n        'projectFolder',\n        configFile.projectFolder,\n        currentConfigFolderPath\n      );\n    }\n\n    if (configFile.mainEntryPointFilePath) {\n      configFile.mainEntryPointFilePath = ExtractorConfig._resolveConfigFileRelativePath(\n        'mainEntryPointFilePath',\n        configFile.mainEntryPointFilePath,\n        currentConfigFolderPath\n      );\n    }\n\n    if (configFile.compiler) {\n      if (configFile.compiler.tsconfigFilePath) {\n        configFile.compiler.tsconfigFilePath = ExtractorConfig._resolveConfigFileRelativePath(\n          'tsconfigFilePath',\n          configFile.compiler.tsconfigFilePath,\n          currentConfigFolderPath\n        );\n      }\n    }\n\n    if (configFile.apiReport) {\n      if (configFile.apiReport.reportFolder) {\n        configFile.apiReport.reportFolder = ExtractorConfig._resolveConfigFileRelativePath(\n          'reportFolder',\n          configFile.apiReport.reportFolder,\n          currentConfigFolderPath\n        );\n      }\n      if (configFile.apiReport.reportTempFolder) {\n        configFile.apiReport.reportTempFolder = ExtractorConfig._resolveConfigFileRelativePath(\n          'reportTempFolder',\n          configFile.apiReport.reportTempFolder,\n          currentConfigFolderPath\n        );\n      }\n    }\n\n    if (configFile.docModel) {\n      if (configFile.docModel.apiJsonFilePath) {\n        configFile.docModel.apiJsonFilePath = ExtractorConfig._resolveConfigFileRelativePath(\n          'apiJsonFilePath',\n          configFile.docModel.apiJsonFilePath,\n          currentConfigFolderPath\n        );\n      }\n    }\n\n    if (configFile.dtsRollup) {\n      if (configFile.dtsRollup.untrimmedFilePath) {\n        configFile.dtsRollup.untrimmedFilePath = ExtractorConfig._resolveConfigFileRelativePath(\n          'untrimmedFilePath',\n          configFile.dtsRollup.untrimmedFilePath,\n          currentConfigFolderPath\n        );\n      }\n      if (configFile.dtsRollup.alphaTrimmedFilePath) {\n        configFile.dtsRollup.alphaTrimmedFilePath = ExtractorConfig._resolveConfigFileRelativePath(\n          'alphaTrimmedFilePath',\n          configFile.dtsRollup.alphaTrimmedFilePath,\n          currentConfigFolderPath\n        );\n      }\n      if (configFile.dtsRollup.betaTrimmedFilePath) {\n        configFile.dtsRollup.betaTrimmedFilePath = ExtractorConfig._resolveConfigFileRelativePath(\n          'betaTrimmedFilePath',\n          configFile.dtsRollup.betaTrimmedFilePath,\n          currentConfigFolderPath\n        );\n      }\n      if (configFile.dtsRollup.publicTrimmedFilePath) {\n        configFile.dtsRollup.publicTrimmedFilePath = ExtractorConfig._resolveConfigFileRelativePath(\n          'publicTrimmedFilePath',\n          configFile.dtsRollup.publicTrimmedFilePath,\n          currentConfigFolderPath\n        );\n      }\n    }\n\n    if (configFile.tsdocMetadata) {\n      if (configFile.tsdocMetadata.tsdocMetadataFilePath) {\n        configFile.tsdocMetadata.tsdocMetadataFilePath = ExtractorConfig._resolveConfigFileRelativePath(\n          'tsdocMetadataFilePath',\n          configFile.tsdocMetadata.tsdocMetadataFilePath,\n          currentConfigFolderPath\n        );\n      }\n    }\n  }\n\n  private static _resolveConfigFileRelativePath(\n    fieldName: string,\n    fieldValue: string,\n    currentConfigFolderPath: string\n  ): string {\n    if (!path.isAbsolute(fieldValue)) {\n      if (fieldValue.indexOf('<projectFolder>') !== 0) {\n        // If the path is not absolute and does not start with \"<projectFolder>\", then resolve it relative\n        // to the folder of the config file that it appears in\n        return path.join(currentConfigFolderPath, fieldValue);\n      }\n    }\n\n    return fieldValue;\n  }\n\n  /**\n   * Prepares an `ExtractorConfig` object using a configuration that is provided as a runtime object,\n   * rather than reading it from disk.  This allows configurations to be constructed programmatically,\n   * loaded from an alternate source, and/or customized after loading.\n   */\n  public static prepare(options: IExtractorConfigPrepareOptions): ExtractorConfig {\n    const filenameForErrors: string = options.configObjectFullPath || 'the configuration object';\n    const configObject: Partial<IConfigFile> = options.configObject;\n\n    if (configObject.extends) {\n      throw new Error(\n        'The IConfigFile.extends field must be expanded before calling ExtractorConfig.prepare()'\n      );\n    }\n\n    if (options.configObjectFullPath) {\n      if (!path.isAbsolute(options.configObjectFullPath)) {\n        throw new Error('The \"configObjectFullPath\" setting must be an absolute path');\n      }\n    }\n\n    ExtractorConfig.jsonSchema.validateObject(configObject, filenameForErrors);\n\n    const packageJsonFullPath: string | undefined = options.packageJsonFullPath;\n    let packageFolder: string | undefined = undefined;\n    let packageJson: INodePackageJson | undefined = undefined;\n\n    if (packageJsonFullPath) {\n      if (!/.json$/i.test(packageJsonFullPath)) {\n        // Catch common mistakes e.g. where someone passes a folder path instead of a file path\n        throw new Error('The \"packageJsonFullPath\" setting does not have a .json file extension');\n      }\n      if (!path.isAbsolute(packageJsonFullPath)) {\n        throw new Error('The \"packageJsonFullPath\" setting must be an absolute path');\n      }\n\n      if (options.packageJson) {\n        packageJson = options.packageJson;\n      } else {\n        const packageJsonLookup: PackageJsonLookup = new PackageJsonLookup();\n        packageJson = packageJsonLookup.loadNodePackageJson(packageJsonFullPath);\n      }\n\n      packageFolder = path.dirname(packageJsonFullPath);\n    }\n\n    // \"tsdocConfigFile\" and \"tsdocConfiguration\" are prepared outside the try-catch block,\n    // so that if exceptions are thrown, it will not get the \"Error parsing api-extractor.json:\" header\n    let extractorConfigParameters: Omit<IExtractorConfigParameters, 'tsdocConfigFile' | 'tsdocConfiguration'>;\n\n    try {\n      if (!configObject.compiler) {\n        // A merged configuration should have this\n        throw new Error('The \"compiler\" section is missing');\n      }\n\n      if (!configObject.projectFolder) {\n        // A merged configuration should have this\n        throw new Error('The \"projectFolder\" setting is missing');\n      }\n\n      let projectFolder: string;\n      if (configObject.projectFolder.trim() === '<lookup>') {\n        if (options.projectFolderLookupToken) {\n          // Use the manually specified \"<lookup>\" value\n          projectFolder = options.projectFolderLookupToken;\n\n          if (!FileSystem.exists(options.projectFolderLookupToken)) {\n            throw new Error(\n              'The specified \"projectFolderLookupToken\" path does not exist: ' +\n                options.projectFolderLookupToken\n            );\n          }\n        } else {\n          if (!options.configObjectFullPath) {\n            throw new Error(\n              'The \"projectFolder\" setting uses the \"<lookup>\" token, but it cannot be expanded because' +\n                ' the \"configObjectFullPath\" setting was not specified'\n            );\n          }\n\n          // \"The default value for `projectFolder` is the token `<lookup>`, which means the folder is determined\n          // by traversing parent folders, starting from the folder containing api-extractor.json, and stopping\n          // at the first folder that contains a tsconfig.json file.  If a tsconfig.json file cannot be found in\n          // this way, then an error will be reported.\"\n\n          let currentFolder: string = path.dirname(options.configObjectFullPath);\n          for (;;) {\n            const tsconfigPath: string = path.join(currentFolder, 'tsconfig.json');\n            if (FileSystem.exists(tsconfigPath)) {\n              projectFolder = currentFolder;\n              break;\n            }\n            const parentFolder: string = path.dirname(currentFolder);\n            if (parentFolder === '' || parentFolder === currentFolder) {\n              throw new Error(\n                'The \"projectFolder\" setting uses the \"<lookup>\" token, but a tsconfig.json file cannot be' +\n                  ' found in this folder or any parent folder.'\n              );\n            }\n            currentFolder = parentFolder;\n          }\n        }\n      } else {\n        ExtractorConfig._rejectAnyTokensInPath(configObject.projectFolder, 'projectFolder');\n\n        if (!FileSystem.exists(configObject.projectFolder)) {\n          throw new Error('The specified \"projectFolder\" path does not exist: ' + configObject.projectFolder);\n        }\n\n        projectFolder = configObject.projectFolder;\n      }\n\n      const tokenContext: IExtractorConfigTokenContext = {\n        unscopedPackageName: 'unknown-package',\n        packageName: 'unknown-package',\n        projectFolder: projectFolder\n      };\n\n      if (packageJson) {\n        tokenContext.packageName = packageJson.name;\n        tokenContext.unscopedPackageName = PackageName.getUnscopedName(packageJson.name);\n      }\n\n      if (!configObject.mainEntryPointFilePath) {\n        // A merged configuration should have this\n        throw new Error('The \"mainEntryPointFilePath\" setting is missing');\n      }\n      const mainEntryPointFilePath: string = ExtractorConfig._resolvePathWithTokens(\n        'mainEntryPointFilePath',\n        configObject.mainEntryPointFilePath,\n        tokenContext\n      );\n\n      if (!ExtractorConfig.hasDtsFileExtension(mainEntryPointFilePath)) {\n        throw new Error(\n          'The \"mainEntryPointFilePath\" value is not a declaration file: ' + mainEntryPointFilePath\n        );\n      }\n\n      if (!options.ignoreMissingEntryPoint && !FileSystem.exists(mainEntryPointFilePath)) {\n        throw new Error('The \"mainEntryPointFilePath\" path does not exist: ' + mainEntryPointFilePath);\n      }\n\n      const bundledPackages: string[] = configObject.bundledPackages || [];\n      for (const bundledPackage of bundledPackages) {\n        if (!PackageName.isValidName(bundledPackage)) {\n          throw new Error(`The \"bundledPackages\" list contains an invalid package name: \"${bundledPackage}\"`);\n        }\n      }\n\n      const tsconfigFilePath: string = ExtractorConfig._resolvePathWithTokens(\n        'tsconfigFilePath',\n        configObject.compiler.tsconfigFilePath,\n        tokenContext\n      );\n\n      if (configObject.compiler.overrideTsconfig === undefined) {\n        if (!tsconfigFilePath) {\n          throw new Error('Either the \"tsconfigFilePath\" or \"overrideTsconfig\" setting must be specified');\n        }\n        if (!FileSystem.exists(tsconfigFilePath)) {\n          throw new Error('The file referenced by \"tsconfigFilePath\" does not exist: ' + tsconfigFilePath);\n        }\n      }\n\n      let apiReportEnabled: boolean = false;\n      let reportFilePath: string = '';\n      let reportTempFilePath: string = '';\n      let apiReportIncludeForgottenExports: boolean = false;\n      if (configObject.apiReport) {\n        apiReportEnabled = !!configObject.apiReport.enabled;\n\n        const reportFilename: string = ExtractorConfig._expandStringWithTokens(\n          'reportFileName',\n          configObject.apiReport.reportFileName || '',\n          tokenContext\n        );\n\n        if (!reportFilename) {\n          // A merged configuration should have this\n          throw new Error('The \"reportFilename\" setting is missing');\n        }\n        if (reportFilename.indexOf('/') >= 0 || reportFilename.indexOf('\\\\') >= 0) {\n          // A merged configuration should have this\n          throw new Error(`The \"reportFilename\" setting contains invalid characters: \"${reportFilename}\"`);\n        }\n\n        const reportFolder: string = ExtractorConfig._resolvePathWithTokens(\n          'reportFolder',\n          configObject.apiReport.reportFolder,\n          tokenContext\n        );\n        const reportTempFolder: string = ExtractorConfig._resolvePathWithTokens(\n          'reportTempFolder',\n          configObject.apiReport.reportTempFolder,\n          tokenContext\n        );\n\n        reportFilePath = path.join(reportFolder, reportFilename);\n        reportTempFilePath = path.join(reportTempFolder, reportFilename);\n        apiReportIncludeForgottenExports = !!configObject.apiReport.includeForgottenExports;\n      }\n\n      let docModelEnabled: boolean = false;\n      let apiJsonFilePath: string = '';\n      let docModelIncludeForgottenExports: boolean = false;\n      let projectFolderUrl: string | undefined;\n      if (configObject.docModel) {\n        docModelEnabled = !!configObject.docModel.enabled;\n        apiJsonFilePath = ExtractorConfig._resolvePathWithTokens(\n          'apiJsonFilePath',\n          configObject.docModel.apiJsonFilePath,\n          tokenContext\n        );\n        docModelIncludeForgottenExports = !!configObject.docModel.includeForgottenExports;\n        projectFolderUrl = configObject.docModel.projectFolderUrl;\n      }\n\n      let tsdocMetadataEnabled: boolean = false;\n      let tsdocMetadataFilePath: string = '';\n      if (configObject.tsdocMetadata) {\n        tsdocMetadataEnabled = !!configObject.tsdocMetadata.enabled;\n\n        if (tsdocMetadataEnabled) {\n          tsdocMetadataFilePath = configObject.tsdocMetadata.tsdocMetadataFilePath || '';\n\n          if (tsdocMetadataFilePath.trim() === '<lookup>') {\n            if (!packageJson) {\n              throw new Error(\n                'The \"<lookup>\" token cannot be used with the \"tsdocMetadataFilePath\" setting because' +\n                  ' the \"packageJson\" option was not provided'\n              );\n            }\n            if (!packageJsonFullPath) {\n              throw new Error(\n                'The \"<lookup>\" token cannot be used with \"tsdocMetadataFilePath\" because' +\n                  'the \"packageJsonFullPath\" option was not provided'\n              );\n            }\n            tsdocMetadataFilePath = PackageMetadataManager.resolveTsdocMetadataPath(\n              path.dirname(packageJsonFullPath),\n              packageJson\n            );\n          } else {\n            tsdocMetadataFilePath = ExtractorConfig._resolvePathWithTokens(\n              'tsdocMetadataFilePath',\n              configObject.tsdocMetadata.tsdocMetadataFilePath,\n              tokenContext\n            );\n          }\n\n          if (!tsdocMetadataFilePath) {\n            throw new Error(\n              'The \"tsdocMetadata.enabled\" setting is enabled,' +\n                ' but \"tsdocMetadataFilePath\" is not specified'\n            );\n          }\n        }\n      }\n\n      let rollupEnabled: boolean = false;\n      let untrimmedFilePath: string = '';\n      let betaTrimmedFilePath: string = '';\n      let alphaTrimmedFilePath: string = '';\n      let publicTrimmedFilePath: string = '';\n      let omitTrimmingComments: boolean = false;\n\n      if (configObject.dtsRollup) {\n        rollupEnabled = !!configObject.dtsRollup.enabled;\n        untrimmedFilePath = ExtractorConfig._resolvePathWithTokens(\n          'untrimmedFilePath',\n          configObject.dtsRollup.untrimmedFilePath,\n          tokenContext\n        );\n        alphaTrimmedFilePath = ExtractorConfig._resolvePathWithTokens(\n          'alphaTrimmedFilePath',\n          configObject.dtsRollup.alphaTrimmedFilePath,\n          tokenContext\n        );\n        betaTrimmedFilePath = ExtractorConfig._resolvePathWithTokens(\n          'betaTrimmedFilePath',\n          configObject.dtsRollup.betaTrimmedFilePath,\n          tokenContext\n        );\n        publicTrimmedFilePath = ExtractorConfig._resolvePathWithTokens(\n          'publicTrimmedFilePath',\n          configObject.dtsRollup.publicTrimmedFilePath,\n          tokenContext\n        );\n        omitTrimmingComments = !!configObject.dtsRollup.omitTrimmingComments;\n      }\n\n      let newlineKind: NewlineKind;\n      switch (configObject.newlineKind) {\n        case 'lf':\n          newlineKind = NewlineKind.Lf;\n          break;\n        case 'os':\n          newlineKind = NewlineKind.OsDefault;\n          break;\n        default:\n          newlineKind = NewlineKind.CrLf;\n          break;\n      }\n\n      const enumMemberOrder: EnumMemberOrder = configObject.enumMemberOrder ?? EnumMemberOrder.ByName;\n\n      extractorConfigParameters = {\n        projectFolder: projectFolder,\n        packageJson,\n        packageFolder,\n        mainEntryPointFilePath,\n        bundledPackages,\n        tsconfigFilePath,\n        overrideTsconfig: configObject.compiler.overrideTsconfig,\n        skipLibCheck: !!configObject.compiler.skipLibCheck,\n        apiReportEnabled,\n        reportFilePath,\n        reportTempFilePath,\n        apiReportIncludeForgottenExports,\n        docModelEnabled,\n        apiJsonFilePath,\n        docModelIncludeForgottenExports,\n        projectFolderUrl,\n        rollupEnabled,\n        untrimmedFilePath,\n        alphaTrimmedFilePath,\n        betaTrimmedFilePath,\n        publicTrimmedFilePath,\n        omitTrimmingComments,\n        tsdocMetadataEnabled,\n        tsdocMetadataFilePath,\n        newlineKind,\n        messages: configObject.messages || {},\n        testMode: !!configObject.testMode,\n        enumMemberOrder\n      };\n    } catch (e) {\n      throw new Error(`Error parsing ${filenameForErrors}:\\n` + (e as Error).message);\n    }\n\n    let tsdocConfigFile: TSDocConfigFile | undefined = options.tsdocConfigFile;\n\n    if (!tsdocConfigFile) {\n      // Example: \"my-project/tsdoc.json\"\n      let packageTSDocConfigPath: string = TSDocConfigFile.findConfigPathForFolder(\n        extractorConfigParameters.projectFolder\n      );\n\n      if (!packageTSDocConfigPath || !FileSystem.exists(packageTSDocConfigPath)) {\n        // If the project does not have a tsdoc.json config file, then use API Extractor's base file.\n        packageTSDocConfigPath = ExtractorConfig._tsdocBaseFilePath;\n        if (!FileSystem.exists(packageTSDocConfigPath)) {\n          throw new InternalError('Unable to load the built-in TSDoc config file: ' + packageTSDocConfigPath);\n        }\n      }\n      tsdocConfigFile = TSDocConfigFile.loadFile(packageTSDocConfigPath);\n    }\n\n    // IMPORTANT: After calling TSDocConfigFile.loadFile(), we need to check for errors.\n    if (tsdocConfigFile.hasErrors) {\n      throw new Error(tsdocConfigFile.getErrorSummary());\n    }\n\n    const tsdocConfiguration: TSDocConfiguration = new TSDocConfiguration();\n    tsdocConfigFile.configureParser(tsdocConfiguration);\n\n    // IMPORTANT: After calling TSDocConfigFile.configureParser(), we need to check for errors a second time.\n    if (tsdocConfigFile.hasErrors) {\n      throw new Error(tsdocConfigFile.getErrorSummary());\n    }\n\n    return new ExtractorConfig({ ...extractorConfigParameters, tsdocConfigFile, tsdocConfiguration });\n  }\n\n  private static _resolvePathWithTokens(\n    fieldName: string,\n    value: string | undefined,\n    tokenContext: IExtractorConfigTokenContext\n  ): string {\n    value = ExtractorConfig._expandStringWithTokens(fieldName, value, tokenContext);\n    if (value !== '') {\n      value = path.resolve(tokenContext.projectFolder, value);\n    }\n    return value;\n  }\n\n  private static _expandStringWithTokens(\n    fieldName: string,\n    value: string | undefined,\n    tokenContext: IExtractorConfigTokenContext\n  ): string {\n    value = value ? value.trim() : '';\n    if (value !== '') {\n      value = Text.replaceAll(value, '<unscopedPackageName>', tokenContext.unscopedPackageName);\n      value = Text.replaceAll(value, '<packageName>', tokenContext.packageName);\n\n      const projectFolderToken: string = '<projectFolder>';\n      if (value.indexOf(projectFolderToken) === 0) {\n        // Replace \"<projectFolder>\" at the start of a string\n        value = path.join(tokenContext.projectFolder, value.substr(projectFolderToken.length));\n      }\n\n      if (value.indexOf(projectFolderToken) >= 0) {\n        // If after all replacements, \"<projectFolder>\" appears somewhere in the string, report an error\n        throw new Error(\n          `The \"${fieldName}\" value incorrectly uses the \"<projectFolder>\" token.` +\n            ` It must appear at the start of the string.`\n        );\n      }\n\n      if (value.indexOf('<lookup>') >= 0) {\n        throw new Error(`The \"${fieldName}\" value incorrectly uses the \"<lookup>\" token`);\n      }\n      ExtractorConfig._rejectAnyTokensInPath(value, fieldName);\n    }\n    return value;\n  }\n\n  /**\n   * Returns true if the specified file path has the \".d.ts\" file extension.\n   */\n  public static hasDtsFileExtension(filePath: string): boolean {\n    return ExtractorConfig._declarationFileExtensionRegExp.test(filePath);\n  }\n\n  /**\n   * Given a path string that may have originally contained expandable tokens such as `<projectFolder>\"`\n   * this reports an error if any token-looking substrings remain after expansion (e.g. `c:\\blah\\<invalid>\\blah`).\n   */\n  private static _rejectAnyTokensInPath(value: string, fieldName: string): void {\n    if (value.indexOf('<') < 0 && value.indexOf('>') < 0) {\n      return;\n    }\n\n    // Can we determine the name of a token?\n    const tokenRegExp: RegExp = /(\\<[^<]*?\\>)/;\n    const match: RegExpExecArray | null = tokenRegExp.exec(value);\n    if (match) {\n      throw new Error(`The \"${fieldName}\" value contains an unrecognized token \"${match[1]}\"`);\n    }\n    throw new Error(`The \"${fieldName}\" value contains extra token characters (\"<\" or \">\"): ${value}`);\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ExtractorConfig.js","sourceRoot":"","sources":["../../src/api/ExtractorConfig.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as resolve from 'resolve';\r\nimport lodash = require('lodash');\r\nimport {\r\n  JsonFile,\r\n  JsonSchema,\r\n  FileSystem,\r\n  PackageJsonLookup,\r\n  type INodePackageJson,\r\n  PackageName,\r\n  Text,\r\n  InternalError,\r\n  Path,\r\n  NewlineKind\r\n} from '@rushstack/node-core-library';\r\nimport { type IRigConfig, RigConfig } from '@rushstack/rig-package';\r\n\r\nimport type { IConfigFile, IExtractorMessagesConfig } from './IConfigFile';\r\nimport { PackageMetadataManager } from '../analyzer/PackageMetadataManager';\r\nimport { MessageRouter } from '../collector/MessageRouter';\r\nimport { EnumMemberOrder } from '@microsoft/api-extractor-model';\r\nimport { TSDocConfiguration } from '@microsoft/tsdoc';\r\nimport { TSDocConfigFile } from '@microsoft/tsdoc-config';\r\n\r\nimport apiExtractorSchema from '../schemas/api-extractor.schema.json';\r\n\r\n/**\r\n * Tokens used during variable expansion of path fields from api-extractor.json.\r\n */\r\ninterface IExtractorConfigTokenContext {\r\n  /**\r\n   * The `<unscopedPackageName>` token returns the project's NPM package name, without any NPM scope.\r\n   * If there is no associated package.json file, then the value is `unknown-package`.\r\n   *\r\n   * Example: `my-project`\r\n   */\r\n  unscopedPackageName: string;\r\n\r\n  /**\r\n   * The `<packageName>` token returns the project's full NPM package name including any NPM scope.\r\n   * If there is no associated package.json file, then the value is `unknown-package`.\r\n   *\r\n   * Example: `@scope/my-project`\r\n   */\r\n  packageName: string;\r\n\r\n  /**\r\n   * The `<projectFolder>` token returns the expanded `\"projectFolder\"` setting from api-extractor.json.\r\n   */\r\n  projectFolder: string;\r\n}\r\n\r\n/**\r\n * Options for {@link ExtractorConfig.tryLoadForFolder}.\r\n *\r\n * @public\r\n */\r\nexport interface IExtractorConfigLoadForFolderOptions {\r\n  /**\r\n   * The folder path to start from when searching for api-extractor.json.\r\n   */\r\n  startingFolder: string;\r\n\r\n  /**\r\n   * An already constructed `PackageJsonLookup` cache object to use.  If omitted, a temporary one will\r\n   * be constructed.\r\n   */\r\n  packageJsonLookup?: PackageJsonLookup;\r\n\r\n  /**\r\n   * An already constructed `RigConfig` object.  If omitted, then a new `RigConfig` object will be constructed.\r\n   */\r\n  rigConfig?: IRigConfig;\r\n}\r\n\r\n/**\r\n * Options for {@link ExtractorConfig.prepare}.\r\n *\r\n * @public\r\n */\r\nexport interface IExtractorConfigPrepareOptions {\r\n  /**\r\n   * A configuration object as returned by {@link ExtractorConfig.loadFile}.\r\n   */\r\n  configObject: IConfigFile;\r\n\r\n  /**\r\n   * The absolute path of the file that the `configObject` object was loaded from.  This is used for error messages\r\n   * and when probing for `tsconfig.json`.\r\n   *\r\n   * @remarks\r\n   *\r\n   * If `configObjectFullPath` and `projectFolderLookupToken` are both unspecified, then the api-extractor.json\r\n   * config file must explicitly specify a `projectFolder` setting rather than relying on the `<lookup>` token.\r\n   */\r\n  configObjectFullPath: string | undefined;\r\n\r\n  /**\r\n   * The parsed package.json file for the working package, or undefined if API Extractor was invoked without\r\n   * a package.json file.\r\n   *\r\n   * @remarks\r\n   *\r\n   * If omitted, then the `<unscopedPackageName>` and `<packageName>` tokens will have default values.\r\n   */\r\n  packageJson?: INodePackageJson | undefined;\r\n\r\n  /**\r\n   * The absolute path of the file that the `packageJson` object was loaded from, or undefined if API Extractor\r\n   * was invoked without a package.json file.\r\n   *\r\n   * @remarks\r\n   *\r\n   * This is used for error messages and when resolving paths found in package.json.\r\n   *\r\n   * If `packageJsonFullPath` is specified but `packageJson` is omitted, the file will be loaded automatically.\r\n   */\r\n  packageJsonFullPath: string | undefined;\r\n\r\n  /**\r\n   * The default value for the `projectFolder` setting is the `<lookup>` token, which uses a heuristic to guess\r\n   * an appropriate project folder.  Use `projectFolderLookupValue` to manually specify the `<lookup>` token value\r\n   * instead.\r\n   *\r\n   * @remarks\r\n   * If the `projectFolder` setting is explicitly specified in api-extractor.json file, it should take precedence\r\n   * over a value specified via the API.  Thus the `projectFolderLookupToken` option provides a way to override\r\n   * the default value for `projectFolder` setting while still honoring a manually specified value.\r\n   */\r\n  projectFolderLookupToken?: string;\r\n\r\n  /**\r\n   * Allow customization of the tsdoc.json config file.  If omitted, this file will be loaded from its default\r\n   * location.  If the file does not exist, then the standard definitions will be used from\r\n   * `@microsoft/api-extractor/extends/tsdoc-base.json`.\r\n   */\r\n  tsdocConfigFile?: TSDocConfigFile;\r\n\r\n  /**\r\n   * When preparing the configuration object, folder and file paths referenced in the configuration are checked\r\n   * for existence, and an error is reported if they are not found.  This option can be used to disable this\r\n   * check for the main entry point module. This may be useful when preparing a configuration file for an\r\n   * un-built project.\r\n   */\r\n  ignoreMissingEntryPoint?: boolean;\r\n}\r\n\r\ninterface IExtractorConfigParameters {\r\n  projectFolder: string;\r\n  packageJson: INodePackageJson | undefined;\r\n  packageFolder: string | undefined;\r\n  mainEntryPointFilePath: string;\r\n  bundledPackages: string[];\r\n  tsconfigFilePath: string;\r\n  overrideTsconfig: {} | undefined;\r\n  skipLibCheck: boolean;\r\n  apiReportEnabled: boolean;\r\n  reportFilePath: string;\r\n  reportTempFilePath: string;\r\n  apiReportIncludeForgottenExports: boolean;\r\n  docModelEnabled: boolean;\r\n  apiJsonFilePath: string;\r\n  docModelIncludeForgottenExports: boolean;\r\n  projectFolderUrl: string | undefined;\r\n  rollupEnabled: boolean;\r\n  untrimmedFilePath: string;\r\n  alphaTrimmedFilePath: string;\r\n  betaTrimmedFilePath: string;\r\n  publicTrimmedFilePath: string;\r\n  omitTrimmingComments: boolean;\r\n  tsdocMetadataEnabled: boolean;\r\n  tsdocMetadataFilePath: string;\r\n  tsdocConfigFile: TSDocConfigFile;\r\n  tsdocConfiguration: TSDocConfiguration;\r\n  newlineKind: NewlineKind;\r\n  messages: IExtractorMessagesConfig;\r\n  testMode: boolean;\r\n  enumMemberOrder: EnumMemberOrder;\r\n}\r\n\r\n/**\r\n * The `ExtractorConfig` class loads, validates, interprets, and represents the api-extractor.json config file.\r\n * @public\r\n */\r\nexport class ExtractorConfig {\r\n  /**\r\n   * The JSON Schema for API Extractor config file (api-extractor.schema.json).\r\n   */\r\n  public static readonly jsonSchema: JsonSchema = JsonSchema.fromLoadedObject(apiExtractorSchema);\r\n\r\n  /**\r\n   * The config file name \"api-extractor.json\".\r\n   */\r\n  public static readonly FILENAME: 'api-extractor.json' = 'api-extractor.json';\r\n\r\n  /**\r\n   * The full path to `extends/tsdoc-base.json` which contains the standard TSDoc configuration\r\n   * for API Extractor.\r\n   * @internal\r\n   */\r\n  public static readonly _tsdocBaseFilePath: string = path.resolve(\r\n    __dirname,\r\n    '../../extends/tsdoc-base.json'\r\n  );\r\n\r\n  private static readonly _defaultConfig: Partial<IConfigFile> = JsonFile.load(\r\n    path.join(__dirname, '../schemas/api-extractor-defaults.json')\r\n  );\r\n\r\n  /** Match all three flavors for type declaration files (.d.ts, .d.mts, .d.cts) */\r\n  private static readonly _declarationFileExtensionRegExp: RegExp = /\\.d\\.(c|m)?ts$/i;\r\n\r\n  /** {@inheritDoc IConfigFile.projectFolder} */\r\n  public readonly projectFolder: string;\r\n\r\n  /**\r\n   * The parsed package.json file for the working package, or undefined if API Extractor was invoked without\r\n   * a package.json file.\r\n   */\r\n  public readonly packageJson: INodePackageJson | undefined;\r\n\r\n  /**\r\n   * The absolute path of the folder containing the package.json file for the working package, or undefined\r\n   * if API Extractor was invoked without a package.json file.\r\n   */\r\n  public readonly packageFolder: string | undefined;\r\n\r\n  /** {@inheritDoc IConfigFile.mainEntryPointFilePath} */\r\n  public readonly mainEntryPointFilePath: string;\r\n\r\n  /** {@inheritDoc IConfigFile.bundledPackages} */\r\n  public readonly bundledPackages: string[];\r\n\r\n  /** {@inheritDoc IConfigCompiler.tsconfigFilePath} */\r\n  public readonly tsconfigFilePath: string;\r\n\r\n  /** {@inheritDoc IConfigCompiler.overrideTsconfig} */\r\n  public readonly overrideTsconfig: {} | undefined;\r\n\r\n  /** {@inheritDoc IConfigCompiler.skipLibCheck} */\r\n  public readonly skipLibCheck: boolean;\r\n\r\n  /** {@inheritDoc IConfigApiReport.enabled} */\r\n  public readonly apiReportEnabled: boolean;\r\n\r\n  /** The `reportFolder` path combined with the `reportFileName`. */\r\n  public readonly reportFilePath: string;\r\n  /** The `reportTempFolder` path combined with the `reportFileName`. */\r\n  public readonly reportTempFilePath: string;\r\n  /** {@inheritDoc IConfigApiReport.includeForgottenExports} */\r\n  public readonly apiReportIncludeForgottenExports: boolean;\r\n\r\n  /** {@inheritDoc IConfigDocModel.enabled} */\r\n  public readonly docModelEnabled: boolean;\r\n  /** {@inheritDoc IConfigDocModel.apiJsonFilePath} */\r\n  public readonly apiJsonFilePath: string;\r\n  /** {@inheritDoc IConfigDocModel.includeForgottenExports} */\r\n  public readonly docModelIncludeForgottenExports: boolean;\r\n  /** {@inheritDoc IConfigDocModel.projectFolderUrl} */\r\n  public readonly projectFolderUrl: string | undefined;\r\n\r\n  /** {@inheritDoc IConfigDtsRollup.enabled} */\r\n  public readonly rollupEnabled: boolean;\r\n  /** {@inheritDoc IConfigDtsRollup.untrimmedFilePath} */\r\n  public readonly untrimmedFilePath: string;\r\n  /** {@inheritDoc IConfigDtsRollup.alphaTrimmedFilePath} */\r\n  public readonly alphaTrimmedFilePath: string;\r\n  /** {@inheritDoc IConfigDtsRollup.betaTrimmedFilePath} */\r\n  public readonly betaTrimmedFilePath: string;\r\n  /** {@inheritDoc IConfigDtsRollup.publicTrimmedFilePath} */\r\n  public readonly publicTrimmedFilePath: string;\r\n  /** {@inheritDoc IConfigDtsRollup.omitTrimmingComments} */\r\n  public readonly omitTrimmingComments: boolean;\r\n\r\n  /** {@inheritDoc IConfigTsdocMetadata.enabled} */\r\n  public readonly tsdocMetadataEnabled: boolean;\r\n  /** {@inheritDoc IConfigTsdocMetadata.tsdocMetadataFilePath} */\r\n  public readonly tsdocMetadataFilePath: string;\r\n\r\n  /**\r\n   * The tsdoc.json configuration that will be used when parsing doc comments.\r\n   */\r\n  public readonly tsdocConfigFile: TSDocConfigFile;\r\n\r\n  /**\r\n   * The `TSDocConfiguration` loaded from {@link ExtractorConfig.tsdocConfigFile}.\r\n   */\r\n  public readonly tsdocConfiguration: TSDocConfiguration;\r\n\r\n  /**\r\n   * Specifies what type of newlines API Extractor should use when writing output files.  By default, the output files\r\n   * will be written with Windows-style newlines.\r\n   */\r\n  public readonly newlineKind: NewlineKind;\r\n\r\n  /** {@inheritDoc IConfigFile.messages} */\r\n  public readonly messages: IExtractorMessagesConfig;\r\n\r\n  /** {@inheritDoc IConfigFile.testMode} */\r\n  public readonly testMode: boolean;\r\n\r\n  /** {@inheritDoc IConfigFile.enumMemberOrder} */\r\n  public readonly enumMemberOrder: EnumMemberOrder;\r\n\r\n  private constructor(parameters: IExtractorConfigParameters) {\r\n    this.projectFolder = parameters.projectFolder;\r\n    this.packageJson = parameters.packageJson;\r\n    this.packageFolder = parameters.packageFolder;\r\n    this.mainEntryPointFilePath = parameters.mainEntryPointFilePath;\r\n    this.bundledPackages = parameters.bundledPackages;\r\n    this.tsconfigFilePath = parameters.tsconfigFilePath;\r\n    this.overrideTsconfig = parameters.overrideTsconfig;\r\n    this.skipLibCheck = parameters.skipLibCheck;\r\n    this.apiReportEnabled = parameters.apiReportEnabled;\r\n    this.reportFilePath = parameters.reportFilePath;\r\n    this.reportTempFilePath = parameters.reportTempFilePath;\r\n    this.apiReportIncludeForgottenExports = parameters.apiReportIncludeForgottenExports;\r\n    this.docModelEnabled = parameters.docModelEnabled;\r\n    this.apiJsonFilePath = parameters.apiJsonFilePath;\r\n    this.docModelIncludeForgottenExports = parameters.docModelIncludeForgottenExports;\r\n    this.projectFolderUrl = parameters.projectFolderUrl;\r\n    this.rollupEnabled = parameters.rollupEnabled;\r\n    this.untrimmedFilePath = parameters.untrimmedFilePath;\r\n    this.alphaTrimmedFilePath = parameters.alphaTrimmedFilePath;\r\n    this.betaTrimmedFilePath = parameters.betaTrimmedFilePath;\r\n    this.publicTrimmedFilePath = parameters.publicTrimmedFilePath;\r\n    this.omitTrimmingComments = parameters.omitTrimmingComments;\r\n    this.tsdocMetadataEnabled = parameters.tsdocMetadataEnabled;\r\n    this.tsdocMetadataFilePath = parameters.tsdocMetadataFilePath;\r\n    this.tsdocConfigFile = parameters.tsdocConfigFile;\r\n    this.tsdocConfiguration = parameters.tsdocConfiguration;\r\n    this.newlineKind = parameters.newlineKind;\r\n    this.messages = parameters.messages;\r\n    this.testMode = parameters.testMode;\r\n    this.enumMemberOrder = parameters.enumMemberOrder;\r\n  }\r\n\r\n  /**\r\n   * Returns a JSON-like string representing the `ExtractorConfig` state, which can be printed to a console\r\n   * for diagnostic purposes.\r\n   *\r\n   * @remarks\r\n   * This is used by the \"--diagnostics\" command-line option.  The string is not intended to be deserialized;\r\n   * its format may be changed at any time.\r\n   */\r\n  public getDiagnosticDump(): string {\r\n    // Handle the simple JSON-serializable properties using buildJsonDumpObject()\r\n    const result: object = MessageRouter.buildJsonDumpObject(this, {\r\n      keyNamesToOmit: ['tsdocConfigFile', 'tsdocConfiguration']\r\n    });\r\n\r\n    // Implement custom formatting for tsdocConfigFile and tsdocConfiguration\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    (result as any).tsdocConfigFile = {\r\n      filePath: this.tsdocConfigFile.filePath,\r\n      log: this.tsdocConfigFile.log.messages.map((x) => x.toString())\r\n    };\r\n\r\n    return JSON.stringify(result, undefined, 2);\r\n  }\r\n\r\n  /**\r\n   * Returns a simplified file path for use in error messages.\r\n   * @internal\r\n   */\r\n  public _getShortFilePath(absolutePath: string): string {\r\n    if (!path.isAbsolute(absolutePath)) {\r\n      throw new InternalError('Expected absolute path: ' + absolutePath);\r\n    }\r\n    if (Path.isUnderOrEqual(absolutePath, this.projectFolder)) {\r\n      return Path.convertToSlashes(path.relative(this.projectFolder, absolutePath));\r\n    }\r\n    return absolutePath;\r\n  }\r\n\r\n  /**\r\n   * Searches for the api-extractor.json config file associated with the specified starting folder,\r\n   * and loads the file if found.  This lookup supports\r\n   * {@link https://www.npmjs.com/package/@rushstack/rig-package | rig packages}.\r\n   *\r\n   * @remarks\r\n   * The search will first look for a package.json file in a parent folder of the starting folder;\r\n   * if found, that will be used as the base folder instead of the starting folder.  If the config\r\n   * file is not found in `<baseFolder>/api-extractor.json` or `<baseFolder>/config/api-extractor.json`,\r\n   * then `<baseFolder/config/rig.json` will be checked to see whether a\r\n   * {@link https://www.npmjs.com/package/@rushstack/rig-package | rig package} is referenced; if so then\r\n   * the rig's api-extractor.json file will be used instead.  If a config file is found, it will be loaded\r\n   * and returned with the `IExtractorConfigPrepareOptions` object. Otherwise, `undefined` is returned\r\n   * to indicate that API Extractor does not appear to be configured for the specified folder.\r\n   *\r\n   * @returns An options object that can be passed to {@link ExtractorConfig.prepare}, or `undefined`\r\n   * if not api-extractor.json file was found.\r\n   */\r\n  public static tryLoadForFolder(\r\n    options: IExtractorConfigLoadForFolderOptions\r\n  ): IExtractorConfigPrepareOptions | undefined {\r\n    const packageJsonLookup: PackageJsonLookup = options.packageJsonLookup || new PackageJsonLookup();\r\n    const startingFolder: string = options.startingFolder;\r\n\r\n    // Figure out which project we're in and look for the config file at the project root\r\n    const packageJsonFullPath: string | undefined =\r\n      packageJsonLookup.tryGetPackageJsonFilePathFor(startingFolder);\r\n    const packageFolder: string | undefined = packageJsonFullPath\r\n      ? path.dirname(packageJsonFullPath)\r\n      : undefined;\r\n\r\n    // If there is no package, then just use the starting folder\r\n    const baseFolder: string = packageFolder || startingFolder;\r\n\r\n    let projectFolderLookupToken: string | undefined = undefined;\r\n\r\n    // First try the standard \"config\" subfolder:\r\n    let configFilename: string = path.join(baseFolder, 'config', ExtractorConfig.FILENAME);\r\n    if (FileSystem.exists(configFilename)) {\r\n      if (FileSystem.exists(path.join(baseFolder, ExtractorConfig.FILENAME))) {\r\n        throw new Error(`Found conflicting ${ExtractorConfig.FILENAME} files in \".\" and \"./config\" folders`);\r\n      }\r\n    } else {\r\n      // Otherwise try the top-level folder\r\n      configFilename = path.join(baseFolder, ExtractorConfig.FILENAME);\r\n\r\n      if (!FileSystem.exists(configFilename)) {\r\n        // If We didn't find it in <packageFolder>/api-extractor.json or <packageFolder>/config/api-extractor.json\r\n        // then check for a rig package\r\n        if (packageFolder) {\r\n          let rigConfig: IRigConfig;\r\n          if (options.rigConfig) {\r\n            // The caller provided an already solved RigConfig.  Double-check that it is for the right project.\r\n            if (!Path.isEqual(options.rigConfig.projectFolderPath, packageFolder)) {\r\n              throw new Error(\r\n                'The provided ILoadForFolderOptions.rigConfig is for the wrong project folder:\\n' +\r\n                  '\\nExpected path: ' +\r\n                  packageFolder +\r\n                  '\\nProvided path: ' +\r\n                  options.rigConfig.projectFolderOriginalPath\r\n              );\r\n            }\r\n            rigConfig = options.rigConfig;\r\n          } else {\r\n            rigConfig = RigConfig.loadForProjectFolder({\r\n              projectFolderPath: packageFolder\r\n            });\r\n          }\r\n\r\n          if (rigConfig.rigFound) {\r\n            configFilename = path.join(rigConfig.getResolvedProfileFolder(), ExtractorConfig.FILENAME);\r\n\r\n            // If the \"projectFolder\" setting isn't specified in api-extractor.json, it defaults to the\r\n            // \"<lookup>\" token which will probe for the tsconfig.json nearest to the api-extractor.json path.\r\n            // But this won't work if api-extractor.json belongs to the rig.  So instead \"<lookup>\" should be\r\n            // the \"<packageFolder>\" that referenced the rig.\r\n            projectFolderLookupToken = packageFolder;\r\n          }\r\n        }\r\n        if (!FileSystem.exists(configFilename)) {\r\n          // API Extractor does not seem to be configured for this folder\r\n          return undefined;\r\n        }\r\n      }\r\n    }\r\n\r\n    const configObjectFullPath: string = path.resolve(configFilename);\r\n    const configObject: IConfigFile = ExtractorConfig.loadFile(configObjectFullPath);\r\n\r\n    return {\r\n      configObject,\r\n      configObjectFullPath,\r\n      packageJsonFullPath,\r\n      projectFolderLookupToken\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Loads the api-extractor.json config file from the specified file path, and prepares an `ExtractorConfig` object.\r\n   *\r\n   * @remarks\r\n   * Loads the api-extractor.json config file from the specified file path.   If the \"extends\" field is present,\r\n   * the referenced file(s) will be merged.  For any omitted fields, the API Extractor default values are merged.\r\n   *\r\n   * The result is prepared using `ExtractorConfig.prepare()`.\r\n   */\r\n  public static loadFileAndPrepare(configJsonFilePath: string): ExtractorConfig {\r\n    const configObjectFullPath: string = path.resolve(configJsonFilePath);\r\n    const configObject: IConfigFile = ExtractorConfig.loadFile(configObjectFullPath);\r\n\r\n    const packageJsonLookup: PackageJsonLookup = new PackageJsonLookup();\r\n    const packageJsonFullPath: string | undefined =\r\n      packageJsonLookup.tryGetPackageJsonFilePathFor(configObjectFullPath);\r\n\r\n    const extractorConfig: ExtractorConfig = ExtractorConfig.prepare({\r\n      configObject,\r\n      configObjectFullPath,\r\n      packageJsonFullPath\r\n    });\r\n\r\n    return extractorConfig;\r\n  }\r\n\r\n  /**\r\n   * Performs only the first half of {@link ExtractorConfig.loadFileAndPrepare}, providing an opportunity to\r\n   * modify the object before it is passed to {@link ExtractorConfig.prepare}.\r\n   *\r\n   * @remarks\r\n   * Loads the api-extractor.json config file from the specified file path.   If the \"extends\" field is present,\r\n   * the referenced file(s) will be merged.  For any omitted fields, the API Extractor default values are merged.\r\n   */\r\n  public static loadFile(jsonFilePath: string): IConfigFile {\r\n    // Set to keep track of config files which have been processed.\r\n    const visitedPaths: Set<string> = new Set<string>();\r\n\r\n    let currentConfigFilePath: string = path.resolve(jsonFilePath);\r\n    let configObject: Partial<IConfigFile> = {};\r\n\r\n    try {\r\n      do {\r\n        // Check if this file was already processed.\r\n        if (visitedPaths.has(currentConfigFilePath)) {\r\n          throw new Error(\r\n            `The API Extractor \"extends\" setting contains a cycle.` +\r\n              `  This file is included twice: \"${currentConfigFilePath}\"`\r\n          );\r\n        }\r\n        visitedPaths.add(currentConfigFilePath);\r\n\r\n        const currentConfigFolderPath: string = path.dirname(currentConfigFilePath);\r\n\r\n        // Load the extractor config defined in extends property.\r\n        const baseConfig: IConfigFile = JsonFile.load(currentConfigFilePath);\r\n\r\n        let extendsField: string = baseConfig.extends || '';\r\n\r\n        // Delete the \"extends\" field so it doesn't get merged\r\n        delete baseConfig.extends;\r\n\r\n        if (extendsField) {\r\n          if (extendsField.match(/^\\.\\.?[\\\\/]/)) {\r\n            // EXAMPLE:  \"./subfolder/api-extractor-base.json\"\r\n            extendsField = path.resolve(currentConfigFolderPath, extendsField);\r\n          } else {\r\n            // EXAMPLE:  \"my-package/api-extractor-base.json\"\r\n            //\r\n            // Resolve \"my-package\" from the perspective of the current folder.\r\n            try {\r\n              extendsField = resolve.sync(extendsField, {\r\n                basedir: currentConfigFolderPath\r\n              });\r\n            } catch (e) {\r\n              throw new Error(`Error resolving NodeJS path \"${extendsField}\": ${(e as Error).message}`);\r\n            }\r\n          }\r\n        }\r\n\r\n        // This step has to be performed in advance, since the currentConfigFolderPath information will be lost\r\n        // after lodash.merge() is performed.\r\n        ExtractorConfig._resolveConfigFileRelativePaths(baseConfig, currentConfigFolderPath);\r\n\r\n        // Merge extractorConfig into baseConfig, mutating baseConfig\r\n        lodash.merge(baseConfig, configObject);\r\n        configObject = baseConfig;\r\n\r\n        currentConfigFilePath = extendsField;\r\n      } while (currentConfigFilePath);\r\n    } catch (e) {\r\n      throw new Error(`Error loading ${currentConfigFilePath}:\\n` + (e as Error).message);\r\n    }\r\n\r\n    // Lastly, apply the defaults\r\n    configObject = lodash.merge(lodash.cloneDeep(ExtractorConfig._defaultConfig), configObject);\r\n\r\n    ExtractorConfig.jsonSchema.validateObject(configObject, jsonFilePath);\r\n\r\n    // The schema validation should ensure that this object conforms to IConfigFile\r\n    return configObject as IConfigFile;\r\n  }\r\n\r\n  private static _resolveConfigFileRelativePaths(\r\n    configFile: IConfigFile,\r\n    currentConfigFolderPath: string\r\n  ): void {\r\n    if (configFile.projectFolder) {\r\n      configFile.projectFolder = ExtractorConfig._resolveConfigFileRelativePath(\r\n        'projectFolder',\r\n        configFile.projectFolder,\r\n        currentConfigFolderPath\r\n      );\r\n    }\r\n\r\n    if (configFile.mainEntryPointFilePath) {\r\n      configFile.mainEntryPointFilePath = ExtractorConfig._resolveConfigFileRelativePath(\r\n        'mainEntryPointFilePath',\r\n        configFile.mainEntryPointFilePath,\r\n        currentConfigFolderPath\r\n      );\r\n    }\r\n\r\n    if (configFile.compiler) {\r\n      if (configFile.compiler.tsconfigFilePath) {\r\n        configFile.compiler.tsconfigFilePath = ExtractorConfig._resolveConfigFileRelativePath(\r\n          'tsconfigFilePath',\r\n          configFile.compiler.tsconfigFilePath,\r\n          currentConfigFolderPath\r\n        );\r\n      }\r\n    }\r\n\r\n    if (configFile.apiReport) {\r\n      if (configFile.apiReport.reportFolder) {\r\n        configFile.apiReport.reportFolder = ExtractorConfig._resolveConfigFileRelativePath(\r\n          'reportFolder',\r\n          configFile.apiReport.reportFolder,\r\n          currentConfigFolderPath\r\n        );\r\n      }\r\n      if (configFile.apiReport.reportTempFolder) {\r\n        configFile.apiReport.reportTempFolder = ExtractorConfig._resolveConfigFileRelativePath(\r\n          'reportTempFolder',\r\n          configFile.apiReport.reportTempFolder,\r\n          currentConfigFolderPath\r\n        );\r\n      }\r\n    }\r\n\r\n    if (configFile.docModel) {\r\n      if (configFile.docModel.apiJsonFilePath) {\r\n        configFile.docModel.apiJsonFilePath = ExtractorConfig._resolveConfigFileRelativePath(\r\n          'apiJsonFilePath',\r\n          configFile.docModel.apiJsonFilePath,\r\n          currentConfigFolderPath\r\n        );\r\n      }\r\n    }\r\n\r\n    if (configFile.dtsRollup) {\r\n      if (configFile.dtsRollup.untrimmedFilePath) {\r\n        configFile.dtsRollup.untrimmedFilePath = ExtractorConfig._resolveConfigFileRelativePath(\r\n          'untrimmedFilePath',\r\n          configFile.dtsRollup.untrimmedFilePath,\r\n          currentConfigFolderPath\r\n        );\r\n      }\r\n      if (configFile.dtsRollup.alphaTrimmedFilePath) {\r\n        configFile.dtsRollup.alphaTrimmedFilePath = ExtractorConfig._resolveConfigFileRelativePath(\r\n          'alphaTrimmedFilePath',\r\n          configFile.dtsRollup.alphaTrimmedFilePath,\r\n          currentConfigFolderPath\r\n        );\r\n      }\r\n      if (configFile.dtsRollup.betaTrimmedFilePath) {\r\n        configFile.dtsRollup.betaTrimmedFilePath = ExtractorConfig._resolveConfigFileRelativePath(\r\n          'betaTrimmedFilePath',\r\n          configFile.dtsRollup.betaTrimmedFilePath,\r\n          currentConfigFolderPath\r\n        );\r\n      }\r\n      if (configFile.dtsRollup.publicTrimmedFilePath) {\r\n        configFile.dtsRollup.publicTrimmedFilePath = ExtractorConfig._resolveConfigFileRelativePath(\r\n          'publicTrimmedFilePath',\r\n          configFile.dtsRollup.publicTrimmedFilePath,\r\n          currentConfigFolderPath\r\n        );\r\n      }\r\n    }\r\n\r\n    if (configFile.tsdocMetadata) {\r\n      if (configFile.tsdocMetadata.tsdocMetadataFilePath) {\r\n        configFile.tsdocMetadata.tsdocMetadataFilePath = ExtractorConfig._resolveConfigFileRelativePath(\r\n          'tsdocMetadataFilePath',\r\n          configFile.tsdocMetadata.tsdocMetadataFilePath,\r\n          currentConfigFolderPath\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _resolveConfigFileRelativePath(\r\n    fieldName: string,\r\n    fieldValue: string,\r\n    currentConfigFolderPath: string\r\n  ): string {\r\n    if (!path.isAbsolute(fieldValue)) {\r\n      if (fieldValue.indexOf('<projectFolder>') !== 0) {\r\n        // If the path is not absolute and does not start with \"<projectFolder>\", then resolve it relative\r\n        // to the folder of the config file that it appears in\r\n        return path.join(currentConfigFolderPath, fieldValue);\r\n      }\r\n    }\r\n\r\n    return fieldValue;\r\n  }\r\n\r\n  /**\r\n   * Prepares an `ExtractorConfig` object using a configuration that is provided as a runtime object,\r\n   * rather than reading it from disk.  This allows configurations to be constructed programmatically,\r\n   * loaded from an alternate source, and/or customized after loading.\r\n   */\r\n  public static prepare(options: IExtractorConfigPrepareOptions): ExtractorConfig {\r\n    const filenameForErrors: string = options.configObjectFullPath || 'the configuration object';\r\n    const configObject: Partial<IConfigFile> = options.configObject;\r\n\r\n    if (configObject.extends) {\r\n      throw new Error(\r\n        'The IConfigFile.extends field must be expanded before calling ExtractorConfig.prepare()'\r\n      );\r\n    }\r\n\r\n    if (options.configObjectFullPath) {\r\n      if (!path.isAbsolute(options.configObjectFullPath)) {\r\n        throw new Error('The \"configObjectFullPath\" setting must be an absolute path');\r\n      }\r\n    }\r\n\r\n    ExtractorConfig.jsonSchema.validateObject(configObject, filenameForErrors);\r\n\r\n    const packageJsonFullPath: string | undefined = options.packageJsonFullPath;\r\n    let packageFolder: string | undefined = undefined;\r\n    let packageJson: INodePackageJson | undefined = undefined;\r\n\r\n    if (packageJsonFullPath) {\r\n      if (!/.json$/i.test(packageJsonFullPath)) {\r\n        // Catch common mistakes e.g. where someone passes a folder path instead of a file path\r\n        throw new Error('The \"packageJsonFullPath\" setting does not have a .json file extension');\r\n      }\r\n      if (!path.isAbsolute(packageJsonFullPath)) {\r\n        throw new Error('The \"packageJsonFullPath\" setting must be an absolute path');\r\n      }\r\n\r\n      if (options.packageJson) {\r\n        packageJson = options.packageJson;\r\n      } else {\r\n        const packageJsonLookup: PackageJsonLookup = new PackageJsonLookup();\r\n        packageJson = packageJsonLookup.loadNodePackageJson(packageJsonFullPath);\r\n      }\r\n\r\n      packageFolder = path.dirname(packageJsonFullPath);\r\n    }\r\n\r\n    // \"tsdocConfigFile\" and \"tsdocConfiguration\" are prepared outside the try-catch block,\r\n    // so that if exceptions are thrown, it will not get the \"Error parsing api-extractor.json:\" header\r\n    let extractorConfigParameters: Omit<IExtractorConfigParameters, 'tsdocConfigFile' | 'tsdocConfiguration'>;\r\n\r\n    try {\r\n      if (!configObject.compiler) {\r\n        // A merged configuration should have this\r\n        throw new Error('The \"compiler\" section is missing');\r\n      }\r\n\r\n      if (!configObject.projectFolder) {\r\n        // A merged configuration should have this\r\n        throw new Error('The \"projectFolder\" setting is missing');\r\n      }\r\n\r\n      let projectFolder: string;\r\n      if (configObject.projectFolder.trim() === '<lookup>') {\r\n        if (options.projectFolderLookupToken) {\r\n          // Use the manually specified \"<lookup>\" value\r\n          projectFolder = options.projectFolderLookupToken;\r\n\r\n          if (!FileSystem.exists(options.projectFolderLookupToken)) {\r\n            throw new Error(\r\n              'The specified \"projectFolderLookupToken\" path does not exist: ' +\r\n                options.projectFolderLookupToken\r\n            );\r\n          }\r\n        } else {\r\n          if (!options.configObjectFullPath) {\r\n            throw new Error(\r\n              'The \"projectFolder\" setting uses the \"<lookup>\" token, but it cannot be expanded because' +\r\n                ' the \"configObjectFullPath\" setting was not specified'\r\n            );\r\n          }\r\n\r\n          // \"The default value for `projectFolder` is the token `<lookup>`, which means the folder is determined\r\n          // by traversing parent folders, starting from the folder containing api-extractor.json, and stopping\r\n          // at the first folder that contains a tsconfig.json file.  If a tsconfig.json file cannot be found in\r\n          // this way, then an error will be reported.\"\r\n\r\n          let currentFolder: string = path.dirname(options.configObjectFullPath);\r\n          for (;;) {\r\n            const tsconfigPath: string = path.join(currentFolder, 'tsconfig.json');\r\n            if (FileSystem.exists(tsconfigPath)) {\r\n              projectFolder = currentFolder;\r\n              break;\r\n            }\r\n            const parentFolder: string = path.dirname(currentFolder);\r\n            if (parentFolder === '' || parentFolder === currentFolder) {\r\n              throw new Error(\r\n                'The \"projectFolder\" setting uses the \"<lookup>\" token, but a tsconfig.json file cannot be' +\r\n                  ' found in this folder or any parent folder.'\r\n              );\r\n            }\r\n            currentFolder = parentFolder;\r\n          }\r\n        }\r\n      } else {\r\n        ExtractorConfig._rejectAnyTokensInPath(configObject.projectFolder, 'projectFolder');\r\n\r\n        if (!FileSystem.exists(configObject.projectFolder)) {\r\n          throw new Error('The specified \"projectFolder\" path does not exist: ' + configObject.projectFolder);\r\n        }\r\n\r\n        projectFolder = configObject.projectFolder;\r\n      }\r\n\r\n      const tokenContext: IExtractorConfigTokenContext = {\r\n        unscopedPackageName: 'unknown-package',\r\n        packageName: 'unknown-package',\r\n        projectFolder: projectFolder\r\n      };\r\n\r\n      if (packageJson) {\r\n        tokenContext.packageName = packageJson.name;\r\n        tokenContext.unscopedPackageName = PackageName.getUnscopedName(packageJson.name);\r\n      }\r\n\r\n      if (!configObject.mainEntryPointFilePath) {\r\n        // A merged configuration should have this\r\n        throw new Error('The \"mainEntryPointFilePath\" setting is missing');\r\n      }\r\n      const mainEntryPointFilePath: string = ExtractorConfig._resolvePathWithTokens(\r\n        'mainEntryPointFilePath',\r\n        configObject.mainEntryPointFilePath,\r\n        tokenContext\r\n      );\r\n\r\n      if (!ExtractorConfig.hasDtsFileExtension(mainEntryPointFilePath)) {\r\n        throw new Error(\r\n          'The \"mainEntryPointFilePath\" value is not a declaration file: ' + mainEntryPointFilePath\r\n        );\r\n      }\r\n\r\n      if (!options.ignoreMissingEntryPoint && !FileSystem.exists(mainEntryPointFilePath)) {\r\n        throw new Error('The \"mainEntryPointFilePath\" path does not exist: ' + mainEntryPointFilePath);\r\n      }\r\n\r\n      const bundledPackages: string[] = configObject.bundledPackages || [];\r\n      // Note: we cannot fully validate package name pattern, as the string may be a RegExp pattern.\r\n      // We won't know if the entries are valid until we can compare them against the package.json \"dependencies\" contents.\r\n\r\n      const tsconfigFilePath: string = ExtractorConfig._resolvePathWithTokens(\r\n        'tsconfigFilePath',\r\n        configObject.compiler.tsconfigFilePath,\r\n        tokenContext\r\n      );\r\n\r\n      if (configObject.compiler.overrideTsconfig === undefined) {\r\n        if (!tsconfigFilePath) {\r\n          throw new Error('Either the \"tsconfigFilePath\" or \"overrideTsconfig\" setting must be specified');\r\n        }\r\n        if (!FileSystem.exists(tsconfigFilePath)) {\r\n          throw new Error('The file referenced by \"tsconfigFilePath\" does not exist: ' + tsconfigFilePath);\r\n        }\r\n      }\r\n\r\n      let apiReportEnabled: boolean = false;\r\n      let reportFilePath: string = '';\r\n      let reportTempFilePath: string = '';\r\n      let apiReportIncludeForgottenExports: boolean = false;\r\n      if (configObject.apiReport) {\r\n        apiReportEnabled = !!configObject.apiReport.enabled;\r\n\r\n        const reportFilename: string = ExtractorConfig._expandStringWithTokens(\r\n          'reportFileName',\r\n          configObject.apiReport.reportFileName || '',\r\n          tokenContext\r\n        );\r\n\r\n        if (!reportFilename) {\r\n          // A merged configuration should have this\r\n          throw new Error('The \"reportFilename\" setting is missing');\r\n        }\r\n        if (reportFilename.indexOf('/') >= 0 || reportFilename.indexOf('\\\\') >= 0) {\r\n          // A merged configuration should have this\r\n          throw new Error(`The \"reportFilename\" setting contains invalid characters: \"${reportFilename}\"`);\r\n        }\r\n\r\n        const reportFolder: string = ExtractorConfig._resolvePathWithTokens(\r\n          'reportFolder',\r\n          configObject.apiReport.reportFolder,\r\n          tokenContext\r\n        );\r\n        const reportTempFolder: string = ExtractorConfig._resolvePathWithTokens(\r\n          'reportTempFolder',\r\n          configObject.apiReport.reportTempFolder,\r\n          tokenContext\r\n        );\r\n\r\n        reportFilePath = path.join(reportFolder, reportFilename);\r\n        reportTempFilePath = path.join(reportTempFolder, reportFilename);\r\n        apiReportIncludeForgottenExports = !!configObject.apiReport.includeForgottenExports;\r\n      }\r\n\r\n      let docModelEnabled: boolean = false;\r\n      let apiJsonFilePath: string = '';\r\n      let docModelIncludeForgottenExports: boolean = false;\r\n      let projectFolderUrl: string | undefined;\r\n      if (configObject.docModel) {\r\n        docModelEnabled = !!configObject.docModel.enabled;\r\n        apiJsonFilePath = ExtractorConfig._resolvePathWithTokens(\r\n          'apiJsonFilePath',\r\n          configObject.docModel.apiJsonFilePath,\r\n          tokenContext\r\n        );\r\n        docModelIncludeForgottenExports = !!configObject.docModel.includeForgottenExports;\r\n        projectFolderUrl = configObject.docModel.projectFolderUrl;\r\n      }\r\n\r\n      let tsdocMetadataEnabled: boolean = false;\r\n      let tsdocMetadataFilePath: string = '';\r\n      if (configObject.tsdocMetadata) {\r\n        tsdocMetadataEnabled = !!configObject.tsdocMetadata.enabled;\r\n\r\n        if (tsdocMetadataEnabled) {\r\n          tsdocMetadataFilePath = configObject.tsdocMetadata.tsdocMetadataFilePath || '';\r\n\r\n          if (tsdocMetadataFilePath.trim() === '<lookup>') {\r\n            if (!packageJson) {\r\n              throw new Error(\r\n                'The \"<lookup>\" token cannot be used with the \"tsdocMetadataFilePath\" setting because' +\r\n                  ' the \"packageJson\" option was not provided'\r\n              );\r\n            }\r\n            if (!packageJsonFullPath) {\r\n              throw new Error(\r\n                'The \"<lookup>\" token cannot be used with \"tsdocMetadataFilePath\" because' +\r\n                  'the \"packageJsonFullPath\" option was not provided'\r\n              );\r\n            }\r\n            tsdocMetadataFilePath = PackageMetadataManager.resolveTsdocMetadataPath(\r\n              path.dirname(packageJsonFullPath),\r\n              packageJson\r\n            );\r\n          } else {\r\n            tsdocMetadataFilePath = ExtractorConfig._resolvePathWithTokens(\r\n              'tsdocMetadataFilePath',\r\n              configObject.tsdocMetadata.tsdocMetadataFilePath,\r\n              tokenContext\r\n            );\r\n          }\r\n\r\n          if (!tsdocMetadataFilePath) {\r\n            throw new Error(\r\n              'The \"tsdocMetadata.enabled\" setting is enabled,' +\r\n                ' but \"tsdocMetadataFilePath\" is not specified'\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      let rollupEnabled: boolean = false;\r\n      let untrimmedFilePath: string = '';\r\n      let betaTrimmedFilePath: string = '';\r\n      let alphaTrimmedFilePath: string = '';\r\n      let publicTrimmedFilePath: string = '';\r\n      let omitTrimmingComments: boolean = false;\r\n\r\n      if (configObject.dtsRollup) {\r\n        rollupEnabled = !!configObject.dtsRollup.enabled;\r\n        untrimmedFilePath = ExtractorConfig._resolvePathWithTokens(\r\n          'untrimmedFilePath',\r\n          configObject.dtsRollup.untrimmedFilePath,\r\n          tokenContext\r\n        );\r\n        alphaTrimmedFilePath = ExtractorConfig._resolvePathWithTokens(\r\n          'alphaTrimmedFilePath',\r\n          configObject.dtsRollup.alphaTrimmedFilePath,\r\n          tokenContext\r\n        );\r\n        betaTrimmedFilePath = ExtractorConfig._resolvePathWithTokens(\r\n          'betaTrimmedFilePath',\r\n          configObject.dtsRollup.betaTrimmedFilePath,\r\n          tokenContext\r\n        );\r\n        publicTrimmedFilePath = ExtractorConfig._resolvePathWithTokens(\r\n          'publicTrimmedFilePath',\r\n          configObject.dtsRollup.publicTrimmedFilePath,\r\n          tokenContext\r\n        );\r\n        omitTrimmingComments = !!configObject.dtsRollup.omitTrimmingComments;\r\n      }\r\n\r\n      let newlineKind: NewlineKind;\r\n      switch (configObject.newlineKind) {\r\n        case 'lf':\r\n          newlineKind = NewlineKind.Lf;\r\n          break;\r\n        case 'os':\r\n          newlineKind = NewlineKind.OsDefault;\r\n          break;\r\n        default:\r\n          newlineKind = NewlineKind.CrLf;\r\n          break;\r\n      }\r\n\r\n      const enumMemberOrder: EnumMemberOrder = configObject.enumMemberOrder ?? EnumMemberOrder.ByName;\r\n\r\n      extractorConfigParameters = {\r\n        projectFolder: projectFolder,\r\n        packageJson,\r\n        packageFolder,\r\n        mainEntryPointFilePath,\r\n        bundledPackages,\r\n        tsconfigFilePath,\r\n        overrideTsconfig: configObject.compiler.overrideTsconfig,\r\n        skipLibCheck: !!configObject.compiler.skipLibCheck,\r\n        apiReportEnabled,\r\n        reportFilePath,\r\n        reportTempFilePath,\r\n        apiReportIncludeForgottenExports,\r\n        docModelEnabled,\r\n        apiJsonFilePath,\r\n        docModelIncludeForgottenExports,\r\n        projectFolderUrl,\r\n        rollupEnabled,\r\n        untrimmedFilePath,\r\n        alphaTrimmedFilePath,\r\n        betaTrimmedFilePath,\r\n        publicTrimmedFilePath,\r\n        omitTrimmingComments,\r\n        tsdocMetadataEnabled,\r\n        tsdocMetadataFilePath,\r\n        newlineKind,\r\n        messages: configObject.messages || {},\r\n        testMode: !!configObject.testMode,\r\n        enumMemberOrder\r\n      };\r\n    } catch (e) {\r\n      throw new Error(`Error parsing ${filenameForErrors}:\\n` + (e as Error).message);\r\n    }\r\n\r\n    let tsdocConfigFile: TSDocConfigFile | undefined = options.tsdocConfigFile;\r\n\r\n    if (!tsdocConfigFile) {\r\n      // Example: \"my-project/tsdoc.json\"\r\n      let packageTSDocConfigPath: string = TSDocConfigFile.findConfigPathForFolder(\r\n        extractorConfigParameters.projectFolder\r\n      );\r\n\r\n      if (!packageTSDocConfigPath || !FileSystem.exists(packageTSDocConfigPath)) {\r\n        // If the project does not have a tsdoc.json config file, then use API Extractor's base file.\r\n        packageTSDocConfigPath = ExtractorConfig._tsdocBaseFilePath;\r\n        if (!FileSystem.exists(packageTSDocConfigPath)) {\r\n          throw new InternalError('Unable to load the built-in TSDoc config file: ' + packageTSDocConfigPath);\r\n        }\r\n      }\r\n      tsdocConfigFile = TSDocConfigFile.loadFile(packageTSDocConfigPath);\r\n    }\r\n\r\n    // IMPORTANT: After calling TSDocConfigFile.loadFile(), we need to check for errors.\r\n    if (tsdocConfigFile.hasErrors) {\r\n      throw new Error(tsdocConfigFile.getErrorSummary());\r\n    }\r\n\r\n    const tsdocConfiguration: TSDocConfiguration = new TSDocConfiguration();\r\n    tsdocConfigFile.configureParser(tsdocConfiguration);\r\n\r\n    // IMPORTANT: After calling TSDocConfigFile.configureParser(), we need to check for errors a second time.\r\n    if (tsdocConfigFile.hasErrors) {\r\n      throw new Error(tsdocConfigFile.getErrorSummary());\r\n    }\r\n\r\n    return new ExtractorConfig({ ...extractorConfigParameters, tsdocConfigFile, tsdocConfiguration });\r\n  }\r\n\r\n  private static _resolvePathWithTokens(\r\n    fieldName: string,\r\n    value: string | undefined,\r\n    tokenContext: IExtractorConfigTokenContext\r\n  ): string {\r\n    value = ExtractorConfig._expandStringWithTokens(fieldName, value, tokenContext);\r\n    if (value !== '') {\r\n      value = path.resolve(tokenContext.projectFolder, value);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  private static _expandStringWithTokens(\r\n    fieldName: string,\r\n    value: string | undefined,\r\n    tokenContext: IExtractorConfigTokenContext\r\n  ): string {\r\n    value = value ? value.trim() : '';\r\n    if (value !== '') {\r\n      value = Text.replaceAll(value, '<unscopedPackageName>', tokenContext.unscopedPackageName);\r\n      value = Text.replaceAll(value, '<packageName>', tokenContext.packageName);\r\n\r\n      const projectFolderToken: string = '<projectFolder>';\r\n      if (value.indexOf(projectFolderToken) === 0) {\r\n        // Replace \"<projectFolder>\" at the start of a string\r\n        value = path.join(tokenContext.projectFolder, value.substr(projectFolderToken.length));\r\n      }\r\n\r\n      if (value.indexOf(projectFolderToken) >= 0) {\r\n        // If after all replacements, \"<projectFolder>\" appears somewhere in the string, report an error\r\n        throw new Error(\r\n          `The \"${fieldName}\" value incorrectly uses the \"<projectFolder>\" token.` +\r\n            ` It must appear at the start of the string.`\r\n        );\r\n      }\r\n\r\n      if (value.indexOf('<lookup>') >= 0) {\r\n        throw new Error(`The \"${fieldName}\" value incorrectly uses the \"<lookup>\" token`);\r\n      }\r\n      ExtractorConfig._rejectAnyTokensInPath(value, fieldName);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the specified file path has the \".d.ts\" file extension.\r\n   */\r\n  public static hasDtsFileExtension(filePath: string): boolean {\r\n    return ExtractorConfig._declarationFileExtensionRegExp.test(filePath);\r\n  }\r\n\r\n  /**\r\n   * Given a path string that may have originally contained expandable tokens such as `<projectFolder>\"`\r\n   * this reports an error if any token-looking substrings remain after expansion (e.g. `c:\\blah\\<invalid>\\blah`).\r\n   */\r\n  private static _rejectAnyTokensInPath(value: string, fieldName: string): void {\r\n    if (value.indexOf('<') < 0 && value.indexOf('>') < 0) {\r\n      return;\r\n    }\r\n\r\n    // Can we determine the name of a token?\r\n    const tokenRegExp: RegExp = /(\\<[^<]*?\\>)/;\r\n    const match: RegExpExecArray | null = tokenRegExp.exec(value);\r\n    if (match) {\r\n      throw new Error(`The \"${fieldName}\" value contains an unrecognized token \"${match[1]}\"`);\r\n    }\r\n    throw new Error(`The \"${fieldName}\" value contains extra token characters (\"<\" or \">\"): ${value}`);\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/api/ExtractorLogLevel.js.map b/lib/api/ExtractorLogLevel.js.map
index ac6522c2b459ddca8a4d88a76fbe6a2ebd2f5f37..f5a2ac3c02d23e46e4abe89a441b2937cb442827 100644
--- a/lib/api/ExtractorLogLevel.js.map
+++ b/lib/api/ExtractorLogLevel.js.map
@@ -1 +1 @@
-{"version":3,"file":"ExtractorLogLevel.js","sourceRoot":"","sources":["../../src/api/ExtractorLogLevel.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/**\n * Used with {@link IConfigMessageReportingRule.logLevel} and {@link IExtractorInvokeOptions.messageCallback}.\n *\n * @remarks\n * This is part of the {@link IConfigFile} structure.\n *\n * @public\n */\nexport const enum ExtractorLogLevel {\n  /**\n   * The message will be displayed as an error.\n   *\n   * @remarks\n   * Errors typically cause the build to fail and return a nonzero exit code.\n   */\n  Error = 'error',\n\n  /**\n   * The message will be displayed as an warning.\n   *\n   * @remarks\n   * Warnings typically cause a production build fail and return a nonzero exit code.  For a non-production build\n   * (e.g. using the `--local` option with `api-extractor run`), the warning is displayed but the build will not fail.\n   */\n  Warning = 'warning',\n\n  /**\n   * The message will be displayed as an informational message.\n   *\n   * @remarks\n   * Informational messages may contain newlines to ensure nice formatting of the output,\n   * however word-wrapping is the responsibility of the message handler.\n   */\n  Info = 'info',\n\n  /**\n   * The message will be displayed only when \"verbose\" output is requested, e.g. using the `--verbose`\n   * command line option.\n   */\n  Verbose = 'verbose',\n\n  /**\n   * The message will be discarded entirely.\n   */\n  None = 'none'\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ExtractorLogLevel.js","sourceRoot":"","sources":["../../src/api/ExtractorLogLevel.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/**\r\n * Used with {@link IConfigMessageReportingRule.logLevel} and {@link IExtractorInvokeOptions.messageCallback}.\r\n *\r\n * @remarks\r\n * This is part of the {@link IConfigFile} structure.\r\n *\r\n * @public\r\n */\r\nexport const enum ExtractorLogLevel {\r\n  /**\r\n   * The message will be displayed as an error.\r\n   *\r\n   * @remarks\r\n   * Errors typically cause the build to fail and return a nonzero exit code.\r\n   */\r\n  Error = 'error',\r\n\r\n  /**\r\n   * The message will be displayed as an warning.\r\n   *\r\n   * @remarks\r\n   * Warnings typically cause a production build fail and return a nonzero exit code.  For a non-production build\r\n   * (e.g. using the `--local` option with `api-extractor run`), the warning is displayed but the build will not fail.\r\n   */\r\n  Warning = 'warning',\r\n\r\n  /**\r\n   * The message will be displayed as an informational message.\r\n   *\r\n   * @remarks\r\n   * Informational messages may contain newlines to ensure nice formatting of the output,\r\n   * however word-wrapping is the responsibility of the message handler.\r\n   */\r\n  Info = 'info',\r\n\r\n  /**\r\n   * The message will be displayed only when \"verbose\" output is requested, e.g. using the `--verbose`\r\n   * command line option.\r\n   */\r\n  Verbose = 'verbose',\r\n\r\n  /**\r\n   * The message will be discarded entirely.\r\n   */\r\n  None = 'none'\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/api/ExtractorMessage.js.map b/lib/api/ExtractorMessage.js.map
index c96d557eee2b3c627598f2f3cc8bc2bd5b46ddfe..a969c1a86c73c7481958b21f21948f0a738a1537 100644
--- a/lib/api/ExtractorMessage.js.map
+++ b/lib/api/ExtractorMessage.js.map
@@ -1 +1 @@
-{"version":3,"file":"ExtractorMessage.js","sourceRoot":"","sources":["../../src/api/ExtractorMessage.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAM3D,yFAAsF;AA4EtF;;;;GAIG;AACH,MAAa,gBAAgB;IA2C3B,gBAAgB;IAChB,YAAmB,OAAiC;QAClD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;QACjC,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;QACzB,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;QAC7C,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;QAC7C,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC,gBAAgB,CAAC;QACjD,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,IAAI,EAAE,CAAC;QAE3C,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,QAAQ,uCAA0B,CAAC;IAC9D,CAAC;IAED;;;;;;;;;;;OAWG;IACH,IAAW,OAAO;QAChB,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED,IAAW,OAAO,CAAC,KAAc;QAC/B,IAAI,IAAI,CAAC,QAAQ,IAAI,CAAC,KAAK,EAAE;YAC3B,MAAM,IAAI,KAAK,CACb,yFAAyF,CAC1F,CAAC;SACH;QACD,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;IACxB,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC;IAED,IAAW,QAAQ,CAAC,KAAwB;QAC1C,QAAQ,KAAK,EAAE;YACb,2CAA6B;YAC7B,yCAA4B;YAC5B,yCAA4B;YAC5B,+CAA+B;YAC/B;gBACE,MAAM;YACR;gBACE,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;SACxC;QACD,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;IACzB,CAAC;IAED;;;;;;;OAOG;IACI,yBAAyB,CAAC,wBAA4C;QAC3E,IAAI,MAAM,GAAW,EAAE,CAAC;QAExB,IAAI,IAAI,CAAC,cAAc,EAAE;YACvB,MAAM,IAAI,yDAA2B,CAAC,UAAU,CAAC,IAAI,CAAC,cAAc,EAAE;gBACpE,cAAc,EAAE,IAAI,CAAC,cAAc;gBACnC,gBAAgB,EAAE,IAAI,CAAC,gBAAgB;gBACvC,wBAAwB;aACzB,CAAC,CAAC;YAEH,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;gBACrB,MAAM,IAAI,KAAK,CAAC;aACjB;SACF;QAED,MAAM,IAAI,IAAI,CAAC,4BAA4B,EAAE,CAAC;QAE9C,OAAO,MAAM,CAAC;IAChB,CAAC;IAEM,4BAA4B;QACjC,OAAO,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,CAAC,IAAI,EAAE,CAAC;IAC5C,CAAC;CACF;AAhJD,4CAgJC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type * as tsdoc from '@microsoft/tsdoc';\nimport type { ExtractorMessageId } from './ExtractorMessageId';\nimport { ExtractorLogLevel } from './ExtractorLogLevel';\nimport type { ConsoleMessageId } from './ConsoleMessageId';\nimport { SourceFileLocationFormatter } from '../analyzer/SourceFileLocationFormatter';\n\n/**\n * Used by {@link ExtractorMessage.properties}.\n *\n * @public\n */\nexport interface IExtractorMessageProperties {\n  /**\n   * A declaration can have multiple names if it is exported more than once.\n   * If an `ExtractorMessage` applies to a specific export name, this property can indicate that.\n   *\n   * @remarks\n   *\n   * Used by {@link ExtractorMessageId.InternalMissingUnderscore}.\n   */\n  readonly exportName?: string;\n}\n\n/**\n * Specifies a category of messages for use with {@link ExtractorMessage}.\n * @public\n */\nexport const enum ExtractorMessageCategory {\n  /**\n   * Messages originating from the TypeScript compiler.\n   *\n   * @remarks\n   * These strings begin with the prefix \"TS\" and have a numeric error code.\n   * Example: `TS2551`\n   */\n  Compiler = 'Compiler',\n\n  /**\n   * Messages related to parsing of TSDoc comments.\n   *\n   * @remarks\n   * These strings begin with the prefix \"tsdoc-\".\n   * Example: `tsdoc-link-tag-unescaped-text`\n   */\n  TSDoc = 'TSDoc',\n\n  /**\n   * Messages related to API Extractor's analysis.\n   *\n   * @remarks\n   * These strings begin with the prefix \"ae-\".\n   * Example: `ae-extra-release-tag`\n   */\n  Extractor = 'Extractor',\n\n  /**\n   * Console messages communicate the progress of the overall operation.  They may include newlines to ensure\n   * nice formatting.  They are output in real time, and cannot be routed to the API Report file.\n   *\n   * @remarks\n   * These strings begin with the prefix \"console-\".\n   * Example: `console-writing-typings-file`\n   */\n  Console = 'console'\n}\n\n/**\n * Constructor options for `ExtractorMessage`.\n */\nexport interface IExtractorMessageOptions {\n  category: ExtractorMessageCategory;\n  messageId: tsdoc.TSDocMessageId | ExtractorMessageId | ConsoleMessageId | string;\n  text: string;\n  sourceFilePath?: string;\n  sourceFileLine?: number;\n  sourceFileColumn?: number;\n  properties?: IExtractorMessageProperties;\n  logLevel?: ExtractorLogLevel;\n}\n\n/**\n * This object is used to report an error or warning that occurred during API Extractor's analysis.\n *\n * @public\n */\nexport class ExtractorMessage {\n  private _handled: boolean;\n  private _logLevel: ExtractorLogLevel;\n\n  /**\n   * The category of issue.\n   */\n  public readonly category: ExtractorMessageCategory;\n\n  /**\n   * A text string that uniquely identifies the issue type.  This identifier can be used to suppress\n   * or configure the reporting of issues, and also to search for help about an issue.\n   */\n  public readonly messageId: tsdoc.TSDocMessageId | ExtractorMessageId | ConsoleMessageId | string;\n\n  /**\n   * The text description of this issue.\n   */\n  public readonly text: string;\n\n  /**\n   * The absolute path to the affected input source file, if there is one.\n   */\n  public readonly sourceFilePath: string | undefined;\n\n  /**\n   * The line number where the issue occurred in the input source file.  This is not used if `sourceFilePath`\n   * is undefined.  The first line number is 1.\n   */\n  public readonly sourceFileLine: number | undefined;\n\n  /**\n   * The column number where the issue occurred in the input source file.  This is not used if `sourceFilePath`\n   * is undefined.  The first column number is 1.\n   */\n  public readonly sourceFileColumn: number | undefined;\n\n  /**\n   * Additional contextual information about the message that may be useful when reporting errors.\n   * All properties are optional.\n   */\n  public readonly properties: IExtractorMessageProperties;\n\n  /** @internal */\n  public constructor(options: IExtractorMessageOptions) {\n    this.category = options.category;\n    this.messageId = options.messageId;\n    this.text = options.text;\n    this.sourceFilePath = options.sourceFilePath;\n    this.sourceFileLine = options.sourceFileLine;\n    this.sourceFileColumn = options.sourceFileColumn;\n    this.properties = options.properties || {};\n\n    this._handled = false;\n    this._logLevel = options.logLevel || ExtractorLogLevel.None;\n  }\n\n  /**\n   * If the {@link IExtractorInvokeOptions.messageCallback} sets this property to true, it will prevent the message\n   * from being displayed by API Extractor.\n   *\n   * @remarks\n   * If the `messageCallback` routes the message to a custom handler (e.g. a toolchain logger), it should\n   * assign `handled = true` to prevent API Extractor from displaying it.  Assigning `handled = true` for all messages\n   * would effectively disable all console output from the `Extractor` API.\n   *\n   * If `handled` is set to true, the message will still be included in the count of errors/warnings;\n   * to discard a message entirely, instead assign `logLevel = none`.\n   */\n  public get handled(): boolean {\n    return this._handled;\n  }\n\n  public set handled(value: boolean) {\n    if (this._handled && !value) {\n      throw new Error(\n        'One a message has been marked as handled, the \"handled\" property cannot be set to false'\n      );\n    }\n    this._handled = value;\n  }\n\n  /**\n   * Specifies how the message should be reported.\n   *\n   * @remarks\n   * If the {@link IExtractorInvokeOptions.messageCallback} handles the message (i.e. sets `handled = true`),\n   * it can use the `logLevel` to determine how to display the message.\n   *\n   * Alternatively, if API Extractor is handling the message, the `messageCallback` could assign `logLevel` to change\n   * how it will be processed.  However, in general the recommended practice is to configure message routing\n   * using the `messages` section in api-extractor.json.\n   *\n   * To discard a message entirely, assign `logLevel = none`.\n   */\n  public get logLevel(): ExtractorLogLevel {\n    return this._logLevel;\n  }\n\n  public set logLevel(value: ExtractorLogLevel) {\n    switch (value) {\n      case ExtractorLogLevel.Error:\n      case ExtractorLogLevel.Info:\n      case ExtractorLogLevel.None:\n      case ExtractorLogLevel.Verbose:\n      case ExtractorLogLevel.Warning:\n        break;\n      default:\n        throw new Error('Invalid log level');\n    }\n    this._logLevel = value;\n  }\n\n  /**\n   * Returns the message formatted with its identifier and file position.\n   * @remarks\n   * Example:\n   * ```\n   * src/folder/File.ts:123:4 - (ae-extra-release-tag) The doc comment should not contain more than one release tag.\n   * ```\n   */\n  public formatMessageWithLocation(workingPackageFolderPath: string | undefined): string {\n    let result: string = '';\n\n    if (this.sourceFilePath) {\n      result += SourceFileLocationFormatter.formatPath(this.sourceFilePath, {\n        sourceFileLine: this.sourceFileLine,\n        sourceFileColumn: this.sourceFileColumn,\n        workingPackageFolderPath\n      });\n\n      if (result.length > 0) {\n        result += ' - ';\n      }\n    }\n\n    result += this.formatMessageWithoutLocation();\n\n    return result;\n  }\n\n  public formatMessageWithoutLocation(): string {\n    return `(${this.messageId}) ${this.text}`;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ExtractorMessage.js","sourceRoot":"","sources":["../../src/api/ExtractorMessage.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAM3D,yFAAsF;AA4EtF;;;;GAIG;AACH,MAAa,gBAAgB;IA2C3B,gBAAgB;IAChB,YAAmB,OAAiC;QAClD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;QACjC,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;QACzB,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;QAC7C,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;QAC7C,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC,gBAAgB,CAAC;QACjD,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,IAAI,EAAE,CAAC;QAE3C,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,QAAQ,uCAA0B,CAAC;IAC9D,CAAC;IAED;;;;;;;;;;;OAWG;IACH,IAAW,OAAO;QAChB,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED,IAAW,OAAO,CAAC,KAAc;QAC/B,IAAI,IAAI,CAAC,QAAQ,IAAI,CAAC,KAAK,EAAE;YAC3B,MAAM,IAAI,KAAK,CACb,yFAAyF,CAC1F,CAAC;SACH;QACD,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;IACxB,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC;IAED,IAAW,QAAQ,CAAC,KAAwB;QAC1C,QAAQ,KAAK,EAAE;YACb,2CAA6B;YAC7B,yCAA4B;YAC5B,yCAA4B;YAC5B,+CAA+B;YAC/B;gBACE,MAAM;YACR;gBACE,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;SACxC;QACD,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;IACzB,CAAC;IAED;;;;;;;OAOG;IACI,yBAAyB,CAAC,wBAA4C;QAC3E,IAAI,MAAM,GAAW,EAAE,CAAC;QAExB,IAAI,IAAI,CAAC,cAAc,EAAE;YACvB,MAAM,IAAI,yDAA2B,CAAC,UAAU,CAAC,IAAI,CAAC,cAAc,EAAE;gBACpE,cAAc,EAAE,IAAI,CAAC,cAAc;gBACnC,gBAAgB,EAAE,IAAI,CAAC,gBAAgB;gBACvC,wBAAwB;aACzB,CAAC,CAAC;YAEH,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;gBACrB,MAAM,IAAI,KAAK,CAAC;aACjB;SACF;QAED,MAAM,IAAI,IAAI,CAAC,4BAA4B,EAAE,CAAC;QAE9C,OAAO,MAAM,CAAC;IAChB,CAAC;IAEM,4BAA4B;QACjC,OAAO,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,CAAC,IAAI,EAAE,CAAC;IAC5C,CAAC;CACF;AAhJD,4CAgJC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport type * as tsdoc from '@microsoft/tsdoc';\r\nimport type { ExtractorMessageId } from './ExtractorMessageId';\r\nimport { ExtractorLogLevel } from './ExtractorLogLevel';\r\nimport type { ConsoleMessageId } from './ConsoleMessageId';\r\nimport { SourceFileLocationFormatter } from '../analyzer/SourceFileLocationFormatter';\r\n\r\n/**\r\n * Used by {@link ExtractorMessage.properties}.\r\n *\r\n * @public\r\n */\r\nexport interface IExtractorMessageProperties {\r\n  /**\r\n   * A declaration can have multiple names if it is exported more than once.\r\n   * If an `ExtractorMessage` applies to a specific export name, this property can indicate that.\r\n   *\r\n   * @remarks\r\n   *\r\n   * Used by {@link ExtractorMessageId.InternalMissingUnderscore}.\r\n   */\r\n  readonly exportName?: string;\r\n}\r\n\r\n/**\r\n * Specifies a category of messages for use with {@link ExtractorMessage}.\r\n * @public\r\n */\r\nexport const enum ExtractorMessageCategory {\r\n  /**\r\n   * Messages originating from the TypeScript compiler.\r\n   *\r\n   * @remarks\r\n   * These strings begin with the prefix \"TS\" and have a numeric error code.\r\n   * Example: `TS2551`\r\n   */\r\n  Compiler = 'Compiler',\r\n\r\n  /**\r\n   * Messages related to parsing of TSDoc comments.\r\n   *\r\n   * @remarks\r\n   * These strings begin with the prefix \"tsdoc-\".\r\n   * Example: `tsdoc-link-tag-unescaped-text`\r\n   */\r\n  TSDoc = 'TSDoc',\r\n\r\n  /**\r\n   * Messages related to API Extractor's analysis.\r\n   *\r\n   * @remarks\r\n   * These strings begin with the prefix \"ae-\".\r\n   * Example: `ae-extra-release-tag`\r\n   */\r\n  Extractor = 'Extractor',\r\n\r\n  /**\r\n   * Console messages communicate the progress of the overall operation.  They may include newlines to ensure\r\n   * nice formatting.  They are output in real time, and cannot be routed to the API Report file.\r\n   *\r\n   * @remarks\r\n   * These strings begin with the prefix \"console-\".\r\n   * Example: `console-writing-typings-file`\r\n   */\r\n  Console = 'console'\r\n}\r\n\r\n/**\r\n * Constructor options for `ExtractorMessage`.\r\n */\r\nexport interface IExtractorMessageOptions {\r\n  category: ExtractorMessageCategory;\r\n  messageId: tsdoc.TSDocMessageId | ExtractorMessageId | ConsoleMessageId | string;\r\n  text: string;\r\n  sourceFilePath?: string;\r\n  sourceFileLine?: number;\r\n  sourceFileColumn?: number;\r\n  properties?: IExtractorMessageProperties;\r\n  logLevel?: ExtractorLogLevel;\r\n}\r\n\r\n/**\r\n * This object is used to report an error or warning that occurred during API Extractor's analysis.\r\n *\r\n * @public\r\n */\r\nexport class ExtractorMessage {\r\n  private _handled: boolean;\r\n  private _logLevel: ExtractorLogLevel;\r\n\r\n  /**\r\n   * The category of issue.\r\n   */\r\n  public readonly category: ExtractorMessageCategory;\r\n\r\n  /**\r\n   * A text string that uniquely identifies the issue type.  This identifier can be used to suppress\r\n   * or configure the reporting of issues, and also to search for help about an issue.\r\n   */\r\n  public readonly messageId: tsdoc.TSDocMessageId | ExtractorMessageId | ConsoleMessageId | string;\r\n\r\n  /**\r\n   * The text description of this issue.\r\n   */\r\n  public readonly text: string;\r\n\r\n  /**\r\n   * The absolute path to the affected input source file, if there is one.\r\n   */\r\n  public readonly sourceFilePath: string | undefined;\r\n\r\n  /**\r\n   * The line number where the issue occurred in the input source file.  This is not used if `sourceFilePath`\r\n   * is undefined.  The first line number is 1.\r\n   */\r\n  public readonly sourceFileLine: number | undefined;\r\n\r\n  /**\r\n   * The column number where the issue occurred in the input source file.  This is not used if `sourceFilePath`\r\n   * is undefined.  The first column number is 1.\r\n   */\r\n  public readonly sourceFileColumn: number | undefined;\r\n\r\n  /**\r\n   * Additional contextual information about the message that may be useful when reporting errors.\r\n   * All properties are optional.\r\n   */\r\n  public readonly properties: IExtractorMessageProperties;\r\n\r\n  /** @internal */\r\n  public constructor(options: IExtractorMessageOptions) {\r\n    this.category = options.category;\r\n    this.messageId = options.messageId;\r\n    this.text = options.text;\r\n    this.sourceFilePath = options.sourceFilePath;\r\n    this.sourceFileLine = options.sourceFileLine;\r\n    this.sourceFileColumn = options.sourceFileColumn;\r\n    this.properties = options.properties || {};\r\n\r\n    this._handled = false;\r\n    this._logLevel = options.logLevel || ExtractorLogLevel.None;\r\n  }\r\n\r\n  /**\r\n   * If the {@link IExtractorInvokeOptions.messageCallback} sets this property to true, it will prevent the message\r\n   * from being displayed by API Extractor.\r\n   *\r\n   * @remarks\r\n   * If the `messageCallback` routes the message to a custom handler (e.g. a toolchain logger), it should\r\n   * assign `handled = true` to prevent API Extractor from displaying it.  Assigning `handled = true` for all messages\r\n   * would effectively disable all console output from the `Extractor` API.\r\n   *\r\n   * If `handled` is set to true, the message will still be included in the count of errors/warnings;\r\n   * to discard a message entirely, instead assign `logLevel = none`.\r\n   */\r\n  public get handled(): boolean {\r\n    return this._handled;\r\n  }\r\n\r\n  public set handled(value: boolean) {\r\n    if (this._handled && !value) {\r\n      throw new Error(\r\n        'One a message has been marked as handled, the \"handled\" property cannot be set to false'\r\n      );\r\n    }\r\n    this._handled = value;\r\n  }\r\n\r\n  /**\r\n   * Specifies how the message should be reported.\r\n   *\r\n   * @remarks\r\n   * If the {@link IExtractorInvokeOptions.messageCallback} handles the message (i.e. sets `handled = true`),\r\n   * it can use the `logLevel` to determine how to display the message.\r\n   *\r\n   * Alternatively, if API Extractor is handling the message, the `messageCallback` could assign `logLevel` to change\r\n   * how it will be processed.  However, in general the recommended practice is to configure message routing\r\n   * using the `messages` section in api-extractor.json.\r\n   *\r\n   * To discard a message entirely, assign `logLevel = none`.\r\n   */\r\n  public get logLevel(): ExtractorLogLevel {\r\n    return this._logLevel;\r\n  }\r\n\r\n  public set logLevel(value: ExtractorLogLevel) {\r\n    switch (value) {\r\n      case ExtractorLogLevel.Error:\r\n      case ExtractorLogLevel.Info:\r\n      case ExtractorLogLevel.None:\r\n      case ExtractorLogLevel.Verbose:\r\n      case ExtractorLogLevel.Warning:\r\n        break;\r\n      default:\r\n        throw new Error('Invalid log level');\r\n    }\r\n    this._logLevel = value;\r\n  }\r\n\r\n  /**\r\n   * Returns the message formatted with its identifier and file position.\r\n   * @remarks\r\n   * Example:\r\n   * ```\r\n   * src/folder/File.ts:123:4 - (ae-extra-release-tag) The doc comment should not contain more than one release tag.\r\n   * ```\r\n   */\r\n  public formatMessageWithLocation(workingPackageFolderPath: string | undefined): string {\r\n    let result: string = '';\r\n\r\n    if (this.sourceFilePath) {\r\n      result += SourceFileLocationFormatter.formatPath(this.sourceFilePath, {\r\n        sourceFileLine: this.sourceFileLine,\r\n        sourceFileColumn: this.sourceFileColumn,\r\n        workingPackageFolderPath\r\n      });\r\n\r\n      if (result.length > 0) {\r\n        result += ' - ';\r\n      }\r\n    }\r\n\r\n    result += this.formatMessageWithoutLocation();\r\n\r\n    return result;\r\n  }\r\n\r\n  public formatMessageWithoutLocation(): string {\r\n    return `(${this.messageId}) ${this.text}`;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/api/ExtractorMessageId.js.map b/lib/api/ExtractorMessageId.js.map
index 6bccd50734f941914d38b313abd28d2522a37ce4..e54efdbda498fae3e76fb3e22275d2a8209066aa 100644
--- a/lib/api/ExtractorMessageId.js.map
+++ b/lib/api/ExtractorMessageId.js.map
@@ -1 +1 @@
-{"version":3,"file":"ExtractorMessageId.js","sourceRoot":"","sources":["../../src/api/ExtractorMessageId.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AA4H9C,QAAA,sBAAsB,GAAgB,IAAI,GAAG,CAAS;IACjE,sBAAsB;IACtB,iBAAiB;IACjB,2BAA2B;IAC3B,8BAA8B;IAC9B,wBAAwB;IACxB,0BAA0B;IAC1B,qBAAqB;IACrB,gCAAgC;IAChC,+BAA+B;IAC/B,iCAAiC;IACjC,gCAAgC;IAChC,oCAAoC;IACpC,+BAA+B;IAC/B,uBAAuB;IACvB,oBAAoB;IACpB,qBAAqB;IACrB,mBAAmB;IACnB,0BAA0B;CAC3B,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/**\n * Unique identifiers for messages reported by API Extractor during its analysis.\n *\n * @remarks\n *\n * These strings are possible values for the {@link ExtractorMessage.messageId} property\n * when the `ExtractorMessage.category` is {@link ExtractorMessageCategory.Extractor}.\n *\n * @public\n */\nexport const enum ExtractorMessageId {\n  /**\n   * \"The doc comment should not contain more than one release tag.\"\n   */\n  ExtraReleaseTag = 'ae-extra-release-tag',\n\n  /**\n   * \"Missing documentation for ___.\"\n   * @remarks\n   * The `ae-undocumented` message is only generated if the API report feature is enabled.\n   *\n   * Because the API report file already annotates undocumented items with `// (undocumented)`,\n   * the `ae-undocumented` message is not logged by default.  To see it, add a setting such as:\n   * ```json\n   * \"messages\": {\n   *   \"extractorMessageReporting\": {\n   *     \"ae-undocumented\": {\n   *       \"logLevel\": \"warning\"\n   *     }\n   *   }\n   *  }\n   * ```\n   */\n  Undocumented = 'ae-undocumented',\n\n  /**\n   * \"This symbol has another declaration with a different release tag.\"\n   */\n  DifferentReleaseTags = 'ae-different-release-tags',\n\n  /**\n   * \"The symbol ___ is marked as ___, but its signature references ___ which is marked as ___.\"\n   */\n  IncompatibleReleaseTags = 'ae-incompatible-release-tags',\n\n  /**\n   * \"___ is part of the package's API, but it is missing a release tag (`@alpha`, `@beta`, `@public`, or `@internal`).\"\n   */\n  MissingReleaseTag = 'ae-missing-release-tag',\n\n  /**\n   * \"The `@packageDocumentation` comment must appear at the top of entry point *.d.ts file.\"\n   */\n  MisplacedPackageTag = 'ae-misplaced-package-tag',\n\n  /**\n   * \"The symbol ___ needs to be exported by the entry point ___.\"\n   */\n  ForgottenExport = 'ae-forgotten-export',\n\n  /**\n   * \"The name ___ should be prefixed with an underscore because the declaration is marked as `@internal`.\"\n   */\n  InternalMissingUnderscore = 'ae-internal-missing-underscore',\n\n  /**\n   * \"Mixed release tags are not allowed for ___ because one of its declarations is marked as `@internal`.\"\n   */\n  InternalMixedReleaseTag = 'ae-internal-mixed-release-tag',\n\n  /**\n   * \"The `@preapproved` tag cannot be applied to ___ because it is not a supported declaration type.\"\n   */\n  PreapprovedUnsupportedType = 'ae-preapproved-unsupported-type',\n\n  /**\n   * \"The `@preapproved` tag cannot be applied to ___ without an `@internal` release tag.\"\n   */\n  PreapprovedBadReleaseTag = 'ae-preapproved-bad-release-tag',\n\n  /**\n   * \"The `@inheritDoc` reference could not be resolved.\"\n   */\n  UnresolvedInheritDocReference = 'ae-unresolved-inheritdoc-reference',\n\n  /**\n   * \"The `@inheritDoc` tag needs a TSDoc declaration reference; signature matching is not supported yet.\"\n   *\n   * @privateRemarks\n   * In the future, we will implement signature matching so that you can write `{@inheritDoc}` and API Extractor\n   * will find a corresponding member from a base class (or implemented interface).  Until then, the tag\n   * always needs an explicit declaration reference such as `{@inhertDoc MyBaseClass.sameMethod}`.\n   */\n  UnresolvedInheritDocBase = 'ae-unresolved-inheritdoc-base',\n\n  /**\n   * \"The `@inheritDoc` tag for ___ refers to its own declaration.\"\n   */\n  CyclicInheritDoc = 'ae-cyclic-inherit-doc',\n\n  /**\n   * \"The `@link` reference could not be resolved.\"\n   */\n  UnresolvedLink = 'ae-unresolved-link',\n\n  /**\n   * \"The doc comment for the property ___ must appear on the getter, not the setter.\"\n   */\n  SetterWithDocs = 'ae-setter-with-docs',\n\n  /**\n   * \"The property ___ has a setter but no getter.\"\n   */\n  MissingGetter = 'ae-missing-getter',\n\n  /**\n   * \"Incorrect file type; API Extractor expects to analyze compiler outputs with the .d.ts file extension.\n   * Troubleshooting tips: `https://api-extractor.com/link/dts-error`\"\n   */\n  WrongInputFileType = 'ae-wrong-input-file-type'\n}\n\nexport const allExtractorMessageIds: Set<string> = new Set<string>([\n  'ae-extra-release-tag',\n  'ae-undocumented',\n  'ae-different-release-tags',\n  'ae-incompatible-release-tags',\n  'ae-missing-release-tag',\n  'ae-misplaced-package-tag',\n  'ae-forgotten-export',\n  'ae-internal-missing-underscore',\n  'ae-internal-mixed-release-tag',\n  'ae-preapproved-unsupported-type',\n  'ae-preapproved-bad-release-tag',\n  'ae-unresolved-inheritdoc-reference',\n  'ae-unresolved-inheritdoc-base',\n  'ae-cyclic-inherit-doc',\n  'ae-unresolved-link',\n  'ae-setter-with-docs',\n  'ae-missing-getter',\n  'ae-wrong-input-file-type'\n]);\n"]}
\ No newline at end of file
+{"version":3,"file":"ExtractorMessageId.js","sourceRoot":"","sources":["../../src/api/ExtractorMessageId.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AA4H9C,QAAA,sBAAsB,GAAgB,IAAI,GAAG,CAAS;IACjE,sBAAsB;IACtB,iBAAiB;IACjB,2BAA2B;IAC3B,8BAA8B;IAC9B,wBAAwB;IACxB,0BAA0B;IAC1B,qBAAqB;IACrB,gCAAgC;IAChC,+BAA+B;IAC/B,iCAAiC;IACjC,gCAAgC;IAChC,oCAAoC;IACpC,+BAA+B;IAC/B,uBAAuB;IACvB,oBAAoB;IACpB,qBAAqB;IACrB,mBAAmB;IACnB,0BAA0B;CAC3B,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/**\r\n * Unique identifiers for messages reported by API Extractor during its analysis.\r\n *\r\n * @remarks\r\n *\r\n * These strings are possible values for the {@link ExtractorMessage.messageId} property\r\n * when the `ExtractorMessage.category` is {@link ExtractorMessageCategory.Extractor}.\r\n *\r\n * @public\r\n */\r\nexport const enum ExtractorMessageId {\r\n  /**\r\n   * \"The doc comment should not contain more than one release tag.\"\r\n   */\r\n  ExtraReleaseTag = 'ae-extra-release-tag',\r\n\r\n  /**\r\n   * \"Missing documentation for ___.\"\r\n   * @remarks\r\n   * The `ae-undocumented` message is only generated if the API report feature is enabled.\r\n   *\r\n   * Because the API report file already annotates undocumented items with `// (undocumented)`,\r\n   * the `ae-undocumented` message is not logged by default.  To see it, add a setting such as:\r\n   * ```json\r\n   * \"messages\": {\r\n   *   \"extractorMessageReporting\": {\r\n   *     \"ae-undocumented\": {\r\n   *       \"logLevel\": \"warning\"\r\n   *     }\r\n   *   }\r\n   *  }\r\n   * ```\r\n   */\r\n  Undocumented = 'ae-undocumented',\r\n\r\n  /**\r\n   * \"This symbol has another declaration with a different release tag.\"\r\n   */\r\n  DifferentReleaseTags = 'ae-different-release-tags',\r\n\r\n  /**\r\n   * \"The symbol ___ is marked as ___, but its signature references ___ which is marked as ___.\"\r\n   */\r\n  IncompatibleReleaseTags = 'ae-incompatible-release-tags',\r\n\r\n  /**\r\n   * \"___ is part of the package's API, but it is missing a release tag (`@alpha`, `@beta`, `@public`, or `@internal`).\"\r\n   */\r\n  MissingReleaseTag = 'ae-missing-release-tag',\r\n\r\n  /**\r\n   * \"The `@packageDocumentation` comment must appear at the top of entry point *.d.ts file.\"\r\n   */\r\n  MisplacedPackageTag = 'ae-misplaced-package-tag',\r\n\r\n  /**\r\n   * \"The symbol ___ needs to be exported by the entry point ___.\"\r\n   */\r\n  ForgottenExport = 'ae-forgotten-export',\r\n\r\n  /**\r\n   * \"The name ___ should be prefixed with an underscore because the declaration is marked as `@internal`.\"\r\n   */\r\n  InternalMissingUnderscore = 'ae-internal-missing-underscore',\r\n\r\n  /**\r\n   * \"Mixed release tags are not allowed for ___ because one of its declarations is marked as `@internal`.\"\r\n   */\r\n  InternalMixedReleaseTag = 'ae-internal-mixed-release-tag',\r\n\r\n  /**\r\n   * \"The `@preapproved` tag cannot be applied to ___ because it is not a supported declaration type.\"\r\n   */\r\n  PreapprovedUnsupportedType = 'ae-preapproved-unsupported-type',\r\n\r\n  /**\r\n   * \"The `@preapproved` tag cannot be applied to ___ without an `@internal` release tag.\"\r\n   */\r\n  PreapprovedBadReleaseTag = 'ae-preapproved-bad-release-tag',\r\n\r\n  /**\r\n   * \"The `@inheritDoc` reference could not be resolved.\"\r\n   */\r\n  UnresolvedInheritDocReference = 'ae-unresolved-inheritdoc-reference',\r\n\r\n  /**\r\n   * \"The `@inheritDoc` tag needs a TSDoc declaration reference; signature matching is not supported yet.\"\r\n   *\r\n   * @privateRemarks\r\n   * In the future, we will implement signature matching so that you can write `{@inheritDoc}` and API Extractor\r\n   * will find a corresponding member from a base class (or implemented interface).  Until then, the tag\r\n   * always needs an explicit declaration reference such as `{@inhertDoc MyBaseClass.sameMethod}`.\r\n   */\r\n  UnresolvedInheritDocBase = 'ae-unresolved-inheritdoc-base',\r\n\r\n  /**\r\n   * \"The `@inheritDoc` tag for ___ refers to its own declaration.\"\r\n   */\r\n  CyclicInheritDoc = 'ae-cyclic-inherit-doc',\r\n\r\n  /**\r\n   * \"The `@link` reference could not be resolved.\"\r\n   */\r\n  UnresolvedLink = 'ae-unresolved-link',\r\n\r\n  /**\r\n   * \"The doc comment for the property ___ must appear on the getter, not the setter.\"\r\n   */\r\n  SetterWithDocs = 'ae-setter-with-docs',\r\n\r\n  /**\r\n   * \"The property ___ has a setter but no getter.\"\r\n   */\r\n  MissingGetter = 'ae-missing-getter',\r\n\r\n  /**\r\n   * \"Incorrect file type; API Extractor expects to analyze compiler outputs with the .d.ts file extension.\r\n   * Troubleshooting tips: `https://api-extractor.com/link/dts-error`\"\r\n   */\r\n  WrongInputFileType = 'ae-wrong-input-file-type'\r\n}\r\n\r\nexport const allExtractorMessageIds: Set<string> = new Set<string>([\r\n  'ae-extra-release-tag',\r\n  'ae-undocumented',\r\n  'ae-different-release-tags',\r\n  'ae-incompatible-release-tags',\r\n  'ae-missing-release-tag',\r\n  'ae-misplaced-package-tag',\r\n  'ae-forgotten-export',\r\n  'ae-internal-missing-underscore',\r\n  'ae-internal-mixed-release-tag',\r\n  'ae-preapproved-unsupported-type',\r\n  'ae-preapproved-bad-release-tag',\r\n  'ae-unresolved-inheritdoc-reference',\r\n  'ae-unresolved-inheritdoc-base',\r\n  'ae-cyclic-inherit-doc',\r\n  'ae-unresolved-link',\r\n  'ae-setter-with-docs',\r\n  'ae-missing-getter',\r\n  'ae-wrong-input-file-type'\r\n]);\r\n"]}
\ No newline at end of file
diff --git a/lib/api/IConfigFile.d.ts b/lib/api/IConfigFile.d.ts
index 34e4745ea5e509b9a4062fdef18d24a0804a28d9..c2078eaa3e1278aa938d11fd14e8613a16351fbe 100644
--- a/lib/api/IConfigFile.d.ts
+++ b/lib/api/IConfigFile.d.ts
@@ -343,10 +343,11 @@ export interface IConfigFile {
     mainEntryPointFilePath: string;
     /**
      * A list of NPM package names whose exports should be treated as part of this package.
+     * Supports regular expressions.
      *
-     * @remarks
+     * @example
      *
-     * For example, suppose that Webpack is used to generate a distributed bundle for the project `library1`,
+     * Suppose that Webpack is used to generate a distributed bundle for the project `library1`,
      * and another NPM package `library2` is embedded in this bundle.  Some types from `library2` may become part
      * of the exported API for `library1`, but by default API Extractor would generate a .d.ts rollup that explicitly
      * imports `library2`.  To avoid this, we can specify:
diff --git a/lib/api/IConfigFile.d.ts.map b/lib/api/IConfigFile.d.ts.map
index d29b01283ef22f72fad7761661b7c1b75702c8c6..8e80c7b68edf7f078fef39aaf59c4dee5315e4dc 100644
--- a/lib/api/IConfigFile.d.ts.map
+++ b/lib/api/IConfigFile.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"IConfigFile.d.ts","sourceRoot":"","sources":["../../src/api/IConfigFile.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"IConfigFile.d.ts","sourceRoot":"","sources":["../../src/api/IConfigFile.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/lib/api/IConfigFile.js.map b/lib/api/IConfigFile.js.map
index 29c6b59ea3e0d1675888802f9dee8aabb8fcca9a..7fec9e3ba2da6d0f636cd34b9ba01f794c2e7dba 100644
--- a/lib/api/IConfigFile.js.map
+++ b/lib/api/IConfigFile.js.map
@@ -1 +1 @@
-{"version":3,"file":"IConfigFile.js","sourceRoot":"","sources":["../../src/api/IConfigFile.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { EnumMemberOrder } from '@microsoft/api-extractor-model';\nimport type { ExtractorLogLevel } from './ExtractorLogLevel';\n\n/**\n * Determines how the TypeScript compiler engine will be invoked by API Extractor.\n *\n * @remarks\n * This is part of the {@link IConfigFile} structure.\n *\n * @public\n */\nexport interface IConfigCompiler {\n  /**\n   * Specifies the path to the tsconfig.json file to be used by API Extractor when analyzing the project.\n   *\n   * @remarks\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\n   * prepend a folder token such as `<projectFolder>`.\n   *\n   * Note: This setting will be ignored if `overrideTsconfig` is used.\n   */\n  tsconfigFilePath?: string;\n\n  /**\n   * Provides a compiler configuration that will be used instead of reading the tsconfig.json file from disk.\n   *\n   * @remarks\n   * The value must conform to the TypeScript tsconfig schema:\n   *\n   * http://json.schemastore.org/tsconfig\n   *\n   * If omitted, then the tsconfig.json file will instead be read from the projectFolder.\n   */\n  overrideTsconfig?: {};\n\n  /**\n   * This option causes the compiler to be invoked with the `--skipLibCheck` option.\n   *\n   * @remarks\n   * This option is not recommended and may cause API Extractor to produce incomplete or incorrect declarations,\n   * but it may be required when dependencies contain declarations that are incompatible with the TypeScript engine\n   * that API Extractor uses for its analysis.  Where possible, the underlying issue should be fixed rather than\n   * relying on skipLibCheck.\n   */\n  skipLibCheck?: boolean;\n}\n\n/**\n * Configures how the API report files (*.api.md) will be generated.\n *\n * @remarks\n * This is part of the {@link IConfigFile} structure.\n *\n * @public\n */\nexport interface IConfigApiReport {\n  /**\n   * Whether to generate an API report.\n   */\n  enabled: boolean;\n\n  /**\n   * The filename for the API report files.  It will be combined with `reportFolder` or `reportTempFolder` to produce\n   * a full output filename.\n   *\n   * @remarks\n   * The file extension should be \".api.md\", and the string should not contain a path separator such as `\\` or `/`.\n   */\n  reportFileName?: string;\n\n  /**\n   * Specifies the folder where the API report file is written.  The file name portion is determined by\n   * the `reportFileName` setting.\n   *\n   * @remarks\n   * The API report file is normally tracked by Git.  Changes to it can be used to trigger a branch policy,\n   * e.g. for an API review.\n   *\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\n   * prepend a folder token such as `<projectFolder>`.\n   */\n  reportFolder?: string;\n\n  /**\n   * Specifies the folder where the temporary report file is written.  The file name portion is determined by\n   * the `reportFileName` setting.\n   *\n   * @remarks\n   * After the temporary file is written to disk, it is compared with the file in the `reportFolder`.\n   * If they are different, a production build will fail.\n   *\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\n   * prepend a folder token such as `<projectFolder>`.\n   */\n  reportTempFolder?: string;\n\n  /**\n   * Whether \"forgotten exports\" should be included in the API report file.\n   *\n   * @remarks\n   * Forgotten exports are declarations flagged with `ae-forgotten-export` warnings. See\n   * https://api-extractor.com/pages/messages/ae-forgotten-export/ to learn more.\n   *\n   * @defaultValue `false`\n   */\n  includeForgottenExports?: boolean;\n}\n\n/**\n * Configures how the doc model file (*.api.json) will be generated.\n *\n * @remarks\n * This is part of the {@link IConfigFile} structure.\n *\n * @public\n */\nexport interface IConfigDocModel {\n  /**\n   * Whether to generate a doc model file.\n   */\n  enabled: boolean;\n\n  /**\n   * The output path for the doc model file.  The file extension should be \".api.json\".\n   *\n   * @remarks\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\n   * prepend a folder token such as `<projectFolder>`.\n   */\n  apiJsonFilePath?: string;\n\n  /**\n   * Whether \"forgotten exports\" should be included in the doc model file.\n   *\n   * @remarks\n   * Forgotten exports are declarations flagged with `ae-forgotten-export` warnings. See\n   * https://api-extractor.com/pages/messages/ae-forgotten-export/ to learn more.\n   *\n   * @defaultValue `false`\n   */\n  includeForgottenExports?: boolean;\n\n  /**\n   * The base URL where the project's source code can be viewed on a website such as GitHub or\n   * Azure DevOps. This URL path corresponds to the `<projectFolder>` path on disk.\n   *\n   * @remarks\n   * This URL is concatenated with the file paths serialized to the doc model to produce URL file paths to individual API items.\n   * For example, if the `projectFolderUrl` is \"https://github.com/microsoft/rushstack/tree/main/apps/api-extractor\" and an API\n   * item's file path is \"api/ExtractorConfig.ts\", the full URL file path would be\n   * \"https://github.com/microsoft/rushstack/tree/main/apps/api-extractor/api/ExtractorConfig.js\".\n   *\n   * Can be omitted if you don't need source code links in your API documentation reference.\n   */\n  projectFolderUrl?: string;\n}\n\n/**\n * Configures how the .d.ts rollup file will be generated.\n *\n * @remarks\n * This is part of the {@link IConfigFile} structure.\n *\n * @public\n */\nexport interface IConfigDtsRollup {\n  /**\n   * Whether to generate the .d.ts rollup file.\n   */\n  enabled: boolean;\n\n  /**\n   * Specifies the output path for a .d.ts rollup file to be generated without any trimming.\n   *\n   * @remarks\n   * This file will include all declarations that are exported by the main entry point.\n   *\n   * If the path is an empty string, then this file will not be written.\n   *\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\n   * prepend a folder token such as `<projectFolder>`.\n   */\n  untrimmedFilePath?: string;\n\n  /**\n   * Specifies the output path for a .d.ts rollup file to be generated with trimming for an \"alpha\" release.\n   *\n   * @remarks\n   * This file will include only declarations that are marked as `@public`, `@beta`, or `@alpha`.\n   *\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\n   * prepend a folder token such as `<projectFolder>`.\n   */\n  alphaTrimmedFilePath?: string;\n\n  /**\n   * Specifies the output path for a .d.ts rollup file to be generated with trimming for a \"beta\" release.\n   *\n   * @remarks\n   * This file will include only declarations that are marked as `@public` or `@beta`.\n   *\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\n   * prepend a folder token such as `<projectFolder>`.\n   */\n  betaTrimmedFilePath?: string;\n\n  /**\n   * Specifies the output path for a .d.ts rollup file to be generated with trimming for a \"public\" release.\n   *\n   * @remarks\n   * This file will include only declarations that are marked as `@public`.\n   *\n   * If the path is an empty string, then this file will not be written.\n   *\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\n   * prepend a folder token such as `<projectFolder>`.\n   */\n  publicTrimmedFilePath?: string;\n\n  /**\n   * When a declaration is trimmed, by default it will be replaced by a code comment such as\n   * \"Excluded from this release type: exampleMember\".  Set \"omitTrimmingComments\" to true to remove the\n   * declaration completely.\n   */\n  omitTrimmingComments?: boolean;\n}\n\n/**\n * Configures how the tsdoc-metadata.json file will be generated.\n *\n * @remarks\n * This is part of the {@link IConfigFile} structure.\n *\n * @public\n */\nexport interface IConfigTsdocMetadata {\n  /**\n   * Whether to generate the tsdoc-metadata.json file.\n   */\n  enabled: boolean;\n\n  /**\n   * Specifies where the TSDoc metadata file should be written.\n   *\n   * @remarks\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\n   * prepend a folder token such as `<projectFolder>`.\n   *\n   * The default value is `<lookup>`, which causes the path to be automatically inferred from the `tsdocMetadata`,\n   * `typings` or `main` fields of the project's package.json.  If none of these fields are set, the lookup\n   * falls back to `tsdoc-metadata.json` in the package folder.\n   */\n  tsdocMetadataFilePath?: string;\n}\n\n/**\n * Configures reporting for a given message identifier.\n *\n * @remarks\n * This is part of the {@link IConfigFile} structure.\n *\n * @public\n */\nexport interface IConfigMessageReportingRule {\n  /**\n   * Specifies whether the message should be written to the the tool's output log.\n   *\n   * @remarks\n   * Note that the `addToApiReportFile` property may supersede this option.\n   */\n  logLevel: ExtractorLogLevel;\n\n  /**\n   * When `addToApiReportFile` is true:  If API Extractor is configured to write an API report file (.api.md),\n   * then the message will be written inside that file; otherwise, the message is instead logged according to\n   * the `logLevel` option.\n   */\n  addToApiReportFile?: boolean;\n}\n\n/**\n * Specifies a table of reporting rules for different message identifiers, and also the default rule used for\n * identifiers that do not appear in the table.\n *\n * @remarks\n * This is part of the {@link IConfigFile} structure.\n *\n * @public\n */\nexport interface IConfigMessageReportingTable {\n  /**\n   * The key is a message identifier for the associated type of message, or \"default\" to specify the default policy.\n   * For example, the key might be `TS2551` (a compiler message), `tsdoc-link-tag-unescaped-text` (a TSDOc message),\n   * or `ae-extra-release-tag` (a message related to the API Extractor analysis).\n   */\n  [messageId: string]: IConfigMessageReportingRule;\n}\n\n/**\n * Configures how API Extractor reports error and warning messages produced during analysis.\n *\n * @remarks\n * This is part of the {@link IConfigFile} structure.\n *\n * @public\n */\nexport interface IExtractorMessagesConfig {\n  /**\n   * Configures handling of diagnostic messages generating the TypeScript compiler while analyzing the\n   * input .d.ts files.\n   */\n  compilerMessageReporting?: IConfigMessageReportingTable;\n\n  /**\n   * Configures handling of messages reported by API Extractor during its analysis.\n   */\n  extractorMessageReporting?: IConfigMessageReportingTable;\n\n  /**\n   * Configures handling of messages reported by the TSDoc parser when analyzing code comments.\n   */\n  tsdocMessageReporting?: IConfigMessageReportingTable;\n}\n\n/**\n * Configuration options for the API Extractor tool.  These options can be constructed programmatically\n * or loaded from the api-extractor.json config file using the {@link ExtractorConfig} class.\n *\n * @public\n */\nexport interface IConfigFile {\n  /**\n   * Optionally specifies another JSON config file that this file extends from.  This provides a way for\n   * standard settings to be shared across multiple projects.\n   *\n   * @remarks\n   * If the path starts with `./` or `../`, the path is resolved relative to the folder of the file that contains\n   * the `extends` field.  Otherwise, the first path segment is interpreted as an NPM package name, and will be\n   * resolved using NodeJS `require()`.\n   */\n  extends?: string;\n\n  /**\n   * Determines the `<projectFolder>` token that can be used with other config file settings.  The project folder\n   * typically contains the tsconfig.json and package.json config files, but the path is user-defined.\n   *\n   * @remarks\n   *\n   * The path is resolved relative to the folder of the config file that contains the setting.\n   *\n   * The default value for `projectFolder` is the token `<lookup>`, which means the folder is determined using\n   * the following heuristics:\n   *\n   * If the config/rig.json system is used (as defined by {@link https://www.npmjs.com/package/@rushstack/rig-package\n   * | @rushstack/rig-package}), then the `<lookup>` value will be the package folder that referenced the rig.\n   *\n   * Otherwise, the `<lookup>` value is determined by traversing parent folders, starting from the folder containing\n   * api-extractor.json, and stopping at the first folder that contains a tsconfig.json file.  If a tsconfig.json file\n   * cannot be found in this way, then an error will be reported.\n   */\n  projectFolder?: string;\n\n  /**\n   * Specifies the .d.ts file to be used as the starting point for analysis.  API Extractor\n   * analyzes the symbols exported by this module.\n   *\n   * @remarks\n   *\n   * The file extension must be \".d.ts\" and not \".ts\".\n   * The path is resolved relative to the \"projectFolder\" location.\n   */\n  mainEntryPointFilePath: string;\n\n  /**\n   * A list of NPM package names whose exports should be treated as part of this package.\n   *\n   * @remarks\n   *\n   * For example, suppose that Webpack is used to generate a distributed bundle for the project `library1`,\n   * and another NPM package `library2` is embedded in this bundle.  Some types from `library2` may become part\n   * of the exported API for `library1`, but by default API Extractor would generate a .d.ts rollup that explicitly\n   * imports `library2`.  To avoid this, we can specify:\n   *\n   * ```js\n   *   \"bundledPackages\": [ \"library2\" ],\n   * ```\n   *\n   * This would direct API Extractor to embed those types directly in the .d.ts rollup, as if they had been\n   * local files for `library1`.\n   */\n  bundledPackages?: string[];\n\n  /**\n   * Specifies what type of newlines API Extractor should use when writing output files.\n   *\n   * @remarks\n   * By default, the output files will be written with Windows-style newlines.\n   * To use POSIX-style newlines, specify \"lf\" instead.\n   * To use the OS's default newline kind, specify \"os\".\n   */\n  newlineKind?: 'crlf' | 'lf' | 'os';\n\n  /**\n   * Set to true when invoking API Extractor's test harness.\n   * @remarks\n   * When `testMode` is true, the `toolVersion` field in the .api.json file is assigned an empty string\n   * to prevent spurious diffs in output files tracked for tests.\n   */\n  testMode?: boolean;\n\n  /**\n   * Specifies how API Extractor sorts members of an enum when generating the .api.json file.\n   *\n   * @remarks\n   * By default, the output files will be sorted alphabetically, which is \"by-name\".\n   * To keep the ordering in the source code, specify \"preserve\".\n   *\n   * @defaultValue `by-name`\n   */\n  enumMemberOrder?: EnumMemberOrder;\n\n  /**\n   * {@inheritDoc IConfigCompiler}\n   */\n  compiler?: IConfigCompiler;\n\n  /**\n   * {@inheritDoc IConfigApiReport}\n   */\n  apiReport?: IConfigApiReport;\n\n  /**\n   * {@inheritDoc IConfigDocModel}\n   */\n  docModel?: IConfigDocModel;\n\n  /**\n   * {@inheritDoc IConfigDtsRollup}\n   * @beta\n   */\n  dtsRollup?: IConfigDtsRollup;\n\n  /**\n   * {@inheritDoc IConfigTsdocMetadata}\n   * @beta\n   */\n  tsdocMetadata?: IConfigTsdocMetadata;\n\n  /**\n   * {@inheritDoc IExtractorMessagesConfig}\n   */\n  messages?: IExtractorMessagesConfig;\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"IConfigFile.js","sourceRoot":"","sources":["../../src/api/IConfigFile.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport type { EnumMemberOrder } from '@microsoft/api-extractor-model';\r\nimport type { ExtractorLogLevel } from './ExtractorLogLevel';\r\n\r\n/**\r\n * Determines how the TypeScript compiler engine will be invoked by API Extractor.\r\n *\r\n * @remarks\r\n * This is part of the {@link IConfigFile} structure.\r\n *\r\n * @public\r\n */\r\nexport interface IConfigCompiler {\r\n  /**\r\n   * Specifies the path to the tsconfig.json file to be used by API Extractor when analyzing the project.\r\n   *\r\n   * @remarks\r\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\r\n   * prepend a folder token such as `<projectFolder>`.\r\n   *\r\n   * Note: This setting will be ignored if `overrideTsconfig` is used.\r\n   */\r\n  tsconfigFilePath?: string;\r\n\r\n  /**\r\n   * Provides a compiler configuration that will be used instead of reading the tsconfig.json file from disk.\r\n   *\r\n   * @remarks\r\n   * The value must conform to the TypeScript tsconfig schema:\r\n   *\r\n   * http://json.schemastore.org/tsconfig\r\n   *\r\n   * If omitted, then the tsconfig.json file will instead be read from the projectFolder.\r\n   */\r\n  overrideTsconfig?: {};\r\n\r\n  /**\r\n   * This option causes the compiler to be invoked with the `--skipLibCheck` option.\r\n   *\r\n   * @remarks\r\n   * This option is not recommended and may cause API Extractor to produce incomplete or incorrect declarations,\r\n   * but it may be required when dependencies contain declarations that are incompatible with the TypeScript engine\r\n   * that API Extractor uses for its analysis.  Where possible, the underlying issue should be fixed rather than\r\n   * relying on skipLibCheck.\r\n   */\r\n  skipLibCheck?: boolean;\r\n}\r\n\r\n/**\r\n * Configures how the API report files (*.api.md) will be generated.\r\n *\r\n * @remarks\r\n * This is part of the {@link IConfigFile} structure.\r\n *\r\n * @public\r\n */\r\nexport interface IConfigApiReport {\r\n  /**\r\n   * Whether to generate an API report.\r\n   */\r\n  enabled: boolean;\r\n\r\n  /**\r\n   * The filename for the API report files.  It will be combined with `reportFolder` or `reportTempFolder` to produce\r\n   * a full output filename.\r\n   *\r\n   * @remarks\r\n   * The file extension should be \".api.md\", and the string should not contain a path separator such as `\\` or `/`.\r\n   */\r\n  reportFileName?: string;\r\n\r\n  /**\r\n   * Specifies the folder where the API report file is written.  The file name portion is determined by\r\n   * the `reportFileName` setting.\r\n   *\r\n   * @remarks\r\n   * The API report file is normally tracked by Git.  Changes to it can be used to trigger a branch policy,\r\n   * e.g. for an API review.\r\n   *\r\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\r\n   * prepend a folder token such as `<projectFolder>`.\r\n   */\r\n  reportFolder?: string;\r\n\r\n  /**\r\n   * Specifies the folder where the temporary report file is written.  The file name portion is determined by\r\n   * the `reportFileName` setting.\r\n   *\r\n   * @remarks\r\n   * After the temporary file is written to disk, it is compared with the file in the `reportFolder`.\r\n   * If they are different, a production build will fail.\r\n   *\r\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\r\n   * prepend a folder token such as `<projectFolder>`.\r\n   */\r\n  reportTempFolder?: string;\r\n\r\n  /**\r\n   * Whether \"forgotten exports\" should be included in the API report file.\r\n   *\r\n   * @remarks\r\n   * Forgotten exports are declarations flagged with `ae-forgotten-export` warnings. See\r\n   * https://api-extractor.com/pages/messages/ae-forgotten-export/ to learn more.\r\n   *\r\n   * @defaultValue `false`\r\n   */\r\n  includeForgottenExports?: boolean;\r\n}\r\n\r\n/**\r\n * Configures how the doc model file (*.api.json) will be generated.\r\n *\r\n * @remarks\r\n * This is part of the {@link IConfigFile} structure.\r\n *\r\n * @public\r\n */\r\nexport interface IConfigDocModel {\r\n  /**\r\n   * Whether to generate a doc model file.\r\n   */\r\n  enabled: boolean;\r\n\r\n  /**\r\n   * The output path for the doc model file.  The file extension should be \".api.json\".\r\n   *\r\n   * @remarks\r\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\r\n   * prepend a folder token such as `<projectFolder>`.\r\n   */\r\n  apiJsonFilePath?: string;\r\n\r\n  /**\r\n   * Whether \"forgotten exports\" should be included in the doc model file.\r\n   *\r\n   * @remarks\r\n   * Forgotten exports are declarations flagged with `ae-forgotten-export` warnings. See\r\n   * https://api-extractor.com/pages/messages/ae-forgotten-export/ to learn more.\r\n   *\r\n   * @defaultValue `false`\r\n   */\r\n  includeForgottenExports?: boolean;\r\n\r\n  /**\r\n   * The base URL where the project's source code can be viewed on a website such as GitHub or\r\n   * Azure DevOps. This URL path corresponds to the `<projectFolder>` path on disk.\r\n   *\r\n   * @remarks\r\n   * This URL is concatenated with the file paths serialized to the doc model to produce URL file paths to individual API items.\r\n   * For example, if the `projectFolderUrl` is \"https://github.com/microsoft/rushstack/tree/main/apps/api-extractor\" and an API\r\n   * item's file path is \"api/ExtractorConfig.ts\", the full URL file path would be\r\n   * \"https://github.com/microsoft/rushstack/tree/main/apps/api-extractor/api/ExtractorConfig.js\".\r\n   *\r\n   * Can be omitted if you don't need source code links in your API documentation reference.\r\n   */\r\n  projectFolderUrl?: string;\r\n}\r\n\r\n/**\r\n * Configures how the .d.ts rollup file will be generated.\r\n *\r\n * @remarks\r\n * This is part of the {@link IConfigFile} structure.\r\n *\r\n * @public\r\n */\r\nexport interface IConfigDtsRollup {\r\n  /**\r\n   * Whether to generate the .d.ts rollup file.\r\n   */\r\n  enabled: boolean;\r\n\r\n  /**\r\n   * Specifies the output path for a .d.ts rollup file to be generated without any trimming.\r\n   *\r\n   * @remarks\r\n   * This file will include all declarations that are exported by the main entry point.\r\n   *\r\n   * If the path is an empty string, then this file will not be written.\r\n   *\r\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\r\n   * prepend a folder token such as `<projectFolder>`.\r\n   */\r\n  untrimmedFilePath?: string;\r\n\r\n  /**\r\n   * Specifies the output path for a .d.ts rollup file to be generated with trimming for an \"alpha\" release.\r\n   *\r\n   * @remarks\r\n   * This file will include only declarations that are marked as `@public`, `@beta`, or `@alpha`.\r\n   *\r\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\r\n   * prepend a folder token such as `<projectFolder>`.\r\n   */\r\n  alphaTrimmedFilePath?: string;\r\n\r\n  /**\r\n   * Specifies the output path for a .d.ts rollup file to be generated with trimming for a \"beta\" release.\r\n   *\r\n   * @remarks\r\n   * This file will include only declarations that are marked as `@public` or `@beta`.\r\n   *\r\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\r\n   * prepend a folder token such as `<projectFolder>`.\r\n   */\r\n  betaTrimmedFilePath?: string;\r\n\r\n  /**\r\n   * Specifies the output path for a .d.ts rollup file to be generated with trimming for a \"public\" release.\r\n   *\r\n   * @remarks\r\n   * This file will include only declarations that are marked as `@public`.\r\n   *\r\n   * If the path is an empty string, then this file will not be written.\r\n   *\r\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\r\n   * prepend a folder token such as `<projectFolder>`.\r\n   */\r\n  publicTrimmedFilePath?: string;\r\n\r\n  /**\r\n   * When a declaration is trimmed, by default it will be replaced by a code comment such as\r\n   * \"Excluded from this release type: exampleMember\".  Set \"omitTrimmingComments\" to true to remove the\r\n   * declaration completely.\r\n   */\r\n  omitTrimmingComments?: boolean;\r\n}\r\n\r\n/**\r\n * Configures how the tsdoc-metadata.json file will be generated.\r\n *\r\n * @remarks\r\n * This is part of the {@link IConfigFile} structure.\r\n *\r\n * @public\r\n */\r\nexport interface IConfigTsdocMetadata {\r\n  /**\r\n   * Whether to generate the tsdoc-metadata.json file.\r\n   */\r\n  enabled: boolean;\r\n\r\n  /**\r\n   * Specifies where the TSDoc metadata file should be written.\r\n   *\r\n   * @remarks\r\n   * The path is resolved relative to the folder of the config file that contains the setting; to change this,\r\n   * prepend a folder token such as `<projectFolder>`.\r\n   *\r\n   * The default value is `<lookup>`, which causes the path to be automatically inferred from the `tsdocMetadata`,\r\n   * `typings` or `main` fields of the project's package.json.  If none of these fields are set, the lookup\r\n   * falls back to `tsdoc-metadata.json` in the package folder.\r\n   */\r\n  tsdocMetadataFilePath?: string;\r\n}\r\n\r\n/**\r\n * Configures reporting for a given message identifier.\r\n *\r\n * @remarks\r\n * This is part of the {@link IConfigFile} structure.\r\n *\r\n * @public\r\n */\r\nexport interface IConfigMessageReportingRule {\r\n  /**\r\n   * Specifies whether the message should be written to the the tool's output log.\r\n   *\r\n   * @remarks\r\n   * Note that the `addToApiReportFile` property may supersede this option.\r\n   */\r\n  logLevel: ExtractorLogLevel;\r\n\r\n  /**\r\n   * When `addToApiReportFile` is true:  If API Extractor is configured to write an API report file (.api.md),\r\n   * then the message will be written inside that file; otherwise, the message is instead logged according to\r\n   * the `logLevel` option.\r\n   */\r\n  addToApiReportFile?: boolean;\r\n}\r\n\r\n/**\r\n * Specifies a table of reporting rules for different message identifiers, and also the default rule used for\r\n * identifiers that do not appear in the table.\r\n *\r\n * @remarks\r\n * This is part of the {@link IConfigFile} structure.\r\n *\r\n * @public\r\n */\r\nexport interface IConfigMessageReportingTable {\r\n  /**\r\n   * The key is a message identifier for the associated type of message, or \"default\" to specify the default policy.\r\n   * For example, the key might be `TS2551` (a compiler message), `tsdoc-link-tag-unescaped-text` (a TSDOc message),\r\n   * or `ae-extra-release-tag` (a message related to the API Extractor analysis).\r\n   */\r\n  [messageId: string]: IConfigMessageReportingRule;\r\n}\r\n\r\n/**\r\n * Configures how API Extractor reports error and warning messages produced during analysis.\r\n *\r\n * @remarks\r\n * This is part of the {@link IConfigFile} structure.\r\n *\r\n * @public\r\n */\r\nexport interface IExtractorMessagesConfig {\r\n  /**\r\n   * Configures handling of diagnostic messages generating the TypeScript compiler while analyzing the\r\n   * input .d.ts files.\r\n   */\r\n  compilerMessageReporting?: IConfigMessageReportingTable;\r\n\r\n  /**\r\n   * Configures handling of messages reported by API Extractor during its analysis.\r\n   */\r\n  extractorMessageReporting?: IConfigMessageReportingTable;\r\n\r\n  /**\r\n   * Configures handling of messages reported by the TSDoc parser when analyzing code comments.\r\n   */\r\n  tsdocMessageReporting?: IConfigMessageReportingTable;\r\n}\r\n\r\n/**\r\n * Configuration options for the API Extractor tool.  These options can be constructed programmatically\r\n * or loaded from the api-extractor.json config file using the {@link ExtractorConfig} class.\r\n *\r\n * @public\r\n */\r\nexport interface IConfigFile {\r\n  /**\r\n   * Optionally specifies another JSON config file that this file extends from.  This provides a way for\r\n   * standard settings to be shared across multiple projects.\r\n   *\r\n   * @remarks\r\n   * If the path starts with `./` or `../`, the path is resolved relative to the folder of the file that contains\r\n   * the `extends` field.  Otherwise, the first path segment is interpreted as an NPM package name, and will be\r\n   * resolved using NodeJS `require()`.\r\n   */\r\n  extends?: string;\r\n\r\n  /**\r\n   * Determines the `<projectFolder>` token that can be used with other config file settings.  The project folder\r\n   * typically contains the tsconfig.json and package.json config files, but the path is user-defined.\r\n   *\r\n   * @remarks\r\n   *\r\n   * The path is resolved relative to the folder of the config file that contains the setting.\r\n   *\r\n   * The default value for `projectFolder` is the token `<lookup>`, which means the folder is determined using\r\n   * the following heuristics:\r\n   *\r\n   * If the config/rig.json system is used (as defined by {@link https://www.npmjs.com/package/@rushstack/rig-package\r\n   * | @rushstack/rig-package}), then the `<lookup>` value will be the package folder that referenced the rig.\r\n   *\r\n   * Otherwise, the `<lookup>` value is determined by traversing parent folders, starting from the folder containing\r\n   * api-extractor.json, and stopping at the first folder that contains a tsconfig.json file.  If a tsconfig.json file\r\n   * cannot be found in this way, then an error will be reported.\r\n   */\r\n  projectFolder?: string;\r\n\r\n  /**\r\n   * Specifies the .d.ts file to be used as the starting point for analysis.  API Extractor\r\n   * analyzes the symbols exported by this module.\r\n   *\r\n   * @remarks\r\n   *\r\n   * The file extension must be \".d.ts\" and not \".ts\".\r\n   * The path is resolved relative to the \"projectFolder\" location.\r\n   */\r\n  mainEntryPointFilePath: string;\r\n\r\n  /**\r\n   * A list of NPM package names whose exports should be treated as part of this package.\r\n   * Supports regular expressions.\r\n   *\r\n   * @example\r\n   *\r\n   * Suppose that Webpack is used to generate a distributed bundle for the project `library1`,\r\n   * and another NPM package `library2` is embedded in this bundle.  Some types from `library2` may become part\r\n   * of the exported API for `library1`, but by default API Extractor would generate a .d.ts rollup that explicitly\r\n   * imports `library2`.  To avoid this, we can specify:\r\n   *\r\n   * ```js\r\n   *   \"bundledPackages\": [ \"library2\" ],\r\n   * ```\r\n   *\r\n   * This would direct API Extractor to embed those types directly in the .d.ts rollup, as if they had been\r\n   * local files for `library1`.\r\n   */\r\n  bundledPackages?: string[];\r\n\r\n  /**\r\n   * Specifies what type of newlines API Extractor should use when writing output files.\r\n   *\r\n   * @remarks\r\n   * By default, the output files will be written with Windows-style newlines.\r\n   * To use POSIX-style newlines, specify \"lf\" instead.\r\n   * To use the OS's default newline kind, specify \"os\".\r\n   */\r\n  newlineKind?: 'crlf' | 'lf' | 'os';\r\n\r\n  /**\r\n   * Set to true when invoking API Extractor's test harness.\r\n   * @remarks\r\n   * When `testMode` is true, the `toolVersion` field in the .api.json file is assigned an empty string\r\n   * to prevent spurious diffs in output files tracked for tests.\r\n   */\r\n  testMode?: boolean;\r\n\r\n  /**\r\n   * Specifies how API Extractor sorts members of an enum when generating the .api.json file.\r\n   *\r\n   * @remarks\r\n   * By default, the output files will be sorted alphabetically, which is \"by-name\".\r\n   * To keep the ordering in the source code, specify \"preserve\".\r\n   *\r\n   * @defaultValue `by-name`\r\n   */\r\n  enumMemberOrder?: EnumMemberOrder;\r\n\r\n  /**\r\n   * {@inheritDoc IConfigCompiler}\r\n   */\r\n  compiler?: IConfigCompiler;\r\n\r\n  /**\r\n   * {@inheritDoc IConfigApiReport}\r\n   */\r\n  apiReport?: IConfigApiReport;\r\n\r\n  /**\r\n   * {@inheritDoc IConfigDocModel}\r\n   */\r\n  docModel?: IConfigDocModel;\r\n\r\n  /**\r\n   * {@inheritDoc IConfigDtsRollup}\r\n   * @beta\r\n   */\r\n  dtsRollup?: IConfigDtsRollup;\r\n\r\n  /**\r\n   * {@inheritDoc IConfigTsdocMetadata}\r\n   * @beta\r\n   */\r\n  tsdocMetadata?: IConfigTsdocMetadata;\r\n\r\n  /**\r\n   * {@inheritDoc IExtractorMessagesConfig}\r\n   */\r\n  messages?: IExtractorMessagesConfig;\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/api/test/Extractor-custom-tags.test.d.ts b/lib/api/test/Extractor-custom-tags.test.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..aa772e1fc16505f41244dfe7988fe1709671fc1b
--- /dev/null
+++ b/lib/api/test/Extractor-custom-tags.test.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=Extractor-custom-tags.test.d.ts.map
\ No newline at end of file
diff --git a/lib/api/test/Extractor-custom-tags.test.d.ts.map b/lib/api/test/Extractor-custom-tags.test.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..7d5a1fe728801f763a3e36819d9fb05b40ec274a
--- /dev/null
+++ b/lib/api/test/Extractor-custom-tags.test.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"Extractor-custom-tags.test.d.ts","sourceRoot":"","sources":["../../../src/api/test/Extractor-custom-tags.test.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/lib/api/test/Extractor-custom-tags.test.js b/lib/api/test/Extractor-custom-tags.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..a5531e4b929cd3bb14fc9c48d5259e9e7c2b769b
--- /dev/null
+++ b/lib/api/test/Extractor-custom-tags.test.js
@@ -0,0 +1,70 @@
+"use strict";
+// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
+// See LICENSE in the project root for license information.
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const tsdoc_1 = require("@microsoft/tsdoc");
+const path = __importStar(require("path"));
+const ExtractorConfig_1 = require("../ExtractorConfig");
+const testDataFolder = path.join(__dirname, 'test-data');
+describe('Extractor-custom-tags', () => {
+    describe('should use a TSDocConfiguration', () => {
+        it.only("with custom TSDoc tags defined in the package's tsdoc.json", () => {
+            const extractorConfig = ExtractorConfig_1.ExtractorConfig.loadFileAndPrepare(path.join(testDataFolder, 'custom-tsdoc-tags/api-extractor.json'));
+            const { tsdocConfiguration } = extractorConfig;
+            expect(tsdocConfiguration.tryGetTagDefinition('@block')).not.toBe(undefined);
+            expect(tsdocConfiguration.tryGetTagDefinition('@inline')).not.toBe(undefined);
+            expect(tsdocConfiguration.tryGetTagDefinition('@modifier')).not.toBe(undefined);
+        });
+        it.only("with custom TSDoc tags enabled per the package's tsdoc.json", () => {
+            const extractorConfig = ExtractorConfig_1.ExtractorConfig.loadFileAndPrepare(path.join(testDataFolder, 'custom-tsdoc-tags/api-extractor.json'));
+            const { tsdocConfiguration } = extractorConfig;
+            const block = tsdocConfiguration.tryGetTagDefinition('@block');
+            const inline = tsdocConfiguration.tryGetTagDefinition('@inline');
+            const modifier = tsdocConfiguration.tryGetTagDefinition('@modifier');
+            expect(tsdocConfiguration.isTagSupported(block)).toBe(true);
+            expect(tsdocConfiguration.isTagSupported(inline)).toBe(true);
+            expect(tsdocConfiguration.isTagSupported(modifier)).toBe(false);
+        });
+        it.only("with standard tags and API Extractor custom tags defined and supported when the package's tsdoc.json extends API Extractor's tsdoc.json", () => {
+            const extractorConfig = ExtractorConfig_1.ExtractorConfig.loadFileAndPrepare(path.join(testDataFolder, 'custom-tsdoc-tags/api-extractor.json'));
+            const { tsdocConfiguration } = extractorConfig;
+            expect(tsdocConfiguration.tryGetTagDefinition('@inline')).not.toBe(undefined);
+            expect(tsdocConfiguration.tryGetTagDefinition('@block')).not.toBe(undefined);
+            expect(tsdocConfiguration.tryGetTagDefinition('@modifier')).not.toBe(undefined);
+            tsdoc_1.StandardTags.allDefinitions
+                .concat([
+                tsdocConfiguration.tryGetTagDefinition('@betaDocumentation'),
+                tsdocConfiguration.tryGetTagDefinition('@internalRemarks'),
+                tsdocConfiguration.tryGetTagDefinition('@preapproved')
+            ])
+                .forEach((tag) => {
+                expect(tsdocConfiguration.tagDefinitions.includes(tag));
+                expect(tsdocConfiguration.supportedTagDefinitions.includes(tag));
+            });
+        });
+    });
+});
+//# sourceMappingURL=Extractor-custom-tags.test.js.map
\ No newline at end of file
diff --git a/lib/api/test/Extractor-custom-tags.test.js.map b/lib/api/test/Extractor-custom-tags.test.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..c2e6851554c46ba0237d6e0c16a24369f2ffcae8
--- /dev/null
+++ b/lib/api/test/Extractor-custom-tags.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Extractor-custom-tags.test.js","sourceRoot":"","sources":["../../../src/api/test/Extractor-custom-tags.test.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { StandardTags } from '@microsoft/tsdoc';\r\nimport * as path from 'path';\r\n\r\nimport { ExtractorConfig } from '../ExtractorConfig';\r\n\r\nconst testDataFolder: string = path.join(__dirname, 'test-data');\r\n\r\ndescribe('Extractor-custom-tags', () => {\r\n  describe('should use a TSDocConfiguration', () => {\r\n    it.only(\"with custom TSDoc tags defined in the package's tsdoc.json\", () => {\r\n      const extractorConfig: ExtractorConfig = ExtractorConfig.loadFileAndPrepare(\r\n        path.join(testDataFolder, 'custom-tsdoc-tags/api-extractor.json')\r\n      );\r\n      const { tsdocConfiguration } = extractorConfig;\r\n\r\n      expect(tsdocConfiguration.tryGetTagDefinition('@block')).not.toBe(undefined);\r\n      expect(tsdocConfiguration.tryGetTagDefinition('@inline')).not.toBe(undefined);\r\n      expect(tsdocConfiguration.tryGetTagDefinition('@modifier')).not.toBe(undefined);\r\n    });\r\n    it.only(\"with custom TSDoc tags enabled per the package's tsdoc.json\", () => {\r\n      const extractorConfig: ExtractorConfig = ExtractorConfig.loadFileAndPrepare(\r\n        path.join(testDataFolder, 'custom-tsdoc-tags/api-extractor.json')\r\n      );\r\n      const { tsdocConfiguration } = extractorConfig;\r\n      const block = tsdocConfiguration.tryGetTagDefinition('@block')!;\r\n      const inline = tsdocConfiguration.tryGetTagDefinition('@inline')!;\r\n      const modifier = tsdocConfiguration.tryGetTagDefinition('@modifier')!;\r\n\r\n      expect(tsdocConfiguration.isTagSupported(block)).toBe(true);\r\n      expect(tsdocConfiguration.isTagSupported(inline)).toBe(true);\r\n      expect(tsdocConfiguration.isTagSupported(modifier)).toBe(false);\r\n    });\r\n    it.only(\"with standard tags and API Extractor custom tags defined and supported when the package's tsdoc.json extends API Extractor's tsdoc.json\", () => {\r\n      const extractorConfig: ExtractorConfig = ExtractorConfig.loadFileAndPrepare(\r\n        path.join(testDataFolder, 'custom-tsdoc-tags/api-extractor.json')\r\n      );\r\n      const { tsdocConfiguration } = extractorConfig;\r\n\r\n      expect(tsdocConfiguration.tryGetTagDefinition('@inline')).not.toBe(undefined);\r\n      expect(tsdocConfiguration.tryGetTagDefinition('@block')).not.toBe(undefined);\r\n      expect(tsdocConfiguration.tryGetTagDefinition('@modifier')).not.toBe(undefined);\r\n\r\n      StandardTags.allDefinitions\r\n        .concat([\r\n          tsdocConfiguration.tryGetTagDefinition('@betaDocumentation')!,\r\n          tsdocConfiguration.tryGetTagDefinition('@internalRemarks')!,\r\n          tsdocConfiguration.tryGetTagDefinition('@preapproved')!\r\n        ])\r\n        .forEach((tag) => {\r\n          expect(tsdocConfiguration.tagDefinitions.includes(tag));\r\n          expect(tsdocConfiguration.supportedTagDefinitions.includes(tag));\r\n        });\r\n    });\r\n  });\r\n});\r\n"]}
\ No newline at end of file
diff --git a/lib/api/test/ExtractorConfig-lookup.test.d.ts b/lib/api/test/ExtractorConfig-lookup.test.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..26bae5318fe6c0341bfb951a5e7c9888c34e89f9
--- /dev/null
+++ b/lib/api/test/ExtractorConfig-lookup.test.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=ExtractorConfig-lookup.test.d.ts.map
\ No newline at end of file
diff --git a/lib/api/test/ExtractorConfig-lookup.test.d.ts.map b/lib/api/test/ExtractorConfig-lookup.test.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..f8d87a72f1e30f6cdb21a2e1fedf45fd283b3bd9
--- /dev/null
+++ b/lib/api/test/ExtractorConfig-lookup.test.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"ExtractorConfig-lookup.test.d.ts","sourceRoot":"","sources":["../../../src/api/test/ExtractorConfig-lookup.test.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/lib/api/test/ExtractorConfig-lookup.test.js b/lib/api/test/ExtractorConfig-lookup.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..5651d05294c962fe48279818a90c8d66c29fbb5e
--- /dev/null
+++ b/lib/api/test/ExtractorConfig-lookup.test.js
@@ -0,0 +1,52 @@
+"use strict";
+// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
+// See LICENSE in the project root for license information.
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const path = __importStar(require("path"));
+const node_core_library_1 = require("@rushstack/node-core-library");
+const ExtractorConfig_1 = require("../ExtractorConfig");
+const testDataFolder = path.join(__dirname, 'test-data');
+function expectEqualPaths(path1, path2) {
+    if (!node_core_library_1.Path.isEqual(path1, path2)) {
+        fail('Expected paths to be equal:\npath1: ' + path1 + '\npath2: ' + path2);
+    }
+}
+// Tests for expanding the "<lookup>" token for the "projectFolder" setting in api-extractor.json
+describe(`${ExtractorConfig_1.ExtractorConfig.name}.${ExtractorConfig_1.ExtractorConfig.loadFileAndPrepare.name}`, () => {
+    it.only('config-lookup1: looks up ./api-extractor.json', () => {
+        const extractorConfig = ExtractorConfig_1.ExtractorConfig.loadFileAndPrepare(path.join(testDataFolder, 'config-lookup1/api-extractor.json'));
+        expectEqualPaths(extractorConfig.projectFolder, path.join(testDataFolder, 'config-lookup1'));
+    });
+    it.only('config-lookup2: looks up ./config/api-extractor.json', () => {
+        const extractorConfig = ExtractorConfig_1.ExtractorConfig.loadFileAndPrepare(path.join(testDataFolder, 'config-lookup2/config/api-extractor.json'));
+        expectEqualPaths(extractorConfig.projectFolder, path.join(testDataFolder, 'config-lookup2'));
+    });
+    it.only('config-lookup3a: looks up ./src/test/config/api-extractor.json', () => {
+        const extractorConfig = ExtractorConfig_1.ExtractorConfig.loadFileAndPrepare(path.join(testDataFolder, 'config-lookup3/src/test/config/api-extractor.json'));
+        expectEqualPaths(extractorConfig.projectFolder, path.join(testDataFolder, 'config-lookup3/src/test/'));
+    });
+});
+//# sourceMappingURL=ExtractorConfig-lookup.test.js.map
\ No newline at end of file
diff --git a/lib/api/test/ExtractorConfig-lookup.test.js.map b/lib/api/test/ExtractorConfig-lookup.test.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..bc380501116e9e3a2e555a30dd5697a9346363f7
--- /dev/null
+++ b/lib/api/test/ExtractorConfig-lookup.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ExtractorConfig-lookup.test.js","sourceRoot":"","sources":["../../../src/api/test/ExtractorConfig-lookup.test.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,2CAA6B;AAC7B,oEAAoD;AAEpD,wDAAqD;AAErD,MAAM,cAAc,GAAW,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;AAEjE,SAAS,gBAAgB,CAAC,KAAa,EAAE,KAAa;IACpD,IAAI,CAAC,wBAAI,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE;QAC/B,IAAI,CAAC,sCAAsC,GAAG,KAAK,GAAG,WAAW,GAAG,KAAK,CAAC,CAAC;KAC5E;AACH,CAAC;AAED,iGAAiG;AACjG,QAAQ,CAAC,GAAG,iCAAe,CAAC,IAAI,IAAI,iCAAe,CAAC,kBAAkB,CAAC,IAAI,EAAE,EAAE,GAAG,EAAE;IAClF,EAAE,CAAC,IAAI,CAAC,+CAA+C,EAAE,GAAG,EAAE;QAC5D,MAAM,eAAe,GAAoB,iCAAe,CAAC,kBAAkB,CACzE,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,mCAAmC,CAAC,CAC/D,CAAC;QACF,gBAAgB,CAAC,eAAe,CAAC,aAAa,EAAE,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,gBAAgB,CAAC,CAAC,CAAC;IAC/F,CAAC,CAAC,CAAC;IACH,EAAE,CAAC,IAAI,CAAC,sDAAsD,EAAE,GAAG,EAAE;QACnE,MAAM,eAAe,GAAoB,iCAAe,CAAC,kBAAkB,CACzE,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,0CAA0C,CAAC,CACtE,CAAC;QACF,gBAAgB,CAAC,eAAe,CAAC,aAAa,EAAE,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,gBAAgB,CAAC,CAAC,CAAC;IAC/F,CAAC,CAAC,CAAC;IACH,EAAE,CAAC,IAAI,CAAC,gEAAgE,EAAE,GAAG,EAAE;QAC7E,MAAM,eAAe,GAAoB,iCAAe,CAAC,kBAAkB,CACzE,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,mDAAmD,CAAC,CAC/E,CAAC;QACF,gBAAgB,CAAC,eAAe,CAAC,aAAa,EAAE,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,0BAA0B,CAAC,CAAC,CAAC;IACzG,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport { Path } from '@rushstack/node-core-library';\r\n\r\nimport { ExtractorConfig } from '../ExtractorConfig';\r\n\r\nconst testDataFolder: string = path.join(__dirname, 'test-data');\r\n\r\nfunction expectEqualPaths(path1: string, path2: string): void {\r\n  if (!Path.isEqual(path1, path2)) {\r\n    fail('Expected paths to be equal:\\npath1: ' + path1 + '\\npath2: ' + path2);\r\n  }\r\n}\r\n\r\n// Tests for expanding the \"<lookup>\" token for the \"projectFolder\" setting in api-extractor.json\r\ndescribe(`${ExtractorConfig.name}.${ExtractorConfig.loadFileAndPrepare.name}`, () => {\r\n  it.only('config-lookup1: looks up ./api-extractor.json', () => {\r\n    const extractorConfig: ExtractorConfig = ExtractorConfig.loadFileAndPrepare(\r\n      path.join(testDataFolder, 'config-lookup1/api-extractor.json')\r\n    );\r\n    expectEqualPaths(extractorConfig.projectFolder, path.join(testDataFolder, 'config-lookup1'));\r\n  });\r\n  it.only('config-lookup2: looks up ./config/api-extractor.json', () => {\r\n    const extractorConfig: ExtractorConfig = ExtractorConfig.loadFileAndPrepare(\r\n      path.join(testDataFolder, 'config-lookup2/config/api-extractor.json')\r\n    );\r\n    expectEqualPaths(extractorConfig.projectFolder, path.join(testDataFolder, 'config-lookup2'));\r\n  });\r\n  it.only('config-lookup3a: looks up ./src/test/config/api-extractor.json', () => {\r\n    const extractorConfig: ExtractorConfig = ExtractorConfig.loadFileAndPrepare(\r\n      path.join(testDataFolder, 'config-lookup3/src/test/config/api-extractor.json')\r\n    );\r\n    expectEqualPaths(extractorConfig.projectFolder, path.join(testDataFolder, 'config-lookup3/src/test/'));\r\n  });\r\n});\r\n"]}
\ No newline at end of file
diff --git a/lib/api/test/test-data/config-lookup1/api-extractor.json b/lib/api/test/test-data/config-lookup1/api-extractor.json
new file mode 100644
index 0000000000000000000000000000000000000000..abf864f30f595efc700ea2156782d96c28f3b6ee
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup1/api-extractor.json
@@ -0,0 +1,17 @@
+{
+  "$schema": "https://developer.microsoft.com/json-schemas/api-extractor/v7/api-extractor.schema.json",
+
+  "mainEntryPointFilePath": "<projectFolder>/index.d.ts",
+
+  "apiReport": {
+    "enabled": true
+  },
+
+  "docModel": {
+    "enabled": true
+  },
+
+  "dtsRollup": {
+    "enabled": true
+  }
+}
diff --git a/lib/api/test/test-data/config-lookup1/index.d.ts b/lib/api/test/test-data/config-lookup1/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bd8276f349276147c911ae2c08b37e7b8811544
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup1/index.d.ts
@@ -0,0 +1 @@
+// empty file
diff --git a/lib/api/test/test-data/config-lookup1/package.json b/lib/api/test/test-data/config-lookup1/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..77b62df195238a97a70afd8b1776aad40c287f55
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup1/package.json
@@ -0,0 +1,4 @@
+{
+  "name": "config-lookup1",
+  "version": "1.0.0"
+}
diff --git a/lib/api/test/test-data/config-lookup1/tsconfig.json b/lib/api/test/test-data/config-lookup1/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..845c0343e3ccfcca66f8a9ed86d3d88fe48d243e
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup1/tsconfig.json
@@ -0,0 +1,25 @@
+{
+  "$schema": "http://json.schemastore.org/tsconfig",
+
+  "compilerOptions": {
+    "outDir": "lib",
+    "rootDir": "src",
+
+    "forceConsistentCasingInFileNames": true,
+    "jsx": "react",
+    "declaration": true,
+    "sourceMap": true,
+    "declarationMap": true,
+    "inlineSources": true,
+    "experimentalDecorators": true,
+    "strictNullChecks": true,
+    "noUnusedLocals": true,
+    "types": ["heft-jest", "node"],
+
+    "module": "commonjs",
+    "target": "es2017",
+    "lib": ["es2017"]
+  },
+  "include": ["src/**/*.ts", "src/**/*.tsx"],
+  "exclude": ["node_modules", "lib"]
+}
diff --git a/lib/api/test/test-data/config-lookup2/config/api-extractor.json b/lib/api/test/test-data/config-lookup2/config/api-extractor.json
new file mode 100644
index 0000000000000000000000000000000000000000..abf864f30f595efc700ea2156782d96c28f3b6ee
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup2/config/api-extractor.json
@@ -0,0 +1,17 @@
+{
+  "$schema": "https://developer.microsoft.com/json-schemas/api-extractor/v7/api-extractor.schema.json",
+
+  "mainEntryPointFilePath": "<projectFolder>/index.d.ts",
+
+  "apiReport": {
+    "enabled": true
+  },
+
+  "docModel": {
+    "enabled": true
+  },
+
+  "dtsRollup": {
+    "enabled": true
+  }
+}
diff --git a/lib/api/test/test-data/config-lookup2/index.d.ts b/lib/api/test/test-data/config-lookup2/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bd8276f349276147c911ae2c08b37e7b8811544
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup2/index.d.ts
@@ -0,0 +1 @@
+// empty file
diff --git a/lib/api/test/test-data/config-lookup2/package.json b/lib/api/test/test-data/config-lookup2/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..09ec7608475795559f0c74ba62a391440dae718d
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup2/package.json
@@ -0,0 +1,4 @@
+{
+  "name": "config-lookup2",
+  "version": "1.0.0"
+}
diff --git a/lib/api/test/test-data/config-lookup2/tsconfig.json b/lib/api/test/test-data/config-lookup2/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..845c0343e3ccfcca66f8a9ed86d3d88fe48d243e
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup2/tsconfig.json
@@ -0,0 +1,25 @@
+{
+  "$schema": "http://json.schemastore.org/tsconfig",
+
+  "compilerOptions": {
+    "outDir": "lib",
+    "rootDir": "src",
+
+    "forceConsistentCasingInFileNames": true,
+    "jsx": "react",
+    "declaration": true,
+    "sourceMap": true,
+    "declarationMap": true,
+    "inlineSources": true,
+    "experimentalDecorators": true,
+    "strictNullChecks": true,
+    "noUnusedLocals": true,
+    "types": ["heft-jest", "node"],
+
+    "module": "commonjs",
+    "target": "es2017",
+    "lib": ["es2017"]
+  },
+  "include": ["src/**/*.ts", "src/**/*.tsx"],
+  "exclude": ["node_modules", "lib"]
+}
diff --git a/lib/api/test/test-data/config-lookup3/config/api-extractor.json b/lib/api/test/test-data/config-lookup3/config/api-extractor.json
new file mode 100644
index 0000000000000000000000000000000000000000..abf864f30f595efc700ea2156782d96c28f3b6ee
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup3/config/api-extractor.json
@@ -0,0 +1,17 @@
+{
+  "$schema": "https://developer.microsoft.com/json-schemas/api-extractor/v7/api-extractor.schema.json",
+
+  "mainEntryPointFilePath": "<projectFolder>/index.d.ts",
+
+  "apiReport": {
+    "enabled": true
+  },
+
+  "docModel": {
+    "enabled": true
+  },
+
+  "dtsRollup": {
+    "enabled": true
+  }
+}
diff --git a/lib/api/test/test-data/config-lookup3/index.d.ts b/lib/api/test/test-data/config-lookup3/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bd8276f349276147c911ae2c08b37e7b8811544
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup3/index.d.ts
@@ -0,0 +1 @@
+// empty file
diff --git a/lib/api/test/test-data/config-lookup3/package.json b/lib/api/test/test-data/config-lookup3/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..f884361a7b97e78595e394222772a0578a795a82
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup3/package.json
@@ -0,0 +1,4 @@
+{
+  "name": "config-lookup3",
+  "version": "1.0.0"
+}
diff --git a/lib/api/test/test-data/config-lookup3/src/test/config/api-extractor.json b/lib/api/test/test-data/config-lookup3/src/test/config/api-extractor.json
new file mode 100644
index 0000000000000000000000000000000000000000..abf864f30f595efc700ea2156782d96c28f3b6ee
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup3/src/test/config/api-extractor.json
@@ -0,0 +1,17 @@
+{
+  "$schema": "https://developer.microsoft.com/json-schemas/api-extractor/v7/api-extractor.schema.json",
+
+  "mainEntryPointFilePath": "<projectFolder>/index.d.ts",
+
+  "apiReport": {
+    "enabled": true
+  },
+
+  "docModel": {
+    "enabled": true
+  },
+
+  "dtsRollup": {
+    "enabled": true
+  }
+}
diff --git a/lib/api/test/test-data/config-lookup3/src/test/index.d.ts b/lib/api/test/test-data/config-lookup3/src/test/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bd8276f349276147c911ae2c08b37e7b8811544
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup3/src/test/index.d.ts
@@ -0,0 +1 @@
+// empty file
diff --git a/lib/api/test/test-data/config-lookup3/src/test/tsconfig.json b/lib/api/test/test-data/config-lookup3/src/test/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..845c0343e3ccfcca66f8a9ed86d3d88fe48d243e
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup3/src/test/tsconfig.json
@@ -0,0 +1,25 @@
+{
+  "$schema": "http://json.schemastore.org/tsconfig",
+
+  "compilerOptions": {
+    "outDir": "lib",
+    "rootDir": "src",
+
+    "forceConsistentCasingInFileNames": true,
+    "jsx": "react",
+    "declaration": true,
+    "sourceMap": true,
+    "declarationMap": true,
+    "inlineSources": true,
+    "experimentalDecorators": true,
+    "strictNullChecks": true,
+    "noUnusedLocals": true,
+    "types": ["heft-jest", "node"],
+
+    "module": "commonjs",
+    "target": "es2017",
+    "lib": ["es2017"]
+  },
+  "include": ["src/**/*.ts", "src/**/*.tsx"],
+  "exclude": ["node_modules", "lib"]
+}
diff --git a/lib/api/test/test-data/config-lookup3/tsconfig.json b/lib/api/test/test-data/config-lookup3/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..845c0343e3ccfcca66f8a9ed86d3d88fe48d243e
--- /dev/null
+++ b/lib/api/test/test-data/config-lookup3/tsconfig.json
@@ -0,0 +1,25 @@
+{
+  "$schema": "http://json.schemastore.org/tsconfig",
+
+  "compilerOptions": {
+    "outDir": "lib",
+    "rootDir": "src",
+
+    "forceConsistentCasingInFileNames": true,
+    "jsx": "react",
+    "declaration": true,
+    "sourceMap": true,
+    "declarationMap": true,
+    "inlineSources": true,
+    "experimentalDecorators": true,
+    "strictNullChecks": true,
+    "noUnusedLocals": true,
+    "types": ["heft-jest", "node"],
+
+    "module": "commonjs",
+    "target": "es2017",
+    "lib": ["es2017"]
+  },
+  "include": ["src/**/*.ts", "src/**/*.tsx"],
+  "exclude": ["node_modules", "lib"]
+}
diff --git a/lib/api/test/test-data/custom-tsdoc-tags/api-extractor.json b/lib/api/test/test-data/custom-tsdoc-tags/api-extractor.json
new file mode 100644
index 0000000000000000000000000000000000000000..abf864f30f595efc700ea2156782d96c28f3b6ee
--- /dev/null
+++ b/lib/api/test/test-data/custom-tsdoc-tags/api-extractor.json
@@ -0,0 +1,17 @@
+{
+  "$schema": "https://developer.microsoft.com/json-schemas/api-extractor/v7/api-extractor.schema.json",
+
+  "mainEntryPointFilePath": "<projectFolder>/index.d.ts",
+
+  "apiReport": {
+    "enabled": true
+  },
+
+  "docModel": {
+    "enabled": true
+  },
+
+  "dtsRollup": {
+    "enabled": true
+  }
+}
diff --git a/lib/api/test/test-data/custom-tsdoc-tags/index.d.ts b/lib/api/test/test-data/custom-tsdoc-tags/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8d125dc716db858506346186267e7c327bfd481d
--- /dev/null
+++ b/lib/api/test/test-data/custom-tsdoc-tags/index.d.ts
@@ -0,0 +1,7 @@
+/**
+ * @block
+ *
+ * @inline test
+ * @modifier
+ */
+interface CustomTagsTestInterface {}
diff --git a/lib/api/test/test-data/custom-tsdoc-tags/package.json b/lib/api/test/test-data/custom-tsdoc-tags/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..77b62df195238a97a70afd8b1776aad40c287f55
--- /dev/null
+++ b/lib/api/test/test-data/custom-tsdoc-tags/package.json
@@ -0,0 +1,4 @@
+{
+  "name": "config-lookup1",
+  "version": "1.0.0"
+}
diff --git a/lib/api/test/test-data/custom-tsdoc-tags/tsconfig.json b/lib/api/test/test-data/custom-tsdoc-tags/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..845c0343e3ccfcca66f8a9ed86d3d88fe48d243e
--- /dev/null
+++ b/lib/api/test/test-data/custom-tsdoc-tags/tsconfig.json
@@ -0,0 +1,25 @@
+{
+  "$schema": "http://json.schemastore.org/tsconfig",
+
+  "compilerOptions": {
+    "outDir": "lib",
+    "rootDir": "src",
+
+    "forceConsistentCasingInFileNames": true,
+    "jsx": "react",
+    "declaration": true,
+    "sourceMap": true,
+    "declarationMap": true,
+    "inlineSources": true,
+    "experimentalDecorators": true,
+    "strictNullChecks": true,
+    "noUnusedLocals": true,
+    "types": ["heft-jest", "node"],
+
+    "module": "commonjs",
+    "target": "es2017",
+    "lib": ["es2017"]
+  },
+  "include": ["src/**/*.ts", "src/**/*.tsx"],
+  "exclude": ["node_modules", "lib"]
+}
diff --git a/lib/api/test/test-data/custom-tsdoc-tags/tsdoc.json b/lib/api/test/test-data/custom-tsdoc-tags/tsdoc.json
new file mode 100644
index 0000000000000000000000000000000000000000..e744a0311bd0c79d79326eda015504925d049cc3
--- /dev/null
+++ b/lib/api/test/test-data/custom-tsdoc-tags/tsdoc.json
@@ -0,0 +1,24 @@
+{
+  "$schema": "https://developer.microsoft.com/json-schemas/tsdoc/v0/tsdoc.schema.json",
+  "extends": ["../../../../../extends/tsdoc-base.json"],
+  "tagDefinitions": [
+    {
+      "tagName": "@block",
+      "syntaxKind": "block"
+    },
+    {
+      "tagName": "@inline",
+      "syntaxKind": "inline",
+      "allowMultiple": true
+    },
+    {
+      "tagName": "@modifier",
+      "syntaxKind": "modifier"
+    }
+  ],
+  "supportForTags": {
+    "@block": true,
+    "@inline": true,
+    "@modifier": false
+  }
+}
diff --git a/lib/cli/ApiExtractorCommandLine.js.map b/lib/cli/ApiExtractorCommandLine.js.map
index bcd1c29fff882627170143f58f499e33a1b49868..8da9606771bfd607c8436cf1689cd564749ac139 100644
--- a/lib/cli/ApiExtractorCommandLine.js.map
+++ b/lib/cli/ApiExtractorCommandLine.js.map
@@ -1 +1 @@
-{"version":3,"file":"ApiExtractorCommandLine.js","sourceRoot":"","sources":["../../src/cli/ApiExtractorCommandLine.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,oDAA4B;AAC5B,uCAAyB;AAEzB,gEAA8F;AAC9F,oEAA6D;AAE7D,2CAAwC;AACxC,6CAA0C;AAE1C,MAAa,uBAAwB,SAAQ,mCAAiB;IAG5D;QACE,KAAK,CAAC;YACJ,YAAY,EAAE,eAAe;YAC7B,eAAe,EACb,wFAAwF;gBACxF,0GAA0G;gBAC1G,qGAAqG;gBACrG,oGAAoG;gBACpG,wEAAwE;SAC3E,CAAC,CAAC;QACH,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAExB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC;YAC9C,iBAAiB,EAAE,SAAS;YAC5B,kBAAkB,EAAE,IAAI;YACxB,WAAW,EAAE,sEAAsE;SACpF,CAAC,CAAC;IACL,CAAC;IAES,SAAS;QACjB,WAAW;QACX,IAAI,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE;YAC9B,iCAAa,CAAC,eAAe,GAAG,IAAI,CAAC;SACtC;QAED,OAAO,KAAK,CAAC,SAAS,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;YACvC,IAAI,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE;gBAC9B,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;aACrC;iBAAM;gBACL,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,GAAG,gBAAM,CAAC,GAAG,CAAC,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;aACtE;YAED,OAAO,CAAC,QAAQ,GAAG,CAAC,CAAC;QACvB,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,gBAAgB;QACtB,IAAI,CAAC,SAAS,CAAC,IAAI,uBAAU,CAAC,IAAI,CAAC,CAAC,CAAC;QACrC,IAAI,CAAC,SAAS,CAAC,IAAI,qBAAS,CAAC,IAAI,CAAC,CAAC,CAAC;IACtC,CAAC;CACF;AA3CD,0DA2CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport colors from 'colors';\nimport * as os from 'os';\n\nimport { CommandLineParser, type CommandLineFlagParameter } from '@rushstack/ts-command-line';\nimport { InternalError } from '@rushstack/node-core-library';\n\nimport { RunAction } from './RunAction';\nimport { InitAction } from './InitAction';\n\nexport class ApiExtractorCommandLine extends CommandLineParser {\n  private readonly _debugParameter: CommandLineFlagParameter;\n\n  public constructor() {\n    super({\n      toolFilename: 'api-extractor',\n      toolDescription:\n        'API Extractor helps you build better TypeScript libraries.  It analyzes the main entry' +\n        ' point for your package, collects the inventory of exported declarations, and then generates three kinds' +\n        ' of output:  an API report file (.api.md) to facilitate reviews, a declaration rollup (.d.ts) to be' +\n        ' published with your NPM package, and a doc model file (.api.json) to be used with a documentation' +\n        ' tool such as api-documenter.  For details, please visit the web site.'\n    });\n    this._populateActions();\n\n    this._debugParameter = this.defineFlagParameter({\n      parameterLongName: '--debug',\n      parameterShortName: '-d',\n      description: 'Show the full call stack if an error occurs while executing the tool'\n    });\n  }\n\n  protected onExecute(): Promise<void> {\n    // override\n    if (this._debugParameter.value) {\n      InternalError.breakInDebugger = true;\n    }\n\n    return super.onExecute().catch((error) => {\n      if (this._debugParameter.value) {\n        console.error(os.EOL + error.stack);\n      } else {\n        console.error(os.EOL + colors.red('ERROR: ' + error.message.trim()));\n      }\n\n      process.exitCode = 1;\n    });\n  }\n\n  private _populateActions(): void {\n    this.addAction(new InitAction(this));\n    this.addAction(new RunAction(this));\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ApiExtractorCommandLine.js","sourceRoot":"","sources":["../../src/cli/ApiExtractorCommandLine.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,oDAA4B;AAC5B,uCAAyB;AAEzB,gEAA8F;AAC9F,oEAA6D;AAE7D,2CAAwC;AACxC,6CAA0C;AAE1C,MAAa,uBAAwB,SAAQ,mCAAiB;IAG5D;QACE,KAAK,CAAC;YACJ,YAAY,EAAE,eAAe;YAC7B,eAAe,EACb,wFAAwF;gBACxF,0GAA0G;gBAC1G,qGAAqG;gBACrG,oGAAoG;gBACpG,wEAAwE;SAC3E,CAAC,CAAC;QACH,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAExB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC;YAC9C,iBAAiB,EAAE,SAAS;YAC5B,kBAAkB,EAAE,IAAI;YACxB,WAAW,EAAE,sEAAsE;SACpF,CAAC,CAAC;IACL,CAAC;IAES,SAAS;QACjB,WAAW;QACX,IAAI,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE;YAC9B,iCAAa,CAAC,eAAe,GAAG,IAAI,CAAC;SACtC;QAED,OAAO,KAAK,CAAC,SAAS,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;YACvC,IAAI,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE;gBAC9B,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;aACrC;iBAAM;gBACL,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,GAAG,gBAAM,CAAC,GAAG,CAAC,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;aACtE;YAED,OAAO,CAAC,QAAQ,GAAG,CAAC,CAAC;QACvB,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,gBAAgB;QACtB,IAAI,CAAC,SAAS,CAAC,IAAI,uBAAU,CAAC,IAAI,CAAC,CAAC,CAAC;QACrC,IAAI,CAAC,SAAS,CAAC,IAAI,qBAAS,CAAC,IAAI,CAAC,CAAC,CAAC;IACtC,CAAC;CACF;AA3CD,0DA2CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport colors from 'colors';\r\nimport * as os from 'os';\r\n\r\nimport { CommandLineParser, type CommandLineFlagParameter } from '@rushstack/ts-command-line';\r\nimport { InternalError } from '@rushstack/node-core-library';\r\n\r\nimport { RunAction } from './RunAction';\r\nimport { InitAction } from './InitAction';\r\n\r\nexport class ApiExtractorCommandLine extends CommandLineParser {\r\n  private readonly _debugParameter: CommandLineFlagParameter;\r\n\r\n  public constructor() {\r\n    super({\r\n      toolFilename: 'api-extractor',\r\n      toolDescription:\r\n        'API Extractor helps you build better TypeScript libraries.  It analyzes the main entry' +\r\n        ' point for your package, collects the inventory of exported declarations, and then generates three kinds' +\r\n        ' of output:  an API report file (.api.md) to facilitate reviews, a declaration rollup (.d.ts) to be' +\r\n        ' published with your NPM package, and a doc model file (.api.json) to be used with a documentation' +\r\n        ' tool such as api-documenter.  For details, please visit the web site.'\r\n    });\r\n    this._populateActions();\r\n\r\n    this._debugParameter = this.defineFlagParameter({\r\n      parameterLongName: '--debug',\r\n      parameterShortName: '-d',\r\n      description: 'Show the full call stack if an error occurs while executing the tool'\r\n    });\r\n  }\r\n\r\n  protected onExecute(): Promise<void> {\r\n    // override\r\n    if (this._debugParameter.value) {\r\n      InternalError.breakInDebugger = true;\r\n    }\r\n\r\n    return super.onExecute().catch((error) => {\r\n      if (this._debugParameter.value) {\r\n        console.error(os.EOL + error.stack);\r\n      } else {\r\n        console.error(os.EOL + colors.red('ERROR: ' + error.message.trim()));\r\n      }\r\n\r\n      process.exitCode = 1;\r\n    });\r\n  }\r\n\r\n  private _populateActions(): void {\r\n    this.addAction(new InitAction(this));\r\n    this.addAction(new RunAction(this));\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/cli/InitAction.js.map b/lib/cli/InitAction.js.map
index 9a344fffb8a60e6efe5a664ff4d629fbacb6395b..16a3ba4612ea35d95b3fb26a4429d427f46a389e 100644
--- a/lib/cli/InitAction.js.map
+++ b/lib/cli/InitAction.js.map
@@ -1 +1 @@
-{"version":3,"file":"InitAction.js","sourceRoot":"","sources":["../../src/cli/InitAction.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,oDAA4B;AAC5B,2CAA6B;AAC7B,oEAA0D;AAC1D,gEAA+D;AAG/D,4DAAyD;AAEzD,MAAa,UAAW,SAAQ,mCAAiB;IAC/C,YAAmB,MAA+B;QAChD,KAAK,CAAC;YACJ,UAAU,EAAE,MAAM;YAClB,OAAO,EAAE,aAAa,iCAAe,CAAC,QAAQ,cAAc;YAC5D,aAAa,EACX,iFAAiF;gBACjF,IAAI,iCAAe,CAAC,QAAQ,0EAA0E;gBACtG,qDAAqD;SACxD,CAAC,CAAC;IACL,CAAC;IAES,KAAK,CAAC,SAAS;QACvB,WAAW;QACX,MAAM,aAAa,GAAW,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,wCAAwC,CAAC,CAAC;QAChG,MAAM,cAAc,GAAW,IAAI,CAAC,OAAO,CAAC,iCAAe,CAAC,QAAQ,CAAC,CAAC;QAEtE,IAAI,8BAAU,CAAC,MAAM,CAAC,cAAc,CAAC,EAAE;YACrC,OAAO,CAAC,GAAG,CAAC,gBAAM,CAAC,GAAG,CAAC,iCAAiC,CAAC,CAAC,CAAC;YAC3D,OAAO,CAAC,GAAG,CAAC,MAAM,GAAG,cAAc,GAAG,IAAI,CAAC,CAAC;YAC5C,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;SAChD;QAED,OAAO,CAAC,GAAG,CAAC,gBAAM,CAAC,KAAK,CAAC,gBAAgB,CAAC,GAAG,cAAc,CAAC,CAAC;QAC7D,8BAAU,CAAC,QAAQ,CAAC;YAClB,UAAU,EAAE,aAAa;YACzB,eAAe,EAAE,cAAc;SAChC,CAAC,CAAC;QAEH,OAAO,CAAC,GAAG,CACT,qFAAqF;YACnF,oDAAoD,CACvD,CAAC;IACJ,CAAC;CACF;AAlCD,gCAkCC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport colors from 'colors';\nimport * as path from 'path';\nimport { FileSystem } from '@rushstack/node-core-library';\nimport { CommandLineAction } from '@rushstack/ts-command-line';\n\nimport type { ApiExtractorCommandLine } from './ApiExtractorCommandLine';\nimport { ExtractorConfig } from '../api/ExtractorConfig';\n\nexport class InitAction extends CommandLineAction {\n  public constructor(parser: ApiExtractorCommandLine) {\n    super({\n      actionName: 'init',\n      summary: `Create an ${ExtractorConfig.FILENAME} config file`,\n      documentation:\n        `Use this command when setting up API Extractor for a new project.  It writes an` +\n        ` ${ExtractorConfig.FILENAME} config file template with code comments that describe all the settings.` +\n        ` The file will be written in the current directory.`\n    });\n  }\n\n  protected async onExecute(): Promise<void> {\n    // override\n    const inputFilePath: string = path.resolve(__dirname, '../schemas/api-extractor-template.json');\n    const outputFilePath: string = path.resolve(ExtractorConfig.FILENAME);\n\n    if (FileSystem.exists(outputFilePath)) {\n      console.log(colors.red('The output file already exists:'));\n      console.log('\\n  ' + outputFilePath + '\\n');\n      throw new Error('Unable to write output file');\n    }\n\n    console.log(colors.green('Writing file: ') + outputFilePath);\n    FileSystem.copyFile({\n      sourcePath: inputFilePath,\n      destinationPath: outputFilePath\n    });\n\n    console.log(\n      '\\nThe recommended location for this file is in the project\\'s \"config\" subfolder,\\n' +\n        'or else in the top-level folder with package.json.'\n    );\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"InitAction.js","sourceRoot":"","sources":["../../src/cli/InitAction.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,oDAA4B;AAC5B,2CAA6B;AAC7B,oEAA0D;AAC1D,gEAA+D;AAG/D,4DAAyD;AAEzD,MAAa,UAAW,SAAQ,mCAAiB;IAC/C,YAAmB,MAA+B;QAChD,KAAK,CAAC;YACJ,UAAU,EAAE,MAAM;YAClB,OAAO,EAAE,aAAa,iCAAe,CAAC,QAAQ,cAAc;YAC5D,aAAa,EACX,iFAAiF;gBACjF,IAAI,iCAAe,CAAC,QAAQ,0EAA0E;gBACtG,qDAAqD;SACxD,CAAC,CAAC;IACL,CAAC;IAES,KAAK,CAAC,SAAS;QACvB,WAAW;QACX,MAAM,aAAa,GAAW,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,wCAAwC,CAAC,CAAC;QAChG,MAAM,cAAc,GAAW,IAAI,CAAC,OAAO,CAAC,iCAAe,CAAC,QAAQ,CAAC,CAAC;QAEtE,IAAI,8BAAU,CAAC,MAAM,CAAC,cAAc,CAAC,EAAE;YACrC,OAAO,CAAC,GAAG,CAAC,gBAAM,CAAC,GAAG,CAAC,iCAAiC,CAAC,CAAC,CAAC;YAC3D,OAAO,CAAC,GAAG,CAAC,MAAM,GAAG,cAAc,GAAG,IAAI,CAAC,CAAC;YAC5C,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;SAChD;QAED,OAAO,CAAC,GAAG,CAAC,gBAAM,CAAC,KAAK,CAAC,gBAAgB,CAAC,GAAG,cAAc,CAAC,CAAC;QAC7D,8BAAU,CAAC,QAAQ,CAAC;YAClB,UAAU,EAAE,aAAa;YACzB,eAAe,EAAE,cAAc;SAChC,CAAC,CAAC;QAEH,OAAO,CAAC,GAAG,CACT,qFAAqF;YACnF,oDAAoD,CACvD,CAAC;IACJ,CAAC;CACF;AAlCD,gCAkCC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport colors from 'colors';\r\nimport * as path from 'path';\r\nimport { FileSystem } from '@rushstack/node-core-library';\r\nimport { CommandLineAction } from '@rushstack/ts-command-line';\r\n\r\nimport type { ApiExtractorCommandLine } from './ApiExtractorCommandLine';\r\nimport { ExtractorConfig } from '../api/ExtractorConfig';\r\n\r\nexport class InitAction extends CommandLineAction {\r\n  public constructor(parser: ApiExtractorCommandLine) {\r\n    super({\r\n      actionName: 'init',\r\n      summary: `Create an ${ExtractorConfig.FILENAME} config file`,\r\n      documentation:\r\n        `Use this command when setting up API Extractor for a new project.  It writes an` +\r\n        ` ${ExtractorConfig.FILENAME} config file template with code comments that describe all the settings.` +\r\n        ` The file will be written in the current directory.`\r\n    });\r\n  }\r\n\r\n  protected async onExecute(): Promise<void> {\r\n    // override\r\n    const inputFilePath: string = path.resolve(__dirname, '../schemas/api-extractor-template.json');\r\n    const outputFilePath: string = path.resolve(ExtractorConfig.FILENAME);\r\n\r\n    if (FileSystem.exists(outputFilePath)) {\r\n      console.log(colors.red('The output file already exists:'));\r\n      console.log('\\n  ' + outputFilePath + '\\n');\r\n      throw new Error('Unable to write output file');\r\n    }\r\n\r\n    console.log(colors.green('Writing file: ') + outputFilePath);\r\n    FileSystem.copyFile({\r\n      sourcePath: inputFilePath,\r\n      destinationPath: outputFilePath\r\n    });\r\n\r\n    console.log(\r\n      '\\nThe recommended location for this file is in the project\\'s \"config\" subfolder,\\n' +\r\n        'or else in the top-level folder with package.json.'\r\n    );\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/cli/RunAction.js.map b/lib/cli/RunAction.js.map
index d1134745a75de6fc0c7c7fb86ed5bbbbb7afb6d6..88546755894df9883c819a376166c28a1dabdf3b 100644
--- a/lib/cli/RunAction.js.map
+++ b/lib/cli/RunAction.js.map
@@ -1 +1 @@
-{"version":3,"file":"RunAction.js","sourceRoot":"","sources":["../../src/cli/RunAction.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport colors from 'colors';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { PackageJsonLookup, FileSystem, type IPackageJson, Path } from '@rushstack/node-core-library';\n\nimport {\n  CommandLineAction,\n  type CommandLineStringParameter,\n  type CommandLineFlagParameter\n} from '@rushstack/ts-command-line';\n\nimport { Extractor, type ExtractorResult } from '../api/Extractor';\n\nimport type { ApiExtractorCommandLine } from './ApiExtractorCommandLine';\nimport { ExtractorConfig, type IExtractorConfigPrepareOptions } from '../api/ExtractorConfig';\n\nexport class RunAction extends CommandLineAction {\n  private readonly _configFileParameter: CommandLineStringParameter;\n  private readonly _localParameter: CommandLineFlagParameter;\n  private readonly _verboseParameter: CommandLineFlagParameter;\n  private readonly _diagnosticsParameter: CommandLineFlagParameter;\n  private readonly _typescriptCompilerFolder: CommandLineStringParameter;\n\n  public constructor(parser: ApiExtractorCommandLine) {\n    super({\n      actionName: 'run',\n      summary: 'Invoke API Extractor on a project',\n      documentation: 'Invoke API Extractor on a project'\n    });\n\n    this._configFileParameter = this.defineStringParameter({\n      parameterLongName: '--config',\n      parameterShortName: '-c',\n      argumentName: 'FILE',\n      description: `Use the specified ${ExtractorConfig.FILENAME} file path, rather than guessing its location`\n    });\n\n    this._localParameter = this.defineFlagParameter({\n      parameterLongName: '--local',\n      parameterShortName: '-l',\n      description:\n        'Indicates that API Extractor is running as part of a local build,' +\n        \" e.g. on a developer's machine. This disables certain validation that would\" +\n        ' normally be performed for a ship/production build. For example, the *.api.md' +\n        ' report file is automatically copied in a local build.'\n    });\n\n    this._verboseParameter = this.defineFlagParameter({\n      parameterLongName: '--verbose',\n      parameterShortName: '-v',\n      description: 'Show additional informational messages in the output.'\n    });\n\n    this._diagnosticsParameter = this.defineFlagParameter({\n      parameterLongName: '--diagnostics',\n      description:\n        'Show diagnostic messages used for troubleshooting problems with API Extractor.' +\n        '  This flag also enables the \"--verbose\" flag.'\n    });\n\n    this._typescriptCompilerFolder = this.defineStringParameter({\n      parameterLongName: '--typescript-compiler-folder',\n      argumentName: 'PATH',\n      description:\n        'API Extractor uses its own TypeScript compiler engine to analyze your project.  If your project' +\n        ' is built with a significantly different TypeScript version, sometimes API Extractor may report compilation' +\n        ' errors due to differences in the system typings (e.g. lib.dom.d.ts).  You can use the' +\n        ' \"--typescriptCompilerFolder\" option to specify the folder path where you installed the TypeScript package,' +\n        \" and API Extractor's compiler will use those system typings instead.\"\n    });\n  }\n\n  protected async onExecute(): Promise<void> {\n    // override\n    const lookup: PackageJsonLookup = new PackageJsonLookup();\n    let configFilename: string;\n\n    let typescriptCompilerFolder: string | undefined = this._typescriptCompilerFolder.value;\n    if (typescriptCompilerFolder) {\n      typescriptCompilerFolder = path.normalize(typescriptCompilerFolder);\n\n      if (FileSystem.exists(typescriptCompilerFolder)) {\n        typescriptCompilerFolder = lookup.tryGetPackageFolderFor(typescriptCompilerFolder);\n        const typescriptCompilerPackageJson: IPackageJson | undefined = typescriptCompilerFolder\n          ? lookup.tryLoadPackageJsonFor(typescriptCompilerFolder)\n          : undefined;\n        if (!typescriptCompilerPackageJson) {\n          throw new Error(\n            `The path specified in the ${this._typescriptCompilerFolder.longName} parameter is not a package.`\n          );\n        } else if (typescriptCompilerPackageJson.name !== 'typescript') {\n          throw new Error(\n            `The path specified in the ${this._typescriptCompilerFolder.longName} parameter is not a TypeScript` +\n              ' compiler package.'\n          );\n        }\n      } else {\n        throw new Error(\n          `The path specified in the ${this._typescriptCompilerFolder.longName} parameter does not exist.`\n        );\n      }\n    }\n\n    let extractorConfig: ExtractorConfig;\n\n    if (this._configFileParameter.value) {\n      configFilename = path.normalize(this._configFileParameter.value);\n      if (!FileSystem.exists(configFilename)) {\n        throw new Error('Config file not found: ' + this._configFileParameter.value);\n      }\n\n      extractorConfig = ExtractorConfig.loadFileAndPrepare(configFilename);\n    } else {\n      const prepareOptions: IExtractorConfigPrepareOptions | undefined = ExtractorConfig.tryLoadForFolder({\n        startingFolder: '.'\n      });\n\n      if (!prepareOptions || !prepareOptions.configObjectFullPath) {\n        throw new Error(`Unable to find an ${ExtractorConfig.FILENAME} file`);\n      }\n\n      const configObjectShortPath: string = Path.formatConcisely({\n        pathToConvert: prepareOptions.configObjectFullPath,\n        baseFolder: process.cwd()\n      });\n      console.log(`Using configuration from ${configObjectShortPath}`);\n\n      extractorConfig = ExtractorConfig.prepare(prepareOptions);\n    }\n\n    const extractorResult: ExtractorResult = Extractor.invoke(extractorConfig, {\n      localBuild: this._localParameter.value,\n      showVerboseMessages: this._verboseParameter.value,\n      showDiagnostics: this._diagnosticsParameter.value,\n      typescriptCompilerFolder: typescriptCompilerFolder\n    });\n\n    if (extractorResult.succeeded) {\n      console.log(os.EOL + 'API Extractor completed successfully');\n    } else {\n      process.exitCode = 1;\n\n      if (extractorResult.errorCount > 0) {\n        console.log(os.EOL + colors.red('API Extractor completed with errors'));\n      } else {\n        console.log(os.EOL + colors.yellow('API Extractor completed with warnings'));\n      }\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"RunAction.js","sourceRoot":"","sources":["../../src/cli/RunAction.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport colors from 'colors';\r\nimport * as os from 'os';\r\nimport * as path from 'path';\r\nimport { PackageJsonLookup, FileSystem, type IPackageJson, Path } from '@rushstack/node-core-library';\r\n\r\nimport {\r\n  CommandLineAction,\r\n  type CommandLineStringParameter,\r\n  type CommandLineFlagParameter\r\n} from '@rushstack/ts-command-line';\r\n\r\nimport { Extractor, type ExtractorResult } from '../api/Extractor';\r\n\r\nimport type { ApiExtractorCommandLine } from './ApiExtractorCommandLine';\r\nimport { ExtractorConfig, type IExtractorConfigPrepareOptions } from '../api/ExtractorConfig';\r\n\r\nexport class RunAction extends CommandLineAction {\r\n  private readonly _configFileParameter: CommandLineStringParameter;\r\n  private readonly _localParameter: CommandLineFlagParameter;\r\n  private readonly _verboseParameter: CommandLineFlagParameter;\r\n  private readonly _diagnosticsParameter: CommandLineFlagParameter;\r\n  private readonly _typescriptCompilerFolder: CommandLineStringParameter;\r\n\r\n  public constructor(parser: ApiExtractorCommandLine) {\r\n    super({\r\n      actionName: 'run',\r\n      summary: 'Invoke API Extractor on a project',\r\n      documentation: 'Invoke API Extractor on a project'\r\n    });\r\n\r\n    this._configFileParameter = this.defineStringParameter({\r\n      parameterLongName: '--config',\r\n      parameterShortName: '-c',\r\n      argumentName: 'FILE',\r\n      description: `Use the specified ${ExtractorConfig.FILENAME} file path, rather than guessing its location`\r\n    });\r\n\r\n    this._localParameter = this.defineFlagParameter({\r\n      parameterLongName: '--local',\r\n      parameterShortName: '-l',\r\n      description:\r\n        'Indicates that API Extractor is running as part of a local build,' +\r\n        \" e.g. on a developer's machine. This disables certain validation that would\" +\r\n        ' normally be performed for a ship/production build. For example, the *.api.md' +\r\n        ' report file is automatically copied in a local build.'\r\n    });\r\n\r\n    this._verboseParameter = this.defineFlagParameter({\r\n      parameterLongName: '--verbose',\r\n      parameterShortName: '-v',\r\n      description: 'Show additional informational messages in the output.'\r\n    });\r\n\r\n    this._diagnosticsParameter = this.defineFlagParameter({\r\n      parameterLongName: '--diagnostics',\r\n      description:\r\n        'Show diagnostic messages used for troubleshooting problems with API Extractor.' +\r\n        '  This flag also enables the \"--verbose\" flag.'\r\n    });\r\n\r\n    this._typescriptCompilerFolder = this.defineStringParameter({\r\n      parameterLongName: '--typescript-compiler-folder',\r\n      argumentName: 'PATH',\r\n      description:\r\n        'API Extractor uses its own TypeScript compiler engine to analyze your project.  If your project' +\r\n        ' is built with a significantly different TypeScript version, sometimes API Extractor may report compilation' +\r\n        ' errors due to differences in the system typings (e.g. lib.dom.d.ts).  You can use the' +\r\n        ' \"--typescriptCompilerFolder\" option to specify the folder path where you installed the TypeScript package,' +\r\n        \" and API Extractor's compiler will use those system typings instead.\"\r\n    });\r\n  }\r\n\r\n  protected async onExecute(): Promise<void> {\r\n    // override\r\n    const lookup: PackageJsonLookup = new PackageJsonLookup();\r\n    let configFilename: string;\r\n\r\n    let typescriptCompilerFolder: string | undefined = this._typescriptCompilerFolder.value;\r\n    if (typescriptCompilerFolder) {\r\n      typescriptCompilerFolder = path.normalize(typescriptCompilerFolder);\r\n\r\n      if (FileSystem.exists(typescriptCompilerFolder)) {\r\n        typescriptCompilerFolder = lookup.tryGetPackageFolderFor(typescriptCompilerFolder);\r\n        const typescriptCompilerPackageJson: IPackageJson | undefined = typescriptCompilerFolder\r\n          ? lookup.tryLoadPackageJsonFor(typescriptCompilerFolder)\r\n          : undefined;\r\n        if (!typescriptCompilerPackageJson) {\r\n          throw new Error(\r\n            `The path specified in the ${this._typescriptCompilerFolder.longName} parameter is not a package.`\r\n          );\r\n        } else if (typescriptCompilerPackageJson.name !== 'typescript') {\r\n          throw new Error(\r\n            `The path specified in the ${this._typescriptCompilerFolder.longName} parameter is not a TypeScript` +\r\n              ' compiler package.'\r\n          );\r\n        }\r\n      } else {\r\n        throw new Error(\r\n          `The path specified in the ${this._typescriptCompilerFolder.longName} parameter does not exist.`\r\n        );\r\n      }\r\n    }\r\n\r\n    let extractorConfig: ExtractorConfig;\r\n\r\n    if (this._configFileParameter.value) {\r\n      configFilename = path.normalize(this._configFileParameter.value);\r\n      if (!FileSystem.exists(configFilename)) {\r\n        throw new Error('Config file not found: ' + this._configFileParameter.value);\r\n      }\r\n\r\n      extractorConfig = ExtractorConfig.loadFileAndPrepare(configFilename);\r\n    } else {\r\n      const prepareOptions: IExtractorConfigPrepareOptions | undefined = ExtractorConfig.tryLoadForFolder({\r\n        startingFolder: '.'\r\n      });\r\n\r\n      if (!prepareOptions || !prepareOptions.configObjectFullPath) {\r\n        throw new Error(`Unable to find an ${ExtractorConfig.FILENAME} file`);\r\n      }\r\n\r\n      const configObjectShortPath: string = Path.formatConcisely({\r\n        pathToConvert: prepareOptions.configObjectFullPath,\r\n        baseFolder: process.cwd()\r\n      });\r\n      console.log(`Using configuration from ${configObjectShortPath}`);\r\n\r\n      extractorConfig = ExtractorConfig.prepare(prepareOptions);\r\n    }\r\n\r\n    const extractorResult: ExtractorResult = Extractor.invoke(extractorConfig, {\r\n      localBuild: this._localParameter.value,\r\n      showVerboseMessages: this._verboseParameter.value,\r\n      showDiagnostics: this._diagnosticsParameter.value,\r\n      typescriptCompilerFolder: typescriptCompilerFolder\r\n    });\r\n\r\n    if (extractorResult.succeeded) {\r\n      console.log(os.EOL + 'API Extractor completed successfully');\r\n    } else {\r\n      process.exitCode = 1;\r\n\r\n      if (extractorResult.errorCount > 0) {\r\n        console.log(os.EOL + colors.red('API Extractor completed with errors'));\r\n      } else {\r\n        console.log(os.EOL + colors.yellow('API Extractor completed with warnings'));\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/collector/ApiItemMetadata.js.map b/lib/collector/ApiItemMetadata.js.map
index a0c6bd4fcf800dbf9e12ea93c1138d0931125bfd..ee046ea8f6259f35ffe38678699e110201baf84d 100644
--- a/lib/collector/ApiItemMetadata.js.map
+++ b/lib/collector/ApiItemMetadata.js.map
@@ -1 +1 @@
-{"version":3,"file":"ApiItemMetadata.js","sourceRoot":"","sources":["../../src/collector/ApiItemMetadata.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAI3D,iDAA8C;AAgB9C;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAa,eAAe;IAqC1B,YAAmB,OAAgC;QALnD,iCAAiC;QAC1B,iBAAY,GAAY,IAAI,CAAC;QAE7B,mCAA8B,GAAiB,2BAAY,CAAC,SAAS,CAAC;QAG3E,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,CAAC;QACrD,IAAI,CAAC,mBAAmB,GAAG,OAAO,CAAC,mBAAmB,CAAC;QACvD,IAAI,CAAC,sBAAsB,GAAG,OAAO,CAAC,sBAAsB,CAAC;QAC7D,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC;QAC/C,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACrC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;QACjC,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;IAC7C,CAAC;CACF;AA/CD,0CA+CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type * as tsdoc from '@microsoft/tsdoc';\nimport type { ReleaseTag } from '@microsoft/api-extractor-model';\nimport { VisitorState } from './VisitorState';\n\n/**\n * Constructor parameters for `ApiItemMetadata`.\n */\nexport interface IApiItemMetadataOptions {\n  declaredReleaseTag: ReleaseTag;\n  effectiveReleaseTag: ReleaseTag;\n  releaseTagSameAsParent: boolean;\n  isEventProperty: boolean;\n  isOverride: boolean;\n  isSealed: boolean;\n  isVirtual: boolean;\n  isPreapproved: boolean;\n}\n\n/**\n * Stores the Collector's additional analysis for an `AstDeclaration`.  This object is assigned to\n * `AstDeclaration.apiItemMetadata` but consumers must always obtain it by calling `Collector.fetchApiItemMetadata()`.\n *\n * @remarks\n * Note that ancillary declarations share their `ApiItemMetadata` with the main declaration,\n * whereas a separate `DeclarationMetadata` object is created for each declaration.\n *\n * Consider this example:\n * ```ts\n * export declare class A {\n *   get b(): string;\n *   set b(value: string);\n * }\n * export declare namespace A { }\n * ```\n *\n * In this example, there are two \"symbols\": `A` and `b`\n *\n * There are four \"declarations\": `A` class, `A` namespace, `b` getter, `b` setter\n *\n * There are three \"API items\": `A` class, `A` namespace, `b` property.  The property getter is the main declaration\n * for `b`, and the setter is the \"ancillary\" declaration.\n */\nexport class ApiItemMetadata {\n  /**\n   * This is the release tag that was explicitly specified in the original doc comment, if any.\n   */\n  public readonly declaredReleaseTag: ReleaseTag;\n\n  /**\n   * The \"effective\" release tag is a normalized value that is based on `declaredReleaseTag`,\n   * but may be inherited from a parent, or corrected if the declared value was somehow invalid.\n   * When actually trimming .d.ts files or generating docs, API Extractor uses the \"effective\" value\n   * instead of the \"declared\" value.\n   */\n  public readonly effectiveReleaseTag: ReleaseTag;\n\n  // If true, then it would be redundant to show this release tag\n  public readonly releaseTagSameAsParent: boolean;\n\n  // NOTE: In the future, the Collector may infer or error-correct some of these states.\n  // Generators should rely on these instead of tsdocComment.modifierTagSet.\n  public readonly isEventProperty: boolean;\n  public readonly isOverride: boolean;\n  public readonly isSealed: boolean;\n  public readonly isVirtual: boolean;\n\n  public readonly isPreapproved: boolean;\n\n  /**\n   * This is the TSDoc comment for the declaration.  It may be modified (or constructed artificially) by\n   * the DocCommentEnhancer.\n   */\n  public tsdocComment: tsdoc.DocComment | undefined;\n\n  // Assigned by DocCommentEnhancer\n  public undocumented: boolean = true;\n\n  public docCommentEnhancerVisitorState: VisitorState = VisitorState.Unvisited;\n\n  public constructor(options: IApiItemMetadataOptions) {\n    this.declaredReleaseTag = options.declaredReleaseTag;\n    this.effectiveReleaseTag = options.effectiveReleaseTag;\n    this.releaseTagSameAsParent = options.releaseTagSameAsParent;\n    this.isEventProperty = options.isEventProperty;\n    this.isOverride = options.isOverride;\n    this.isSealed = options.isSealed;\n    this.isVirtual = options.isVirtual;\n    this.isPreapproved = options.isPreapproved;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ApiItemMetadata.js","sourceRoot":"","sources":["../../src/collector/ApiItemMetadata.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAI3D,iDAA8C;AAgB9C;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAa,eAAe;IAqC1B,YAAmB,OAAgC;QALnD,iCAAiC;QAC1B,iBAAY,GAAY,IAAI,CAAC;QAE7B,mCAA8B,GAAiB,2BAAY,CAAC,SAAS,CAAC;QAG3E,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,CAAC;QACrD,IAAI,CAAC,mBAAmB,GAAG,OAAO,CAAC,mBAAmB,CAAC;QACvD,IAAI,CAAC,sBAAsB,GAAG,OAAO,CAAC,sBAAsB,CAAC;QAC7D,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC;QAC/C,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACrC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;QACjC,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;IAC7C,CAAC;CACF;AA/CD,0CA+CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport type * as tsdoc from '@microsoft/tsdoc';\r\nimport type { ReleaseTag } from '@microsoft/api-extractor-model';\r\nimport { VisitorState } from './VisitorState';\r\n\r\n/**\r\n * Constructor parameters for `ApiItemMetadata`.\r\n */\r\nexport interface IApiItemMetadataOptions {\r\n  declaredReleaseTag: ReleaseTag;\r\n  effectiveReleaseTag: ReleaseTag;\r\n  releaseTagSameAsParent: boolean;\r\n  isEventProperty: boolean;\r\n  isOverride: boolean;\r\n  isSealed: boolean;\r\n  isVirtual: boolean;\r\n  isPreapproved: boolean;\r\n}\r\n\r\n/**\r\n * Stores the Collector's additional analysis for an `AstDeclaration`.  This object is assigned to\r\n * `AstDeclaration.apiItemMetadata` but consumers must always obtain it by calling `Collector.fetchApiItemMetadata()`.\r\n *\r\n * @remarks\r\n * Note that ancillary declarations share their `ApiItemMetadata` with the main declaration,\r\n * whereas a separate `DeclarationMetadata` object is created for each declaration.\r\n *\r\n * Consider this example:\r\n * ```ts\r\n * export declare class A {\r\n *   get b(): string;\r\n *   set b(value: string);\r\n * }\r\n * export declare namespace A { }\r\n * ```\r\n *\r\n * In this example, there are two \"symbols\": `A` and `b`\r\n *\r\n * There are four \"declarations\": `A` class, `A` namespace, `b` getter, `b` setter\r\n *\r\n * There are three \"API items\": `A` class, `A` namespace, `b` property.  The property getter is the main declaration\r\n * for `b`, and the setter is the \"ancillary\" declaration.\r\n */\r\nexport class ApiItemMetadata {\r\n  /**\r\n   * This is the release tag that was explicitly specified in the original doc comment, if any.\r\n   */\r\n  public readonly declaredReleaseTag: ReleaseTag;\r\n\r\n  /**\r\n   * The \"effective\" release tag is a normalized value that is based on `declaredReleaseTag`,\r\n   * but may be inherited from a parent, or corrected if the declared value was somehow invalid.\r\n   * When actually trimming .d.ts files or generating docs, API Extractor uses the \"effective\" value\r\n   * instead of the \"declared\" value.\r\n   */\r\n  public readonly effectiveReleaseTag: ReleaseTag;\r\n\r\n  // If true, then it would be redundant to show this release tag\r\n  public readonly releaseTagSameAsParent: boolean;\r\n\r\n  // NOTE: In the future, the Collector may infer or error-correct some of these states.\r\n  // Generators should rely on these instead of tsdocComment.modifierTagSet.\r\n  public readonly isEventProperty: boolean;\r\n  public readonly isOverride: boolean;\r\n  public readonly isSealed: boolean;\r\n  public readonly isVirtual: boolean;\r\n\r\n  public readonly isPreapproved: boolean;\r\n\r\n  /**\r\n   * This is the TSDoc comment for the declaration.  It may be modified (or constructed artificially) by\r\n   * the DocCommentEnhancer.\r\n   */\r\n  public tsdocComment: tsdoc.DocComment | undefined;\r\n\r\n  // Assigned by DocCommentEnhancer\r\n  public undocumented: boolean = true;\r\n\r\n  public docCommentEnhancerVisitorState: VisitorState = VisitorState.Unvisited;\r\n\r\n  public constructor(options: IApiItemMetadataOptions) {\r\n    this.declaredReleaseTag = options.declaredReleaseTag;\r\n    this.effectiveReleaseTag = options.effectiveReleaseTag;\r\n    this.releaseTagSameAsParent = options.releaseTagSameAsParent;\r\n    this.isEventProperty = options.isEventProperty;\r\n    this.isOverride = options.isOverride;\r\n    this.isSealed = options.isSealed;\r\n    this.isVirtual = options.isVirtual;\r\n    this.isPreapproved = options.isPreapproved;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/collector/Collector.d.ts b/lib/collector/Collector.d.ts
index e5f737bbc0333765cf11df5dba61ae89389bb840..1460a99c8408c376ad328f4286363c0f9254e236 100644
--- a/lib/collector/Collector.d.ts
+++ b/lib/collector/Collector.d.ts
@@ -63,6 +63,14 @@ export declare class Collector {
     private readonly _dtsLibReferenceDirectives;
     private readonly _cachedOverloadIndexesByDeclaration;
     constructor(options: ICollectorOptions);
+    /**
+     * Searches the provided package.json for dependencies and devDependencies that match the provided
+     * package names and/or RegExp patterns in `bundledPackages`.
+     * @param bundledPackages - The list of package names and/or RegExp patterns to search for in the package.json.
+     * @param packageJson - The package.json of the package being processed.
+     * @returns The set of matching package names.
+     */
+    private static _resolveBundledPackagePatterns;
     /**
      * Returns a list of names (e.g. "example-library") that should appear in a reference like this:
      *
diff --git a/lib/collector/Collector.d.ts.map b/lib/collector/Collector.d.ts.map
index c7e0a0a187a3da9340ca00d7b307e375469b3690..8be38aaa09c514f254aa7fd9d1d38a064548c608 100644
--- a/lib/collector/Collector.d.ts.map
+++ b/lib/collector/Collector.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"Collector.d.ts","sourceRoot":"","sources":["../../src/collector/Collector.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"Collector.d.ts","sourceRoot":"","sources":["../../src/collector/Collector.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/lib/collector/Collector.js b/lib/collector/Collector.js
index 34702cd3969e8357dd97815185af571c7d85b49e..7b2b1749f5f725931bd68839491543d4f6abfb76 100644
--- a/lib/collector/Collector.js
+++ b/lib/collector/Collector.js
@@ -81,11 +81,65 @@ class Collector {
         this.typeChecker = options.program.getTypeChecker();
         this.globalVariableAnalyzer = TypeScriptInternals_1.TypeScriptInternals.getGlobalVariableAnalyzer(this.program);
         this._tsdocParser = new tsdoc.TSDocParser(this.extractorConfig.tsdocConfiguration);
-        this.bundledPackageNames = new Set(this.extractorConfig.bundledPackages);
+        // Resolve glob patterns and store concrete set of bundled package dependency names
+        this.bundledPackageNames = Collector._resolveBundledPackagePatterns(this.extractorConfig.bundledPackages, this.extractorConfig.packageJson);
         this.astSymbolTable = new AstSymbolTable_1.AstSymbolTable(this.program, this.typeChecker, this.packageJsonLookup, this.bundledPackageNames, this.messageRouter);
         this.astReferenceResolver = new AstReferenceResolver_1.AstReferenceResolver(this);
         this._cachedOverloadIndexesByDeclaration = new Map();
     }
+    /**
+     * Searches the provided package.json for dependencies and devDependencies that match the provided
+     * package names and/or RegExp patterns in `bundledPackages`.
+     * @param bundledPackages - The list of package names and/or RegExp patterns to search for in the package.json.
+     * @param packageJson - The package.json of the package being processed.
+     * @returns The set of matching package names.
+     */
+    static _resolveBundledPackagePatterns(bundledPackages, packageJson) {
+        var _a, _b;
+        // The set to be built up and returned
+        const packageNames = new Set();
+        if (bundledPackages.length === 0) {
+            // If no `bundledPackages` were specified, then there is nothing to resolve.
+            // Return an empty set.
+            return packageNames;
+        }
+        if (packageJson === undefined) {
+            // If no package.json is present, then there are no possible package matches.
+            // Return an empty set.
+            return packageNames;
+        }
+        const dependencyKeys = Object.keys((_a = packageJson.dependencies) !== null && _a !== void 0 ? _a : {});
+        const devDependencyKeys = Object.keys((_b = packageJson.devDependencies) !== null && _b !== void 0 ? _b : {});
+        const dependencyNames = dependencyKeys.concat(devDependencyKeys);
+        if (dependencyNames.length === 0) {
+            // If there are no dependencies nor devDependencies, then there are no possible package matches.
+            // Return an empty set.
+            return packageNames;
+        }
+        for (const packageNameOrPattern of bundledPackages) {
+            if (node_core_library_1.PackageName.isValidName(packageNameOrPattern)) {
+                // If the string is an exact package name, search for exact match
+                if (dependencyNames.includes(packageNameOrPattern)) {
+                    packageNames.add(packageNameOrPattern);
+                }
+                else {
+                    console.warn(`package.json contained no dependency or devDependency for specified bundledPackages entry "${packageNameOrPattern}".`);
+                }
+            }
+            else {
+                // If the entry isn't an exact package name, assume RegExp and search for matches
+                const regexp = new RegExp(packageNameOrPattern);
+                const matches = dependencyNames.filter((dependencyName) => regexp.test(dependencyName));
+                if (matches.length === 0) {
+                    console.warn(`No matching package dependencies found for provided bundledPackages pattern "${packageNameOrPattern}".`);
+                }
+                else {
+                    matches.forEach((match) => packageNames.add(match));
+                }
+            }
+        }
+        return packageNames;
+    }
     /**
      * Returns a list of names (e.g. "example-library") that should appear in a reference like this:
      *
diff --git a/lib/collector/Collector.js.map b/lib/collector/Collector.js.map
index 0839796e78ab568e07adb4d19525c7671dda9680..84e5bef9b975ea9772cf1969e2d216cf7f1c8f7f 100644
--- a/lib/collector/Collector.js.map
+++ b/lib/collector/Collector.js.map
@@ -1 +1 @@
-{"version":3,"file":"Collector.js","sourceRoot":"","sources":["../../src/collector/Collector.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\nimport * as tsdoc from '@microsoft/tsdoc';\nimport { PackageJsonLookup, Sort, InternalError } from '@rushstack/node-core-library';\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\n\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\n\nimport { CollectorEntity } from './CollectorEntity';\nimport { AstSymbolTable } from '../analyzer/AstSymbolTable';\nimport type { AstEntity } from '../analyzer/AstEntity';\nimport type { AstModule, AstModuleExportInfo } from '../analyzer/AstModule';\nimport { AstSymbol } from '../analyzer/AstSymbol';\nimport type { AstDeclaration } from '../analyzer/AstDeclaration';\nimport { TypeScriptHelpers } from '../analyzer/TypeScriptHelpers';\nimport { WorkingPackage } from './WorkingPackage';\nimport { PackageDocComment } from '../aedoc/PackageDocComment';\nimport { type DeclarationMetadata, InternalDeclarationMetadata } from './DeclarationMetadata';\nimport { ApiItemMetadata, type IApiItemMetadataOptions } from './ApiItemMetadata';\nimport { SymbolMetadata } from './SymbolMetadata';\nimport { TypeScriptInternals, type IGlobalVariableAnalyzer } from '../analyzer/TypeScriptInternals';\nimport type { MessageRouter } from './MessageRouter';\nimport { AstReferenceResolver } from '../analyzer/AstReferenceResolver';\nimport { ExtractorConfig } from '../api/ExtractorConfig';\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\nimport { AstImport } from '../analyzer/AstImport';\nimport type { SourceMapper } from './SourceMapper';\n\n/**\n * Options for Collector constructor.\n */\nexport interface ICollectorOptions {\n  /**\n   * Configuration for the TypeScript compiler.  The most important options to set are:\n   *\n   * - target: ts.ScriptTarget.ES5\n   * - module: ts.ModuleKind.CommonJS\n   * - moduleResolution: ts.ModuleResolutionKind.NodeJs\n   * - rootDir: inputFolder\n   */\n  program: ts.Program;\n\n  messageRouter: MessageRouter;\n\n  extractorConfig: ExtractorConfig;\n\n  sourceMapper: SourceMapper;\n}\n\n/**\n * The `Collector` manages the overall data set that is used by `ApiModelGenerator`,\n * `DtsRollupGenerator`, and `ApiReportGenerator`.  Starting from the working package's entry point,\n * the `Collector` collects all exported symbols, determines how to import any symbols they reference,\n * assigns unique names, and sorts everything into a normalized alphabetical ordering.\n */\nexport class Collector {\n  public readonly program: ts.Program;\n  public readonly typeChecker: ts.TypeChecker;\n  public readonly globalVariableAnalyzer: IGlobalVariableAnalyzer;\n  public readonly astSymbolTable: AstSymbolTable;\n  public readonly astReferenceResolver: AstReferenceResolver;\n\n  public readonly packageJsonLookup: PackageJsonLookup;\n  public readonly messageRouter: MessageRouter;\n\n  public readonly workingPackage: WorkingPackage;\n\n  public readonly extractorConfig: ExtractorConfig;\n\n  public readonly sourceMapper: SourceMapper;\n\n  /**\n   * The `ExtractorConfig.bundledPackages` names in a set.\n   */\n  public readonly bundledPackageNames: ReadonlySet<string>;\n\n  private readonly _program: ts.Program;\n\n  private readonly _tsdocParser: tsdoc.TSDocParser;\n\n  private _astEntryPoint: AstModule | undefined;\n\n  private readonly _entities: CollectorEntity[] = [];\n  private readonly _entitiesByAstEntity: Map<AstEntity, CollectorEntity> = new Map<\n    AstEntity,\n    CollectorEntity\n  >();\n  private readonly _entitiesBySymbol: Map<ts.Symbol, CollectorEntity> = new Map<ts.Symbol, CollectorEntity>();\n\n  private readonly _starExportedExternalModulePaths: string[] = [];\n\n  private readonly _dtsTypeReferenceDirectives: Set<string> = new Set<string>();\n  private readonly _dtsLibReferenceDirectives: Set<string> = new Set<string>();\n\n  // Used by getOverloadIndex()\n  private readonly _cachedOverloadIndexesByDeclaration: Map<AstDeclaration, number>;\n\n  public constructor(options: ICollectorOptions) {\n    this.packageJsonLookup = new PackageJsonLookup();\n\n    this._program = options.program;\n    this.extractorConfig = options.extractorConfig;\n    this.sourceMapper = options.sourceMapper;\n\n    const entryPointSourceFile: ts.SourceFile | undefined = options.program.getSourceFile(\n      this.extractorConfig.mainEntryPointFilePath\n    );\n\n    if (!entryPointSourceFile) {\n      throw new Error('Unable to load file: ' + this.extractorConfig.mainEntryPointFilePath);\n    }\n\n    if (!this.extractorConfig.packageFolder || !this.extractorConfig.packageJson) {\n      // TODO: We should be able to analyze projects that don't have any package.json.\n      // The ExtractorConfig class is already designed to allow this.\n      throw new Error('Unable to find a package.json file for the project being analyzed');\n    }\n\n    this.workingPackage = new WorkingPackage({\n      packageFolder: this.extractorConfig.packageFolder,\n      packageJson: this.extractorConfig.packageJson,\n      entryPointSourceFile\n    });\n\n    this.messageRouter = options.messageRouter;\n\n    this.program = options.program;\n    this.typeChecker = options.program.getTypeChecker();\n    this.globalVariableAnalyzer = TypeScriptInternals.getGlobalVariableAnalyzer(this.program);\n\n    this._tsdocParser = new tsdoc.TSDocParser(this.extractorConfig.tsdocConfiguration);\n\n    this.bundledPackageNames = new Set<string>(this.extractorConfig.bundledPackages);\n\n    this.astSymbolTable = new AstSymbolTable(\n      this.program,\n      this.typeChecker,\n      this.packageJsonLookup,\n      this.bundledPackageNames,\n      this.messageRouter\n    );\n    this.astReferenceResolver = new AstReferenceResolver(this);\n\n    this._cachedOverloadIndexesByDeclaration = new Map<AstDeclaration, number>();\n  }\n\n  /**\n   * Returns a list of names (e.g. \"example-library\") that should appear in a reference like this:\n   *\n   * ```\n   * /// <reference types=\"example-library\" />\n   * ```\n   */\n  public get dtsTypeReferenceDirectives(): ReadonlySet<string> {\n    return this._dtsTypeReferenceDirectives;\n  }\n\n  /**\n   * A list of names (e.g. \"runtime-library\") that should appear in a reference like this:\n   *\n   * ```\n   * /// <reference lib=\"runtime-library\" />\n   * ```\n   */\n  public get dtsLibReferenceDirectives(): ReadonlySet<string> {\n    return this._dtsLibReferenceDirectives;\n  }\n\n  public get entities(): ReadonlyArray<CollectorEntity> {\n    return this._entities;\n  }\n\n  /**\n   * A list of module specifiers (e.g. `\"@rushstack/node-core-library/lib/FileSystem\"`) that should be emitted\n   * as star exports (e.g. `export * from \"@rushstack/node-core-library/lib/FileSystem\"`).\n   */\n  public get starExportedExternalModulePaths(): ReadonlyArray<string> {\n    return this._starExportedExternalModulePaths;\n  }\n\n  /**\n   * Perform the analysis.\n   */\n  public analyze(): void {\n    if (this._astEntryPoint) {\n      throw new Error('DtsRollupGenerator.analyze() was already called');\n    }\n\n    // This runs a full type analysis, and then augments the Abstract Syntax Tree (i.e. declarations)\n    // with semantic information (i.e. symbols).  The \"diagnostics\" are a subset of the everyday\n    // compile errors that would result from a full compilation.\n    for (const diagnostic of this._program.getSemanticDiagnostics()) {\n      this.messageRouter.addCompilerDiagnostic(diagnostic);\n    }\n\n    const sourceFiles: readonly ts.SourceFile[] = this.program.getSourceFiles();\n\n    if (this.messageRouter.showDiagnostics) {\n      this.messageRouter.logDiagnosticHeader('Root filenames');\n      for (const fileName of this.program.getRootFileNames()) {\n        this.messageRouter.logDiagnostic(fileName);\n      }\n      this.messageRouter.logDiagnosticFooter();\n\n      this.messageRouter.logDiagnosticHeader('Files analyzed by compiler');\n      for (const sourceFile of sourceFiles) {\n        this.messageRouter.logDiagnostic(sourceFile.fileName);\n      }\n      this.messageRouter.logDiagnosticFooter();\n    }\n\n    // We can throw this error earlier in CompilerState.ts, but intentionally wait until after we've logged the\n    // associated diagnostic message above to make debugging easier for developers.\n    // Typically there will be many such files -- to avoid too much noise, only report the first one.\n    const badSourceFile: ts.SourceFile | undefined = sourceFiles.find(\n      ({ fileName }) => !ExtractorConfig.hasDtsFileExtension(fileName)\n    );\n    if (badSourceFile) {\n      this.messageRouter.addAnalyzerIssueForPosition(\n        ExtractorMessageId.WrongInputFileType,\n        'Incorrect file type; API Extractor expects to analyze compiler outputs with the .d.ts file extension. ' +\n          'Troubleshooting tips: https://api-extractor.com/link/dts-error',\n        badSourceFile,\n        0\n      );\n    }\n\n    // Build the entry point\n    const entryPointSourceFile: ts.SourceFile = this.workingPackage.entryPointSourceFile;\n\n    const astEntryPoint: AstModule =\n      this.astSymbolTable.fetchAstModuleFromWorkingPackage(entryPointSourceFile);\n    this._astEntryPoint = astEntryPoint;\n\n    const packageDocCommentTextRange: ts.TextRange | undefined = PackageDocComment.tryFindInSourceFile(\n      entryPointSourceFile,\n      this\n    );\n\n    if (packageDocCommentTextRange) {\n      const range: tsdoc.TextRange = tsdoc.TextRange.fromStringRange(\n        entryPointSourceFile.text,\n        packageDocCommentTextRange.pos,\n        packageDocCommentTextRange.end\n      );\n\n      this.workingPackage.tsdocParserContext = this._tsdocParser.parseRange(range);\n\n      this.messageRouter.addTsdocMessages(this.workingPackage.tsdocParserContext, entryPointSourceFile);\n\n      this.workingPackage.tsdocComment = this.workingPackage.tsdocParserContext!.docComment;\n    }\n\n    const astModuleExportInfo: AstModuleExportInfo =\n      this.astSymbolTable.fetchAstModuleExportInfo(astEntryPoint);\n\n    // Create a CollectorEntity for each top-level export.\n    const processedAstEntities: AstEntity[] = [];\n    for (const [exportName, astEntity] of astModuleExportInfo.exportedLocalEntities) {\n      this._createCollectorEntity(astEntity, exportName);\n      processedAstEntities.push(astEntity);\n    }\n\n    // Recursively create the remaining CollectorEntities after the top-level entities\n    // have been processed.\n    const alreadySeenAstEntities: Set<AstEntity> = new Set<AstEntity>();\n    for (const astEntity of processedAstEntities) {\n      this._recursivelyCreateEntities(astEntity, alreadySeenAstEntities);\n      if (astEntity instanceof AstSymbol) {\n        this.fetchSymbolMetadata(astEntity);\n      }\n    }\n\n    this._makeUniqueNames();\n\n    for (const starExportedExternalModule of astModuleExportInfo.starExportedExternalModules) {\n      if (starExportedExternalModule.externalModulePath !== undefined) {\n        this._starExportedExternalModulePaths.push(starExportedExternalModule.externalModulePath);\n      }\n    }\n\n    Sort.sortBy(this._entities, (x) => x.getSortKey());\n    Sort.sortSet(this._dtsTypeReferenceDirectives);\n    Sort.sortSet(this._dtsLibReferenceDirectives);\n    this._starExportedExternalModulePaths.sort();\n  }\n\n  /**\n   * For a given ts.Identifier that is part of an AstSymbol that we analyzed, return the CollectorEntity that\n   * it refers to.  Returns undefined if it doesn't refer to anything interesting.\n   * @remarks\n   * Throws an Error if the ts.Identifier is not part of node tree that was analyzed.\n   */\n  public tryGetEntityForNode(identifier: ts.Identifier | ts.ImportTypeNode): CollectorEntity | undefined {\n    const astEntity: AstEntity | undefined = this.astSymbolTable.tryGetEntityForNode(identifier);\n    if (astEntity) {\n      return this._entitiesByAstEntity.get(astEntity);\n    }\n    return undefined;\n  }\n\n  /**\n   * For a given analyzed ts.Symbol, return the CollectorEntity that it refers to. Returns undefined if it\n   * doesn't refer to anything interesting.\n   */\n  public tryGetEntityForSymbol(symbol: ts.Symbol): CollectorEntity | undefined {\n    return this._entitiesBySymbol.get(symbol);\n  }\n\n  /**\n   * Returns the associated `CollectorEntity` for the given `astEntity`, if one was created during analysis.\n   */\n  public tryGetCollectorEntity(astEntity: AstEntity): CollectorEntity | undefined {\n    return this._entitiesByAstEntity.get(astEntity);\n  }\n\n  public fetchSymbolMetadata(astSymbol: AstSymbol): SymbolMetadata {\n    if (astSymbol.symbolMetadata === undefined) {\n      this._fetchSymbolMetadata(astSymbol);\n    }\n    return astSymbol.symbolMetadata as SymbolMetadata;\n  }\n\n  public fetchDeclarationMetadata(astDeclaration: AstDeclaration): DeclarationMetadata {\n    if (astDeclaration.declarationMetadata === undefined) {\n      // Fetching the SymbolMetadata always constructs the DeclarationMetadata\n      this._fetchSymbolMetadata(astDeclaration.astSymbol);\n    }\n    return astDeclaration.declarationMetadata as DeclarationMetadata;\n  }\n\n  public fetchApiItemMetadata(astDeclaration: AstDeclaration): ApiItemMetadata {\n    if (astDeclaration.apiItemMetadata === undefined) {\n      // Fetching the SymbolMetadata always constructs the ApiItemMetadata\n      this._fetchSymbolMetadata(astDeclaration.astSymbol);\n    }\n    return astDeclaration.apiItemMetadata as ApiItemMetadata;\n  }\n\n  public tryFetchMetadataForAstEntity(astEntity: AstEntity): SymbolMetadata | undefined {\n    if (astEntity instanceof AstSymbol) {\n      return this.fetchSymbolMetadata(astEntity);\n    }\n    if (astEntity instanceof AstImport) {\n      if (astEntity.astSymbol) {\n        return this.fetchSymbolMetadata(astEntity.astSymbol);\n      }\n    }\n    return undefined;\n  }\n\n  public isAncillaryDeclaration(astDeclaration: AstDeclaration): boolean {\n    const declarationMetadata: DeclarationMetadata = this.fetchDeclarationMetadata(astDeclaration);\n    return declarationMetadata.isAncillary;\n  }\n\n  public getNonAncillaryDeclarations(astSymbol: AstSymbol): ReadonlyArray<AstDeclaration> {\n    const result: AstDeclaration[] = [];\n    for (const astDeclaration of astSymbol.astDeclarations) {\n      const declarationMetadata: DeclarationMetadata = this.fetchDeclarationMetadata(astDeclaration);\n      if (!declarationMetadata.isAncillary) {\n        result.push(astDeclaration);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Removes the leading underscore, for example: \"_Example\" --> \"example*Example*_\"\n   *\n   * @remarks\n   * This causes internal definitions to sort alphabetically case-insensitive, then case-sensitive, and\n   * initially ignoring the underscore prefix, while still deterministically comparing it.\n   * The star is used as a delimiter because it is not a legal  identifier character.\n   */\n  public static getSortKeyIgnoringUnderscore(identifier: string | undefined): string {\n    if (!identifier) return '';\n\n    let parts: string[];\n\n    if (identifier[0] === '_') {\n      const withoutUnderscore: string = identifier.substr(1);\n      parts = [withoutUnderscore.toLowerCase(), '*', withoutUnderscore, '*', '_'];\n    } else {\n      parts = [identifier.toLowerCase(), '*', identifier];\n    }\n\n    return parts.join('');\n  }\n\n  /**\n   * For function-like signatures, this returns the TSDoc \"overload index\" which can be used to identify\n   * a specific overload.\n   */\n  public getOverloadIndex(astDeclaration: AstDeclaration): number {\n    const allDeclarations: ReadonlyArray<AstDeclaration> = astDeclaration.astSymbol.astDeclarations;\n    if (allDeclarations.length === 1) {\n      return 1; // trivial case\n    }\n\n    let overloadIndex: number | undefined = this._cachedOverloadIndexesByDeclaration.get(astDeclaration);\n\n    if (overloadIndex === undefined) {\n      // TSDoc index selectors are positive integers counting from 1\n      let nextIndex: number = 1;\n      for (const other of allDeclarations) {\n        // Filter out other declarations that are not overloads.  For example, an overloaded function can also\n        // be a namespace.\n        if (other.declaration.kind === astDeclaration.declaration.kind) {\n          this._cachedOverloadIndexesByDeclaration.set(other, nextIndex);\n          ++nextIndex;\n        }\n      }\n      overloadIndex = this._cachedOverloadIndexesByDeclaration.get(astDeclaration);\n    }\n\n    if (overloadIndex === undefined) {\n      // This should never happen\n      throw new InternalError('Error calculating overload index for declaration');\n    }\n\n    return overloadIndex;\n  }\n\n  private _createCollectorEntity(\n    astEntity: AstEntity,\n    exportName?: string,\n    parent?: CollectorEntity\n  ): CollectorEntity {\n    let entity: CollectorEntity | undefined = this._entitiesByAstEntity.get(astEntity);\n\n    if (!entity) {\n      entity = new CollectorEntity(astEntity);\n\n      this._entitiesByAstEntity.set(astEntity, entity);\n      if (astEntity instanceof AstSymbol) {\n        this._entitiesBySymbol.set(astEntity.followedSymbol, entity);\n      } else if (astEntity instanceof AstNamespaceImport) {\n        this._entitiesBySymbol.set(astEntity.symbol, entity);\n      }\n      this._entities.push(entity);\n      this._collectReferenceDirectives(astEntity);\n    }\n\n    if (exportName) {\n      if (parent) {\n        entity.addLocalExportName(exportName, parent);\n      } else {\n        entity.addExportName(exportName);\n      }\n    }\n\n    return entity;\n  }\n\n  private _recursivelyCreateEntities(astEntity: AstEntity, alreadySeenAstEntities: Set<AstEntity>): void {\n    if (alreadySeenAstEntities.has(astEntity)) return;\n    alreadySeenAstEntities.add(astEntity);\n\n    if (astEntity instanceof AstSymbol) {\n      astEntity.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\n        for (const referencedAstEntity of astDeclaration.referencedAstEntities) {\n          if (referencedAstEntity instanceof AstSymbol) {\n            // We only create collector entities for root-level symbols. For example, if a symbol is\n            // nested inside a namespace, only the namespace gets a collector entity. Note that this\n            // is not true for AstNamespaceImports below.\n            if (referencedAstEntity.parentAstSymbol === undefined) {\n              this._createCollectorEntity(referencedAstEntity);\n            }\n          } else {\n            this._createCollectorEntity(referencedAstEntity);\n          }\n\n          this._recursivelyCreateEntities(referencedAstEntity, alreadySeenAstEntities);\n        }\n      });\n    }\n\n    if (astEntity instanceof AstNamespaceImport) {\n      const astModuleExportInfo: AstModuleExportInfo = astEntity.fetchAstModuleExportInfo(this);\n      const parentEntity: CollectorEntity | undefined = this._entitiesByAstEntity.get(astEntity);\n      if (!parentEntity) {\n        // This should never happen, as we've already created entities for all AstNamespaceImports.\n        throw new InternalError(\n          `Failed to get CollectorEntity for AstNamespaceImport with namespace name \"${astEntity.namespaceName}\"`\n        );\n      }\n\n      for (const [localExportName, localAstEntity] of astModuleExportInfo.exportedLocalEntities) {\n        // Create a CollectorEntity for each local export within an AstNamespaceImport entity.\n        this._createCollectorEntity(localAstEntity, localExportName, parentEntity);\n        this._recursivelyCreateEntities(localAstEntity, alreadySeenAstEntities);\n      }\n    }\n  }\n\n  /**\n   * Ensures a unique name for each item in the package typings file.\n   */\n  private _makeUniqueNames(): void {\n    // The following examples illustrate the nameForEmit heuristics:\n    //\n    // Example 1:\n    //   class X { } <--- nameForEmit should be \"A\" to simplify things and reduce possibility of conflicts\n    //   export { X as A };\n    //\n    // Example 2:\n    //   class X { } <--- nameForEmit should be \"X\" because choosing A or B would be nondeterministic\n    //   export { X as A };\n    //   export { X as B };\n    //\n    // Example 3:\n    //   class X { } <--- nameForEmit should be \"X_1\" because Y has a stronger claim to the name\n    //   export { X as A };\n    //   export { X as B };\n    //   class Y { } <--- nameForEmit should be \"X\"\n    //   export { Y as X };\n\n    // Set of names that should NOT be used when generating a unique nameForEmit\n    const usedNames: Set<string> = new Set<string>();\n\n    // First collect the names of explicit package exports, and perform a sanity check.\n    for (const entity of this._entities) {\n      for (const exportName of entity.exportNames) {\n        if (usedNames.has(exportName)) {\n          // This should be impossible\n          throw new InternalError(`A package cannot have two exports with the name \"${exportName}\"`);\n        }\n        usedNames.add(exportName);\n      }\n    }\n\n    // Ensure that each entity has a unique nameForEmit\n    for (const entity of this._entities) {\n      // What name would we ideally want to emit it as?\n      let idealNameForEmit: string;\n\n      // If this entity is exported exactly once, then we prefer the exported name\n      if (\n        entity.singleExportName !== undefined &&\n        entity.singleExportName !== ts.InternalSymbolName.Default\n      ) {\n        idealNameForEmit = entity.singleExportName;\n      } else {\n        // otherwise use the local name\n        idealNameForEmit = entity.astEntity.localName;\n      }\n\n      if (idealNameForEmit.includes('.')) {\n        // For an ImportType with a namespace chain, only the top namespace is imported.\n        idealNameForEmit = idealNameForEmit.split('.')[0];\n      }\n\n      // If the idealNameForEmit happens to be the same as one of the exports, then we're safe to use that...\n      if (entity.exportNames.has(idealNameForEmit)) {\n        // ...except that if it conflicts with a global name, then the global name wins\n        if (!this.globalVariableAnalyzer.hasGlobalName(idealNameForEmit)) {\n          // ...also avoid \"default\" which can interfere with \"export { default } from 'some-module;'\"\n          if (idealNameForEmit !== 'default') {\n            entity.nameForEmit = idealNameForEmit;\n            continue;\n          }\n        }\n      }\n\n      // Generate a unique name based on idealNameForEmit\n      let suffix: number = 1;\n      let nameForEmit: string = idealNameForEmit;\n\n      // Choose a name that doesn't conflict with usedNames or a global name\n      while (\n        nameForEmit === 'default' ||\n        usedNames.has(nameForEmit) ||\n        this.globalVariableAnalyzer.hasGlobalName(nameForEmit)\n      ) {\n        nameForEmit = `${idealNameForEmit}_${++suffix}`;\n      }\n      entity.nameForEmit = nameForEmit;\n      usedNames.add(nameForEmit);\n    }\n  }\n\n  private _fetchSymbolMetadata(astSymbol: AstSymbol): void {\n    if (astSymbol.symbolMetadata) {\n      return;\n    }\n\n    // When we solve an astSymbol, then we always also solve all of its parents and all of its declarations.\n    // The parent is solved first.\n    if (astSymbol.parentAstSymbol && astSymbol.parentAstSymbol.symbolMetadata === undefined) {\n      this._fetchSymbolMetadata(astSymbol.parentAstSymbol);\n    }\n\n    // Construct the DeclarationMetadata objects, and detect any ancillary declarations\n    this._calculateDeclarationMetadataForDeclarations(astSymbol);\n\n    // Calculate the ApiItemMetadata objects\n    for (const astDeclaration of astSymbol.astDeclarations) {\n      this._calculateApiItemMetadata(astDeclaration);\n    }\n\n    // The most public effectiveReleaseTag for all declarations\n    let maxEffectiveReleaseTag: ReleaseTag = ReleaseTag.None;\n\n    for (const astDeclaration of astSymbol.astDeclarations) {\n      // We know we solved this above\n      const apiItemMetadata: ApiItemMetadata = astDeclaration.apiItemMetadata as ApiItemMetadata;\n\n      const effectiveReleaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      if (effectiveReleaseTag > maxEffectiveReleaseTag) {\n        maxEffectiveReleaseTag = effectiveReleaseTag;\n      }\n    }\n\n    // Update this last when we're sure no exceptions were thrown\n    astSymbol.symbolMetadata = new SymbolMetadata({\n      maxEffectiveReleaseTag\n    });\n  }\n\n  private _calculateDeclarationMetadataForDeclarations(astSymbol: AstSymbol): void {\n    // Initialize DeclarationMetadata for each declaration\n    for (const astDeclaration of astSymbol.astDeclarations) {\n      if (astDeclaration.declarationMetadata) {\n        throw new InternalError(\n          'AstDeclaration.declarationMetadata is not expected to have been initialized yet'\n        );\n      }\n\n      const metadata: InternalDeclarationMetadata = new InternalDeclarationMetadata();\n      metadata.tsdocParserContext = this._parseTsdocForAstDeclaration(astDeclaration);\n\n      astDeclaration.declarationMetadata = metadata;\n    }\n\n    // Detect ancillary declarations\n    for (const astDeclaration of astSymbol.astDeclarations) {\n      // For a getter/setter pair, make the setter ancillary to the getter\n      if (astDeclaration.declaration.kind === ts.SyntaxKind.SetAccessor) {\n        let foundGetter: boolean = false;\n        for (const getterAstDeclaration of astDeclaration.astSymbol.astDeclarations) {\n          if (getterAstDeclaration.declaration.kind === ts.SyntaxKind.GetAccessor) {\n            // Associate it with the getter\n            this._addAncillaryDeclaration(getterAstDeclaration, astDeclaration);\n\n            foundGetter = true;\n          }\n        }\n\n        if (!foundGetter) {\n          this.messageRouter.addAnalyzerIssue(\n            ExtractorMessageId.MissingGetter,\n            `The property \"${astDeclaration.astSymbol.localName}\" has a setter but no getter.`,\n            astDeclaration\n          );\n        }\n      }\n    }\n  }\n\n  private _addAncillaryDeclaration(\n    mainAstDeclaration: AstDeclaration,\n    ancillaryAstDeclaration: AstDeclaration\n  ): void {\n    const mainMetadata: InternalDeclarationMetadata =\n      mainAstDeclaration.declarationMetadata as InternalDeclarationMetadata;\n    const ancillaryMetadata: InternalDeclarationMetadata =\n      ancillaryAstDeclaration.declarationMetadata as InternalDeclarationMetadata;\n\n    if (mainMetadata.ancillaryDeclarations.indexOf(ancillaryAstDeclaration) >= 0) {\n      return; // already added\n    }\n\n    if (mainAstDeclaration.astSymbol !== ancillaryAstDeclaration.astSymbol) {\n      throw new InternalError(\n        'Invalid call to _addAncillaryDeclaration() because declarations do not' +\n          ' belong to the same symbol'\n      );\n    }\n\n    if (mainMetadata.isAncillary) {\n      throw new InternalError(\n        'Invalid call to _addAncillaryDeclaration() because the target is ancillary itself'\n      );\n    }\n\n    if (ancillaryMetadata.isAncillary) {\n      throw new InternalError(\n        'Invalid call to _addAncillaryDeclaration() because source is already ancillary' +\n          ' to another declaration'\n      );\n    }\n\n    if (mainAstDeclaration.apiItemMetadata || ancillaryAstDeclaration.apiItemMetadata) {\n      throw new InternalError(\n        'Invalid call to _addAncillaryDeclaration() because the API item metadata' +\n          ' has already been constructed'\n      );\n    }\n\n    ancillaryMetadata.isAncillary = true;\n    mainMetadata.ancillaryDeclarations.push(ancillaryAstDeclaration);\n  }\n\n  private _calculateApiItemMetadata(astDeclaration: AstDeclaration): void {\n    const declarationMetadata: InternalDeclarationMetadata =\n      astDeclaration.declarationMetadata as InternalDeclarationMetadata;\n    if (declarationMetadata.isAncillary) {\n      if (astDeclaration.declaration.kind === ts.SyntaxKind.SetAccessor) {\n        if (declarationMetadata.tsdocParserContext) {\n          this.messageRouter.addAnalyzerIssue(\n            ExtractorMessageId.SetterWithDocs,\n            `The doc comment for the property \"${astDeclaration.astSymbol.localName}\"` +\n              ` must appear on the getter, not the setter.`,\n            astDeclaration\n          );\n        }\n      }\n\n      // We never calculate ApiItemMetadata for an ancillary declaration; instead, it is assigned when\n      // the main declaration is processed.\n      return;\n    }\n\n    const options: IApiItemMetadataOptions = {\n      declaredReleaseTag: ReleaseTag.None,\n      effectiveReleaseTag: ReleaseTag.None,\n      isEventProperty: false,\n      isOverride: false,\n      isSealed: false,\n      isVirtual: false,\n      isPreapproved: false,\n      releaseTagSameAsParent: false\n    };\n\n    const parserContext: tsdoc.ParserContext | undefined = declarationMetadata.tsdocParserContext;\n    if (parserContext) {\n      const modifierTagSet: tsdoc.StandardModifierTagSet = parserContext.docComment.modifierTagSet;\n\n      let declaredReleaseTag: ReleaseTag = ReleaseTag.None;\n      let extraReleaseTags: boolean = false;\n\n      if (modifierTagSet.isPublic()) {\n        declaredReleaseTag = ReleaseTag.Public;\n      }\n      if (modifierTagSet.isBeta()) {\n        if (declaredReleaseTag !== ReleaseTag.None) {\n          extraReleaseTags = true;\n        } else {\n          declaredReleaseTag = ReleaseTag.Beta;\n        }\n      }\n      if (modifierTagSet.isAlpha()) {\n        if (declaredReleaseTag !== ReleaseTag.None) {\n          extraReleaseTags = true;\n        } else {\n          declaredReleaseTag = ReleaseTag.Alpha;\n        }\n      }\n      if (modifierTagSet.isInternal()) {\n        if (declaredReleaseTag !== ReleaseTag.None) {\n          extraReleaseTags = true;\n        } else {\n          declaredReleaseTag = ReleaseTag.Internal;\n        }\n      }\n\n      if (extraReleaseTags) {\n        if (!astDeclaration.astSymbol.isExternal) {\n          // for now, don't report errors for external code\n          this.messageRouter.addAnalyzerIssue(\n            ExtractorMessageId.ExtraReleaseTag,\n            'The doc comment should not contain more than one release tag',\n            astDeclaration\n          );\n        }\n      }\n\n      options.declaredReleaseTag = declaredReleaseTag;\n\n      options.isEventProperty = modifierTagSet.isEventProperty();\n      options.isOverride = modifierTagSet.isOverride();\n      options.isSealed = modifierTagSet.isSealed();\n      options.isVirtual = modifierTagSet.isVirtual();\n      const preapprovedTag: tsdoc.TSDocTagDefinition | void =\n        this.extractorConfig.tsdocConfiguration.tryGetTagDefinition('@preapproved');\n\n      if (preapprovedTag && modifierTagSet.hasTag(preapprovedTag)) {\n        // This feature only makes sense for potentially big declarations.\n        switch (astDeclaration.declaration.kind) {\n          case ts.SyntaxKind.ClassDeclaration:\n          case ts.SyntaxKind.EnumDeclaration:\n          case ts.SyntaxKind.InterfaceDeclaration:\n          case ts.SyntaxKind.ModuleDeclaration:\n            if (declaredReleaseTag === ReleaseTag.Internal) {\n              options.isPreapproved = true;\n            } else {\n              this.messageRouter.addAnalyzerIssue(\n                ExtractorMessageId.PreapprovedBadReleaseTag,\n                `The @preapproved tag cannot be applied to \"${astDeclaration.astSymbol.localName}\"` +\n                  ` without an @internal release tag`,\n                astDeclaration\n              );\n            }\n            break;\n          default:\n            this.messageRouter.addAnalyzerIssue(\n              ExtractorMessageId.PreapprovedUnsupportedType,\n              `The @preapproved tag cannot be applied to \"${astDeclaration.astSymbol.localName}\"` +\n                ` because it is not a supported declaration type`,\n              astDeclaration\n            );\n            break;\n        }\n      }\n    }\n\n    // This needs to be set regardless of whether or not a parserContext exists\n    if (astDeclaration.parent) {\n      const parentApiItemMetadata: ApiItemMetadata = this.fetchApiItemMetadata(astDeclaration.parent);\n      options.effectiveReleaseTag =\n        options.declaredReleaseTag === ReleaseTag.None\n          ? parentApiItemMetadata.effectiveReleaseTag\n          : options.declaredReleaseTag;\n\n      options.releaseTagSameAsParent =\n        parentApiItemMetadata.effectiveReleaseTag === options.effectiveReleaseTag;\n    } else {\n      options.effectiveReleaseTag = options.declaredReleaseTag;\n    }\n\n    if (options.effectiveReleaseTag === ReleaseTag.None) {\n      if (!astDeclaration.astSymbol.isExternal) {\n        // for now, don't report errors for external code\n        // Don't report missing release tags for forgotten exports (unless we're including forgotten exports\n        // in either the API report or doc model).\n        const astSymbol: AstSymbol = astDeclaration.astSymbol;\n        const entity: CollectorEntity | undefined = this._entitiesByAstEntity.get(astSymbol.rootAstSymbol);\n        if (\n          entity &&\n          (entity.consumable ||\n            this.extractorConfig.apiReportIncludeForgottenExports ||\n            this.extractorConfig.docModelIncludeForgottenExports)\n        ) {\n          // We also don't report errors for the default export of an entry point, since its doc comment\n          // isn't easy to obtain from the .d.ts file\n          if (astSymbol.rootAstSymbol.localName !== '_default') {\n            this.messageRouter.addAnalyzerIssue(\n              ExtractorMessageId.MissingReleaseTag,\n              `\"${entity.astEntity.localName}\" is part of the package's API, but it is missing ` +\n                `a release tag (@alpha, @beta, @public, or @internal)`,\n              astSymbol\n            );\n          }\n        }\n      }\n\n      options.effectiveReleaseTag = ReleaseTag.Public;\n    }\n\n    const apiItemMetadata: ApiItemMetadata = new ApiItemMetadata(options);\n    if (parserContext) {\n      apiItemMetadata.tsdocComment = parserContext.docComment;\n    }\n\n    astDeclaration.apiItemMetadata = apiItemMetadata;\n\n    // Lastly, share the result with any ancillary declarations\n    for (const ancillaryDeclaration of declarationMetadata.ancillaryDeclarations) {\n      ancillaryDeclaration.apiItemMetadata = apiItemMetadata;\n    }\n  }\n\n  private _parseTsdocForAstDeclaration(astDeclaration: AstDeclaration): tsdoc.ParserContext | undefined {\n    const declaration: ts.Declaration = astDeclaration.declaration;\n    let nodeForComment: ts.Node = declaration;\n\n    if (ts.isVariableDeclaration(declaration)) {\n      // Variable declarations are special because they can be combined into a list.  For example:\n      //\n      // /** A */ export /** B */ const /** C */ x = 1, /** D **/ [ /** E */ y, z] = [3, 4];\n      //\n      // The compiler will only emit comments A and C in the .d.ts file, so in general there isn't a well-defined\n      // way to document these parts.  API Extractor requires you to break them into separate exports like this:\n      //\n      // /** A */ export const x = 1;\n      //\n      // But _getReleaseTagForDeclaration() still receives a node corresponding to \"x\", so we need to walk upwards\n      // and find the containing statement in order for getJSDocCommentRanges() to read the comment that we expect.\n      const statement: ts.VariableStatement | undefined = TypeScriptHelpers.findFirstParent(\n        declaration,\n        ts.SyntaxKind.VariableStatement\n      ) as ts.VariableStatement | undefined;\n      if (statement !== undefined) {\n        // For a compound declaration, fall back to looking for C instead of A\n        if (statement.declarationList.declarations.length === 1) {\n          nodeForComment = statement;\n        }\n      }\n    }\n\n    const sourceFileText: string = declaration.getSourceFile().text;\n    const ranges: ts.CommentRange[] =\n      TypeScriptInternals.getJSDocCommentRanges(nodeForComment, sourceFileText) || [];\n\n    if (ranges.length === 0) {\n      return undefined;\n    }\n\n    // We use the JSDoc comment block that is closest to the definition, i.e.\n    // the last one preceding it\n    const range: ts.TextRange = ranges[ranges.length - 1];\n\n    const tsdocTextRange: tsdoc.TextRange = tsdoc.TextRange.fromStringRange(\n      sourceFileText,\n      range.pos,\n      range.end\n    );\n\n    const parserContext: tsdoc.ParserContext = this._tsdocParser.parseRange(tsdocTextRange);\n\n    this.messageRouter.addTsdocMessages(parserContext, declaration.getSourceFile(), astDeclaration);\n\n    // We delete the @privateRemarks block as early as possible, to ensure that it never leaks through\n    // into one of the output files.\n    parserContext.docComment.privateRemarks = undefined;\n\n    return parserContext;\n  }\n\n  private _collectReferenceDirectives(astEntity: AstEntity): void {\n    if (astEntity instanceof AstSymbol) {\n      const sourceFiles: ts.SourceFile[] = astEntity.astDeclarations.map((astDeclaration) =>\n        astDeclaration.declaration.getSourceFile()\n      );\n      return this._collectReferenceDirectivesFromSourceFiles(sourceFiles);\n    }\n\n    if (astEntity instanceof AstNamespaceImport) {\n      const sourceFiles: ts.SourceFile[] = [astEntity.astModule.sourceFile];\n      return this._collectReferenceDirectivesFromSourceFiles(sourceFiles);\n    }\n  }\n\n  private _collectReferenceDirectivesFromSourceFiles(sourceFiles: ts.SourceFile[]): void {\n    const seenFilenames: Set<string> = new Set<string>();\n\n    for (const sourceFile of sourceFiles) {\n      if (sourceFile && sourceFile.fileName) {\n        if (!seenFilenames.has(sourceFile.fileName)) {\n          seenFilenames.add(sourceFile.fileName);\n\n          for (const typeReferenceDirective of sourceFile.typeReferenceDirectives) {\n            const name: string = sourceFile.text.substring(\n              typeReferenceDirective.pos,\n              typeReferenceDirective.end\n            );\n            this._dtsTypeReferenceDirectives.add(name);\n          }\n\n          for (const libReferenceDirective of sourceFile.libReferenceDirectives) {\n            const name: string = sourceFile.text.substring(\n              libReferenceDirective.pos,\n              libReferenceDirective.end\n            );\n            this._dtsLibReferenceDirectives.add(name);\n          }\n        }\n      }\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"Collector.js","sourceRoot":"","sources":["../../src/collector/Collector.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,+CAAiC;AACjC,wDAA0C;AAC1C,oEAMsC;AACtC,wEAA4D;AAI5D,uDAAoD;AACpD,+DAA4D;AAG5D,qDAAkD;AAElD,qEAAkE;AAClE,qDAAkD;AAClD,kEAA+D;AAC/D,+DAA8F;AAC9F,uDAAkF;AAClF,qDAAkD;AAClD,yEAAoG;AAEpG,2EAAwE;AACxE,4DAAyD;AACzD,uEAAoE;AACpE,qDAAkD;AAwBlD;;;;;GAKG;AACH,MAAa,SAAS;IA0CpB,YAAmB,OAA0B;QAf5B,cAAS,GAAsB,EAAE,CAAC;QAClC,yBAAoB,GAAoC,IAAI,GAAG,EAG7E,CAAC;QACa,sBAAiB,GAAoC,IAAI,GAAG,EAA8B,CAAC;QAE3F,qCAAgC,GAAa,EAAE,CAAC;QAEhD,gCAA2B,GAAgB,IAAI,GAAG,EAAU,CAAC;QAC7D,+BAA0B,GAAgB,IAAI,GAAG,EAAU,CAAC;QAM3E,IAAI,CAAC,iBAAiB,GAAG,IAAI,qCAAiB,EAAE,CAAC;QAEjD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,OAAO,CAAC;QAChC,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC;QAC/C,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,YAAY,CAAC;QAEzC,MAAM,oBAAoB,GAA8B,OAAO,CAAC,OAAO,CAAC,aAAa,CACnF,IAAI,CAAC,eAAe,CAAC,sBAAsB,CAC5C,CAAC;QAEF,IAAI,CAAC,oBAAoB,EAAE;YACzB,MAAM,IAAI,KAAK,CAAC,uBAAuB,GAAG,IAAI,CAAC,eAAe,CAAC,sBAAsB,CAAC,CAAC;SACxF;QAED,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,aAAa,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE;YAC5E,gFAAgF;YAChF,+DAA+D;YAC/D,MAAM,IAAI,KAAK,CAAC,mEAAmE,CAAC,CAAC;SACtF;QAED,IAAI,CAAC,cAAc,GAAG,IAAI,+BAAc,CAAC;YACvC,aAAa,EAAE,IAAI,CAAC,eAAe,CAAC,aAAa;YACjD,WAAW,EAAE,IAAI,CAAC,eAAe,CAAC,WAAW;YAC7C,oBAAoB;SACrB,CAAC,CAAC;QAEH,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;QAE3C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;QAC/B,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,OAAO,CAAC,cAAc,EAAE,CAAC;QACpD,IAAI,CAAC,sBAAsB,GAAG,yCAAmB,CAAC,yBAAyB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAE1F,IAAI,CAAC,YAAY,GAAG,IAAI,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,CAAC;QAEnF,mFAAmF;QACnF,IAAI,CAAC,mBAAmB,GAAG,SAAS,CAAC,8BAA8B,CACjE,IAAI,CAAC,eAAe,CAAC,eAAe,EACpC,IAAI,CAAC,eAAe,CAAC,WAAW,CACjC,CAAC;QAEF,IAAI,CAAC,cAAc,GAAG,IAAI,+BAAc,CACtC,IAAI,CAAC,OAAO,EACZ,IAAI,CAAC,WAAW,EAChB,IAAI,CAAC,iBAAiB,EACtB,IAAI,CAAC,mBAAmB,EACxB,IAAI,CAAC,aAAa,CACnB,CAAC;QACF,IAAI,CAAC,oBAAoB,GAAG,IAAI,2CAAoB,CAAC,IAAI,CAAC,CAAC;QAE3D,IAAI,CAAC,mCAAmC,GAAG,IAAI,GAAG,EAA0B,CAAC;IAC/E,CAAC;IAED;;;;;;OAMG;IACK,MAAM,CAAC,8BAA8B,CAC3C,eAAyB,EACzB,WAAyC;;QAEzC,sCAAsC;QACtC,MAAM,YAAY,GAAgB,IAAI,GAAG,EAAU,CAAC;QAEpD,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE;YAChC,4EAA4E;YAC5E,uBAAuB;YACvB,OAAO,YAAY,CAAC;SACrB;QAED,IAAI,WAAW,KAAK,SAAS,EAAE;YAC7B,6EAA6E;YAC7E,uBAAuB;YACvB,OAAO,YAAY,CAAC;SACrB;QAED,MAAM,cAAc,GAAa,MAAM,CAAC,IAAI,CAAC,MAAA,WAAW,CAAC,YAAY,mCAAI,EAAE,CAAC,CAAC;QAC7E,MAAM,iBAAiB,GAAa,MAAM,CAAC,IAAI,CAAC,MAAA,WAAW,CAAC,eAAe,mCAAI,EAAE,CAAC,CAAC;QAEnF,MAAM,eAAe,GAAa,cAAc,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;QAE3E,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE;YAChC,gGAAgG;YAChG,uBAAuB;YACvB,OAAO,YAAY,CAAC;SACrB;QAED,KAAK,MAAM,oBAAoB,IAAI,eAAe,EAAE;YAClD,IAAI,+BAAW,CAAC,WAAW,CAAC,oBAAoB,CAAC,EAAE;gBACjD,iEAAiE;gBACjE,IAAI,eAAe,CAAC,QAAQ,CAAC,oBAAoB,CAAC,EAAE;oBAClD,YAAY,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC;iBACxC;qBAAM;oBACL,OAAO,CAAC,IAAI,CACV,8FAA8F,oBAAoB,IAAI,CACvH,CAAC;iBACH;aACF;iBAAM;gBACL,iFAAiF;gBACjF,MAAM,MAAM,GAAW,IAAI,MAAM,CAAC,oBAAoB,CAAC,CAAC;gBACxD,MAAM,OAAO,GAAa,eAAe,CAAC,MAAM,CAAC,CAAC,cAAc,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;gBAClG,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;oBACxB,OAAO,CAAC,IAAI,CACV,gFAAgF,oBAAoB,IAAI,CACzG,CAAC;iBACH;qBAAM;oBACL,OAAO,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;iBACrD;aACF;SACF;QACD,OAAO,YAAY,CAAC;IACtB,CAAC;IAED;;;;;;OAMG;IACH,IAAW,0BAA0B;QACnC,OAAO,IAAI,CAAC,2BAA2B,CAAC;IAC1C,CAAC;IAED;;;;;;OAMG;IACH,IAAW,yBAAyB;QAClC,OAAO,IAAI,CAAC,0BAA0B,CAAC;IACzC,CAAC;IAED,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC;IAED;;;OAGG;IACH,IAAW,+BAA+B;QACxC,OAAO,IAAI,CAAC,gCAAgC,CAAC;IAC/C,CAAC;IAED;;OAEG;IACI,OAAO;QACZ,IAAI,IAAI,CAAC,cAAc,EAAE;YACvB,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;SACpE;QAED,iGAAiG;QACjG,4FAA4F;QAC5F,4DAA4D;QAC5D,KAAK,MAAM,UAAU,IAAI,IAAI,CAAC,QAAQ,CAAC,sBAAsB,EAAE,EAAE;YAC/D,IAAI,CAAC,aAAa,CAAC,qBAAqB,CAAC,UAAU,CAAC,CAAC;SACtD;QAED,MAAM,WAAW,GAA6B,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,CAAC;QAE5E,IAAI,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE;YACtC,IAAI,CAAC,aAAa,CAAC,mBAAmB,CAAC,gBAAgB,CAAC,CAAC;YACzD,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,OAAO,CAAC,gBAAgB,EAAE,EAAE;gBACtD,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;aAC5C;YACD,IAAI,CAAC,aAAa,CAAC,mBAAmB,EAAE,CAAC;YAEzC,IAAI,CAAC,aAAa,CAAC,mBAAmB,CAAC,4BAA4B,CAAC,CAAC;YACrE,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;gBACpC,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;aACvD;YACD,IAAI,CAAC,aAAa,CAAC,mBAAmB,EAAE,CAAC;SAC1C;QAED,2GAA2G;QAC3G,+EAA+E;QAC/E,iGAAiG;QACjG,MAAM,aAAa,GAA8B,WAAW,CAAC,IAAI,CAC/D,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,CAAC,CAAC,iCAAe,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CACjE,CAAC;QACF,IAAI,aAAa,EAAE;YACjB,IAAI,CAAC,aAAa,CAAC,2BAA2B,yEAE5C,wGAAwG;gBACtG,gEAAgE,EAClE,aAAa,EACb,CAAC,CACF,CAAC;SACH;QAED,wBAAwB;QACxB,MAAM,oBAAoB,GAAkB,IAAI,CAAC,cAAc,CAAC,oBAAoB,CAAC;QAErF,MAAM,aAAa,GACjB,IAAI,CAAC,cAAc,CAAC,gCAAgC,CAAC,oBAAoB,CAAC,CAAC;QAC7E,IAAI,CAAC,cAAc,GAAG,aAAa,CAAC;QAEpC,MAAM,0BAA0B,GAA6B,qCAAiB,CAAC,mBAAmB,CAChG,oBAAoB,EACpB,IAAI,CACL,CAAC;QAEF,IAAI,0BAA0B,EAAE;YAC9B,MAAM,KAAK,GAAoB,KAAK,CAAC,SAAS,CAAC,eAAe,CAC5D,oBAAoB,CAAC,IAAI,EACzB,0BAA0B,CAAC,GAAG,EAC9B,0BAA0B,CAAC,GAAG,CAC/B,CAAC;YAEF,IAAI,CAAC,cAAc,CAAC,kBAAkB,GAAG,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YAE7E,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,kBAAkB,EAAE,oBAAoB,CAAC,CAAC;YAElG,IAAI,CAAC,cAAc,CAAC,YAAY,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAmB,CAAC,UAAU,CAAC;SACvF;QAED,MAAM,mBAAmB,GACvB,IAAI,CAAC,cAAc,CAAC,wBAAwB,CAAC,aAAa,CAAC,CAAC;QAE9D,sDAAsD;QACtD,MAAM,oBAAoB,GAAgB,EAAE,CAAC;QAC7C,KAAK,MAAM,CAAC,UAAU,EAAE,SAAS,CAAC,IAAI,mBAAmB,CAAC,qBAAqB,EAAE;YAC/E,IAAI,CAAC,sBAAsB,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;YACnD,oBAAoB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;SACtC;QAED,kFAAkF;QAClF,uBAAuB;QACvB,MAAM,sBAAsB,GAAmB,IAAI,GAAG,EAAa,CAAC;QACpE,KAAK,MAAM,SAAS,IAAI,oBAAoB,EAAE;YAC5C,IAAI,CAAC,0BAA0B,CAAC,SAAS,EAAE,sBAAsB,CAAC,CAAC;YACnE,IAAI,SAAS,YAAY,qBAAS,EAAE;gBAClC,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;aACrC;SACF;QAED,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAExB,KAAK,MAAM,0BAA0B,IAAI,mBAAmB,CAAC,2BAA2B,EAAE;YACxF,IAAI,0BAA0B,CAAC,kBAAkB,KAAK,SAAS,EAAE;gBAC/D,IAAI,CAAC,gCAAgC,CAAC,IAAI,CAAC,0BAA0B,CAAC,kBAAkB,CAAC,CAAC;aAC3F;SACF;QAED,wBAAI,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC,CAAC;QACnD,wBAAI,CAAC,OAAO,CAAC,IAAI,CAAC,2BAA2B,CAAC,CAAC;QAC/C,wBAAI,CAAC,OAAO,CAAC,IAAI,CAAC,0BAA0B,CAAC,CAAC;QAC9C,IAAI,CAAC,gCAAgC,CAAC,IAAI,EAAE,CAAC;IAC/C,CAAC;IAED;;;;;OAKG;IACI,mBAAmB,CAAC,UAA6C;QACtE,MAAM,SAAS,GAA0B,IAAI,CAAC,cAAc,CAAC,mBAAmB,CAAC,UAAU,CAAC,CAAC;QAC7F,IAAI,SAAS,EAAE;YACb,OAAO,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;SACjD;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAED;;;OAGG;IACI,qBAAqB,CAAC,MAAiB;QAC5C,OAAO,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IAC5C,CAAC;IAED;;OAEG;IACI,qBAAqB,CAAC,SAAoB;QAC/C,OAAO,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;IAClD,CAAC;IAEM,mBAAmB,CAAC,SAAoB;QAC7C,IAAI,SAAS,CAAC,cAAc,KAAK,SAAS,EAAE;YAC1C,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC;SACtC;QACD,OAAO,SAAS,CAAC,cAAgC,CAAC;IACpD,CAAC;IAEM,wBAAwB,CAAC,cAA8B;QAC5D,IAAI,cAAc,CAAC,mBAAmB,KAAK,SAAS,EAAE;YACpD,wEAAwE;YACxE,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;SACrD;QACD,OAAO,cAAc,CAAC,mBAA0C,CAAC;IACnE,CAAC;IAEM,oBAAoB,CAAC,cAA8B;QACxD,IAAI,cAAc,CAAC,eAAe,KAAK,SAAS,EAAE;YAChD,oEAAoE;YACpE,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;SACrD;QACD,OAAO,cAAc,CAAC,eAAkC,CAAC;IAC3D,CAAC;IAEM,4BAA4B,CAAC,SAAoB;QACtD,IAAI,SAAS,YAAY,qBAAS,EAAE;YAClC,OAAO,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;SAC5C;QACD,IAAI,SAAS,YAAY,qBAAS,EAAE;YAClC,IAAI,SAAS,CAAC,SAAS,EAAE;gBACvB,OAAO,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;aACtD;SACF;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAEM,sBAAsB,CAAC,cAA8B;QAC1D,MAAM,mBAAmB,GAAwB,IAAI,CAAC,wBAAwB,CAAC,cAAc,CAAC,CAAC;QAC/F,OAAO,mBAAmB,CAAC,WAAW,CAAC;IACzC,CAAC;IAEM,2BAA2B,CAAC,SAAoB;QACrD,MAAM,MAAM,GAAqB,EAAE,CAAC;QACpC,KAAK,MAAM,cAAc,IAAI,SAAS,CAAC,eAAe,EAAE;YACtD,MAAM,mBAAmB,GAAwB,IAAI,CAAC,wBAAwB,CAAC,cAAc,CAAC,CAAC;YAC/F,IAAI,CAAC,mBAAmB,CAAC,WAAW,EAAE;gBACpC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;aAC7B;SACF;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,4BAA4B,CAAC,UAA8B;QACvE,IAAI,CAAC,UAAU;YAAE,OAAO,EAAE,CAAC;QAE3B,IAAI,KAAe,CAAC;QAEpB,IAAI,UAAU,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YACzB,MAAM,iBAAiB,GAAW,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YACvD,KAAK,GAAG,CAAC,iBAAiB,CAAC,WAAW,EAAE,EAAE,GAAG,EAAE,iBAAiB,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;SAC7E;aAAM;YACL,KAAK,GAAG,CAAC,UAAU,CAAC,WAAW,EAAE,EAAE,GAAG,EAAE,UAAU,CAAC,CAAC;SACrD;QAED,OAAO,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACxB,CAAC;IAED;;;OAGG;IACI,gBAAgB,CAAC,cAA8B;QACpD,MAAM,eAAe,GAAkC,cAAc,CAAC,SAAS,CAAC,eAAe,CAAC;QAChG,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE;YAChC,OAAO,CAAC,CAAC,CAAC,eAAe;SAC1B;QAED,IAAI,aAAa,GAAuB,IAAI,CAAC,mCAAmC,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;QAErG,IAAI,aAAa,KAAK,SAAS,EAAE;YAC/B,8DAA8D;YAC9D,IAAI,SAAS,GAAW,CAAC,CAAC;YAC1B,KAAK,MAAM,KAAK,IAAI,eAAe,EAAE;gBACnC,sGAAsG;gBACtG,kBAAkB;gBAClB,IAAI,KAAK,CAAC,WAAW,CAAC,IAAI,KAAK,cAAc,CAAC,WAAW,CAAC,IAAI,EAAE;oBAC9D,IAAI,CAAC,mCAAmC,CAAC,GAAG,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;oBAC/D,EAAE,SAAS,CAAC;iBACb;aACF;YACD,aAAa,GAAG,IAAI,CAAC,mCAAmC,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;SAC9E;QAED,IAAI,aAAa,KAAK,SAAS,EAAE;YAC/B,2BAA2B;YAC3B,MAAM,IAAI,iCAAa,CAAC,kDAAkD,CAAC,CAAC;SAC7E;QAED,OAAO,aAAa,CAAC;IACvB,CAAC;IAEO,sBAAsB,CAC5B,SAAoB,EACpB,UAAmB,EACnB,MAAwB;QAExB,IAAI,MAAM,GAAgC,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAEnF,IAAI,CAAC,MAAM,EAAE;YACX,MAAM,GAAG,IAAI,iCAAe,CAAC,SAAS,CAAC,CAAC;YAExC,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;YACjD,IAAI,SAAS,YAAY,qBAAS,EAAE;gBAClC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,CAAC,cAAc,EAAE,MAAM,CAAC,CAAC;aAC9D;iBAAM,IAAI,SAAS,YAAY,uCAAkB,EAAE;gBAClD,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;aACtD;YACD,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC5B,IAAI,CAAC,2BAA2B,CAAC,SAAS,CAAC,CAAC;SAC7C;QAED,IAAI,UAAU,EAAE;YACd,IAAI,MAAM,EAAE;gBACV,MAAM,CAAC,kBAAkB,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;aAC/C;iBAAM;gBACL,MAAM,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;aAClC;SACF;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAEO,0BAA0B,CAAC,SAAoB,EAAE,sBAAsC;QAC7F,IAAI,sBAAsB,CAAC,GAAG,CAAC,SAAS,CAAC;YAAE,OAAO;QAClD,sBAAsB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAEtC,IAAI,SAAS,YAAY,qBAAS,EAAE;YAClC,SAAS,CAAC,2BAA2B,CAAC,CAAC,cAA8B,EAAE,EAAE;gBACvE,KAAK,MAAM,mBAAmB,IAAI,cAAc,CAAC,qBAAqB,EAAE;oBACtE,IAAI,mBAAmB,YAAY,qBAAS,EAAE;wBAC5C,wFAAwF;wBACxF,wFAAwF;wBACxF,6CAA6C;wBAC7C,IAAI,mBAAmB,CAAC,eAAe,KAAK,SAAS,EAAE;4BACrD,IAAI,CAAC,sBAAsB,CAAC,mBAAmB,CAAC,CAAC;yBAClD;qBACF;yBAAM;wBACL,IAAI,CAAC,sBAAsB,CAAC,mBAAmB,CAAC,CAAC;qBAClD;oBAED,IAAI,CAAC,0BAA0B,CAAC,mBAAmB,EAAE,sBAAsB,CAAC,CAAC;iBAC9E;YACH,CAAC,CAAC,CAAC;SACJ;QAED,IAAI,SAAS,YAAY,uCAAkB,EAAE;YAC3C,MAAM,mBAAmB,GAAwB,SAAS,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;YAC1F,MAAM,YAAY,GAAgC,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YAC3F,IAAI,CAAC,YAAY,EAAE;gBACjB,2FAA2F;gBAC3F,MAAM,IAAI,iCAAa,CACrB,6EAA6E,SAAS,CAAC,aAAa,GAAG,CACxG,CAAC;aACH;YAED,KAAK,MAAM,CAAC,eAAe,EAAE,cAAc,CAAC,IAAI,mBAAmB,CAAC,qBAAqB,EAAE;gBACzF,sFAAsF;gBACtF,IAAI,CAAC,sBAAsB,CAAC,cAAc,EAAE,eAAe,EAAE,YAAY,CAAC,CAAC;gBAC3E,IAAI,CAAC,0BAA0B,CAAC,cAAc,EAAE,sBAAsB,CAAC,CAAC;aACzE;SACF;IACH,CAAC;IAED;;OAEG;IACK,gBAAgB;QACtB,gEAAgE;QAChE,EAAE;QACF,aAAa;QACb,sGAAsG;QACtG,uBAAuB;QACvB,EAAE;QACF,aAAa;QACb,iGAAiG;QACjG,uBAAuB;QACvB,uBAAuB;QACvB,EAAE;QACF,aAAa;QACb,4FAA4F;QAC5F,uBAAuB;QACvB,uBAAuB;QACvB,+CAA+C;QAC/C,uBAAuB;QAEvB,4EAA4E;QAC5E,MAAM,SAAS,GAAgB,IAAI,GAAG,EAAU,CAAC;QAEjD,mFAAmF;QACnF,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,SAAS,EAAE;YACnC,KAAK,MAAM,UAAU,IAAI,MAAM,CAAC,WAAW,EAAE;gBAC3C,IAAI,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;oBAC7B,4BAA4B;oBAC5B,MAAM,IAAI,iCAAa,CAAC,oDAAoD,UAAU,GAAG,CAAC,CAAC;iBAC5F;gBACD,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;aAC3B;SACF;QAED,mDAAmD;QACnD,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,SAAS,EAAE;YACnC,iDAAiD;YACjD,IAAI,gBAAwB,CAAC;YAE7B,4EAA4E;YAC5E,IACE,MAAM,CAAC,gBAAgB,KAAK,SAAS;gBACrC,MAAM,CAAC,gBAAgB,KAAK,EAAE,CAAC,kBAAkB,CAAC,OAAO,EACzD;gBACA,gBAAgB,GAAG,MAAM,CAAC,gBAAgB,CAAC;aAC5C;iBAAM;gBACL,+BAA+B;gBAC/B,gBAAgB,GAAG,MAAM,CAAC,SAAS,CAAC,SAAS,CAAC;aAC/C;YAED,IAAI,gBAAgB,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;gBAClC,gFAAgF;gBAChF,gBAAgB,GAAG,gBAAgB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;aACnD;YAED,uGAAuG;YACvG,IAAI,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC,gBAAgB,CAAC,EAAE;gBAC5C,+EAA+E;gBAC/E,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,aAAa,CAAC,gBAAgB,CAAC,EAAE;oBAChE,4FAA4F;oBAC5F,IAAI,gBAAgB,KAAK,SAAS,EAAE;wBAClC,MAAM,CAAC,WAAW,GAAG,gBAAgB,CAAC;wBACtC,SAAS;qBACV;iBACF;aACF;YAED,mDAAmD;YACnD,IAAI,MAAM,GAAW,CAAC,CAAC;YACvB,IAAI,WAAW,GAAW,gBAAgB,CAAC;YAE3C,sEAAsE;YACtE,OACE,WAAW,KAAK,SAAS;gBACzB,SAAS,CAAC,GAAG,CAAC,WAAW,CAAC;gBAC1B,IAAI,CAAC,sBAAsB,CAAC,aAAa,CAAC,WAAW,CAAC,EACtD;gBACA,WAAW,GAAG,GAAG,gBAAgB,IAAI,EAAE,MAAM,EAAE,CAAC;aACjD;YACD,MAAM,CAAC,WAAW,GAAG,WAAW,CAAC;YACjC,SAAS,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;SAC5B;IACH,CAAC;IAEO,oBAAoB,CAAC,SAAoB;QAC/C,IAAI,SAAS,CAAC,cAAc,EAAE;YAC5B,OAAO;SACR;QAED,wGAAwG;QACxG,8BAA8B;QAC9B,IAAI,SAAS,CAAC,eAAe,IAAI,SAAS,CAAC,eAAe,CAAC,cAAc,KAAK,SAAS,EAAE;YACvF,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;SACtD;QAED,mFAAmF;QACnF,IAAI,CAAC,4CAA4C,CAAC,SAAS,CAAC,CAAC;QAE7D,wCAAwC;QACxC,KAAK,MAAM,cAAc,IAAI,SAAS,CAAC,eAAe,EAAE;YACtD,IAAI,CAAC,yBAAyB,CAAC,cAAc,CAAC,CAAC;SAChD;QAED,2DAA2D;QAC3D,IAAI,sBAAsB,GAAe,gCAAU,CAAC,IAAI,CAAC;QAEzD,KAAK,MAAM,cAAc,IAAI,SAAS,CAAC,eAAe,EAAE;YACtD,+BAA+B;YAC/B,MAAM,eAAe,GAAoB,cAAc,CAAC,eAAkC,CAAC;YAE3F,MAAM,mBAAmB,GAAe,eAAe,CAAC,mBAAmB,CAAC;YAE5E,IAAI,mBAAmB,GAAG,sBAAsB,EAAE;gBAChD,sBAAsB,GAAG,mBAAmB,CAAC;aAC9C;SACF;QAED,6DAA6D;QAC7D,SAAS,CAAC,cAAc,GAAG,IAAI,+BAAc,CAAC;YAC5C,sBAAsB;SACvB,CAAC,CAAC;IACL,CAAC;IAEO,4CAA4C,CAAC,SAAoB;QACvE,sDAAsD;QACtD,KAAK,MAAM,cAAc,IAAI,SAAS,CAAC,eAAe,EAAE;YACtD,IAAI,cAAc,CAAC,mBAAmB,EAAE;gBACtC,MAAM,IAAI,iCAAa,CACrB,iFAAiF,CAClF,CAAC;aACH;YAED,MAAM,QAAQ,GAAgC,IAAI,iDAA2B,EAAE,CAAC;YAChF,QAAQ,CAAC,kBAAkB,GAAG,IAAI,CAAC,4BAA4B,CAAC,cAAc,CAAC,CAAC;YAEhF,cAAc,CAAC,mBAAmB,GAAG,QAAQ,CAAC;SAC/C;QAED,gCAAgC;QAChC,KAAK,MAAM,cAAc,IAAI,SAAS,CAAC,eAAe,EAAE;YACtD,oEAAoE;YACpE,IAAI,cAAc,CAAC,WAAW,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW,EAAE;gBACjE,IAAI,WAAW,GAAY,KAAK,CAAC;gBACjC,KAAK,MAAM,oBAAoB,IAAI,cAAc,CAAC,SAAS,CAAC,eAAe,EAAE;oBAC3E,IAAI,oBAAoB,CAAC,WAAW,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW,EAAE;wBACvE,+BAA+B;wBAC/B,IAAI,CAAC,wBAAwB,CAAC,oBAAoB,EAAE,cAAc,CAAC,CAAC;wBAEpE,WAAW,GAAG,IAAI,CAAC;qBACpB;iBACF;gBAED,IAAI,CAAC,WAAW,EAAE;oBAChB,IAAI,CAAC,aAAa,CAAC,gBAAgB,6DAEjC,iBAAiB,cAAc,CAAC,SAAS,CAAC,SAAS,+BAA+B,EAClF,cAAc,CACf,CAAC;iBACH;aACF;SACF;IACH,CAAC;IAEO,wBAAwB,CAC9B,kBAAkC,EAClC,uBAAuC;QAEvC,MAAM,YAAY,GAChB,kBAAkB,CAAC,mBAAkD,CAAC;QACxE,MAAM,iBAAiB,GACrB,uBAAuB,CAAC,mBAAkD,CAAC;QAE7E,IAAI,YAAY,CAAC,qBAAqB,CAAC,OAAO,CAAC,uBAAuB,CAAC,IAAI,CAAC,EAAE;YAC5E,OAAO,CAAC,gBAAgB;SACzB;QAED,IAAI,kBAAkB,CAAC,SAAS,KAAK,uBAAuB,CAAC,SAAS,EAAE;YACtE,MAAM,IAAI,iCAAa,CACrB,wEAAwE;gBACtE,4BAA4B,CAC/B,CAAC;SACH;QAED,IAAI,YAAY,CAAC,WAAW,EAAE;YAC5B,MAAM,IAAI,iCAAa,CACrB,mFAAmF,CACpF,CAAC;SACH;QAED,IAAI,iBAAiB,CAAC,WAAW,EAAE;YACjC,MAAM,IAAI,iCAAa,CACrB,gFAAgF;gBAC9E,yBAAyB,CAC5B,CAAC;SACH;QAED,IAAI,kBAAkB,CAAC,eAAe,IAAI,uBAAuB,CAAC,eAAe,EAAE;YACjF,MAAM,IAAI,iCAAa,CACrB,0EAA0E;gBACxE,+BAA+B,CAClC,CAAC;SACH;QAED,iBAAiB,CAAC,WAAW,GAAG,IAAI,CAAC;QACrC,YAAY,CAAC,qBAAqB,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC;IACnE,CAAC;IAEO,yBAAyB,CAAC,cAA8B;QAC9D,MAAM,mBAAmB,GACvB,cAAc,CAAC,mBAAkD,CAAC;QACpE,IAAI,mBAAmB,CAAC,WAAW,EAAE;YACnC,IAAI,cAAc,CAAC,WAAW,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW,EAAE;gBACjE,IAAI,mBAAmB,CAAC,kBAAkB,EAAE;oBAC1C,IAAI,CAAC,aAAa,CAAC,gBAAgB,gEAEjC,qCAAqC,cAAc,CAAC,SAAS,CAAC,SAAS,GAAG;wBACxE,6CAA6C,EAC/C,cAAc,CACf,CAAC;iBACH;aACF;YAED,gGAAgG;YAChG,qCAAqC;YACrC,OAAO;SACR;QAED,MAAM,OAAO,GAA4B;YACvC,kBAAkB,EAAE,gCAAU,CAAC,IAAI;YACnC,mBAAmB,EAAE,gCAAU,CAAC,IAAI;YACpC,eAAe,EAAE,KAAK;YACtB,UAAU,EAAE,KAAK;YACjB,QAAQ,EAAE,KAAK;YACf,SAAS,EAAE,KAAK;YAChB,aAAa,EAAE,KAAK;YACpB,sBAAsB,EAAE,KAAK;SAC9B,CAAC;QAEF,MAAM,aAAa,GAAoC,mBAAmB,CAAC,kBAAkB,CAAC;QAC9F,IAAI,aAAa,EAAE;YACjB,MAAM,cAAc,GAAiC,aAAa,CAAC,UAAU,CAAC,cAAc,CAAC;YAE7F,IAAI,kBAAkB,GAAe,gCAAU,CAAC,IAAI,CAAC;YACrD,IAAI,gBAAgB,GAAY,KAAK,CAAC;YAEtC,IAAI,cAAc,CAAC,QAAQ,EAAE,EAAE;gBAC7B,kBAAkB,GAAG,gCAAU,CAAC,MAAM,CAAC;aACxC;YACD,IAAI,cAAc,CAAC,MAAM,EAAE,EAAE;gBAC3B,IAAI,kBAAkB,KAAK,gCAAU,CAAC,IAAI,EAAE;oBAC1C,gBAAgB,GAAG,IAAI,CAAC;iBACzB;qBAAM;oBACL,kBAAkB,GAAG,gCAAU,CAAC,IAAI,CAAC;iBACtC;aACF;YACD,IAAI,cAAc,CAAC,OAAO,EAAE,EAAE;gBAC5B,IAAI,kBAAkB,KAAK,gCAAU,CAAC,IAAI,EAAE;oBAC1C,gBAAgB,GAAG,IAAI,CAAC;iBACzB;qBAAM;oBACL,kBAAkB,GAAG,gCAAU,CAAC,KAAK,CAAC;iBACvC;aACF;YACD,IAAI,cAAc,CAAC,UAAU,EAAE,EAAE;gBAC/B,IAAI,kBAAkB,KAAK,gCAAU,CAAC,IAAI,EAAE;oBAC1C,gBAAgB,GAAG,IAAI,CAAC;iBACzB;qBAAM;oBACL,kBAAkB,GAAG,gCAAU,CAAC,QAAQ,CAAC;iBAC1C;aACF;YAED,IAAI,gBAAgB,EAAE;gBACpB,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,UAAU,EAAE;oBACxC,iDAAiD;oBACjD,IAAI,CAAC,aAAa,CAAC,gBAAgB,kEAEjC,8DAA8D,EAC9D,cAAc,CACf,CAAC;iBACH;aACF;YAED,OAAO,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;YAEhD,OAAO,CAAC,eAAe,GAAG,cAAc,CAAC,eAAe,EAAE,CAAC;YAC3D,OAAO,CAAC,UAAU,GAAG,cAAc,CAAC,UAAU,EAAE,CAAC;YACjD,OAAO,CAAC,QAAQ,GAAG,cAAc,CAAC,QAAQ,EAAE,CAAC;YAC7C,OAAO,CAAC,SAAS,GAAG,cAAc,CAAC,SAAS,EAAE,CAAC;YAC/C,MAAM,cAAc,GAClB,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,mBAAmB,CAAC,cAAc,CAAC,CAAC;YAE9E,IAAI,cAAc,IAAI,cAAc,CAAC,MAAM,CAAC,cAAc,CAAC,EAAE;gBAC3D,kEAAkE;gBAClE,QAAQ,cAAc,CAAC,WAAW,CAAC,IAAI,EAAE;oBACvC,KAAK,EAAE,CAAC,UAAU,CAAC,gBAAgB,CAAC;oBACpC,KAAK,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC;oBACnC,KAAK,EAAE,CAAC,UAAU,CAAC,oBAAoB,CAAC;oBACxC,KAAK,EAAE,CAAC,UAAU,CAAC,iBAAiB;wBAClC,IAAI,kBAAkB,KAAK,gCAAU,CAAC,QAAQ,EAAE;4BAC9C,OAAO,CAAC,aAAa,GAAG,IAAI,CAAC;yBAC9B;6BAAM;4BACL,IAAI,CAAC,aAAa,CAAC,gBAAgB,qFAEjC,8CAA8C,cAAc,CAAC,SAAS,CAAC,SAAS,GAAG;gCACjF,mCAAmC,EACrC,cAAc,CACf,CAAC;yBACH;wBACD,MAAM;oBACR;wBACE,IAAI,CAAC,aAAa,CAAC,gBAAgB,wFAEjC,8CAA8C,cAAc,CAAC,SAAS,CAAC,SAAS,GAAG;4BACjF,iDAAiD,EACnD,cAAc,CACf,CAAC;wBACF,MAAM;iBACT;aACF;SACF;QAED,2EAA2E;QAC3E,IAAI,cAAc,CAAC,MAAM,EAAE;YACzB,MAAM,qBAAqB,GAAoB,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;YAChG,OAAO,CAAC,mBAAmB;gBACzB,OAAO,CAAC,kBAAkB,KAAK,gCAAU,CAAC,IAAI;oBAC5C,CAAC,CAAC,qBAAqB,CAAC,mBAAmB;oBAC3C,CAAC,CAAC,OAAO,CAAC,kBAAkB,CAAC;YAEjC,OAAO,CAAC,sBAAsB;gBAC5B,qBAAqB,CAAC,mBAAmB,KAAK,OAAO,CAAC,mBAAmB,CAAC;SAC7E;aAAM;YACL,OAAO,CAAC,mBAAmB,GAAG,OAAO,CAAC,kBAAkB,CAAC;SAC1D;QAED,IAAI,OAAO,CAAC,mBAAmB,KAAK,gCAAU,CAAC,IAAI,EAAE;YACnD,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,UAAU,EAAE;gBACxC,iDAAiD;gBACjD,oGAAoG;gBACpG,0CAA0C;gBAC1C,MAAM,SAAS,GAAc,cAAc,CAAC,SAAS,CAAC;gBACtD,MAAM,MAAM,GAAgC,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC;gBACnG,IACE,MAAM;oBACN,CAAC,MAAM,CAAC,UAAU;wBAChB,IAAI,CAAC,eAAe,CAAC,gCAAgC;wBACrD,IAAI,CAAC,eAAe,CAAC,+BAA+B,CAAC,EACvD;oBACA,8FAA8F;oBAC9F,2CAA2C;oBAC3C,IAAI,SAAS,CAAC,aAAa,CAAC,SAAS,KAAK,UAAU,EAAE;wBACpD,IAAI,CAAC,aAAa,CAAC,gBAAgB,sEAEjC,IAAI,MAAM,CAAC,SAAS,CAAC,SAAS,oDAAoD;4BAChF,sDAAsD,EACxD,SAAS,CACV,CAAC;qBACH;iBACF;aACF;YAED,OAAO,CAAC,mBAAmB,GAAG,gCAAU,CAAC,MAAM,CAAC;SACjD;QAED,MAAM,eAAe,GAAoB,IAAI,iCAAe,CAAC,OAAO,CAAC,CAAC;QACtE,IAAI,aAAa,EAAE;YACjB,eAAe,CAAC,YAAY,GAAG,aAAa,CAAC,UAAU,CAAC;SACzD;QAED,cAAc,CAAC,eAAe,GAAG,eAAe,CAAC;QAEjD,2DAA2D;QAC3D,KAAK,MAAM,oBAAoB,IAAI,mBAAmB,CAAC,qBAAqB,EAAE;YAC5E,oBAAoB,CAAC,eAAe,GAAG,eAAe,CAAC;SACxD;IACH,CAAC;IAEO,4BAA4B,CAAC,cAA8B;QACjE,MAAM,WAAW,GAAmB,cAAc,CAAC,WAAW,CAAC;QAC/D,IAAI,cAAc,GAAY,WAAW,CAAC;QAE1C,IAAI,EAAE,CAAC,qBAAqB,CAAC,WAAW,CAAC,EAAE;YACzC,4FAA4F;YAC5F,EAAE;YACF,sFAAsF;YACtF,EAAE;YACF,2GAA2G;YAC3G,0GAA0G;YAC1G,EAAE;YACF,+BAA+B;YAC/B,EAAE;YACF,4GAA4G;YAC5G,6GAA6G;YAC7G,MAAM,SAAS,GAAqC,qCAAiB,CAAC,eAAe,CACnF,WAAW,EACX,EAAE,CAAC,UAAU,CAAC,iBAAiB,CACI,CAAC;YACtC,IAAI,SAAS,KAAK,SAAS,EAAE;gBAC3B,sEAAsE;gBACtE,IAAI,SAAS,CAAC,eAAe,CAAC,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE;oBACvD,cAAc,GAAG,SAAS,CAAC;iBAC5B;aACF;SACF;QAED,MAAM,cAAc,GAAW,WAAW,CAAC,aAAa,EAAE,CAAC,IAAI,CAAC;QAChE,MAAM,MAAM,GACV,yCAAmB,CAAC,qBAAqB,CAAC,cAAc,EAAE,cAAc,CAAC,IAAI,EAAE,CAAC;QAElF,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;YACvB,OAAO,SAAS,CAAC;SAClB;QAED,yEAAyE;QACzE,4BAA4B;QAC5B,MAAM,KAAK,GAAiB,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAEtD,MAAM,cAAc,GAAoB,KAAK,CAAC,SAAS,CAAC,eAAe,CACrE,cAAc,EACd,KAAK,CAAC,GAAG,EACT,KAAK,CAAC,GAAG,CACV,CAAC;QAEF,MAAM,aAAa,GAAwB,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;QAExF,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAC,aAAa,EAAE,WAAW,CAAC,aAAa,EAAE,EAAE,cAAc,CAAC,CAAC;QAEhG,kGAAkG;QAClG,gCAAgC;QAChC,aAAa,CAAC,UAAU,CAAC,cAAc,GAAG,SAAS,CAAC;QAEpD,OAAO,aAAa,CAAC;IACvB,CAAC;IAEO,2BAA2B,CAAC,SAAoB;QACtD,IAAI,SAAS,YAAY,qBAAS,EAAE;YAClC,MAAM,WAAW,GAAoB,SAAS,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,cAAc,EAAE,EAAE,CACpF,cAAc,CAAC,WAAW,CAAC,aAAa,EAAE,CAC3C,CAAC;YACF,OAAO,IAAI,CAAC,0CAA0C,CAAC,WAAW,CAAC,CAAC;SACrE;QAED,IAAI,SAAS,YAAY,uCAAkB,EAAE;YAC3C,MAAM,WAAW,GAAoB,CAAC,SAAS,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;YACtE,OAAO,IAAI,CAAC,0CAA0C,CAAC,WAAW,CAAC,CAAC;SACrE;IACH,CAAC;IAEO,0CAA0C,CAAC,WAA4B;QAC7E,MAAM,aAAa,GAAgB,IAAI,GAAG,EAAU,CAAC;QAErD,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;YACpC,IAAI,UAAU,IAAI,UAAU,CAAC,QAAQ,EAAE;gBACrC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;oBAC3C,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;oBAEvC,KAAK,MAAM,sBAAsB,IAAI,UAAU,CAAC,uBAAuB,EAAE;wBACvE,MAAM,IAAI,GAAW,UAAU,CAAC,IAAI,CAAC,SAAS,CAC5C,sBAAsB,CAAC,GAAG,EAC1B,sBAAsB,CAAC,GAAG,CAC3B,CAAC;wBACF,IAAI,CAAC,2BAA2B,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;qBAC5C;oBAED,KAAK,MAAM,qBAAqB,IAAI,UAAU,CAAC,sBAAsB,EAAE;wBACrE,MAAM,IAAI,GAAW,UAAU,CAAC,IAAI,CAAC,SAAS,CAC5C,qBAAqB,CAAC,GAAG,EACzB,qBAAqB,CAAC,GAAG,CAC1B,CAAC;wBACF,IAAI,CAAC,0BAA0B,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;qBAC3C;iBACF;aACF;SACF;IACH,CAAC;CACF;AAx9BD,8BAw9BC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport * as tsdoc from '@microsoft/tsdoc';\r\nimport {\r\n  PackageJsonLookup,\r\n  Sort,\r\n  InternalError,\r\n  type INodePackageJson,\r\n  PackageName\r\n} from '@rushstack/node-core-library';\r\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\r\n\r\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\r\n\r\nimport { CollectorEntity } from './CollectorEntity';\r\nimport { AstSymbolTable } from '../analyzer/AstSymbolTable';\r\nimport type { AstEntity } from '../analyzer/AstEntity';\r\nimport type { AstModule, AstModuleExportInfo } from '../analyzer/AstModule';\r\nimport { AstSymbol } from '../analyzer/AstSymbol';\r\nimport type { AstDeclaration } from '../analyzer/AstDeclaration';\r\nimport { TypeScriptHelpers } from '../analyzer/TypeScriptHelpers';\r\nimport { WorkingPackage } from './WorkingPackage';\r\nimport { PackageDocComment } from '../aedoc/PackageDocComment';\r\nimport { type DeclarationMetadata, InternalDeclarationMetadata } from './DeclarationMetadata';\r\nimport { ApiItemMetadata, type IApiItemMetadataOptions } from './ApiItemMetadata';\r\nimport { SymbolMetadata } from './SymbolMetadata';\r\nimport { TypeScriptInternals, type IGlobalVariableAnalyzer } from '../analyzer/TypeScriptInternals';\r\nimport type { MessageRouter } from './MessageRouter';\r\nimport { AstReferenceResolver } from '../analyzer/AstReferenceResolver';\r\nimport { ExtractorConfig } from '../api/ExtractorConfig';\r\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\r\nimport { AstImport } from '../analyzer/AstImport';\r\nimport type { SourceMapper } from './SourceMapper';\r\n\r\n/**\r\n * Options for Collector constructor.\r\n */\r\nexport interface ICollectorOptions {\r\n  /**\r\n   * Configuration for the TypeScript compiler.  The most important options to set are:\r\n   *\r\n   * - target: ts.ScriptTarget.ES5\r\n   * - module: ts.ModuleKind.CommonJS\r\n   * - moduleResolution: ts.ModuleResolutionKind.NodeJs\r\n   * - rootDir: inputFolder\r\n   */\r\n  program: ts.Program;\r\n\r\n  messageRouter: MessageRouter;\r\n\r\n  extractorConfig: ExtractorConfig;\r\n\r\n  sourceMapper: SourceMapper;\r\n}\r\n\r\n/**\r\n * The `Collector` manages the overall data set that is used by `ApiModelGenerator`,\r\n * `DtsRollupGenerator`, and `ApiReportGenerator`.  Starting from the working package's entry point,\r\n * the `Collector` collects all exported symbols, determines how to import any symbols they reference,\r\n * assigns unique names, and sorts everything into a normalized alphabetical ordering.\r\n */\r\nexport class Collector {\r\n  public readonly program: ts.Program;\r\n  public readonly typeChecker: ts.TypeChecker;\r\n  public readonly globalVariableAnalyzer: IGlobalVariableAnalyzer;\r\n  public readonly astSymbolTable: AstSymbolTable;\r\n  public readonly astReferenceResolver: AstReferenceResolver;\r\n\r\n  public readonly packageJsonLookup: PackageJsonLookup;\r\n  public readonly messageRouter: MessageRouter;\r\n\r\n  public readonly workingPackage: WorkingPackage;\r\n\r\n  public readonly extractorConfig: ExtractorConfig;\r\n\r\n  public readonly sourceMapper: SourceMapper;\r\n\r\n  /**\r\n   * The `ExtractorConfig.bundledPackages` names in a set.\r\n   */\r\n  public readonly bundledPackageNames: ReadonlySet<string>;\r\n\r\n  private readonly _program: ts.Program;\r\n\r\n  private readonly _tsdocParser: tsdoc.TSDocParser;\r\n\r\n  private _astEntryPoint: AstModule | undefined;\r\n\r\n  private readonly _entities: CollectorEntity[] = [];\r\n  private readonly _entitiesByAstEntity: Map<AstEntity, CollectorEntity> = new Map<\r\n    AstEntity,\r\n    CollectorEntity\r\n  >();\r\n  private readonly _entitiesBySymbol: Map<ts.Symbol, CollectorEntity> = new Map<ts.Symbol, CollectorEntity>();\r\n\r\n  private readonly _starExportedExternalModulePaths: string[] = [];\r\n\r\n  private readonly _dtsTypeReferenceDirectives: Set<string> = new Set<string>();\r\n  private readonly _dtsLibReferenceDirectives: Set<string> = new Set<string>();\r\n\r\n  // Used by getOverloadIndex()\r\n  private readonly _cachedOverloadIndexesByDeclaration: Map<AstDeclaration, number>;\r\n\r\n  public constructor(options: ICollectorOptions) {\r\n    this.packageJsonLookup = new PackageJsonLookup();\r\n\r\n    this._program = options.program;\r\n    this.extractorConfig = options.extractorConfig;\r\n    this.sourceMapper = options.sourceMapper;\r\n\r\n    const entryPointSourceFile: ts.SourceFile | undefined = options.program.getSourceFile(\r\n      this.extractorConfig.mainEntryPointFilePath\r\n    );\r\n\r\n    if (!entryPointSourceFile) {\r\n      throw new Error('Unable to load file: ' + this.extractorConfig.mainEntryPointFilePath);\r\n    }\r\n\r\n    if (!this.extractorConfig.packageFolder || !this.extractorConfig.packageJson) {\r\n      // TODO: We should be able to analyze projects that don't have any package.json.\r\n      // The ExtractorConfig class is already designed to allow this.\r\n      throw new Error('Unable to find a package.json file for the project being analyzed');\r\n    }\r\n\r\n    this.workingPackage = new WorkingPackage({\r\n      packageFolder: this.extractorConfig.packageFolder,\r\n      packageJson: this.extractorConfig.packageJson,\r\n      entryPointSourceFile\r\n    });\r\n\r\n    this.messageRouter = options.messageRouter;\r\n\r\n    this.program = options.program;\r\n    this.typeChecker = options.program.getTypeChecker();\r\n    this.globalVariableAnalyzer = TypeScriptInternals.getGlobalVariableAnalyzer(this.program);\r\n\r\n    this._tsdocParser = new tsdoc.TSDocParser(this.extractorConfig.tsdocConfiguration);\r\n\r\n    // Resolve glob patterns and store concrete set of bundled package dependency names\r\n    this.bundledPackageNames = Collector._resolveBundledPackagePatterns(\r\n      this.extractorConfig.bundledPackages,\r\n      this.extractorConfig.packageJson\r\n    );\r\n\r\n    this.astSymbolTable = new AstSymbolTable(\r\n      this.program,\r\n      this.typeChecker,\r\n      this.packageJsonLookup,\r\n      this.bundledPackageNames,\r\n      this.messageRouter\r\n    );\r\n    this.astReferenceResolver = new AstReferenceResolver(this);\r\n\r\n    this._cachedOverloadIndexesByDeclaration = new Map<AstDeclaration, number>();\r\n  }\r\n\r\n  /**\r\n   * Searches the provided package.json for dependencies and devDependencies that match the provided\r\n   * package names and/or RegExp patterns in `bundledPackages`.\r\n   * @param bundledPackages - The list of package names and/or RegExp patterns to search for in the package.json.\r\n   * @param packageJson - The package.json of the package being processed.\r\n   * @returns The set of matching package names.\r\n   */\r\n  private static _resolveBundledPackagePatterns(\r\n    bundledPackages: string[],\r\n    packageJson: INodePackageJson | undefined\r\n  ): ReadonlySet<string> {\r\n    // The set to be built up and returned\r\n    const packageNames: Set<string> = new Set<string>();\r\n\r\n    if (bundledPackages.length === 0) {\r\n      // If no `bundledPackages` were specified, then there is nothing to resolve.\r\n      // Return an empty set.\r\n      return packageNames;\r\n    }\r\n\r\n    if (packageJson === undefined) {\r\n      // If no package.json is present, then there are no possible package matches.\r\n      // Return an empty set.\r\n      return packageNames;\r\n    }\r\n\r\n    const dependencyKeys: string[] = Object.keys(packageJson.dependencies ?? {});\r\n    const devDependencyKeys: string[] = Object.keys(packageJson.devDependencies ?? {});\r\n\r\n    const dependencyNames: string[] = dependencyKeys.concat(devDependencyKeys);\r\n\r\n    if (dependencyNames.length === 0) {\r\n      // If there are no dependencies nor devDependencies, then there are no possible package matches.\r\n      // Return an empty set.\r\n      return packageNames;\r\n    }\r\n\r\n    for (const packageNameOrPattern of bundledPackages) {\r\n      if (PackageName.isValidName(packageNameOrPattern)) {\r\n        // If the string is an exact package name, search for exact match\r\n        if (dependencyNames.includes(packageNameOrPattern)) {\r\n          packageNames.add(packageNameOrPattern);\r\n        } else {\r\n          console.warn(\r\n            `package.json contained no dependency or devDependency for specified bundledPackages entry \"${packageNameOrPattern}\".`\r\n          );\r\n        }\r\n      } else {\r\n        // If the entry isn't an exact package name, assume RegExp and search for matches\r\n        const regexp: RegExp = new RegExp(packageNameOrPattern);\r\n        const matches: string[] = dependencyNames.filter((dependencyName) => regexp.test(dependencyName));\r\n        if (matches.length === 0) {\r\n          console.warn(\r\n            `No matching package dependencies found for provided bundledPackages pattern \"${packageNameOrPattern}\".`\r\n          );\r\n        } else {\r\n          matches.forEach((match) => packageNames.add(match));\r\n        }\r\n      }\r\n    }\r\n    return packageNames;\r\n  }\r\n\r\n  /**\r\n   * Returns a list of names (e.g. \"example-library\") that should appear in a reference like this:\r\n   *\r\n   * ```\r\n   * /// <reference types=\"example-library\" />\r\n   * ```\r\n   */\r\n  public get dtsTypeReferenceDirectives(): ReadonlySet<string> {\r\n    return this._dtsTypeReferenceDirectives;\r\n  }\r\n\r\n  /**\r\n   * A list of names (e.g. \"runtime-library\") that should appear in a reference like this:\r\n   *\r\n   * ```\r\n   * /// <reference lib=\"runtime-library\" />\r\n   * ```\r\n   */\r\n  public get dtsLibReferenceDirectives(): ReadonlySet<string> {\r\n    return this._dtsLibReferenceDirectives;\r\n  }\r\n\r\n  public get entities(): ReadonlyArray<CollectorEntity> {\r\n    return this._entities;\r\n  }\r\n\r\n  /**\r\n   * A list of module specifiers (e.g. `\"@rushstack/node-core-library/lib/FileSystem\"`) that should be emitted\r\n   * as star exports (e.g. `export * from \"@rushstack/node-core-library/lib/FileSystem\"`).\r\n   */\r\n  public get starExportedExternalModulePaths(): ReadonlyArray<string> {\r\n    return this._starExportedExternalModulePaths;\r\n  }\r\n\r\n  /**\r\n   * Perform the analysis.\r\n   */\r\n  public analyze(): void {\r\n    if (this._astEntryPoint) {\r\n      throw new Error('DtsRollupGenerator.analyze() was already called');\r\n    }\r\n\r\n    // This runs a full type analysis, and then augments the Abstract Syntax Tree (i.e. declarations)\r\n    // with semantic information (i.e. symbols).  The \"diagnostics\" are a subset of the everyday\r\n    // compile errors that would result from a full compilation.\r\n    for (const diagnostic of this._program.getSemanticDiagnostics()) {\r\n      this.messageRouter.addCompilerDiagnostic(diagnostic);\r\n    }\r\n\r\n    const sourceFiles: readonly ts.SourceFile[] = this.program.getSourceFiles();\r\n\r\n    if (this.messageRouter.showDiagnostics) {\r\n      this.messageRouter.logDiagnosticHeader('Root filenames');\r\n      for (const fileName of this.program.getRootFileNames()) {\r\n        this.messageRouter.logDiagnostic(fileName);\r\n      }\r\n      this.messageRouter.logDiagnosticFooter();\r\n\r\n      this.messageRouter.logDiagnosticHeader('Files analyzed by compiler');\r\n      for (const sourceFile of sourceFiles) {\r\n        this.messageRouter.logDiagnostic(sourceFile.fileName);\r\n      }\r\n      this.messageRouter.logDiagnosticFooter();\r\n    }\r\n\r\n    // We can throw this error earlier in CompilerState.ts, but intentionally wait until after we've logged the\r\n    // associated diagnostic message above to make debugging easier for developers.\r\n    // Typically there will be many such files -- to avoid too much noise, only report the first one.\r\n    const badSourceFile: ts.SourceFile | undefined = sourceFiles.find(\r\n      ({ fileName }) => !ExtractorConfig.hasDtsFileExtension(fileName)\r\n    );\r\n    if (badSourceFile) {\r\n      this.messageRouter.addAnalyzerIssueForPosition(\r\n        ExtractorMessageId.WrongInputFileType,\r\n        'Incorrect file type; API Extractor expects to analyze compiler outputs with the .d.ts file extension. ' +\r\n          'Troubleshooting tips: https://api-extractor.com/link/dts-error',\r\n        badSourceFile,\r\n        0\r\n      );\r\n    }\r\n\r\n    // Build the entry point\r\n    const entryPointSourceFile: ts.SourceFile = this.workingPackage.entryPointSourceFile;\r\n\r\n    const astEntryPoint: AstModule =\r\n      this.astSymbolTable.fetchAstModuleFromWorkingPackage(entryPointSourceFile);\r\n    this._astEntryPoint = astEntryPoint;\r\n\r\n    const packageDocCommentTextRange: ts.TextRange | undefined = PackageDocComment.tryFindInSourceFile(\r\n      entryPointSourceFile,\r\n      this\r\n    );\r\n\r\n    if (packageDocCommentTextRange) {\r\n      const range: tsdoc.TextRange = tsdoc.TextRange.fromStringRange(\r\n        entryPointSourceFile.text,\r\n        packageDocCommentTextRange.pos,\r\n        packageDocCommentTextRange.end\r\n      );\r\n\r\n      this.workingPackage.tsdocParserContext = this._tsdocParser.parseRange(range);\r\n\r\n      this.messageRouter.addTsdocMessages(this.workingPackage.tsdocParserContext, entryPointSourceFile);\r\n\r\n      this.workingPackage.tsdocComment = this.workingPackage.tsdocParserContext!.docComment;\r\n    }\r\n\r\n    const astModuleExportInfo: AstModuleExportInfo =\r\n      this.astSymbolTable.fetchAstModuleExportInfo(astEntryPoint);\r\n\r\n    // Create a CollectorEntity for each top-level export.\r\n    const processedAstEntities: AstEntity[] = [];\r\n    for (const [exportName, astEntity] of astModuleExportInfo.exportedLocalEntities) {\r\n      this._createCollectorEntity(astEntity, exportName);\r\n      processedAstEntities.push(astEntity);\r\n    }\r\n\r\n    // Recursively create the remaining CollectorEntities after the top-level entities\r\n    // have been processed.\r\n    const alreadySeenAstEntities: Set<AstEntity> = new Set<AstEntity>();\r\n    for (const astEntity of processedAstEntities) {\r\n      this._recursivelyCreateEntities(astEntity, alreadySeenAstEntities);\r\n      if (astEntity instanceof AstSymbol) {\r\n        this.fetchSymbolMetadata(astEntity);\r\n      }\r\n    }\r\n\r\n    this._makeUniqueNames();\r\n\r\n    for (const starExportedExternalModule of astModuleExportInfo.starExportedExternalModules) {\r\n      if (starExportedExternalModule.externalModulePath !== undefined) {\r\n        this._starExportedExternalModulePaths.push(starExportedExternalModule.externalModulePath);\r\n      }\r\n    }\r\n\r\n    Sort.sortBy(this._entities, (x) => x.getSortKey());\r\n    Sort.sortSet(this._dtsTypeReferenceDirectives);\r\n    Sort.sortSet(this._dtsLibReferenceDirectives);\r\n    this._starExportedExternalModulePaths.sort();\r\n  }\r\n\r\n  /**\r\n   * For a given ts.Identifier that is part of an AstSymbol that we analyzed, return the CollectorEntity that\r\n   * it refers to.  Returns undefined if it doesn't refer to anything interesting.\r\n   * @remarks\r\n   * Throws an Error if the ts.Identifier is not part of node tree that was analyzed.\r\n   */\r\n  public tryGetEntityForNode(identifier: ts.Identifier | ts.ImportTypeNode): CollectorEntity | undefined {\r\n    const astEntity: AstEntity | undefined = this.astSymbolTable.tryGetEntityForNode(identifier);\r\n    if (astEntity) {\r\n      return this._entitiesByAstEntity.get(astEntity);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * For a given analyzed ts.Symbol, return the CollectorEntity that it refers to. Returns undefined if it\r\n   * doesn't refer to anything interesting.\r\n   */\r\n  public tryGetEntityForSymbol(symbol: ts.Symbol): CollectorEntity | undefined {\r\n    return this._entitiesBySymbol.get(symbol);\r\n  }\r\n\r\n  /**\r\n   * Returns the associated `CollectorEntity` for the given `astEntity`, if one was created during analysis.\r\n   */\r\n  public tryGetCollectorEntity(astEntity: AstEntity): CollectorEntity | undefined {\r\n    return this._entitiesByAstEntity.get(astEntity);\r\n  }\r\n\r\n  public fetchSymbolMetadata(astSymbol: AstSymbol): SymbolMetadata {\r\n    if (astSymbol.symbolMetadata === undefined) {\r\n      this._fetchSymbolMetadata(astSymbol);\r\n    }\r\n    return astSymbol.symbolMetadata as SymbolMetadata;\r\n  }\r\n\r\n  public fetchDeclarationMetadata(astDeclaration: AstDeclaration): DeclarationMetadata {\r\n    if (astDeclaration.declarationMetadata === undefined) {\r\n      // Fetching the SymbolMetadata always constructs the DeclarationMetadata\r\n      this._fetchSymbolMetadata(astDeclaration.astSymbol);\r\n    }\r\n    return astDeclaration.declarationMetadata as DeclarationMetadata;\r\n  }\r\n\r\n  public fetchApiItemMetadata(astDeclaration: AstDeclaration): ApiItemMetadata {\r\n    if (astDeclaration.apiItemMetadata === undefined) {\r\n      // Fetching the SymbolMetadata always constructs the ApiItemMetadata\r\n      this._fetchSymbolMetadata(astDeclaration.astSymbol);\r\n    }\r\n    return astDeclaration.apiItemMetadata as ApiItemMetadata;\r\n  }\r\n\r\n  public tryFetchMetadataForAstEntity(astEntity: AstEntity): SymbolMetadata | undefined {\r\n    if (astEntity instanceof AstSymbol) {\r\n      return this.fetchSymbolMetadata(astEntity);\r\n    }\r\n    if (astEntity instanceof AstImport) {\r\n      if (astEntity.astSymbol) {\r\n        return this.fetchSymbolMetadata(astEntity.astSymbol);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  public isAncillaryDeclaration(astDeclaration: AstDeclaration): boolean {\r\n    const declarationMetadata: DeclarationMetadata = this.fetchDeclarationMetadata(astDeclaration);\r\n    return declarationMetadata.isAncillary;\r\n  }\r\n\r\n  public getNonAncillaryDeclarations(astSymbol: AstSymbol): ReadonlyArray<AstDeclaration> {\r\n    const result: AstDeclaration[] = [];\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      const declarationMetadata: DeclarationMetadata = this.fetchDeclarationMetadata(astDeclaration);\r\n      if (!declarationMetadata.isAncillary) {\r\n        result.push(astDeclaration);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Removes the leading underscore, for example: \"_Example\" --> \"example*Example*_\"\r\n   *\r\n   * @remarks\r\n   * This causes internal definitions to sort alphabetically case-insensitive, then case-sensitive, and\r\n   * initially ignoring the underscore prefix, while still deterministically comparing it.\r\n   * The star is used as a delimiter because it is not a legal  identifier character.\r\n   */\r\n  public static getSortKeyIgnoringUnderscore(identifier: string | undefined): string {\r\n    if (!identifier) return '';\r\n\r\n    let parts: string[];\r\n\r\n    if (identifier[0] === '_') {\r\n      const withoutUnderscore: string = identifier.substr(1);\r\n      parts = [withoutUnderscore.toLowerCase(), '*', withoutUnderscore, '*', '_'];\r\n    } else {\r\n      parts = [identifier.toLowerCase(), '*', identifier];\r\n    }\r\n\r\n    return parts.join('');\r\n  }\r\n\r\n  /**\r\n   * For function-like signatures, this returns the TSDoc \"overload index\" which can be used to identify\r\n   * a specific overload.\r\n   */\r\n  public getOverloadIndex(astDeclaration: AstDeclaration): number {\r\n    const allDeclarations: ReadonlyArray<AstDeclaration> = astDeclaration.astSymbol.astDeclarations;\r\n    if (allDeclarations.length === 1) {\r\n      return 1; // trivial case\r\n    }\r\n\r\n    let overloadIndex: number | undefined = this._cachedOverloadIndexesByDeclaration.get(astDeclaration);\r\n\r\n    if (overloadIndex === undefined) {\r\n      // TSDoc index selectors are positive integers counting from 1\r\n      let nextIndex: number = 1;\r\n      for (const other of allDeclarations) {\r\n        // Filter out other declarations that are not overloads.  For example, an overloaded function can also\r\n        // be a namespace.\r\n        if (other.declaration.kind === astDeclaration.declaration.kind) {\r\n          this._cachedOverloadIndexesByDeclaration.set(other, nextIndex);\r\n          ++nextIndex;\r\n        }\r\n      }\r\n      overloadIndex = this._cachedOverloadIndexesByDeclaration.get(astDeclaration);\r\n    }\r\n\r\n    if (overloadIndex === undefined) {\r\n      // This should never happen\r\n      throw new InternalError('Error calculating overload index for declaration');\r\n    }\r\n\r\n    return overloadIndex;\r\n  }\r\n\r\n  private _createCollectorEntity(\r\n    astEntity: AstEntity,\r\n    exportName?: string,\r\n    parent?: CollectorEntity\r\n  ): CollectorEntity {\r\n    let entity: CollectorEntity | undefined = this._entitiesByAstEntity.get(astEntity);\r\n\r\n    if (!entity) {\r\n      entity = new CollectorEntity(astEntity);\r\n\r\n      this._entitiesByAstEntity.set(astEntity, entity);\r\n      if (astEntity instanceof AstSymbol) {\r\n        this._entitiesBySymbol.set(astEntity.followedSymbol, entity);\r\n      } else if (astEntity instanceof AstNamespaceImport) {\r\n        this._entitiesBySymbol.set(astEntity.symbol, entity);\r\n      }\r\n      this._entities.push(entity);\r\n      this._collectReferenceDirectives(astEntity);\r\n    }\r\n\r\n    if (exportName) {\r\n      if (parent) {\r\n        entity.addLocalExportName(exportName, parent);\r\n      } else {\r\n        entity.addExportName(exportName);\r\n      }\r\n    }\r\n\r\n    return entity;\r\n  }\r\n\r\n  private _recursivelyCreateEntities(astEntity: AstEntity, alreadySeenAstEntities: Set<AstEntity>): void {\r\n    if (alreadySeenAstEntities.has(astEntity)) return;\r\n    alreadySeenAstEntities.add(astEntity);\r\n\r\n    if (astEntity instanceof AstSymbol) {\r\n      astEntity.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\r\n        for (const referencedAstEntity of astDeclaration.referencedAstEntities) {\r\n          if (referencedAstEntity instanceof AstSymbol) {\r\n            // We only create collector entities for root-level symbols. For example, if a symbol is\r\n            // nested inside a namespace, only the namespace gets a collector entity. Note that this\r\n            // is not true for AstNamespaceImports below.\r\n            if (referencedAstEntity.parentAstSymbol === undefined) {\r\n              this._createCollectorEntity(referencedAstEntity);\r\n            }\r\n          } else {\r\n            this._createCollectorEntity(referencedAstEntity);\r\n          }\r\n\r\n          this._recursivelyCreateEntities(referencedAstEntity, alreadySeenAstEntities);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (astEntity instanceof AstNamespaceImport) {\r\n      const astModuleExportInfo: AstModuleExportInfo = astEntity.fetchAstModuleExportInfo(this);\r\n      const parentEntity: CollectorEntity | undefined = this._entitiesByAstEntity.get(astEntity);\r\n      if (!parentEntity) {\r\n        // This should never happen, as we've already created entities for all AstNamespaceImports.\r\n        throw new InternalError(\r\n          `Failed to get CollectorEntity for AstNamespaceImport with namespace name \"${astEntity.namespaceName}\"`\r\n        );\r\n      }\r\n\r\n      for (const [localExportName, localAstEntity] of astModuleExportInfo.exportedLocalEntities) {\r\n        // Create a CollectorEntity for each local export within an AstNamespaceImport entity.\r\n        this._createCollectorEntity(localAstEntity, localExportName, parentEntity);\r\n        this._recursivelyCreateEntities(localAstEntity, alreadySeenAstEntities);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensures a unique name for each item in the package typings file.\r\n   */\r\n  private _makeUniqueNames(): void {\r\n    // The following examples illustrate the nameForEmit heuristics:\r\n    //\r\n    // Example 1:\r\n    //   class X { } <--- nameForEmit should be \"A\" to simplify things and reduce possibility of conflicts\r\n    //   export { X as A };\r\n    //\r\n    // Example 2:\r\n    //   class X { } <--- nameForEmit should be \"X\" because choosing A or B would be nondeterministic\r\n    //   export { X as A };\r\n    //   export { X as B };\r\n    //\r\n    // Example 3:\r\n    //   class X { } <--- nameForEmit should be \"X_1\" because Y has a stronger claim to the name\r\n    //   export { X as A };\r\n    //   export { X as B };\r\n    //   class Y { } <--- nameForEmit should be \"X\"\r\n    //   export { Y as X };\r\n\r\n    // Set of names that should NOT be used when generating a unique nameForEmit\r\n    const usedNames: Set<string> = new Set<string>();\r\n\r\n    // First collect the names of explicit package exports, and perform a sanity check.\r\n    for (const entity of this._entities) {\r\n      for (const exportName of entity.exportNames) {\r\n        if (usedNames.has(exportName)) {\r\n          // This should be impossible\r\n          throw new InternalError(`A package cannot have two exports with the name \"${exportName}\"`);\r\n        }\r\n        usedNames.add(exportName);\r\n      }\r\n    }\r\n\r\n    // Ensure that each entity has a unique nameForEmit\r\n    for (const entity of this._entities) {\r\n      // What name would we ideally want to emit it as?\r\n      let idealNameForEmit: string;\r\n\r\n      // If this entity is exported exactly once, then we prefer the exported name\r\n      if (\r\n        entity.singleExportName !== undefined &&\r\n        entity.singleExportName !== ts.InternalSymbolName.Default\r\n      ) {\r\n        idealNameForEmit = entity.singleExportName;\r\n      } else {\r\n        // otherwise use the local name\r\n        idealNameForEmit = entity.astEntity.localName;\r\n      }\r\n\r\n      if (idealNameForEmit.includes('.')) {\r\n        // For an ImportType with a namespace chain, only the top namespace is imported.\r\n        idealNameForEmit = idealNameForEmit.split('.')[0];\r\n      }\r\n\r\n      // If the idealNameForEmit happens to be the same as one of the exports, then we're safe to use that...\r\n      if (entity.exportNames.has(idealNameForEmit)) {\r\n        // ...except that if it conflicts with a global name, then the global name wins\r\n        if (!this.globalVariableAnalyzer.hasGlobalName(idealNameForEmit)) {\r\n          // ...also avoid \"default\" which can interfere with \"export { default } from 'some-module;'\"\r\n          if (idealNameForEmit !== 'default') {\r\n            entity.nameForEmit = idealNameForEmit;\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Generate a unique name based on idealNameForEmit\r\n      let suffix: number = 1;\r\n      let nameForEmit: string = idealNameForEmit;\r\n\r\n      // Choose a name that doesn't conflict with usedNames or a global name\r\n      while (\r\n        nameForEmit === 'default' ||\r\n        usedNames.has(nameForEmit) ||\r\n        this.globalVariableAnalyzer.hasGlobalName(nameForEmit)\r\n      ) {\r\n        nameForEmit = `${idealNameForEmit}_${++suffix}`;\r\n      }\r\n      entity.nameForEmit = nameForEmit;\r\n      usedNames.add(nameForEmit);\r\n    }\r\n  }\r\n\r\n  private _fetchSymbolMetadata(astSymbol: AstSymbol): void {\r\n    if (astSymbol.symbolMetadata) {\r\n      return;\r\n    }\r\n\r\n    // When we solve an astSymbol, then we always also solve all of its parents and all of its declarations.\r\n    // The parent is solved first.\r\n    if (astSymbol.parentAstSymbol && astSymbol.parentAstSymbol.symbolMetadata === undefined) {\r\n      this._fetchSymbolMetadata(astSymbol.parentAstSymbol);\r\n    }\r\n\r\n    // Construct the DeclarationMetadata objects, and detect any ancillary declarations\r\n    this._calculateDeclarationMetadataForDeclarations(astSymbol);\r\n\r\n    // Calculate the ApiItemMetadata objects\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      this._calculateApiItemMetadata(astDeclaration);\r\n    }\r\n\r\n    // The most public effectiveReleaseTag for all declarations\r\n    let maxEffectiveReleaseTag: ReleaseTag = ReleaseTag.None;\r\n\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      // We know we solved this above\r\n      const apiItemMetadata: ApiItemMetadata = astDeclaration.apiItemMetadata as ApiItemMetadata;\r\n\r\n      const effectiveReleaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n\r\n      if (effectiveReleaseTag > maxEffectiveReleaseTag) {\r\n        maxEffectiveReleaseTag = effectiveReleaseTag;\r\n      }\r\n    }\r\n\r\n    // Update this last when we're sure no exceptions were thrown\r\n    astSymbol.symbolMetadata = new SymbolMetadata({\r\n      maxEffectiveReleaseTag\r\n    });\r\n  }\r\n\r\n  private _calculateDeclarationMetadataForDeclarations(astSymbol: AstSymbol): void {\r\n    // Initialize DeclarationMetadata for each declaration\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      if (astDeclaration.declarationMetadata) {\r\n        throw new InternalError(\r\n          'AstDeclaration.declarationMetadata is not expected to have been initialized yet'\r\n        );\r\n      }\r\n\r\n      const metadata: InternalDeclarationMetadata = new InternalDeclarationMetadata();\r\n      metadata.tsdocParserContext = this._parseTsdocForAstDeclaration(astDeclaration);\r\n\r\n      astDeclaration.declarationMetadata = metadata;\r\n    }\r\n\r\n    // Detect ancillary declarations\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      // For a getter/setter pair, make the setter ancillary to the getter\r\n      if (astDeclaration.declaration.kind === ts.SyntaxKind.SetAccessor) {\r\n        let foundGetter: boolean = false;\r\n        for (const getterAstDeclaration of astDeclaration.astSymbol.astDeclarations) {\r\n          if (getterAstDeclaration.declaration.kind === ts.SyntaxKind.GetAccessor) {\r\n            // Associate it with the getter\r\n            this._addAncillaryDeclaration(getterAstDeclaration, astDeclaration);\r\n\r\n            foundGetter = true;\r\n          }\r\n        }\r\n\r\n        if (!foundGetter) {\r\n          this.messageRouter.addAnalyzerIssue(\r\n            ExtractorMessageId.MissingGetter,\r\n            `The property \"${astDeclaration.astSymbol.localName}\" has a setter but no getter.`,\r\n            astDeclaration\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private _addAncillaryDeclaration(\r\n    mainAstDeclaration: AstDeclaration,\r\n    ancillaryAstDeclaration: AstDeclaration\r\n  ): void {\r\n    const mainMetadata: InternalDeclarationMetadata =\r\n      mainAstDeclaration.declarationMetadata as InternalDeclarationMetadata;\r\n    const ancillaryMetadata: InternalDeclarationMetadata =\r\n      ancillaryAstDeclaration.declarationMetadata as InternalDeclarationMetadata;\r\n\r\n    if (mainMetadata.ancillaryDeclarations.indexOf(ancillaryAstDeclaration) >= 0) {\r\n      return; // already added\r\n    }\r\n\r\n    if (mainAstDeclaration.astSymbol !== ancillaryAstDeclaration.astSymbol) {\r\n      throw new InternalError(\r\n        'Invalid call to _addAncillaryDeclaration() because declarations do not' +\r\n          ' belong to the same symbol'\r\n      );\r\n    }\r\n\r\n    if (mainMetadata.isAncillary) {\r\n      throw new InternalError(\r\n        'Invalid call to _addAncillaryDeclaration() because the target is ancillary itself'\r\n      );\r\n    }\r\n\r\n    if (ancillaryMetadata.isAncillary) {\r\n      throw new InternalError(\r\n        'Invalid call to _addAncillaryDeclaration() because source is already ancillary' +\r\n          ' to another declaration'\r\n      );\r\n    }\r\n\r\n    if (mainAstDeclaration.apiItemMetadata || ancillaryAstDeclaration.apiItemMetadata) {\r\n      throw new InternalError(\r\n        'Invalid call to _addAncillaryDeclaration() because the API item metadata' +\r\n          ' has already been constructed'\r\n      );\r\n    }\r\n\r\n    ancillaryMetadata.isAncillary = true;\r\n    mainMetadata.ancillaryDeclarations.push(ancillaryAstDeclaration);\r\n  }\r\n\r\n  private _calculateApiItemMetadata(astDeclaration: AstDeclaration): void {\r\n    const declarationMetadata: InternalDeclarationMetadata =\r\n      astDeclaration.declarationMetadata as InternalDeclarationMetadata;\r\n    if (declarationMetadata.isAncillary) {\r\n      if (astDeclaration.declaration.kind === ts.SyntaxKind.SetAccessor) {\r\n        if (declarationMetadata.tsdocParserContext) {\r\n          this.messageRouter.addAnalyzerIssue(\r\n            ExtractorMessageId.SetterWithDocs,\r\n            `The doc comment for the property \"${astDeclaration.astSymbol.localName}\"` +\r\n              ` must appear on the getter, not the setter.`,\r\n            astDeclaration\r\n          );\r\n        }\r\n      }\r\n\r\n      // We never calculate ApiItemMetadata for an ancillary declaration; instead, it is assigned when\r\n      // the main declaration is processed.\r\n      return;\r\n    }\r\n\r\n    const options: IApiItemMetadataOptions = {\r\n      declaredReleaseTag: ReleaseTag.None,\r\n      effectiveReleaseTag: ReleaseTag.None,\r\n      isEventProperty: false,\r\n      isOverride: false,\r\n      isSealed: false,\r\n      isVirtual: false,\r\n      isPreapproved: false,\r\n      releaseTagSameAsParent: false\r\n    };\r\n\r\n    const parserContext: tsdoc.ParserContext | undefined = declarationMetadata.tsdocParserContext;\r\n    if (parserContext) {\r\n      const modifierTagSet: tsdoc.StandardModifierTagSet = parserContext.docComment.modifierTagSet;\r\n\r\n      let declaredReleaseTag: ReleaseTag = ReleaseTag.None;\r\n      let extraReleaseTags: boolean = false;\r\n\r\n      if (modifierTagSet.isPublic()) {\r\n        declaredReleaseTag = ReleaseTag.Public;\r\n      }\r\n      if (modifierTagSet.isBeta()) {\r\n        if (declaredReleaseTag !== ReleaseTag.None) {\r\n          extraReleaseTags = true;\r\n        } else {\r\n          declaredReleaseTag = ReleaseTag.Beta;\r\n        }\r\n      }\r\n      if (modifierTagSet.isAlpha()) {\r\n        if (declaredReleaseTag !== ReleaseTag.None) {\r\n          extraReleaseTags = true;\r\n        } else {\r\n          declaredReleaseTag = ReleaseTag.Alpha;\r\n        }\r\n      }\r\n      if (modifierTagSet.isInternal()) {\r\n        if (declaredReleaseTag !== ReleaseTag.None) {\r\n          extraReleaseTags = true;\r\n        } else {\r\n          declaredReleaseTag = ReleaseTag.Internal;\r\n        }\r\n      }\r\n\r\n      if (extraReleaseTags) {\r\n        if (!astDeclaration.astSymbol.isExternal) {\r\n          // for now, don't report errors for external code\r\n          this.messageRouter.addAnalyzerIssue(\r\n            ExtractorMessageId.ExtraReleaseTag,\r\n            'The doc comment should not contain more than one release tag',\r\n            astDeclaration\r\n          );\r\n        }\r\n      }\r\n\r\n      options.declaredReleaseTag = declaredReleaseTag;\r\n\r\n      options.isEventProperty = modifierTagSet.isEventProperty();\r\n      options.isOverride = modifierTagSet.isOverride();\r\n      options.isSealed = modifierTagSet.isSealed();\r\n      options.isVirtual = modifierTagSet.isVirtual();\r\n      const preapprovedTag: tsdoc.TSDocTagDefinition | void =\r\n        this.extractorConfig.tsdocConfiguration.tryGetTagDefinition('@preapproved');\r\n\r\n      if (preapprovedTag && modifierTagSet.hasTag(preapprovedTag)) {\r\n        // This feature only makes sense for potentially big declarations.\r\n        switch (astDeclaration.declaration.kind) {\r\n          case ts.SyntaxKind.ClassDeclaration:\r\n          case ts.SyntaxKind.EnumDeclaration:\r\n          case ts.SyntaxKind.InterfaceDeclaration:\r\n          case ts.SyntaxKind.ModuleDeclaration:\r\n            if (declaredReleaseTag === ReleaseTag.Internal) {\r\n              options.isPreapproved = true;\r\n            } else {\r\n              this.messageRouter.addAnalyzerIssue(\r\n                ExtractorMessageId.PreapprovedBadReleaseTag,\r\n                `The @preapproved tag cannot be applied to \"${astDeclaration.astSymbol.localName}\"` +\r\n                  ` without an @internal release tag`,\r\n                astDeclaration\r\n              );\r\n            }\r\n            break;\r\n          default:\r\n            this.messageRouter.addAnalyzerIssue(\r\n              ExtractorMessageId.PreapprovedUnsupportedType,\r\n              `The @preapproved tag cannot be applied to \"${astDeclaration.astSymbol.localName}\"` +\r\n                ` because it is not a supported declaration type`,\r\n              astDeclaration\r\n            );\r\n            break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // This needs to be set regardless of whether or not a parserContext exists\r\n    if (astDeclaration.parent) {\r\n      const parentApiItemMetadata: ApiItemMetadata = this.fetchApiItemMetadata(astDeclaration.parent);\r\n      options.effectiveReleaseTag =\r\n        options.declaredReleaseTag === ReleaseTag.None\r\n          ? parentApiItemMetadata.effectiveReleaseTag\r\n          : options.declaredReleaseTag;\r\n\r\n      options.releaseTagSameAsParent =\r\n        parentApiItemMetadata.effectiveReleaseTag === options.effectiveReleaseTag;\r\n    } else {\r\n      options.effectiveReleaseTag = options.declaredReleaseTag;\r\n    }\r\n\r\n    if (options.effectiveReleaseTag === ReleaseTag.None) {\r\n      if (!astDeclaration.astSymbol.isExternal) {\r\n        // for now, don't report errors for external code\r\n        // Don't report missing release tags for forgotten exports (unless we're including forgotten exports\r\n        // in either the API report or doc model).\r\n        const astSymbol: AstSymbol = astDeclaration.astSymbol;\r\n        const entity: CollectorEntity | undefined = this._entitiesByAstEntity.get(astSymbol.rootAstSymbol);\r\n        if (\r\n          entity &&\r\n          (entity.consumable ||\r\n            this.extractorConfig.apiReportIncludeForgottenExports ||\r\n            this.extractorConfig.docModelIncludeForgottenExports)\r\n        ) {\r\n          // We also don't report errors for the default export of an entry point, since its doc comment\r\n          // isn't easy to obtain from the .d.ts file\r\n          if (astSymbol.rootAstSymbol.localName !== '_default') {\r\n            this.messageRouter.addAnalyzerIssue(\r\n              ExtractorMessageId.MissingReleaseTag,\r\n              `\"${entity.astEntity.localName}\" is part of the package's API, but it is missing ` +\r\n                `a release tag (@alpha, @beta, @public, or @internal)`,\r\n              astSymbol\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      options.effectiveReleaseTag = ReleaseTag.Public;\r\n    }\r\n\r\n    const apiItemMetadata: ApiItemMetadata = new ApiItemMetadata(options);\r\n    if (parserContext) {\r\n      apiItemMetadata.tsdocComment = parserContext.docComment;\r\n    }\r\n\r\n    astDeclaration.apiItemMetadata = apiItemMetadata;\r\n\r\n    // Lastly, share the result with any ancillary declarations\r\n    for (const ancillaryDeclaration of declarationMetadata.ancillaryDeclarations) {\r\n      ancillaryDeclaration.apiItemMetadata = apiItemMetadata;\r\n    }\r\n  }\r\n\r\n  private _parseTsdocForAstDeclaration(astDeclaration: AstDeclaration): tsdoc.ParserContext | undefined {\r\n    const declaration: ts.Declaration = astDeclaration.declaration;\r\n    let nodeForComment: ts.Node = declaration;\r\n\r\n    if (ts.isVariableDeclaration(declaration)) {\r\n      // Variable declarations are special because they can be combined into a list.  For example:\r\n      //\r\n      // /** A */ export /** B */ const /** C */ x = 1, /** D **/ [ /** E */ y, z] = [3, 4];\r\n      //\r\n      // The compiler will only emit comments A and C in the .d.ts file, so in general there isn't a well-defined\r\n      // way to document these parts.  API Extractor requires you to break them into separate exports like this:\r\n      //\r\n      // /** A */ export const x = 1;\r\n      //\r\n      // But _getReleaseTagForDeclaration() still receives a node corresponding to \"x\", so we need to walk upwards\r\n      // and find the containing statement in order for getJSDocCommentRanges() to read the comment that we expect.\r\n      const statement: ts.VariableStatement | undefined = TypeScriptHelpers.findFirstParent(\r\n        declaration,\r\n        ts.SyntaxKind.VariableStatement\r\n      ) as ts.VariableStatement | undefined;\r\n      if (statement !== undefined) {\r\n        // For a compound declaration, fall back to looking for C instead of A\r\n        if (statement.declarationList.declarations.length === 1) {\r\n          nodeForComment = statement;\r\n        }\r\n      }\r\n    }\r\n\r\n    const sourceFileText: string = declaration.getSourceFile().text;\r\n    const ranges: ts.CommentRange[] =\r\n      TypeScriptInternals.getJSDocCommentRanges(nodeForComment, sourceFileText) || [];\r\n\r\n    if (ranges.length === 0) {\r\n      return undefined;\r\n    }\r\n\r\n    // We use the JSDoc comment block that is closest to the definition, i.e.\r\n    // the last one preceding it\r\n    const range: ts.TextRange = ranges[ranges.length - 1];\r\n\r\n    const tsdocTextRange: tsdoc.TextRange = tsdoc.TextRange.fromStringRange(\r\n      sourceFileText,\r\n      range.pos,\r\n      range.end\r\n    );\r\n\r\n    const parserContext: tsdoc.ParserContext = this._tsdocParser.parseRange(tsdocTextRange);\r\n\r\n    this.messageRouter.addTsdocMessages(parserContext, declaration.getSourceFile(), astDeclaration);\r\n\r\n    // We delete the @privateRemarks block as early as possible, to ensure that it never leaks through\r\n    // into one of the output files.\r\n    parserContext.docComment.privateRemarks = undefined;\r\n\r\n    return parserContext;\r\n  }\r\n\r\n  private _collectReferenceDirectives(astEntity: AstEntity): void {\r\n    if (astEntity instanceof AstSymbol) {\r\n      const sourceFiles: ts.SourceFile[] = astEntity.astDeclarations.map((astDeclaration) =>\r\n        astDeclaration.declaration.getSourceFile()\r\n      );\r\n      return this._collectReferenceDirectivesFromSourceFiles(sourceFiles);\r\n    }\r\n\r\n    if (astEntity instanceof AstNamespaceImport) {\r\n      const sourceFiles: ts.SourceFile[] = [astEntity.astModule.sourceFile];\r\n      return this._collectReferenceDirectivesFromSourceFiles(sourceFiles);\r\n    }\r\n  }\r\n\r\n  private _collectReferenceDirectivesFromSourceFiles(sourceFiles: ts.SourceFile[]): void {\r\n    const seenFilenames: Set<string> = new Set<string>();\r\n\r\n    for (const sourceFile of sourceFiles) {\r\n      if (sourceFile && sourceFile.fileName) {\r\n        if (!seenFilenames.has(sourceFile.fileName)) {\r\n          seenFilenames.add(sourceFile.fileName);\r\n\r\n          for (const typeReferenceDirective of sourceFile.typeReferenceDirectives) {\r\n            const name: string = sourceFile.text.substring(\r\n              typeReferenceDirective.pos,\r\n              typeReferenceDirective.end\r\n            );\r\n            this._dtsTypeReferenceDirectives.add(name);\r\n          }\r\n\r\n          for (const libReferenceDirective of sourceFile.libReferenceDirectives) {\r\n            const name: string = sourceFile.text.substring(\r\n              libReferenceDirective.pos,\r\n              libReferenceDirective.end\r\n            );\r\n            this._dtsLibReferenceDirectives.add(name);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/collector/CollectorEntity.js.map b/lib/collector/CollectorEntity.js.map
index 46952adb84958cd4d4456f409246ac4161ce9b6e..20d9e4ce480e8e9a4a9b76cbf909c84d14ad5631 100644
--- a/lib/collector/CollectorEntity.js.map
+++ b/lib/collector/CollectorEntity.js.map
@@ -1 +1 @@
-{"version":3,"file":"CollectorEntity.js","sourceRoot":"","sources":["../../src/collector/CollectorEntity.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\n\nimport { AstSymbol } from '../analyzer/AstSymbol';\nimport { Collector } from './Collector';\nimport { Sort } from '@rushstack/node-core-library';\nimport type { AstEntity } from '../analyzer/AstEntity';\n\n/**\n * This is a data structure used by the Collector to track an AstEntity that may be emitted in the *.d.ts file.\n *\n * @remarks\n * The additional contextual state beyond AstSymbol is:\n * - Whether it's an export of this entry point or not\n * - The nameForEmit, which may get renamed by DtsRollupGenerator._makeUniqueNames()\n * - The export name (or names, if the same symbol is exported multiple times)\n */\nexport class CollectorEntity {\n  /**\n   * The AstEntity that this entry represents.\n   */\n  public readonly astEntity: AstEntity;\n\n  private _exportNames: Set<string> = new Set();\n  private _exportNamesSorted: boolean = false;\n  private _singleExportName: string | undefined = undefined;\n  private _localExportNamesByParent: Map<CollectorEntity, Set<string>> = new Map();\n\n  private _nameForEmit: string | undefined = undefined;\n\n  private _sortKey: string | undefined = undefined;\n\n  public constructor(astEntity: AstEntity) {\n    this.astEntity = astEntity;\n  }\n\n  /**\n   * The declaration name that will be emitted in the .d.ts rollup, .api.md, and .api.json files. Generated by\n   * `Collector._makeUniqueNames`. Be aware that the declaration may be renamed to avoid conflicts with (1)\n   * global names (e.g. `Promise`) and (2) if local, other local names across different files.\n   */\n  public get nameForEmit(): string | undefined {\n    return this._nameForEmit;\n  }\n\n  public set nameForEmit(value: string | undefined) {\n    this._nameForEmit = value;\n    this._sortKey = undefined; // invalidate the cached value\n  }\n\n  /**\n   * The list of export names if this symbol is exported from the entry point.\n   *\n   * @remarks\n   * Note that a given symbol may be exported more than once:\n   * ```\n   * class X { }\n   * export { X }\n   * export { X as Y }\n   * ```\n   */\n  public get exportNames(): ReadonlySet<string> {\n    if (!this._exportNamesSorted) {\n      Sort.sortSet(this._exportNames);\n      this._exportNamesSorted = true;\n    }\n    return this._exportNames;\n  }\n\n  /**\n   * If exportNames contains only one string, then singleExportName is that string.\n   * In all other cases, it is undefined.\n   */\n  public get singleExportName(): string | undefined {\n    return this._singleExportName;\n  }\n\n  /**\n   * This is true if exportNames contains only one string, and the declaration can be exported using the inline syntax\n   * such as \"export class X { }\" instead of \"export { X }\".\n   */\n  public get shouldInlineExport(): boolean {\n    // We don't inline an AstImport\n    if (this.astEntity instanceof AstSymbol) {\n      // We don't inline a symbol with more than one exported name\n      if (this._singleExportName !== undefined && this._singleExportName !== ts.InternalSymbolName.Default) {\n        // We can't inline a symbol whose emitted name is different from the export name\n        if (this._nameForEmit === undefined || this._nameForEmit === this._singleExportName) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Indicates that this entity is exported from the package entry point. Compare to `CollectorEntity.exported`.\n   */\n  public get exportedFromEntryPoint(): boolean {\n    return this.exportNames.size > 0;\n  }\n\n  /**\n   * Indicates that this entity is exported from its parent module (i.e. either the package entry point or\n   * a local namespace). Compare to `CollectorEntity.consumable`.\n   *\n   * @remarks\n   * In the example below:\n   *\n   * ```ts\n   * declare function add(): void;\n   * declare namespace calculator {\n   *  export {\n   *    add\n   *  }\n   * }\n   * ```\n   *\n   * Namespace `calculator` is neither exported nor consumable, function `add` is exported (from `calculator`)\n   * but not consumable.\n   */\n  public get exported(): boolean {\n    // Exported from top-level?\n    if (this.exportedFromEntryPoint) return true;\n\n    // Exported from parent?\n    for (const localExportNames of this._localExportNamesByParent.values()) {\n      if (localExportNames.size > 0) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Indicates that it is possible for a consumer of the API to \"consume\" this entity, either by importing\n   * it directly or via a namespace. If an entity is not consumable, then API Extractor will report an\n   * `ae-forgotten-export` warning. Compare to `CollectorEntity.exported`.\n   *\n   * @remarks\n   * An API item is consumable if:\n   *\n   * 1. It is exported from the top-level entry point OR\n   * 2. It is exported from a consumable parent entity.\n   *\n   * For an example of #2, consider how `AstNamespaceImport` entities are processed. A generated rollup.d.ts\n   * might look like this:\n   *\n   * ```ts\n   * declare function add(): void;\n   * declare namespace calculator {\n   *   export {\n   *     add\n   *   }\n   * }\n   * export { calculator }\n   * ```\n   *\n   * In this example, `add` is exported via the consumable `calculator` namespace.\n   */\n  public get consumable(): boolean {\n    // Exported from top-level?\n    if (this.exportedFromEntryPoint) return true;\n\n    // Exported from consumable parent?\n    for (const [parent, localExportNames] of this._localExportNamesByParent) {\n      if (localExportNames.size > 0 && parent.consumable) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Return the first consumable parent that exports this entity. If there is none, returns\n   * `undefined`.\n   */\n  public getFirstExportingConsumableParent(): CollectorEntity | undefined {\n    for (const [parent, localExportNames] of this._localExportNamesByParent) {\n      if (parent.consumable && localExportNames.size > 0) {\n        return parent;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Adds a new export name to the entity.\n   */\n  public addExportName(exportName: string): void {\n    if (!this._exportNames.has(exportName)) {\n      this._exportNamesSorted = false;\n      this._exportNames.add(exportName);\n\n      if (this._exportNames.size === 1) {\n        this._singleExportName = exportName;\n      } else {\n        this._singleExportName = undefined;\n      }\n    }\n  }\n\n  /**\n   * Adds a new local export name to the entity.\n   *\n   * @remarks\n   * In the example below:\n   *\n   * ```ts\n   * declare function add(): void;\n   * declare namespace calculator {\n   *  export {\n   *    add\n   *  }\n   * }\n   * ```\n   *\n   * `add` is the local export name for the `CollectorEntity` for `add`.\n   */\n  public addLocalExportName(localExportName: string, parent: CollectorEntity): void {\n    const localExportNames: Set<string> = this._localExportNamesByParent.get(parent) || new Set();\n    localExportNames.add(localExportName);\n\n    this._localExportNamesByParent.set(parent, localExportNames);\n  }\n\n  /**\n   * A sorting key used by DtsRollupGenerator._makeUniqueNames()\n   */\n  public getSortKey(): string {\n    if (!this._sortKey) {\n      this._sortKey = Collector.getSortKeyIgnoringUnderscore(this.nameForEmit || this.astEntity.localName);\n    }\n    return this._sortKey;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"CollectorEntity.js","sourceRoot":"","sources":["../../src/collector/CollectorEntity.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\n\r\nimport { AstSymbol } from '../analyzer/AstSymbol';\r\nimport { Collector } from './Collector';\r\nimport { Sort } from '@rushstack/node-core-library';\r\nimport type { AstEntity } from '../analyzer/AstEntity';\r\n\r\n/**\r\n * This is a data structure used by the Collector to track an AstEntity that may be emitted in the *.d.ts file.\r\n *\r\n * @remarks\r\n * The additional contextual state beyond AstSymbol is:\r\n * - Whether it's an export of this entry point or not\r\n * - The nameForEmit, which may get renamed by DtsRollupGenerator._makeUniqueNames()\r\n * - The export name (or names, if the same symbol is exported multiple times)\r\n */\r\nexport class CollectorEntity {\r\n  /**\r\n   * The AstEntity that this entry represents.\r\n   */\r\n  public readonly astEntity: AstEntity;\r\n\r\n  private _exportNames: Set<string> = new Set();\r\n  private _exportNamesSorted: boolean = false;\r\n  private _singleExportName: string | undefined = undefined;\r\n  private _localExportNamesByParent: Map<CollectorEntity, Set<string>> = new Map();\r\n\r\n  private _nameForEmit: string | undefined = undefined;\r\n\r\n  private _sortKey: string | undefined = undefined;\r\n\r\n  public constructor(astEntity: AstEntity) {\r\n    this.astEntity = astEntity;\r\n  }\r\n\r\n  /**\r\n   * The declaration name that will be emitted in the .d.ts rollup, .api.md, and .api.json files. Generated by\r\n   * `Collector._makeUniqueNames`. Be aware that the declaration may be renamed to avoid conflicts with (1)\r\n   * global names (e.g. `Promise`) and (2) if local, other local names across different files.\r\n   */\r\n  public get nameForEmit(): string | undefined {\r\n    return this._nameForEmit;\r\n  }\r\n\r\n  public set nameForEmit(value: string | undefined) {\r\n    this._nameForEmit = value;\r\n    this._sortKey = undefined; // invalidate the cached value\r\n  }\r\n\r\n  /**\r\n   * The list of export names if this symbol is exported from the entry point.\r\n   *\r\n   * @remarks\r\n   * Note that a given symbol may be exported more than once:\r\n   * ```\r\n   * class X { }\r\n   * export { X }\r\n   * export { X as Y }\r\n   * ```\r\n   */\r\n  public get exportNames(): ReadonlySet<string> {\r\n    if (!this._exportNamesSorted) {\r\n      Sort.sortSet(this._exportNames);\r\n      this._exportNamesSorted = true;\r\n    }\r\n    return this._exportNames;\r\n  }\r\n\r\n  /**\r\n   * If exportNames contains only one string, then singleExportName is that string.\r\n   * In all other cases, it is undefined.\r\n   */\r\n  public get singleExportName(): string | undefined {\r\n    return this._singleExportName;\r\n  }\r\n\r\n  /**\r\n   * This is true if exportNames contains only one string, and the declaration can be exported using the inline syntax\r\n   * such as \"export class X { }\" instead of \"export { X }\".\r\n   */\r\n  public get shouldInlineExport(): boolean {\r\n    // We don't inline an AstImport\r\n    if (this.astEntity instanceof AstSymbol) {\r\n      // We don't inline a symbol with more than one exported name\r\n      if (this._singleExportName !== undefined && this._singleExportName !== ts.InternalSymbolName.Default) {\r\n        // We can't inline a symbol whose emitted name is different from the export name\r\n        if (this._nameForEmit === undefined || this._nameForEmit === this._singleExportName) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Indicates that this entity is exported from the package entry point. Compare to `CollectorEntity.exported`.\r\n   */\r\n  public get exportedFromEntryPoint(): boolean {\r\n    return this.exportNames.size > 0;\r\n  }\r\n\r\n  /**\r\n   * Indicates that this entity is exported from its parent module (i.e. either the package entry point or\r\n   * a local namespace). Compare to `CollectorEntity.consumable`.\r\n   *\r\n   * @remarks\r\n   * In the example below:\r\n   *\r\n   * ```ts\r\n   * declare function add(): void;\r\n   * declare namespace calculator {\r\n   *  export {\r\n   *    add\r\n   *  }\r\n   * }\r\n   * ```\r\n   *\r\n   * Namespace `calculator` is neither exported nor consumable, function `add` is exported (from `calculator`)\r\n   * but not consumable.\r\n   */\r\n  public get exported(): boolean {\r\n    // Exported from top-level?\r\n    if (this.exportedFromEntryPoint) return true;\r\n\r\n    // Exported from parent?\r\n    for (const localExportNames of this._localExportNamesByParent.values()) {\r\n      if (localExportNames.size > 0) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Indicates that it is possible for a consumer of the API to \"consume\" this entity, either by importing\r\n   * it directly or via a namespace. If an entity is not consumable, then API Extractor will report an\r\n   * `ae-forgotten-export` warning. Compare to `CollectorEntity.exported`.\r\n   *\r\n   * @remarks\r\n   * An API item is consumable if:\r\n   *\r\n   * 1. It is exported from the top-level entry point OR\r\n   * 2. It is exported from a consumable parent entity.\r\n   *\r\n   * For an example of #2, consider how `AstNamespaceImport` entities are processed. A generated rollup.d.ts\r\n   * might look like this:\r\n   *\r\n   * ```ts\r\n   * declare function add(): void;\r\n   * declare namespace calculator {\r\n   *   export {\r\n   *     add\r\n   *   }\r\n   * }\r\n   * export { calculator }\r\n   * ```\r\n   *\r\n   * In this example, `add` is exported via the consumable `calculator` namespace.\r\n   */\r\n  public get consumable(): boolean {\r\n    // Exported from top-level?\r\n    if (this.exportedFromEntryPoint) return true;\r\n\r\n    // Exported from consumable parent?\r\n    for (const [parent, localExportNames] of this._localExportNamesByParent) {\r\n      if (localExportNames.size > 0 && parent.consumable) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Return the first consumable parent that exports this entity. If there is none, returns\r\n   * `undefined`.\r\n   */\r\n  public getFirstExportingConsumableParent(): CollectorEntity | undefined {\r\n    for (const [parent, localExportNames] of this._localExportNamesByParent) {\r\n      if (parent.consumable && localExportNames.size > 0) {\r\n        return parent;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Adds a new export name to the entity.\r\n   */\r\n  public addExportName(exportName: string): void {\r\n    if (!this._exportNames.has(exportName)) {\r\n      this._exportNamesSorted = false;\r\n      this._exportNames.add(exportName);\r\n\r\n      if (this._exportNames.size === 1) {\r\n        this._singleExportName = exportName;\r\n      } else {\r\n        this._singleExportName = undefined;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a new local export name to the entity.\r\n   *\r\n   * @remarks\r\n   * In the example below:\r\n   *\r\n   * ```ts\r\n   * declare function add(): void;\r\n   * declare namespace calculator {\r\n   *  export {\r\n   *    add\r\n   *  }\r\n   * }\r\n   * ```\r\n   *\r\n   * `add` is the local export name for the `CollectorEntity` for `add`.\r\n   */\r\n  public addLocalExportName(localExportName: string, parent: CollectorEntity): void {\r\n    const localExportNames: Set<string> = this._localExportNamesByParent.get(parent) || new Set();\r\n    localExportNames.add(localExportName);\r\n\r\n    this._localExportNamesByParent.set(parent, localExportNames);\r\n  }\r\n\r\n  /**\r\n   * A sorting key used by DtsRollupGenerator._makeUniqueNames()\r\n   */\r\n  public getSortKey(): string {\r\n    if (!this._sortKey) {\r\n      this._sortKey = Collector.getSortKeyIgnoringUnderscore(this.nameForEmit || this.astEntity.localName);\r\n    }\r\n    return this._sortKey;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/collector/DeclarationMetadata.js.map b/lib/collector/DeclarationMetadata.js.map
index edaebcf0ab8374aa23c2063e311a2320da28f499..0684c4a232adcecfbe755c8c29442672306c86dd 100644
--- a/lib/collector/DeclarationMetadata.js.map
+++ b/lib/collector/DeclarationMetadata.js.map
@@ -1 +1 @@
-{"version":3,"file":"DeclarationMetadata.js","sourceRoot":"","sources":["../../src/collector/DeclarationMetadata.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAK3D;;;;;;;GAOG;AACH,MAAsB,mBAAmB;CAuBxC;AAvBD,kDAuBC;AAED;;GAEG;AACH,MAAa,2BAA4B,SAAQ,mBAAmB;IAApE;;QACS,uBAAkB,GAAoC,SAAS,CAAC;QAEhE,gBAAW,GAAY,KAAK,CAAC;QAE7B,0BAAqB,GAAqB,EAAE,CAAC;IACtD,CAAC;CAAA;AAND,kEAMC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type * as tsdoc from '@microsoft/tsdoc';\nimport type { AstDeclaration } from '../analyzer/AstDeclaration';\n\n/**\n * Stores the Collector's additional analysis for a specific `AstDeclaration` signature.  This object is assigned to\n * `AstDeclaration.declarationMetadata` but consumers must always obtain it by calling\n * `Collector.fetchDeclarationMetadata()`.\n *\n * Note that ancillary declarations share their `ApiItemMetadata` with the main declaration,\n * whereas a separate `DeclarationMetadata` object is created for each declaration.\n */\nexport abstract class DeclarationMetadata {\n  /**\n   * The ParserContext from when the TSDoc comment was parsed from the source code.\n   * If the source code did not contain a doc comment, then this will be undefined.\n   *\n   * Note that if an ancillary declaration has a doc comment, it is tracked here, whereas\n   * `ApiItemMetadata.tsdocComment` corresponds to documentation for the main declaration.\n   */\n  public abstract readonly tsdocParserContext: tsdoc.ParserContext | undefined;\n\n  /**\n   * If true, then this declaration is treated as part of another declaration.\n   */\n  public abstract readonly isAncillary: boolean;\n\n  /**\n   * A list of other declarations that are treated as being part of this declaration.  For example, a property\n   * getter/setter pair will be treated as a single API item, with the setter being treated as ancillary to the getter.\n   *\n   * If the `ancillaryDeclarations` array is non-empty, then `isAncillary` will be false for this declaration,\n   * and `isAncillary` will be true for all the array items.\n   */\n  public abstract readonly ancillaryDeclarations: ReadonlyArray<AstDeclaration>;\n}\n\n/**\n * Used internally by the `Collector` to build up `DeclarationMetadata`.\n */\nexport class InternalDeclarationMetadata extends DeclarationMetadata {\n  public tsdocParserContext: tsdoc.ParserContext | undefined = undefined;\n\n  public isAncillary: boolean = false;\n\n  public ancillaryDeclarations: AstDeclaration[] = [];\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"DeclarationMetadata.js","sourceRoot":"","sources":["../../src/collector/DeclarationMetadata.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAK3D;;;;;;;GAOG;AACH,MAAsB,mBAAmB;CAuBxC;AAvBD,kDAuBC;AAED;;GAEG;AACH,MAAa,2BAA4B,SAAQ,mBAAmB;IAApE;;QACS,uBAAkB,GAAoC,SAAS,CAAC;QAEhE,gBAAW,GAAY,KAAK,CAAC;QAE7B,0BAAqB,GAAqB,EAAE,CAAC;IACtD,CAAC;CAAA;AAND,kEAMC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport type * as tsdoc from '@microsoft/tsdoc';\r\nimport type { AstDeclaration } from '../analyzer/AstDeclaration';\r\n\r\n/**\r\n * Stores the Collector's additional analysis for a specific `AstDeclaration` signature.  This object is assigned to\r\n * `AstDeclaration.declarationMetadata` but consumers must always obtain it by calling\r\n * `Collector.fetchDeclarationMetadata()`.\r\n *\r\n * Note that ancillary declarations share their `ApiItemMetadata` with the main declaration,\r\n * whereas a separate `DeclarationMetadata` object is created for each declaration.\r\n */\r\nexport abstract class DeclarationMetadata {\r\n  /**\r\n   * The ParserContext from when the TSDoc comment was parsed from the source code.\r\n   * If the source code did not contain a doc comment, then this will be undefined.\r\n   *\r\n   * Note that if an ancillary declaration has a doc comment, it is tracked here, whereas\r\n   * `ApiItemMetadata.tsdocComment` corresponds to documentation for the main declaration.\r\n   */\r\n  public abstract readonly tsdocParserContext: tsdoc.ParserContext | undefined;\r\n\r\n  /**\r\n   * If true, then this declaration is treated as part of another declaration.\r\n   */\r\n  public abstract readonly isAncillary: boolean;\r\n\r\n  /**\r\n   * A list of other declarations that are treated as being part of this declaration.  For example, a property\r\n   * getter/setter pair will be treated as a single API item, with the setter being treated as ancillary to the getter.\r\n   *\r\n   * If the `ancillaryDeclarations` array is non-empty, then `isAncillary` will be false for this declaration,\r\n   * and `isAncillary` will be true for all the array items.\r\n   */\r\n  public abstract readonly ancillaryDeclarations: ReadonlyArray<AstDeclaration>;\r\n}\r\n\r\n/**\r\n * Used internally by the `Collector` to build up `DeclarationMetadata`.\r\n */\r\nexport class InternalDeclarationMetadata extends DeclarationMetadata {\r\n  public tsdocParserContext: tsdoc.ParserContext | undefined = undefined;\r\n\r\n  public isAncillary: boolean = false;\r\n\r\n  public ancillaryDeclarations: AstDeclaration[] = [];\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/collector/MessageRouter.js.map b/lib/collector/MessageRouter.js.map
index fa9d71dbfb887bb90a2a4f9d048ddf008baded32..1ca4f0554a3b2352285cac908f9ed57d930516e7 100644
--- a/lib/collector/MessageRouter.js.map
+++ b/lib/collector/MessageRouter.js.map
@@ -1 +1 @@
-{"version":3,"file":"MessageRouter.js","sourceRoot":"","sources":["../../src/collector/MessageRouter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport colors from 'colors';\nimport * as ts from 'typescript';\nimport type * as tsdoc from '@microsoft/tsdoc';\nimport { Sort, InternalError } from '@rushstack/node-core-library';\n\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\nimport type { AstSymbol } from '../analyzer/AstSymbol';\nimport {\n  ExtractorMessage,\n  ExtractorMessageCategory,\n  type IExtractorMessageOptions,\n  type IExtractorMessageProperties\n} from '../api/ExtractorMessage';\nimport { type ExtractorMessageId, allExtractorMessageIds } from '../api/ExtractorMessageId';\nimport type { IExtractorMessagesConfig, IConfigMessageReportingRule } from '../api/IConfigFile';\nimport type { ISourceLocation, SourceMapper } from './SourceMapper';\nimport { ExtractorLogLevel } from '../api/ExtractorLogLevel';\nimport { ConsoleMessageId } from '../api/ConsoleMessageId';\n\ninterface IReportingRule {\n  logLevel: ExtractorLogLevel;\n  addToApiReportFile: boolean;\n}\n\nexport interface IMessageRouterOptions {\n  workingPackageFolder: string | undefined;\n  messageCallback: ((message: ExtractorMessage) => void) | undefined;\n  messagesConfig: IExtractorMessagesConfig;\n  showVerboseMessages: boolean;\n  showDiagnostics: boolean;\n  tsdocConfiguration: tsdoc.TSDocConfiguration;\n  sourceMapper: SourceMapper;\n}\n\nexport interface IBuildJsonDumpObjectOptions {\n  /**\n   * {@link MessageRouter.buildJsonDumpObject} will omit any objects keys with these names.\n   */\n  keyNamesToOmit?: string[];\n}\n\nexport class MessageRouter {\n  public static readonly DIAGNOSTICS_LINE: string =\n    '============================================================';\n\n  private readonly _workingPackageFolder: string | undefined;\n  private readonly _messageCallback: ((message: ExtractorMessage) => void) | undefined;\n\n  // All messages\n  private readonly _messages: ExtractorMessage[];\n\n  // For each AstDeclaration, the messages associated with it.  This is used when addToApiReportFile=true\n  private readonly _associatedMessagesForAstDeclaration: Map<AstDeclaration, ExtractorMessage[]>;\n\n  private readonly _sourceMapper: SourceMapper;\n\n  private readonly _tsdocConfiguration: tsdoc.TSDocConfiguration;\n\n  // Normalized representation of the routing rules from api-extractor.json\n  private _reportingRuleByMessageId: Map<string, IReportingRule> = new Map<string, IReportingRule>();\n  private _compilerDefaultRule: IReportingRule = {\n    logLevel: ExtractorLogLevel.None,\n    addToApiReportFile: false\n  };\n  private _extractorDefaultRule: IReportingRule = {\n    logLevel: ExtractorLogLevel.None,\n    addToApiReportFile: false\n  };\n  private _tsdocDefaultRule: IReportingRule = { logLevel: ExtractorLogLevel.None, addToApiReportFile: false };\n\n  public errorCount: number = 0;\n  public warningCount: number = 0;\n\n  /**\n   * See {@link IExtractorInvokeOptions.showVerboseMessages}\n   */\n  public readonly showVerboseMessages: boolean;\n\n  /**\n   * See {@link IExtractorInvokeOptions.showDiagnostics}\n   */\n  public readonly showDiagnostics: boolean;\n\n  public constructor(options: IMessageRouterOptions) {\n    this._workingPackageFolder = options.workingPackageFolder;\n    this._messageCallback = options.messageCallback;\n\n    this._messages = [];\n    this._associatedMessagesForAstDeclaration = new Map<AstDeclaration, ExtractorMessage[]>();\n    this._sourceMapper = options.sourceMapper;\n    this._tsdocConfiguration = options.tsdocConfiguration;\n\n    // showDiagnostics implies showVerboseMessages\n    this.showVerboseMessages = options.showVerboseMessages || options.showDiagnostics;\n    this.showDiagnostics = options.showDiagnostics;\n\n    this._applyMessagesConfig(options.messagesConfig);\n  }\n\n  /**\n   * Read the api-extractor.json configuration and build up the tables of routing rules.\n   */\n  private _applyMessagesConfig(messagesConfig: IExtractorMessagesConfig): void {\n    if (messagesConfig.compilerMessageReporting) {\n      for (const messageId of Object.getOwnPropertyNames(messagesConfig.compilerMessageReporting)) {\n        const reportingRule: IReportingRule = MessageRouter._getNormalizedRule(\n          messagesConfig.compilerMessageReporting[messageId]\n        );\n\n        if (messageId === 'default') {\n          this._compilerDefaultRule = reportingRule;\n        } else if (!/^TS[0-9]+$/.test(messageId)) {\n          throw new Error(\n            `Error in API Extractor config: The messages.compilerMessageReporting table contains` +\n              ` an invalid entry \"${messageId}\". The identifier format is \"TS\" followed by an integer.`\n          );\n        } else {\n          this._reportingRuleByMessageId.set(messageId, reportingRule);\n        }\n      }\n    }\n\n    if (messagesConfig.extractorMessageReporting) {\n      for (const messageId of Object.getOwnPropertyNames(messagesConfig.extractorMessageReporting)) {\n        const reportingRule: IReportingRule = MessageRouter._getNormalizedRule(\n          messagesConfig.extractorMessageReporting[messageId]\n        );\n\n        if (messageId === 'default') {\n          this._extractorDefaultRule = reportingRule;\n        } else if (!/^ae-/.test(messageId)) {\n          throw new Error(\n            `Error in API Extractor config: The messages.extractorMessageReporting table contains` +\n              ` an invalid entry \"${messageId}\".  The name should begin with the \"ae-\" prefix.`\n          );\n        } else if (!allExtractorMessageIds.has(messageId)) {\n          throw new Error(\n            `Error in API Extractor config: The messages.extractorMessageReporting table contains` +\n              ` an unrecognized identifier \"${messageId}\".  Is it spelled correctly?`\n          );\n        } else {\n          this._reportingRuleByMessageId.set(messageId, reportingRule);\n        }\n      }\n    }\n\n    if (messagesConfig.tsdocMessageReporting) {\n      for (const messageId of Object.getOwnPropertyNames(messagesConfig.tsdocMessageReporting)) {\n        const reportingRule: IReportingRule = MessageRouter._getNormalizedRule(\n          messagesConfig.tsdocMessageReporting[messageId]\n        );\n\n        if (messageId === 'default') {\n          this._tsdocDefaultRule = reportingRule;\n        } else if (!/^tsdoc-/.test(messageId)) {\n          throw new Error(\n            `Error in API Extractor config: The messages.tsdocMessageReporting table contains` +\n              ` an invalid entry \"${messageId}\".  The name should begin with the \"tsdoc-\" prefix.`\n          );\n        } else if (!this._tsdocConfiguration.isKnownMessageId(messageId)) {\n          throw new Error(\n            `Error in API Extractor config: The messages.tsdocMessageReporting table contains` +\n              ` an unrecognized identifier \"${messageId}\".  Is it spelled correctly?`\n          );\n        } else {\n          this._reportingRuleByMessageId.set(messageId, reportingRule);\n        }\n      }\n    }\n  }\n\n  private static _getNormalizedRule(rule: IConfigMessageReportingRule): IReportingRule {\n    return {\n      logLevel: rule.logLevel || 'none',\n      addToApiReportFile: rule.addToApiReportFile || false\n    };\n  }\n\n  public get messages(): ReadonlyArray<ExtractorMessage> {\n    return this._messages;\n  }\n\n  /**\n   * Add a diagnostic message reported by the TypeScript compiler\n   */\n  public addCompilerDiagnostic(diagnostic: ts.Diagnostic): void {\n    switch (diagnostic.category) {\n      case ts.DiagnosticCategory.Suggestion:\n      case ts.DiagnosticCategory.Message:\n        return; // ignore noise\n    }\n\n    const messageText: string = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\\n');\n    const options: IExtractorMessageOptions = {\n      category: ExtractorMessageCategory.Compiler,\n      messageId: `TS${diagnostic.code}`,\n      text: messageText\n    };\n\n    if (diagnostic.file) {\n      // NOTE: Since compiler errors pertain to issues specific to the .d.ts files,\n      // we do not apply source mappings for them.\n      const sourceFile: ts.SourceFile = diagnostic.file;\n      const sourceLocation: ISourceLocation = this._sourceMapper.getSourceLocation({\n        sourceFile,\n        pos: diagnostic.start || 0,\n        useDtsLocation: true\n      });\n      options.sourceFilePath = sourceLocation.sourceFilePath;\n      options.sourceFileLine = sourceLocation.sourceFileLine;\n      options.sourceFileColumn = sourceLocation.sourceFileColumn;\n    }\n\n    this._messages.push(new ExtractorMessage(options));\n  }\n\n  /**\n   * Add a message from the API Extractor analysis\n   */\n  public addAnalyzerIssue(\n    messageId: ExtractorMessageId,\n    messageText: string,\n    astDeclarationOrSymbol: AstDeclaration | AstSymbol,\n    properties?: IExtractorMessageProperties\n  ): void {\n    let astDeclaration: AstDeclaration;\n    if (astDeclarationOrSymbol instanceof AstDeclaration) {\n      astDeclaration = astDeclarationOrSymbol;\n    } else {\n      astDeclaration = astDeclarationOrSymbol.astDeclarations[0];\n    }\n\n    const extractorMessage: ExtractorMessage = this.addAnalyzerIssueForPosition(\n      messageId,\n      messageText,\n      astDeclaration.declaration.getSourceFile(),\n      astDeclaration.declaration.getStart(),\n      properties\n    );\n\n    this._associateMessageWithAstDeclaration(extractorMessage, astDeclaration);\n  }\n\n  /**\n   * Add all messages produced from an invocation of the TSDoc parser, assuming they refer to\n   * code in the specified source file.\n   */\n  public addTsdocMessages(\n    parserContext: tsdoc.ParserContext,\n    sourceFile: ts.SourceFile,\n    astDeclaration?: AstDeclaration\n  ): void {\n    for (const message of parserContext.log.messages) {\n      const options: IExtractorMessageOptions = {\n        category: ExtractorMessageCategory.TSDoc,\n        messageId: message.messageId,\n        text: message.unformattedText\n      };\n\n      const sourceLocation: ISourceLocation = this._sourceMapper.getSourceLocation({\n        sourceFile,\n        pos: message.textRange.pos\n      });\n      options.sourceFilePath = sourceLocation.sourceFilePath;\n      options.sourceFileLine = sourceLocation.sourceFileLine;\n      options.sourceFileColumn = sourceLocation.sourceFileColumn;\n\n      const extractorMessage: ExtractorMessage = new ExtractorMessage(options);\n\n      if (astDeclaration) {\n        this._associateMessageWithAstDeclaration(extractorMessage, astDeclaration);\n      }\n\n      this._messages.push(extractorMessage);\n    }\n  }\n\n  /**\n   * Recursively collects the primitive members (numbers, strings, arrays, etc) into an object that\n   * is JSON serializable.  This is used by the \"--diagnostics\" feature to dump the state of configuration objects.\n   *\n   * @returns a JSON serializable object (possibly including `null` values)\n   *          or `undefined` if the input cannot be represented as JSON\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public static buildJsonDumpObject(input: any, options?: IBuildJsonDumpObjectOptions): any | undefined {\n    if (!options) {\n      options = {};\n    }\n\n    const keyNamesToOmit: Set<string> = new Set(options.keyNamesToOmit);\n\n    return MessageRouter._buildJsonDumpObject(input, keyNamesToOmit);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private static _buildJsonDumpObject(input: any, keyNamesToOmit: Set<string>): any | undefined {\n    if (input === null || input === undefined) {\n      return null; // JSON uses null instead of undefined\n    }\n\n    switch (typeof input) {\n      case 'boolean':\n      case 'number':\n      case 'string':\n        return input;\n      case 'object':\n        if (Array.isArray(input)) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const outputArray: any[] = [];\n          for (const element of input) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const serializedElement: any = MessageRouter._buildJsonDumpObject(element, keyNamesToOmit);\n            if (serializedElement !== undefined) {\n              outputArray.push(serializedElement);\n            }\n          }\n          return outputArray;\n        }\n\n        const outputObject: object = {};\n        for (const key of Object.getOwnPropertyNames(input)) {\n          if (keyNamesToOmit.has(key)) {\n            continue;\n          }\n\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const value: any = input[key];\n\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const serializedValue: any = MessageRouter._buildJsonDumpObject(value, keyNamesToOmit);\n\n          if (serializedValue !== undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (outputObject as any)[key] = serializedValue;\n          }\n        }\n        return outputObject;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Record this message in  _associatedMessagesForAstDeclaration\n   */\n  private _associateMessageWithAstDeclaration(\n    extractorMessage: ExtractorMessage,\n    astDeclaration: AstDeclaration\n  ): void {\n    let associatedMessages: ExtractorMessage[] | undefined =\n      this._associatedMessagesForAstDeclaration.get(astDeclaration);\n\n    if (!associatedMessages) {\n      associatedMessages = [];\n      this._associatedMessagesForAstDeclaration.set(astDeclaration, associatedMessages);\n    }\n    associatedMessages.push(extractorMessage);\n  }\n\n  /**\n   * Add a message for a location in an arbitrary source file.\n   */\n  public addAnalyzerIssueForPosition(\n    messageId: ExtractorMessageId,\n    messageText: string,\n    sourceFile: ts.SourceFile,\n    pos: number,\n    properties?: IExtractorMessageProperties\n  ): ExtractorMessage {\n    const options: IExtractorMessageOptions = {\n      category: ExtractorMessageCategory.Extractor,\n      messageId,\n      text: messageText,\n      properties\n    };\n\n    const sourceLocation: ISourceLocation = this._sourceMapper.getSourceLocation({\n      sourceFile,\n      pos\n    });\n    options.sourceFilePath = sourceLocation.sourceFilePath;\n    options.sourceFileLine = sourceLocation.sourceFileLine;\n    options.sourceFileColumn = sourceLocation.sourceFileColumn;\n\n    const extractorMessage: ExtractorMessage = new ExtractorMessage(options);\n\n    this._messages.push(extractorMessage);\n    return extractorMessage;\n  }\n\n  /**\n   * This is used when writing the API report file.  It looks up any messages that were configured to get emitted\n   * in the API report file and returns them.  It also records that they were emitted, which suppresses them from\n   * being shown on the console.\n   */\n  public fetchAssociatedMessagesForReviewFile(astDeclaration: AstDeclaration): ExtractorMessage[] {\n    const messagesForApiReportFile: ExtractorMessage[] = [];\n\n    const associatedMessages: ExtractorMessage[] =\n      this._associatedMessagesForAstDeclaration.get(astDeclaration) || [];\n    for (const associatedMessage of associatedMessages) {\n      // Make sure we didn't already report this message for some reason\n      if (!associatedMessage.handled) {\n        // Is this message type configured to go in the API report file?\n        const reportingRule: IReportingRule = this._getRuleForMessage(associatedMessage);\n        if (reportingRule.addToApiReportFile) {\n          // Include it in the result, and record that it went to the API report file\n          messagesForApiReportFile.push(associatedMessage);\n          associatedMessage.handled = true;\n        }\n      }\n    }\n\n    this._sortMessagesForOutput(messagesForApiReportFile);\n    return messagesForApiReportFile;\n  }\n\n  /**\n   * This returns all remaining messages that were flagged with `addToApiReportFile`, but which were not\n   * retreieved using `fetchAssociatedMessagesForReviewFile()`.\n   */\n  public fetchUnassociatedMessagesForReviewFile(): ExtractorMessage[] {\n    const messagesForApiReportFile: ExtractorMessage[] = [];\n\n    for (const unassociatedMessage of this.messages) {\n      // Make sure we didn't already report this message for some reason\n      if (!unassociatedMessage.handled) {\n        // Is this message type configured to go in the API report file?\n        const reportingRule: IReportingRule = this._getRuleForMessage(unassociatedMessage);\n        if (reportingRule.addToApiReportFile) {\n          // Include it in the result, and record that it went to the API report file\n          messagesForApiReportFile.push(unassociatedMessage);\n          unassociatedMessage.handled = true;\n        }\n      }\n    }\n\n    this._sortMessagesForOutput(messagesForApiReportFile);\n    return messagesForApiReportFile;\n  }\n\n  /**\n   * This returns the list of remaining messages that were not already processed by\n   * `fetchAssociatedMessagesForReviewFile()` or `fetchUnassociatedMessagesForReviewFile()`.\n   * These messages will be shown on the console.\n   */\n  public handleRemainingNonConsoleMessages(): void {\n    const messagesForLogger: ExtractorMessage[] = [];\n\n    for (const message of this.messages) {\n      // Make sure we didn't already report this message\n      if (!message.handled) {\n        messagesForLogger.push(message);\n      }\n    }\n\n    this._sortMessagesForOutput(messagesForLogger);\n\n    for (const message of messagesForLogger) {\n      this._handleMessage(message);\n    }\n  }\n\n  public logError(\n    messageId: ConsoleMessageId,\n    message: string,\n    properties?: IExtractorMessageProperties\n  ): void {\n    this._handleMessage(\n      new ExtractorMessage({\n        category: ExtractorMessageCategory.Console,\n        messageId,\n        text: message,\n        properties,\n        logLevel: ExtractorLogLevel.Error\n      })\n    );\n  }\n\n  public logWarning(\n    messageId: ConsoleMessageId,\n    message: string,\n    properties?: IExtractorMessageProperties\n  ): void {\n    this._handleMessage(\n      new ExtractorMessage({\n        category: ExtractorMessageCategory.Console,\n        messageId,\n        text: message,\n        properties,\n        logLevel: ExtractorLogLevel.Warning\n      })\n    );\n  }\n\n  public logInfo(\n    messageId: ConsoleMessageId,\n    message: string,\n    properties?: IExtractorMessageProperties\n  ): void {\n    this._handleMessage(\n      new ExtractorMessage({\n        category: ExtractorMessageCategory.Console,\n        messageId,\n        text: message,\n        properties,\n        logLevel: ExtractorLogLevel.Info\n      })\n    );\n  }\n\n  public logVerbose(\n    messageId: ConsoleMessageId,\n    message: string,\n    properties?: IExtractorMessageProperties\n  ): void {\n    this._handleMessage(\n      new ExtractorMessage({\n        category: ExtractorMessageCategory.Console,\n        messageId,\n        text: message,\n        properties,\n        logLevel: ExtractorLogLevel.Verbose\n      })\n    );\n  }\n\n  public logDiagnosticHeader(title: string): void {\n    this.logDiagnostic(MessageRouter.DIAGNOSTICS_LINE);\n    this.logDiagnostic(`DIAGNOSTIC: ` + title);\n    this.logDiagnostic(MessageRouter.DIAGNOSTICS_LINE);\n  }\n\n  public logDiagnosticFooter(): void {\n    this.logDiagnostic(MessageRouter.DIAGNOSTICS_LINE + '\\n');\n  }\n\n  public logDiagnostic(message: string): void {\n    if (this.showDiagnostics) {\n      this.logVerbose(ConsoleMessageId.Diagnostics, message);\n    }\n  }\n\n  /**\n   * Give the calling application a chance to handle the `ExtractorMessage`, and if not, display it on the console.\n   */\n  private _handleMessage(message: ExtractorMessage): void {\n    // Don't tally messages that were already \"handled\" by writing them into the API report\n    if (message.handled) {\n      return;\n    }\n\n    // Assign the ExtractorMessage.logLevel; the message callback may adjust it below\n    if (message.category === ExtractorMessageCategory.Console) {\n      // Console messages have their category log level assigned via logInfo(), logVerbose(), etc.\n    } else {\n      const reportingRule: IReportingRule = this._getRuleForMessage(message);\n      message.logLevel = reportingRule.logLevel;\n    }\n\n    // If there is a callback, allow it to modify and/or handle the message\n    if (this._messageCallback) {\n      this._messageCallback(message);\n    }\n\n    // Update the statistics\n    switch (message.logLevel) {\n      case ExtractorLogLevel.Error:\n        ++this.errorCount;\n        break;\n      case ExtractorLogLevel.Warning:\n        ++this.warningCount;\n        break;\n    }\n\n    if (message.handled) {\n      return;\n    }\n\n    // The messageCallback did not handle the message, so perform default handling\n    message.handled = true;\n\n    if (message.logLevel === ExtractorLogLevel.None) {\n      return;\n    }\n\n    let messageText: string;\n    if (message.category === ExtractorMessageCategory.Console) {\n      messageText = message.text;\n    } else {\n      messageText = message.formatMessageWithLocation(this._workingPackageFolder);\n    }\n\n    switch (message.logLevel) {\n      case ExtractorLogLevel.Error:\n        console.error(colors.red('Error: ' + messageText));\n        break;\n      case ExtractorLogLevel.Warning:\n        console.warn(colors.yellow('Warning: ' + messageText));\n        break;\n      case ExtractorLogLevel.Info:\n        console.log(messageText);\n        break;\n      case ExtractorLogLevel.Verbose:\n        if (this.showVerboseMessages) {\n          console.log(colors.cyan(messageText));\n        }\n        break;\n      default:\n        throw new Error(`Invalid logLevel value: ${JSON.stringify(message.logLevel)}`);\n    }\n  }\n\n  /**\n   * For a given message, determine the IReportingRule based on the rule tables.\n   */\n  private _getRuleForMessage(message: ExtractorMessage): IReportingRule {\n    const reportingRule: IReportingRule | undefined = this._reportingRuleByMessageId.get(message.messageId);\n    if (reportingRule) {\n      return reportingRule;\n    }\n    switch (message.category) {\n      case ExtractorMessageCategory.Compiler:\n        return this._compilerDefaultRule;\n      case ExtractorMessageCategory.Extractor:\n        return this._extractorDefaultRule;\n      case ExtractorMessageCategory.TSDoc:\n        return this._tsdocDefaultRule;\n      case ExtractorMessageCategory.Console:\n        throw new InternalError('ExtractorMessageCategory.Console is not supported with IReportingRule');\n    }\n  }\n\n  /**\n   * Sorts an array of messages according to a reasonable ordering\n   */\n  private _sortMessagesForOutput(messages: ExtractorMessage[]): void {\n    messages.sort((a, b) => {\n      let diff: number;\n      // First sort by file name\n      diff = Sort.compareByValue(a.sourceFilePath, b.sourceFilePath);\n      if (diff !== 0) {\n        return diff;\n      }\n      // Then sort by line number\n      diff = Sort.compareByValue(a.sourceFileLine, b.sourceFileLine);\n      if (diff !== 0) {\n        return diff;\n      }\n      // Then sort by messageId\n      return Sort.compareByValue(a.messageId, b.messageId);\n    });\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"MessageRouter.js","sourceRoot":"","sources":["../../src/collector/MessageRouter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport colors from 'colors';\r\nimport * as ts from 'typescript';\r\nimport type * as tsdoc from '@microsoft/tsdoc';\r\nimport { Sort, InternalError } from '@rushstack/node-core-library';\r\n\r\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\r\nimport type { AstSymbol } from '../analyzer/AstSymbol';\r\nimport {\r\n  ExtractorMessage,\r\n  ExtractorMessageCategory,\r\n  type IExtractorMessageOptions,\r\n  type IExtractorMessageProperties\r\n} from '../api/ExtractorMessage';\r\nimport { type ExtractorMessageId, allExtractorMessageIds } from '../api/ExtractorMessageId';\r\nimport type { IExtractorMessagesConfig, IConfigMessageReportingRule } from '../api/IConfigFile';\r\nimport type { ISourceLocation, SourceMapper } from './SourceMapper';\r\nimport { ExtractorLogLevel } from '../api/ExtractorLogLevel';\r\nimport { ConsoleMessageId } from '../api/ConsoleMessageId';\r\n\r\ninterface IReportingRule {\r\n  logLevel: ExtractorLogLevel;\r\n  addToApiReportFile: boolean;\r\n}\r\n\r\nexport interface IMessageRouterOptions {\r\n  workingPackageFolder: string | undefined;\r\n  messageCallback: ((message: ExtractorMessage) => void) | undefined;\r\n  messagesConfig: IExtractorMessagesConfig;\r\n  showVerboseMessages: boolean;\r\n  showDiagnostics: boolean;\r\n  tsdocConfiguration: tsdoc.TSDocConfiguration;\r\n  sourceMapper: SourceMapper;\r\n}\r\n\r\nexport interface IBuildJsonDumpObjectOptions {\r\n  /**\r\n   * {@link MessageRouter.buildJsonDumpObject} will omit any objects keys with these names.\r\n   */\r\n  keyNamesToOmit?: string[];\r\n}\r\n\r\nexport class MessageRouter {\r\n  public static readonly DIAGNOSTICS_LINE: string =\r\n    '============================================================';\r\n\r\n  private readonly _workingPackageFolder: string | undefined;\r\n  private readonly _messageCallback: ((message: ExtractorMessage) => void) | undefined;\r\n\r\n  // All messages\r\n  private readonly _messages: ExtractorMessage[];\r\n\r\n  // For each AstDeclaration, the messages associated with it.  This is used when addToApiReportFile=true\r\n  private readonly _associatedMessagesForAstDeclaration: Map<AstDeclaration, ExtractorMessage[]>;\r\n\r\n  private readonly _sourceMapper: SourceMapper;\r\n\r\n  private readonly _tsdocConfiguration: tsdoc.TSDocConfiguration;\r\n\r\n  // Normalized representation of the routing rules from api-extractor.json\r\n  private _reportingRuleByMessageId: Map<string, IReportingRule> = new Map<string, IReportingRule>();\r\n  private _compilerDefaultRule: IReportingRule = {\r\n    logLevel: ExtractorLogLevel.None,\r\n    addToApiReportFile: false\r\n  };\r\n  private _extractorDefaultRule: IReportingRule = {\r\n    logLevel: ExtractorLogLevel.None,\r\n    addToApiReportFile: false\r\n  };\r\n  private _tsdocDefaultRule: IReportingRule = { logLevel: ExtractorLogLevel.None, addToApiReportFile: false };\r\n\r\n  public errorCount: number = 0;\r\n  public warningCount: number = 0;\r\n\r\n  /**\r\n   * See {@link IExtractorInvokeOptions.showVerboseMessages}\r\n   */\r\n  public readonly showVerboseMessages: boolean;\r\n\r\n  /**\r\n   * See {@link IExtractorInvokeOptions.showDiagnostics}\r\n   */\r\n  public readonly showDiagnostics: boolean;\r\n\r\n  public constructor(options: IMessageRouterOptions) {\r\n    this._workingPackageFolder = options.workingPackageFolder;\r\n    this._messageCallback = options.messageCallback;\r\n\r\n    this._messages = [];\r\n    this._associatedMessagesForAstDeclaration = new Map<AstDeclaration, ExtractorMessage[]>();\r\n    this._sourceMapper = options.sourceMapper;\r\n    this._tsdocConfiguration = options.tsdocConfiguration;\r\n\r\n    // showDiagnostics implies showVerboseMessages\r\n    this.showVerboseMessages = options.showVerboseMessages || options.showDiagnostics;\r\n    this.showDiagnostics = options.showDiagnostics;\r\n\r\n    this._applyMessagesConfig(options.messagesConfig);\r\n  }\r\n\r\n  /**\r\n   * Read the api-extractor.json configuration and build up the tables of routing rules.\r\n   */\r\n  private _applyMessagesConfig(messagesConfig: IExtractorMessagesConfig): void {\r\n    if (messagesConfig.compilerMessageReporting) {\r\n      for (const messageId of Object.getOwnPropertyNames(messagesConfig.compilerMessageReporting)) {\r\n        const reportingRule: IReportingRule = MessageRouter._getNormalizedRule(\r\n          messagesConfig.compilerMessageReporting[messageId]\r\n        );\r\n\r\n        if (messageId === 'default') {\r\n          this._compilerDefaultRule = reportingRule;\r\n        } else if (!/^TS[0-9]+$/.test(messageId)) {\r\n          throw new Error(\r\n            `Error in API Extractor config: The messages.compilerMessageReporting table contains` +\r\n              ` an invalid entry \"${messageId}\". The identifier format is \"TS\" followed by an integer.`\r\n          );\r\n        } else {\r\n          this._reportingRuleByMessageId.set(messageId, reportingRule);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (messagesConfig.extractorMessageReporting) {\r\n      for (const messageId of Object.getOwnPropertyNames(messagesConfig.extractorMessageReporting)) {\r\n        const reportingRule: IReportingRule = MessageRouter._getNormalizedRule(\r\n          messagesConfig.extractorMessageReporting[messageId]\r\n        );\r\n\r\n        if (messageId === 'default') {\r\n          this._extractorDefaultRule = reportingRule;\r\n        } else if (!/^ae-/.test(messageId)) {\r\n          throw new Error(\r\n            `Error in API Extractor config: The messages.extractorMessageReporting table contains` +\r\n              ` an invalid entry \"${messageId}\".  The name should begin with the \"ae-\" prefix.`\r\n          );\r\n        } else if (!allExtractorMessageIds.has(messageId)) {\r\n          throw new Error(\r\n            `Error in API Extractor config: The messages.extractorMessageReporting table contains` +\r\n              ` an unrecognized identifier \"${messageId}\".  Is it spelled correctly?`\r\n          );\r\n        } else {\r\n          this._reportingRuleByMessageId.set(messageId, reportingRule);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (messagesConfig.tsdocMessageReporting) {\r\n      for (const messageId of Object.getOwnPropertyNames(messagesConfig.tsdocMessageReporting)) {\r\n        const reportingRule: IReportingRule = MessageRouter._getNormalizedRule(\r\n          messagesConfig.tsdocMessageReporting[messageId]\r\n        );\r\n\r\n        if (messageId === 'default') {\r\n          this._tsdocDefaultRule = reportingRule;\r\n        } else if (!/^tsdoc-/.test(messageId)) {\r\n          throw new Error(\r\n            `Error in API Extractor config: The messages.tsdocMessageReporting table contains` +\r\n              ` an invalid entry \"${messageId}\".  The name should begin with the \"tsdoc-\" prefix.`\r\n          );\r\n        } else if (!this._tsdocConfiguration.isKnownMessageId(messageId)) {\r\n          throw new Error(\r\n            `Error in API Extractor config: The messages.tsdocMessageReporting table contains` +\r\n              ` an unrecognized identifier \"${messageId}\".  Is it spelled correctly?`\r\n          );\r\n        } else {\r\n          this._reportingRuleByMessageId.set(messageId, reportingRule);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _getNormalizedRule(rule: IConfigMessageReportingRule): IReportingRule {\r\n    return {\r\n      logLevel: rule.logLevel || 'none',\r\n      addToApiReportFile: rule.addToApiReportFile || false\r\n    };\r\n  }\r\n\r\n  public get messages(): ReadonlyArray<ExtractorMessage> {\r\n    return this._messages;\r\n  }\r\n\r\n  /**\r\n   * Add a diagnostic message reported by the TypeScript compiler\r\n   */\r\n  public addCompilerDiagnostic(diagnostic: ts.Diagnostic): void {\r\n    switch (diagnostic.category) {\r\n      case ts.DiagnosticCategory.Suggestion:\r\n      case ts.DiagnosticCategory.Message:\r\n        return; // ignore noise\r\n    }\r\n\r\n    const messageText: string = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\\n');\r\n    const options: IExtractorMessageOptions = {\r\n      category: ExtractorMessageCategory.Compiler,\r\n      messageId: `TS${diagnostic.code}`,\r\n      text: messageText\r\n    };\r\n\r\n    if (diagnostic.file) {\r\n      // NOTE: Since compiler errors pertain to issues specific to the .d.ts files,\r\n      // we do not apply source mappings for them.\r\n      const sourceFile: ts.SourceFile = diagnostic.file;\r\n      const sourceLocation: ISourceLocation = this._sourceMapper.getSourceLocation({\r\n        sourceFile,\r\n        pos: diagnostic.start || 0,\r\n        useDtsLocation: true\r\n      });\r\n      options.sourceFilePath = sourceLocation.sourceFilePath;\r\n      options.sourceFileLine = sourceLocation.sourceFileLine;\r\n      options.sourceFileColumn = sourceLocation.sourceFileColumn;\r\n    }\r\n\r\n    this._messages.push(new ExtractorMessage(options));\r\n  }\r\n\r\n  /**\r\n   * Add a message from the API Extractor analysis\r\n   */\r\n  public addAnalyzerIssue(\r\n    messageId: ExtractorMessageId,\r\n    messageText: string,\r\n    astDeclarationOrSymbol: AstDeclaration | AstSymbol,\r\n    properties?: IExtractorMessageProperties\r\n  ): void {\r\n    let astDeclaration: AstDeclaration;\r\n    if (astDeclarationOrSymbol instanceof AstDeclaration) {\r\n      astDeclaration = astDeclarationOrSymbol;\r\n    } else {\r\n      astDeclaration = astDeclarationOrSymbol.astDeclarations[0];\r\n    }\r\n\r\n    const extractorMessage: ExtractorMessage = this.addAnalyzerIssueForPosition(\r\n      messageId,\r\n      messageText,\r\n      astDeclaration.declaration.getSourceFile(),\r\n      astDeclaration.declaration.getStart(),\r\n      properties\r\n    );\r\n\r\n    this._associateMessageWithAstDeclaration(extractorMessage, astDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Add all messages produced from an invocation of the TSDoc parser, assuming they refer to\r\n   * code in the specified source file.\r\n   */\r\n  public addTsdocMessages(\r\n    parserContext: tsdoc.ParserContext,\r\n    sourceFile: ts.SourceFile,\r\n    astDeclaration?: AstDeclaration\r\n  ): void {\r\n    for (const message of parserContext.log.messages) {\r\n      const options: IExtractorMessageOptions = {\r\n        category: ExtractorMessageCategory.TSDoc,\r\n        messageId: message.messageId,\r\n        text: message.unformattedText\r\n      };\r\n\r\n      const sourceLocation: ISourceLocation = this._sourceMapper.getSourceLocation({\r\n        sourceFile,\r\n        pos: message.textRange.pos\r\n      });\r\n      options.sourceFilePath = sourceLocation.sourceFilePath;\r\n      options.sourceFileLine = sourceLocation.sourceFileLine;\r\n      options.sourceFileColumn = sourceLocation.sourceFileColumn;\r\n\r\n      const extractorMessage: ExtractorMessage = new ExtractorMessage(options);\r\n\r\n      if (astDeclaration) {\r\n        this._associateMessageWithAstDeclaration(extractorMessage, astDeclaration);\r\n      }\r\n\r\n      this._messages.push(extractorMessage);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recursively collects the primitive members (numbers, strings, arrays, etc) into an object that\r\n   * is JSON serializable.  This is used by the \"--diagnostics\" feature to dump the state of configuration objects.\r\n   *\r\n   * @returns a JSON serializable object (possibly including `null` values)\r\n   *          or `undefined` if the input cannot be represented as JSON\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  public static buildJsonDumpObject(input: any, options?: IBuildJsonDumpObjectOptions): any | undefined {\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    const keyNamesToOmit: Set<string> = new Set(options.keyNamesToOmit);\r\n\r\n    return MessageRouter._buildJsonDumpObject(input, keyNamesToOmit);\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  private static _buildJsonDumpObject(input: any, keyNamesToOmit: Set<string>): any | undefined {\r\n    if (input === null || input === undefined) {\r\n      return null; // JSON uses null instead of undefined\r\n    }\r\n\r\n    switch (typeof input) {\r\n      case 'boolean':\r\n      case 'number':\r\n      case 'string':\r\n        return input;\r\n      case 'object':\r\n        if (Array.isArray(input)) {\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          const outputArray: any[] = [];\r\n          for (const element of input) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            const serializedElement: any = MessageRouter._buildJsonDumpObject(element, keyNamesToOmit);\r\n            if (serializedElement !== undefined) {\r\n              outputArray.push(serializedElement);\r\n            }\r\n          }\r\n          return outputArray;\r\n        }\r\n\r\n        const outputObject: object = {};\r\n        for (const key of Object.getOwnPropertyNames(input)) {\r\n          if (keyNamesToOmit.has(key)) {\r\n            continue;\r\n          }\r\n\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          const value: any = input[key];\r\n\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          const serializedValue: any = MessageRouter._buildJsonDumpObject(value, keyNamesToOmit);\r\n\r\n          if (serializedValue !== undefined) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            (outputObject as any)[key] = serializedValue;\r\n          }\r\n        }\r\n        return outputObject;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Record this message in  _associatedMessagesForAstDeclaration\r\n   */\r\n  private _associateMessageWithAstDeclaration(\r\n    extractorMessage: ExtractorMessage,\r\n    astDeclaration: AstDeclaration\r\n  ): void {\r\n    let associatedMessages: ExtractorMessage[] | undefined =\r\n      this._associatedMessagesForAstDeclaration.get(astDeclaration);\r\n\r\n    if (!associatedMessages) {\r\n      associatedMessages = [];\r\n      this._associatedMessagesForAstDeclaration.set(astDeclaration, associatedMessages);\r\n    }\r\n    associatedMessages.push(extractorMessage);\r\n  }\r\n\r\n  /**\r\n   * Add a message for a location in an arbitrary source file.\r\n   */\r\n  public addAnalyzerIssueForPosition(\r\n    messageId: ExtractorMessageId,\r\n    messageText: string,\r\n    sourceFile: ts.SourceFile,\r\n    pos: number,\r\n    properties?: IExtractorMessageProperties\r\n  ): ExtractorMessage {\r\n    const options: IExtractorMessageOptions = {\r\n      category: ExtractorMessageCategory.Extractor,\r\n      messageId,\r\n      text: messageText,\r\n      properties\r\n    };\r\n\r\n    const sourceLocation: ISourceLocation = this._sourceMapper.getSourceLocation({\r\n      sourceFile,\r\n      pos\r\n    });\r\n    options.sourceFilePath = sourceLocation.sourceFilePath;\r\n    options.sourceFileLine = sourceLocation.sourceFileLine;\r\n    options.sourceFileColumn = sourceLocation.sourceFileColumn;\r\n\r\n    const extractorMessage: ExtractorMessage = new ExtractorMessage(options);\r\n\r\n    this._messages.push(extractorMessage);\r\n    return extractorMessage;\r\n  }\r\n\r\n  /**\r\n   * This is used when writing the API report file.  It looks up any messages that were configured to get emitted\r\n   * in the API report file and returns them.  It also records that they were emitted, which suppresses them from\r\n   * being shown on the console.\r\n   */\r\n  public fetchAssociatedMessagesForReviewFile(astDeclaration: AstDeclaration): ExtractorMessage[] {\r\n    const messagesForApiReportFile: ExtractorMessage[] = [];\r\n\r\n    const associatedMessages: ExtractorMessage[] =\r\n      this._associatedMessagesForAstDeclaration.get(astDeclaration) || [];\r\n    for (const associatedMessage of associatedMessages) {\r\n      // Make sure we didn't already report this message for some reason\r\n      if (!associatedMessage.handled) {\r\n        // Is this message type configured to go in the API report file?\r\n        const reportingRule: IReportingRule = this._getRuleForMessage(associatedMessage);\r\n        if (reportingRule.addToApiReportFile) {\r\n          // Include it in the result, and record that it went to the API report file\r\n          messagesForApiReportFile.push(associatedMessage);\r\n          associatedMessage.handled = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    this._sortMessagesForOutput(messagesForApiReportFile);\r\n    return messagesForApiReportFile;\r\n  }\r\n\r\n  /**\r\n   * This returns all remaining messages that were flagged with `addToApiReportFile`, but which were not\r\n   * retreieved using `fetchAssociatedMessagesForReviewFile()`.\r\n   */\r\n  public fetchUnassociatedMessagesForReviewFile(): ExtractorMessage[] {\r\n    const messagesForApiReportFile: ExtractorMessage[] = [];\r\n\r\n    for (const unassociatedMessage of this.messages) {\r\n      // Make sure we didn't already report this message for some reason\r\n      if (!unassociatedMessage.handled) {\r\n        // Is this message type configured to go in the API report file?\r\n        const reportingRule: IReportingRule = this._getRuleForMessage(unassociatedMessage);\r\n        if (reportingRule.addToApiReportFile) {\r\n          // Include it in the result, and record that it went to the API report file\r\n          messagesForApiReportFile.push(unassociatedMessage);\r\n          unassociatedMessage.handled = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    this._sortMessagesForOutput(messagesForApiReportFile);\r\n    return messagesForApiReportFile;\r\n  }\r\n\r\n  /**\r\n   * This returns the list of remaining messages that were not already processed by\r\n   * `fetchAssociatedMessagesForReviewFile()` or `fetchUnassociatedMessagesForReviewFile()`.\r\n   * These messages will be shown on the console.\r\n   */\r\n  public handleRemainingNonConsoleMessages(): void {\r\n    const messagesForLogger: ExtractorMessage[] = [];\r\n\r\n    for (const message of this.messages) {\r\n      // Make sure we didn't already report this message\r\n      if (!message.handled) {\r\n        messagesForLogger.push(message);\r\n      }\r\n    }\r\n\r\n    this._sortMessagesForOutput(messagesForLogger);\r\n\r\n    for (const message of messagesForLogger) {\r\n      this._handleMessage(message);\r\n    }\r\n  }\r\n\r\n  public logError(\r\n    messageId: ConsoleMessageId,\r\n    message: string,\r\n    properties?: IExtractorMessageProperties\r\n  ): void {\r\n    this._handleMessage(\r\n      new ExtractorMessage({\r\n        category: ExtractorMessageCategory.Console,\r\n        messageId,\r\n        text: message,\r\n        properties,\r\n        logLevel: ExtractorLogLevel.Error\r\n      })\r\n    );\r\n  }\r\n\r\n  public logWarning(\r\n    messageId: ConsoleMessageId,\r\n    message: string,\r\n    properties?: IExtractorMessageProperties\r\n  ): void {\r\n    this._handleMessage(\r\n      new ExtractorMessage({\r\n        category: ExtractorMessageCategory.Console,\r\n        messageId,\r\n        text: message,\r\n        properties,\r\n        logLevel: ExtractorLogLevel.Warning\r\n      })\r\n    );\r\n  }\r\n\r\n  public logInfo(\r\n    messageId: ConsoleMessageId,\r\n    message: string,\r\n    properties?: IExtractorMessageProperties\r\n  ): void {\r\n    this._handleMessage(\r\n      new ExtractorMessage({\r\n        category: ExtractorMessageCategory.Console,\r\n        messageId,\r\n        text: message,\r\n        properties,\r\n        logLevel: ExtractorLogLevel.Info\r\n      })\r\n    );\r\n  }\r\n\r\n  public logVerbose(\r\n    messageId: ConsoleMessageId,\r\n    message: string,\r\n    properties?: IExtractorMessageProperties\r\n  ): void {\r\n    this._handleMessage(\r\n      new ExtractorMessage({\r\n        category: ExtractorMessageCategory.Console,\r\n        messageId,\r\n        text: message,\r\n        properties,\r\n        logLevel: ExtractorLogLevel.Verbose\r\n      })\r\n    );\r\n  }\r\n\r\n  public logDiagnosticHeader(title: string): void {\r\n    this.logDiagnostic(MessageRouter.DIAGNOSTICS_LINE);\r\n    this.logDiagnostic(`DIAGNOSTIC: ` + title);\r\n    this.logDiagnostic(MessageRouter.DIAGNOSTICS_LINE);\r\n  }\r\n\r\n  public logDiagnosticFooter(): void {\r\n    this.logDiagnostic(MessageRouter.DIAGNOSTICS_LINE + '\\n');\r\n  }\r\n\r\n  public logDiagnostic(message: string): void {\r\n    if (this.showDiagnostics) {\r\n      this.logVerbose(ConsoleMessageId.Diagnostics, message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Give the calling application a chance to handle the `ExtractorMessage`, and if not, display it on the console.\r\n   */\r\n  private _handleMessage(message: ExtractorMessage): void {\r\n    // Don't tally messages that were already \"handled\" by writing them into the API report\r\n    if (message.handled) {\r\n      return;\r\n    }\r\n\r\n    // Assign the ExtractorMessage.logLevel; the message callback may adjust it below\r\n    if (message.category === ExtractorMessageCategory.Console) {\r\n      // Console messages have their category log level assigned via logInfo(), logVerbose(), etc.\r\n    } else {\r\n      const reportingRule: IReportingRule = this._getRuleForMessage(message);\r\n      message.logLevel = reportingRule.logLevel;\r\n    }\r\n\r\n    // If there is a callback, allow it to modify and/or handle the message\r\n    if (this._messageCallback) {\r\n      this._messageCallback(message);\r\n    }\r\n\r\n    // Update the statistics\r\n    switch (message.logLevel) {\r\n      case ExtractorLogLevel.Error:\r\n        ++this.errorCount;\r\n        break;\r\n      case ExtractorLogLevel.Warning:\r\n        ++this.warningCount;\r\n        break;\r\n    }\r\n\r\n    if (message.handled) {\r\n      return;\r\n    }\r\n\r\n    // The messageCallback did not handle the message, so perform default handling\r\n    message.handled = true;\r\n\r\n    if (message.logLevel === ExtractorLogLevel.None) {\r\n      return;\r\n    }\r\n\r\n    let messageText: string;\r\n    if (message.category === ExtractorMessageCategory.Console) {\r\n      messageText = message.text;\r\n    } else {\r\n      messageText = message.formatMessageWithLocation(this._workingPackageFolder);\r\n    }\r\n\r\n    switch (message.logLevel) {\r\n      case ExtractorLogLevel.Error:\r\n        console.error(colors.red('Error: ' + messageText));\r\n        break;\r\n      case ExtractorLogLevel.Warning:\r\n        console.warn(colors.yellow('Warning: ' + messageText));\r\n        break;\r\n      case ExtractorLogLevel.Info:\r\n        console.log(messageText);\r\n        break;\r\n      case ExtractorLogLevel.Verbose:\r\n        if (this.showVerboseMessages) {\r\n          console.log(colors.cyan(messageText));\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error(`Invalid logLevel value: ${JSON.stringify(message.logLevel)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For a given message, determine the IReportingRule based on the rule tables.\r\n   */\r\n  private _getRuleForMessage(message: ExtractorMessage): IReportingRule {\r\n    const reportingRule: IReportingRule | undefined = this._reportingRuleByMessageId.get(message.messageId);\r\n    if (reportingRule) {\r\n      return reportingRule;\r\n    }\r\n    switch (message.category) {\r\n      case ExtractorMessageCategory.Compiler:\r\n        return this._compilerDefaultRule;\r\n      case ExtractorMessageCategory.Extractor:\r\n        return this._extractorDefaultRule;\r\n      case ExtractorMessageCategory.TSDoc:\r\n        return this._tsdocDefaultRule;\r\n      case ExtractorMessageCategory.Console:\r\n        throw new InternalError('ExtractorMessageCategory.Console is not supported with IReportingRule');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sorts an array of messages according to a reasonable ordering\r\n   */\r\n  private _sortMessagesForOutput(messages: ExtractorMessage[]): void {\r\n    messages.sort((a, b) => {\r\n      let diff: number;\r\n      // First sort by file name\r\n      diff = Sort.compareByValue(a.sourceFilePath, b.sourceFilePath);\r\n      if (diff !== 0) {\r\n        return diff;\r\n      }\r\n      // Then sort by line number\r\n      diff = Sort.compareByValue(a.sourceFileLine, b.sourceFileLine);\r\n      if (diff !== 0) {\r\n        return diff;\r\n      }\r\n      // Then sort by messageId\r\n      return Sort.compareByValue(a.messageId, b.messageId);\r\n    });\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/collector/SourceMapper.js.map b/lib/collector/SourceMapper.js.map
index 6023f6a201335d7be0a802038eecd28844dd7525..da513390d395a2300289f23b6d51284d45e363f1 100644
--- a/lib/collector/SourceMapper.js.map
+++ b/lib/collector/SourceMapper.js.map
@@ -1 +1 @@
-{"version":3,"file":"SourceMapper.js","sourceRoot":"","sources":["../../src/collector/SourceMapper.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport { SourceMapConsumer, type RawSourceMap, type MappingItem, type Position } from 'source-map';\nimport { FileSystem, InternalError, JsonFile, NewlineKind } from '@rushstack/node-core-library';\nimport type ts from 'typescript';\n\ninterface ISourceMap {\n  sourceMapConsumer: SourceMapConsumer;\n\n  // SourceMapConsumer.originalPositionFor() is useless because the mapping contains numerous gaps,\n  // and the API provides no way to find the nearest match.  So instead we extract all the mapping items\n  // and search them using SourceMapper._findNearestMappingItem().\n  mappingItems: MappingItem[];\n}\n\ninterface IOriginalFileInfo {\n  // Whether the .ts file exists\n  fileExists: boolean;\n\n  // This is used to check whether the guessed position is out of bounds.\n  // Since column/line numbers are 1-based, the 0th item in this array is unused.\n  maxColumnForLine: number[];\n}\n\nexport interface ISourceLocation {\n  /**\n   * The absolute path to the source file.\n   */\n  sourceFilePath: string;\n\n  /**\n   * The line number in the source file. The first line number is 1.\n   */\n  sourceFileLine: number;\n\n  /**\n   * The column number in the source file. The first column number is 1.\n   */\n  sourceFileColumn: number;\n}\n\nexport interface IGetSourceLocationOptions {\n  /**\n   * The source file to get the source location from.\n   */\n  sourceFile: ts.SourceFile;\n\n  /**\n   * The position within the source file to get the source location from.\n   */\n  pos: number;\n\n  /**\n   * If `false` or not provided, then we attempt to follow source maps in order to resolve the\n   * location to the original `.ts` file. If resolution isn't possible for some reason, we fall\n   * back to the `.d.ts` location.\n   *\n   * If `true`, then we don't bother following source maps, and the location refers to the `.d.ts`\n   * location.\n   */\n  useDtsLocation?: boolean;\n}\n\nexport class SourceMapper {\n  // Map from .d.ts file path --> ISourceMap if a source map was found, or null if not found\n  private _sourceMapByFilePath: Map<string, ISourceMap | null> = new Map<string, ISourceMap | null>();\n\n  // Cache the FileSystem.exists() result for mapped .ts files\n  private _originalFileInfoByPath: Map<string, IOriginalFileInfo> = new Map<string, IOriginalFileInfo>();\n\n  /**\n   * Given a `.d.ts` source file and a specific position within the file, return the corresponding\n   * `ISourceLocation`.\n   */\n  public getSourceLocation(options: IGetSourceLocationOptions): ISourceLocation {\n    const lineAndCharacter: ts.LineAndCharacter = options.sourceFile.getLineAndCharacterOfPosition(\n      options.pos\n    );\n    const sourceLocation: ISourceLocation = {\n      sourceFilePath: options.sourceFile.fileName,\n      sourceFileLine: lineAndCharacter.line + 1,\n      sourceFileColumn: lineAndCharacter.character + 1\n    };\n\n    if (options.useDtsLocation) {\n      return sourceLocation;\n    }\n\n    const mappedSourceLocation: ISourceLocation | undefined = this._getMappedSourceLocation(sourceLocation);\n    return mappedSourceLocation || sourceLocation;\n  }\n\n  private _getMappedSourceLocation(sourceLocation: ISourceLocation): ISourceLocation | undefined {\n    const { sourceFilePath, sourceFileLine, sourceFileColumn } = sourceLocation;\n\n    if (!FileSystem.exists(sourceFilePath)) {\n      // Sanity check\n      throw new InternalError('The referenced path was not found: ' + sourceFilePath);\n    }\n\n    const sourceMap: ISourceMap | null = this._getSourceMap(sourceFilePath);\n    if (!sourceMap) return;\n\n    const nearestMappingItem: MappingItem | undefined = SourceMapper._findNearestMappingItem(\n      sourceMap.mappingItems,\n      {\n        line: sourceFileLine,\n        column: sourceFileColumn\n      }\n    );\n\n    if (!nearestMappingItem) return;\n\n    const mappedFilePath: string = path.resolve(path.dirname(sourceFilePath), nearestMappingItem.source);\n\n    // Does the mapped filename exist?  Use a cache to remember the answer.\n    let originalFileInfo: IOriginalFileInfo | undefined = this._originalFileInfoByPath.get(mappedFilePath);\n    if (originalFileInfo === undefined) {\n      originalFileInfo = {\n        fileExists: FileSystem.exists(mappedFilePath),\n        maxColumnForLine: []\n      };\n\n      if (originalFileInfo.fileExists) {\n        // Read the file and measure the length of each line\n        originalFileInfo.maxColumnForLine = FileSystem.readFile(mappedFilePath, {\n          convertLineEndings: NewlineKind.Lf\n        })\n          .split('\\n')\n          .map((x) => x.length + 1); // +1 since columns are 1-based\n        originalFileInfo.maxColumnForLine.unshift(0); // Extra item since lines are 1-based\n      }\n\n      this._originalFileInfoByPath.set(mappedFilePath, originalFileInfo);\n    }\n\n    // Don't translate coordinates to a file that doesn't exist\n    if (!originalFileInfo.fileExists) return;\n\n    // The nearestMappingItem anchor may be above/left of the real position, due to gaps in the mapping.  Calculate\n    // the delta and apply it to the original position.\n    const guessedPosition: Position = {\n      line: nearestMappingItem.originalLine + sourceFileLine - nearestMappingItem.generatedLine,\n      column: nearestMappingItem.originalColumn + sourceFileColumn - nearestMappingItem.generatedColumn\n    };\n\n    // Verify that the result is not out of bounds, in cause our heuristic failed\n    if (\n      guessedPosition.line >= 1 &&\n      guessedPosition.line < originalFileInfo.maxColumnForLine.length &&\n      guessedPosition.column >= 1 &&\n      guessedPosition.column <= originalFileInfo.maxColumnForLine[guessedPosition.line]\n    ) {\n      return {\n        sourceFilePath: mappedFilePath,\n        sourceFileLine: guessedPosition.line,\n        sourceFileColumn: guessedPosition.column\n      };\n    } else {\n      // The guessed position was out of bounds, so use the nearestMappingItem position instead.\n      return {\n        sourceFilePath: mappedFilePath,\n        sourceFileLine: nearestMappingItem.originalLine,\n        sourceFileColumn: nearestMappingItem.originalColumn\n      };\n    }\n  }\n\n  private _getSourceMap(sourceFilePath: string): ISourceMap | null {\n    let sourceMap: ISourceMap | null | undefined = this._sourceMapByFilePath.get(sourceFilePath);\n\n    if (sourceMap === undefined) {\n      // Normalize the path and redo the lookup\n      const normalizedPath: string = FileSystem.getRealPath(sourceFilePath);\n\n      sourceMap = this._sourceMapByFilePath.get(normalizedPath);\n      if (sourceMap !== undefined) {\n        // Copy the result from the normalized to the non-normalized key\n        this._sourceMapByFilePath.set(sourceFilePath, sourceMap);\n      } else {\n        // Given \"folder/file.d.ts\", check for a corresponding \"folder/file.d.ts.map\"\n        const sourceMapPath: string = normalizedPath + '.map';\n        if (FileSystem.exists(sourceMapPath)) {\n          // Load up the source map\n          const rawSourceMap: RawSourceMap = JsonFile.load(sourceMapPath) as RawSourceMap;\n\n          const sourceMapConsumer: SourceMapConsumer = new SourceMapConsumer(rawSourceMap);\n          const mappingItems: MappingItem[] = [];\n\n          // Extract the list of mapping items\n          sourceMapConsumer.eachMapping(\n            (mappingItem: MappingItem) => {\n              mappingItems.push({\n                ...mappingItem,\n                // The \"source-map\" package inexplicably uses 1-based line numbers but 0-based column numbers.\n                // Fix that up proactively so we don't have to deal with it later.\n                generatedColumn: mappingItem.generatedColumn + 1,\n                originalColumn: mappingItem.originalColumn + 1\n              });\n            },\n            this,\n            SourceMapConsumer.GENERATED_ORDER\n          );\n\n          sourceMap = { sourceMapConsumer, mappingItems };\n        } else {\n          // No source map for this filename\n          sourceMap = null;\n        }\n\n        this._sourceMapByFilePath.set(normalizedPath, sourceMap);\n        if (sourceFilePath !== normalizedPath) {\n          // Add both keys to the map\n          this._sourceMapByFilePath.set(sourceFilePath, sourceMap);\n        }\n      }\n    }\n\n    return sourceMap;\n  }\n\n  // The `mappingItems` array is sorted by generatedLine/generatedColumn (GENERATED_ORDER).\n  // The _findNearestMappingItem() lookup is a simple binary search that returns the previous item\n  // if there is no exact match.\n  private static _findNearestMappingItem(\n    mappingItems: MappingItem[],\n    position: Position\n  ): MappingItem | undefined {\n    if (mappingItems.length === 0) {\n      return undefined;\n    }\n\n    let startIndex: number = 0;\n    let endIndex: number = mappingItems.length - 1;\n\n    while (startIndex <= endIndex) {\n      const middleIndex: number = startIndex + Math.floor((endIndex - startIndex) / 2);\n\n      const diff: number = SourceMapper._compareMappingItem(mappingItems[middleIndex], position);\n\n      if (diff < 0) {\n        startIndex = middleIndex + 1;\n      } else if (diff > 0) {\n        endIndex = middleIndex - 1;\n      } else {\n        // Exact match\n        return mappingItems[middleIndex];\n      }\n    }\n\n    // If we didn't find an exact match, then endIndex < startIndex.\n    // Take endIndex because it's the smaller value.\n    return mappingItems[endIndex];\n  }\n\n  private static _compareMappingItem(mappingItem: MappingItem, position: Position): number {\n    const diff: number = mappingItem.generatedLine - position.line;\n    if (diff !== 0) {\n      return diff;\n    }\n    return mappingItem.generatedColumn - position.column;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SourceMapper.js","sourceRoot":"","sources":["../../src/collector/SourceMapper.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport { SourceMapConsumer, type RawSourceMap, type MappingItem, type Position } from 'source-map';\r\nimport { FileSystem, InternalError, JsonFile, NewlineKind } from '@rushstack/node-core-library';\r\nimport type ts from 'typescript';\r\n\r\ninterface ISourceMap {\r\n  sourceMapConsumer: SourceMapConsumer;\r\n\r\n  // SourceMapConsumer.originalPositionFor() is useless because the mapping contains numerous gaps,\r\n  // and the API provides no way to find the nearest match.  So instead we extract all the mapping items\r\n  // and search them using SourceMapper._findNearestMappingItem().\r\n  mappingItems: MappingItem[];\r\n}\r\n\r\ninterface IOriginalFileInfo {\r\n  // Whether the .ts file exists\r\n  fileExists: boolean;\r\n\r\n  // This is used to check whether the guessed position is out of bounds.\r\n  // Since column/line numbers are 1-based, the 0th item in this array is unused.\r\n  maxColumnForLine: number[];\r\n}\r\n\r\nexport interface ISourceLocation {\r\n  /**\r\n   * The absolute path to the source file.\r\n   */\r\n  sourceFilePath: string;\r\n\r\n  /**\r\n   * The line number in the source file. The first line number is 1.\r\n   */\r\n  sourceFileLine: number;\r\n\r\n  /**\r\n   * The column number in the source file. The first column number is 1.\r\n   */\r\n  sourceFileColumn: number;\r\n}\r\n\r\nexport interface IGetSourceLocationOptions {\r\n  /**\r\n   * The source file to get the source location from.\r\n   */\r\n  sourceFile: ts.SourceFile;\r\n\r\n  /**\r\n   * The position within the source file to get the source location from.\r\n   */\r\n  pos: number;\r\n\r\n  /**\r\n   * If `false` or not provided, then we attempt to follow source maps in order to resolve the\r\n   * location to the original `.ts` file. If resolution isn't possible for some reason, we fall\r\n   * back to the `.d.ts` location.\r\n   *\r\n   * If `true`, then we don't bother following source maps, and the location refers to the `.d.ts`\r\n   * location.\r\n   */\r\n  useDtsLocation?: boolean;\r\n}\r\n\r\nexport class SourceMapper {\r\n  // Map from .d.ts file path --> ISourceMap if a source map was found, or null if not found\r\n  private _sourceMapByFilePath: Map<string, ISourceMap | null> = new Map<string, ISourceMap | null>();\r\n\r\n  // Cache the FileSystem.exists() result for mapped .ts files\r\n  private _originalFileInfoByPath: Map<string, IOriginalFileInfo> = new Map<string, IOriginalFileInfo>();\r\n\r\n  /**\r\n   * Given a `.d.ts` source file and a specific position within the file, return the corresponding\r\n   * `ISourceLocation`.\r\n   */\r\n  public getSourceLocation(options: IGetSourceLocationOptions): ISourceLocation {\r\n    const lineAndCharacter: ts.LineAndCharacter = options.sourceFile.getLineAndCharacterOfPosition(\r\n      options.pos\r\n    );\r\n    const sourceLocation: ISourceLocation = {\r\n      sourceFilePath: options.sourceFile.fileName,\r\n      sourceFileLine: lineAndCharacter.line + 1,\r\n      sourceFileColumn: lineAndCharacter.character + 1\r\n    };\r\n\r\n    if (options.useDtsLocation) {\r\n      return sourceLocation;\r\n    }\r\n\r\n    const mappedSourceLocation: ISourceLocation | undefined = this._getMappedSourceLocation(sourceLocation);\r\n    return mappedSourceLocation || sourceLocation;\r\n  }\r\n\r\n  private _getMappedSourceLocation(sourceLocation: ISourceLocation): ISourceLocation | undefined {\r\n    const { sourceFilePath, sourceFileLine, sourceFileColumn } = sourceLocation;\r\n\r\n    if (!FileSystem.exists(sourceFilePath)) {\r\n      // Sanity check\r\n      throw new InternalError('The referenced path was not found: ' + sourceFilePath);\r\n    }\r\n\r\n    const sourceMap: ISourceMap | null = this._getSourceMap(sourceFilePath);\r\n    if (!sourceMap) return;\r\n\r\n    const nearestMappingItem: MappingItem | undefined = SourceMapper._findNearestMappingItem(\r\n      sourceMap.mappingItems,\r\n      {\r\n        line: sourceFileLine,\r\n        column: sourceFileColumn\r\n      }\r\n    );\r\n\r\n    if (!nearestMappingItem) return;\r\n\r\n    const mappedFilePath: string = path.resolve(path.dirname(sourceFilePath), nearestMappingItem.source);\r\n\r\n    // Does the mapped filename exist?  Use a cache to remember the answer.\r\n    let originalFileInfo: IOriginalFileInfo | undefined = this._originalFileInfoByPath.get(mappedFilePath);\r\n    if (originalFileInfo === undefined) {\r\n      originalFileInfo = {\r\n        fileExists: FileSystem.exists(mappedFilePath),\r\n        maxColumnForLine: []\r\n      };\r\n\r\n      if (originalFileInfo.fileExists) {\r\n        // Read the file and measure the length of each line\r\n        originalFileInfo.maxColumnForLine = FileSystem.readFile(mappedFilePath, {\r\n          convertLineEndings: NewlineKind.Lf\r\n        })\r\n          .split('\\n')\r\n          .map((x) => x.length + 1); // +1 since columns are 1-based\r\n        originalFileInfo.maxColumnForLine.unshift(0); // Extra item since lines are 1-based\r\n      }\r\n\r\n      this._originalFileInfoByPath.set(mappedFilePath, originalFileInfo);\r\n    }\r\n\r\n    // Don't translate coordinates to a file that doesn't exist\r\n    if (!originalFileInfo.fileExists) return;\r\n\r\n    // The nearestMappingItem anchor may be above/left of the real position, due to gaps in the mapping.  Calculate\r\n    // the delta and apply it to the original position.\r\n    const guessedPosition: Position = {\r\n      line: nearestMappingItem.originalLine + sourceFileLine - nearestMappingItem.generatedLine,\r\n      column: nearestMappingItem.originalColumn + sourceFileColumn - nearestMappingItem.generatedColumn\r\n    };\r\n\r\n    // Verify that the result is not out of bounds, in cause our heuristic failed\r\n    if (\r\n      guessedPosition.line >= 1 &&\r\n      guessedPosition.line < originalFileInfo.maxColumnForLine.length &&\r\n      guessedPosition.column >= 1 &&\r\n      guessedPosition.column <= originalFileInfo.maxColumnForLine[guessedPosition.line]\r\n    ) {\r\n      return {\r\n        sourceFilePath: mappedFilePath,\r\n        sourceFileLine: guessedPosition.line,\r\n        sourceFileColumn: guessedPosition.column\r\n      };\r\n    } else {\r\n      // The guessed position was out of bounds, so use the nearestMappingItem position instead.\r\n      return {\r\n        sourceFilePath: mappedFilePath,\r\n        sourceFileLine: nearestMappingItem.originalLine,\r\n        sourceFileColumn: nearestMappingItem.originalColumn\r\n      };\r\n    }\r\n  }\r\n\r\n  private _getSourceMap(sourceFilePath: string): ISourceMap | null {\r\n    let sourceMap: ISourceMap | null | undefined = this._sourceMapByFilePath.get(sourceFilePath);\r\n\r\n    if (sourceMap === undefined) {\r\n      // Normalize the path and redo the lookup\r\n      const normalizedPath: string = FileSystem.getRealPath(sourceFilePath);\r\n\r\n      sourceMap = this._sourceMapByFilePath.get(normalizedPath);\r\n      if (sourceMap !== undefined) {\r\n        // Copy the result from the normalized to the non-normalized key\r\n        this._sourceMapByFilePath.set(sourceFilePath, sourceMap);\r\n      } else {\r\n        // Given \"folder/file.d.ts\", check for a corresponding \"folder/file.d.ts.map\"\r\n        const sourceMapPath: string = normalizedPath + '.map';\r\n        if (FileSystem.exists(sourceMapPath)) {\r\n          // Load up the source map\r\n          const rawSourceMap: RawSourceMap = JsonFile.load(sourceMapPath) as RawSourceMap;\r\n\r\n          const sourceMapConsumer: SourceMapConsumer = new SourceMapConsumer(rawSourceMap);\r\n          const mappingItems: MappingItem[] = [];\r\n\r\n          // Extract the list of mapping items\r\n          sourceMapConsumer.eachMapping(\r\n            (mappingItem: MappingItem) => {\r\n              mappingItems.push({\r\n                ...mappingItem,\r\n                // The \"source-map\" package inexplicably uses 1-based line numbers but 0-based column numbers.\r\n                // Fix that up proactively so we don't have to deal with it later.\r\n                generatedColumn: mappingItem.generatedColumn + 1,\r\n                originalColumn: mappingItem.originalColumn + 1\r\n              });\r\n            },\r\n            this,\r\n            SourceMapConsumer.GENERATED_ORDER\r\n          );\r\n\r\n          sourceMap = { sourceMapConsumer, mappingItems };\r\n        } else {\r\n          // No source map for this filename\r\n          sourceMap = null;\r\n        }\r\n\r\n        this._sourceMapByFilePath.set(normalizedPath, sourceMap);\r\n        if (sourceFilePath !== normalizedPath) {\r\n          // Add both keys to the map\r\n          this._sourceMapByFilePath.set(sourceFilePath, sourceMap);\r\n        }\r\n      }\r\n    }\r\n\r\n    return sourceMap;\r\n  }\r\n\r\n  // The `mappingItems` array is sorted by generatedLine/generatedColumn (GENERATED_ORDER).\r\n  // The _findNearestMappingItem() lookup is a simple binary search that returns the previous item\r\n  // if there is no exact match.\r\n  private static _findNearestMappingItem(\r\n    mappingItems: MappingItem[],\r\n    position: Position\r\n  ): MappingItem | undefined {\r\n    if (mappingItems.length === 0) {\r\n      return undefined;\r\n    }\r\n\r\n    let startIndex: number = 0;\r\n    let endIndex: number = mappingItems.length - 1;\r\n\r\n    while (startIndex <= endIndex) {\r\n      const middleIndex: number = startIndex + Math.floor((endIndex - startIndex) / 2);\r\n\r\n      const diff: number = SourceMapper._compareMappingItem(mappingItems[middleIndex], position);\r\n\r\n      if (diff < 0) {\r\n        startIndex = middleIndex + 1;\r\n      } else if (diff > 0) {\r\n        endIndex = middleIndex - 1;\r\n      } else {\r\n        // Exact match\r\n        return mappingItems[middleIndex];\r\n      }\r\n    }\r\n\r\n    // If we didn't find an exact match, then endIndex < startIndex.\r\n    // Take endIndex because it's the smaller value.\r\n    return mappingItems[endIndex];\r\n  }\r\n\r\n  private static _compareMappingItem(mappingItem: MappingItem, position: Position): number {\r\n    const diff: number = mappingItem.generatedLine - position.line;\r\n    if (diff !== 0) {\r\n      return diff;\r\n    }\r\n    return mappingItem.generatedColumn - position.column;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/collector/SymbolMetadata.js.map b/lib/collector/SymbolMetadata.js.map
index c9ae5c16b804c3234d2a91d77543c85f69215e0f..b26b41998e92cb461cb8a517a0adc0d6973447d5 100644
--- a/lib/collector/SymbolMetadata.js.map
+++ b/lib/collector/SymbolMetadata.js.map
@@ -1 +1 @@
-{"version":3,"file":"SymbolMetadata.js","sourceRoot":"","sources":["../../src/collector/SymbolMetadata.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAW3D;;;GAGG;AACH,MAAa,cAAc;IAKzB,YAAmB,OAA+B;QAChD,IAAI,CAAC,sBAAsB,GAAG,OAAO,CAAC,sBAAsB,CAAC;IAC/D,CAAC;CACF;AARD,wCAQC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { ReleaseTag } from '@microsoft/api-extractor-model';\n\n/**\n * Constructor parameters for `SymbolMetadata`.\n */\nexport interface ISymbolMetadataOptions {\n  maxEffectiveReleaseTag: ReleaseTag;\n}\n\n/**\n * Stores the Collector's additional analysis for an `AstSymbol`.  This object is assigned to `AstSymbol.metadata`\n * but consumers must always obtain it by calling `Collector.fetchSymbolMetadata()`.\n */\nexport class SymbolMetadata {\n  // For all declarations associated with this symbol, this is the\n  // `ApiItemMetadata.effectiveReleaseTag` value that is most public.\n  public readonly maxEffectiveReleaseTag: ReleaseTag;\n\n  public constructor(options: ISymbolMetadataOptions) {\n    this.maxEffectiveReleaseTag = options.maxEffectiveReleaseTag;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SymbolMetadata.js","sourceRoot":"","sources":["../../src/collector/SymbolMetadata.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAW3D;;;GAGG;AACH,MAAa,cAAc;IAKzB,YAAmB,OAA+B;QAChD,IAAI,CAAC,sBAAsB,GAAG,OAAO,CAAC,sBAAsB,CAAC;IAC/D,CAAC;CACF;AARD,wCAQC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport type { ReleaseTag } from '@microsoft/api-extractor-model';\r\n\r\n/**\r\n * Constructor parameters for `SymbolMetadata`.\r\n */\r\nexport interface ISymbolMetadataOptions {\r\n  maxEffectiveReleaseTag: ReleaseTag;\r\n}\r\n\r\n/**\r\n * Stores the Collector's additional analysis for an `AstSymbol`.  This object is assigned to `AstSymbol.metadata`\r\n * but consumers must always obtain it by calling `Collector.fetchSymbolMetadata()`.\r\n */\r\nexport class SymbolMetadata {\r\n  // For all declarations associated with this symbol, this is the\r\n  // `ApiItemMetadata.effectiveReleaseTag` value that is most public.\r\n  public readonly maxEffectiveReleaseTag: ReleaseTag;\r\n\r\n  public constructor(options: ISymbolMetadataOptions) {\r\n    this.maxEffectiveReleaseTag = options.maxEffectiveReleaseTag;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/collector/VisitorState.js.map b/lib/collector/VisitorState.js.map
index 143dce6d460229212e09e13a1fff0e85a0e72352..3024b2ee2f1aa0bbd40e38936c8c8bff31b66285 100644
--- a/lib/collector/VisitorState.js.map
+++ b/lib/collector/VisitorState.js.map
@@ -1 +1 @@
-{"version":3,"file":"VisitorState.js","sourceRoot":"","sources":["../../src/collector/VisitorState.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D;;GAEG;AACH,IAAY,YAiBX;AAjBD,WAAY,YAAY;IACtB;;OAEG;IACH,yDAAa,CAAA;IAEb;;;;OAIG;IACH,uDAAY,CAAA;IAEZ;;OAEG;IACH,qDAAW,CAAA;AACb,CAAC,EAjBW,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAiBvB","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/**\n * Keeps track of a directed graph traversal that needs to detect cycles.\n */\nexport enum VisitorState {\n  /**\n   * We have not visited the node yet.\n   */\n  Unvisited = 0,\n\n  /**\n   * We have visited the node, but have not finished traversing its references yet.\n   * If we reach a node that is already in the `Visiting` state, this means we have\n   * encountered a cyclic reference.\n   */\n  Visiting = 1,\n\n  /**\n   * We are finished vising the node and all its references.\n   */\n  Visited = 2\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"VisitorState.js","sourceRoot":"","sources":["../../src/collector/VisitorState.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D;;GAEG;AACH,IAAY,YAiBX;AAjBD,WAAY,YAAY;IACtB;;OAEG;IACH,yDAAa,CAAA;IAEb;;;;OAIG;IACH,uDAAY,CAAA;IAEZ;;OAEG;IACH,qDAAW,CAAA;AACb,CAAC,EAjBW,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAiBvB","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/**\r\n * Keeps track of a directed graph traversal that needs to detect cycles.\r\n */\r\nexport enum VisitorState {\r\n  /**\r\n   * We have not visited the node yet.\r\n   */\r\n  Unvisited = 0,\r\n\r\n  /**\r\n   * We have visited the node, but have not finished traversing its references yet.\r\n   * If we reach a node that is already in the `Visiting` state, this means we have\r\n   * encountered a cyclic reference.\r\n   */\r\n  Visiting = 1,\r\n\r\n  /**\r\n   * We are finished vising the node and all its references.\r\n   */\r\n  Visited = 2\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/collector/WorkingPackage.js.map b/lib/collector/WorkingPackage.js.map
index 14762ddc244e44ae0381abb0173da40630010da7..66ffab548cde4d1ad720ab407574889f4aa7a817 100644
--- a/lib/collector/WorkingPackage.js.map
+++ b/lib/collector/WorkingPackage.js.map
@@ -1 +1 @@
-{"version":3,"file":"WorkingPackage.js","sourceRoot":"","sources":["../../src/collector/WorkingPackage.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAgB3D;;;;;;;;;;;;;GAaG;AACH,MAAa,cAAc;IAmCzB,YAAmB,OAA+B;QAChD,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;QAC3C,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC;QACvC,IAAI,CAAC,oBAAoB,GAAG,OAAO,CAAC,oBAAoB,CAAC;IAC3D,CAAC;IAED;;OAEG;IACH,IAAW,IAAI;QACb,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;IAC/B,CAAC;CACF;AA/CD,wCA+CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type * as ts from 'typescript';\nimport type * as tsdoc from '@microsoft/tsdoc';\n\nimport type { INodePackageJson } from '@rushstack/node-core-library';\n\n/**\n * Constructor options for WorkingPackage\n */\nexport interface IWorkingPackageOptions {\n  packageFolder: string;\n  packageJson: INodePackageJson;\n  entryPointSourceFile: ts.SourceFile;\n}\n\n/**\n * Information about the working package for a particular invocation of API Extractor.\n *\n * @remarks\n * API Extractor tries to model the world as a collection of NPM packages, such that each\n * .d.ts file belongs to at most one package.  When API Extractor is invoked on a project,\n * we refer to that project as being the \"working package\".  There is exactly one\n * \"working package\" for the duration of this analysis.  Any files that do not belong to\n * the working package are referred to as \"external\":  external declarations belonging to\n * external packages.\n *\n * If API Extractor is invoked on a standalone .d.ts file, the \"working package\" may not\n * have an actual package.json file on disk, but we still refer to it in concept.\n */\nexport class WorkingPackage {\n  /**\n   * Returns the folder for the package.json file of the working package.\n   *\n   * @remarks\n   * If the entry point is `C:\\Folder\\project\\src\\index.ts` and the nearest package.json\n   * is `C:\\Folder\\project\\package.json`, then the packageFolder is `C:\\Folder\\project`\n   */\n  public readonly packageFolder: string;\n\n  /**\n   * The parsed package.json file for the working package.\n   */\n  public readonly packageJson: INodePackageJson;\n\n  /**\n   * The entry point being processed during this invocation of API Extractor.\n   *\n   * @remarks\n   * The working package may have multiple entry points; however, today API Extractor\n   * only processes a single entry point during an invocation.  This will be improved\n   * in the future.\n   */\n  public readonly entryPointSourceFile: ts.SourceFile;\n\n  /**\n   * The `@packageDocumentation` comment, if any, for the working package.\n   */\n  public tsdocComment: tsdoc.DocComment | undefined;\n\n  /**\n   * Additional parser information for `WorkingPackage.tsdocComment`.\n   */\n  public tsdocParserContext: tsdoc.ParserContext | undefined;\n\n  public constructor(options: IWorkingPackageOptions) {\n    this.packageFolder = options.packageFolder;\n    this.packageJson = options.packageJson;\n    this.entryPointSourceFile = options.entryPointSourceFile;\n  }\n\n  /**\n   * Returns the full name of the working package.\n   */\n  public get name(): string {\n    return this.packageJson.name;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"WorkingPackage.js","sourceRoot":"","sources":["../../src/collector/WorkingPackage.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAgB3D;;;;;;;;;;;;;GAaG;AACH,MAAa,cAAc;IAmCzB,YAAmB,OAA+B;QAChD,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;QAC3C,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC;QACvC,IAAI,CAAC,oBAAoB,GAAG,OAAO,CAAC,oBAAoB,CAAC;IAC3D,CAAC;IAED;;OAEG;IACH,IAAW,IAAI;QACb,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;IAC/B,CAAC;CACF;AA/CD,wCA+CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport type * as ts from 'typescript';\r\nimport type * as tsdoc from '@microsoft/tsdoc';\r\n\r\nimport type { INodePackageJson } from '@rushstack/node-core-library';\r\n\r\n/**\r\n * Constructor options for WorkingPackage\r\n */\r\nexport interface IWorkingPackageOptions {\r\n  packageFolder: string;\r\n  packageJson: INodePackageJson;\r\n  entryPointSourceFile: ts.SourceFile;\r\n}\r\n\r\n/**\r\n * Information about the working package for a particular invocation of API Extractor.\r\n *\r\n * @remarks\r\n * API Extractor tries to model the world as a collection of NPM packages, such that each\r\n * .d.ts file belongs to at most one package.  When API Extractor is invoked on a project,\r\n * we refer to that project as being the \"working package\".  There is exactly one\r\n * \"working package\" for the duration of this analysis.  Any files that do not belong to\r\n * the working package are referred to as \"external\":  external declarations belonging to\r\n * external packages.\r\n *\r\n * If API Extractor is invoked on a standalone .d.ts file, the \"working package\" may not\r\n * have an actual package.json file on disk, but we still refer to it in concept.\r\n */\r\nexport class WorkingPackage {\r\n  /**\r\n   * Returns the folder for the package.json file of the working package.\r\n   *\r\n   * @remarks\r\n   * If the entry point is `C:\\Folder\\project\\src\\index.ts` and the nearest package.json\r\n   * is `C:\\Folder\\project\\package.json`, then the packageFolder is `C:\\Folder\\project`\r\n   */\r\n  public readonly packageFolder: string;\r\n\r\n  /**\r\n   * The parsed package.json file for the working package.\r\n   */\r\n  public readonly packageJson: INodePackageJson;\r\n\r\n  /**\r\n   * The entry point being processed during this invocation of API Extractor.\r\n   *\r\n   * @remarks\r\n   * The working package may have multiple entry points; however, today API Extractor\r\n   * only processes a single entry point during an invocation.  This will be improved\r\n   * in the future.\r\n   */\r\n  public readonly entryPointSourceFile: ts.SourceFile;\r\n\r\n  /**\r\n   * The `@packageDocumentation` comment, if any, for the working package.\r\n   */\r\n  public tsdocComment: tsdoc.DocComment | undefined;\r\n\r\n  /**\r\n   * Additional parser information for `WorkingPackage.tsdocComment`.\r\n   */\r\n  public tsdocParserContext: tsdoc.ParserContext | undefined;\r\n\r\n  public constructor(options: IWorkingPackageOptions) {\r\n    this.packageFolder = options.packageFolder;\r\n    this.packageJson = options.packageJson;\r\n    this.entryPointSourceFile = options.entryPointSourceFile;\r\n  }\r\n\r\n  /**\r\n   * Returns the full name of the working package.\r\n   */\r\n  public get name(): string {\r\n    return this.packageJson.name;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/enhancers/DocCommentEnhancer.js.map b/lib/enhancers/DocCommentEnhancer.js.map
index 97f4b8e9c697a177c3e89752f98be35544f93147..c9caac6262b81f43a89aaca3771f875abb5cd1e8 100644
--- a/lib/enhancers/DocCommentEnhancer.js.map
+++ b/lib/enhancers/DocCommentEnhancer.js.map
@@ -1 +1 @@
-{"version":3,"file":"DocCommentEnhancer.js","sourceRoot":"","sources":["../../src/enhancers/DocCommentEnhancer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\nimport * as tsdoc from '@microsoft/tsdoc';\n\nimport type { Collector } from '../collector/Collector';\nimport { AstSymbol } from '../analyzer/AstSymbol';\nimport type { AstDeclaration } from '../analyzer/AstDeclaration';\nimport type { ApiItemMetadata } from '../collector/ApiItemMetadata';\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\nimport { VisitorState } from '../collector/VisitorState';\nimport { ResolverFailure } from '../analyzer/AstReferenceResolver';\n\nexport class DocCommentEnhancer {\n  private readonly _collector: Collector;\n\n  public constructor(collector: Collector) {\n    this._collector = collector;\n  }\n\n  public static analyze(collector: Collector): void {\n    const docCommentEnhancer: DocCommentEnhancer = new DocCommentEnhancer(collector);\n    docCommentEnhancer.analyze();\n  }\n\n  public analyze(): void {\n    for (const entity of this._collector.entities) {\n      if (entity.astEntity instanceof AstSymbol) {\n        if (\n          entity.consumable ||\n          this._collector.extractorConfig.apiReportIncludeForgottenExports ||\n          this._collector.extractorConfig.docModelIncludeForgottenExports\n        ) {\n          entity.astEntity.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\n            this._analyzeApiItem(astDeclaration);\n          });\n        }\n      }\n    }\n  }\n\n  private _analyzeApiItem(astDeclaration: AstDeclaration): void {\n    const metadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n    if (metadata.docCommentEnhancerVisitorState === VisitorState.Visited) {\n      return;\n    }\n\n    if (metadata.docCommentEnhancerVisitorState === VisitorState.Visiting) {\n      this._collector.messageRouter.addAnalyzerIssue(\n        ExtractorMessageId.CyclicInheritDoc,\n        `The @inheritDoc tag for \"${astDeclaration.astSymbol.localName}\" refers to its own declaration`,\n        astDeclaration\n      );\n      return;\n    }\n    metadata.docCommentEnhancerVisitorState = VisitorState.Visiting;\n\n    if (metadata.tsdocComment && metadata.tsdocComment.inheritDocTag) {\n      this._applyInheritDoc(astDeclaration, metadata.tsdocComment, metadata.tsdocComment.inheritDocTag);\n    }\n\n    this._analyzeNeedsDocumentation(astDeclaration, metadata);\n\n    this._checkForBrokenLinks(astDeclaration, metadata);\n\n    metadata.docCommentEnhancerVisitorState = VisitorState.Visited;\n  }\n\n  private _analyzeNeedsDocumentation(astDeclaration: AstDeclaration, metadata: ApiItemMetadata): void {\n    if (astDeclaration.declaration.kind === ts.SyntaxKind.Constructor) {\n      // Constructors always do pretty much the same thing, so it's annoying to require people to write\n      // descriptions for them.  Instead, if the constructor lacks a TSDoc summary, then API Extractor\n      // will auto-generate one.\n      metadata.undocumented = false;\n\n      // The class that contains this constructor\n      const classDeclaration: AstDeclaration = astDeclaration.parent!;\n\n      const configuration: tsdoc.TSDocConfiguration = this._collector.extractorConfig.tsdocConfiguration;\n\n      if (!metadata.tsdocComment) {\n        metadata.tsdocComment = new tsdoc.DocComment({ configuration });\n      }\n\n      if (!tsdoc.PlainTextEmitter.hasAnyTextContent(metadata.tsdocComment.summarySection)) {\n        metadata.tsdocComment.summarySection.appendNodesInParagraph([\n          new tsdoc.DocPlainText({ configuration, text: 'Constructs a new instance of the ' }),\n          new tsdoc.DocCodeSpan({\n            configuration,\n            code: classDeclaration.astSymbol.localName\n          }),\n          new tsdoc.DocPlainText({ configuration, text: ' class' })\n        ]);\n      }\n\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      if (apiItemMetadata.effectiveReleaseTag === ReleaseTag.Internal) {\n        // If the constructor is marked as internal, then add a boilerplate notice for the containing class\n        const classMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(classDeclaration);\n\n        if (!classMetadata.tsdocComment) {\n          classMetadata.tsdocComment = new tsdoc.DocComment({ configuration });\n        }\n\n        if (classMetadata.tsdocComment.remarksBlock === undefined) {\n          classMetadata.tsdocComment.remarksBlock = new tsdoc.DocBlock({\n            configuration,\n            blockTag: new tsdoc.DocBlockTag({\n              configuration,\n              tagName: tsdoc.StandardTags.remarks.tagName\n            })\n          });\n        }\n\n        classMetadata.tsdocComment.remarksBlock.content.appendNode(\n          new tsdoc.DocParagraph({ configuration }, [\n            new tsdoc.DocPlainText({\n              configuration,\n              text:\n                `The constructor for this class is marked as internal. Third-party code should not` +\n                ` call the constructor directly or create subclasses that extend the `\n            }),\n            new tsdoc.DocCodeSpan({\n              configuration,\n              code: classDeclaration.astSymbol.localName\n            }),\n            new tsdoc.DocPlainText({ configuration, text: ' class.' })\n          ])\n        );\n      }\n      return;\n    }\n\n    if (metadata.tsdocComment) {\n      // Require the summary to contain at least 10 non-spacing characters\n      metadata.undocumented = !tsdoc.PlainTextEmitter.hasAnyTextContent(\n        metadata.tsdocComment.summarySection,\n        10\n      );\n    } else {\n      metadata.undocumented = true;\n    }\n  }\n\n  private _checkForBrokenLinks(astDeclaration: AstDeclaration, metadata: ApiItemMetadata): void {\n    if (!metadata.tsdocComment) {\n      return;\n    }\n    this._checkForBrokenLinksRecursive(astDeclaration, metadata.tsdocComment);\n  }\n\n  private _checkForBrokenLinksRecursive(astDeclaration: AstDeclaration, node: tsdoc.DocNode): void {\n    if (node instanceof tsdoc.DocLinkTag) {\n      if (node.codeDestination) {\n        // Is it referring to the working package?  If not, we don't do any link validation, because\n        // AstReferenceResolver doesn't support it yet (but ModelReferenceResolver does of course).\n        // Tracked by:  https://github.com/microsoft/rushstack/issues/1195\n        if (\n          node.codeDestination.packageName === undefined ||\n          node.codeDestination.packageName === this._collector.workingPackage.name\n        ) {\n          const referencedAstDeclaration: AstDeclaration | ResolverFailure =\n            this._collector.astReferenceResolver.resolve(node.codeDestination);\n\n          if (referencedAstDeclaration instanceof ResolverFailure) {\n            this._collector.messageRouter.addAnalyzerIssue(\n              ExtractorMessageId.UnresolvedLink,\n              'The @link reference could not be resolved: ' + referencedAstDeclaration.reason,\n              astDeclaration\n            );\n          }\n        }\n      }\n    }\n    for (const childNode of node.getChildNodes()) {\n      this._checkForBrokenLinksRecursive(astDeclaration, childNode);\n    }\n  }\n\n  /**\n   * Follow an `{@inheritDoc ___}` reference and copy the content that we find in the referenced comment.\n   */\n  private _applyInheritDoc(\n    astDeclaration: AstDeclaration,\n    docComment: tsdoc.DocComment,\n    inheritDocTag: tsdoc.DocInheritDocTag\n  ): void {\n    if (!inheritDocTag.declarationReference) {\n      this._collector.messageRouter.addAnalyzerIssue(\n        ExtractorMessageId.UnresolvedInheritDocBase,\n        'The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet',\n        astDeclaration\n      );\n      return;\n    }\n\n    // Is it referring to the working package?\n    if (\n      !(\n        inheritDocTag.declarationReference.packageName === undefined ||\n        inheritDocTag.declarationReference.packageName === this._collector.workingPackage.name\n      )\n    ) {\n      // It's referencing an external package, so skip this inheritDoc tag, since AstReferenceResolver doesn't\n      // support it yet.  As a workaround, this tag will get handled later by api-documenter.\n      // Tracked by:  https://github.com/microsoft/rushstack/issues/1195\n      return;\n    }\n\n    const referencedAstDeclaration: AstDeclaration | ResolverFailure =\n      this._collector.astReferenceResolver.resolve(inheritDocTag.declarationReference);\n\n    if (referencedAstDeclaration instanceof ResolverFailure) {\n      this._collector.messageRouter.addAnalyzerIssue(\n        ExtractorMessageId.UnresolvedInheritDocReference,\n        'The @inheritDoc reference could not be resolved: ' + referencedAstDeclaration.reason,\n        astDeclaration\n      );\n      return;\n    }\n\n    this._analyzeApiItem(referencedAstDeclaration);\n\n    const referencedMetadata: ApiItemMetadata =\n      this._collector.fetchApiItemMetadata(referencedAstDeclaration);\n\n    if (referencedMetadata.tsdocComment) {\n      this._copyInheritedDocs(docComment, referencedMetadata.tsdocComment);\n    }\n  }\n\n  /**\n   * Copy the content from `sourceDocComment` to `targetDocComment`.\n   */\n  private _copyInheritedDocs(targetDocComment: tsdoc.DocComment, sourceDocComment: tsdoc.DocComment): void {\n    targetDocComment.summarySection = sourceDocComment.summarySection;\n    targetDocComment.remarksBlock = sourceDocComment.remarksBlock;\n\n    targetDocComment.params.clear();\n    for (const param of sourceDocComment.params) {\n      targetDocComment.params.add(param);\n    }\n    for (const typeParam of sourceDocComment.typeParams) {\n      targetDocComment.typeParams.add(typeParam);\n    }\n    targetDocComment.returnsBlock = sourceDocComment.returnsBlock;\n\n    targetDocComment.inheritDocTag = undefined;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"DocCommentEnhancer.js","sourceRoot":"","sources":["../../src/enhancers/DocCommentEnhancer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport * as tsdoc from '@microsoft/tsdoc';\r\n\r\nimport type { Collector } from '../collector/Collector';\r\nimport { AstSymbol } from '../analyzer/AstSymbol';\r\nimport type { AstDeclaration } from '../analyzer/AstDeclaration';\r\nimport type { ApiItemMetadata } from '../collector/ApiItemMetadata';\r\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\r\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\r\nimport { VisitorState } from '../collector/VisitorState';\r\nimport { ResolverFailure } from '../analyzer/AstReferenceResolver';\r\n\r\nexport class DocCommentEnhancer {\r\n  private readonly _collector: Collector;\r\n\r\n  public constructor(collector: Collector) {\r\n    this._collector = collector;\r\n  }\r\n\r\n  public static analyze(collector: Collector): void {\r\n    const docCommentEnhancer: DocCommentEnhancer = new DocCommentEnhancer(collector);\r\n    docCommentEnhancer.analyze();\r\n  }\r\n\r\n  public analyze(): void {\r\n    for (const entity of this._collector.entities) {\r\n      if (entity.astEntity instanceof AstSymbol) {\r\n        if (\r\n          entity.consumable ||\r\n          this._collector.extractorConfig.apiReportIncludeForgottenExports ||\r\n          this._collector.extractorConfig.docModelIncludeForgottenExports\r\n        ) {\r\n          entity.astEntity.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\r\n            this._analyzeApiItem(astDeclaration);\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private _analyzeApiItem(astDeclaration: AstDeclaration): void {\r\n    const metadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n    if (metadata.docCommentEnhancerVisitorState === VisitorState.Visited) {\r\n      return;\r\n    }\r\n\r\n    if (metadata.docCommentEnhancerVisitorState === VisitorState.Visiting) {\r\n      this._collector.messageRouter.addAnalyzerIssue(\r\n        ExtractorMessageId.CyclicInheritDoc,\r\n        `The @inheritDoc tag for \"${astDeclaration.astSymbol.localName}\" refers to its own declaration`,\r\n        astDeclaration\r\n      );\r\n      return;\r\n    }\r\n    metadata.docCommentEnhancerVisitorState = VisitorState.Visiting;\r\n\r\n    if (metadata.tsdocComment && metadata.tsdocComment.inheritDocTag) {\r\n      this._applyInheritDoc(astDeclaration, metadata.tsdocComment, metadata.tsdocComment.inheritDocTag);\r\n    }\r\n\r\n    this._analyzeNeedsDocumentation(astDeclaration, metadata);\r\n\r\n    this._checkForBrokenLinks(astDeclaration, metadata);\r\n\r\n    metadata.docCommentEnhancerVisitorState = VisitorState.Visited;\r\n  }\r\n\r\n  private _analyzeNeedsDocumentation(astDeclaration: AstDeclaration, metadata: ApiItemMetadata): void {\r\n    if (astDeclaration.declaration.kind === ts.SyntaxKind.Constructor) {\r\n      // Constructors always do pretty much the same thing, so it's annoying to require people to write\r\n      // descriptions for them.  Instead, if the constructor lacks a TSDoc summary, then API Extractor\r\n      // will auto-generate one.\r\n      metadata.undocumented = false;\r\n\r\n      // The class that contains this constructor\r\n      const classDeclaration: AstDeclaration = astDeclaration.parent!;\r\n\r\n      const configuration: tsdoc.TSDocConfiguration = this._collector.extractorConfig.tsdocConfiguration;\r\n\r\n      if (!metadata.tsdocComment) {\r\n        metadata.tsdocComment = new tsdoc.DocComment({ configuration });\r\n      }\r\n\r\n      if (!tsdoc.PlainTextEmitter.hasAnyTextContent(metadata.tsdocComment.summarySection)) {\r\n        metadata.tsdocComment.summarySection.appendNodesInParagraph([\r\n          new tsdoc.DocPlainText({ configuration, text: 'Constructs a new instance of the ' }),\r\n          new tsdoc.DocCodeSpan({\r\n            configuration,\r\n            code: classDeclaration.astSymbol.localName\r\n          }),\r\n          new tsdoc.DocPlainText({ configuration, text: ' class' })\r\n        ]);\r\n      }\r\n\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      if (apiItemMetadata.effectiveReleaseTag === ReleaseTag.Internal) {\r\n        // If the constructor is marked as internal, then add a boilerplate notice for the containing class\r\n        const classMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(classDeclaration);\r\n\r\n        if (!classMetadata.tsdocComment) {\r\n          classMetadata.tsdocComment = new tsdoc.DocComment({ configuration });\r\n        }\r\n\r\n        if (classMetadata.tsdocComment.remarksBlock === undefined) {\r\n          classMetadata.tsdocComment.remarksBlock = new tsdoc.DocBlock({\r\n            configuration,\r\n            blockTag: new tsdoc.DocBlockTag({\r\n              configuration,\r\n              tagName: tsdoc.StandardTags.remarks.tagName\r\n            })\r\n          });\r\n        }\r\n\r\n        classMetadata.tsdocComment.remarksBlock.content.appendNode(\r\n          new tsdoc.DocParagraph({ configuration }, [\r\n            new tsdoc.DocPlainText({\r\n              configuration,\r\n              text:\r\n                `The constructor for this class is marked as internal. Third-party code should not` +\r\n                ` call the constructor directly or create subclasses that extend the `\r\n            }),\r\n            new tsdoc.DocCodeSpan({\r\n              configuration,\r\n              code: classDeclaration.astSymbol.localName\r\n            }),\r\n            new tsdoc.DocPlainText({ configuration, text: ' class.' })\r\n          ])\r\n        );\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (metadata.tsdocComment) {\r\n      // Require the summary to contain at least 10 non-spacing characters\r\n      metadata.undocumented = !tsdoc.PlainTextEmitter.hasAnyTextContent(\r\n        metadata.tsdocComment.summarySection,\r\n        10\r\n      );\r\n    } else {\r\n      metadata.undocumented = true;\r\n    }\r\n  }\r\n\r\n  private _checkForBrokenLinks(astDeclaration: AstDeclaration, metadata: ApiItemMetadata): void {\r\n    if (!metadata.tsdocComment) {\r\n      return;\r\n    }\r\n    this._checkForBrokenLinksRecursive(astDeclaration, metadata.tsdocComment);\r\n  }\r\n\r\n  private _checkForBrokenLinksRecursive(astDeclaration: AstDeclaration, node: tsdoc.DocNode): void {\r\n    if (node instanceof tsdoc.DocLinkTag) {\r\n      if (node.codeDestination) {\r\n        // Is it referring to the working package?  If not, we don't do any link validation, because\r\n        // AstReferenceResolver doesn't support it yet (but ModelReferenceResolver does of course).\r\n        // Tracked by:  https://github.com/microsoft/rushstack/issues/1195\r\n        if (\r\n          node.codeDestination.packageName === undefined ||\r\n          node.codeDestination.packageName === this._collector.workingPackage.name\r\n        ) {\r\n          const referencedAstDeclaration: AstDeclaration | ResolverFailure =\r\n            this._collector.astReferenceResolver.resolve(node.codeDestination);\r\n\r\n          if (referencedAstDeclaration instanceof ResolverFailure) {\r\n            this._collector.messageRouter.addAnalyzerIssue(\r\n              ExtractorMessageId.UnresolvedLink,\r\n              'The @link reference could not be resolved: ' + referencedAstDeclaration.reason,\r\n              astDeclaration\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n    for (const childNode of node.getChildNodes()) {\r\n      this._checkForBrokenLinksRecursive(astDeclaration, childNode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Follow an `{@inheritDoc ___}` reference and copy the content that we find in the referenced comment.\r\n   */\r\n  private _applyInheritDoc(\r\n    astDeclaration: AstDeclaration,\r\n    docComment: tsdoc.DocComment,\r\n    inheritDocTag: tsdoc.DocInheritDocTag\r\n  ): void {\r\n    if (!inheritDocTag.declarationReference) {\r\n      this._collector.messageRouter.addAnalyzerIssue(\r\n        ExtractorMessageId.UnresolvedInheritDocBase,\r\n        'The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet',\r\n        astDeclaration\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Is it referring to the working package?\r\n    if (\r\n      !(\r\n        inheritDocTag.declarationReference.packageName === undefined ||\r\n        inheritDocTag.declarationReference.packageName === this._collector.workingPackage.name\r\n      )\r\n    ) {\r\n      // It's referencing an external package, so skip this inheritDoc tag, since AstReferenceResolver doesn't\r\n      // support it yet.  As a workaround, this tag will get handled later by api-documenter.\r\n      // Tracked by:  https://github.com/microsoft/rushstack/issues/1195\r\n      return;\r\n    }\r\n\r\n    const referencedAstDeclaration: AstDeclaration | ResolverFailure =\r\n      this._collector.astReferenceResolver.resolve(inheritDocTag.declarationReference);\r\n\r\n    if (referencedAstDeclaration instanceof ResolverFailure) {\r\n      this._collector.messageRouter.addAnalyzerIssue(\r\n        ExtractorMessageId.UnresolvedInheritDocReference,\r\n        'The @inheritDoc reference could not be resolved: ' + referencedAstDeclaration.reason,\r\n        astDeclaration\r\n      );\r\n      return;\r\n    }\r\n\r\n    this._analyzeApiItem(referencedAstDeclaration);\r\n\r\n    const referencedMetadata: ApiItemMetadata =\r\n      this._collector.fetchApiItemMetadata(referencedAstDeclaration);\r\n\r\n    if (referencedMetadata.tsdocComment) {\r\n      this._copyInheritedDocs(docComment, referencedMetadata.tsdocComment);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Copy the content from `sourceDocComment` to `targetDocComment`.\r\n   */\r\n  private _copyInheritedDocs(targetDocComment: tsdoc.DocComment, sourceDocComment: tsdoc.DocComment): void {\r\n    targetDocComment.summarySection = sourceDocComment.summarySection;\r\n    targetDocComment.remarksBlock = sourceDocComment.remarksBlock;\r\n\r\n    targetDocComment.params.clear();\r\n    for (const param of sourceDocComment.params) {\r\n      targetDocComment.params.add(param);\r\n    }\r\n    for (const typeParam of sourceDocComment.typeParams) {\r\n      targetDocComment.typeParams.add(typeParam);\r\n    }\r\n    targetDocComment.returnsBlock = sourceDocComment.returnsBlock;\r\n\r\n    targetDocComment.inheritDocTag = undefined;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/enhancers/ValidationEnhancer.js b/lib/enhancers/ValidationEnhancer.js
index 3511bb2fd2269cce8c45197ef8dc61c28158f743..61101cea95d362b94be8b9e9ccc3e833fca8fccc 100644
--- a/lib/enhancers/ValidationEnhancer.js
+++ b/lib/enhancers/ValidationEnhancer.js
@@ -186,15 +186,13 @@ class ValidationEnhancer {
             else {
                 continue;
             }
-            if (collectorEntity && collectorEntity.consumable) {
-                if (api_extractor_model_1.ReleaseTag.compare(declarationReleaseTag, referencedReleaseTag) > 0) {
-                    collector.messageRouter.addAnalyzerIssue("ae-incompatible-release-tags" /* ExtractorMessageId.IncompatibleReleaseTags */, `The symbol "${astDeclaration.astSymbol.localName}"` +
-                        ` is marked as ${api_extractor_model_1.ReleaseTag.getTagName(declarationReleaseTag)},` +
-                        ` but its signature references "${localName}"` +
-                        ` which is marked as ${api_extractor_model_1.ReleaseTag.getTagName(referencedReleaseTag)}`, astDeclaration);
-                }
+            if (api_extractor_model_1.ReleaseTag.compare(declarationReleaseTag, referencedReleaseTag) > 0) {
+                collector.messageRouter.addAnalyzerIssue("ae-incompatible-release-tags" /* ExtractorMessageId.IncompatibleReleaseTags */, `The symbol "${astDeclaration.astSymbol.localName}"` +
+                    ` is marked as ${api_extractor_model_1.ReleaseTag.getTagName(declarationReleaseTag)},` +
+                    ` but its signature references "${localName}"` +
+                    ` which is marked as ${api_extractor_model_1.ReleaseTag.getTagName(referencedReleaseTag)}`, astDeclaration);
             }
-            else {
+            if (!collectorEntity || !collectorEntity.consumable) {
                 const entryPointFilename = path.basename(collector.workingPackage.entryPointSourceFile.fileName);
                 if (!alreadyWarnedEntities.has(referencedEntity)) {
                     alreadyWarnedEntities.add(referencedEntity);
diff --git a/lib/enhancers/ValidationEnhancer.js.map b/lib/enhancers/ValidationEnhancer.js.map
index 04ff4c10c50e3fc32365d6ae51bc2ed8e34b956d..a008a6c9d8b96038378d8626dd7c26e93503bdc5 100644
--- a/lib/enhancers/ValidationEnhancer.js.map
+++ b/lib/enhancers/ValidationEnhancer.js.map
@@ -1 +1 @@
-{"version":3,"file":"ValidationEnhancer.js","sourceRoot":"","sources":["../../src/enhancers/ValidationEnhancer.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,2CAA6B;AAC7B,+CAAiC;AAGjC,qDAAkD;AAMlD,wEAA4D;AAC5D,uEAAoE;AAIpE,MAAa,kBAAkB;IACtB,MAAM,CAAC,OAAO,CAAC,SAAoB;QACxC,MAAM,qBAAqB,GAAmB,IAAI,GAAG,EAAa,CAAC;QAEnE,KAAK,MAAM,MAAM,IAAI,SAAS,CAAC,QAAQ,EAAE;YACvC,IACE,CAAC,CACC,MAAM,CAAC,UAAU;gBACjB,SAAS,CAAC,eAAe,CAAC,gCAAgC;gBAC1D,SAAS,CAAC,eAAe,CAAC,+BAA+B,CAC1D,EACD;gBACA,SAAS;aACV;YAED,IAAI,MAAM,CAAC,SAAS,YAAY,qBAAS,EAAE;gBACzC,+BAA+B;gBAE/B,MAAM,SAAS,GAAc,MAAM,CAAC,SAAS,CAAC;gBAE9C,SAAS,CAAC,2BAA2B,CAAC,CAAC,cAA8B,EAAE,EAAE;oBACvE,kBAAkB,CAAC,gBAAgB,CAAC,SAAS,EAAE,cAAc,EAAE,qBAAqB,CAAC,CAAC;gBACxF,CAAC,CAAC,CAAC;gBAEH,MAAM,cAAc,GAAmB,SAAS,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;gBAChF,kBAAkB,CAAC,2BAA2B,CAAC,SAAS,EAAE,MAAM,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;gBAC7F,kBAAkB,CAAC,gCAAgC,CAAC,SAAS,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;aAC3F;iBAAM,IAAI,MAAM,CAAC,SAAS,YAAY,uCAAkB,EAAE;gBACzD,uDAAuD;gBACvD,MAAM,kBAAkB,GAAuB,MAAM,CAAC,SAAS,CAAC;gBAEhE,MAAM,mBAAmB,GACvB,kBAAkB,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC;gBAEzD,KAAK,MAAM,wBAAwB,IAAI,mBAAmB,CAAC,qBAAqB,CAAC,MAAM,EAAE,EAAE;oBACzF,IAAI,wBAAwB,YAAY,qBAAS,EAAE;wBACjD,MAAM,SAAS,GAAc,wBAAwB,CAAC;wBAEtD,SAAS,CAAC,2BAA2B,CAAC,CAAC,cAA8B,EAAE,EAAE;4BACvE,kBAAkB,CAAC,gBAAgB,CAAC,SAAS,EAAE,cAAc,EAAE,qBAAqB,CAAC,CAAC;wBACxF,CAAC,CAAC,CAAC;wBAEH,MAAM,cAAc,GAAmB,SAAS,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;wBAEhF,gGAAgG;wBAEhG,kBAAkB,CAAC,gCAAgC,CAAC,SAAS,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;qBAC3F;iBACF;aACF;SACF;IACH,CAAC;IAEO,MAAM,CAAC,2BAA2B,CACxC,SAAoB,EACpB,eAAgC,EAChC,SAAoB,EACpB,cAA8B;QAE9B,IAAI,eAAe,GAAY,KAAK,CAAC;QAErC,IAAI,cAAc,CAAC,sBAAsB,KAAK,gCAAU,CAAC,QAAQ,EAAE;YACjE,IAAI,CAAC,SAAS,CAAC,eAAe,EAAE;gBAC9B,8EAA8E;gBAC9E,+GAA+G;gBAC/G,EAAE;gBACF,mBAAmB;gBACnB,sBAAsB;gBACtB,EAAE;gBACF,qBAAqB;gBACrB,2BAA2B;gBAC3B,EAAE;gBACF,iGAAiG;gBACjG,eAAe,GAAG,IAAI,CAAC;aACxB;iBAAM;gBACL,6GAA6G;gBAC7G,EAAE;gBACF,+EAA+E;gBAC/E,EAAE;gBACF,qBAAqB;gBACrB,yBAAyB;gBACzB,8BAA8B;gBAC9B,MAAM;gBACN,EAAE;gBACF,mBAAmB;gBACnB,qBAAqB;gBACrB,uBAAuB;gBACvB,oEAAoE;gBACpE,MAAM;gBACN,MAAM,oBAAoB,GAAmB,SAAS,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;gBACtF,IAAI,oBAAoB,CAAC,sBAAsB,GAAG,gCAAU,CAAC,QAAQ,EAAE;oBACrE,eAAe,GAAG,IAAI,CAAC;iBACxB;aACF;SACF;QAED,IAAI,eAAe,EAAE;YACnB,KAAK,MAAM,UAAU,IAAI,eAAe,CAAC,WAAW,EAAE;gBACpD,IAAI,UAAU,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;oBACzB,SAAS,CAAC,aAAa,CAAC,gBAAgB,sFAEtC,aAAa,UAAU,yCAAyC;wBAC9D,iDAAiD,EACnD,SAAS,EACT,EAAE,UAAU,EAAE,CACf,CAAC;iBACH;aACF;SACF;IACH,CAAC;IAEO,MAAM,CAAC,gCAAgC,CAC7C,SAAoB,EACpB,SAAoB,EACpB,cAA8B;QAE9B,IAAI,SAAS,CAAC,UAAU,EAAE;YACxB,oGAAoG;YACpG,mDAAmD;YACnD,OAAO;SACR;QAED,6GAA6G;QAC7G,sCAAsC;QACtC,MAAM,2BAA2B,GAAe,cAAc,CAAC,sBAAsB,CAAC;QAEtF,+GAA+G;QAC/G,IAAI,gBAAgB,GAAY,KAAK,CAAC;QAEtC,uFAAuF;QACvF,IAAI,qBAAqB,GAAY,IAAI,CAAC;QAE1C,iEAAiE;QACjE,IAAI,sBAAsB,GAAY,KAAK,CAAC;QAE5C,KAAK,MAAM,cAAc,IAAI,SAAS,CAAC,eAAe,EAAE;YACtD,MAAM,eAAe,GAAoB,SAAS,CAAC,oBAAoB,CAAC,cAAc,CAAC,CAAC;YACxF,MAAM,mBAAmB,GAAe,eAAe,CAAC,mBAAmB,CAAC;YAE5E,QAAQ,cAAc,CAAC,WAAW,CAAC,IAAI,EAAE;gBACvC,KAAK,EAAE,CAAC,UAAU,CAAC,mBAAmB,CAAC;gBACvC,KAAK,EAAE,CAAC,UAAU,CAAC,iBAAiB;oBAClC,MAAM;gBACR;oBACE,qBAAqB,GAAG,KAAK,CAAC;aACjC;YAED,IAAI,mBAAmB,KAAK,2BAA2B,EAAE;gBACvD,gBAAgB,GAAG,IAAI,CAAC;aACzB;YAED,IAAI,mBAAmB,KAAK,gCAAU,CAAC,QAAQ,EAAE;gBAC/C,sBAAsB,GAAG,IAAI,CAAC;aAC/B;SACF;QAED,IAAI,gBAAgB,EAAE;YACpB,IAAI,CAAC,qBAAqB,EAAE;gBAC1B,SAAS,CAAC,aAAa,CAAC,gBAAgB,4EAEtC,kEAAkE,EAClE,SAAS,CACV,CAAC;aACH;YAED,IAAI,sBAAsB,EAAE;gBAC1B,SAAS,CAAC,aAAa,CAAC,gBAAgB,mFAEtC,2CAA2C,SAAS,CAAC,SAAS,mCAAmC;oBAC/F,yBAAyB,EAC3B,SAAS,CACV,CAAC;aACH;SACF;IACH,CAAC;IAEO,MAAM,CAAC,gBAAgB,CAC7B,SAAoB,EACpB,cAA8B,EAC9B,qBAAqC;QAErC,MAAM,eAAe,GAAoB,SAAS,CAAC,oBAAoB,CAAC,cAAc,CAAC,CAAC;QACxF,MAAM,qBAAqB,GAAe,eAAe,CAAC,mBAAmB,CAAC;QAE9E,KAAK,MAAM,gBAAgB,IAAI,cAAc,CAAC,qBAAqB,EAAE;YACnE,IAAI,eAA4C,CAAC;YACjD,IAAI,oBAAgC,CAAC;YACrC,IAAI,SAAiB,CAAC;YAEtB,IAAI,gBAAgB,YAAY,qBAAS,EAAE;gBACzC,kGAAkG;gBAClG,yBAAyB;gBACzB,EAAE;gBACF,kFAAkF;gBAClF,MAAM,UAAU,GAAc,gBAAgB,CAAC,aAAa,CAAC;gBAE7D,IAAI,UAAU,CAAC,UAAU,EAAE;oBACzB,SAAS;iBACV;gBAED,eAAe,GAAG,SAAS,CAAC,qBAAqB,CAAC,UAAU,CAAC,CAAC;gBAC9D,SAAS,GAAG,CAAA,eAAe,aAAf,eAAe,uBAAf,eAAe,CAAE,WAAW,KAAI,UAAU,CAAC,SAAS,CAAC;gBAEjE,MAAM,kBAAkB,GAAmB,SAAS,CAAC,mBAAmB,CAAC,gBAAgB,CAAC,CAAC;gBAC3F,oBAAoB,GAAG,kBAAkB,CAAC,sBAAsB,CAAC;aAClE;iBAAM,IAAI,gBAAgB,YAAY,uCAAkB,EAAE;gBACzD,eAAe,GAAG,SAAS,CAAC,qBAAqB,CAAC,gBAAgB,CAAC,CAAC;gBAEpE,0FAA0F;gBAC1F,oBAAoB,GAAG,gCAAU,CAAC,MAAM,CAAC;gBAEzC,SAAS,GAAG,CAAA,eAAe,aAAf,eAAe,uBAAf,eAAe,CAAE,WAAW,KAAI,gBAAgB,CAAC,SAAS,CAAC;aACxE;iBAAM;gBACL,SAAS;aACV;YAED,IAAI,eAAe,IAAI,eAAe,CAAC,UAAU,EAAE;gBACjD,IAAI,gCAAU,CAAC,OAAO,CAAC,qBAAqB,EAAE,oBAAoB,CAAC,GAAG,CAAC,EAAE;oBACvE,SAAS,CAAC,aAAa,CAAC,gBAAgB,kFAEtC,eAAe,cAAc,CAAC,SAAS,CAAC,SAAS,GAAG;wBAClD,iBAAiB,gCAAU,CAAC,UAAU,CAAC,qBAAqB,CAAC,GAAG;wBAChE,kCAAkC,SAAS,GAAG;wBAC9C,uBAAuB,gCAAU,CAAC,UAAU,CAAC,oBAAoB,CAAC,EAAE,EACtE,cAAc,CACf,CAAC;iBACH;aACF;iBAAM;gBACL,MAAM,kBAAkB,GAAW,IAAI,CAAC,QAAQ,CAC9C,SAAS,CAAC,cAAc,CAAC,oBAAoB,CAAC,QAAQ,CACvD,CAAC;gBAEF,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,gBAAgB,CAAC,EAAE;oBAChD,qBAAqB,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;oBAE5C,IACE,gBAAgB,YAAY,qBAAS;wBACrC,kBAAkB,CAAC,mBAAmB,CAAC,gBAAgB,CAAC,EACxD;wBACA,mGAAmG;wBACnG,oEAAoE;qBACrE;yBAAM;wBACL,SAAS,CAAC,aAAa,CAAC,gBAAgB,iEAEtC,eAAe,SAAS,6CAA6C,kBAAkB,EAAE,EACzF,cAAc,CACf,CAAC;qBACH;iBACF;aACF;SACF;IACH,CAAC;IAED,+EAA+E;IAC/E,EAAE;IACF,sDAAsD;IAC9C,MAAM,CAAC,mBAAmB,CAAC,SAAoB;QACrD,IAAI,SAAS,CAAC,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE;YAC1C,OAAO,KAAK,CAAC;SACd;QAED,oCAAoC;QACpC,EAAE;QACF,yBAAyB;QACzB,kCAAkC;QAClC,mCAAmC;QACnC,oBAAoB;QACpB,6CAA6C;QAC7C,qCAAqC;QACrC,MAAM,cAAc,GAAmB,SAAS,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;QACpE,IAAI,EAAE,CAAC,qBAAqB,CAAC,cAAc,CAAC,WAAW,CAAC,EAAE;YACxD,MAAM,gBAAgB,GAA4B,cAAc,CAAC,WAAW,CAAC,IAAI,CAAC;YAClF,IAAI,gBAAgB,EAAE;gBACpB,KAAK,MAAM,KAAK,IAAI,gBAAgB,CAAC,WAAW,EAAE,EAAE;oBAClD,IAAI,KAAK,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,aAAa,EAAE;wBAC9C,OAAO,IAAI,CAAC;qBACb;iBACF;aACF;SACF;QAED,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AA3RD,gDA2RC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nimport type { Collector } from '../collector/Collector';\nimport { AstSymbol } from '../analyzer/AstSymbol';\nimport type { AstDeclaration } from '../analyzer/AstDeclaration';\nimport type { ApiItemMetadata } from '../collector/ApiItemMetadata';\nimport type { SymbolMetadata } from '../collector/SymbolMetadata';\nimport type { CollectorEntity } from '../collector/CollectorEntity';\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\nimport type { AstModuleExportInfo } from '../analyzer/AstModule';\nimport type { AstEntity } from '../analyzer/AstEntity';\n\nexport class ValidationEnhancer {\n  public static analyze(collector: Collector): void {\n    const alreadyWarnedEntities: Set<AstEntity> = new Set<AstEntity>();\n\n    for (const entity of collector.entities) {\n      if (\n        !(\n          entity.consumable ||\n          collector.extractorConfig.apiReportIncludeForgottenExports ||\n          collector.extractorConfig.docModelIncludeForgottenExports\n        )\n      ) {\n        continue;\n      }\n\n      if (entity.astEntity instanceof AstSymbol) {\n        // A regular exported AstSymbol\n\n        const astSymbol: AstSymbol = entity.astEntity;\n\n        astSymbol.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\n          ValidationEnhancer._checkReferences(collector, astDeclaration, alreadyWarnedEntities);\n        });\n\n        const symbolMetadata: SymbolMetadata = collector.fetchSymbolMetadata(astSymbol);\n        ValidationEnhancer._checkForInternalUnderscore(collector, entity, astSymbol, symbolMetadata);\n        ValidationEnhancer._checkForInconsistentReleaseTags(collector, astSymbol, symbolMetadata);\n      } else if (entity.astEntity instanceof AstNamespaceImport) {\n        // A namespace created using \"import * as ___ from ___\"\n        const astNamespaceImport: AstNamespaceImport = entity.astEntity;\n\n        const astModuleExportInfo: AstModuleExportInfo =\n          astNamespaceImport.fetchAstModuleExportInfo(collector);\n\n        for (const namespaceMemberAstEntity of astModuleExportInfo.exportedLocalEntities.values()) {\n          if (namespaceMemberAstEntity instanceof AstSymbol) {\n            const astSymbol: AstSymbol = namespaceMemberAstEntity;\n\n            astSymbol.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\n              ValidationEnhancer._checkReferences(collector, astDeclaration, alreadyWarnedEntities);\n            });\n\n            const symbolMetadata: SymbolMetadata = collector.fetchSymbolMetadata(astSymbol);\n\n            // (Don't apply ValidationEnhancer._checkForInternalUnderscore() for AstNamespaceImport members)\n\n            ValidationEnhancer._checkForInconsistentReleaseTags(collector, astSymbol, symbolMetadata);\n          }\n        }\n      }\n    }\n  }\n\n  private static _checkForInternalUnderscore(\n    collector: Collector,\n    collectorEntity: CollectorEntity,\n    astSymbol: AstSymbol,\n    symbolMetadata: SymbolMetadata\n  ): void {\n    let needsUnderscore: boolean = false;\n\n    if (symbolMetadata.maxEffectiveReleaseTag === ReleaseTag.Internal) {\n      if (!astSymbol.parentAstSymbol) {\n        // If it's marked as @internal and has no parent, then it needs an underscore.\n        // We use maxEffectiveReleaseTag because a merged declaration would NOT need an underscore in a case like this:\n        //\n        //   /** @public */\n        //   export enum X { }\n        //\n        //   /** @internal */\n        //   export namespace X { }\n        //\n        // (The above normally reports an error \"ae-different-release-tags\", but that may be suppressed.)\n        needsUnderscore = true;\n      } else {\n        // If it's marked as @internal and the parent isn't obviously already @internal, then it needs an underscore.\n        //\n        // For example, we WOULD need an underscore for a merged declaration like this:\n        //\n        //   /** @internal */\n        //   export namespace X {\n        //     export interface _Y { }\n        //   }\n        //\n        //   /** @public */\n        //   export class X {\n        //     /** @internal */\n        //     public static _Y(): void { }   // <==== different from parent\n        //   }\n        const parentSymbolMetadata: SymbolMetadata = collector.fetchSymbolMetadata(astSymbol);\n        if (parentSymbolMetadata.maxEffectiveReleaseTag > ReleaseTag.Internal) {\n          needsUnderscore = true;\n        }\n      }\n    }\n\n    if (needsUnderscore) {\n      for (const exportName of collectorEntity.exportNames) {\n        if (exportName[0] !== '_') {\n          collector.messageRouter.addAnalyzerIssue(\n            ExtractorMessageId.InternalMissingUnderscore,\n            `The name \"${exportName}\" should be prefixed with an underscore` +\n              ` because the declaration is marked as @internal`,\n            astSymbol,\n            { exportName }\n          );\n        }\n      }\n    }\n  }\n\n  private static _checkForInconsistentReleaseTags(\n    collector: Collector,\n    astSymbol: AstSymbol,\n    symbolMetadata: SymbolMetadata\n  ): void {\n    if (astSymbol.isExternal) {\n      // For now, don't report errors for external code.  If the developer cares about it, they should run\n      // API Extractor separately on the external project\n      return;\n    }\n\n    // Normally we will expect all release tags to be the same.  Arbitrarily we choose the maxEffectiveReleaseTag\n    // as the thing they should all match.\n    const expectedEffectiveReleaseTag: ReleaseTag = symbolMetadata.maxEffectiveReleaseTag;\n\n    // This is set to true if we find a declaration whose release tag is different from expectedEffectiveReleaseTag\n    let mixedReleaseTags: boolean = false;\n\n    // This is set to false if we find a declaration that is not a function/method overload\n    let onlyFunctionOverloads: boolean = true;\n\n    // This is set to true if we find a declaration that is @internal\n    let anyInternalReleaseTags: boolean = false;\n\n    for (const astDeclaration of astSymbol.astDeclarations) {\n      const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\n      const effectiveReleaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      switch (astDeclaration.declaration.kind) {\n        case ts.SyntaxKind.FunctionDeclaration:\n        case ts.SyntaxKind.MethodDeclaration:\n          break;\n        default:\n          onlyFunctionOverloads = false;\n      }\n\n      if (effectiveReleaseTag !== expectedEffectiveReleaseTag) {\n        mixedReleaseTags = true;\n      }\n\n      if (effectiveReleaseTag === ReleaseTag.Internal) {\n        anyInternalReleaseTags = true;\n      }\n    }\n\n    if (mixedReleaseTags) {\n      if (!onlyFunctionOverloads) {\n        collector.messageRouter.addAnalyzerIssue(\n          ExtractorMessageId.DifferentReleaseTags,\n          'This symbol has another declaration with a different release tag',\n          astSymbol\n        );\n      }\n\n      if (anyInternalReleaseTags) {\n        collector.messageRouter.addAnalyzerIssue(\n          ExtractorMessageId.InternalMixedReleaseTag,\n          `Mixed release tags are not allowed for \"${astSymbol.localName}\" because one of its declarations` +\n            ` is marked as @internal`,\n          astSymbol\n        );\n      }\n    }\n  }\n\n  private static _checkReferences(\n    collector: Collector,\n    astDeclaration: AstDeclaration,\n    alreadyWarnedEntities: Set<AstEntity>\n  ): void {\n    const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\n    const declarationReleaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n    for (const referencedEntity of astDeclaration.referencedAstEntities) {\n      let collectorEntity: CollectorEntity | undefined;\n      let referencedReleaseTag: ReleaseTag;\n      let localName: string;\n\n      if (referencedEntity instanceof AstSymbol) {\n        // If this is e.g. a member of a namespace, then we need to be checking the top-level scope to see\n        // whether it's exported.\n        //\n        // TODO: Technically we should also check each of the nested scopes along the way.\n        const rootSymbol: AstSymbol = referencedEntity.rootAstSymbol;\n\n        if (rootSymbol.isExternal) {\n          continue;\n        }\n\n        collectorEntity = collector.tryGetCollectorEntity(rootSymbol);\n        localName = collectorEntity?.nameForEmit || rootSymbol.localName;\n\n        const referencedMetadata: SymbolMetadata = collector.fetchSymbolMetadata(referencedEntity);\n        referencedReleaseTag = referencedMetadata.maxEffectiveReleaseTag;\n      } else if (referencedEntity instanceof AstNamespaceImport) {\n        collectorEntity = collector.tryGetCollectorEntity(referencedEntity);\n\n        // TODO: Currently the \"import * as ___ from ___\" syntax does not yet support doc comments\n        referencedReleaseTag = ReleaseTag.Public;\n\n        localName = collectorEntity?.nameForEmit || referencedEntity.localName;\n      } else {\n        continue;\n      }\n\n      if (collectorEntity && collectorEntity.consumable) {\n        if (ReleaseTag.compare(declarationReleaseTag, referencedReleaseTag) > 0) {\n          collector.messageRouter.addAnalyzerIssue(\n            ExtractorMessageId.IncompatibleReleaseTags,\n            `The symbol \"${astDeclaration.astSymbol.localName}\"` +\n              ` is marked as ${ReleaseTag.getTagName(declarationReleaseTag)},` +\n              ` but its signature references \"${localName}\"` +\n              ` which is marked as ${ReleaseTag.getTagName(referencedReleaseTag)}`,\n            astDeclaration\n          );\n        }\n      } else {\n        const entryPointFilename: string = path.basename(\n          collector.workingPackage.entryPointSourceFile.fileName\n        );\n\n        if (!alreadyWarnedEntities.has(referencedEntity)) {\n          alreadyWarnedEntities.add(referencedEntity);\n\n          if (\n            referencedEntity instanceof AstSymbol &&\n            ValidationEnhancer._isEcmaScriptSymbol(referencedEntity)\n          ) {\n            // The main usage scenario for ECMAScript symbols is to attach private data to a JavaScript object,\n            // so as a special case, we do NOT report them as forgotten exports.\n          } else {\n            collector.messageRouter.addAnalyzerIssue(\n              ExtractorMessageId.ForgottenExport,\n              `The symbol \"${localName}\" needs to be exported by the entry point ${entryPointFilename}`,\n              astDeclaration\n            );\n          }\n        }\n      }\n    }\n  }\n\n  // Detect an AstSymbol that refers to an ECMAScript symbol declaration such as:\n  //\n  // const mySymbol: unique symbol = Symbol('mySymbol');\n  private static _isEcmaScriptSymbol(astSymbol: AstSymbol): boolean {\n    if (astSymbol.astDeclarations.length !== 1) {\n      return false;\n    }\n\n    // We are matching a form like this:\n    //\n    // - VariableDeclaration:\n    //   - Identifier:  pre=[mySymbol]\n    //   - ColonToken:  pre=[:] sep=[ ]\n    //   - TypeOperator:\n    //     - UniqueKeyword:  pre=[unique] sep=[ ]\n    //     - SymbolKeyword:  pre=[symbol]\n    const astDeclaration: AstDeclaration = astSymbol.astDeclarations[0];\n    if (ts.isVariableDeclaration(astDeclaration.declaration)) {\n      const variableTypeNode: ts.TypeNode | undefined = astDeclaration.declaration.type;\n      if (variableTypeNode) {\n        for (const token of variableTypeNode.getChildren()) {\n          if (token.kind === ts.SyntaxKind.SymbolKeyword) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ValidationEnhancer.js","sourceRoot":"","sources":["../../src/enhancers/ValidationEnhancer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as ts from 'typescript';\r\n\r\nimport type { Collector } from '../collector/Collector';\r\nimport { AstSymbol } from '../analyzer/AstSymbol';\r\nimport type { AstDeclaration } from '../analyzer/AstDeclaration';\r\nimport type { ApiItemMetadata } from '../collector/ApiItemMetadata';\r\nimport type { SymbolMetadata } from '../collector/SymbolMetadata';\r\nimport type { CollectorEntity } from '../collector/CollectorEntity';\r\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\r\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\r\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\r\nimport type { AstModuleExportInfo } from '../analyzer/AstModule';\r\nimport type { AstEntity } from '../analyzer/AstEntity';\r\n\r\nexport class ValidationEnhancer {\r\n  public static analyze(collector: Collector): void {\r\n    const alreadyWarnedEntities: Set<AstEntity> = new Set<AstEntity>();\r\n\r\n    for (const entity of collector.entities) {\r\n      if (\r\n        !(\r\n          entity.consumable ||\r\n          collector.extractorConfig.apiReportIncludeForgottenExports ||\r\n          collector.extractorConfig.docModelIncludeForgottenExports\r\n        )\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      if (entity.astEntity instanceof AstSymbol) {\r\n        // A regular exported AstSymbol\r\n\r\n        const astSymbol: AstSymbol = entity.astEntity;\r\n\r\n        astSymbol.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\r\n          ValidationEnhancer._checkReferences(collector, astDeclaration, alreadyWarnedEntities);\r\n        });\r\n\r\n        const symbolMetadata: SymbolMetadata = collector.fetchSymbolMetadata(astSymbol);\r\n        ValidationEnhancer._checkForInternalUnderscore(collector, entity, astSymbol, symbolMetadata);\r\n        ValidationEnhancer._checkForInconsistentReleaseTags(collector, astSymbol, symbolMetadata);\r\n      } else if (entity.astEntity instanceof AstNamespaceImport) {\r\n        // A namespace created using \"import * as ___ from ___\"\r\n        const astNamespaceImport: AstNamespaceImport = entity.astEntity;\r\n\r\n        const astModuleExportInfo: AstModuleExportInfo =\r\n          astNamespaceImport.fetchAstModuleExportInfo(collector);\r\n\r\n        for (const namespaceMemberAstEntity of astModuleExportInfo.exportedLocalEntities.values()) {\r\n          if (namespaceMemberAstEntity instanceof AstSymbol) {\r\n            const astSymbol: AstSymbol = namespaceMemberAstEntity;\r\n\r\n            astSymbol.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\r\n              ValidationEnhancer._checkReferences(collector, astDeclaration, alreadyWarnedEntities);\r\n            });\r\n\r\n            const symbolMetadata: SymbolMetadata = collector.fetchSymbolMetadata(astSymbol);\r\n\r\n            // (Don't apply ValidationEnhancer._checkForInternalUnderscore() for AstNamespaceImport members)\r\n\r\n            ValidationEnhancer._checkForInconsistentReleaseTags(collector, astSymbol, symbolMetadata);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _checkForInternalUnderscore(\r\n    collector: Collector,\r\n    collectorEntity: CollectorEntity,\r\n    astSymbol: AstSymbol,\r\n    symbolMetadata: SymbolMetadata\r\n  ): void {\r\n    let needsUnderscore: boolean = false;\r\n\r\n    if (symbolMetadata.maxEffectiveReleaseTag === ReleaseTag.Internal) {\r\n      if (!astSymbol.parentAstSymbol) {\r\n        // If it's marked as @internal and has no parent, then it needs an underscore.\r\n        // We use maxEffectiveReleaseTag because a merged declaration would NOT need an underscore in a case like this:\r\n        //\r\n        //   /** @public */\r\n        //   export enum X { }\r\n        //\r\n        //   /** @internal */\r\n        //   export namespace X { }\r\n        //\r\n        // (The above normally reports an error \"ae-different-release-tags\", but that may be suppressed.)\r\n        needsUnderscore = true;\r\n      } else {\r\n        // If it's marked as @internal and the parent isn't obviously already @internal, then it needs an underscore.\r\n        //\r\n        // For example, we WOULD need an underscore for a merged declaration like this:\r\n        //\r\n        //   /** @internal */\r\n        //   export namespace X {\r\n        //     export interface _Y { }\r\n        //   }\r\n        //\r\n        //   /** @public */\r\n        //   export class X {\r\n        //     /** @internal */\r\n        //     public static _Y(): void { }   // <==== different from parent\r\n        //   }\r\n        const parentSymbolMetadata: SymbolMetadata = collector.fetchSymbolMetadata(astSymbol);\r\n        if (parentSymbolMetadata.maxEffectiveReleaseTag > ReleaseTag.Internal) {\r\n          needsUnderscore = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (needsUnderscore) {\r\n      for (const exportName of collectorEntity.exportNames) {\r\n        if (exportName[0] !== '_') {\r\n          collector.messageRouter.addAnalyzerIssue(\r\n            ExtractorMessageId.InternalMissingUnderscore,\r\n            `The name \"${exportName}\" should be prefixed with an underscore` +\r\n              ` because the declaration is marked as @internal`,\r\n            astSymbol,\r\n            { exportName }\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _checkForInconsistentReleaseTags(\r\n    collector: Collector,\r\n    astSymbol: AstSymbol,\r\n    symbolMetadata: SymbolMetadata\r\n  ): void {\r\n    if (astSymbol.isExternal) {\r\n      // For now, don't report errors for external code.  If the developer cares about it, they should run\r\n      // API Extractor separately on the external project\r\n      return;\r\n    }\r\n\r\n    // Normally we will expect all release tags to be the same.  Arbitrarily we choose the maxEffectiveReleaseTag\r\n    // as the thing they should all match.\r\n    const expectedEffectiveReleaseTag: ReleaseTag = symbolMetadata.maxEffectiveReleaseTag;\r\n\r\n    // This is set to true if we find a declaration whose release tag is different from expectedEffectiveReleaseTag\r\n    let mixedReleaseTags: boolean = false;\r\n\r\n    // This is set to false if we find a declaration that is not a function/method overload\r\n    let onlyFunctionOverloads: boolean = true;\r\n\r\n    // This is set to true if we find a declaration that is @internal\r\n    let anyInternalReleaseTags: boolean = false;\r\n\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\r\n      const effectiveReleaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n\r\n      switch (astDeclaration.declaration.kind) {\r\n        case ts.SyntaxKind.FunctionDeclaration:\r\n        case ts.SyntaxKind.MethodDeclaration:\r\n          break;\r\n        default:\r\n          onlyFunctionOverloads = false;\r\n      }\r\n\r\n      if (effectiveReleaseTag !== expectedEffectiveReleaseTag) {\r\n        mixedReleaseTags = true;\r\n      }\r\n\r\n      if (effectiveReleaseTag === ReleaseTag.Internal) {\r\n        anyInternalReleaseTags = true;\r\n      }\r\n    }\r\n\r\n    if (mixedReleaseTags) {\r\n      if (!onlyFunctionOverloads) {\r\n        collector.messageRouter.addAnalyzerIssue(\r\n          ExtractorMessageId.DifferentReleaseTags,\r\n          'This symbol has another declaration with a different release tag',\r\n          astSymbol\r\n        );\r\n      }\r\n\r\n      if (anyInternalReleaseTags) {\r\n        collector.messageRouter.addAnalyzerIssue(\r\n          ExtractorMessageId.InternalMixedReleaseTag,\r\n          `Mixed release tags are not allowed for \"${astSymbol.localName}\" because one of its declarations` +\r\n            ` is marked as @internal`,\r\n          astSymbol\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _checkReferences(\r\n    collector: Collector,\r\n    astDeclaration: AstDeclaration,\r\n    alreadyWarnedEntities: Set<AstEntity>\r\n  ): void {\r\n    const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\r\n    const declarationReleaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n\r\n    for (const referencedEntity of astDeclaration.referencedAstEntities) {\r\n      let collectorEntity: CollectorEntity | undefined;\r\n      let referencedReleaseTag: ReleaseTag;\r\n      let localName: string;\r\n\r\n      if (referencedEntity instanceof AstSymbol) {\r\n        // If this is e.g. a member of a namespace, then we need to be checking the top-level scope to see\r\n        // whether it's exported.\r\n        //\r\n        // TODO: Technically we should also check each of the nested scopes along the way.\r\n        const rootSymbol: AstSymbol = referencedEntity.rootAstSymbol;\r\n\r\n        if (rootSymbol.isExternal) {\r\n          continue;\r\n        }\r\n\r\n        collectorEntity = collector.tryGetCollectorEntity(rootSymbol);\r\n        localName = collectorEntity?.nameForEmit || rootSymbol.localName;\r\n\r\n        const referencedMetadata: SymbolMetadata = collector.fetchSymbolMetadata(referencedEntity);\r\n        referencedReleaseTag = referencedMetadata.maxEffectiveReleaseTag;\r\n      } else if (referencedEntity instanceof AstNamespaceImport) {\r\n        collectorEntity = collector.tryGetCollectorEntity(referencedEntity);\r\n\r\n        // TODO: Currently the \"import * as ___ from ___\" syntax does not yet support doc comments\r\n        referencedReleaseTag = ReleaseTag.Public;\r\n\r\n        localName = collectorEntity?.nameForEmit || referencedEntity.localName;\r\n      } else {\r\n        continue;\r\n      }\r\n\r\n      if (ReleaseTag.compare(declarationReleaseTag, referencedReleaseTag) > 0) {\r\n        collector.messageRouter.addAnalyzerIssue(\r\n          ExtractorMessageId.IncompatibleReleaseTags,\r\n          `The symbol \"${astDeclaration.astSymbol.localName}\"` +\r\n            ` is marked as ${ReleaseTag.getTagName(declarationReleaseTag)},` +\r\n            ` but its signature references \"${localName}\"` +\r\n            ` which is marked as ${ReleaseTag.getTagName(referencedReleaseTag)}`,\r\n          astDeclaration\r\n        );\r\n      }\r\n\r\n      if (!collectorEntity || !collectorEntity.consumable) {\r\n        const entryPointFilename: string = path.basename(\r\n          collector.workingPackage.entryPointSourceFile.fileName\r\n        );\r\n\r\n        if (!alreadyWarnedEntities.has(referencedEntity)) {\r\n          alreadyWarnedEntities.add(referencedEntity);\r\n\r\n          if (\r\n            referencedEntity instanceof AstSymbol &&\r\n            ValidationEnhancer._isEcmaScriptSymbol(referencedEntity)\r\n          ) {\r\n            // The main usage scenario for ECMAScript symbols is to attach private data to a JavaScript object,\r\n            // so as a special case, we do NOT report them as forgotten exports.\r\n          } else {\r\n            collector.messageRouter.addAnalyzerIssue(\r\n              ExtractorMessageId.ForgottenExport,\r\n              `The symbol \"${localName}\" needs to be exported by the entry point ${entryPointFilename}`,\r\n              astDeclaration\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Detect an AstSymbol that refers to an ECMAScript symbol declaration such as:\r\n  //\r\n  // const mySymbol: unique symbol = Symbol('mySymbol');\r\n  private static _isEcmaScriptSymbol(astSymbol: AstSymbol): boolean {\r\n    if (astSymbol.astDeclarations.length !== 1) {\r\n      return false;\r\n    }\r\n\r\n    // We are matching a form like this:\r\n    //\r\n    // - VariableDeclaration:\r\n    //   - Identifier:  pre=[mySymbol]\r\n    //   - ColonToken:  pre=[:] sep=[ ]\r\n    //   - TypeOperator:\r\n    //     - UniqueKeyword:  pre=[unique] sep=[ ]\r\n    //     - SymbolKeyword:  pre=[symbol]\r\n    const astDeclaration: AstDeclaration = astSymbol.astDeclarations[0];\r\n    if (ts.isVariableDeclaration(astDeclaration.declaration)) {\r\n      const variableTypeNode: ts.TypeNode | undefined = astDeclaration.declaration.type;\r\n      if (variableTypeNode) {\r\n        for (const token of variableTypeNode.getChildren()) {\r\n          if (token.kind === ts.SyntaxKind.SymbolKeyword) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/generators/ApiModelGenerator.js.map b/lib/generators/ApiModelGenerator.js.map
index 19ab35cd23f408fa0e823823db10a84657173c11..5785b9a71e62fbe64dfca85b9fc5498100f8dde2 100644
--- a/lib/generators/ApiModelGenerator.js.map
+++ b/lib/generators/ApiModelGenerator.js.map
@@ -1 +1 @@
-{"version":3,"file":"ApiModelGenerator.js","sourceRoot":"","sources":["../../src/generators/ApiModelGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/* eslint-disable no-bitwise */\n\nimport * as path from 'path';\nimport * as ts from 'typescript';\nimport type * as tsdoc from '@microsoft/tsdoc';\nimport {\n  ApiModel,\n  ApiClass,\n  ApiPackage,\n  ApiEntryPoint,\n  ApiMethod,\n  ApiNamespace,\n  ApiInterface,\n  ApiPropertySignature,\n  type ApiItemContainerMixin,\n  ReleaseTag,\n  ApiProperty,\n  ApiMethodSignature,\n  type IApiParameterOptions,\n  ApiEnum,\n  ApiEnumMember,\n  type IExcerptTokenRange,\n  type IExcerptToken,\n  ApiConstructor,\n  ApiConstructSignature,\n  ApiFunction,\n  ApiIndexSignature,\n  ApiVariable,\n  ApiTypeAlias,\n  ApiCallSignature,\n  type IApiTypeParameterOptions,\n  EnumMemberOrder\n} from '@microsoft/api-extractor-model';\nimport { Path } from '@rushstack/node-core-library';\n\nimport type { Collector } from '../collector/Collector';\nimport type { ISourceLocation } from '../collector/SourceMapper';\nimport type { AstDeclaration } from '../analyzer/AstDeclaration';\nimport { ExcerptBuilder, type IExcerptBuilderNodeToCapture } from './ExcerptBuilder';\nimport { AstSymbol } from '../analyzer/AstSymbol';\nimport { DeclarationReferenceGenerator } from './DeclarationReferenceGenerator';\nimport type { ApiItemMetadata } from '../collector/ApiItemMetadata';\nimport type { DeclarationMetadata } from '../collector/DeclarationMetadata';\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\nimport type { AstEntity } from '../analyzer/AstEntity';\nimport type { AstModule } from '../analyzer/AstModule';\nimport { TypeScriptInternals } from '../analyzer/TypeScriptInternals';\n\ninterface IProcessAstEntityContext {\n  name: string;\n  isExported: boolean;\n  parentApiItem: ApiItemContainerMixin;\n}\n\nexport class ApiModelGenerator {\n  private readonly _collector: Collector;\n  private readonly _apiModel: ApiModel;\n  private readonly _referenceGenerator: DeclarationReferenceGenerator;\n\n  public constructor(collector: Collector) {\n    this._collector = collector;\n    this._apiModel = new ApiModel();\n    this._referenceGenerator = new DeclarationReferenceGenerator(collector);\n  }\n\n  public get apiModel(): ApiModel {\n    return this._apiModel;\n  }\n\n  public buildApiPackage(): ApiPackage {\n    const packageDocComment: tsdoc.DocComment | undefined = this._collector.workingPackage.tsdocComment;\n\n    const apiPackage: ApiPackage = new ApiPackage({\n      name: this._collector.workingPackage.name,\n      docComment: packageDocComment,\n      tsdocConfiguration: this._collector.extractorConfig.tsdocConfiguration,\n      projectFolderUrl: this._collector.extractorConfig.projectFolderUrl\n    });\n    this._apiModel.addMember(apiPackage);\n\n    const apiEntryPoint: ApiEntryPoint = new ApiEntryPoint({ name: '' });\n    apiPackage.addMember(apiEntryPoint);\n\n    for (const entity of this._collector.entities) {\n      // Only process entities that are exported from the entry point. Entities that are exported from\n      // `AstNamespaceImport` entities will be processed by `_processAstNamespaceImport`. However, if\n      // we are including forgotten exports, then process everything.\n      if (entity.exportedFromEntryPoint || this._collector.extractorConfig.docModelIncludeForgottenExports) {\n        this._processAstEntity(entity.astEntity, {\n          name: entity.nameForEmit!,\n          isExported: entity.exportedFromEntryPoint,\n          parentApiItem: apiEntryPoint\n        });\n      }\n    }\n\n    return apiPackage;\n  }\n\n  private _processAstEntity(astEntity: AstEntity, context: IProcessAstEntityContext): void {\n    if (astEntity instanceof AstSymbol) {\n      // Skip ancillary declarations; we will process them with the main declaration\n      for (const astDeclaration of this._collector.getNonAncillaryDeclarations(astEntity)) {\n        this._processDeclaration(astDeclaration, context);\n      }\n      return;\n    }\n\n    if (astEntity instanceof AstNamespaceImport) {\n      // Note that a single API item can belong to two different AstNamespaceImport namespaces.  For example:\n      //\n      //   // file.ts defines \"thing()\"\n      //   import * as example1 from \"./file\";\n      //   import * as example2 from \"./file\";\n      //\n      //   // ...so here we end up with example1.thing() and example2.thing()\n      //   export { example1, example2 }\n      //\n      // The current logic does not try to associate \"thing()\" with a specific parent.  Instead\n      // the API documentation will show duplicated entries for example1.thing() and example2.thing().\n      //\n      // This could be improved in the future, but it requires a stable mechanism for choosing an associated parent.\n      // For thoughts about this:  https://github.com/microsoft/rushstack/issues/1308\n      this._processAstNamespaceImport(astEntity, context);\n      return;\n    }\n\n    // TODO: Figure out how to represent reexported AstImport objects.  Basically we need to introduce a new\n    // ApiItem subclass for \"export alias\", similar to a type alias, but representing declarations of the\n    // form \"export { X } from 'external-package'\".  We can also use this to solve GitHub issue #950.\n  }\n\n  private _processAstNamespaceImport(\n    astNamespaceImport: AstNamespaceImport,\n    context: IProcessAstEntityContext\n  ): void {\n    const astModule: AstModule = astNamespaceImport.astModule;\n    const { name, isExported, parentApiItem } = context;\n    const containerKey: string = ApiNamespace.getContainerKey(name);\n    const fileUrlPath: string = this._getFileUrlPath(astNamespaceImport.declaration);\n\n    let apiNamespace: ApiNamespace | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiNamespace;\n\n    if (apiNamespace === undefined) {\n      apiNamespace = new ApiNamespace({\n        name,\n        docComment: undefined,\n        releaseTag: ReleaseTag.None,\n        excerptTokens: [],\n        isExported,\n        fileUrlPath\n      });\n      parentApiItem.addMember(apiNamespace);\n    }\n\n    astModule.astModuleExportInfo!.exportedLocalEntities.forEach(\n      (exportedEntity: AstEntity, exportedName: string) => {\n        this._processAstEntity(exportedEntity, {\n          name: exportedName,\n          isExported: true,\n          parentApiItem: apiNamespace!\n        });\n      }\n    );\n  }\n\n  private _processDeclaration(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    if ((astDeclaration.modifierFlags & ts.ModifierFlags.Private) !== 0) {\n      return; // trim out private declarations\n    }\n\n    const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n    const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n    if (releaseTag === ReleaseTag.Internal) {\n      return; // trim out items marked as \"@internal\"\n    }\n\n    switch (astDeclaration.declaration.kind) {\n      case ts.SyntaxKind.CallSignature:\n        this._processApiCallSignature(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.Constructor:\n        this._processApiConstructor(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.ConstructSignature:\n        this._processApiConstructSignature(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.ClassDeclaration:\n        this._processApiClass(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.EnumDeclaration:\n        this._processApiEnum(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.EnumMember:\n        this._processApiEnumMember(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.FunctionDeclaration:\n        this._processApiFunction(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.GetAccessor:\n        this._processApiProperty(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.SetAccessor:\n        this._processApiProperty(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.IndexSignature:\n        this._processApiIndexSignature(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.InterfaceDeclaration:\n        this._processApiInterface(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.MethodDeclaration:\n        this._processApiMethod(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.MethodSignature:\n        this._processApiMethodSignature(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.ModuleDeclaration:\n        this._processApiNamespace(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.PropertyDeclaration:\n        this._processApiProperty(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.PropertySignature:\n        this._processApiPropertySignature(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.TypeAliasDeclaration:\n        this._processApiTypeAlias(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.VariableDeclaration:\n        this._processApiVariable(astDeclaration, context);\n        break;\n\n      default:\n      // ignore unknown types\n    }\n  }\n\n  private _processChildDeclarations(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    for (const childDeclaration of astDeclaration.children) {\n      this._processDeclaration(childDeclaration, {\n        ...context,\n        name: childDeclaration.astSymbol.localName\n      });\n    }\n  }\n\n  private _processApiCallSignature(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { parentApiItem } = context;\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiCallSignature.getContainerKey(overloadIndex);\n\n    let apiCallSignature: ApiCallSignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiCallSignature;\n\n    if (apiCallSignature === undefined) {\n      const callSignature: ts.CallSignatureDeclaration =\n        astDeclaration.declaration as ts.CallSignatureDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: callSignature.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        callSignature.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        callSignature.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const fileUrlPath: string = this._getFileUrlPath(callSignature);\n\n      apiCallSignature = new ApiCallSignature({\n        docComment,\n        releaseTag,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiCallSignature);\n    }\n  }\n\n  private _processApiConstructor(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { parentApiItem } = context;\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiConstructor.getContainerKey(overloadIndex);\n\n    let apiConstructor: ApiConstructor | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiConstructor;\n\n    if (apiConstructor === undefined) {\n      const constructorDeclaration: ts.ConstructorDeclaration =\n        astDeclaration.declaration as ts.ConstructorDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        constructorDeclaration.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isProtected: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Protected) !== 0;\n      const fileUrlPath: string = this._getFileUrlPath(constructorDeclaration);\n\n      apiConstructor = new ApiConstructor({\n        docComment,\n        releaseTag,\n        isProtected,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiConstructor);\n    }\n  }\n\n  private _processApiClass(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, isExported, parentApiItem } = context;\n    const containerKey: string = ApiClass.getContainerKey(name);\n\n    let apiClass: ApiClass | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiClass;\n\n    if (apiClass === undefined) {\n      const classDeclaration: ts.ClassDeclaration = astDeclaration.declaration as ts.ClassDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        classDeclaration.typeParameters\n      );\n\n      let extendsTokenRange: IExcerptTokenRange | undefined = undefined;\n      const implementsTokenRanges: IExcerptTokenRange[] = [];\n\n      for (const heritageClause of classDeclaration.heritageClauses || []) {\n        if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {\n          extendsTokenRange = ExcerptBuilder.createEmptyTokenRange();\n          if (heritageClause.types.length > 0) {\n            nodesToCapture.push({ node: heritageClause.types[0], tokenRange: extendsTokenRange });\n          }\n        } else if (heritageClause.token === ts.SyntaxKind.ImplementsKeyword) {\n          for (const heritageType of heritageClause.types) {\n            const implementsTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n            implementsTokenRanges.push(implementsTokenRange);\n            nodesToCapture.push({ node: heritageType, tokenRange: implementsTokenRange });\n          }\n        }\n      }\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isAbstract: boolean =\n        (ts.getCombinedModifierFlags(classDeclaration) & ts.ModifierFlags.Abstract) !== 0;\n      const fileUrlPath: string = this._getFileUrlPath(classDeclaration);\n\n      apiClass = new ApiClass({\n        name,\n        isAbstract,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        typeParameters,\n        extendsTokenRange,\n        implementsTokenRanges,\n        isExported,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiClass);\n    }\n\n    this._processChildDeclarations(astDeclaration, {\n      ...context,\n      parentApiItem: apiClass\n    });\n  }\n\n  private _processApiConstructSignature(\n    astDeclaration: AstDeclaration,\n    context: IProcessAstEntityContext\n  ): void {\n    const { parentApiItem } = context;\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiConstructSignature.getContainerKey(overloadIndex);\n\n    let apiConstructSignature: ApiConstructSignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiConstructSignature;\n\n    if (apiConstructSignature === undefined) {\n      const constructSignature: ts.ConstructSignatureDeclaration =\n        astDeclaration.declaration as ts.ConstructSignatureDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: constructSignature.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        constructSignature.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        constructSignature.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const fileUrlPath: string = this._getFileUrlPath(constructSignature);\n\n      apiConstructSignature = new ApiConstructSignature({\n        docComment,\n        releaseTag,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiConstructSignature);\n    }\n  }\n\n  private _processApiEnum(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, isExported, parentApiItem } = context;\n    const containerKey: string = ApiEnum.getContainerKey(name);\n\n    let apiEnum: ApiEnum | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiEnum;\n\n    if (apiEnum === undefined) {\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, []);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const preserveMemberOrder: boolean =\n        this._collector.extractorConfig.enumMemberOrder === EnumMemberOrder.Preserve;\n      const fileUrlPath: string = this._getFileUrlPath(astDeclaration.declaration);\n\n      apiEnum = new ApiEnum({\n        name,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        preserveMemberOrder,\n        isExported,\n        fileUrlPath\n      });\n      parentApiItem.addMember(apiEnum);\n    }\n\n    this._processChildDeclarations(astDeclaration, {\n      ...context,\n      parentApiItem: apiEnum\n    });\n  }\n\n  private _processApiEnumMember(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, parentApiItem } = context;\n    const containerKey: string = ApiEnumMember.getContainerKey(name);\n\n    let apiEnumMember: ApiEnumMember | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiEnumMember;\n\n    if (apiEnumMember === undefined) {\n      const enumMember: ts.EnumMember = astDeclaration.declaration as ts.EnumMember;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      let initializerTokenRange: IExcerptTokenRange | undefined = undefined;\n      if (enumMember.initializer) {\n        initializerTokenRange = ExcerptBuilder.createEmptyTokenRange();\n        nodesToCapture.push({ node: enumMember.initializer, tokenRange: initializerTokenRange });\n      }\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const fileUrlPath: string = this._getFileUrlPath(enumMember);\n\n      apiEnumMember = new ApiEnumMember({\n        name,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        initializerTokenRange,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiEnumMember);\n    }\n  }\n\n  private _processApiFunction(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, isExported, parentApiItem } = context;\n\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiFunction.getContainerKey(name, overloadIndex);\n\n    let apiFunction: ApiFunction | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiFunction;\n\n    if (apiFunction === undefined) {\n      const functionDeclaration: ts.FunctionDeclaration =\n        astDeclaration.declaration as ts.FunctionDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: functionDeclaration.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        functionDeclaration.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        functionDeclaration.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const fileUrlPath: string = this._getFileUrlPath(functionDeclaration);\n\n      apiFunction = new ApiFunction({\n        name,\n        docComment,\n        releaseTag,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange,\n        isExported,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiFunction);\n    }\n  }\n\n  private _processApiIndexSignature(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { parentApiItem } = context;\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiIndexSignature.getContainerKey(overloadIndex);\n\n    let apiIndexSignature: ApiIndexSignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiIndexSignature;\n\n    if (apiIndexSignature === undefined) {\n      const indexSignature: ts.IndexSignatureDeclaration =\n        astDeclaration.declaration as ts.IndexSignatureDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: indexSignature.type, tokenRange: returnTypeTokenRange });\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        indexSignature.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isReadonly: boolean = this._isReadonly(astDeclaration);\n      const fileUrlPath: string = this._getFileUrlPath(indexSignature);\n\n      apiIndexSignature = new ApiIndexSignature({\n        docComment,\n        releaseTag,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange,\n        isReadonly,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiIndexSignature);\n    }\n  }\n\n  private _processApiInterface(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, isExported, parentApiItem } = context;\n    const containerKey: string = ApiInterface.getContainerKey(name);\n\n    let apiInterface: ApiInterface | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiInterface;\n\n    if (apiInterface === undefined) {\n      const interfaceDeclaration: ts.InterfaceDeclaration =\n        astDeclaration.declaration as ts.InterfaceDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        interfaceDeclaration.typeParameters\n      );\n\n      const extendsTokenRanges: IExcerptTokenRange[] = [];\n\n      for (const heritageClause of interfaceDeclaration.heritageClauses || []) {\n        if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {\n          for (const heritageType of heritageClause.types) {\n            const extendsTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n            extendsTokenRanges.push(extendsTokenRange);\n            nodesToCapture.push({ node: heritageType, tokenRange: extendsTokenRange });\n          }\n        }\n      }\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const fileUrlPath: string = this._getFileUrlPath(interfaceDeclaration);\n\n      apiInterface = new ApiInterface({\n        name,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        typeParameters,\n        extendsTokenRanges,\n        isExported,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiInterface);\n    }\n\n    this._processChildDeclarations(astDeclaration, {\n      ...context,\n      parentApiItem: apiInterface\n    });\n  }\n\n  private _processApiMethod(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, parentApiItem } = context;\n    const isStatic: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Static) !== 0;\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiMethod.getContainerKey(name, isStatic, overloadIndex);\n\n    let apiMethod: ApiMethod | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiMethod;\n\n    if (apiMethod === undefined) {\n      const methodDeclaration: ts.MethodDeclaration = astDeclaration.declaration as ts.MethodDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: methodDeclaration.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        methodDeclaration.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        methodDeclaration.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      if (releaseTag === ReleaseTag.Internal || releaseTag === ReleaseTag.Alpha) {\n        return; // trim out items marked as \"@internal\" or \"@alpha\"\n      }\n      const isOptional: boolean =\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\n      const isProtected: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Protected) !== 0;\n      const isAbstract: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Abstract) !== 0;\n      const fileUrlPath: string = this._getFileUrlPath(methodDeclaration);\n\n      apiMethod = new ApiMethod({\n        name,\n        isAbstract,\n        docComment,\n        releaseTag,\n        isProtected,\n        isStatic,\n        isOptional,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiMethod);\n    }\n  }\n\n  private _processApiMethodSignature(\n    astDeclaration: AstDeclaration,\n    context: IProcessAstEntityContext\n  ): void {\n    const { name, parentApiItem } = context;\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiMethodSignature.getContainerKey(name, overloadIndex);\n\n    let apiMethodSignature: ApiMethodSignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiMethodSignature;\n\n    if (apiMethodSignature === undefined) {\n      const methodSignature: ts.MethodSignature = astDeclaration.declaration as ts.MethodSignature;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: methodSignature.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        methodSignature.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        methodSignature.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isOptional: boolean =\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\n      const fileUrlPath: string = this._getFileUrlPath(methodSignature);\n\n      apiMethodSignature = new ApiMethodSignature({\n        name,\n        docComment,\n        releaseTag,\n        isOptional,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiMethodSignature);\n    }\n  }\n\n  private _processApiNamespace(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, isExported, parentApiItem } = context;\n    const containerKey: string = ApiNamespace.getContainerKey(name);\n\n    let apiNamespace: ApiNamespace | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiNamespace;\n\n    if (apiNamespace === undefined) {\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, []);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const fileUrlPath: string = this._getFileUrlPath(astDeclaration.declaration);\n\n      apiNamespace = new ApiNamespace({\n        name,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        isExported,\n        fileUrlPath\n      });\n      parentApiItem.addMember(apiNamespace);\n    }\n\n    this._processChildDeclarations(astDeclaration, {\n      ...context,\n      parentApiItem: apiNamespace\n    });\n  }\n\n  private _processApiProperty(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, parentApiItem } = context;\n    const isStatic: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Static) !== 0;\n    const containerKey: string = ApiProperty.getContainerKey(name, isStatic);\n\n    let apiProperty: ApiProperty | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiProperty;\n\n    if (apiProperty === undefined) {\n      const declaration: ts.Declaration = astDeclaration.declaration;\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const propertyTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      let propertyTypeNode: ts.TypeNode | undefined;\n\n      if (ts.isPropertyDeclaration(declaration) || ts.isGetAccessorDeclaration(declaration)) {\n        propertyTypeNode = declaration.type;\n      }\n\n      if (ts.isSetAccessorDeclaration(declaration)) {\n        // Note that TypeScript always reports an error if a setter does not have exactly one parameter.\n        propertyTypeNode = declaration.parameters[0].type;\n      }\n\n      nodesToCapture.push({ node: propertyTypeNode, tokenRange: propertyTypeTokenRange });\n\n      let initializerTokenRange: IExcerptTokenRange | undefined = undefined;\n      if (ts.isPropertyDeclaration(declaration) && declaration.initializer) {\n        initializerTokenRange = ExcerptBuilder.createEmptyTokenRange();\n        nodesToCapture.push({ node: declaration.initializer, tokenRange: initializerTokenRange });\n      }\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isOptional: boolean =\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\n      const isProtected: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Protected) !== 0;\n      const isAbstract: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Abstract) !== 0;\n      const isReadonly: boolean = this._isReadonly(astDeclaration);\n      const fileUrlPath: string = this._getFileUrlPath(declaration);\n\n      apiProperty = new ApiProperty({\n        name,\n        docComment,\n        releaseTag,\n        isAbstract,\n        isProtected,\n        isStatic,\n        isOptional,\n        isReadonly,\n        excerptTokens,\n        propertyTypeTokenRange,\n        initializerTokenRange,\n        fileUrlPath\n      });\n      parentApiItem.addMember(apiProperty);\n    } else {\n      // If the property was already declared before (via a merged interface declaration),\n      // we assume its signature is identical, because the language requires that.\n    }\n  }\n\n  private _processApiPropertySignature(\n    astDeclaration: AstDeclaration,\n    context: IProcessAstEntityContext\n  ): void {\n    const { name, parentApiItem } = context;\n    const containerKey: string = ApiPropertySignature.getContainerKey(name);\n\n    let apiPropertySignature: ApiPropertySignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiPropertySignature;\n\n    if (apiPropertySignature === undefined) {\n      const propertySignature: ts.PropertySignature = astDeclaration.declaration as ts.PropertySignature;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const propertyTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: propertySignature.type, tokenRange: propertyTypeTokenRange });\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isOptional: boolean =\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\n      const isReadonly: boolean = this._isReadonly(astDeclaration);\n      const fileUrlPath: string = this._getFileUrlPath(propertySignature);\n\n      apiPropertySignature = new ApiPropertySignature({\n        name,\n        docComment,\n        releaseTag,\n        isOptional,\n        excerptTokens,\n        propertyTypeTokenRange,\n        isReadonly,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiPropertySignature);\n    } else {\n      // If the property was already declared before (via a merged interface declaration),\n      // we assume its signature is identical, because the language requires that.\n    }\n  }\n\n  private _processApiTypeAlias(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, isExported, parentApiItem } = context;\n\n    const containerKey: string = ApiTypeAlias.getContainerKey(name);\n\n    let apiTypeAlias: ApiTypeAlias | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiTypeAlias;\n\n    if (apiTypeAlias === undefined) {\n      const typeAliasDeclaration: ts.TypeAliasDeclaration =\n        astDeclaration.declaration as ts.TypeAliasDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        typeAliasDeclaration.typeParameters\n      );\n\n      const typeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: typeAliasDeclaration.type, tokenRange: typeTokenRange });\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const fileUrlPath: string = this._getFileUrlPath(typeAliasDeclaration);\n\n      apiTypeAlias = new ApiTypeAlias({\n        name,\n        docComment,\n        typeParameters,\n        releaseTag,\n        excerptTokens,\n        typeTokenRange,\n        isExported,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiTypeAlias);\n    }\n  }\n\n  private _processApiVariable(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, isExported, parentApiItem } = context;\n\n    const containerKey: string = ApiVariable.getContainerKey(name);\n\n    let apiVariable: ApiVariable | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiVariable;\n\n    if (apiVariable === undefined) {\n      const variableDeclaration: ts.VariableDeclaration =\n        astDeclaration.declaration as ts.VariableDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const variableTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: variableDeclaration.type, tokenRange: variableTypeTokenRange });\n\n      let initializerTokenRange: IExcerptTokenRange | undefined = undefined;\n      if (variableDeclaration.initializer) {\n        initializerTokenRange = ExcerptBuilder.createEmptyTokenRange();\n        nodesToCapture.push({ node: variableDeclaration.initializer, tokenRange: initializerTokenRange });\n      }\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isReadonly: boolean = this._isReadonly(astDeclaration);\n      const fileUrlPath: string = this._getFileUrlPath(variableDeclaration);\n\n      apiVariable = new ApiVariable({\n        name,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        variableTypeTokenRange,\n        initializerTokenRange,\n        isReadonly,\n        isExported,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiVariable);\n    }\n  }\n\n  /**\n   * @param nodesToCapture - A list of child nodes whose token ranges we want to capture\n   */\n  private _buildExcerptTokens(\n    astDeclaration: AstDeclaration,\n    nodesToCapture: IExcerptBuilderNodeToCapture[]\n  ): IExcerptToken[] {\n    const excerptTokens: IExcerptToken[] = [];\n\n    // Build the main declaration\n    ExcerptBuilder.addDeclaration(excerptTokens, astDeclaration, nodesToCapture, this._referenceGenerator);\n\n    const declarationMetadata: DeclarationMetadata = this._collector.fetchDeclarationMetadata(astDeclaration);\n\n    // Add any ancillary declarations\n    for (const ancillaryDeclaration of declarationMetadata.ancillaryDeclarations) {\n      ExcerptBuilder.addBlankLine(excerptTokens);\n      ExcerptBuilder.addDeclaration(\n        excerptTokens,\n        ancillaryDeclaration,\n        nodesToCapture,\n        this._referenceGenerator\n      );\n    }\n\n    return excerptTokens;\n  }\n\n  private _captureTypeParameters(\n    nodesToCapture: IExcerptBuilderNodeToCapture[],\n    typeParameterNodes: ts.NodeArray<ts.TypeParameterDeclaration> | undefined\n  ): IApiTypeParameterOptions[] {\n    const typeParameters: IApiTypeParameterOptions[] = [];\n    if (typeParameterNodes) {\n      for (const typeParameter of typeParameterNodes) {\n        const constraintTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n        nodesToCapture.push({ node: typeParameter.constraint, tokenRange: constraintTokenRange });\n\n        const defaultTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n        nodesToCapture.push({ node: typeParameter.default, tokenRange: defaultTypeTokenRange });\n\n        typeParameters.push({\n          typeParameterName: typeParameter.name.getText().trim(),\n          constraintTokenRange,\n          defaultTypeTokenRange\n        });\n      }\n    }\n    return typeParameters;\n  }\n\n  private _captureParameters(\n    nodesToCapture: IExcerptBuilderNodeToCapture[],\n    parameterNodes: ts.NodeArray<ts.ParameterDeclaration>\n  ): IApiParameterOptions[] {\n    const parameters: IApiParameterOptions[] = [];\n    for (const parameter of parameterNodes) {\n      const parameterTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: parameter.type, tokenRange: parameterTypeTokenRange });\n      parameters.push({\n        parameterName: parameter.name.getText().trim(),\n        parameterTypeTokenRange,\n        isOptional: this._collector.typeChecker.isOptionalParameter(parameter)\n      });\n    }\n    return parameters;\n  }\n\n  private _isReadonly(astDeclaration: AstDeclaration): boolean {\n    switch (astDeclaration.declaration.kind) {\n      case ts.SyntaxKind.GetAccessor:\n      case ts.SyntaxKind.IndexSignature:\n      case ts.SyntaxKind.PropertyDeclaration:\n      case ts.SyntaxKind.PropertySignature:\n      case ts.SyntaxKind.SetAccessor:\n      case ts.SyntaxKind.VariableDeclaration: {\n        const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n        const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n        const declarationMetadata: DeclarationMetadata =\n          this._collector.fetchDeclarationMetadata(astDeclaration);\n\n        const hasReadonlyModifier: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Readonly) !== 0;\n        const hasReadonlyDocTag: boolean = !!docComment?.modifierTagSet?.hasTagName('@readonly');\n        const isGetterWithNoSetter: boolean =\n          ts.isGetAccessorDeclaration(astDeclaration.declaration) &&\n          declarationMetadata.ancillaryDeclarations.length === 0;\n        const isVarConst: boolean =\n          ts.isVariableDeclaration(astDeclaration.declaration) &&\n          TypeScriptInternals.isVarConst(astDeclaration.declaration);\n\n        return hasReadonlyModifier || hasReadonlyDocTag || isGetterWithNoSetter || isVarConst;\n      }\n      default: {\n        // Readonly-ness does not make sense for any other declaration kind.\n        return false;\n      }\n    }\n  }\n\n  private _getFileUrlPath(declaration: ts.Declaration): string {\n    const sourceFile: ts.SourceFile = declaration.getSourceFile();\n    const sourceLocation: ISourceLocation = this._collector.sourceMapper.getSourceLocation({\n      sourceFile,\n      pos: declaration.pos\n    });\n\n    let result: string = path.relative(\n      this._collector.extractorConfig.projectFolder,\n      sourceLocation.sourceFilePath\n    );\n    result = Path.convertToSlashes(result);\n    return result;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ApiModelGenerator.js","sourceRoot":"","sources":["../../src/generators/ApiModelGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* eslint-disable no-bitwise */\r\n\r\nimport * as path from 'path';\r\nimport * as ts from 'typescript';\r\nimport type * as tsdoc from '@microsoft/tsdoc';\r\nimport {\r\n  ApiModel,\r\n  ApiClass,\r\n  ApiPackage,\r\n  ApiEntryPoint,\r\n  ApiMethod,\r\n  ApiNamespace,\r\n  ApiInterface,\r\n  ApiPropertySignature,\r\n  type ApiItemContainerMixin,\r\n  ReleaseTag,\r\n  ApiProperty,\r\n  ApiMethodSignature,\r\n  type IApiParameterOptions,\r\n  ApiEnum,\r\n  ApiEnumMember,\r\n  type IExcerptTokenRange,\r\n  type IExcerptToken,\r\n  ApiConstructor,\r\n  ApiConstructSignature,\r\n  ApiFunction,\r\n  ApiIndexSignature,\r\n  ApiVariable,\r\n  ApiTypeAlias,\r\n  ApiCallSignature,\r\n  type IApiTypeParameterOptions,\r\n  EnumMemberOrder\r\n} from '@microsoft/api-extractor-model';\r\nimport { Path } from '@rushstack/node-core-library';\r\n\r\nimport type { Collector } from '../collector/Collector';\r\nimport type { ISourceLocation } from '../collector/SourceMapper';\r\nimport type { AstDeclaration } from '../analyzer/AstDeclaration';\r\nimport { ExcerptBuilder, type IExcerptBuilderNodeToCapture } from './ExcerptBuilder';\r\nimport { AstSymbol } from '../analyzer/AstSymbol';\r\nimport { DeclarationReferenceGenerator } from './DeclarationReferenceGenerator';\r\nimport type { ApiItemMetadata } from '../collector/ApiItemMetadata';\r\nimport type { DeclarationMetadata } from '../collector/DeclarationMetadata';\r\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\r\nimport type { AstEntity } from '../analyzer/AstEntity';\r\nimport type { AstModule } from '../analyzer/AstModule';\r\nimport { TypeScriptInternals } from '../analyzer/TypeScriptInternals';\r\n\r\ninterface IProcessAstEntityContext {\r\n  name: string;\r\n  isExported: boolean;\r\n  parentApiItem: ApiItemContainerMixin;\r\n}\r\n\r\nexport class ApiModelGenerator {\r\n  private readonly _collector: Collector;\r\n  private readonly _apiModel: ApiModel;\r\n  private readonly _referenceGenerator: DeclarationReferenceGenerator;\r\n\r\n  public constructor(collector: Collector) {\r\n    this._collector = collector;\r\n    this._apiModel = new ApiModel();\r\n    this._referenceGenerator = new DeclarationReferenceGenerator(collector);\r\n  }\r\n\r\n  public get apiModel(): ApiModel {\r\n    return this._apiModel;\r\n  }\r\n\r\n  public buildApiPackage(): ApiPackage {\r\n    const packageDocComment: tsdoc.DocComment | undefined = this._collector.workingPackage.tsdocComment;\r\n\r\n    const apiPackage: ApiPackage = new ApiPackage({\r\n      name: this._collector.workingPackage.name,\r\n      docComment: packageDocComment,\r\n      tsdocConfiguration: this._collector.extractorConfig.tsdocConfiguration,\r\n      projectFolderUrl: this._collector.extractorConfig.projectFolderUrl\r\n    });\r\n    this._apiModel.addMember(apiPackage);\r\n\r\n    const apiEntryPoint: ApiEntryPoint = new ApiEntryPoint({ name: '' });\r\n    apiPackage.addMember(apiEntryPoint);\r\n\r\n    for (const entity of this._collector.entities) {\r\n      // Only process entities that are exported from the entry point. Entities that are exported from\r\n      // `AstNamespaceImport` entities will be processed by `_processAstNamespaceImport`. However, if\r\n      // we are including forgotten exports, then process everything.\r\n      if (entity.exportedFromEntryPoint || this._collector.extractorConfig.docModelIncludeForgottenExports) {\r\n        this._processAstEntity(entity.astEntity, {\r\n          name: entity.nameForEmit!,\r\n          isExported: entity.exportedFromEntryPoint,\r\n          parentApiItem: apiEntryPoint\r\n        });\r\n      }\r\n    }\r\n\r\n    return apiPackage;\r\n  }\r\n\r\n  private _processAstEntity(astEntity: AstEntity, context: IProcessAstEntityContext): void {\r\n    if (astEntity instanceof AstSymbol) {\r\n      // Skip ancillary declarations; we will process them with the main declaration\r\n      for (const astDeclaration of this._collector.getNonAncillaryDeclarations(astEntity)) {\r\n        this._processDeclaration(astDeclaration, context);\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (astEntity instanceof AstNamespaceImport) {\r\n      // Note that a single API item can belong to two different AstNamespaceImport namespaces.  For example:\r\n      //\r\n      //   // file.ts defines \"thing()\"\r\n      //   import * as example1 from \"./file\";\r\n      //   import * as example2 from \"./file\";\r\n      //\r\n      //   // ...so here we end up with example1.thing() and example2.thing()\r\n      //   export { example1, example2 }\r\n      //\r\n      // The current logic does not try to associate \"thing()\" with a specific parent.  Instead\r\n      // the API documentation will show duplicated entries for example1.thing() and example2.thing().\r\n      //\r\n      // This could be improved in the future, but it requires a stable mechanism for choosing an associated parent.\r\n      // For thoughts about this:  https://github.com/microsoft/rushstack/issues/1308\r\n      this._processAstNamespaceImport(astEntity, context);\r\n      return;\r\n    }\r\n\r\n    // TODO: Figure out how to represent reexported AstImport objects.  Basically we need to introduce a new\r\n    // ApiItem subclass for \"export alias\", similar to a type alias, but representing declarations of the\r\n    // form \"export { X } from 'external-package'\".  We can also use this to solve GitHub issue #950.\r\n  }\r\n\r\n  private _processAstNamespaceImport(\r\n    astNamespaceImport: AstNamespaceImport,\r\n    context: IProcessAstEntityContext\r\n  ): void {\r\n    const astModule: AstModule = astNamespaceImport.astModule;\r\n    const { name, isExported, parentApiItem } = context;\r\n    const containerKey: string = ApiNamespace.getContainerKey(name);\r\n    const fileUrlPath: string = this._getFileUrlPath(astNamespaceImport.declaration);\r\n\r\n    let apiNamespace: ApiNamespace | undefined = parentApiItem.tryGetMemberByKey(\r\n      containerKey\r\n    ) as ApiNamespace;\r\n\r\n    if (apiNamespace === undefined) {\r\n      apiNamespace = new ApiNamespace({\r\n        name,\r\n        docComment: undefined,\r\n        releaseTag: ReleaseTag.None,\r\n        excerptTokens: [],\r\n        isExported,\r\n        fileUrlPath\r\n      });\r\n      parentApiItem.addMember(apiNamespace);\r\n    }\r\n\r\n    astModule.astModuleExportInfo!.exportedLocalEntities.forEach(\r\n      (exportedEntity: AstEntity, exportedName: string) => {\r\n        this._processAstEntity(exportedEntity, {\r\n          name: exportedName,\r\n          isExported: true,\r\n          parentApiItem: apiNamespace!\r\n        });\r\n      }\r\n    );\r\n  }\r\n\r\n  private _processDeclaration(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    if ((astDeclaration.modifierFlags & ts.ModifierFlags.Private) !== 0) {\r\n      return; // trim out private declarations\r\n    }\r\n\r\n    const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n    const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n    if (releaseTag === ReleaseTag.Internal) {\r\n      return; // trim out items marked as \"@internal\"\r\n    }\r\n\r\n    switch (astDeclaration.declaration.kind) {\r\n      case ts.SyntaxKind.CallSignature:\r\n        this._processApiCallSignature(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.Constructor:\r\n        this._processApiConstructor(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.ConstructSignature:\r\n        this._processApiConstructSignature(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.ClassDeclaration:\r\n        this._processApiClass(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.EnumDeclaration:\r\n        this._processApiEnum(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.EnumMember:\r\n        this._processApiEnumMember(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.FunctionDeclaration:\r\n        this._processApiFunction(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.GetAccessor:\r\n        this._processApiProperty(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.SetAccessor:\r\n        this._processApiProperty(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.IndexSignature:\r\n        this._processApiIndexSignature(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.InterfaceDeclaration:\r\n        this._processApiInterface(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.MethodDeclaration:\r\n        this._processApiMethod(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.MethodSignature:\r\n        this._processApiMethodSignature(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.ModuleDeclaration:\r\n        this._processApiNamespace(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.PropertyDeclaration:\r\n        this._processApiProperty(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.PropertySignature:\r\n        this._processApiPropertySignature(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.TypeAliasDeclaration:\r\n        this._processApiTypeAlias(astDeclaration, context);\r\n        break;\r\n\r\n      case ts.SyntaxKind.VariableDeclaration:\r\n        this._processApiVariable(astDeclaration, context);\r\n        break;\r\n\r\n      default:\r\n      // ignore unknown types\r\n    }\r\n  }\r\n\r\n  private _processChildDeclarations(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    for (const childDeclaration of astDeclaration.children) {\r\n      this._processDeclaration(childDeclaration, {\r\n        ...context,\r\n        name: childDeclaration.astSymbol.localName\r\n      });\r\n    }\r\n  }\r\n\r\n  private _processApiCallSignature(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    const { parentApiItem } = context;\r\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\r\n    const containerKey: string = ApiCallSignature.getContainerKey(overloadIndex);\r\n\r\n    let apiCallSignature: ApiCallSignature | undefined = parentApiItem.tryGetMemberByKey(\r\n      containerKey\r\n    ) as ApiCallSignature;\r\n\r\n    if (apiCallSignature === undefined) {\r\n      const callSignature: ts.CallSignatureDeclaration =\r\n        astDeclaration.declaration as ts.CallSignatureDeclaration;\r\n\r\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\r\n\r\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n      nodesToCapture.push({ node: callSignature.type, tokenRange: returnTypeTokenRange });\r\n\r\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\r\n        nodesToCapture,\r\n        callSignature.typeParameters\r\n      );\r\n\r\n      const parameters: IApiParameterOptions[] = this._captureParameters(\r\n        nodesToCapture,\r\n        callSignature.parameters\r\n      );\r\n\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const fileUrlPath: string = this._getFileUrlPath(callSignature);\r\n\r\n      apiCallSignature = new ApiCallSignature({\r\n        docComment,\r\n        releaseTag,\r\n        typeParameters,\r\n        parameters,\r\n        overloadIndex,\r\n        excerptTokens,\r\n        returnTypeTokenRange,\r\n        fileUrlPath\r\n      });\r\n\r\n      parentApiItem.addMember(apiCallSignature);\r\n    }\r\n  }\r\n\r\n  private _processApiConstructor(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    const { parentApiItem } = context;\r\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\r\n    const containerKey: string = ApiConstructor.getContainerKey(overloadIndex);\r\n\r\n    let apiConstructor: ApiConstructor | undefined = parentApiItem.tryGetMemberByKey(\r\n      containerKey\r\n    ) as ApiConstructor;\r\n\r\n    if (apiConstructor === undefined) {\r\n      const constructorDeclaration: ts.ConstructorDeclaration =\r\n        astDeclaration.declaration as ts.ConstructorDeclaration;\r\n\r\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\r\n\r\n      const parameters: IApiParameterOptions[] = this._captureParameters(\r\n        nodesToCapture,\r\n        constructorDeclaration.parameters\r\n      );\r\n\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const isProtected: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Protected) !== 0;\r\n      const fileUrlPath: string = this._getFileUrlPath(constructorDeclaration);\r\n\r\n      apiConstructor = new ApiConstructor({\r\n        docComment,\r\n        releaseTag,\r\n        isProtected,\r\n        parameters,\r\n        overloadIndex,\r\n        excerptTokens,\r\n        fileUrlPath\r\n      });\r\n\r\n      parentApiItem.addMember(apiConstructor);\r\n    }\r\n  }\r\n\r\n  private _processApiClass(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    const { name, isExported, parentApiItem } = context;\r\n    const containerKey: string = ApiClass.getContainerKey(name);\r\n\r\n    let apiClass: ApiClass | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiClass;\r\n\r\n    if (apiClass === undefined) {\r\n      const classDeclaration: ts.ClassDeclaration = astDeclaration.declaration as ts.ClassDeclaration;\r\n\r\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\r\n\r\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\r\n        nodesToCapture,\r\n        classDeclaration.typeParameters\r\n      );\r\n\r\n      let extendsTokenRange: IExcerptTokenRange | undefined = undefined;\r\n      const implementsTokenRanges: IExcerptTokenRange[] = [];\r\n\r\n      for (const heritageClause of classDeclaration.heritageClauses || []) {\r\n        if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {\r\n          extendsTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n          if (heritageClause.types.length > 0) {\r\n            nodesToCapture.push({ node: heritageClause.types[0], tokenRange: extendsTokenRange });\r\n          }\r\n        } else if (heritageClause.token === ts.SyntaxKind.ImplementsKeyword) {\r\n          for (const heritageType of heritageClause.types) {\r\n            const implementsTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n            implementsTokenRanges.push(implementsTokenRange);\r\n            nodesToCapture.push({ node: heritageType, tokenRange: implementsTokenRange });\r\n          }\r\n        }\r\n      }\r\n\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const isAbstract: boolean =\r\n        (ts.getCombinedModifierFlags(classDeclaration) & ts.ModifierFlags.Abstract) !== 0;\r\n      const fileUrlPath: string = this._getFileUrlPath(classDeclaration);\r\n\r\n      apiClass = new ApiClass({\r\n        name,\r\n        isAbstract,\r\n        docComment,\r\n        releaseTag,\r\n        excerptTokens,\r\n        typeParameters,\r\n        extendsTokenRange,\r\n        implementsTokenRanges,\r\n        isExported,\r\n        fileUrlPath\r\n      });\r\n\r\n      parentApiItem.addMember(apiClass);\r\n    }\r\n\r\n    this._processChildDeclarations(astDeclaration, {\r\n      ...context,\r\n      parentApiItem: apiClass\r\n    });\r\n  }\r\n\r\n  private _processApiConstructSignature(\r\n    astDeclaration: AstDeclaration,\r\n    context: IProcessAstEntityContext\r\n  ): void {\r\n    const { parentApiItem } = context;\r\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\r\n    const containerKey: string = ApiConstructSignature.getContainerKey(overloadIndex);\r\n\r\n    let apiConstructSignature: ApiConstructSignature | undefined = parentApiItem.tryGetMemberByKey(\r\n      containerKey\r\n    ) as ApiConstructSignature;\r\n\r\n    if (apiConstructSignature === undefined) {\r\n      const constructSignature: ts.ConstructSignatureDeclaration =\r\n        astDeclaration.declaration as ts.ConstructSignatureDeclaration;\r\n\r\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\r\n\r\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n      nodesToCapture.push({ node: constructSignature.type, tokenRange: returnTypeTokenRange });\r\n\r\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\r\n        nodesToCapture,\r\n        constructSignature.typeParameters\r\n      );\r\n\r\n      const parameters: IApiParameterOptions[] = this._captureParameters(\r\n        nodesToCapture,\r\n        constructSignature.parameters\r\n      );\r\n\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const fileUrlPath: string = this._getFileUrlPath(constructSignature);\r\n\r\n      apiConstructSignature = new ApiConstructSignature({\r\n        docComment,\r\n        releaseTag,\r\n        typeParameters,\r\n        parameters,\r\n        overloadIndex,\r\n        excerptTokens,\r\n        returnTypeTokenRange,\r\n        fileUrlPath\r\n      });\r\n\r\n      parentApiItem.addMember(apiConstructSignature);\r\n    }\r\n  }\r\n\r\n  private _processApiEnum(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    const { name, isExported, parentApiItem } = context;\r\n    const containerKey: string = ApiEnum.getContainerKey(name);\r\n\r\n    let apiEnum: ApiEnum | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiEnum;\r\n\r\n    if (apiEnum === undefined) {\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, []);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const preserveMemberOrder: boolean =\r\n        this._collector.extractorConfig.enumMemberOrder === EnumMemberOrder.Preserve;\r\n      const fileUrlPath: string = this._getFileUrlPath(astDeclaration.declaration);\r\n\r\n      apiEnum = new ApiEnum({\r\n        name,\r\n        docComment,\r\n        releaseTag,\r\n        excerptTokens,\r\n        preserveMemberOrder,\r\n        isExported,\r\n        fileUrlPath\r\n      });\r\n      parentApiItem.addMember(apiEnum);\r\n    }\r\n\r\n    this._processChildDeclarations(astDeclaration, {\r\n      ...context,\r\n      parentApiItem: apiEnum\r\n    });\r\n  }\r\n\r\n  private _processApiEnumMember(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    const { name, parentApiItem } = context;\r\n    const containerKey: string = ApiEnumMember.getContainerKey(name);\r\n\r\n    let apiEnumMember: ApiEnumMember | undefined = parentApiItem.tryGetMemberByKey(\r\n      containerKey\r\n    ) as ApiEnumMember;\r\n\r\n    if (apiEnumMember === undefined) {\r\n      const enumMember: ts.EnumMember = astDeclaration.declaration as ts.EnumMember;\r\n\r\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\r\n\r\n      let initializerTokenRange: IExcerptTokenRange | undefined = undefined;\r\n      if (enumMember.initializer) {\r\n        initializerTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n        nodesToCapture.push({ node: enumMember.initializer, tokenRange: initializerTokenRange });\r\n      }\r\n\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const fileUrlPath: string = this._getFileUrlPath(enumMember);\r\n\r\n      apiEnumMember = new ApiEnumMember({\r\n        name,\r\n        docComment,\r\n        releaseTag,\r\n        excerptTokens,\r\n        initializerTokenRange,\r\n        fileUrlPath\r\n      });\r\n\r\n      parentApiItem.addMember(apiEnumMember);\r\n    }\r\n  }\r\n\r\n  private _processApiFunction(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    const { name, isExported, parentApiItem } = context;\r\n\r\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\r\n    const containerKey: string = ApiFunction.getContainerKey(name, overloadIndex);\r\n\r\n    let apiFunction: ApiFunction | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiFunction;\r\n\r\n    if (apiFunction === undefined) {\r\n      const functionDeclaration: ts.FunctionDeclaration =\r\n        astDeclaration.declaration as ts.FunctionDeclaration;\r\n\r\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\r\n\r\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n      nodesToCapture.push({ node: functionDeclaration.type, tokenRange: returnTypeTokenRange });\r\n\r\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\r\n        nodesToCapture,\r\n        functionDeclaration.typeParameters\r\n      );\r\n\r\n      const parameters: IApiParameterOptions[] = this._captureParameters(\r\n        nodesToCapture,\r\n        functionDeclaration.parameters\r\n      );\r\n\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const fileUrlPath: string = this._getFileUrlPath(functionDeclaration);\r\n\r\n      apiFunction = new ApiFunction({\r\n        name,\r\n        docComment,\r\n        releaseTag,\r\n        typeParameters,\r\n        parameters,\r\n        overloadIndex,\r\n        excerptTokens,\r\n        returnTypeTokenRange,\r\n        isExported,\r\n        fileUrlPath\r\n      });\r\n\r\n      parentApiItem.addMember(apiFunction);\r\n    }\r\n  }\r\n\r\n  private _processApiIndexSignature(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    const { parentApiItem } = context;\r\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\r\n    const containerKey: string = ApiIndexSignature.getContainerKey(overloadIndex);\r\n\r\n    let apiIndexSignature: ApiIndexSignature | undefined = parentApiItem.tryGetMemberByKey(\r\n      containerKey\r\n    ) as ApiIndexSignature;\r\n\r\n    if (apiIndexSignature === undefined) {\r\n      const indexSignature: ts.IndexSignatureDeclaration =\r\n        astDeclaration.declaration as ts.IndexSignatureDeclaration;\r\n\r\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\r\n\r\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n      nodesToCapture.push({ node: indexSignature.type, tokenRange: returnTypeTokenRange });\r\n\r\n      const parameters: IApiParameterOptions[] = this._captureParameters(\r\n        nodesToCapture,\r\n        indexSignature.parameters\r\n      );\r\n\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const isReadonly: boolean = this._isReadonly(astDeclaration);\r\n      const fileUrlPath: string = this._getFileUrlPath(indexSignature);\r\n\r\n      apiIndexSignature = new ApiIndexSignature({\r\n        docComment,\r\n        releaseTag,\r\n        parameters,\r\n        overloadIndex,\r\n        excerptTokens,\r\n        returnTypeTokenRange,\r\n        isReadonly,\r\n        fileUrlPath\r\n      });\r\n\r\n      parentApiItem.addMember(apiIndexSignature);\r\n    }\r\n  }\r\n\r\n  private _processApiInterface(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    const { name, isExported, parentApiItem } = context;\r\n    const containerKey: string = ApiInterface.getContainerKey(name);\r\n\r\n    let apiInterface: ApiInterface | undefined = parentApiItem.tryGetMemberByKey(\r\n      containerKey\r\n    ) as ApiInterface;\r\n\r\n    if (apiInterface === undefined) {\r\n      const interfaceDeclaration: ts.InterfaceDeclaration =\r\n        astDeclaration.declaration as ts.InterfaceDeclaration;\r\n\r\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\r\n\r\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\r\n        nodesToCapture,\r\n        interfaceDeclaration.typeParameters\r\n      );\r\n\r\n      const extendsTokenRanges: IExcerptTokenRange[] = [];\r\n\r\n      for (const heritageClause of interfaceDeclaration.heritageClauses || []) {\r\n        if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {\r\n          for (const heritageType of heritageClause.types) {\r\n            const extendsTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n            extendsTokenRanges.push(extendsTokenRange);\r\n            nodesToCapture.push({ node: heritageType, tokenRange: extendsTokenRange });\r\n          }\r\n        }\r\n      }\r\n\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const fileUrlPath: string = this._getFileUrlPath(interfaceDeclaration);\r\n\r\n      apiInterface = new ApiInterface({\r\n        name,\r\n        docComment,\r\n        releaseTag,\r\n        excerptTokens,\r\n        typeParameters,\r\n        extendsTokenRanges,\r\n        isExported,\r\n        fileUrlPath\r\n      });\r\n\r\n      parentApiItem.addMember(apiInterface);\r\n    }\r\n\r\n    this._processChildDeclarations(astDeclaration, {\r\n      ...context,\r\n      parentApiItem: apiInterface\r\n    });\r\n  }\r\n\r\n  private _processApiMethod(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    const { name, parentApiItem } = context;\r\n    const isStatic: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Static) !== 0;\r\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\r\n    const containerKey: string = ApiMethod.getContainerKey(name, isStatic, overloadIndex);\r\n\r\n    let apiMethod: ApiMethod | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiMethod;\r\n\r\n    if (apiMethod === undefined) {\r\n      const methodDeclaration: ts.MethodDeclaration = astDeclaration.declaration as ts.MethodDeclaration;\r\n\r\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\r\n\r\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n      nodesToCapture.push({ node: methodDeclaration.type, tokenRange: returnTypeTokenRange });\r\n\r\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\r\n        nodesToCapture,\r\n        methodDeclaration.typeParameters\r\n      );\r\n\r\n      const parameters: IApiParameterOptions[] = this._captureParameters(\r\n        nodesToCapture,\r\n        methodDeclaration.parameters\r\n      );\r\n\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      if (releaseTag === ReleaseTag.Internal || releaseTag === ReleaseTag.Alpha) {\r\n        return; // trim out items marked as \"@internal\" or \"@alpha\"\r\n      }\r\n      const isOptional: boolean =\r\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\r\n      const isProtected: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Protected) !== 0;\r\n      const isAbstract: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Abstract) !== 0;\r\n      const fileUrlPath: string = this._getFileUrlPath(methodDeclaration);\r\n\r\n      apiMethod = new ApiMethod({\r\n        name,\r\n        isAbstract,\r\n        docComment,\r\n        releaseTag,\r\n        isProtected,\r\n        isStatic,\r\n        isOptional,\r\n        typeParameters,\r\n        parameters,\r\n        overloadIndex,\r\n        excerptTokens,\r\n        returnTypeTokenRange,\r\n        fileUrlPath\r\n      });\r\n\r\n      parentApiItem.addMember(apiMethod);\r\n    }\r\n  }\r\n\r\n  private _processApiMethodSignature(\r\n    astDeclaration: AstDeclaration,\r\n    context: IProcessAstEntityContext\r\n  ): void {\r\n    const { name, parentApiItem } = context;\r\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\r\n    const containerKey: string = ApiMethodSignature.getContainerKey(name, overloadIndex);\r\n\r\n    let apiMethodSignature: ApiMethodSignature | undefined = parentApiItem.tryGetMemberByKey(\r\n      containerKey\r\n    ) as ApiMethodSignature;\r\n\r\n    if (apiMethodSignature === undefined) {\r\n      const methodSignature: ts.MethodSignature = astDeclaration.declaration as ts.MethodSignature;\r\n\r\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\r\n\r\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n      nodesToCapture.push({ node: methodSignature.type, tokenRange: returnTypeTokenRange });\r\n\r\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\r\n        nodesToCapture,\r\n        methodSignature.typeParameters\r\n      );\r\n\r\n      const parameters: IApiParameterOptions[] = this._captureParameters(\r\n        nodesToCapture,\r\n        methodSignature.parameters\r\n      );\r\n\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const isOptional: boolean =\r\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\r\n      const fileUrlPath: string = this._getFileUrlPath(methodSignature);\r\n\r\n      apiMethodSignature = new ApiMethodSignature({\r\n        name,\r\n        docComment,\r\n        releaseTag,\r\n        isOptional,\r\n        typeParameters,\r\n        parameters,\r\n        overloadIndex,\r\n        excerptTokens,\r\n        returnTypeTokenRange,\r\n        fileUrlPath\r\n      });\r\n\r\n      parentApiItem.addMember(apiMethodSignature);\r\n    }\r\n  }\r\n\r\n  private _processApiNamespace(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    const { name, isExported, parentApiItem } = context;\r\n    const containerKey: string = ApiNamespace.getContainerKey(name);\r\n\r\n    let apiNamespace: ApiNamespace | undefined = parentApiItem.tryGetMemberByKey(\r\n      containerKey\r\n    ) as ApiNamespace;\r\n\r\n    if (apiNamespace === undefined) {\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, []);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const fileUrlPath: string = this._getFileUrlPath(astDeclaration.declaration);\r\n\r\n      apiNamespace = new ApiNamespace({\r\n        name,\r\n        docComment,\r\n        releaseTag,\r\n        excerptTokens,\r\n        isExported,\r\n        fileUrlPath\r\n      });\r\n      parentApiItem.addMember(apiNamespace);\r\n    }\r\n\r\n    this._processChildDeclarations(astDeclaration, {\r\n      ...context,\r\n      parentApiItem: apiNamespace\r\n    });\r\n  }\r\n\r\n  private _processApiProperty(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    const { name, parentApiItem } = context;\r\n    const isStatic: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Static) !== 0;\r\n    const containerKey: string = ApiProperty.getContainerKey(name, isStatic);\r\n\r\n    let apiProperty: ApiProperty | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiProperty;\r\n\r\n    if (apiProperty === undefined) {\r\n      const declaration: ts.Declaration = astDeclaration.declaration;\r\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\r\n\r\n      const propertyTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n      let propertyTypeNode: ts.TypeNode | undefined;\r\n\r\n      if (ts.isPropertyDeclaration(declaration) || ts.isGetAccessorDeclaration(declaration)) {\r\n        propertyTypeNode = declaration.type;\r\n      }\r\n\r\n      if (ts.isSetAccessorDeclaration(declaration)) {\r\n        // Note that TypeScript always reports an error if a setter does not have exactly one parameter.\r\n        propertyTypeNode = declaration.parameters[0].type;\r\n      }\r\n\r\n      nodesToCapture.push({ node: propertyTypeNode, tokenRange: propertyTypeTokenRange });\r\n\r\n      let initializerTokenRange: IExcerptTokenRange | undefined = undefined;\r\n      if (ts.isPropertyDeclaration(declaration) && declaration.initializer) {\r\n        initializerTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n        nodesToCapture.push({ node: declaration.initializer, tokenRange: initializerTokenRange });\r\n      }\r\n\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const isOptional: boolean =\r\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\r\n      const isProtected: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Protected) !== 0;\r\n      const isAbstract: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Abstract) !== 0;\r\n      const isReadonly: boolean = this._isReadonly(astDeclaration);\r\n      const fileUrlPath: string = this._getFileUrlPath(declaration);\r\n\r\n      apiProperty = new ApiProperty({\r\n        name,\r\n        docComment,\r\n        releaseTag,\r\n        isAbstract,\r\n        isProtected,\r\n        isStatic,\r\n        isOptional,\r\n        isReadonly,\r\n        excerptTokens,\r\n        propertyTypeTokenRange,\r\n        initializerTokenRange,\r\n        fileUrlPath\r\n      });\r\n      parentApiItem.addMember(apiProperty);\r\n    } else {\r\n      // If the property was already declared before (via a merged interface declaration),\r\n      // we assume its signature is identical, because the language requires that.\r\n    }\r\n  }\r\n\r\n  private _processApiPropertySignature(\r\n    astDeclaration: AstDeclaration,\r\n    context: IProcessAstEntityContext\r\n  ): void {\r\n    const { name, parentApiItem } = context;\r\n    const containerKey: string = ApiPropertySignature.getContainerKey(name);\r\n\r\n    let apiPropertySignature: ApiPropertySignature | undefined = parentApiItem.tryGetMemberByKey(\r\n      containerKey\r\n    ) as ApiPropertySignature;\r\n\r\n    if (apiPropertySignature === undefined) {\r\n      const propertySignature: ts.PropertySignature = astDeclaration.declaration as ts.PropertySignature;\r\n\r\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\r\n\r\n      const propertyTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n      nodesToCapture.push({ node: propertySignature.type, tokenRange: propertyTypeTokenRange });\r\n\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const isOptional: boolean =\r\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\r\n      const isReadonly: boolean = this._isReadonly(astDeclaration);\r\n      const fileUrlPath: string = this._getFileUrlPath(propertySignature);\r\n\r\n      apiPropertySignature = new ApiPropertySignature({\r\n        name,\r\n        docComment,\r\n        releaseTag,\r\n        isOptional,\r\n        excerptTokens,\r\n        propertyTypeTokenRange,\r\n        isReadonly,\r\n        fileUrlPath\r\n      });\r\n\r\n      parentApiItem.addMember(apiPropertySignature);\r\n    } else {\r\n      // If the property was already declared before (via a merged interface declaration),\r\n      // we assume its signature is identical, because the language requires that.\r\n    }\r\n  }\r\n\r\n  private _processApiTypeAlias(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    const { name, isExported, parentApiItem } = context;\r\n\r\n    const containerKey: string = ApiTypeAlias.getContainerKey(name);\r\n\r\n    let apiTypeAlias: ApiTypeAlias | undefined = parentApiItem.tryGetMemberByKey(\r\n      containerKey\r\n    ) as ApiTypeAlias;\r\n\r\n    if (apiTypeAlias === undefined) {\r\n      const typeAliasDeclaration: ts.TypeAliasDeclaration =\r\n        astDeclaration.declaration as ts.TypeAliasDeclaration;\r\n\r\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\r\n\r\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\r\n        nodesToCapture,\r\n        typeAliasDeclaration.typeParameters\r\n      );\r\n\r\n      const typeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n      nodesToCapture.push({ node: typeAliasDeclaration.type, tokenRange: typeTokenRange });\r\n\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const fileUrlPath: string = this._getFileUrlPath(typeAliasDeclaration);\r\n\r\n      apiTypeAlias = new ApiTypeAlias({\r\n        name,\r\n        docComment,\r\n        typeParameters,\r\n        releaseTag,\r\n        excerptTokens,\r\n        typeTokenRange,\r\n        isExported,\r\n        fileUrlPath\r\n      });\r\n\r\n      parentApiItem.addMember(apiTypeAlias);\r\n    }\r\n  }\r\n\r\n  private _processApiVariable(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\r\n    const { name, isExported, parentApiItem } = context;\r\n\r\n    const containerKey: string = ApiVariable.getContainerKey(name);\r\n\r\n    let apiVariable: ApiVariable | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiVariable;\r\n\r\n    if (apiVariable === undefined) {\r\n      const variableDeclaration: ts.VariableDeclaration =\r\n        astDeclaration.declaration as ts.VariableDeclaration;\r\n\r\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\r\n\r\n      const variableTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n      nodesToCapture.push({ node: variableDeclaration.type, tokenRange: variableTypeTokenRange });\r\n\r\n      let initializerTokenRange: IExcerptTokenRange | undefined = undefined;\r\n      if (variableDeclaration.initializer) {\r\n        initializerTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n        nodesToCapture.push({ node: variableDeclaration.initializer, tokenRange: initializerTokenRange });\r\n      }\r\n\r\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\r\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n      const isReadonly: boolean = this._isReadonly(astDeclaration);\r\n      const fileUrlPath: string = this._getFileUrlPath(variableDeclaration);\r\n\r\n      apiVariable = new ApiVariable({\r\n        name,\r\n        docComment,\r\n        releaseTag,\r\n        excerptTokens,\r\n        variableTypeTokenRange,\r\n        initializerTokenRange,\r\n        isReadonly,\r\n        isExported,\r\n        fileUrlPath\r\n      });\r\n\r\n      parentApiItem.addMember(apiVariable);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param nodesToCapture - A list of child nodes whose token ranges we want to capture\r\n   */\r\n  private _buildExcerptTokens(\r\n    astDeclaration: AstDeclaration,\r\n    nodesToCapture: IExcerptBuilderNodeToCapture[]\r\n  ): IExcerptToken[] {\r\n    const excerptTokens: IExcerptToken[] = [];\r\n\r\n    // Build the main declaration\r\n    ExcerptBuilder.addDeclaration(excerptTokens, astDeclaration, nodesToCapture, this._referenceGenerator);\r\n\r\n    const declarationMetadata: DeclarationMetadata = this._collector.fetchDeclarationMetadata(astDeclaration);\r\n\r\n    // Add any ancillary declarations\r\n    for (const ancillaryDeclaration of declarationMetadata.ancillaryDeclarations) {\r\n      ExcerptBuilder.addBlankLine(excerptTokens);\r\n      ExcerptBuilder.addDeclaration(\r\n        excerptTokens,\r\n        ancillaryDeclaration,\r\n        nodesToCapture,\r\n        this._referenceGenerator\r\n      );\r\n    }\r\n\r\n    return excerptTokens;\r\n  }\r\n\r\n  private _captureTypeParameters(\r\n    nodesToCapture: IExcerptBuilderNodeToCapture[],\r\n    typeParameterNodes: ts.NodeArray<ts.TypeParameterDeclaration> | undefined\r\n  ): IApiTypeParameterOptions[] {\r\n    const typeParameters: IApiTypeParameterOptions[] = [];\r\n    if (typeParameterNodes) {\r\n      for (const typeParameter of typeParameterNodes) {\r\n        const constraintTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n        nodesToCapture.push({ node: typeParameter.constraint, tokenRange: constraintTokenRange });\r\n\r\n        const defaultTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n        nodesToCapture.push({ node: typeParameter.default, tokenRange: defaultTypeTokenRange });\r\n\r\n        typeParameters.push({\r\n          typeParameterName: typeParameter.name.getText().trim(),\r\n          constraintTokenRange,\r\n          defaultTypeTokenRange\r\n        });\r\n      }\r\n    }\r\n    return typeParameters;\r\n  }\r\n\r\n  private _captureParameters(\r\n    nodesToCapture: IExcerptBuilderNodeToCapture[],\r\n    parameterNodes: ts.NodeArray<ts.ParameterDeclaration>\r\n  ): IApiParameterOptions[] {\r\n    const parameters: IApiParameterOptions[] = [];\r\n    for (const parameter of parameterNodes) {\r\n      const parameterTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\r\n      nodesToCapture.push({ node: parameter.type, tokenRange: parameterTypeTokenRange });\r\n      parameters.push({\r\n        parameterName: parameter.name.getText().trim(),\r\n        parameterTypeTokenRange,\r\n        isOptional: this._collector.typeChecker.isOptionalParameter(parameter)\r\n      });\r\n    }\r\n    return parameters;\r\n  }\r\n\r\n  private _isReadonly(astDeclaration: AstDeclaration): boolean {\r\n    switch (astDeclaration.declaration.kind) {\r\n      case ts.SyntaxKind.GetAccessor:\r\n      case ts.SyntaxKind.IndexSignature:\r\n      case ts.SyntaxKind.PropertyDeclaration:\r\n      case ts.SyntaxKind.PropertySignature:\r\n      case ts.SyntaxKind.SetAccessor:\r\n      case ts.SyntaxKind.VariableDeclaration: {\r\n        const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\r\n        const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\r\n        const declarationMetadata: DeclarationMetadata =\r\n          this._collector.fetchDeclarationMetadata(astDeclaration);\r\n\r\n        const hasReadonlyModifier: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Readonly) !== 0;\r\n        const hasReadonlyDocTag: boolean = !!docComment?.modifierTagSet?.hasTagName('@readonly');\r\n        const isGetterWithNoSetter: boolean =\r\n          ts.isGetAccessorDeclaration(astDeclaration.declaration) &&\r\n          declarationMetadata.ancillaryDeclarations.length === 0;\r\n        const isVarConst: boolean =\r\n          ts.isVariableDeclaration(astDeclaration.declaration) &&\r\n          TypeScriptInternals.isVarConst(astDeclaration.declaration);\r\n\r\n        return hasReadonlyModifier || hasReadonlyDocTag || isGetterWithNoSetter || isVarConst;\r\n      }\r\n      default: {\r\n        // Readonly-ness does not make sense for any other declaration kind.\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _getFileUrlPath(declaration: ts.Declaration): string {\r\n    const sourceFile: ts.SourceFile = declaration.getSourceFile();\r\n    const sourceLocation: ISourceLocation = this._collector.sourceMapper.getSourceLocation({\r\n      sourceFile,\r\n      pos: declaration.pos\r\n    });\r\n\r\n    let result: string = path.relative(\r\n      this._collector.extractorConfig.projectFolder,\r\n      sourceLocation.sourceFilePath\r\n    );\r\n    result = Path.convertToSlashes(result);\r\n    return result;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/generators/ApiReportGenerator.js.map b/lib/generators/ApiReportGenerator.js.map
index d6171211b3cea25c9b1107b0c3d7bb543baed4c3..5712a49b209dc3fee50a96bcde8547bc13e16d55 100644
--- a/lib/generators/ApiReportGenerator.js.map
+++ b/lib/generators/ApiReportGenerator.js.map
@@ -1 +1 @@
-{"version":3,"file":"ApiReportGenerator.js","sourceRoot":"","sources":["../../src/generators/ApiReportGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\nimport { Text, InternalError } from '@rushstack/node-core-library';\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\n\nimport { Collector } from '../collector/Collector';\nimport { TypeScriptHelpers } from '../analyzer/TypeScriptHelpers';\nimport { Span } from '../analyzer/Span';\nimport type { CollectorEntity } from '../collector/CollectorEntity';\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\nimport type { ApiItemMetadata } from '../collector/ApiItemMetadata';\nimport { AstImport } from '../analyzer/AstImport';\nimport { AstSymbol } from '../analyzer/AstSymbol';\nimport type { ExtractorMessage } from '../api/ExtractorMessage';\nimport { IndentedWriter } from './IndentedWriter';\nimport { DtsEmitHelpers } from './DtsEmitHelpers';\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\nimport type { AstEntity } from '../analyzer/AstEntity';\nimport type { AstModuleExportInfo } from '../analyzer/AstModule';\nimport { SourceFileLocationFormatter } from '../analyzer/SourceFileLocationFormatter';\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\n\nexport class ApiReportGenerator {\n  private static _trimSpacesRegExp: RegExp = / +$/gm;\n\n  /**\n   * Compares the contents of two API files that were created using ApiFileGenerator,\n   * and returns true if they are equivalent.  Note that these files are not normally edited\n   * by a human; the \"equivalence\" comparison here is intended to ignore spurious changes that\n   * might be introduced by a tool, e.g. Git newline normalization or an editor that strips\n   * whitespace when saving.\n   */\n  public static areEquivalentApiFileContents(\n    actualFileContent: string,\n    expectedFileContent: string\n  ): boolean {\n    // NOTE: \"\\s\" also matches \"\\r\" and \"\\n\"\n    const normalizedActual: string = actualFileContent.replace(/[\\s]+/g, ' ');\n    const normalizedExpected: string = expectedFileContent.replace(/[\\s]+/g, ' ');\n    return normalizedActual === normalizedExpected;\n  }\n\n  public static generateReviewFileContent(collector: Collector): string {\n    const writer: IndentedWriter = new IndentedWriter();\n    writer.trimLeadingSpaces = true;\n\n    writer.writeLine(\n      [\n        `## API Report File for \"${collector.workingPackage.name}\"`,\n        ``,\n        `> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).`,\n        ``\n      ].join('\\n')\n    );\n\n    // Write the opening delimiter for the Markdown code fence\n    writer.writeLine('```ts\\n');\n\n    // Emit the triple slash directives\n    for (const typeDirectiveReference of Array.from(collector.dtsTypeReferenceDirectives).sort()) {\n      // https://github.com/microsoft/TypeScript/blob/611ebc7aadd7a44a4c0447698bfda9222a78cb66/src/compiler/declarationEmitter.ts#L162\n      writer.writeLine(`/// <reference types=\"${typeDirectiveReference}\" />`);\n    }\n    for (const libDirectiveReference of Array.from(collector.dtsLibReferenceDirectives).sort()) {\n      writer.writeLine(`/// <reference lib=\"${libDirectiveReference}\" />`);\n    }\n    writer.ensureSkippedLine();\n\n    // Emit the imports\n    for (const entity of collector.entities) {\n      if (entity.astEntity instanceof AstImport) {\n        DtsEmitHelpers.emitImport(writer, entity, entity.astEntity);\n      }\n    }\n    writer.ensureSkippedLine();\n\n    // Emit the regular declarations\n    for (const entity of collector.entities) {\n      const astEntity: AstEntity = entity.astEntity;\n      if (entity.consumable || collector.extractorConfig.apiReportIncludeForgottenExports) {\n        // First, collect the list of export names for this symbol.  When reporting messages with\n        // ExtractorMessage.properties.exportName, this will enable us to emit the warning comments alongside\n        // the associated export statement.\n        interface IExportToEmit {\n          readonly exportName: string;\n          readonly associatedMessages: ExtractorMessage[];\n        }\n        const exportsToEmit: Map<string, IExportToEmit> = new Map<string, IExportToEmit>();\n\n        for (const exportName of entity.exportNames) {\n          if (!entity.shouldInlineExport) {\n            exportsToEmit.set(exportName, { exportName, associatedMessages: [] });\n          }\n        }\n\n        if (astEntity instanceof AstSymbol) {\n          // Emit all the declarations for this entity\n          for (const astDeclaration of astEntity.astDeclarations || []) {\n            // Get the messages associated with this declaration\n            const fetchedMessages: ExtractorMessage[] =\n              collector.messageRouter.fetchAssociatedMessagesForReviewFile(astDeclaration);\n\n            // Peel off the messages associated with an export statement and store them\n            // in IExportToEmit.associatedMessages (to be processed later).  The remaining messages will\n            // added to messagesToReport, to be emitted next to the declaration instead of the export statement.\n            const messagesToReport: ExtractorMessage[] = [];\n            for (const message of fetchedMessages) {\n              if (message.properties.exportName) {\n                const exportToEmit: IExportToEmit | undefined = exportsToEmit.get(\n                  message.properties.exportName\n                );\n                if (exportToEmit) {\n                  exportToEmit.associatedMessages.push(message);\n                  continue;\n                }\n              }\n              messagesToReport.push(message);\n            }\n\n            writer.ensureSkippedLine();\n            writer.write(ApiReportGenerator._getAedocSynopsis(collector, astDeclaration, messagesToReport));\n\n            const span: Span = new Span(astDeclaration.declaration);\n\n            const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\n            if (apiItemMetadata.isPreapproved) {\n              ApiReportGenerator._modifySpanForPreapproved(span);\n            } else {\n              ApiReportGenerator._modifySpan(collector, span, entity, astDeclaration, false);\n            }\n\n            span.writeModifiedText(writer);\n            writer.ensureNewLine();\n          }\n        }\n\n        if (astEntity instanceof AstNamespaceImport) {\n          const astModuleExportInfo: AstModuleExportInfo = astEntity.fetchAstModuleExportInfo(collector);\n\n          if (entity.nameForEmit === undefined) {\n            // This should never happen\n            throw new InternalError('referencedEntry.nameForEmit is undefined');\n          }\n\n          if (astModuleExportInfo.starExportedExternalModules.size > 0) {\n            // We could support this, but we would need to find a way to safely represent it.\n            throw new Error(\n              `The ${entity.nameForEmit} namespace import includes a star export, which is not supported:\\n` +\n                SourceFileLocationFormatter.formatDeclaration(astEntity.declaration)\n            );\n          }\n\n          // Emit a synthetic declaration for the namespace.  It will look like this:\n          //\n          //    declare namespace example {\n          //      export {\n          //        f1,\n          //        f2\n          //      }\n          //    }\n          //\n          // Note that we do not try to relocate f1()/f2() to be inside the namespace because other type\n          // signatures may reference them directly (without using the namespace qualifier).\n\n          writer.ensureSkippedLine();\n          writer.writeLine(`declare namespace ${entity.nameForEmit} {`);\n\n          // all local exports of local imported module are just references to top-level declarations\n          writer.increaseIndent();\n          writer.writeLine('export {');\n          writer.increaseIndent();\n\n          const exportClauses: string[] = [];\n          for (const [exportedName, exportedEntity] of astModuleExportInfo.exportedLocalEntities) {\n            const collectorEntity: CollectorEntity | undefined =\n              collector.tryGetCollectorEntity(exportedEntity);\n            if (collectorEntity === undefined) {\n              // This should never happen\n              // top-level exports of local imported module should be added as collector entities before\n              throw new InternalError(\n                `Cannot find collector entity for ${entity.nameForEmit}.${exportedEntity.localName}`\n              );\n            }\n\n            if (collectorEntity.nameForEmit === exportedName) {\n              exportClauses.push(collectorEntity.nameForEmit);\n            } else {\n              exportClauses.push(`${collectorEntity.nameForEmit} as ${exportedName}`);\n            }\n          }\n          writer.writeLine(exportClauses.join(',\\n'));\n\n          writer.decreaseIndent();\n          writer.writeLine('}'); // end of \"export { ... }\"\n          writer.decreaseIndent();\n          writer.writeLine('}'); // end of \"declare namespace { ... }\"\n        }\n\n        // Now emit the export statements for this entity.\n        for (const exportToEmit of exportsToEmit.values()) {\n          // Write any associated messages\n          if (exportToEmit.associatedMessages.length > 0) {\n            writer.ensureSkippedLine();\n            for (const message of exportToEmit.associatedMessages) {\n              ApiReportGenerator._writeLineAsComments(\n                writer,\n                'Warning: ' + message.formatMessageWithoutLocation()\n              );\n            }\n          }\n\n          DtsEmitHelpers.emitNamedExport(writer, exportToEmit.exportName, entity);\n        }\n        writer.ensureSkippedLine();\n      }\n    }\n\n    DtsEmitHelpers.emitStarExports(writer, collector);\n\n    // Write the unassociated warnings at the bottom of the file\n    const unassociatedMessages: ExtractorMessage[] =\n      collector.messageRouter.fetchUnassociatedMessagesForReviewFile();\n    if (unassociatedMessages.length > 0) {\n      writer.ensureSkippedLine();\n      ApiReportGenerator._writeLineAsComments(writer, 'Warnings were encountered during analysis:');\n      ApiReportGenerator._writeLineAsComments(writer, '');\n      for (const unassociatedMessage of unassociatedMessages) {\n        ApiReportGenerator._writeLineAsComments(\n          writer,\n          unassociatedMessage.formatMessageWithLocation(collector.workingPackage.packageFolder)\n        );\n      }\n    }\n\n    if (collector.workingPackage.tsdocComment === undefined) {\n      writer.ensureSkippedLine();\n      ApiReportGenerator._writeLineAsComments(writer, '(No @packageDocumentation comment for this package)');\n    }\n\n    // Write the closing delimiter for the Markdown code fence\n    writer.ensureSkippedLine();\n    writer.writeLine('```');\n\n    // Remove any trailing spaces\n    return writer.toString().replace(ApiReportGenerator._trimSpacesRegExp, '');\n  }\n\n  /**\n   * Before writing out a declaration, _modifySpan() applies various fixups to make it nice.\n   */\n  private static _modifySpan(\n    collector: Collector,\n    span: Span,\n    entity: CollectorEntity,\n    astDeclaration: AstDeclaration,\n    insideTypeLiteral: boolean\n  ): void {\n    // Should we process this declaration at all?\n    // eslint-disable-next-line no-bitwise\n    if (!ApiReportGenerator._shouldIncludeInReport(astDeclaration)) {\n      span.modification.skipAll();\n      return;\n    }\n\n    const previousSpan: Span | undefined = span.previousSibling;\n\n    let recurseChildren: boolean = true;\n    let sortChildren: boolean = false;\n\n    switch (span.kind) {\n      case ts.SyntaxKind.JSDocComment:\n        span.modification.skipAll();\n        // For now, we don't transform JSDoc comment nodes at all\n        recurseChildren = false;\n        break;\n\n      case ts.SyntaxKind.ExportKeyword:\n      case ts.SyntaxKind.DefaultKeyword:\n      case ts.SyntaxKind.DeclareKeyword:\n        // Delete any explicit \"export\" or \"declare\" keywords -- we will re-add them below\n        span.modification.skipAll();\n        break;\n\n      case ts.SyntaxKind.InterfaceKeyword:\n      case ts.SyntaxKind.ClassKeyword:\n      case ts.SyntaxKind.EnumKeyword:\n      case ts.SyntaxKind.NamespaceKeyword:\n      case ts.SyntaxKind.ModuleKeyword:\n      case ts.SyntaxKind.TypeKeyword:\n      case ts.SyntaxKind.FunctionKeyword:\n        // Replace the stuff we possibly deleted above\n        let replacedModifiers: string = '';\n\n        if (entity.shouldInlineExport) {\n          replacedModifiers = 'export ' + replacedModifiers;\n        }\n\n        if (previousSpan && previousSpan.kind === ts.SyntaxKind.SyntaxList) {\n          // If there is a previous span of type SyntaxList, then apply it before any other modifiers\n          // (e.g. \"abstract\") that appear there.\n          previousSpan.modification.prefix = replacedModifiers + previousSpan.modification.prefix;\n        } else {\n          // Otherwise just stick it in front of this span\n          span.modification.prefix = replacedModifiers + span.modification.prefix;\n        }\n        break;\n\n      case ts.SyntaxKind.SyntaxList:\n        if (span.parent) {\n          if (AstDeclaration.isSupportedSyntaxKind(span.parent.kind)) {\n            // If the immediate parent is an API declaration, and the immediate children are API declarations,\n            // then sort the children alphabetically\n            sortChildren = true;\n          } else if (span.parent.kind === ts.SyntaxKind.ModuleBlock) {\n            // Namespaces are special because their chain goes ModuleDeclaration -> ModuleBlock -> SyntaxList\n            sortChildren = true;\n          }\n        }\n        break;\n\n      case ts.SyntaxKind.VariableDeclaration:\n        if (!span.parent) {\n          // The VariableDeclaration node is part of a VariableDeclarationList, however\n          // the Entry.followedSymbol points to the VariableDeclaration part because\n          // multiple definitions might share the same VariableDeclarationList.\n          //\n          // Since we are emitting a separate declaration for each one, we need to look upwards\n          // in the ts.Node tree and write a copy of the enclosing VariableDeclarationList\n          // content (e.g. \"var\" from \"var x=1, y=2\").\n          const list: ts.VariableDeclarationList | undefined = TypeScriptHelpers.matchAncestor(span.node, [\n            ts.SyntaxKind.VariableDeclarationList,\n            ts.SyntaxKind.VariableDeclaration\n          ]);\n          if (!list) {\n            // This should not happen unless the compiler API changes somehow\n            throw new InternalError('Unsupported variable declaration');\n          }\n          const listPrefix: string = list\n            .getSourceFile()\n            .text.substring(list.getStart(), list.declarations[0].getStart());\n          span.modification.prefix = listPrefix + span.modification.prefix;\n          span.modification.suffix = ';';\n\n          if (entity.shouldInlineExport) {\n            span.modification.prefix = 'export ' + span.modification.prefix;\n          }\n        }\n        break;\n\n      case ts.SyntaxKind.Identifier:\n        const referencedEntity: CollectorEntity | undefined = collector.tryGetEntityForNode(\n          span.node as ts.Identifier\n        );\n\n        if (referencedEntity) {\n          if (!referencedEntity.nameForEmit) {\n            // This should never happen\n            throw new InternalError('referencedEntry.nameForEmit is undefined');\n          }\n\n          span.modification.prefix = referencedEntity.nameForEmit;\n          // For debugging:\n          // span.modification.prefix += '/*R=FIX*/';\n        } else {\n          // For debugging:\n          // span.modification.prefix += '/*R=KEEP*/';\n        }\n\n        break;\n\n      case ts.SyntaxKind.TypeLiteral:\n        insideTypeLiteral = true;\n        break;\n\n      case ts.SyntaxKind.ImportType:\n        DtsEmitHelpers.modifyImportTypeSpan(\n          collector,\n          span,\n          astDeclaration,\n          (childSpan, childAstDeclaration) => {\n            ApiReportGenerator._modifySpan(\n              collector,\n              childSpan,\n              entity,\n              childAstDeclaration,\n              insideTypeLiteral\n            );\n          }\n        );\n        break;\n    }\n\n    if (recurseChildren) {\n      for (const child of span.children) {\n        let childAstDeclaration: AstDeclaration = astDeclaration;\n\n        if (AstDeclaration.isSupportedSyntaxKind(child.kind)) {\n          childAstDeclaration = collector.astSymbolTable.getChildAstDeclarationByNode(\n            child.node,\n            astDeclaration\n          );\n\n          if (ApiReportGenerator._shouldIncludeInReport(childAstDeclaration)) {\n            if (sortChildren) {\n              span.modification.sortChildren = true;\n              child.modification.sortKey = Collector.getSortKeyIgnoringUnderscore(\n                childAstDeclaration.astSymbol.localName\n              );\n            }\n\n            if (!insideTypeLiteral) {\n              const messagesToReport: ExtractorMessage[] =\n                collector.messageRouter.fetchAssociatedMessagesForReviewFile(childAstDeclaration);\n\n              // NOTE: This generates ae-undocumented messages as a side effect\n              const aedocSynopsis: string = ApiReportGenerator._getAedocSynopsis(\n                collector,\n                childAstDeclaration,\n                messagesToReport\n              );\n\n              child.modification.prefix = aedocSynopsis + child.modification.prefix;\n            }\n          }\n        }\n\n        ApiReportGenerator._modifySpan(collector, child, entity, childAstDeclaration, insideTypeLiteral);\n      }\n    }\n  }\n\n  private static _shouldIncludeInReport(astDeclaration: AstDeclaration): boolean {\n    // Private declarations are not included in the API report\n    // eslint-disable-next-line no-bitwise\n    return (astDeclaration.modifierFlags & ts.ModifierFlags.Private) === 0;\n  }\n\n  /**\n   * For declarations marked as `@preapproved`, this is used instead of _modifySpan().\n   */\n  private static _modifySpanForPreapproved(span: Span): void {\n    // Match something like this:\n    //\n    //   ClassDeclaration:\n    //     SyntaxList:\n    //       ExportKeyword:  pre=[export] sep=[ ]\n    //       DeclareKeyword:  pre=[declare] sep=[ ]\n    //     ClassKeyword:  pre=[class] sep=[ ]\n    //     Identifier:  pre=[_PreapprovedClass] sep=[ ]\n    //     FirstPunctuation:  pre=[{] sep=[\\n\\n    ]\n    //     SyntaxList:\n    //       ...\n    //     CloseBraceToken:  pre=[}]\n    //\n    // or this:\n    //   ModuleDeclaration:\n    //     SyntaxList:\n    //       ExportKeyword:  pre=[export] sep=[ ]\n    //       DeclareKeyword:  pre=[declare] sep=[ ]\n    //     NamespaceKeyword:  pre=[namespace] sep=[ ]\n    //     Identifier:  pre=[_PreapprovedNamespace] sep=[ ]\n    //     ModuleBlock:\n    //       FirstPunctuation:  pre=[{] sep=[\\n\\n    ]\n    //       SyntaxList:\n    //         ...\n    //       CloseBraceToken:  pre=[}]\n    //\n    // And reduce it to something like this:\n    //\n    //   // @internal (undocumented)\n    //   class _PreapprovedClass { /* (preapproved) */ }\n    //\n\n    let skipRest: boolean = false;\n    for (const child of span.children) {\n      if (skipRest || child.kind === ts.SyntaxKind.SyntaxList || child.kind === ts.SyntaxKind.JSDocComment) {\n        child.modification.skipAll();\n      }\n      if (child.kind === ts.SyntaxKind.Identifier) {\n        skipRest = true;\n        child.modification.omitSeparatorAfter = true;\n        child.modification.suffix = ' { /* (preapproved) */ }';\n      }\n    }\n  }\n\n  /**\n   * Writes a synopsis of the AEDoc comments, which indicates the release tag,\n   * whether the item has been documented, and any warnings that were detected\n   * by the analysis.\n   */\n  private static _getAedocSynopsis(\n    collector: Collector,\n    astDeclaration: AstDeclaration,\n    messagesToReport: ExtractorMessage[]\n  ): string {\n    const writer: IndentedWriter = new IndentedWriter();\n\n    for (const message of messagesToReport) {\n      ApiReportGenerator._writeLineAsComments(writer, 'Warning: ' + message.formatMessageWithoutLocation());\n    }\n\n    if (!collector.isAncillaryDeclaration(astDeclaration)) {\n      const footerParts: string[] = [];\n      const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\n      if (!apiItemMetadata.releaseTagSameAsParent) {\n        if (apiItemMetadata.effectiveReleaseTag !== ReleaseTag.None) {\n          footerParts.push(ReleaseTag.getTagName(apiItemMetadata.effectiveReleaseTag));\n        }\n      }\n\n      if (apiItemMetadata.isSealed) {\n        footerParts.push('@sealed');\n      }\n\n      if (apiItemMetadata.isVirtual) {\n        footerParts.push('@virtual');\n      }\n\n      if (apiItemMetadata.isOverride) {\n        footerParts.push('@override');\n      }\n\n      if (apiItemMetadata.isEventProperty) {\n        footerParts.push('@eventProperty');\n      }\n\n      if (apiItemMetadata.tsdocComment) {\n        if (apiItemMetadata.tsdocComment.deprecatedBlock) {\n          footerParts.push('@deprecated');\n        }\n      }\n\n      if (apiItemMetadata.undocumented) {\n        footerParts.push('(undocumented)');\n\n        collector.messageRouter.addAnalyzerIssue(\n          ExtractorMessageId.Undocumented,\n          `Missing documentation for \"${astDeclaration.astSymbol.localName}\".`,\n          astDeclaration\n        );\n      }\n\n      if (footerParts.length > 0) {\n        if (messagesToReport.length > 0) {\n          ApiReportGenerator._writeLineAsComments(writer, ''); // skip a line after the warnings\n        }\n\n        ApiReportGenerator._writeLineAsComments(writer, footerParts.join(' '));\n      }\n    }\n\n    return writer.toString();\n  }\n\n  private static _writeLineAsComments(writer: IndentedWriter, line: string): void {\n    const lines: string[] = Text.convertToLf(line).split('\\n');\n    for (const realLine of lines) {\n      writer.write('// ');\n      writer.write(realLine);\n      writer.writeLine();\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ApiReportGenerator.js","sourceRoot":"","sources":["../../src/generators/ApiReportGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { Text, InternalError } from '@rushstack/node-core-library';\r\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\r\n\r\nimport { Collector } from '../collector/Collector';\r\nimport { TypeScriptHelpers } from '../analyzer/TypeScriptHelpers';\r\nimport { Span } from '../analyzer/Span';\r\nimport type { CollectorEntity } from '../collector/CollectorEntity';\r\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\r\nimport type { ApiItemMetadata } from '../collector/ApiItemMetadata';\r\nimport { AstImport } from '../analyzer/AstImport';\r\nimport { AstSymbol } from '../analyzer/AstSymbol';\r\nimport type { ExtractorMessage } from '../api/ExtractorMessage';\r\nimport { IndentedWriter } from './IndentedWriter';\r\nimport { DtsEmitHelpers } from './DtsEmitHelpers';\r\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\r\nimport type { AstEntity } from '../analyzer/AstEntity';\r\nimport type { AstModuleExportInfo } from '../analyzer/AstModule';\r\nimport { SourceFileLocationFormatter } from '../analyzer/SourceFileLocationFormatter';\r\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\r\n\r\nexport class ApiReportGenerator {\r\n  private static _trimSpacesRegExp: RegExp = / +$/gm;\r\n\r\n  /**\r\n   * Compares the contents of two API files that were created using ApiFileGenerator,\r\n   * and returns true if they are equivalent.  Note that these files are not normally edited\r\n   * by a human; the \"equivalence\" comparison here is intended to ignore spurious changes that\r\n   * might be introduced by a tool, e.g. Git newline normalization or an editor that strips\r\n   * whitespace when saving.\r\n   */\r\n  public static areEquivalentApiFileContents(\r\n    actualFileContent: string,\r\n    expectedFileContent: string\r\n  ): boolean {\r\n    // NOTE: \"\\s\" also matches \"\\r\" and \"\\n\"\r\n    const normalizedActual: string = actualFileContent.replace(/[\\s]+/g, ' ');\r\n    const normalizedExpected: string = expectedFileContent.replace(/[\\s]+/g, ' ');\r\n    return normalizedActual === normalizedExpected;\r\n  }\r\n\r\n  public static generateReviewFileContent(collector: Collector): string {\r\n    const writer: IndentedWriter = new IndentedWriter();\r\n    writer.trimLeadingSpaces = true;\r\n\r\n    writer.writeLine(\r\n      [\r\n        `## API Report File for \"${collector.workingPackage.name}\"`,\r\n        ``,\r\n        `> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).`,\r\n        ``\r\n      ].join('\\n')\r\n    );\r\n\r\n    // Write the opening delimiter for the Markdown code fence\r\n    writer.writeLine('```ts\\n');\r\n\r\n    // Emit the triple slash directives\r\n    for (const typeDirectiveReference of Array.from(collector.dtsTypeReferenceDirectives).sort()) {\r\n      // https://github.com/microsoft/TypeScript/blob/611ebc7aadd7a44a4c0447698bfda9222a78cb66/src/compiler/declarationEmitter.ts#L162\r\n      writer.writeLine(`/// <reference types=\"${typeDirectiveReference}\" />`);\r\n    }\r\n    for (const libDirectiveReference of Array.from(collector.dtsLibReferenceDirectives).sort()) {\r\n      writer.writeLine(`/// <reference lib=\"${libDirectiveReference}\" />`);\r\n    }\r\n    writer.ensureSkippedLine();\r\n\r\n    // Emit the imports\r\n    for (const entity of collector.entities) {\r\n      if (entity.astEntity instanceof AstImport) {\r\n        DtsEmitHelpers.emitImport(writer, entity, entity.astEntity);\r\n      }\r\n    }\r\n    writer.ensureSkippedLine();\r\n\r\n    // Emit the regular declarations\r\n    for (const entity of collector.entities) {\r\n      const astEntity: AstEntity = entity.astEntity;\r\n      if (entity.consumable || collector.extractorConfig.apiReportIncludeForgottenExports) {\r\n        // First, collect the list of export names for this symbol.  When reporting messages with\r\n        // ExtractorMessage.properties.exportName, this will enable us to emit the warning comments alongside\r\n        // the associated export statement.\r\n        interface IExportToEmit {\r\n          readonly exportName: string;\r\n          readonly associatedMessages: ExtractorMessage[];\r\n        }\r\n        const exportsToEmit: Map<string, IExportToEmit> = new Map<string, IExportToEmit>();\r\n\r\n        for (const exportName of entity.exportNames) {\r\n          if (!entity.shouldInlineExport) {\r\n            exportsToEmit.set(exportName, { exportName, associatedMessages: [] });\r\n          }\r\n        }\r\n\r\n        if (astEntity instanceof AstSymbol) {\r\n          // Emit all the declarations for this entity\r\n          for (const astDeclaration of astEntity.astDeclarations || []) {\r\n            // Get the messages associated with this declaration\r\n            const fetchedMessages: ExtractorMessage[] =\r\n              collector.messageRouter.fetchAssociatedMessagesForReviewFile(astDeclaration);\r\n\r\n            // Peel off the messages associated with an export statement and store them\r\n            // in IExportToEmit.associatedMessages (to be processed later).  The remaining messages will\r\n            // added to messagesToReport, to be emitted next to the declaration instead of the export statement.\r\n            const messagesToReport: ExtractorMessage[] = [];\r\n            for (const message of fetchedMessages) {\r\n              if (message.properties.exportName) {\r\n                const exportToEmit: IExportToEmit | undefined = exportsToEmit.get(\r\n                  message.properties.exportName\r\n                );\r\n                if (exportToEmit) {\r\n                  exportToEmit.associatedMessages.push(message);\r\n                  continue;\r\n                }\r\n              }\r\n              messagesToReport.push(message);\r\n            }\r\n\r\n            writer.ensureSkippedLine();\r\n            writer.write(ApiReportGenerator._getAedocSynopsis(collector, astDeclaration, messagesToReport));\r\n\r\n            const span: Span = new Span(astDeclaration.declaration);\r\n\r\n            const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\r\n            if (apiItemMetadata.isPreapproved) {\r\n              ApiReportGenerator._modifySpanForPreapproved(span);\r\n            } else {\r\n              ApiReportGenerator._modifySpan(collector, span, entity, astDeclaration, false);\r\n            }\r\n\r\n            span.writeModifiedText(writer);\r\n            writer.ensureNewLine();\r\n          }\r\n        }\r\n\r\n        if (astEntity instanceof AstNamespaceImport) {\r\n          const astModuleExportInfo: AstModuleExportInfo = astEntity.fetchAstModuleExportInfo(collector);\r\n\r\n          if (entity.nameForEmit === undefined) {\r\n            // This should never happen\r\n            throw new InternalError('referencedEntry.nameForEmit is undefined');\r\n          }\r\n\r\n          if (astModuleExportInfo.starExportedExternalModules.size > 0) {\r\n            // We could support this, but we would need to find a way to safely represent it.\r\n            throw new Error(\r\n              `The ${entity.nameForEmit} namespace import includes a star export, which is not supported:\\n` +\r\n                SourceFileLocationFormatter.formatDeclaration(astEntity.declaration)\r\n            );\r\n          }\r\n\r\n          // Emit a synthetic declaration for the namespace.  It will look like this:\r\n          //\r\n          //    declare namespace example {\r\n          //      export {\r\n          //        f1,\r\n          //        f2\r\n          //      }\r\n          //    }\r\n          //\r\n          // Note that we do not try to relocate f1()/f2() to be inside the namespace because other type\r\n          // signatures may reference them directly (without using the namespace qualifier).\r\n\r\n          writer.ensureSkippedLine();\r\n          writer.writeLine(`declare namespace ${entity.nameForEmit} {`);\r\n\r\n          // all local exports of local imported module are just references to top-level declarations\r\n          writer.increaseIndent();\r\n          writer.writeLine('export {');\r\n          writer.increaseIndent();\r\n\r\n          const exportClauses: string[] = [];\r\n          for (const [exportedName, exportedEntity] of astModuleExportInfo.exportedLocalEntities) {\r\n            const collectorEntity: CollectorEntity | undefined =\r\n              collector.tryGetCollectorEntity(exportedEntity);\r\n            if (collectorEntity === undefined) {\r\n              // This should never happen\r\n              // top-level exports of local imported module should be added as collector entities before\r\n              throw new InternalError(\r\n                `Cannot find collector entity for ${entity.nameForEmit}.${exportedEntity.localName}`\r\n              );\r\n            }\r\n\r\n            if (collectorEntity.nameForEmit === exportedName) {\r\n              exportClauses.push(collectorEntity.nameForEmit);\r\n            } else {\r\n              exportClauses.push(`${collectorEntity.nameForEmit} as ${exportedName}`);\r\n            }\r\n          }\r\n          writer.writeLine(exportClauses.join(',\\n'));\r\n\r\n          writer.decreaseIndent();\r\n          writer.writeLine('}'); // end of \"export { ... }\"\r\n          writer.decreaseIndent();\r\n          writer.writeLine('}'); // end of \"declare namespace { ... }\"\r\n        }\r\n\r\n        // Now emit the export statements for this entity.\r\n        for (const exportToEmit of exportsToEmit.values()) {\r\n          // Write any associated messages\r\n          if (exportToEmit.associatedMessages.length > 0) {\r\n            writer.ensureSkippedLine();\r\n            for (const message of exportToEmit.associatedMessages) {\r\n              ApiReportGenerator._writeLineAsComments(\r\n                writer,\r\n                'Warning: ' + message.formatMessageWithoutLocation()\r\n              );\r\n            }\r\n          }\r\n\r\n          DtsEmitHelpers.emitNamedExport(writer, exportToEmit.exportName, entity);\r\n        }\r\n        writer.ensureSkippedLine();\r\n      }\r\n    }\r\n\r\n    DtsEmitHelpers.emitStarExports(writer, collector);\r\n\r\n    // Write the unassociated warnings at the bottom of the file\r\n    const unassociatedMessages: ExtractorMessage[] =\r\n      collector.messageRouter.fetchUnassociatedMessagesForReviewFile();\r\n    if (unassociatedMessages.length > 0) {\r\n      writer.ensureSkippedLine();\r\n      ApiReportGenerator._writeLineAsComments(writer, 'Warnings were encountered during analysis:');\r\n      ApiReportGenerator._writeLineAsComments(writer, '');\r\n      for (const unassociatedMessage of unassociatedMessages) {\r\n        ApiReportGenerator._writeLineAsComments(\r\n          writer,\r\n          unassociatedMessage.formatMessageWithLocation(collector.workingPackage.packageFolder)\r\n        );\r\n      }\r\n    }\r\n\r\n    if (collector.workingPackage.tsdocComment === undefined) {\r\n      writer.ensureSkippedLine();\r\n      ApiReportGenerator._writeLineAsComments(writer, '(No @packageDocumentation comment for this package)');\r\n    }\r\n\r\n    // Write the closing delimiter for the Markdown code fence\r\n    writer.ensureSkippedLine();\r\n    writer.writeLine('```');\r\n\r\n    // Remove any trailing spaces\r\n    return writer.toString().replace(ApiReportGenerator._trimSpacesRegExp, '');\r\n  }\r\n\r\n  /**\r\n   * Before writing out a declaration, _modifySpan() applies various fixups to make it nice.\r\n   */\r\n  private static _modifySpan(\r\n    collector: Collector,\r\n    span: Span,\r\n    entity: CollectorEntity,\r\n    astDeclaration: AstDeclaration,\r\n    insideTypeLiteral: boolean\r\n  ): void {\r\n    // Should we process this declaration at all?\r\n    // eslint-disable-next-line no-bitwise\r\n    if (!ApiReportGenerator._shouldIncludeInReport(astDeclaration)) {\r\n      span.modification.skipAll();\r\n      return;\r\n    }\r\n\r\n    const previousSpan: Span | undefined = span.previousSibling;\r\n\r\n    let recurseChildren: boolean = true;\r\n    let sortChildren: boolean = false;\r\n\r\n    switch (span.kind) {\r\n      case ts.SyntaxKind.JSDocComment:\r\n        span.modification.skipAll();\r\n        // For now, we don't transform JSDoc comment nodes at all\r\n        recurseChildren = false;\r\n        break;\r\n\r\n      case ts.SyntaxKind.ExportKeyword:\r\n      case ts.SyntaxKind.DefaultKeyword:\r\n      case ts.SyntaxKind.DeclareKeyword:\r\n        // Delete any explicit \"export\" or \"declare\" keywords -- we will re-add them below\r\n        span.modification.skipAll();\r\n        break;\r\n\r\n      case ts.SyntaxKind.InterfaceKeyword:\r\n      case ts.SyntaxKind.ClassKeyword:\r\n      case ts.SyntaxKind.EnumKeyword:\r\n      case ts.SyntaxKind.NamespaceKeyword:\r\n      case ts.SyntaxKind.ModuleKeyword:\r\n      case ts.SyntaxKind.TypeKeyword:\r\n      case ts.SyntaxKind.FunctionKeyword:\r\n        // Replace the stuff we possibly deleted above\r\n        let replacedModifiers: string = '';\r\n\r\n        if (entity.shouldInlineExport) {\r\n          replacedModifiers = 'export ' + replacedModifiers;\r\n        }\r\n\r\n        if (previousSpan && previousSpan.kind === ts.SyntaxKind.SyntaxList) {\r\n          // If there is a previous span of type SyntaxList, then apply it before any other modifiers\r\n          // (e.g. \"abstract\") that appear there.\r\n          previousSpan.modification.prefix = replacedModifiers + previousSpan.modification.prefix;\r\n        } else {\r\n          // Otherwise just stick it in front of this span\r\n          span.modification.prefix = replacedModifiers + span.modification.prefix;\r\n        }\r\n        break;\r\n\r\n      case ts.SyntaxKind.SyntaxList:\r\n        if (span.parent) {\r\n          if (AstDeclaration.isSupportedSyntaxKind(span.parent.kind)) {\r\n            // If the immediate parent is an API declaration, and the immediate children are API declarations,\r\n            // then sort the children alphabetically\r\n            sortChildren = true;\r\n          } else if (span.parent.kind === ts.SyntaxKind.ModuleBlock) {\r\n            // Namespaces are special because their chain goes ModuleDeclaration -> ModuleBlock -> SyntaxList\r\n            sortChildren = true;\r\n          }\r\n        }\r\n        break;\r\n\r\n      case ts.SyntaxKind.VariableDeclaration:\r\n        if (!span.parent) {\r\n          // The VariableDeclaration node is part of a VariableDeclarationList, however\r\n          // the Entry.followedSymbol points to the VariableDeclaration part because\r\n          // multiple definitions might share the same VariableDeclarationList.\r\n          //\r\n          // Since we are emitting a separate declaration for each one, we need to look upwards\r\n          // in the ts.Node tree and write a copy of the enclosing VariableDeclarationList\r\n          // content (e.g. \"var\" from \"var x=1, y=2\").\r\n          const list: ts.VariableDeclarationList | undefined = TypeScriptHelpers.matchAncestor(span.node, [\r\n            ts.SyntaxKind.VariableDeclarationList,\r\n            ts.SyntaxKind.VariableDeclaration\r\n          ]);\r\n          if (!list) {\r\n            // This should not happen unless the compiler API changes somehow\r\n            throw new InternalError('Unsupported variable declaration');\r\n          }\r\n          const listPrefix: string = list\r\n            .getSourceFile()\r\n            .text.substring(list.getStart(), list.declarations[0].getStart());\r\n          span.modification.prefix = listPrefix + span.modification.prefix;\r\n          span.modification.suffix = ';';\r\n\r\n          if (entity.shouldInlineExport) {\r\n            span.modification.prefix = 'export ' + span.modification.prefix;\r\n          }\r\n        }\r\n        break;\r\n\r\n      case ts.SyntaxKind.Identifier:\r\n        const referencedEntity: CollectorEntity | undefined = collector.tryGetEntityForNode(\r\n          span.node as ts.Identifier\r\n        );\r\n\r\n        if (referencedEntity) {\r\n          if (!referencedEntity.nameForEmit) {\r\n            // This should never happen\r\n            throw new InternalError('referencedEntry.nameForEmit is undefined');\r\n          }\r\n\r\n          span.modification.prefix = referencedEntity.nameForEmit;\r\n          // For debugging:\r\n          // span.modification.prefix += '/*R=FIX*/';\r\n        } else {\r\n          // For debugging:\r\n          // span.modification.prefix += '/*R=KEEP*/';\r\n        }\r\n\r\n        break;\r\n\r\n      case ts.SyntaxKind.TypeLiteral:\r\n        insideTypeLiteral = true;\r\n        break;\r\n\r\n      case ts.SyntaxKind.ImportType:\r\n        DtsEmitHelpers.modifyImportTypeSpan(\r\n          collector,\r\n          span,\r\n          astDeclaration,\r\n          (childSpan, childAstDeclaration) => {\r\n            ApiReportGenerator._modifySpan(\r\n              collector,\r\n              childSpan,\r\n              entity,\r\n              childAstDeclaration,\r\n              insideTypeLiteral\r\n            );\r\n          }\r\n        );\r\n        break;\r\n    }\r\n\r\n    if (recurseChildren) {\r\n      for (const child of span.children) {\r\n        let childAstDeclaration: AstDeclaration = astDeclaration;\r\n\r\n        if (AstDeclaration.isSupportedSyntaxKind(child.kind)) {\r\n          childAstDeclaration = collector.astSymbolTable.getChildAstDeclarationByNode(\r\n            child.node,\r\n            astDeclaration\r\n          );\r\n\r\n          if (ApiReportGenerator._shouldIncludeInReport(childAstDeclaration)) {\r\n            if (sortChildren) {\r\n              span.modification.sortChildren = true;\r\n              child.modification.sortKey = Collector.getSortKeyIgnoringUnderscore(\r\n                childAstDeclaration.astSymbol.localName\r\n              );\r\n            }\r\n\r\n            if (!insideTypeLiteral) {\r\n              const messagesToReport: ExtractorMessage[] =\r\n                collector.messageRouter.fetchAssociatedMessagesForReviewFile(childAstDeclaration);\r\n\r\n              // NOTE: This generates ae-undocumented messages as a side effect\r\n              const aedocSynopsis: string = ApiReportGenerator._getAedocSynopsis(\r\n                collector,\r\n                childAstDeclaration,\r\n                messagesToReport\r\n              );\r\n\r\n              child.modification.prefix = aedocSynopsis + child.modification.prefix;\r\n            }\r\n          }\r\n        }\r\n\r\n        ApiReportGenerator._modifySpan(collector, child, entity, childAstDeclaration, insideTypeLiteral);\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _shouldIncludeInReport(astDeclaration: AstDeclaration): boolean {\r\n    // Private declarations are not included in the API report\r\n    // eslint-disable-next-line no-bitwise\r\n    return (astDeclaration.modifierFlags & ts.ModifierFlags.Private) === 0;\r\n  }\r\n\r\n  /**\r\n   * For declarations marked as `@preapproved`, this is used instead of _modifySpan().\r\n   */\r\n  private static _modifySpanForPreapproved(span: Span): void {\r\n    // Match something like this:\r\n    //\r\n    //   ClassDeclaration:\r\n    //     SyntaxList:\r\n    //       ExportKeyword:  pre=[export] sep=[ ]\r\n    //       DeclareKeyword:  pre=[declare] sep=[ ]\r\n    //     ClassKeyword:  pre=[class] sep=[ ]\r\n    //     Identifier:  pre=[_PreapprovedClass] sep=[ ]\r\n    //     FirstPunctuation:  pre=[{] sep=[\\n\\n    ]\r\n    //     SyntaxList:\r\n    //       ...\r\n    //     CloseBraceToken:  pre=[}]\r\n    //\r\n    // or this:\r\n    //   ModuleDeclaration:\r\n    //     SyntaxList:\r\n    //       ExportKeyword:  pre=[export] sep=[ ]\r\n    //       DeclareKeyword:  pre=[declare] sep=[ ]\r\n    //     NamespaceKeyword:  pre=[namespace] sep=[ ]\r\n    //     Identifier:  pre=[_PreapprovedNamespace] sep=[ ]\r\n    //     ModuleBlock:\r\n    //       FirstPunctuation:  pre=[{] sep=[\\n\\n    ]\r\n    //       SyntaxList:\r\n    //         ...\r\n    //       CloseBraceToken:  pre=[}]\r\n    //\r\n    // And reduce it to something like this:\r\n    //\r\n    //   // @internal (undocumented)\r\n    //   class _PreapprovedClass { /* (preapproved) */ }\r\n    //\r\n\r\n    let skipRest: boolean = false;\r\n    for (const child of span.children) {\r\n      if (skipRest || child.kind === ts.SyntaxKind.SyntaxList || child.kind === ts.SyntaxKind.JSDocComment) {\r\n        child.modification.skipAll();\r\n      }\r\n      if (child.kind === ts.SyntaxKind.Identifier) {\r\n        skipRest = true;\r\n        child.modification.omitSeparatorAfter = true;\r\n        child.modification.suffix = ' { /* (preapproved) */ }';\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Writes a synopsis of the AEDoc comments, which indicates the release tag,\r\n   * whether the item has been documented, and any warnings that were detected\r\n   * by the analysis.\r\n   */\r\n  private static _getAedocSynopsis(\r\n    collector: Collector,\r\n    astDeclaration: AstDeclaration,\r\n    messagesToReport: ExtractorMessage[]\r\n  ): string {\r\n    const writer: IndentedWriter = new IndentedWriter();\r\n\r\n    for (const message of messagesToReport) {\r\n      ApiReportGenerator._writeLineAsComments(writer, 'Warning: ' + message.formatMessageWithoutLocation());\r\n    }\r\n\r\n    if (!collector.isAncillaryDeclaration(astDeclaration)) {\r\n      const footerParts: string[] = [];\r\n      const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\r\n      if (!apiItemMetadata.releaseTagSameAsParent) {\r\n        if (apiItemMetadata.effectiveReleaseTag !== ReleaseTag.None) {\r\n          footerParts.push(ReleaseTag.getTagName(apiItemMetadata.effectiveReleaseTag));\r\n        }\r\n      }\r\n\r\n      if (apiItemMetadata.isSealed) {\r\n        footerParts.push('@sealed');\r\n      }\r\n\r\n      if (apiItemMetadata.isVirtual) {\r\n        footerParts.push('@virtual');\r\n      }\r\n\r\n      if (apiItemMetadata.isOverride) {\r\n        footerParts.push('@override');\r\n      }\r\n\r\n      if (apiItemMetadata.isEventProperty) {\r\n        footerParts.push('@eventProperty');\r\n      }\r\n\r\n      if (apiItemMetadata.tsdocComment) {\r\n        if (apiItemMetadata.tsdocComment.deprecatedBlock) {\r\n          footerParts.push('@deprecated');\r\n        }\r\n      }\r\n\r\n      if (apiItemMetadata.undocumented) {\r\n        footerParts.push('(undocumented)');\r\n\r\n        collector.messageRouter.addAnalyzerIssue(\r\n          ExtractorMessageId.Undocumented,\r\n          `Missing documentation for \"${astDeclaration.astSymbol.localName}\".`,\r\n          astDeclaration\r\n        );\r\n      }\r\n\r\n      if (footerParts.length > 0) {\r\n        if (messagesToReport.length > 0) {\r\n          ApiReportGenerator._writeLineAsComments(writer, ''); // skip a line after the warnings\r\n        }\r\n\r\n        ApiReportGenerator._writeLineAsComments(writer, footerParts.join(' '));\r\n      }\r\n    }\r\n\r\n    return writer.toString();\r\n  }\r\n\r\n  private static _writeLineAsComments(writer: IndentedWriter, line: string): void {\r\n    const lines: string[] = Text.convertToLf(line).split('\\n');\r\n    for (const realLine of lines) {\r\n      writer.write('// ');\r\n      writer.write(realLine);\r\n      writer.writeLine();\r\n    }\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/generators/DeclarationReferenceGenerator.js.map b/lib/generators/DeclarationReferenceGenerator.js.map
index 29bdebbb183f5ea58c71269acc7ed42efdda6de2..3a8db1dc947e0b984dfd9cdca82a1f55d2ad46a4 100644
--- a/lib/generators/DeclarationReferenceGenerator.js.map
+++ b/lib/generators/DeclarationReferenceGenerator.js.map
@@ -1 +1 @@
-{"version":3,"file":"DeclarationReferenceGenerator.js","sourceRoot":"","sources":["../../src/generators/DeclarationReferenceGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/* eslint-disable no-bitwise */\nimport * as ts from 'typescript';\nimport {\n  DeclarationReference,\n  ModuleSource,\n  GlobalSource,\n  Navigation,\n  Meaning\n} from '@microsoft/tsdoc/lib-commonjs/beta/DeclarationReference';\nimport { type INodePackageJson, InternalError } from '@rushstack/node-core-library';\nimport { TypeScriptHelpers } from '../analyzer/TypeScriptHelpers';\nimport { TypeScriptInternals } from '../analyzer/TypeScriptInternals';\nimport type { Collector } from '../collector/Collector';\nimport type { CollectorEntity } from '../collector/CollectorEntity';\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\n\nexport class DeclarationReferenceGenerator {\n  public static readonly unknownReference: string = '?';\n\n  private _collector: Collector;\n\n  public constructor(collector: Collector) {\n    this._collector = collector;\n  }\n\n  /**\n   * Gets the UID for a TypeScript Identifier that references a type.\n   */\n  public getDeclarationReferenceForIdentifier(node: ts.Identifier): DeclarationReference | undefined {\n    const symbol: ts.Symbol | undefined = this._collector.typeChecker.getSymbolAtLocation(node);\n    if (symbol !== undefined) {\n      const isExpression: boolean = DeclarationReferenceGenerator._isInExpressionContext(node);\n      return (\n        this.getDeclarationReferenceForSymbol(\n          symbol,\n          isExpression ? ts.SymbolFlags.Value : ts.SymbolFlags.Type\n        ) ||\n        this.getDeclarationReferenceForSymbol(\n          symbol,\n          isExpression ? ts.SymbolFlags.Type : ts.SymbolFlags.Value\n        ) ||\n        this.getDeclarationReferenceForSymbol(symbol, ts.SymbolFlags.Namespace)\n      );\n    }\n  }\n\n  /**\n   * Gets the DeclarationReference for a TypeScript Symbol for a given meaning.\n   */\n  public getDeclarationReferenceForSymbol(\n    symbol: ts.Symbol,\n    meaning: ts.SymbolFlags\n  ): DeclarationReference | undefined {\n    return this._symbolToDeclarationReference(symbol, meaning, /*includeModuleSymbols*/ false);\n  }\n\n  private static _isInExpressionContext(node: ts.Node): boolean {\n    switch (node.parent.kind) {\n      case ts.SyntaxKind.TypeQuery:\n      case ts.SyntaxKind.ComputedPropertyName:\n        return true;\n      case ts.SyntaxKind.QualifiedName:\n        return DeclarationReferenceGenerator._isInExpressionContext(node.parent);\n      default:\n        return false;\n    }\n  }\n\n  private static _isExternalModuleSymbol(symbol: ts.Symbol): boolean {\n    return (\n      !!(symbol.flags & ts.SymbolFlags.ValueModule) &&\n      symbol.valueDeclaration !== undefined &&\n      ts.isSourceFile(symbol.valueDeclaration)\n    );\n  }\n\n  private static _isSameSymbol(left: ts.Symbol | undefined, right: ts.Symbol): boolean {\n    return (\n      left === right ||\n      !!(\n        left &&\n        left.valueDeclaration &&\n        right.valueDeclaration &&\n        left.valueDeclaration === right.valueDeclaration\n      )\n    );\n  }\n\n  private _getNavigationToSymbol(symbol: ts.Symbol): Navigation {\n    const declaration: ts.Declaration | undefined = TypeScriptHelpers.tryGetADeclaration(symbol);\n    const sourceFile: ts.SourceFile | undefined = declaration?.getSourceFile();\n    const parent: ts.Symbol | undefined = TypeScriptInternals.getSymbolParent(symbol);\n\n    // If it's global or from an external library, then use either Members or Exports. It's not possible for\n    // global symbols or external library symbols to be Locals.\n    const isGlobal: boolean = !!sourceFile && !ts.isExternalModule(sourceFile);\n    const isFromExternalLibrary: boolean =\n      !!sourceFile && this._collector.program.isSourceFileFromExternalLibrary(sourceFile);\n    if (isGlobal || isFromExternalLibrary) {\n      if (\n        parent &&\n        parent.members &&\n        DeclarationReferenceGenerator._isSameSymbol(parent.members.get(symbol.escapedName), symbol)\n      ) {\n        return Navigation.Members;\n      }\n\n      return Navigation.Exports;\n    }\n\n    // Otherwise, this symbol is from the current package. If we've found an associated consumable\n    // `CollectorEntity`, then use Exports. We use `consumable` here instead of `exported` because\n    // if the symbol is exported from a non-consumable `AstNamespaceImport`, we don't want to use\n    // Exports. We should use Locals instead.\n    const entity: CollectorEntity | undefined = this._collector.tryGetEntityForSymbol(symbol);\n    if (entity?.consumable) {\n      return Navigation.Exports;\n    }\n\n    // If its parent symbol is not a source file, then use either Exports or Members. If the parent symbol\n    // is a source file, but it wasn't exported from the package entry point (in the check above), then the\n    // symbol is a local, so fall through below.\n    if (parent && !DeclarationReferenceGenerator._isExternalModuleSymbol(parent)) {\n      if (\n        parent.members &&\n        DeclarationReferenceGenerator._isSameSymbol(parent.members.get(symbol.escapedName), symbol)\n      ) {\n        return Navigation.Members;\n      }\n\n      return Navigation.Exports;\n    }\n\n    // Otherwise, we have a local symbol, so use a Locals navigation. These are either:\n    //\n    // 1. Symbols that are exported from a file module but not the package entry point.\n    // 2. Symbols that are not exported from their parent module.\n    return Navigation.Locals;\n  }\n\n  private static _getMeaningOfSymbol(symbol: ts.Symbol, meaning: ts.SymbolFlags): Meaning | undefined {\n    if (symbol.flags & meaning & ts.SymbolFlags.Class) {\n      return Meaning.Class;\n    }\n    if (symbol.flags & meaning & ts.SymbolFlags.Enum) {\n      return Meaning.Enum;\n    }\n    if (symbol.flags & meaning & ts.SymbolFlags.Interface) {\n      return Meaning.Interface;\n    }\n    if (symbol.flags & meaning & ts.SymbolFlags.TypeAlias) {\n      return Meaning.TypeAlias;\n    }\n    if (symbol.flags & meaning & ts.SymbolFlags.Function) {\n      return Meaning.Function;\n    }\n    if (symbol.flags & meaning & ts.SymbolFlags.Variable) {\n      return Meaning.Variable;\n    }\n    if (symbol.flags & meaning & ts.SymbolFlags.Module) {\n      return Meaning.Namespace;\n    }\n    if (symbol.flags & meaning & ts.SymbolFlags.ClassMember) {\n      return Meaning.Member;\n    }\n    if (symbol.flags & meaning & ts.SymbolFlags.Constructor) {\n      return Meaning.Constructor;\n    }\n    if (symbol.flags & meaning & ts.SymbolFlags.EnumMember) {\n      return Meaning.Member;\n    }\n    if (symbol.flags & meaning & ts.SymbolFlags.Signature) {\n      if (symbol.escapedName === ts.InternalSymbolName.Call) {\n        return Meaning.CallSignature;\n      }\n      if (symbol.escapedName === ts.InternalSymbolName.New) {\n        return Meaning.ConstructSignature;\n      }\n      if (symbol.escapedName === ts.InternalSymbolName.Index) {\n        return Meaning.IndexSignature;\n      }\n    }\n    if (symbol.flags & meaning & ts.SymbolFlags.TypeParameter) {\n      // This should have already been handled in `getDeclarationReferenceOfSymbol`.\n      throw new InternalError('Not supported.');\n    }\n    return undefined;\n  }\n\n  private _symbolToDeclarationReference(\n    symbol: ts.Symbol,\n    meaning: ts.SymbolFlags,\n    includeModuleSymbols: boolean\n  ): DeclarationReference | undefined {\n    const declaration: ts.Node | undefined = TypeScriptHelpers.tryGetADeclaration(symbol);\n    const sourceFile: ts.SourceFile | undefined = declaration?.getSourceFile();\n\n    let followedSymbol: ts.Symbol = symbol;\n    if (followedSymbol.flags & ts.SymbolFlags.ExportValue) {\n      followedSymbol = this._collector.typeChecker.getExportSymbolOfSymbol(followedSymbol);\n    }\n    if (followedSymbol.flags & ts.SymbolFlags.Alias) {\n      followedSymbol = this._collector.typeChecker.getAliasedSymbol(followedSymbol);\n\n      // Without this logic, we end up following the symbol `ns` in `import * as ns from './file'` to\n      // the actual file `file.ts`. We don't want to do this, so revert to the original symbol.\n      if (followedSymbol.flags & ts.SymbolFlags.ValueModule) {\n        followedSymbol = symbol;\n      }\n    }\n\n    if (DeclarationReferenceGenerator._isExternalModuleSymbol(followedSymbol)) {\n      if (!includeModuleSymbols) {\n        return undefined;\n      }\n      return new DeclarationReference(this._sourceFileToModuleSource(sourceFile));\n    }\n\n    // Do not generate a declaration reference for a type parameter.\n    if (followedSymbol.flags & ts.SymbolFlags.TypeParameter) {\n      return undefined;\n    }\n\n    let parentRef: DeclarationReference | undefined = this._getParentReference(followedSymbol);\n    if (!parentRef) {\n      return undefined;\n    }\n\n    let localName: string = followedSymbol.name;\n    const entity: CollectorEntity | undefined = this._collector.tryGetEntityForSymbol(followedSymbol);\n    if (entity?.nameForEmit) {\n      localName = entity.nameForEmit;\n    }\n\n    if (followedSymbol.escapedName === ts.InternalSymbolName.Constructor) {\n      localName = 'constructor';\n    } else {\n      const wellKnownName: string | undefined = TypeScriptHelpers.tryDecodeWellKnownSymbolName(\n        followedSymbol.escapedName\n      );\n      if (wellKnownName) {\n        // TypeScript binds well-known ECMAScript symbols like 'Symbol.iterator' as '__@iterator'.\n        // This converts a string like '__@iterator' into the property name '[Symbol.iterator]'.\n        localName = wellKnownName;\n      } else if (TypeScriptHelpers.isUniqueSymbolName(followedSymbol.escapedName)) {\n        for (const decl of followedSymbol.declarations || []) {\n          const declName: ts.DeclarationName | undefined = ts.getNameOfDeclaration(decl);\n          if (declName && ts.isComputedPropertyName(declName)) {\n            const lateName: string | undefined = TypeScriptHelpers.tryGetLateBoundName(declName);\n            if (lateName !== undefined) {\n              localName = lateName;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    const navigation: Navigation = this._getNavigationToSymbol(followedSymbol);\n\n    // If the symbol is a global, ensure the source is global.\n    if (sourceFile && !ts.isExternalModule(sourceFile) && parentRef.source !== GlobalSource.instance) {\n      parentRef = new DeclarationReference(GlobalSource.instance);\n    }\n\n    return parentRef\n      .addNavigationStep(navigation, localName)\n      .withMeaning(DeclarationReferenceGenerator._getMeaningOfSymbol(followedSymbol, meaning));\n  }\n\n  private _getParentReference(symbol: ts.Symbol): DeclarationReference | undefined {\n    const declaration: ts.Node | undefined = TypeScriptHelpers.tryGetADeclaration(symbol);\n    const sourceFile: ts.SourceFile | undefined = declaration?.getSourceFile();\n\n    // Note that it's possible for a symbol to be exported from an entry point as well as one or more\n    // namespaces. In that case, it's not clear what to choose as its parent. Today's logic is neither\n    // perfect nor particularly stable to API items being renamed and shuffled around.\n    const entity: CollectorEntity | undefined = this._collector.tryGetEntityForSymbol(symbol);\n    if (entity) {\n      if (entity.exportedFromEntryPoint) {\n        return new DeclarationReference(this._sourceFileToModuleSource(sourceFile));\n      }\n\n      const firstExportingConsumableParent: CollectorEntity | undefined =\n        entity.getFirstExportingConsumableParent();\n      if (\n        firstExportingConsumableParent &&\n        firstExportingConsumableParent.astEntity instanceof AstNamespaceImport\n      ) {\n        const parentSymbol: ts.Symbol | undefined = TypeScriptInternals.tryGetSymbolForDeclaration(\n          firstExportingConsumableParent.astEntity.declaration,\n          this._collector.typeChecker\n        );\n        if (parentSymbol) {\n          return this._symbolToDeclarationReference(\n            parentSymbol,\n            parentSymbol.flags,\n            /*includeModuleSymbols*/ true\n          );\n        }\n      }\n    }\n\n    // Next, try to find a parent symbol via the symbol tree.\n    const parentSymbol: ts.Symbol | undefined = TypeScriptInternals.getSymbolParent(symbol);\n    if (parentSymbol) {\n      return this._symbolToDeclarationReference(\n        parentSymbol,\n        parentSymbol.flags,\n        /*includeModuleSymbols*/ true\n      );\n    }\n\n    // If that doesn't work, try to find a parent symbol via the node tree. As far as we can tell,\n    // this logic is only needed for local symbols within namespaces. For example:\n    //\n    // ```\n    // export namespace n {\n    //   type SomeType = number;\n    //   export function someFunction(): SomeType { return 5; }\n    // }\n    // ```\n    //\n    // In the example above, `SomeType` doesn't have a parent symbol per the TS internal API above,\n    // but its reference still needs to be qualified with the parent reference for `n`.\n    const grandParent: ts.Node | undefined = declaration?.parent?.parent;\n    if (grandParent && ts.isModuleDeclaration(grandParent)) {\n      const grandParentSymbol: ts.Symbol | undefined = TypeScriptInternals.tryGetSymbolForDeclaration(\n        grandParent,\n        this._collector.typeChecker\n      );\n      if (grandParentSymbol) {\n        return this._symbolToDeclarationReference(\n          grandParentSymbol,\n          grandParentSymbol.flags,\n          /*includeModuleSymbols*/ true\n        );\n      }\n    }\n\n    // At this point, we have a local symbol in a module.\n    if (sourceFile && ts.isExternalModule(sourceFile)) {\n      return new DeclarationReference(this._sourceFileToModuleSource(sourceFile));\n    } else {\n      return new DeclarationReference(GlobalSource.instance);\n    }\n  }\n\n  private _getPackageName(sourceFile: ts.SourceFile): string {\n    if (this._collector.program.isSourceFileFromExternalLibrary(sourceFile)) {\n      const packageJson: INodePackageJson | undefined =\n        this._collector.packageJsonLookup.tryLoadNodePackageJsonFor(sourceFile.fileName);\n\n      if (packageJson && packageJson.name) {\n        return packageJson.name;\n      }\n      return DeclarationReferenceGenerator.unknownReference;\n    }\n    return this._collector.workingPackage.name;\n  }\n\n  private _sourceFileToModuleSource(sourceFile: ts.SourceFile | undefined): GlobalSource | ModuleSource {\n    if (sourceFile && ts.isExternalModule(sourceFile)) {\n      const packageName: string = this._getPackageName(sourceFile);\n\n      if (this._collector.bundledPackageNames.has(packageName)) {\n        // The api-extractor.json config file has a \"bundledPackages\" setting, which causes imports from\n        // certain NPM packages to be treated as part of the working project.  In this case, we need to\n        // substitute the working package name.\n        return new ModuleSource(this._collector.workingPackage.name);\n      } else {\n        return new ModuleSource(packageName);\n      }\n    }\n    return GlobalSource.instance;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"DeclarationReferenceGenerator.js","sourceRoot":"","sources":["../../src/generators/DeclarationReferenceGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* eslint-disable no-bitwise */\r\nimport * as ts from 'typescript';\r\nimport {\r\n  DeclarationReference,\r\n  ModuleSource,\r\n  GlobalSource,\r\n  Navigation,\r\n  Meaning\r\n} from '@microsoft/tsdoc/lib-commonjs/beta/DeclarationReference';\r\nimport { type INodePackageJson, InternalError } from '@rushstack/node-core-library';\r\nimport { TypeScriptHelpers } from '../analyzer/TypeScriptHelpers';\r\nimport { TypeScriptInternals } from '../analyzer/TypeScriptInternals';\r\nimport type { Collector } from '../collector/Collector';\r\nimport type { CollectorEntity } from '../collector/CollectorEntity';\r\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\r\n\r\nexport class DeclarationReferenceGenerator {\r\n  public static readonly unknownReference: string = '?';\r\n\r\n  private _collector: Collector;\r\n\r\n  public constructor(collector: Collector) {\r\n    this._collector = collector;\r\n  }\r\n\r\n  /**\r\n   * Gets the UID for a TypeScript Identifier that references a type.\r\n   */\r\n  public getDeclarationReferenceForIdentifier(node: ts.Identifier): DeclarationReference | undefined {\r\n    const symbol: ts.Symbol | undefined = this._collector.typeChecker.getSymbolAtLocation(node);\r\n    if (symbol !== undefined) {\r\n      const isExpression: boolean = DeclarationReferenceGenerator._isInExpressionContext(node);\r\n      return (\r\n        this.getDeclarationReferenceForSymbol(\r\n          symbol,\r\n          isExpression ? ts.SymbolFlags.Value : ts.SymbolFlags.Type\r\n        ) ||\r\n        this.getDeclarationReferenceForSymbol(\r\n          symbol,\r\n          isExpression ? ts.SymbolFlags.Type : ts.SymbolFlags.Value\r\n        ) ||\r\n        this.getDeclarationReferenceForSymbol(symbol, ts.SymbolFlags.Namespace)\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the DeclarationReference for a TypeScript Symbol for a given meaning.\r\n   */\r\n  public getDeclarationReferenceForSymbol(\r\n    symbol: ts.Symbol,\r\n    meaning: ts.SymbolFlags\r\n  ): DeclarationReference | undefined {\r\n    return this._symbolToDeclarationReference(symbol, meaning, /*includeModuleSymbols*/ false);\r\n  }\r\n\r\n  private static _isInExpressionContext(node: ts.Node): boolean {\r\n    switch (node.parent.kind) {\r\n      case ts.SyntaxKind.TypeQuery:\r\n      case ts.SyntaxKind.ComputedPropertyName:\r\n        return true;\r\n      case ts.SyntaxKind.QualifiedName:\r\n        return DeclarationReferenceGenerator._isInExpressionContext(node.parent);\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  private static _isExternalModuleSymbol(symbol: ts.Symbol): boolean {\r\n    return (\r\n      !!(symbol.flags & ts.SymbolFlags.ValueModule) &&\r\n      symbol.valueDeclaration !== undefined &&\r\n      ts.isSourceFile(symbol.valueDeclaration)\r\n    );\r\n  }\r\n\r\n  private static _isSameSymbol(left: ts.Symbol | undefined, right: ts.Symbol): boolean {\r\n    return (\r\n      left === right ||\r\n      !!(\r\n        left &&\r\n        left.valueDeclaration &&\r\n        right.valueDeclaration &&\r\n        left.valueDeclaration === right.valueDeclaration\r\n      )\r\n    );\r\n  }\r\n\r\n  private _getNavigationToSymbol(symbol: ts.Symbol): Navigation {\r\n    const declaration: ts.Declaration | undefined = TypeScriptHelpers.tryGetADeclaration(symbol);\r\n    const sourceFile: ts.SourceFile | undefined = declaration?.getSourceFile();\r\n    const parent: ts.Symbol | undefined = TypeScriptInternals.getSymbolParent(symbol);\r\n\r\n    // If it's global or from an external library, then use either Members or Exports. It's not possible for\r\n    // global symbols or external library symbols to be Locals.\r\n    const isGlobal: boolean = !!sourceFile && !ts.isExternalModule(sourceFile);\r\n    const isFromExternalLibrary: boolean =\r\n      !!sourceFile && this._collector.program.isSourceFileFromExternalLibrary(sourceFile);\r\n    if (isGlobal || isFromExternalLibrary) {\r\n      if (\r\n        parent &&\r\n        parent.members &&\r\n        DeclarationReferenceGenerator._isSameSymbol(parent.members.get(symbol.escapedName), symbol)\r\n      ) {\r\n        return Navigation.Members;\r\n      }\r\n\r\n      return Navigation.Exports;\r\n    }\r\n\r\n    // Otherwise, this symbol is from the current package. If we've found an associated consumable\r\n    // `CollectorEntity`, then use Exports. We use `consumable` here instead of `exported` because\r\n    // if the symbol is exported from a non-consumable `AstNamespaceImport`, we don't want to use\r\n    // Exports. We should use Locals instead.\r\n    const entity: CollectorEntity | undefined = this._collector.tryGetEntityForSymbol(symbol);\r\n    if (entity?.consumable) {\r\n      return Navigation.Exports;\r\n    }\r\n\r\n    // If its parent symbol is not a source file, then use either Exports or Members. If the parent symbol\r\n    // is a source file, but it wasn't exported from the package entry point (in the check above), then the\r\n    // symbol is a local, so fall through below.\r\n    if (parent && !DeclarationReferenceGenerator._isExternalModuleSymbol(parent)) {\r\n      if (\r\n        parent.members &&\r\n        DeclarationReferenceGenerator._isSameSymbol(parent.members.get(symbol.escapedName), symbol)\r\n      ) {\r\n        return Navigation.Members;\r\n      }\r\n\r\n      return Navigation.Exports;\r\n    }\r\n\r\n    // Otherwise, we have a local symbol, so use a Locals navigation. These are either:\r\n    //\r\n    // 1. Symbols that are exported from a file module but not the package entry point.\r\n    // 2. Symbols that are not exported from their parent module.\r\n    return Navigation.Locals;\r\n  }\r\n\r\n  private static _getMeaningOfSymbol(symbol: ts.Symbol, meaning: ts.SymbolFlags): Meaning | undefined {\r\n    if (symbol.flags & meaning & ts.SymbolFlags.Class) {\r\n      return Meaning.Class;\r\n    }\r\n    if (symbol.flags & meaning & ts.SymbolFlags.Enum) {\r\n      return Meaning.Enum;\r\n    }\r\n    if (symbol.flags & meaning & ts.SymbolFlags.Interface) {\r\n      return Meaning.Interface;\r\n    }\r\n    if (symbol.flags & meaning & ts.SymbolFlags.TypeAlias) {\r\n      return Meaning.TypeAlias;\r\n    }\r\n    if (symbol.flags & meaning & ts.SymbolFlags.Function) {\r\n      return Meaning.Function;\r\n    }\r\n    if (symbol.flags & meaning & ts.SymbolFlags.Variable) {\r\n      return Meaning.Variable;\r\n    }\r\n    if (symbol.flags & meaning & ts.SymbolFlags.Module) {\r\n      return Meaning.Namespace;\r\n    }\r\n    if (symbol.flags & meaning & ts.SymbolFlags.ClassMember) {\r\n      return Meaning.Member;\r\n    }\r\n    if (symbol.flags & meaning & ts.SymbolFlags.Constructor) {\r\n      return Meaning.Constructor;\r\n    }\r\n    if (symbol.flags & meaning & ts.SymbolFlags.EnumMember) {\r\n      return Meaning.Member;\r\n    }\r\n    if (symbol.flags & meaning & ts.SymbolFlags.Signature) {\r\n      if (symbol.escapedName === ts.InternalSymbolName.Call) {\r\n        return Meaning.CallSignature;\r\n      }\r\n      if (symbol.escapedName === ts.InternalSymbolName.New) {\r\n        return Meaning.ConstructSignature;\r\n      }\r\n      if (symbol.escapedName === ts.InternalSymbolName.Index) {\r\n        return Meaning.IndexSignature;\r\n      }\r\n    }\r\n    if (symbol.flags & meaning & ts.SymbolFlags.TypeParameter) {\r\n      // This should have already been handled in `getDeclarationReferenceOfSymbol`.\r\n      throw new InternalError('Not supported.');\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  private _symbolToDeclarationReference(\r\n    symbol: ts.Symbol,\r\n    meaning: ts.SymbolFlags,\r\n    includeModuleSymbols: boolean\r\n  ): DeclarationReference | undefined {\r\n    const declaration: ts.Node | undefined = TypeScriptHelpers.tryGetADeclaration(symbol);\r\n    const sourceFile: ts.SourceFile | undefined = declaration?.getSourceFile();\r\n\r\n    let followedSymbol: ts.Symbol = symbol;\r\n    if (followedSymbol.flags & ts.SymbolFlags.ExportValue) {\r\n      followedSymbol = this._collector.typeChecker.getExportSymbolOfSymbol(followedSymbol);\r\n    }\r\n    if (followedSymbol.flags & ts.SymbolFlags.Alias) {\r\n      followedSymbol = this._collector.typeChecker.getAliasedSymbol(followedSymbol);\r\n\r\n      // Without this logic, we end up following the symbol `ns` in `import * as ns from './file'` to\r\n      // the actual file `file.ts`. We don't want to do this, so revert to the original symbol.\r\n      if (followedSymbol.flags & ts.SymbolFlags.ValueModule) {\r\n        followedSymbol = symbol;\r\n      }\r\n    }\r\n\r\n    if (DeclarationReferenceGenerator._isExternalModuleSymbol(followedSymbol)) {\r\n      if (!includeModuleSymbols) {\r\n        return undefined;\r\n      }\r\n      return new DeclarationReference(this._sourceFileToModuleSource(sourceFile));\r\n    }\r\n\r\n    // Do not generate a declaration reference for a type parameter.\r\n    if (followedSymbol.flags & ts.SymbolFlags.TypeParameter) {\r\n      return undefined;\r\n    }\r\n\r\n    let parentRef: DeclarationReference | undefined = this._getParentReference(followedSymbol);\r\n    if (!parentRef) {\r\n      return undefined;\r\n    }\r\n\r\n    let localName: string = followedSymbol.name;\r\n    const entity: CollectorEntity | undefined = this._collector.tryGetEntityForSymbol(followedSymbol);\r\n    if (entity?.nameForEmit) {\r\n      localName = entity.nameForEmit;\r\n    }\r\n\r\n    if (followedSymbol.escapedName === ts.InternalSymbolName.Constructor) {\r\n      localName = 'constructor';\r\n    } else {\r\n      const wellKnownName: string | undefined = TypeScriptHelpers.tryDecodeWellKnownSymbolName(\r\n        followedSymbol.escapedName\r\n      );\r\n      if (wellKnownName) {\r\n        // TypeScript binds well-known ECMAScript symbols like 'Symbol.iterator' as '__@iterator'.\r\n        // This converts a string like '__@iterator' into the property name '[Symbol.iterator]'.\r\n        localName = wellKnownName;\r\n      } else if (TypeScriptHelpers.isUniqueSymbolName(followedSymbol.escapedName)) {\r\n        for (const decl of followedSymbol.declarations || []) {\r\n          const declName: ts.DeclarationName | undefined = ts.getNameOfDeclaration(decl);\r\n          if (declName && ts.isComputedPropertyName(declName)) {\r\n            const lateName: string | undefined = TypeScriptHelpers.tryGetLateBoundName(declName);\r\n            if (lateName !== undefined) {\r\n              localName = lateName;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const navigation: Navigation = this._getNavigationToSymbol(followedSymbol);\r\n\r\n    // If the symbol is a global, ensure the source is global.\r\n    if (sourceFile && !ts.isExternalModule(sourceFile) && parentRef.source !== GlobalSource.instance) {\r\n      parentRef = new DeclarationReference(GlobalSource.instance);\r\n    }\r\n\r\n    return parentRef\r\n      .addNavigationStep(navigation, localName)\r\n      .withMeaning(DeclarationReferenceGenerator._getMeaningOfSymbol(followedSymbol, meaning));\r\n  }\r\n\r\n  private _getParentReference(symbol: ts.Symbol): DeclarationReference | undefined {\r\n    const declaration: ts.Node | undefined = TypeScriptHelpers.tryGetADeclaration(symbol);\r\n    const sourceFile: ts.SourceFile | undefined = declaration?.getSourceFile();\r\n\r\n    // Note that it's possible for a symbol to be exported from an entry point as well as one or more\r\n    // namespaces. In that case, it's not clear what to choose as its parent. Today's logic is neither\r\n    // perfect nor particularly stable to API items being renamed and shuffled around.\r\n    const entity: CollectorEntity | undefined = this._collector.tryGetEntityForSymbol(symbol);\r\n    if (entity) {\r\n      if (entity.exportedFromEntryPoint) {\r\n        return new DeclarationReference(this._sourceFileToModuleSource(sourceFile));\r\n      }\r\n\r\n      const firstExportingConsumableParent: CollectorEntity | undefined =\r\n        entity.getFirstExportingConsumableParent();\r\n      if (\r\n        firstExportingConsumableParent &&\r\n        firstExportingConsumableParent.astEntity instanceof AstNamespaceImport\r\n      ) {\r\n        const parentSymbol: ts.Symbol | undefined = TypeScriptInternals.tryGetSymbolForDeclaration(\r\n          firstExportingConsumableParent.astEntity.declaration,\r\n          this._collector.typeChecker\r\n        );\r\n        if (parentSymbol) {\r\n          return this._symbolToDeclarationReference(\r\n            parentSymbol,\r\n            parentSymbol.flags,\r\n            /*includeModuleSymbols*/ true\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Next, try to find a parent symbol via the symbol tree.\r\n    const parentSymbol: ts.Symbol | undefined = TypeScriptInternals.getSymbolParent(symbol);\r\n    if (parentSymbol) {\r\n      return this._symbolToDeclarationReference(\r\n        parentSymbol,\r\n        parentSymbol.flags,\r\n        /*includeModuleSymbols*/ true\r\n      );\r\n    }\r\n\r\n    // If that doesn't work, try to find a parent symbol via the node tree. As far as we can tell,\r\n    // this logic is only needed for local symbols within namespaces. For example:\r\n    //\r\n    // ```\r\n    // export namespace n {\r\n    //   type SomeType = number;\r\n    //   export function someFunction(): SomeType { return 5; }\r\n    // }\r\n    // ```\r\n    //\r\n    // In the example above, `SomeType` doesn't have a parent symbol per the TS internal API above,\r\n    // but its reference still needs to be qualified with the parent reference for `n`.\r\n    const grandParent: ts.Node | undefined = declaration?.parent?.parent;\r\n    if (grandParent && ts.isModuleDeclaration(grandParent)) {\r\n      const grandParentSymbol: ts.Symbol | undefined = TypeScriptInternals.tryGetSymbolForDeclaration(\r\n        grandParent,\r\n        this._collector.typeChecker\r\n      );\r\n      if (grandParentSymbol) {\r\n        return this._symbolToDeclarationReference(\r\n          grandParentSymbol,\r\n          grandParentSymbol.flags,\r\n          /*includeModuleSymbols*/ true\r\n        );\r\n      }\r\n    }\r\n\r\n    // At this point, we have a local symbol in a module.\r\n    if (sourceFile && ts.isExternalModule(sourceFile)) {\r\n      return new DeclarationReference(this._sourceFileToModuleSource(sourceFile));\r\n    } else {\r\n      return new DeclarationReference(GlobalSource.instance);\r\n    }\r\n  }\r\n\r\n  private _getPackageName(sourceFile: ts.SourceFile): string {\r\n    if (this._collector.program.isSourceFileFromExternalLibrary(sourceFile)) {\r\n      const packageJson: INodePackageJson | undefined =\r\n        this._collector.packageJsonLookup.tryLoadNodePackageJsonFor(sourceFile.fileName);\r\n\r\n      if (packageJson && packageJson.name) {\r\n        return packageJson.name;\r\n      }\r\n      return DeclarationReferenceGenerator.unknownReference;\r\n    }\r\n    return this._collector.workingPackage.name;\r\n  }\r\n\r\n  private _sourceFileToModuleSource(sourceFile: ts.SourceFile | undefined): GlobalSource | ModuleSource {\r\n    if (sourceFile && ts.isExternalModule(sourceFile)) {\r\n      const packageName: string = this._getPackageName(sourceFile);\r\n\r\n      if (this._collector.bundledPackageNames.has(packageName)) {\r\n        // The api-extractor.json config file has a \"bundledPackages\" setting, which causes imports from\r\n        // certain NPM packages to be treated as part of the working project.  In this case, we need to\r\n        // substitute the working package name.\r\n        return new ModuleSource(this._collector.workingPackage.name);\r\n      } else {\r\n        return new ModuleSource(packageName);\r\n      }\r\n    }\r\n    return GlobalSource.instance;\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/generators/DtsEmitHelpers.js.map b/lib/generators/DtsEmitHelpers.js.map
index efd6b045915cc46c85ee3ed3e4b8a2f7104c67f9..cac9435a286e26eb79d62d473d5614850f14200e 100644
--- a/lib/generators/DtsEmitHelpers.js.map
+++ b/lib/generators/DtsEmitHelpers.js.map
@@ -1 +1 @@
-{"version":3,"file":"DtsEmitHelpers.js","sourceRoot":"","sources":["../../src/generators/DtsEmitHelpers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\n\nimport { InternalError } from '@rushstack/node-core-library';\nimport type { CollectorEntity } from '../collector/CollectorEntity';\nimport { AstImport, AstImportKind } from '../analyzer/AstImport';\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\nimport type { Collector } from '../collector/Collector';\nimport type { Span } from '../analyzer/Span';\nimport type { IndentedWriter } from './IndentedWriter';\nimport { SourceFileLocationFormatter } from '../analyzer/SourceFileLocationFormatter';\n\n/**\n * Some common code shared between DtsRollupGenerator and ApiReportGenerator.\n */\nexport class DtsEmitHelpers {\n  public static emitImport(\n    writer: IndentedWriter,\n    collectorEntity: CollectorEntity,\n    astImport: AstImport\n  ): void {\n    const importPrefix: string = astImport.isTypeOnlyEverywhere ? 'import type' : 'import';\n\n    switch (astImport.importKind) {\n      case AstImportKind.DefaultImport:\n        if (collectorEntity.nameForEmit !== astImport.exportName) {\n          writer.write(`${importPrefix} { default as ${collectorEntity.nameForEmit} }`);\n        } else {\n          writer.write(`${importPrefix} ${astImport.exportName}`);\n        }\n        writer.writeLine(` from '${astImport.modulePath}';`);\n        break;\n      case AstImportKind.NamedImport:\n        if (collectorEntity.nameForEmit === astImport.exportName) {\n          writer.write(`${importPrefix} { ${astImport.exportName} }`);\n        } else {\n          writer.write(`${importPrefix} { ${astImport.exportName} as ${collectorEntity.nameForEmit} }`);\n        }\n        writer.writeLine(` from '${astImport.modulePath}';`);\n        break;\n      case AstImportKind.StarImport:\n        writer.writeLine(\n          `${importPrefix} * as ${collectorEntity.nameForEmit} from '${astImport.modulePath}';`\n        );\n        break;\n      case AstImportKind.EqualsImport:\n        writer.writeLine(\n          `${importPrefix} ${collectorEntity.nameForEmit} = require('${astImport.modulePath}');`\n        );\n        break;\n      case AstImportKind.ImportType:\n        if (!astImport.exportName) {\n          writer.writeLine(\n            `${importPrefix} * as ${collectorEntity.nameForEmit} from '${astImport.modulePath}';`\n          );\n        } else {\n          const topExportName: string = astImport.exportName.split('.')[0];\n          if (collectorEntity.nameForEmit === topExportName) {\n            writer.write(`${importPrefix} { ${topExportName} }`);\n          } else {\n            writer.write(`${importPrefix} { ${topExportName} as ${collectorEntity.nameForEmit} }`);\n          }\n          writer.writeLine(` from '${astImport.modulePath}';`);\n        }\n        break;\n      default:\n        throw new InternalError('Unimplemented AstImportKind');\n    }\n  }\n\n  public static emitNamedExport(\n    writer: IndentedWriter,\n    exportName: string,\n    collectorEntity: CollectorEntity\n  ): void {\n    if (exportName === ts.InternalSymbolName.Default) {\n      writer.writeLine(`export default ${collectorEntity.nameForEmit};`);\n    } else if (collectorEntity.nameForEmit !== exportName) {\n      writer.writeLine(`export { ${collectorEntity.nameForEmit} as ${exportName} }`);\n    } else {\n      writer.writeLine(`export { ${exportName} }`);\n    }\n  }\n\n  public static emitStarExports(writer: IndentedWriter, collector: Collector): void {\n    if (collector.starExportedExternalModulePaths.length > 0) {\n      writer.writeLine();\n      for (const starExportedExternalModulePath of collector.starExportedExternalModulePaths) {\n        writer.writeLine(`export * from \"${starExportedExternalModulePath}\";`);\n      }\n    }\n  }\n\n  public static modifyImportTypeSpan(\n    collector: Collector,\n    span: Span,\n    astDeclaration: AstDeclaration,\n    modifyNestedSpan: (childSpan: Span, childAstDeclaration: AstDeclaration) => void\n  ): void {\n    const node: ts.ImportTypeNode = span.node as ts.ImportTypeNode;\n    const referencedEntity: CollectorEntity | undefined = collector.tryGetEntityForNode(node);\n\n    if (referencedEntity) {\n      if (!referencedEntity.nameForEmit) {\n        // This should never happen\n\n        throw new InternalError('referencedEntry.nameForEmit is undefined');\n      }\n\n      let typeArgumentsText: string = '';\n\n      if (node.typeArguments && node.typeArguments.length > 0) {\n        // Type arguments have to be processed and written to the document\n        const lessThanTokenPos: number = span.children.findIndex(\n          (childSpan) => childSpan.node.kind === ts.SyntaxKind.LessThanToken\n        );\n        const greaterThanTokenPos: number = span.children.findIndex(\n          (childSpan) => childSpan.node.kind === ts.SyntaxKind.GreaterThanToken\n        );\n\n        if (lessThanTokenPos < 0 || greaterThanTokenPos <= lessThanTokenPos) {\n          throw new InternalError(\n            `Invalid type arguments: ${node.getText()}\\n` +\n              SourceFileLocationFormatter.formatDeclaration(node)\n          );\n        }\n\n        const typeArgumentsSpans: Span[] = span.children.slice(lessThanTokenPos + 1, greaterThanTokenPos);\n\n        // Apply modifications to Span elements of typeArguments\n        typeArgumentsSpans.forEach((childSpan) => {\n          const childAstDeclaration: AstDeclaration = AstDeclaration.isSupportedSyntaxKind(childSpan.kind)\n            ? collector.astSymbolTable.getChildAstDeclarationByNode(childSpan.node, astDeclaration)\n            : astDeclaration;\n\n          modifyNestedSpan(childSpan, childAstDeclaration);\n        });\n\n        const typeArgumentsStrings: string[] = typeArgumentsSpans.map((childSpan) =>\n          childSpan.getModifiedText()\n        );\n        typeArgumentsText = `<${typeArgumentsStrings.join(', ')}>`;\n      }\n\n      const separatorAfter: string = /(\\s*)$/.exec(span.getText())?.[1] ?? '';\n\n      if (\n        referencedEntity.astEntity instanceof AstImport &&\n        referencedEntity.astEntity.importKind === AstImportKind.ImportType &&\n        referencedEntity.astEntity.exportName\n      ) {\n        // For an ImportType with a namespace chain, only the top namespace is imported.\n        // Must add the original nested qualifiers to the rolled up import.\n        const qualifiersText: string = node.qualifier?.getText() ?? '';\n        const nestedQualifiersStart: number = qualifiersText.indexOf('.');\n        // Including the leading \".\"\n        const nestedQualifiersText: string =\n          nestedQualifiersStart >= 0 ? qualifiersText.substring(nestedQualifiersStart) : '';\n\n        const replacement: string = `${referencedEntity.nameForEmit}${nestedQualifiersText}${typeArgumentsText}${separatorAfter}`;\n\n        span.modification.skipAll();\n        span.modification.prefix = replacement;\n      } else {\n        // Replace with internal symbol or AstImport\n        span.modification.skipAll();\n        span.modification.prefix = `${referencedEntity.nameForEmit}${typeArgumentsText}${separatorAfter}`;\n      }\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"DtsEmitHelpers.js","sourceRoot":"","sources":["../../src/generators/DtsEmitHelpers.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,+CAAiC;AAEjC,oEAA6D;AAE7D,qDAAiE;AACjE,+DAA4D;AAI5D,yFAAsF;AAEtF;;GAEG;AACH,MAAa,cAAc;IAClB,MAAM,CAAC,UAAU,CACtB,MAAsB,EACtB,eAAgC,EAChC,SAAoB;QAEpB,MAAM,YAAY,GAAW,SAAS,CAAC,oBAAoB,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,QAAQ,CAAC;QAEvF,QAAQ,SAAS,CAAC,UAAU,EAAE;YAC5B,KAAK,yBAAa,CAAC,aAAa;gBAC9B,IAAI,eAAe,CAAC,WAAW,KAAK,SAAS,CAAC,UAAU,EAAE;oBACxD,MAAM,CAAC,KAAK,CAAC,GAAG,YAAY,iBAAiB,eAAe,CAAC,WAAW,IAAI,CAAC,CAAC;iBAC/E;qBAAM;oBACL,MAAM,CAAC,KAAK,CAAC,GAAG,YAAY,IAAI,SAAS,CAAC,UAAU,EAAE,CAAC,CAAC;iBACzD;gBACD,MAAM,CAAC,SAAS,CAAC,UAAU,SAAS,CAAC,UAAU,IAAI,CAAC,CAAC;gBACrD,MAAM;YACR,KAAK,yBAAa,CAAC,WAAW;gBAC5B,IAAI,eAAe,CAAC,WAAW,KAAK,SAAS,CAAC,UAAU,EAAE;oBACxD,MAAM,CAAC,KAAK,CAAC,GAAG,YAAY,MAAM,SAAS,CAAC,UAAU,IAAI,CAAC,CAAC;iBAC7D;qBAAM;oBACL,MAAM,CAAC,KAAK,CAAC,GAAG,YAAY,MAAM,SAAS,CAAC,UAAU,OAAO,eAAe,CAAC,WAAW,IAAI,CAAC,CAAC;iBAC/F;gBACD,MAAM,CAAC,SAAS,CAAC,UAAU,SAAS,CAAC,UAAU,IAAI,CAAC,CAAC;gBACrD,MAAM;YACR,KAAK,yBAAa,CAAC,UAAU;gBAC3B,MAAM,CAAC,SAAS,CACd,GAAG,YAAY,SAAS,eAAe,CAAC,WAAW,UAAU,SAAS,CAAC,UAAU,IAAI,CACtF,CAAC;gBACF,MAAM;YACR,KAAK,yBAAa,CAAC,YAAY;gBAC7B,MAAM,CAAC,SAAS,CACd,GAAG,YAAY,IAAI,eAAe,CAAC,WAAW,eAAe,SAAS,CAAC,UAAU,KAAK,CACvF,CAAC;gBACF,MAAM;YACR,KAAK,yBAAa,CAAC,UAAU;gBAC3B,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE;oBACzB,MAAM,CAAC,SAAS,CACd,GAAG,YAAY,SAAS,eAAe,CAAC,WAAW,UAAU,SAAS,CAAC,UAAU,IAAI,CACtF,CAAC;iBACH;qBAAM;oBACL,MAAM,aAAa,GAAW,SAAS,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;oBACjE,IAAI,eAAe,CAAC,WAAW,KAAK,aAAa,EAAE;wBACjD,MAAM,CAAC,KAAK,CAAC,GAAG,YAAY,MAAM,aAAa,IAAI,CAAC,CAAC;qBACtD;yBAAM;wBACL,MAAM,CAAC,KAAK,CAAC,GAAG,YAAY,MAAM,aAAa,OAAO,eAAe,CAAC,WAAW,IAAI,CAAC,CAAC;qBACxF;oBACD,MAAM,CAAC,SAAS,CAAC,UAAU,SAAS,CAAC,UAAU,IAAI,CAAC,CAAC;iBACtD;gBACD,MAAM;YACR;gBACE,MAAM,IAAI,iCAAa,CAAC,6BAA6B,CAAC,CAAC;SAC1D;IACH,CAAC;IAEM,MAAM,CAAC,eAAe,CAC3B,MAAsB,EACtB,UAAkB,EAClB,eAAgC;QAEhC,IAAI,UAAU,KAAK,EAAE,CAAC,kBAAkB,CAAC,OAAO,EAAE;YAChD,MAAM,CAAC,SAAS,CAAC,kBAAkB,eAAe,CAAC,WAAW,GAAG,CAAC,CAAC;SACpE;aAAM,IAAI,eAAe,CAAC,WAAW,KAAK,UAAU,EAAE;YACrD,MAAM,CAAC,SAAS,CAAC,YAAY,eAAe,CAAC,WAAW,OAAO,UAAU,IAAI,CAAC,CAAC;SAChF;aAAM;YACL,MAAM,CAAC,SAAS,CAAC,YAAY,UAAU,IAAI,CAAC,CAAC;SAC9C;IACH,CAAC;IAEM,MAAM,CAAC,eAAe,CAAC,MAAsB,EAAE,SAAoB;QACxE,IAAI,SAAS,CAAC,+BAA+B,CAAC,MAAM,GAAG,CAAC,EAAE;YACxD,MAAM,CAAC,SAAS,EAAE,CAAC;YACnB,KAAK,MAAM,8BAA8B,IAAI,SAAS,CAAC,+BAA+B,EAAE;gBACtF,MAAM,CAAC,SAAS,CAAC,kBAAkB,8BAA8B,IAAI,CAAC,CAAC;aACxE;SACF;IACH,CAAC;IAEM,MAAM,CAAC,oBAAoB,CAChC,SAAoB,EACpB,IAAU,EACV,cAA8B,EAC9B,gBAAgF;;QAEhF,MAAM,IAAI,GAAsB,IAAI,CAAC,IAAyB,CAAC;QAC/D,MAAM,gBAAgB,GAAgC,SAAS,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;QAE1F,IAAI,gBAAgB,EAAE;YACpB,IAAI,CAAC,gBAAgB,CAAC,WAAW,EAAE;gBACjC,2BAA2B;gBAE3B,MAAM,IAAI,iCAAa,CAAC,0CAA0C,CAAC,CAAC;aACrE;YAED,IAAI,iBAAiB,GAAW,EAAE,CAAC;YAEnC,IAAI,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;gBACvD,kEAAkE;gBAClE,MAAM,gBAAgB,GAAW,IAAI,CAAC,QAAQ,CAAC,SAAS,CACtD,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,aAAa,CACnE,CAAC;gBACF,MAAM,mBAAmB,GAAW,IAAI,CAAC,QAAQ,CAAC,SAAS,CACzD,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,gBAAgB,CACtE,CAAC;gBAEF,IAAI,gBAAgB,GAAG,CAAC,IAAI,mBAAmB,IAAI,gBAAgB,EAAE;oBACnE,MAAM,IAAI,iCAAa,CACrB,2BAA2B,IAAI,CAAC,OAAO,EAAE,IAAI;wBAC3C,yDAA2B,CAAC,iBAAiB,CAAC,IAAI,CAAC,CACtD,CAAC;iBACH;gBAED,MAAM,kBAAkB,GAAW,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,gBAAgB,GAAG,CAAC,EAAE,mBAAmB,CAAC,CAAC;gBAElG,wDAAwD;gBACxD,kBAAkB,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,EAAE;oBACvC,MAAM,mBAAmB,GAAmB,+BAAc,CAAC,qBAAqB,CAAC,SAAS,CAAC,IAAI,CAAC;wBAC9F,CAAC,CAAC,SAAS,CAAC,cAAc,CAAC,4BAA4B,CAAC,SAAS,CAAC,IAAI,EAAE,cAAc,CAAC;wBACvF,CAAC,CAAC,cAAc,CAAC;oBAEnB,gBAAgB,CAAC,SAAS,EAAE,mBAAmB,CAAC,CAAC;gBACnD,CAAC,CAAC,CAAC;gBAEH,MAAM,oBAAoB,GAAa,kBAAkB,CAAC,GAAG,CAAC,CAAC,SAAS,EAAE,EAAE,CAC1E,SAAS,CAAC,eAAe,EAAE,CAC5B,CAAC;gBACF,iBAAiB,GAAG,IAAI,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;aAC5D;YAED,MAAM,cAAc,GAAW,MAAA,MAAA,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,0CAAG,CAAC,CAAC,mCAAI,EAAE,CAAC;YAExE,IACE,gBAAgB,CAAC,SAAS,YAAY,qBAAS;gBAC/C,gBAAgB,CAAC,SAAS,CAAC,UAAU,KAAK,yBAAa,CAAC,UAAU;gBAClE,gBAAgB,CAAC,SAAS,CAAC,UAAU,EACrC;gBACA,gFAAgF;gBAChF,mEAAmE;gBACnE,MAAM,cAAc,GAAW,MAAA,MAAA,IAAI,CAAC,SAAS,0CAAE,OAAO,EAAE,mCAAI,EAAE,CAAC;gBAC/D,MAAM,qBAAqB,GAAW,cAAc,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;gBAClE,4BAA4B;gBAC5B,MAAM,oBAAoB,GACxB,qBAAqB,IAAI,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,SAAS,CAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;gBAEpF,MAAM,WAAW,GAAW,GAAG,gBAAgB,CAAC,WAAW,GAAG,oBAAoB,GAAG,iBAAiB,GAAG,cAAc,EAAE,CAAC;gBAE1H,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;gBAC5B,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,WAAW,CAAC;aACxC;iBAAM;gBACL,4CAA4C;gBAC5C,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;gBAC5B,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,GAAG,gBAAgB,CAAC,WAAW,GAAG,iBAAiB,GAAG,cAAc,EAAE,CAAC;aACnG;SACF;IACH,CAAC;CACF;AA3JD,wCA2JC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\n\r\nimport { InternalError } from '@rushstack/node-core-library';\r\nimport type { CollectorEntity } from '../collector/CollectorEntity';\r\nimport { AstImport, AstImportKind } from '../analyzer/AstImport';\r\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\r\nimport type { Collector } from '../collector/Collector';\r\nimport type { Span } from '../analyzer/Span';\r\nimport type { IndentedWriter } from './IndentedWriter';\r\nimport { SourceFileLocationFormatter } from '../analyzer/SourceFileLocationFormatter';\r\n\r\n/**\r\n * Some common code shared between DtsRollupGenerator and ApiReportGenerator.\r\n */\r\nexport class DtsEmitHelpers {\r\n  public static emitImport(\r\n    writer: IndentedWriter,\r\n    collectorEntity: CollectorEntity,\r\n    astImport: AstImport\r\n  ): void {\r\n    const importPrefix: string = astImport.isTypeOnlyEverywhere ? 'import type' : 'import';\r\n\r\n    switch (astImport.importKind) {\r\n      case AstImportKind.DefaultImport:\r\n        if (collectorEntity.nameForEmit !== astImport.exportName) {\r\n          writer.write(`${importPrefix} { default as ${collectorEntity.nameForEmit} }`);\r\n        } else {\r\n          writer.write(`${importPrefix} ${astImport.exportName}`);\r\n        }\r\n        writer.writeLine(` from '${astImport.modulePath}';`);\r\n        break;\r\n      case AstImportKind.NamedImport:\r\n        if (collectorEntity.nameForEmit === astImport.exportName) {\r\n          writer.write(`${importPrefix} { ${astImport.exportName} }`);\r\n        } else {\r\n          writer.write(`${importPrefix} { ${astImport.exportName} as ${collectorEntity.nameForEmit} }`);\r\n        }\r\n        writer.writeLine(` from '${astImport.modulePath}';`);\r\n        break;\r\n      case AstImportKind.StarImport:\r\n        writer.writeLine(\r\n          `${importPrefix} * as ${collectorEntity.nameForEmit} from '${astImport.modulePath}';`\r\n        );\r\n        break;\r\n      case AstImportKind.EqualsImport:\r\n        writer.writeLine(\r\n          `${importPrefix} ${collectorEntity.nameForEmit} = require('${astImport.modulePath}');`\r\n        );\r\n        break;\r\n      case AstImportKind.ImportType:\r\n        if (!astImport.exportName) {\r\n          writer.writeLine(\r\n            `${importPrefix} * as ${collectorEntity.nameForEmit} from '${astImport.modulePath}';`\r\n          );\r\n        } else {\r\n          const topExportName: string = astImport.exportName.split('.')[0];\r\n          if (collectorEntity.nameForEmit === topExportName) {\r\n            writer.write(`${importPrefix} { ${topExportName} }`);\r\n          } else {\r\n            writer.write(`${importPrefix} { ${topExportName} as ${collectorEntity.nameForEmit} }`);\r\n          }\r\n          writer.writeLine(` from '${astImport.modulePath}';`);\r\n        }\r\n        break;\r\n      default:\r\n        throw new InternalError('Unimplemented AstImportKind');\r\n    }\r\n  }\r\n\r\n  public static emitNamedExport(\r\n    writer: IndentedWriter,\r\n    exportName: string,\r\n    collectorEntity: CollectorEntity\r\n  ): void {\r\n    if (exportName === ts.InternalSymbolName.Default) {\r\n      writer.writeLine(`export default ${collectorEntity.nameForEmit};`);\r\n    } else if (collectorEntity.nameForEmit !== exportName) {\r\n      writer.writeLine(`export { ${collectorEntity.nameForEmit} as ${exportName} }`);\r\n    } else {\r\n      writer.writeLine(`export { ${exportName} }`);\r\n    }\r\n  }\r\n\r\n  public static emitStarExports(writer: IndentedWriter, collector: Collector): void {\r\n    if (collector.starExportedExternalModulePaths.length > 0) {\r\n      writer.writeLine();\r\n      for (const starExportedExternalModulePath of collector.starExportedExternalModulePaths) {\r\n        writer.writeLine(`export * from \"${starExportedExternalModulePath}\";`);\r\n      }\r\n    }\r\n  }\r\n\r\n  public static modifyImportTypeSpan(\r\n    collector: Collector,\r\n    span: Span,\r\n    astDeclaration: AstDeclaration,\r\n    modifyNestedSpan: (childSpan: Span, childAstDeclaration: AstDeclaration) => void\r\n  ): void {\r\n    const node: ts.ImportTypeNode = span.node as ts.ImportTypeNode;\r\n    const referencedEntity: CollectorEntity | undefined = collector.tryGetEntityForNode(node);\r\n\r\n    if (referencedEntity) {\r\n      if (!referencedEntity.nameForEmit) {\r\n        // This should never happen\r\n\r\n        throw new InternalError('referencedEntry.nameForEmit is undefined');\r\n      }\r\n\r\n      let typeArgumentsText: string = '';\r\n\r\n      if (node.typeArguments && node.typeArguments.length > 0) {\r\n        // Type arguments have to be processed and written to the document\r\n        const lessThanTokenPos: number = span.children.findIndex(\r\n          (childSpan) => childSpan.node.kind === ts.SyntaxKind.LessThanToken\r\n        );\r\n        const greaterThanTokenPos: number = span.children.findIndex(\r\n          (childSpan) => childSpan.node.kind === ts.SyntaxKind.GreaterThanToken\r\n        );\r\n\r\n        if (lessThanTokenPos < 0 || greaterThanTokenPos <= lessThanTokenPos) {\r\n          throw new InternalError(\r\n            `Invalid type arguments: ${node.getText()}\\n` +\r\n              SourceFileLocationFormatter.formatDeclaration(node)\r\n          );\r\n        }\r\n\r\n        const typeArgumentsSpans: Span[] = span.children.slice(lessThanTokenPos + 1, greaterThanTokenPos);\r\n\r\n        // Apply modifications to Span elements of typeArguments\r\n        typeArgumentsSpans.forEach((childSpan) => {\r\n          const childAstDeclaration: AstDeclaration = AstDeclaration.isSupportedSyntaxKind(childSpan.kind)\r\n            ? collector.astSymbolTable.getChildAstDeclarationByNode(childSpan.node, astDeclaration)\r\n            : astDeclaration;\r\n\r\n          modifyNestedSpan(childSpan, childAstDeclaration);\r\n        });\r\n\r\n        const typeArgumentsStrings: string[] = typeArgumentsSpans.map((childSpan) =>\r\n          childSpan.getModifiedText()\r\n        );\r\n        typeArgumentsText = `<${typeArgumentsStrings.join(', ')}>`;\r\n      }\r\n\r\n      const separatorAfter: string = /(\\s*)$/.exec(span.getText())?.[1] ?? '';\r\n\r\n      if (\r\n        referencedEntity.astEntity instanceof AstImport &&\r\n        referencedEntity.astEntity.importKind === AstImportKind.ImportType &&\r\n        referencedEntity.astEntity.exportName\r\n      ) {\r\n        // For an ImportType with a namespace chain, only the top namespace is imported.\r\n        // Must add the original nested qualifiers to the rolled up import.\r\n        const qualifiersText: string = node.qualifier?.getText() ?? '';\r\n        const nestedQualifiersStart: number = qualifiersText.indexOf('.');\r\n        // Including the leading \".\"\r\n        const nestedQualifiersText: string =\r\n          nestedQualifiersStart >= 0 ? qualifiersText.substring(nestedQualifiersStart) : '';\r\n\r\n        const replacement: string = `${referencedEntity.nameForEmit}${nestedQualifiersText}${typeArgumentsText}${separatorAfter}`;\r\n\r\n        span.modification.skipAll();\r\n        span.modification.prefix = replacement;\r\n      } else {\r\n        // Replace with internal symbol or AstImport\r\n        span.modification.skipAll();\r\n        span.modification.prefix = `${referencedEntity.nameForEmit}${typeArgumentsText}${separatorAfter}`;\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/generators/DtsRollupGenerator.js.map b/lib/generators/DtsRollupGenerator.js.map
index bcb4b71caacf419c54f8103b1930b0dff1f22725..1dff397e49262656e9c49e28ae57deca18d0ef87 100644
--- a/lib/generators/DtsRollupGenerator.js.map
+++ b/lib/generators/DtsRollupGenerator.js.map
@@ -1 +1 @@
-{"version":3,"file":"DtsRollupGenerator.js","sourceRoot":"","sources":["../../src/generators/DtsRollupGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/* eslint-disable no-bitwise */\n\nimport * as ts from 'typescript';\nimport { FileSystem, type NewlineKind, InternalError } from '@rushstack/node-core-library';\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\n\nimport type { Collector } from '../collector/Collector';\nimport { TypeScriptHelpers } from '../analyzer/TypeScriptHelpers';\nimport { IndentDocCommentScope, Span, type SpanModification } from '../analyzer/Span';\nimport { AstImport } from '../analyzer/AstImport';\nimport type { CollectorEntity } from '../collector/CollectorEntity';\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\nimport type { ApiItemMetadata } from '../collector/ApiItemMetadata';\nimport { AstSymbol } from '../analyzer/AstSymbol';\nimport type { SymbolMetadata } from '../collector/SymbolMetadata';\nimport { IndentedWriter } from './IndentedWriter';\nimport { DtsEmitHelpers } from './DtsEmitHelpers';\nimport type { DeclarationMetadata } from '../collector/DeclarationMetadata';\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\nimport type { AstModuleExportInfo } from '../analyzer/AstModule';\nimport { SourceFileLocationFormatter } from '../analyzer/SourceFileLocationFormatter';\nimport type { AstEntity } from '../analyzer/AstEntity';\n\n/**\n * Used with DtsRollupGenerator.writeTypingsFile()\n */\nexport enum DtsRollupKind {\n  /**\n   * Generate a *.d.ts file for an internal release, or for the trimming=false mode.\n   * This output file will contain all definitions that are reachable from the entry point.\n   */\n  InternalRelease,\n\n  /**\n   * Generate a *.d.ts file for a preview release.\n   * This output file will contain all definitions that are reachable from the entry point,\n   * except definitions marked as \\@internal.\n   */\n  AlphaRelease,\n\n  /**\n   * Generate a *.d.ts file for a preview release.\n   * This output file will contain all definitions that are reachable from the entry point,\n   * except definitions marked as \\@alpha or \\@internal.\n   */\n  BetaRelease,\n\n  /**\n   * Generate a *.d.ts file for a public release.\n   * This output file will contain all definitions that are reachable from the entry point,\n   * except definitions marked as \\@beta, \\@alpha, or \\@internal.\n   */\n  PublicRelease\n}\n\nexport class DtsRollupGenerator {\n  /**\n   * Generates the typings file and writes it to disk.\n   *\n   * @param dtsFilename    - The *.d.ts output filename\n   */\n  public static writeTypingsFile(\n    collector: Collector,\n    dtsFilename: string,\n    dtsKind: DtsRollupKind,\n    newlineKind: NewlineKind\n  ): void {\n    const writer: IndentedWriter = new IndentedWriter();\n    writer.trimLeadingSpaces = true;\n\n    DtsRollupGenerator._generateTypingsFileContent(collector, writer, dtsKind);\n\n    FileSystem.writeFile(dtsFilename, writer.toString(), {\n      convertLineEndings: newlineKind,\n      ensureFolderExists: true\n    });\n  }\n\n  private static _generateTypingsFileContent(\n    collector: Collector,\n    writer: IndentedWriter,\n    dtsKind: DtsRollupKind\n  ): void {\n    // Emit the @packageDocumentation comment at the top of the file\n    if (collector.workingPackage.tsdocParserContext) {\n      writer.trimLeadingSpaces = false;\n      writer.writeLine(collector.workingPackage.tsdocParserContext.sourceRange.toString());\n      writer.trimLeadingSpaces = true;\n      writer.ensureSkippedLine();\n    }\n\n    // Emit the triple slash directives\n    for (const typeDirectiveReference of collector.dtsTypeReferenceDirectives) {\n      // https://github.com/microsoft/TypeScript/blob/611ebc7aadd7a44a4c0447698bfda9222a78cb66/src/compiler/declarationEmitter.ts#L162\n      writer.writeLine(`/// <reference types=\"${typeDirectiveReference}\" />`);\n    }\n    for (const libDirectiveReference of collector.dtsLibReferenceDirectives) {\n      writer.writeLine(`/// <reference lib=\"${libDirectiveReference}\" />`);\n    }\n    writer.ensureSkippedLine();\n\n    // Emit the imports\n    for (const entity of collector.entities) {\n      if (entity.astEntity instanceof AstImport) {\n        const astImport: AstImport = entity.astEntity;\n\n        // For example, if the imported API comes from an external package that supports AEDoc,\n        // and it was marked as `@internal`, then don't emit it.\n        const symbolMetadata: SymbolMetadata | undefined = collector.tryFetchMetadataForAstEntity(astImport);\n        const maxEffectiveReleaseTag: ReleaseTag = symbolMetadata\n          ? symbolMetadata.maxEffectiveReleaseTag\n          : ReleaseTag.None;\n\n        if (this._shouldIncludeReleaseTag(maxEffectiveReleaseTag, dtsKind)) {\n          DtsEmitHelpers.emitImport(writer, entity, astImport);\n        }\n      }\n    }\n    writer.ensureSkippedLine();\n\n    // Emit the regular declarations\n    for (const entity of collector.entities) {\n      const astEntity: AstEntity = entity.astEntity;\n      const symbolMetadata: SymbolMetadata | undefined = collector.tryFetchMetadataForAstEntity(astEntity);\n      const maxEffectiveReleaseTag: ReleaseTag = symbolMetadata\n        ? symbolMetadata.maxEffectiveReleaseTag\n        : ReleaseTag.None;\n\n      if (!this._shouldIncludeReleaseTag(maxEffectiveReleaseTag, dtsKind)) {\n        if (!collector.extractorConfig.omitTrimmingComments) {\n          writer.ensureSkippedLine();\n          writer.writeLine(`/* Excluded from this release type: ${entity.nameForEmit} */`);\n        }\n        continue;\n      }\n\n      if (astEntity instanceof AstSymbol) {\n        // Emit all the declarations for this entry\n        for (const astDeclaration of astEntity.astDeclarations || []) {\n          const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\n\n          if (!this._shouldIncludeReleaseTag(apiItemMetadata.effectiveReleaseTag, dtsKind)) {\n            if (!collector.extractorConfig.omitTrimmingComments) {\n              writer.ensureSkippedLine();\n              writer.writeLine(`/* Excluded declaration from this release type: ${entity.nameForEmit} */`);\n            }\n            continue;\n          } else {\n            const span: Span = new Span(astDeclaration.declaration);\n            DtsRollupGenerator._modifySpan(collector, span, entity, astDeclaration, dtsKind);\n            writer.ensureSkippedLine();\n            span.writeModifiedText(writer);\n            writer.ensureNewLine();\n          }\n        }\n      }\n\n      if (astEntity instanceof AstNamespaceImport) {\n        const astModuleExportInfo: AstModuleExportInfo = astEntity.fetchAstModuleExportInfo(collector);\n\n        if (entity.nameForEmit === undefined) {\n          // This should never happen\n          throw new InternalError('referencedEntry.nameForEmit is undefined');\n        }\n\n        if (astModuleExportInfo.starExportedExternalModules.size > 0) {\n          // We could support this, but we would need to find a way to safely represent it.\n          throw new Error(\n            `The ${entity.nameForEmit} namespace import includes a start export, which is not supported:\\n` +\n              SourceFileLocationFormatter.formatDeclaration(astEntity.declaration)\n          );\n        }\n\n        // Emit a synthetic declaration for the namespace.  It will look like this:\n        //\n        //    declare namespace example {\n        //      export {\n        //        f1,\n        //        f2\n        //      }\n        //    }\n        //\n        // Note that we do not try to relocate f1()/f2() to be inside the namespace because other type\n        // signatures may reference them directly (without using the namespace qualifier).\n\n        writer.ensureSkippedLine();\n        if (entity.shouldInlineExport) {\n          writer.write('export ');\n        }\n        writer.writeLine(`declare namespace ${entity.nameForEmit} {`);\n\n        // all local exports of local imported module are just references to top-level declarations\n        writer.increaseIndent();\n        writer.writeLine('export {');\n        writer.increaseIndent();\n\n        const exportClauses: string[] = [];\n        for (const [exportedName, exportedEntity] of astModuleExportInfo.exportedLocalEntities) {\n          const collectorEntity: CollectorEntity | undefined =\n            collector.tryGetCollectorEntity(exportedEntity);\n          if (collectorEntity === undefined) {\n            // This should never happen\n            // top-level exports of local imported module should be added as collector entities before\n            throw new InternalError(\n              `Cannot find collector entity for ${entity.nameForEmit}.${exportedEntity.localName}`\n            );\n          }\n\n          if (collectorEntity.nameForEmit === exportedName) {\n            exportClauses.push(collectorEntity.nameForEmit);\n          } else {\n            exportClauses.push(`${collectorEntity.nameForEmit} as ${exportedName}`);\n          }\n        }\n        writer.writeLine(exportClauses.join(',\\n'));\n\n        writer.decreaseIndent();\n        writer.writeLine('}'); // end of \"export { ... }\"\n        writer.decreaseIndent();\n        writer.writeLine('}'); // end of \"declare namespace { ... }\"\n      }\n\n      if (!entity.shouldInlineExport) {\n        for (const exportName of entity.exportNames) {\n          DtsEmitHelpers.emitNamedExport(writer, exportName, entity);\n        }\n      }\n\n      writer.ensureSkippedLine();\n    }\n\n    DtsEmitHelpers.emitStarExports(writer, collector);\n\n    // Emit \"export { }\" which is a special directive that prevents consumers from importing declarations\n    // that don't have an explicit \"export\" modifier.\n    writer.ensureSkippedLine();\n    writer.writeLine('export { }');\n  }\n\n  /**\n   * Before writing out a declaration, _modifySpan() applies various fixups to make it nice.\n   */\n  private static _modifySpan(\n    collector: Collector,\n    span: Span,\n    entity: CollectorEntity,\n    astDeclaration: AstDeclaration,\n    dtsKind: DtsRollupKind\n  ): void {\n    const previousSpan: Span | undefined = span.previousSibling;\n\n    let recurseChildren: boolean = true;\n    switch (span.kind) {\n      case ts.SyntaxKind.JSDocComment:\n        // If the @packageDocumentation comment seems to be attached to one of the regular API items,\n        // omit it.  It gets explictly emitted at the top of the file.\n        if (span.node.getText().match(/(?:\\s|\\*)@packageDocumentation(?:\\s|\\*)/gi)) {\n          span.modification.skipAll();\n        }\n\n        // For now, we don't transform JSDoc comment nodes at all\n        recurseChildren = false;\n        break;\n\n      case ts.SyntaxKind.ExportKeyword:\n      case ts.SyntaxKind.DefaultKeyword:\n      case ts.SyntaxKind.DeclareKeyword:\n        // Delete any explicit \"export\" or \"declare\" keywords -- we will re-add them below\n        span.modification.skipAll();\n        break;\n\n      case ts.SyntaxKind.InterfaceKeyword:\n      case ts.SyntaxKind.ClassKeyword:\n      case ts.SyntaxKind.EnumKeyword:\n      case ts.SyntaxKind.NamespaceKeyword:\n      case ts.SyntaxKind.ModuleKeyword:\n      case ts.SyntaxKind.TypeKeyword:\n      case ts.SyntaxKind.FunctionKeyword:\n        // Replace the stuff we possibly deleted above\n        let replacedModifiers: string = '';\n\n        // Add a declare statement for root declarations (but not for nested declarations)\n        if (!astDeclaration.parent) {\n          replacedModifiers += 'declare ';\n        }\n\n        if (entity.shouldInlineExport) {\n          replacedModifiers = 'export ' + replacedModifiers;\n        }\n\n        if (previousSpan && previousSpan.kind === ts.SyntaxKind.SyntaxList) {\n          // If there is a previous span of type SyntaxList, then apply it before any other modifiers\n          // (e.g. \"abstract\") that appear there.\n          previousSpan.modification.prefix = replacedModifiers + previousSpan.modification.prefix;\n        } else {\n          // Otherwise just stick it in front of this span\n          span.modification.prefix = replacedModifiers + span.modification.prefix;\n        }\n        break;\n\n      case ts.SyntaxKind.VariableDeclaration:\n        // Is this a top-level variable declaration?\n        // (The logic below does not apply to variable declarations that are part of an explicit \"namespace\" block,\n        // since the compiler prefers not to emit \"declare\" or \"export\" keywords for those declarations.)\n        if (!span.parent) {\n          // The VariableDeclaration node is part of a VariableDeclarationList, however\n          // the Entry.followedSymbol points to the VariableDeclaration part because\n          // multiple definitions might share the same VariableDeclarationList.\n          //\n          // Since we are emitting a separate declaration for each one, we need to look upwards\n          // in the ts.Node tree and write a copy of the enclosing VariableDeclarationList\n          // content (e.g. \"var\" from \"var x=1, y=2\").\n          const list: ts.VariableDeclarationList | undefined = TypeScriptHelpers.matchAncestor(span.node, [\n            ts.SyntaxKind.VariableDeclarationList,\n            ts.SyntaxKind.VariableDeclaration\n          ]);\n          if (!list) {\n            // This should not happen unless the compiler API changes somehow\n            throw new InternalError('Unsupported variable declaration');\n          }\n          const listPrefix: string = list\n            .getSourceFile()\n            .text.substring(list.getStart(), list.declarations[0].getStart());\n          span.modification.prefix = 'declare ' + listPrefix + span.modification.prefix;\n          span.modification.suffix = ';';\n\n          if (entity.shouldInlineExport) {\n            span.modification.prefix = 'export ' + span.modification.prefix;\n          }\n\n          const declarationMetadata: DeclarationMetadata = collector.fetchDeclarationMetadata(astDeclaration);\n          if (declarationMetadata.tsdocParserContext) {\n            // Typically the comment for a variable declaration is attached to the outer variable statement\n            // (which may possibly contain multiple variable declarations), so it's not part of the Span.\n            // Instead we need to manually inject it.\n            let originalComment: string = declarationMetadata.tsdocParserContext.sourceRange.toString();\n            if (!/\\r?\\n\\s*$/.test(originalComment)) {\n              originalComment += '\\n';\n            }\n            span.modification.indentDocComment = IndentDocCommentScope.PrefixOnly;\n            span.modification.prefix = originalComment + span.modification.prefix;\n          }\n        }\n        break;\n\n      case ts.SyntaxKind.Identifier:\n        {\n          const referencedEntity: CollectorEntity | undefined = collector.tryGetEntityForNode(\n            span.node as ts.Identifier\n          );\n\n          if (referencedEntity) {\n            if (!referencedEntity.nameForEmit) {\n              // This should never happen\n              throw new InternalError('referencedEntry.nameForEmit is undefined');\n            }\n\n            span.modification.prefix = referencedEntity.nameForEmit;\n            // For debugging:\n            // span.modification.prefix += '/*R=FIX*/';\n          } else {\n            // For debugging:\n            // span.modification.prefix += '/*R=KEEP*/';\n          }\n        }\n        break;\n\n      case ts.SyntaxKind.ImportType:\n        DtsEmitHelpers.modifyImportTypeSpan(\n          collector,\n          span,\n          astDeclaration,\n          (childSpan, childAstDeclaration) => {\n            DtsRollupGenerator._modifySpan(collector, childSpan, entity, childAstDeclaration, dtsKind);\n          }\n        );\n        break;\n    }\n\n    if (recurseChildren) {\n      for (const child of span.children) {\n        let childAstDeclaration: AstDeclaration = astDeclaration;\n\n        // Should we trim this node?\n        let trimmed: boolean = false;\n        if (AstDeclaration.isSupportedSyntaxKind(child.kind)) {\n          childAstDeclaration = collector.astSymbolTable.getChildAstDeclarationByNode(\n            child.node,\n            astDeclaration\n          );\n          const releaseTag: ReleaseTag =\n            collector.fetchApiItemMetadata(childAstDeclaration).effectiveReleaseTag;\n\n          if (!this._shouldIncludeReleaseTag(releaseTag, dtsKind)) {\n            let nodeToTrim: Span = child;\n\n            // If we are trimming a variable statement, then we need to trim the outer VariableDeclarationList\n            // as well.\n            if (child.kind === ts.SyntaxKind.VariableDeclaration) {\n              const variableStatement: Span | undefined = child.findFirstParent(\n                ts.SyntaxKind.VariableStatement\n              );\n              if (variableStatement !== undefined) {\n                nodeToTrim = variableStatement;\n              }\n            }\n\n            const modification: SpanModification = nodeToTrim.modification;\n\n            // Yes, trim it and stop here\n            const name: string = childAstDeclaration.astSymbol.localName;\n            modification.omitChildren = true;\n\n            if (!collector.extractorConfig.omitTrimmingComments) {\n              modification.prefix = `/* Excluded from this release type: ${name} */`;\n            } else {\n              modification.prefix = '';\n            }\n            modification.suffix = '';\n\n            if (nodeToTrim.children.length > 0) {\n              // If there are grandchildren, then keep the last grandchild's separator,\n              // since it often has useful whitespace\n              modification.suffix = nodeToTrim.children[nodeToTrim.children.length - 1].separator;\n            }\n\n            if (nodeToTrim.nextSibling) {\n              // If the thing we are trimming is followed by a comma, then trim the comma also.\n              // An example would be an enum member.\n              if (nodeToTrim.nextSibling.kind === ts.SyntaxKind.CommaToken) {\n                // Keep its separator since it often has useful whitespace\n                modification.suffix += nodeToTrim.nextSibling.separator;\n                nodeToTrim.nextSibling.modification.skipAll();\n              }\n            }\n\n            trimmed = true;\n          }\n        }\n\n        if (!trimmed) {\n          DtsRollupGenerator._modifySpan(collector, child, entity, childAstDeclaration, dtsKind);\n        }\n      }\n    }\n  }\n\n  private static _shouldIncludeReleaseTag(releaseTag: ReleaseTag, dtsKind: DtsRollupKind): boolean {\n    switch (dtsKind) {\n      case DtsRollupKind.InternalRelease:\n        return true;\n      case DtsRollupKind.AlphaRelease:\n        return (\n          releaseTag === ReleaseTag.Alpha ||\n          releaseTag === ReleaseTag.Beta ||\n          releaseTag === ReleaseTag.Public ||\n          // NOTE: If the release tag is \"None\", then we don't have enough information to trim it\n          releaseTag === ReleaseTag.None\n        );\n      case DtsRollupKind.BetaRelease:\n        return (\n          releaseTag === ReleaseTag.Beta ||\n          releaseTag === ReleaseTag.Public ||\n          // NOTE: If the release tag is \"None\", then we don't have enough information to trim it\n          releaseTag === ReleaseTag.None\n        );\n      case DtsRollupKind.PublicRelease:\n        return releaseTag === ReleaseTag.Public || releaseTag === ReleaseTag.None;\n      default:\n        throw new Error(`${DtsRollupKind[dtsKind]} is not implemented`);\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"DtsRollupGenerator.js","sourceRoot":"","sources":["../../src/generators/DtsRollupGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* eslint-disable no-bitwise */\r\n\r\nimport * as ts from 'typescript';\r\nimport { FileSystem, type NewlineKind, InternalError } from '@rushstack/node-core-library';\r\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\r\n\r\nimport type { Collector } from '../collector/Collector';\r\nimport { TypeScriptHelpers } from '../analyzer/TypeScriptHelpers';\r\nimport { IndentDocCommentScope, Span, type SpanModification } from '../analyzer/Span';\r\nimport { AstImport } from '../analyzer/AstImport';\r\nimport type { CollectorEntity } from '../collector/CollectorEntity';\r\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\r\nimport type { ApiItemMetadata } from '../collector/ApiItemMetadata';\r\nimport { AstSymbol } from '../analyzer/AstSymbol';\r\nimport type { SymbolMetadata } from '../collector/SymbolMetadata';\r\nimport { IndentedWriter } from './IndentedWriter';\r\nimport { DtsEmitHelpers } from './DtsEmitHelpers';\r\nimport type { DeclarationMetadata } from '../collector/DeclarationMetadata';\r\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\r\nimport type { AstModuleExportInfo } from '../analyzer/AstModule';\r\nimport { SourceFileLocationFormatter } from '../analyzer/SourceFileLocationFormatter';\r\nimport type { AstEntity } from '../analyzer/AstEntity';\r\n\r\n/**\r\n * Used with DtsRollupGenerator.writeTypingsFile()\r\n */\r\nexport enum DtsRollupKind {\r\n  /**\r\n   * Generate a *.d.ts file for an internal release, or for the trimming=false mode.\r\n   * This output file will contain all definitions that are reachable from the entry point.\r\n   */\r\n  InternalRelease,\r\n\r\n  /**\r\n   * Generate a *.d.ts file for a preview release.\r\n   * This output file will contain all definitions that are reachable from the entry point,\r\n   * except definitions marked as \\@internal.\r\n   */\r\n  AlphaRelease,\r\n\r\n  /**\r\n   * Generate a *.d.ts file for a preview release.\r\n   * This output file will contain all definitions that are reachable from the entry point,\r\n   * except definitions marked as \\@alpha or \\@internal.\r\n   */\r\n  BetaRelease,\r\n\r\n  /**\r\n   * Generate a *.d.ts file for a public release.\r\n   * This output file will contain all definitions that are reachable from the entry point,\r\n   * except definitions marked as \\@beta, \\@alpha, or \\@internal.\r\n   */\r\n  PublicRelease\r\n}\r\n\r\nexport class DtsRollupGenerator {\r\n  /**\r\n   * Generates the typings file and writes it to disk.\r\n   *\r\n   * @param dtsFilename    - The *.d.ts output filename\r\n   */\r\n  public static writeTypingsFile(\r\n    collector: Collector,\r\n    dtsFilename: string,\r\n    dtsKind: DtsRollupKind,\r\n    newlineKind: NewlineKind\r\n  ): void {\r\n    const writer: IndentedWriter = new IndentedWriter();\r\n    writer.trimLeadingSpaces = true;\r\n\r\n    DtsRollupGenerator._generateTypingsFileContent(collector, writer, dtsKind);\r\n\r\n    FileSystem.writeFile(dtsFilename, writer.toString(), {\r\n      convertLineEndings: newlineKind,\r\n      ensureFolderExists: true\r\n    });\r\n  }\r\n\r\n  private static _generateTypingsFileContent(\r\n    collector: Collector,\r\n    writer: IndentedWriter,\r\n    dtsKind: DtsRollupKind\r\n  ): void {\r\n    // Emit the @packageDocumentation comment at the top of the file\r\n    if (collector.workingPackage.tsdocParserContext) {\r\n      writer.trimLeadingSpaces = false;\r\n      writer.writeLine(collector.workingPackage.tsdocParserContext.sourceRange.toString());\r\n      writer.trimLeadingSpaces = true;\r\n      writer.ensureSkippedLine();\r\n    }\r\n\r\n    // Emit the triple slash directives\r\n    for (const typeDirectiveReference of collector.dtsTypeReferenceDirectives) {\r\n      // https://github.com/microsoft/TypeScript/blob/611ebc7aadd7a44a4c0447698bfda9222a78cb66/src/compiler/declarationEmitter.ts#L162\r\n      writer.writeLine(`/// <reference types=\"${typeDirectiveReference}\" />`);\r\n    }\r\n    for (const libDirectiveReference of collector.dtsLibReferenceDirectives) {\r\n      writer.writeLine(`/// <reference lib=\"${libDirectiveReference}\" />`);\r\n    }\r\n    writer.ensureSkippedLine();\r\n\r\n    // Emit the imports\r\n    for (const entity of collector.entities) {\r\n      if (entity.astEntity instanceof AstImport) {\r\n        const astImport: AstImport = entity.astEntity;\r\n\r\n        // For example, if the imported API comes from an external package that supports AEDoc,\r\n        // and it was marked as `@internal`, then don't emit it.\r\n        const symbolMetadata: SymbolMetadata | undefined = collector.tryFetchMetadataForAstEntity(astImport);\r\n        const maxEffectiveReleaseTag: ReleaseTag = symbolMetadata\r\n          ? symbolMetadata.maxEffectiveReleaseTag\r\n          : ReleaseTag.None;\r\n\r\n        if (this._shouldIncludeReleaseTag(maxEffectiveReleaseTag, dtsKind)) {\r\n          DtsEmitHelpers.emitImport(writer, entity, astImport);\r\n        }\r\n      }\r\n    }\r\n    writer.ensureSkippedLine();\r\n\r\n    // Emit the regular declarations\r\n    for (const entity of collector.entities) {\r\n      const astEntity: AstEntity = entity.astEntity;\r\n      const symbolMetadata: SymbolMetadata | undefined = collector.tryFetchMetadataForAstEntity(astEntity);\r\n      const maxEffectiveReleaseTag: ReleaseTag = symbolMetadata\r\n        ? symbolMetadata.maxEffectiveReleaseTag\r\n        : ReleaseTag.None;\r\n\r\n      if (!this._shouldIncludeReleaseTag(maxEffectiveReleaseTag, dtsKind)) {\r\n        if (!collector.extractorConfig.omitTrimmingComments) {\r\n          writer.ensureSkippedLine();\r\n          writer.writeLine(`/* Excluded from this release type: ${entity.nameForEmit} */`);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      if (astEntity instanceof AstSymbol) {\r\n        // Emit all the declarations for this entry\r\n        for (const astDeclaration of astEntity.astDeclarations || []) {\r\n          const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\r\n\r\n          if (!this._shouldIncludeReleaseTag(apiItemMetadata.effectiveReleaseTag, dtsKind)) {\r\n            if (!collector.extractorConfig.omitTrimmingComments) {\r\n              writer.ensureSkippedLine();\r\n              writer.writeLine(`/* Excluded declaration from this release type: ${entity.nameForEmit} */`);\r\n            }\r\n            continue;\r\n          } else {\r\n            const span: Span = new Span(astDeclaration.declaration);\r\n            DtsRollupGenerator._modifySpan(collector, span, entity, astDeclaration, dtsKind);\r\n            writer.ensureSkippedLine();\r\n            span.writeModifiedText(writer);\r\n            writer.ensureNewLine();\r\n          }\r\n        }\r\n      }\r\n\r\n      if (astEntity instanceof AstNamespaceImport) {\r\n        const astModuleExportInfo: AstModuleExportInfo = astEntity.fetchAstModuleExportInfo(collector);\r\n\r\n        if (entity.nameForEmit === undefined) {\r\n          // This should never happen\r\n          throw new InternalError('referencedEntry.nameForEmit is undefined');\r\n        }\r\n\r\n        if (astModuleExportInfo.starExportedExternalModules.size > 0) {\r\n          // We could support this, but we would need to find a way to safely represent it.\r\n          throw new Error(\r\n            `The ${entity.nameForEmit} namespace import includes a start export, which is not supported:\\n` +\r\n              SourceFileLocationFormatter.formatDeclaration(astEntity.declaration)\r\n          );\r\n        }\r\n\r\n        // Emit a synthetic declaration for the namespace.  It will look like this:\r\n        //\r\n        //    declare namespace example {\r\n        //      export {\r\n        //        f1,\r\n        //        f2\r\n        //      }\r\n        //    }\r\n        //\r\n        // Note that we do not try to relocate f1()/f2() to be inside the namespace because other type\r\n        // signatures may reference them directly (without using the namespace qualifier).\r\n\r\n        writer.ensureSkippedLine();\r\n        if (entity.shouldInlineExport) {\r\n          writer.write('export ');\r\n        }\r\n        writer.writeLine(`declare namespace ${entity.nameForEmit} {`);\r\n\r\n        // all local exports of local imported module are just references to top-level declarations\r\n        writer.increaseIndent();\r\n        writer.writeLine('export {');\r\n        writer.increaseIndent();\r\n\r\n        const exportClauses: string[] = [];\r\n        for (const [exportedName, exportedEntity] of astModuleExportInfo.exportedLocalEntities) {\r\n          const collectorEntity: CollectorEntity | undefined =\r\n            collector.tryGetCollectorEntity(exportedEntity);\r\n          if (collectorEntity === undefined) {\r\n            // This should never happen\r\n            // top-level exports of local imported module should be added as collector entities before\r\n            throw new InternalError(\r\n              `Cannot find collector entity for ${entity.nameForEmit}.${exportedEntity.localName}`\r\n            );\r\n          }\r\n\r\n          if (collectorEntity.nameForEmit === exportedName) {\r\n            exportClauses.push(collectorEntity.nameForEmit);\r\n          } else {\r\n            exportClauses.push(`${collectorEntity.nameForEmit} as ${exportedName}`);\r\n          }\r\n        }\r\n        writer.writeLine(exportClauses.join(',\\n'));\r\n\r\n        writer.decreaseIndent();\r\n        writer.writeLine('}'); // end of \"export { ... }\"\r\n        writer.decreaseIndent();\r\n        writer.writeLine('}'); // end of \"declare namespace { ... }\"\r\n      }\r\n\r\n      if (!entity.shouldInlineExport) {\r\n        for (const exportName of entity.exportNames) {\r\n          DtsEmitHelpers.emitNamedExport(writer, exportName, entity);\r\n        }\r\n      }\r\n\r\n      writer.ensureSkippedLine();\r\n    }\r\n\r\n    DtsEmitHelpers.emitStarExports(writer, collector);\r\n\r\n    // Emit \"export { }\" which is a special directive that prevents consumers from importing declarations\r\n    // that don't have an explicit \"export\" modifier.\r\n    writer.ensureSkippedLine();\r\n    writer.writeLine('export { }');\r\n  }\r\n\r\n  /**\r\n   * Before writing out a declaration, _modifySpan() applies various fixups to make it nice.\r\n   */\r\n  private static _modifySpan(\r\n    collector: Collector,\r\n    span: Span,\r\n    entity: CollectorEntity,\r\n    astDeclaration: AstDeclaration,\r\n    dtsKind: DtsRollupKind\r\n  ): void {\r\n    const previousSpan: Span | undefined = span.previousSibling;\r\n\r\n    let recurseChildren: boolean = true;\r\n    switch (span.kind) {\r\n      case ts.SyntaxKind.JSDocComment:\r\n        // If the @packageDocumentation comment seems to be attached to one of the regular API items,\r\n        // omit it.  It gets explictly emitted at the top of the file.\r\n        if (span.node.getText().match(/(?:\\s|\\*)@packageDocumentation(?:\\s|\\*)/gi)) {\r\n          span.modification.skipAll();\r\n        }\r\n\r\n        // For now, we don't transform JSDoc comment nodes at all\r\n        recurseChildren = false;\r\n        break;\r\n\r\n      case ts.SyntaxKind.ExportKeyword:\r\n      case ts.SyntaxKind.DefaultKeyword:\r\n      case ts.SyntaxKind.DeclareKeyword:\r\n        // Delete any explicit \"export\" or \"declare\" keywords -- we will re-add them below\r\n        span.modification.skipAll();\r\n        break;\r\n\r\n      case ts.SyntaxKind.InterfaceKeyword:\r\n      case ts.SyntaxKind.ClassKeyword:\r\n      case ts.SyntaxKind.EnumKeyword:\r\n      case ts.SyntaxKind.NamespaceKeyword:\r\n      case ts.SyntaxKind.ModuleKeyword:\r\n      case ts.SyntaxKind.TypeKeyword:\r\n      case ts.SyntaxKind.FunctionKeyword:\r\n        // Replace the stuff we possibly deleted above\r\n        let replacedModifiers: string = '';\r\n\r\n        // Add a declare statement for root declarations (but not for nested declarations)\r\n        if (!astDeclaration.parent) {\r\n          replacedModifiers += 'declare ';\r\n        }\r\n\r\n        if (entity.shouldInlineExport) {\r\n          replacedModifiers = 'export ' + replacedModifiers;\r\n        }\r\n\r\n        if (previousSpan && previousSpan.kind === ts.SyntaxKind.SyntaxList) {\r\n          // If there is a previous span of type SyntaxList, then apply it before any other modifiers\r\n          // (e.g. \"abstract\") that appear there.\r\n          previousSpan.modification.prefix = replacedModifiers + previousSpan.modification.prefix;\r\n        } else {\r\n          // Otherwise just stick it in front of this span\r\n          span.modification.prefix = replacedModifiers + span.modification.prefix;\r\n        }\r\n        break;\r\n\r\n      case ts.SyntaxKind.VariableDeclaration:\r\n        // Is this a top-level variable declaration?\r\n        // (The logic below does not apply to variable declarations that are part of an explicit \"namespace\" block,\r\n        // since the compiler prefers not to emit \"declare\" or \"export\" keywords for those declarations.)\r\n        if (!span.parent) {\r\n          // The VariableDeclaration node is part of a VariableDeclarationList, however\r\n          // the Entry.followedSymbol points to the VariableDeclaration part because\r\n          // multiple definitions might share the same VariableDeclarationList.\r\n          //\r\n          // Since we are emitting a separate declaration for each one, we need to look upwards\r\n          // in the ts.Node tree and write a copy of the enclosing VariableDeclarationList\r\n          // content (e.g. \"var\" from \"var x=1, y=2\").\r\n          const list: ts.VariableDeclarationList | undefined = TypeScriptHelpers.matchAncestor(span.node, [\r\n            ts.SyntaxKind.VariableDeclarationList,\r\n            ts.SyntaxKind.VariableDeclaration\r\n          ]);\r\n          if (!list) {\r\n            // This should not happen unless the compiler API changes somehow\r\n            throw new InternalError('Unsupported variable declaration');\r\n          }\r\n          const listPrefix: string = list\r\n            .getSourceFile()\r\n            .text.substring(list.getStart(), list.declarations[0].getStart());\r\n          span.modification.prefix = 'declare ' + listPrefix + span.modification.prefix;\r\n          span.modification.suffix = ';';\r\n\r\n          if (entity.shouldInlineExport) {\r\n            span.modification.prefix = 'export ' + span.modification.prefix;\r\n          }\r\n\r\n          const declarationMetadata: DeclarationMetadata = collector.fetchDeclarationMetadata(astDeclaration);\r\n          if (declarationMetadata.tsdocParserContext) {\r\n            // Typically the comment for a variable declaration is attached to the outer variable statement\r\n            // (which may possibly contain multiple variable declarations), so it's not part of the Span.\r\n            // Instead we need to manually inject it.\r\n            let originalComment: string = declarationMetadata.tsdocParserContext.sourceRange.toString();\r\n            if (!/\\r?\\n\\s*$/.test(originalComment)) {\r\n              originalComment += '\\n';\r\n            }\r\n            span.modification.indentDocComment = IndentDocCommentScope.PrefixOnly;\r\n            span.modification.prefix = originalComment + span.modification.prefix;\r\n          }\r\n        }\r\n        break;\r\n\r\n      case ts.SyntaxKind.Identifier:\r\n        {\r\n          const referencedEntity: CollectorEntity | undefined = collector.tryGetEntityForNode(\r\n            span.node as ts.Identifier\r\n          );\r\n\r\n          if (referencedEntity) {\r\n            if (!referencedEntity.nameForEmit) {\r\n              // This should never happen\r\n              throw new InternalError('referencedEntry.nameForEmit is undefined');\r\n            }\r\n\r\n            span.modification.prefix = referencedEntity.nameForEmit;\r\n            // For debugging:\r\n            // span.modification.prefix += '/*R=FIX*/';\r\n          } else {\r\n            // For debugging:\r\n            // span.modification.prefix += '/*R=KEEP*/';\r\n          }\r\n        }\r\n        break;\r\n\r\n      case ts.SyntaxKind.ImportType:\r\n        DtsEmitHelpers.modifyImportTypeSpan(\r\n          collector,\r\n          span,\r\n          astDeclaration,\r\n          (childSpan, childAstDeclaration) => {\r\n            DtsRollupGenerator._modifySpan(collector, childSpan, entity, childAstDeclaration, dtsKind);\r\n          }\r\n        );\r\n        break;\r\n    }\r\n\r\n    if (recurseChildren) {\r\n      for (const child of span.children) {\r\n        let childAstDeclaration: AstDeclaration = astDeclaration;\r\n\r\n        // Should we trim this node?\r\n        let trimmed: boolean = false;\r\n        if (AstDeclaration.isSupportedSyntaxKind(child.kind)) {\r\n          childAstDeclaration = collector.astSymbolTable.getChildAstDeclarationByNode(\r\n            child.node,\r\n            astDeclaration\r\n          );\r\n          const releaseTag: ReleaseTag =\r\n            collector.fetchApiItemMetadata(childAstDeclaration).effectiveReleaseTag;\r\n\r\n          if (!this._shouldIncludeReleaseTag(releaseTag, dtsKind)) {\r\n            let nodeToTrim: Span = child;\r\n\r\n            // If we are trimming a variable statement, then we need to trim the outer VariableDeclarationList\r\n            // as well.\r\n            if (child.kind === ts.SyntaxKind.VariableDeclaration) {\r\n              const variableStatement: Span | undefined = child.findFirstParent(\r\n                ts.SyntaxKind.VariableStatement\r\n              );\r\n              if (variableStatement !== undefined) {\r\n                nodeToTrim = variableStatement;\r\n              }\r\n            }\r\n\r\n            const modification: SpanModification = nodeToTrim.modification;\r\n\r\n            // Yes, trim it and stop here\r\n            const name: string = childAstDeclaration.astSymbol.localName;\r\n            modification.omitChildren = true;\r\n\r\n            if (!collector.extractorConfig.omitTrimmingComments) {\r\n              modification.prefix = `/* Excluded from this release type: ${name} */`;\r\n            } else {\r\n              modification.prefix = '';\r\n            }\r\n            modification.suffix = '';\r\n\r\n            if (nodeToTrim.children.length > 0) {\r\n              // If there are grandchildren, then keep the last grandchild's separator,\r\n              // since it often has useful whitespace\r\n              modification.suffix = nodeToTrim.children[nodeToTrim.children.length - 1].separator;\r\n            }\r\n\r\n            if (nodeToTrim.nextSibling) {\r\n              // If the thing we are trimming is followed by a comma, then trim the comma also.\r\n              // An example would be an enum member.\r\n              if (nodeToTrim.nextSibling.kind === ts.SyntaxKind.CommaToken) {\r\n                // Keep its separator since it often has useful whitespace\r\n                modification.suffix += nodeToTrim.nextSibling.separator;\r\n                nodeToTrim.nextSibling.modification.skipAll();\r\n              }\r\n            }\r\n\r\n            trimmed = true;\r\n          }\r\n        }\r\n\r\n        if (!trimmed) {\r\n          DtsRollupGenerator._modifySpan(collector, child, entity, childAstDeclaration, dtsKind);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _shouldIncludeReleaseTag(releaseTag: ReleaseTag, dtsKind: DtsRollupKind): boolean {\r\n    switch (dtsKind) {\r\n      case DtsRollupKind.InternalRelease:\r\n        return true;\r\n      case DtsRollupKind.AlphaRelease:\r\n        return (\r\n          releaseTag === ReleaseTag.Alpha ||\r\n          releaseTag === ReleaseTag.Beta ||\r\n          releaseTag === ReleaseTag.Public ||\r\n          // NOTE: If the release tag is \"None\", then we don't have enough information to trim it\r\n          releaseTag === ReleaseTag.None\r\n        );\r\n      case DtsRollupKind.BetaRelease:\r\n        return (\r\n          releaseTag === ReleaseTag.Beta ||\r\n          releaseTag === ReleaseTag.Public ||\r\n          // NOTE: If the release tag is \"None\", then we don't have enough information to trim it\r\n          releaseTag === ReleaseTag.None\r\n        );\r\n      case DtsRollupKind.PublicRelease:\r\n        return releaseTag === ReleaseTag.Public || releaseTag === ReleaseTag.None;\r\n      default:\r\n        throw new Error(`${DtsRollupKind[dtsKind]} is not implemented`);\r\n    }\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/generators/ExcerptBuilder.js.map b/lib/generators/ExcerptBuilder.js.map
index e9f3791f2208bcc657650611d883223f9da1aafb..ebfc9bbad8041f3f951bdf13771d004feaf735af 100644
--- a/lib/generators/ExcerptBuilder.js.map
+++ b/lib/generators/ExcerptBuilder.js.map
@@ -1 +1 @@
-{"version":3,"file":"ExcerptBuilder.js","sourceRoot":"","sources":["../../src/generators/ExcerptBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\nimport type { DeclarationReference } from '@microsoft/tsdoc/lib-commonjs/beta/DeclarationReference';\nimport {\n  ExcerptTokenKind,\n  type IExcerptToken,\n  type IExcerptTokenRange\n} from '@microsoft/api-extractor-model';\n\nimport { Span } from '../analyzer/Span';\nimport type { DeclarationReferenceGenerator } from './DeclarationReferenceGenerator';\nimport type { AstDeclaration } from '../analyzer/AstDeclaration';\n\n/**\n * Used to provide ExcerptBuilder with a list of nodes whose token range we want to capture.\n */\nexport interface IExcerptBuilderNodeToCapture {\n  /**\n   * The node to capture\n   */\n  node: ts.Node | undefined;\n  /**\n   * The token range whose startIndex/endIndex will be overwritten with the indexes for the\n   * tokens corresponding to IExcerptBuilderNodeToCapture.node\n   */\n  tokenRange: IExcerptTokenRange;\n}\n\n/**\n * Internal state for ExcerptBuilder\n */\ninterface IBuildSpanState {\n  referenceGenerator: DeclarationReferenceGenerator;\n\n  /**\n   * The AST node that we will traverse to extract tokens\n   */\n  startingNode: ts.Node;\n\n  /**\n   * Normally, the excerpt will include all child nodes for `startingNode`; whereas if `childKindToStopBefore`\n   * is specified, then the node traversal will stop before (i.e. excluding) the first immediate child\n   * of `startingNode` with the specified syntax kind.\n   *\n   * @remarks\n   * For example, suppose the signature is `interface X: Y { z: string }`.  The token `{` has syntax kind\n   * `ts.SyntaxKind.FirstPunctuation`, so we can specify that to truncate the excerpt to `interface X: Y`.\n   */\n  stopBeforeChildKind: ts.SyntaxKind | undefined;\n\n  tokenRangesByNode: Map<ts.Node, IExcerptTokenRange>;\n\n  /**\n   * Tracks whether the last appended token was a separator. If so, and we're in the middle of\n   * capturing a token range, then omit the separator from the range.\n   */\n  lastAppendedTokenIsSeparator: boolean;\n}\n\nexport class ExcerptBuilder {\n  /**\n   * Appends a blank line to the `excerptTokens` list.\n   * @param excerptTokens - The target token list to append to\n   */\n  public static addBlankLine(excerptTokens: IExcerptToken[]): void {\n    let newlines: string = '\\n\\n';\n    // If the existing text already ended with a newline, then only append one newline\n    if (excerptTokens.length > 0) {\n      const previousText: string = excerptTokens[excerptTokens.length - 1].text;\n      if (/\\n$/.test(previousText)) {\n        newlines = '\\n';\n      }\n    }\n    excerptTokens.push({ kind: ExcerptTokenKind.Content, text: newlines });\n  }\n\n  /**\n   * Appends the signature for the specified `AstDeclaration` to the `excerptTokens` list.\n   * @param excerptTokens - The target token list to append to\n   * @param nodesToCapture - A list of child nodes whose token ranges we want to capture\n   */\n  public static addDeclaration(\n    excerptTokens: IExcerptToken[],\n    astDeclaration: AstDeclaration,\n    nodesToCapture: IExcerptBuilderNodeToCapture[],\n    referenceGenerator: DeclarationReferenceGenerator\n  ): void {\n    let stopBeforeChildKind: ts.SyntaxKind | undefined = undefined;\n\n    switch (astDeclaration.declaration.kind) {\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.EnumDeclaration:\n      case ts.SyntaxKind.InterfaceDeclaration:\n        // FirstPunctuation = \"{\"\n        stopBeforeChildKind = ts.SyntaxKind.FirstPunctuation;\n        break;\n      case ts.SyntaxKind.ModuleDeclaration:\n        // ModuleBlock = the \"{ ... }\" block\n        stopBeforeChildKind = ts.SyntaxKind.ModuleBlock;\n        break;\n    }\n\n    const span: Span = new Span(astDeclaration.declaration);\n\n    const tokenRangesByNode: Map<ts.Node, IExcerptTokenRange> = new Map<ts.Node, IExcerptTokenRange>();\n    for (const excerpt of nodesToCapture || []) {\n      if (excerpt.node) {\n        tokenRangesByNode.set(excerpt.node, excerpt.tokenRange);\n      }\n    }\n\n    ExcerptBuilder._buildSpan(excerptTokens, span, {\n      referenceGenerator: referenceGenerator,\n      startingNode: span.node,\n      stopBeforeChildKind,\n      tokenRangesByNode,\n      lastAppendedTokenIsSeparator: false\n    });\n    ExcerptBuilder._condenseTokens(excerptTokens, [...tokenRangesByNode.values()]);\n  }\n\n  public static createEmptyTokenRange(): IExcerptTokenRange {\n    return { startIndex: 0, endIndex: 0 };\n  }\n\n  private static _buildSpan(excerptTokens: IExcerptToken[], span: Span, state: IBuildSpanState): boolean {\n    if (span.kind === ts.SyntaxKind.JSDocComment) {\n      // Discard any comments\n      return true;\n    }\n\n    // Can this node start a excerpt?\n    const capturedTokenRange: IExcerptTokenRange | undefined = state.tokenRangesByNode.get(span.node);\n    let excerptStartIndex: number = 0;\n\n    if (capturedTokenRange) {\n      // We will assign capturedTokenRange.startIndex to be the index of the next token to be appended\n      excerptStartIndex = excerptTokens.length;\n    }\n\n    if (span.prefix) {\n      let canonicalReference: DeclarationReference | undefined = undefined;\n\n      if (span.kind === ts.SyntaxKind.Identifier) {\n        const name: ts.Identifier = span.node as ts.Identifier;\n        if (!ExcerptBuilder._isDeclarationName(name)) {\n          canonicalReference = state.referenceGenerator.getDeclarationReferenceForIdentifier(name);\n        }\n      }\n\n      if (canonicalReference) {\n        ExcerptBuilder._appendToken(\n          excerptTokens,\n          ExcerptTokenKind.Reference,\n          span.prefix,\n          canonicalReference\n        );\n      } else {\n        ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content, span.prefix);\n      }\n      state.lastAppendedTokenIsSeparator = false;\n    }\n\n    for (const child of span.children) {\n      if (span.node === state.startingNode) {\n        if (state.stopBeforeChildKind && child.kind === state.stopBeforeChildKind) {\n          // We reached a child whose kind is stopBeforeChildKind, so stop traversing\n          return false;\n        }\n      }\n\n      if (!this._buildSpan(excerptTokens, child, state)) {\n        return false;\n      }\n    }\n\n    if (span.suffix) {\n      ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content, span.suffix);\n      state.lastAppendedTokenIsSeparator = false;\n    }\n    if (span.separator) {\n      ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content, span.separator);\n      state.lastAppendedTokenIsSeparator = true;\n    }\n\n    // Are we building a excerpt?  If so, set its range\n    if (capturedTokenRange) {\n      capturedTokenRange.startIndex = excerptStartIndex;\n\n      // We will assign capturedTokenRange.startIndex to be the index after the last token\n      // that was appended so far. However, if the last appended token was a separator, omit\n      // it from the range.\n      let excerptEndIndex: number = excerptTokens.length;\n      if (state.lastAppendedTokenIsSeparator) {\n        excerptEndIndex--;\n      }\n\n      capturedTokenRange.endIndex = excerptEndIndex;\n    }\n\n    return true;\n  }\n\n  private static _appendToken(\n    excerptTokens: IExcerptToken[],\n    excerptTokenKind: ExcerptTokenKind,\n    text: string,\n    canonicalReference?: DeclarationReference\n  ): void {\n    if (text.length === 0) {\n      return;\n    }\n\n    const excerptToken: IExcerptToken = { kind: excerptTokenKind, text: text };\n    if (canonicalReference !== undefined) {\n      excerptToken.canonicalReference = canonicalReference.toString();\n    }\n    excerptTokens.push(excerptToken);\n  }\n\n  /**\n   * Condenses the provided excerpt tokens by merging tokens where possible. Updates the provided token ranges to\n   * remain accurate after token merging.\n   *\n   * @remarks\n   * For example, suppose we have excerpt tokens [\"A\", \"B\", \"C\"] and a token range [0, 2]. If the excerpt tokens\n   * are condensed to [\"AB\", \"C\"], then the token range would be updated to [0, 1]. Note that merges are only\n   * performed if they are compatible with the provided token ranges. In the example above, if our token range was\n   * originally [0, 1], we would not be able to merge tokens \"A\" and \"B\".\n   */\n  private static _condenseTokens(excerptTokens: IExcerptToken[], tokenRanges: IExcerptTokenRange[]): void {\n    // This set is used to quickly lookup a start or end index.\n    const startOrEndIndices: Set<number> = new Set();\n    for (const tokenRange of tokenRanges) {\n      startOrEndIndices.add(tokenRange.startIndex);\n      startOrEndIndices.add(tokenRange.endIndex);\n    }\n\n    for (let currentIndex: number = 1; currentIndex < excerptTokens.length; ++currentIndex) {\n      while (currentIndex < excerptTokens.length) {\n        const prevPrevToken: IExcerptToken = excerptTokens[currentIndex - 2]; // May be undefined\n        const prevToken: IExcerptToken = excerptTokens[currentIndex - 1];\n        const currentToken: IExcerptToken = excerptTokens[currentIndex];\n\n        // The number of excerpt tokens that are merged in this iteration. We need this to determine\n        // how to update the start and end indices of our token ranges.\n        let mergeCount: number;\n\n        // There are two types of merges that can occur. We only perform these merges if they are\n        // compatible with all of our token ranges.\n        if (\n          prevPrevToken &&\n          prevPrevToken.kind === ExcerptTokenKind.Reference &&\n          prevToken.kind === ExcerptTokenKind.Content &&\n          prevToken.text.trim() === '.' &&\n          currentToken.kind === ExcerptTokenKind.Reference &&\n          !startOrEndIndices.has(currentIndex) &&\n          !startOrEndIndices.has(currentIndex - 1)\n        ) {\n          // If the current token is a reference token, the previous token is a \".\", and the previous-\n          // previous token is a reference token, then merge all three tokens into a reference token.\n          //\n          // For example: Given [\"MyNamespace\" (R), \".\", \"MyClass\" (R)], tokens \".\" and \"MyClass\" might\n          // be merged into \"MyNamespace\". The condensed token would be [\"MyNamespace.MyClass\" (R)].\n          prevPrevToken.text += prevToken.text + currentToken.text;\n          prevPrevToken.canonicalReference = currentToken.canonicalReference;\n          mergeCount = 2;\n          currentIndex--;\n        } else if (\n          // If the current and previous tokens are both content tokens, then merge the tokens into a\n          // single content token. For example: Given [\"export \", \"declare class\"], these tokens\n          // might be merged into \"export declare class\".\n          prevToken.kind === ExcerptTokenKind.Content &&\n          prevToken.kind === currentToken.kind &&\n          !startOrEndIndices.has(currentIndex)\n        ) {\n          prevToken.text += currentToken.text;\n          mergeCount = 1;\n        } else {\n          // Otherwise, no merging can occur here. Continue to the next index.\n          break;\n        }\n\n        // Remove the now redundant excerpt token(s), as they were merged into a previous token.\n        excerptTokens.splice(currentIndex, mergeCount);\n\n        // Update the start and end indices for all token ranges based upon how many excerpt\n        // tokens were merged and in what positions.\n        for (const tokenRange of tokenRanges) {\n          if (tokenRange.startIndex > currentIndex) {\n            tokenRange.startIndex -= mergeCount;\n          }\n\n          if (tokenRange.endIndex > currentIndex) {\n            tokenRange.endIndex -= mergeCount;\n          }\n        }\n\n        // Clear and repopulate our set with the updated indices.\n        startOrEndIndices.clear();\n        for (const tokenRange of tokenRanges) {\n          startOrEndIndices.add(tokenRange.startIndex);\n          startOrEndIndices.add(tokenRange.endIndex);\n        }\n      }\n    }\n  }\n\n  private static _isDeclarationName(name: ts.Identifier): boolean {\n    return ExcerptBuilder._isDeclaration(name.parent) && name.parent.name === name;\n  }\n\n  private static _isDeclaration(node: ts.Node): node is ts.NamedDeclaration {\n    switch (node.kind) {\n      case ts.SyntaxKind.FunctionDeclaration:\n      case ts.SyntaxKind.FunctionExpression:\n      case ts.SyntaxKind.VariableDeclaration:\n      case ts.SyntaxKind.Parameter:\n      case ts.SyntaxKind.EnumDeclaration:\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.ClassExpression:\n      case ts.SyntaxKind.ModuleDeclaration:\n      case ts.SyntaxKind.MethodDeclaration:\n      case ts.SyntaxKind.MethodSignature:\n      case ts.SyntaxKind.PropertyDeclaration:\n      case ts.SyntaxKind.PropertySignature:\n      case ts.SyntaxKind.GetAccessor:\n      case ts.SyntaxKind.SetAccessor:\n      case ts.SyntaxKind.InterfaceDeclaration:\n      case ts.SyntaxKind.TypeAliasDeclaration:\n      case ts.SyntaxKind.TypeParameter:\n      case ts.SyntaxKind.EnumMember:\n      case ts.SyntaxKind.BindingElement:\n        return true;\n      default:\n        return false;\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ExcerptBuilder.js","sourceRoot":"","sources":["../../src/generators/ExcerptBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport type { DeclarationReference } from '@microsoft/tsdoc/lib-commonjs/beta/DeclarationReference';\r\nimport {\r\n  ExcerptTokenKind,\r\n  type IExcerptToken,\r\n  type IExcerptTokenRange\r\n} from '@microsoft/api-extractor-model';\r\n\r\nimport { Span } from '../analyzer/Span';\r\nimport type { DeclarationReferenceGenerator } from './DeclarationReferenceGenerator';\r\nimport type { AstDeclaration } from '../analyzer/AstDeclaration';\r\n\r\n/**\r\n * Used to provide ExcerptBuilder with a list of nodes whose token range we want to capture.\r\n */\r\nexport interface IExcerptBuilderNodeToCapture {\r\n  /**\r\n   * The node to capture\r\n   */\r\n  node: ts.Node | undefined;\r\n  /**\r\n   * The token range whose startIndex/endIndex will be overwritten with the indexes for the\r\n   * tokens corresponding to IExcerptBuilderNodeToCapture.node\r\n   */\r\n  tokenRange: IExcerptTokenRange;\r\n}\r\n\r\n/**\r\n * Internal state for ExcerptBuilder\r\n */\r\ninterface IBuildSpanState {\r\n  referenceGenerator: DeclarationReferenceGenerator;\r\n\r\n  /**\r\n   * The AST node that we will traverse to extract tokens\r\n   */\r\n  startingNode: ts.Node;\r\n\r\n  /**\r\n   * Normally, the excerpt will include all child nodes for `startingNode`; whereas if `childKindToStopBefore`\r\n   * is specified, then the node traversal will stop before (i.e. excluding) the first immediate child\r\n   * of `startingNode` with the specified syntax kind.\r\n   *\r\n   * @remarks\r\n   * For example, suppose the signature is `interface X: Y { z: string }`.  The token `{` has syntax kind\r\n   * `ts.SyntaxKind.FirstPunctuation`, so we can specify that to truncate the excerpt to `interface X: Y`.\r\n   */\r\n  stopBeforeChildKind: ts.SyntaxKind | undefined;\r\n\r\n  tokenRangesByNode: Map<ts.Node, IExcerptTokenRange>;\r\n\r\n  /**\r\n   * Tracks whether the last appended token was a separator. If so, and we're in the middle of\r\n   * capturing a token range, then omit the separator from the range.\r\n   */\r\n  lastAppendedTokenIsSeparator: boolean;\r\n}\r\n\r\nexport class ExcerptBuilder {\r\n  /**\r\n   * Appends a blank line to the `excerptTokens` list.\r\n   * @param excerptTokens - The target token list to append to\r\n   */\r\n  public static addBlankLine(excerptTokens: IExcerptToken[]): void {\r\n    let newlines: string = '\\n\\n';\r\n    // If the existing text already ended with a newline, then only append one newline\r\n    if (excerptTokens.length > 0) {\r\n      const previousText: string = excerptTokens[excerptTokens.length - 1].text;\r\n      if (/\\n$/.test(previousText)) {\r\n        newlines = '\\n';\r\n      }\r\n    }\r\n    excerptTokens.push({ kind: ExcerptTokenKind.Content, text: newlines });\r\n  }\r\n\r\n  /**\r\n   * Appends the signature for the specified `AstDeclaration` to the `excerptTokens` list.\r\n   * @param excerptTokens - The target token list to append to\r\n   * @param nodesToCapture - A list of child nodes whose token ranges we want to capture\r\n   */\r\n  public static addDeclaration(\r\n    excerptTokens: IExcerptToken[],\r\n    astDeclaration: AstDeclaration,\r\n    nodesToCapture: IExcerptBuilderNodeToCapture[],\r\n    referenceGenerator: DeclarationReferenceGenerator\r\n  ): void {\r\n    let stopBeforeChildKind: ts.SyntaxKind | undefined = undefined;\r\n\r\n    switch (astDeclaration.declaration.kind) {\r\n      case ts.SyntaxKind.ClassDeclaration:\r\n      case ts.SyntaxKind.EnumDeclaration:\r\n      case ts.SyntaxKind.InterfaceDeclaration:\r\n        // FirstPunctuation = \"{\"\r\n        stopBeforeChildKind = ts.SyntaxKind.FirstPunctuation;\r\n        break;\r\n      case ts.SyntaxKind.ModuleDeclaration:\r\n        // ModuleBlock = the \"{ ... }\" block\r\n        stopBeforeChildKind = ts.SyntaxKind.ModuleBlock;\r\n        break;\r\n    }\r\n\r\n    const span: Span = new Span(astDeclaration.declaration);\r\n\r\n    const tokenRangesByNode: Map<ts.Node, IExcerptTokenRange> = new Map<ts.Node, IExcerptTokenRange>();\r\n    for (const excerpt of nodesToCapture || []) {\r\n      if (excerpt.node) {\r\n        tokenRangesByNode.set(excerpt.node, excerpt.tokenRange);\r\n      }\r\n    }\r\n\r\n    ExcerptBuilder._buildSpan(excerptTokens, span, {\r\n      referenceGenerator: referenceGenerator,\r\n      startingNode: span.node,\r\n      stopBeforeChildKind,\r\n      tokenRangesByNode,\r\n      lastAppendedTokenIsSeparator: false\r\n    });\r\n    ExcerptBuilder._condenseTokens(excerptTokens, [...tokenRangesByNode.values()]);\r\n  }\r\n\r\n  public static createEmptyTokenRange(): IExcerptTokenRange {\r\n    return { startIndex: 0, endIndex: 0 };\r\n  }\r\n\r\n  private static _buildSpan(excerptTokens: IExcerptToken[], span: Span, state: IBuildSpanState): boolean {\r\n    if (span.kind === ts.SyntaxKind.JSDocComment) {\r\n      // Discard any comments\r\n      return true;\r\n    }\r\n\r\n    // Can this node start a excerpt?\r\n    const capturedTokenRange: IExcerptTokenRange | undefined = state.tokenRangesByNode.get(span.node);\r\n    let excerptStartIndex: number = 0;\r\n\r\n    if (capturedTokenRange) {\r\n      // We will assign capturedTokenRange.startIndex to be the index of the next token to be appended\r\n      excerptStartIndex = excerptTokens.length;\r\n    }\r\n\r\n    if (span.prefix) {\r\n      let canonicalReference: DeclarationReference | undefined = undefined;\r\n\r\n      if (span.kind === ts.SyntaxKind.Identifier) {\r\n        const name: ts.Identifier = span.node as ts.Identifier;\r\n        if (!ExcerptBuilder._isDeclarationName(name)) {\r\n          canonicalReference = state.referenceGenerator.getDeclarationReferenceForIdentifier(name);\r\n        }\r\n      }\r\n\r\n      if (canonicalReference) {\r\n        ExcerptBuilder._appendToken(\r\n          excerptTokens,\r\n          ExcerptTokenKind.Reference,\r\n          span.prefix,\r\n          canonicalReference\r\n        );\r\n      } else {\r\n        ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content, span.prefix);\r\n      }\r\n      state.lastAppendedTokenIsSeparator = false;\r\n    }\r\n\r\n    for (const child of span.children) {\r\n      if (span.node === state.startingNode) {\r\n        if (state.stopBeforeChildKind && child.kind === state.stopBeforeChildKind) {\r\n          // We reached a child whose kind is stopBeforeChildKind, so stop traversing\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!this._buildSpan(excerptTokens, child, state)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (span.suffix) {\r\n      ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content, span.suffix);\r\n      state.lastAppendedTokenIsSeparator = false;\r\n    }\r\n    if (span.separator) {\r\n      ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content, span.separator);\r\n      state.lastAppendedTokenIsSeparator = true;\r\n    }\r\n\r\n    // Are we building a excerpt?  If so, set its range\r\n    if (capturedTokenRange) {\r\n      capturedTokenRange.startIndex = excerptStartIndex;\r\n\r\n      // We will assign capturedTokenRange.startIndex to be the index after the last token\r\n      // that was appended so far. However, if the last appended token was a separator, omit\r\n      // it from the range.\r\n      let excerptEndIndex: number = excerptTokens.length;\r\n      if (state.lastAppendedTokenIsSeparator) {\r\n        excerptEndIndex--;\r\n      }\r\n\r\n      capturedTokenRange.endIndex = excerptEndIndex;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private static _appendToken(\r\n    excerptTokens: IExcerptToken[],\r\n    excerptTokenKind: ExcerptTokenKind,\r\n    text: string,\r\n    canonicalReference?: DeclarationReference\r\n  ): void {\r\n    if (text.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const excerptToken: IExcerptToken = { kind: excerptTokenKind, text: text };\r\n    if (canonicalReference !== undefined) {\r\n      excerptToken.canonicalReference = canonicalReference.toString();\r\n    }\r\n    excerptTokens.push(excerptToken);\r\n  }\r\n\r\n  /**\r\n   * Condenses the provided excerpt tokens by merging tokens where possible. Updates the provided token ranges to\r\n   * remain accurate after token merging.\r\n   *\r\n   * @remarks\r\n   * For example, suppose we have excerpt tokens [\"A\", \"B\", \"C\"] and a token range [0, 2]. If the excerpt tokens\r\n   * are condensed to [\"AB\", \"C\"], then the token range would be updated to [0, 1]. Note that merges are only\r\n   * performed if they are compatible with the provided token ranges. In the example above, if our token range was\r\n   * originally [0, 1], we would not be able to merge tokens \"A\" and \"B\".\r\n   */\r\n  private static _condenseTokens(excerptTokens: IExcerptToken[], tokenRanges: IExcerptTokenRange[]): void {\r\n    // This set is used to quickly lookup a start or end index.\r\n    const startOrEndIndices: Set<number> = new Set();\r\n    for (const tokenRange of tokenRanges) {\r\n      startOrEndIndices.add(tokenRange.startIndex);\r\n      startOrEndIndices.add(tokenRange.endIndex);\r\n    }\r\n\r\n    for (let currentIndex: number = 1; currentIndex < excerptTokens.length; ++currentIndex) {\r\n      while (currentIndex < excerptTokens.length) {\r\n        const prevPrevToken: IExcerptToken = excerptTokens[currentIndex - 2]; // May be undefined\r\n        const prevToken: IExcerptToken = excerptTokens[currentIndex - 1];\r\n        const currentToken: IExcerptToken = excerptTokens[currentIndex];\r\n\r\n        // The number of excerpt tokens that are merged in this iteration. We need this to determine\r\n        // how to update the start and end indices of our token ranges.\r\n        let mergeCount: number;\r\n\r\n        // There are two types of merges that can occur. We only perform these merges if they are\r\n        // compatible with all of our token ranges.\r\n        if (\r\n          prevPrevToken &&\r\n          prevPrevToken.kind === ExcerptTokenKind.Reference &&\r\n          prevToken.kind === ExcerptTokenKind.Content &&\r\n          prevToken.text.trim() === '.' &&\r\n          currentToken.kind === ExcerptTokenKind.Reference &&\r\n          !startOrEndIndices.has(currentIndex) &&\r\n          !startOrEndIndices.has(currentIndex - 1)\r\n        ) {\r\n          // If the current token is a reference token, the previous token is a \".\", and the previous-\r\n          // previous token is a reference token, then merge all three tokens into a reference token.\r\n          //\r\n          // For example: Given [\"MyNamespace\" (R), \".\", \"MyClass\" (R)], tokens \".\" and \"MyClass\" might\r\n          // be merged into \"MyNamespace\". The condensed token would be [\"MyNamespace.MyClass\" (R)].\r\n          prevPrevToken.text += prevToken.text + currentToken.text;\r\n          prevPrevToken.canonicalReference = currentToken.canonicalReference;\r\n          mergeCount = 2;\r\n          currentIndex--;\r\n        } else if (\r\n          // If the current and previous tokens are both content tokens, then merge the tokens into a\r\n          // single content token. For example: Given [\"export \", \"declare class\"], these tokens\r\n          // might be merged into \"export declare class\".\r\n          prevToken.kind === ExcerptTokenKind.Content &&\r\n          prevToken.kind === currentToken.kind &&\r\n          !startOrEndIndices.has(currentIndex)\r\n        ) {\r\n          prevToken.text += currentToken.text;\r\n          mergeCount = 1;\r\n        } else {\r\n          // Otherwise, no merging can occur here. Continue to the next index.\r\n          break;\r\n        }\r\n\r\n        // Remove the now redundant excerpt token(s), as they were merged into a previous token.\r\n        excerptTokens.splice(currentIndex, mergeCount);\r\n\r\n        // Update the start and end indices for all token ranges based upon how many excerpt\r\n        // tokens were merged and in what positions.\r\n        for (const tokenRange of tokenRanges) {\r\n          if (tokenRange.startIndex > currentIndex) {\r\n            tokenRange.startIndex -= mergeCount;\r\n          }\r\n\r\n          if (tokenRange.endIndex > currentIndex) {\r\n            tokenRange.endIndex -= mergeCount;\r\n          }\r\n        }\r\n\r\n        // Clear and repopulate our set with the updated indices.\r\n        startOrEndIndices.clear();\r\n        for (const tokenRange of tokenRanges) {\r\n          startOrEndIndices.add(tokenRange.startIndex);\r\n          startOrEndIndices.add(tokenRange.endIndex);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _isDeclarationName(name: ts.Identifier): boolean {\r\n    return ExcerptBuilder._isDeclaration(name.parent) && name.parent.name === name;\r\n  }\r\n\r\n  private static _isDeclaration(node: ts.Node): node is ts.NamedDeclaration {\r\n    switch (node.kind) {\r\n      case ts.SyntaxKind.FunctionDeclaration:\r\n      case ts.SyntaxKind.FunctionExpression:\r\n      case ts.SyntaxKind.VariableDeclaration:\r\n      case ts.SyntaxKind.Parameter:\r\n      case ts.SyntaxKind.EnumDeclaration:\r\n      case ts.SyntaxKind.ClassDeclaration:\r\n      case ts.SyntaxKind.ClassExpression:\r\n      case ts.SyntaxKind.ModuleDeclaration:\r\n      case ts.SyntaxKind.MethodDeclaration:\r\n      case ts.SyntaxKind.MethodSignature:\r\n      case ts.SyntaxKind.PropertyDeclaration:\r\n      case ts.SyntaxKind.PropertySignature:\r\n      case ts.SyntaxKind.GetAccessor:\r\n      case ts.SyntaxKind.SetAccessor:\r\n      case ts.SyntaxKind.InterfaceDeclaration:\r\n      case ts.SyntaxKind.TypeAliasDeclaration:\r\n      case ts.SyntaxKind.TypeParameter:\r\n      case ts.SyntaxKind.EnumMember:\r\n      case ts.SyntaxKind.BindingElement:\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/generators/IndentedWriter.js.map b/lib/generators/IndentedWriter.js.map
index ee6455a340864a5820587fa6f036b0668c081c4f..13705a4f543d258bc56d2fd32b4bbc6e67816226 100644
--- a/lib/generators/IndentedWriter.js.map
+++ b/lib/generators/IndentedWriter.js.map
@@ -1 +1 @@
-{"version":3,"file":"IndentedWriter.js","sourceRoot":"","sources":["../../src/generators/IndentedWriter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { StringBuilder, type IStringBuilder } from '@rushstack/node-core-library';\n\n/**\n * A utility for writing indented text.\n *\n * @remarks\n *\n * Note that the indentation is inserted at the last possible opportunity.\n * For example, this code...\n *\n * ```ts\n *   writer.write('begin\\n');\n *   writer.increaseIndent();\n *   writer.write('one\\ntwo\\n');\n *   writer.decreaseIndent();\n *   writer.increaseIndent();\n *   writer.decreaseIndent();\n *   writer.write('end');\n * ```\n *\n * ...would produce this output:\n *\n * ```\n *   begin\n *     one\n *     two\n *   end\n * ```\n */\nexport class IndentedWriter {\n  /**\n   * The text characters used to create one level of indentation.\n   * Two spaces by default.\n   */\n  public defaultIndentPrefix: string = '    ';\n\n  /**\n   * Whether to indent blank lines\n   */\n  public indentBlankLines: boolean = false;\n\n  /**\n   * Trims leading spaces from the input text before applying the indent.\n   *\n   * @remarks\n   * Consider the following example:\n   *\n   * ```ts\n   * indentedWriter.increaseIndent('    '); // four spaces\n   * indentedWriter.write('  a\\n  b  c\\n');\n   * indentedWriter.decreaseIndent();\n   * ```\n   *\n   * Normally the output would be indented by 6 spaces: 4 from `increaseIndent()`, plus the 2 spaces\n   * from `write()`:\n   * ```\n   *       a\n   *       b  c\n   * ```\n   *\n   * Setting `trimLeadingSpaces=true` will trim the leading spaces, so that the lines are indented\n   * by 4 spaces only:\n   * ```\n   *     a\n   *     b  c\n   * ```\n   */\n  public trimLeadingSpaces: boolean = false;\n\n  private readonly _builder: IStringBuilder;\n\n  private _latestChunk: string | undefined;\n  private _previousChunk: string | undefined;\n  private _atStartOfLine: boolean;\n\n  private readonly _indentStack: string[];\n  private _indentText: string;\n\n  private _previousLineIsBlank: boolean;\n  private _currentLineIsBlank: boolean;\n\n  public constructor(builder?: IStringBuilder) {\n    this._builder = builder === undefined ? new StringBuilder() : builder;\n    this._latestChunk = undefined;\n    this._previousChunk = undefined;\n    this._atStartOfLine = true;\n    this._previousLineIsBlank = true;\n    this._currentLineIsBlank = true;\n\n    this._indentStack = [];\n    this._indentText = '';\n  }\n\n  /**\n   * Retrieves the output that was built so far.\n   */\n  public getText(): string {\n    return this._builder.toString();\n  }\n\n  public toString(): string {\n    return this.getText();\n  }\n\n  /**\n   * Increases the indentation.  Normally the indentation is two spaces,\n   * however an arbitrary prefix can optional be specified.  (For example,\n   * the prefix could be \"// \" to indent and comment simultaneously.)\n   * Each call to IndentedWriter.increaseIndent() must be followed by a\n   * corresponding call to IndentedWriter.decreaseIndent().\n   */\n  public increaseIndent(indentPrefix?: string): void {\n    this._indentStack.push(indentPrefix !== undefined ? indentPrefix : this.defaultIndentPrefix);\n    this._updateIndentText();\n  }\n\n  /**\n   * Decreases the indentation, reverting the effect of the corresponding call\n   * to IndentedWriter.increaseIndent().\n   */\n  public decreaseIndent(): void {\n    this._indentStack.pop();\n    this._updateIndentText();\n  }\n\n  /**\n   * A shorthand for ensuring that increaseIndent()/decreaseIndent() occur\n   * in pairs.\n   */\n  public indentScope(scope: () => void, indentPrefix?: string): void {\n    this.increaseIndent(indentPrefix);\n    scope();\n    this.decreaseIndent();\n  }\n\n  /**\n   * Adds a newline if the file pointer is not already at the start of the line (or start of the stream).\n   */\n  public ensureNewLine(): void {\n    const lastCharacter: string = this.peekLastCharacter();\n    if (lastCharacter !== '\\n' && lastCharacter !== '') {\n      this._writeNewLine();\n    }\n  }\n\n  /**\n   * Adds up to two newlines to ensure that there is a blank line above the current position.\n   * The start of the stream is considered to be a blank line, so `ensureSkippedLine()` has no effect\n   * unless some text has been written.\n   */\n  public ensureSkippedLine(): void {\n    this.ensureNewLine();\n    if (!this._previousLineIsBlank) {\n      this._writeNewLine();\n    }\n  }\n\n  /**\n   * Returns the last character that was written, or an empty string if no characters have been written yet.\n   */\n  public peekLastCharacter(): string {\n    if (this._latestChunk !== undefined) {\n      return this._latestChunk.substr(-1, 1);\n    }\n    return '';\n  }\n\n  /**\n   * Returns the second to last character that was written, or an empty string if less than one characters\n   * have been written yet.\n   */\n  public peekSecondLastCharacter(): string {\n    if (this._latestChunk !== undefined) {\n      if (this._latestChunk.length > 1) {\n        return this._latestChunk.substr(-2, 1);\n      }\n      if (this._previousChunk !== undefined) {\n        return this._previousChunk.substr(-1, 1);\n      }\n    }\n    return '';\n  }\n\n  /**\n   * Writes some text to the internal string buffer, applying indentation according\n   * to the current indentation level.  If the string contains multiple newlines,\n   * each line will be indented separately.\n   */\n  public write(message: string): void {\n    if (message.length === 0) {\n      return;\n    }\n\n    // If there are no newline characters, then append the string verbatim\n    if (!/[\\r\\n]/.test(message)) {\n      this._writeLinePart(message);\n      return;\n    }\n\n    // Otherwise split the lines and write each one individually\n    let first: boolean = true;\n    for (const linePart of message.split('\\n')) {\n      if (!first) {\n        this._writeNewLine();\n      } else {\n        first = false;\n      }\n      if (linePart) {\n        this._writeLinePart(linePart.replace(/[\\r]/g, ''));\n      }\n    }\n  }\n\n  /**\n   * A shorthand for writing an optional message, followed by a newline.\n   * Indentation is applied following the semantics of IndentedWriter.write().\n   */\n  public writeLine(message: string = ''): void {\n    if (message.length > 0) {\n      this.write(message);\n    }\n    this._writeNewLine();\n  }\n\n  /**\n   * Writes a string that does not contain any newline characters.\n   */\n  private _writeLinePart(message: string): void {\n    let trimmedMessage: string = message;\n\n    if (this.trimLeadingSpaces && this._atStartOfLine) {\n      trimmedMessage = message.replace(/^ +/, '');\n    }\n\n    if (trimmedMessage.length > 0) {\n      if (this._atStartOfLine && this._indentText.length > 0) {\n        this._write(this._indentText);\n      }\n      this._write(trimmedMessage);\n      if (this._currentLineIsBlank) {\n        if (/\\S/.test(trimmedMessage)) {\n          this._currentLineIsBlank = false;\n        }\n      }\n      this._atStartOfLine = false;\n    }\n  }\n\n  private _writeNewLine(): void {\n    if (this.indentBlankLines) {\n      if (this._atStartOfLine && this._indentText.length > 0) {\n        this._write(this._indentText);\n      }\n    }\n\n    this._previousLineIsBlank = this._currentLineIsBlank;\n    this._write('\\n');\n    this._currentLineIsBlank = true;\n    this._atStartOfLine = true;\n  }\n\n  private _write(s: string): void {\n    this._previousChunk = this._latestChunk;\n    this._latestChunk = s;\n    this._builder.append(s);\n  }\n\n  private _updateIndentText(): void {\n    this._indentText = this._indentStack.join('');\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"IndentedWriter.js","sourceRoot":"","sources":["../../src/generators/IndentedWriter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { StringBuilder, type IStringBuilder } from '@rushstack/node-core-library';\r\n\r\n/**\r\n * A utility for writing indented text.\r\n *\r\n * @remarks\r\n *\r\n * Note that the indentation is inserted at the last possible opportunity.\r\n * For example, this code...\r\n *\r\n * ```ts\r\n *   writer.write('begin\\n');\r\n *   writer.increaseIndent();\r\n *   writer.write('one\\ntwo\\n');\r\n *   writer.decreaseIndent();\r\n *   writer.increaseIndent();\r\n *   writer.decreaseIndent();\r\n *   writer.write('end');\r\n * ```\r\n *\r\n * ...would produce this output:\r\n *\r\n * ```\r\n *   begin\r\n *     one\r\n *     two\r\n *   end\r\n * ```\r\n */\r\nexport class IndentedWriter {\r\n  /**\r\n   * The text characters used to create one level of indentation.\r\n   * Two spaces by default.\r\n   */\r\n  public defaultIndentPrefix: string = '    ';\r\n\r\n  /**\r\n   * Whether to indent blank lines\r\n   */\r\n  public indentBlankLines: boolean = false;\r\n\r\n  /**\r\n   * Trims leading spaces from the input text before applying the indent.\r\n   *\r\n   * @remarks\r\n   * Consider the following example:\r\n   *\r\n   * ```ts\r\n   * indentedWriter.increaseIndent('    '); // four spaces\r\n   * indentedWriter.write('  a\\n  b  c\\n');\r\n   * indentedWriter.decreaseIndent();\r\n   * ```\r\n   *\r\n   * Normally the output would be indented by 6 spaces: 4 from `increaseIndent()`, plus the 2 spaces\r\n   * from `write()`:\r\n   * ```\r\n   *       a\r\n   *       b  c\r\n   * ```\r\n   *\r\n   * Setting `trimLeadingSpaces=true` will trim the leading spaces, so that the lines are indented\r\n   * by 4 spaces only:\r\n   * ```\r\n   *     a\r\n   *     b  c\r\n   * ```\r\n   */\r\n  public trimLeadingSpaces: boolean = false;\r\n\r\n  private readonly _builder: IStringBuilder;\r\n\r\n  private _latestChunk: string | undefined;\r\n  private _previousChunk: string | undefined;\r\n  private _atStartOfLine: boolean;\r\n\r\n  private readonly _indentStack: string[];\r\n  private _indentText: string;\r\n\r\n  private _previousLineIsBlank: boolean;\r\n  private _currentLineIsBlank: boolean;\r\n\r\n  public constructor(builder?: IStringBuilder) {\r\n    this._builder = builder === undefined ? new StringBuilder() : builder;\r\n    this._latestChunk = undefined;\r\n    this._previousChunk = undefined;\r\n    this._atStartOfLine = true;\r\n    this._previousLineIsBlank = true;\r\n    this._currentLineIsBlank = true;\r\n\r\n    this._indentStack = [];\r\n    this._indentText = '';\r\n  }\r\n\r\n  /**\r\n   * Retrieves the output that was built so far.\r\n   */\r\n  public getText(): string {\r\n    return this._builder.toString();\r\n  }\r\n\r\n  public toString(): string {\r\n    return this.getText();\r\n  }\r\n\r\n  /**\r\n   * Increases the indentation.  Normally the indentation is two spaces,\r\n   * however an arbitrary prefix can optional be specified.  (For example,\r\n   * the prefix could be \"// \" to indent and comment simultaneously.)\r\n   * Each call to IndentedWriter.increaseIndent() must be followed by a\r\n   * corresponding call to IndentedWriter.decreaseIndent().\r\n   */\r\n  public increaseIndent(indentPrefix?: string): void {\r\n    this._indentStack.push(indentPrefix !== undefined ? indentPrefix : this.defaultIndentPrefix);\r\n    this._updateIndentText();\r\n  }\r\n\r\n  /**\r\n   * Decreases the indentation, reverting the effect of the corresponding call\r\n   * to IndentedWriter.increaseIndent().\r\n   */\r\n  public decreaseIndent(): void {\r\n    this._indentStack.pop();\r\n    this._updateIndentText();\r\n  }\r\n\r\n  /**\r\n   * A shorthand for ensuring that increaseIndent()/decreaseIndent() occur\r\n   * in pairs.\r\n   */\r\n  public indentScope(scope: () => void, indentPrefix?: string): void {\r\n    this.increaseIndent(indentPrefix);\r\n    scope();\r\n    this.decreaseIndent();\r\n  }\r\n\r\n  /**\r\n   * Adds a newline if the file pointer is not already at the start of the line (or start of the stream).\r\n   */\r\n  public ensureNewLine(): void {\r\n    const lastCharacter: string = this.peekLastCharacter();\r\n    if (lastCharacter !== '\\n' && lastCharacter !== '') {\r\n      this._writeNewLine();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds up to two newlines to ensure that there is a blank line above the current position.\r\n   * The start of the stream is considered to be a blank line, so `ensureSkippedLine()` has no effect\r\n   * unless some text has been written.\r\n   */\r\n  public ensureSkippedLine(): void {\r\n    this.ensureNewLine();\r\n    if (!this._previousLineIsBlank) {\r\n      this._writeNewLine();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the last character that was written, or an empty string if no characters have been written yet.\r\n   */\r\n  public peekLastCharacter(): string {\r\n    if (this._latestChunk !== undefined) {\r\n      return this._latestChunk.substr(-1, 1);\r\n    }\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Returns the second to last character that was written, or an empty string if less than one characters\r\n   * have been written yet.\r\n   */\r\n  public peekSecondLastCharacter(): string {\r\n    if (this._latestChunk !== undefined) {\r\n      if (this._latestChunk.length > 1) {\r\n        return this._latestChunk.substr(-2, 1);\r\n      }\r\n      if (this._previousChunk !== undefined) {\r\n        return this._previousChunk.substr(-1, 1);\r\n      }\r\n    }\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Writes some text to the internal string buffer, applying indentation according\r\n   * to the current indentation level.  If the string contains multiple newlines,\r\n   * each line will be indented separately.\r\n   */\r\n  public write(message: string): void {\r\n    if (message.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // If there are no newline characters, then append the string verbatim\r\n    if (!/[\\r\\n]/.test(message)) {\r\n      this._writeLinePart(message);\r\n      return;\r\n    }\r\n\r\n    // Otherwise split the lines and write each one individually\r\n    let first: boolean = true;\r\n    for (const linePart of message.split('\\n')) {\r\n      if (!first) {\r\n        this._writeNewLine();\r\n      } else {\r\n        first = false;\r\n      }\r\n      if (linePart) {\r\n        this._writeLinePart(linePart.replace(/[\\r]/g, ''));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A shorthand for writing an optional message, followed by a newline.\r\n   * Indentation is applied following the semantics of IndentedWriter.write().\r\n   */\r\n  public writeLine(message: string = ''): void {\r\n    if (message.length > 0) {\r\n      this.write(message);\r\n    }\r\n    this._writeNewLine();\r\n  }\r\n\r\n  /**\r\n   * Writes a string that does not contain any newline characters.\r\n   */\r\n  private _writeLinePart(message: string): void {\r\n    let trimmedMessage: string = message;\r\n\r\n    if (this.trimLeadingSpaces && this._atStartOfLine) {\r\n      trimmedMessage = message.replace(/^ +/, '');\r\n    }\r\n\r\n    if (trimmedMessage.length > 0) {\r\n      if (this._atStartOfLine && this._indentText.length > 0) {\r\n        this._write(this._indentText);\r\n      }\r\n      this._write(trimmedMessage);\r\n      if (this._currentLineIsBlank) {\r\n        if (/\\S/.test(trimmedMessage)) {\r\n          this._currentLineIsBlank = false;\r\n        }\r\n      }\r\n      this._atStartOfLine = false;\r\n    }\r\n  }\r\n\r\n  private _writeNewLine(): void {\r\n    if (this.indentBlankLines) {\r\n      if (this._atStartOfLine && this._indentText.length > 0) {\r\n        this._write(this._indentText);\r\n      }\r\n    }\r\n\r\n    this._previousLineIsBlank = this._currentLineIsBlank;\r\n    this._write('\\n');\r\n    this._currentLineIsBlank = true;\r\n    this._atStartOfLine = true;\r\n  }\r\n\r\n  private _write(s: string): void {\r\n    this._previousChunk = this._latestChunk;\r\n    this._latestChunk = s;\r\n    this._builder.append(s);\r\n  }\r\n\r\n  private _updateIndentText(): void {\r\n    this._indentText = this._indentStack.join('');\r\n  }\r\n}\r\n"]}
\ No newline at end of file
diff --git a/lib/generators/test/IndentedWriter.test.d.ts b/lib/generators/test/IndentedWriter.test.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..76847ac77f2497ed2a9f20ebee66e1061d298a22
--- /dev/null
+++ b/lib/generators/test/IndentedWriter.test.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=IndentedWriter.test.d.ts.map
\ No newline at end of file
diff --git a/lib/generators/test/IndentedWriter.test.d.ts.map b/lib/generators/test/IndentedWriter.test.d.ts.map
new file mode 100644
index 0000000000000000000000000000000000000000..bd1ad85c4460dbcbb54213d3525287e59fff3e0b
--- /dev/null
+++ b/lib/generators/test/IndentedWriter.test.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"IndentedWriter.test.d.ts","sourceRoot":"","sources":["../../../src/generators/test/IndentedWriter.test.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/lib/generators/test/IndentedWriter.test.js b/lib/generators/test/IndentedWriter.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..c48187d1588791650f4462e9e2ac2f84d02f01be
--- /dev/null
+++ b/lib/generators/test/IndentedWriter.test.js
@@ -0,0 +1,103 @@
+"use strict";
+// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
+// See LICENSE in the project root for license information.
+Object.defineProperty(exports, "__esModule", { value: true });
+const IndentedWriter_1 = require("../IndentedWriter");
+test('01 Demo from docs', () => {
+    const indentedWriter = new IndentedWriter_1.IndentedWriter();
+    indentedWriter.write('begin\n');
+    indentedWriter.increaseIndent();
+    indentedWriter.write('one\ntwo\n');
+    indentedWriter.decreaseIndent();
+    indentedWriter.increaseIndent();
+    indentedWriter.decreaseIndent();
+    indentedWriter.write('end');
+    expect(indentedWriter.toString()).toMatchSnapshot();
+});
+test('02 Indent something', () => {
+    const indentedWriter = new IndentedWriter_1.IndentedWriter();
+    indentedWriter.write('a');
+    indentedWriter.write('b');
+    indentedWriter.increaseIndent();
+    indentedWriter.writeLine('c');
+    indentedWriter.writeLine('d');
+    indentedWriter.decreaseIndent();
+    indentedWriter.writeLine('e');
+    indentedWriter.increaseIndent('>>> ');
+    indentedWriter.writeLine();
+    indentedWriter.writeLine();
+    indentedWriter.writeLine('g');
+    indentedWriter.decreaseIndent();
+    expect(indentedWriter.toString()).toMatchSnapshot();
+});
+test('03 Indent something with indentBlankLines=true', () => {
+    const indentedWriter = new IndentedWriter_1.IndentedWriter();
+    indentedWriter.indentBlankLines = true;
+    indentedWriter.write('a');
+    indentedWriter.write('b');
+    indentedWriter.increaseIndent();
+    indentedWriter.writeLine('c');
+    indentedWriter.writeLine('d');
+    indentedWriter.decreaseIndent();
+    indentedWriter.writeLine('e');
+    indentedWriter.increaseIndent('>>> ');
+    indentedWriter.writeLine();
+    indentedWriter.writeLine();
+    indentedWriter.writeLine('g');
+    indentedWriter.decreaseIndent();
+    expect(indentedWriter.toString()).toMatchSnapshot();
+});
+test('04 Two kinds of indents', () => {
+    const indentedWriter = new IndentedWriter_1.IndentedWriter();
+    indentedWriter.writeLine('---');
+    indentedWriter.indentScope(() => {
+        indentedWriter.write('a\nb');
+        indentedWriter.indentScope(() => {
+            indentedWriter.write('c\nd\n');
+        });
+        indentedWriter.write('e\n');
+    }, '> ');
+    indentedWriter.writeLine('---');
+    expect(indentedWriter.toString()).toMatchSnapshot();
+});
+test('05 Edge cases for ensureNewLine()', () => {
+    let indentedWriter = new IndentedWriter_1.IndentedWriter();
+    indentedWriter.ensureNewLine();
+    indentedWriter.write('line');
+    expect(indentedWriter.toString()).toMatchSnapshot();
+    indentedWriter = new IndentedWriter_1.IndentedWriter();
+    indentedWriter.write('previous');
+    indentedWriter.ensureNewLine();
+    indentedWriter.write('line');
+    expect(indentedWriter.toString()).toMatchSnapshot();
+});
+test('06 Edge cases for ensureSkippedLine()', () => {
+    let indentedWriter = new IndentedWriter_1.IndentedWriter();
+    indentedWriter.ensureSkippedLine();
+    indentedWriter.write('line');
+    expect(indentedWriter.toString()).toMatchSnapshot();
+    indentedWriter = new IndentedWriter_1.IndentedWriter();
+    indentedWriter.write('previous');
+    indentedWriter.ensureSkippedLine();
+    indentedWriter.write('line');
+    indentedWriter.ensureSkippedLine();
+    expect(indentedWriter.toString()).toMatchSnapshot();
+});
+test('06 trimLeadingSpaces=true', () => {
+    const indentedWriter = new IndentedWriter_1.IndentedWriter();
+    indentedWriter.trimLeadingSpaces = true;
+    // Example from doc comment
+    indentedWriter.increaseIndent('    ');
+    indentedWriter.write('  a\n  b  c\n');
+    indentedWriter.decreaseIndent();
+    indentedWriter.ensureSkippedLine();
+    indentedWriter.increaseIndent('>>');
+    indentedWriter.write(' ');
+    indentedWriter.write('   ');
+    indentedWriter.write(' a');
+    indentedWriter.writeLine('   b');
+    indentedWriter.writeLine('\ttab'); // does not get indented
+    indentedWriter.writeLine('c  ');
+    expect(indentedWriter.toString()).toMatchSnapshot();
+});
+//# sourceMappingURL=IndentedWriter.test.js.map
\ No newline at end of file
diff --git a/lib/generators/test/IndentedWriter.test.js.map b/lib/generators/test/IndentedWriter.test.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..40018c0f86f03f6de40a33e3c099c5ca56bce65d
--- /dev/null
+++ b/lib/generators/test/IndentedWriter.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"IndentedWriter.test.js","sourceRoot":"","sources":["../../../src/generators/test/IndentedWriter.test.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { IndentedWriter } from '../IndentedWriter';\r\n\r\ntest('01 Demo from docs', () => {\r\n  const indentedWriter: IndentedWriter = new IndentedWriter();\r\n  indentedWriter.write('begin\\n');\r\n  indentedWriter.increaseIndent();\r\n  indentedWriter.write('one\\ntwo\\n');\r\n  indentedWriter.decreaseIndent();\r\n  indentedWriter.increaseIndent();\r\n  indentedWriter.decreaseIndent();\r\n  indentedWriter.write('end');\r\n\r\n  expect(indentedWriter.toString()).toMatchSnapshot();\r\n});\r\n\r\ntest('02 Indent something', () => {\r\n  const indentedWriter: IndentedWriter = new IndentedWriter();\r\n  indentedWriter.write('a');\r\n  indentedWriter.write('b');\r\n  indentedWriter.increaseIndent();\r\n  indentedWriter.writeLine('c');\r\n  indentedWriter.writeLine('d');\r\n  indentedWriter.decreaseIndent();\r\n  indentedWriter.writeLine('e');\r\n\r\n  indentedWriter.increaseIndent('>>> ');\r\n  indentedWriter.writeLine();\r\n  indentedWriter.writeLine();\r\n  indentedWriter.writeLine('g');\r\n  indentedWriter.decreaseIndent();\r\n\r\n  expect(indentedWriter.toString()).toMatchSnapshot();\r\n});\r\n\r\ntest('03 Indent something with indentBlankLines=true', () => {\r\n  const indentedWriter: IndentedWriter = new IndentedWriter();\r\n  indentedWriter.indentBlankLines = true;\r\n\r\n  indentedWriter.write('a');\r\n  indentedWriter.write('b');\r\n  indentedWriter.increaseIndent();\r\n  indentedWriter.writeLine('c');\r\n  indentedWriter.writeLine('d');\r\n  indentedWriter.decreaseIndent();\r\n  indentedWriter.writeLine('e');\r\n\r\n  indentedWriter.increaseIndent('>>> ');\r\n  indentedWriter.writeLine();\r\n  indentedWriter.writeLine();\r\n  indentedWriter.writeLine('g');\r\n  indentedWriter.decreaseIndent();\r\n\r\n  expect(indentedWriter.toString()).toMatchSnapshot();\r\n});\r\n\r\ntest('04 Two kinds of indents', () => {\r\n  const indentedWriter: IndentedWriter = new IndentedWriter();\r\n\r\n  indentedWriter.writeLine('---');\r\n  indentedWriter.indentScope(() => {\r\n    indentedWriter.write('a\\nb');\r\n    indentedWriter.indentScope(() => {\r\n      indentedWriter.write('c\\nd\\n');\r\n    });\r\n    indentedWriter.write('e\\n');\r\n  }, '> ');\r\n  indentedWriter.writeLine('---');\r\n\r\n  expect(indentedWriter.toString()).toMatchSnapshot();\r\n});\r\n\r\ntest('05 Edge cases for ensureNewLine()', () => {\r\n  let indentedWriter: IndentedWriter = new IndentedWriter();\r\n  indentedWriter.ensureNewLine();\r\n  indentedWriter.write('line');\r\n  expect(indentedWriter.toString()).toMatchSnapshot();\r\n\r\n  indentedWriter = new IndentedWriter();\r\n  indentedWriter.write('previous');\r\n  indentedWriter.ensureNewLine();\r\n  indentedWriter.write('line');\r\n  expect(indentedWriter.toString()).toMatchSnapshot();\r\n});\r\n\r\ntest('06 Edge cases for ensureSkippedLine()', () => {\r\n  let indentedWriter: IndentedWriter = new IndentedWriter();\r\n  indentedWriter.ensureSkippedLine();\r\n  indentedWriter.write('line');\r\n  expect(indentedWriter.toString()).toMatchSnapshot();\r\n\r\n  indentedWriter = new IndentedWriter();\r\n  indentedWriter.write('previous');\r\n  indentedWriter.ensureSkippedLine();\r\n  indentedWriter.write('line');\r\n  indentedWriter.ensureSkippedLine();\r\n  expect(indentedWriter.toString()).toMatchSnapshot();\r\n});\r\n\r\ntest('06 trimLeadingSpaces=true', () => {\r\n  const indentedWriter: IndentedWriter = new IndentedWriter();\r\n  indentedWriter.trimLeadingSpaces = true;\r\n\r\n  // Example from doc comment\r\n  indentedWriter.increaseIndent('    ');\r\n  indentedWriter.write('  a\\n  b  c\\n');\r\n  indentedWriter.decreaseIndent();\r\n  indentedWriter.ensureSkippedLine();\r\n  indentedWriter.increaseIndent('>>');\r\n  indentedWriter.write(' ');\r\n  indentedWriter.write('   ');\r\n  indentedWriter.write(' a');\r\n  indentedWriter.writeLine('   b');\r\n  indentedWriter.writeLine('\\ttab'); // does not get indented\r\n  indentedWriter.writeLine('c  ');\r\n  expect(indentedWriter.toString()).toMatchSnapshot();\r\n});\r\n"]}
\ No newline at end of file
diff --git a/lib/index.js.map b/lib/index.js.map
index 7caa04246bb0f58be8f9c8a454654ac00a80db65..0f3a1b744b9c879c69b70d5af5a8367558416ff6 100644
--- a/lib/index.js.map
+++ b/lib/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAY3D,qDAAiF;AAAxE,8GAAA,aAAa,OAAA;AAEtB,6CAAsF;AAA7E,sGAAA,SAAS,OAAA;AAA2B,4GAAA,eAAe,OAAA;AAE5D,yDAI+B;AAD7B,kHAAA,eAAe,OAAA;AAKjB,2DAIgC;AAH9B,oHAAA,gBAAgB,OAAA","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/**\n * API Extractor helps with validation, documentation, and reviewing of the exported API for a TypeScript library.\n * The `@microsoft/api-extractor` package provides the command-line tool.  It also exposes a developer API that you\n * can use to invoke API Extractor programmatically.\n *\n * @packageDocumentation\n */\n\nexport { ConsoleMessageId } from './api/ConsoleMessageId';\n\nexport { CompilerState, ICompilerStateCreateOptions } from './api/CompilerState';\n\nexport { Extractor, IExtractorInvokeOptions, ExtractorResult } from './api/Extractor';\n\nexport {\n  IExtractorConfigPrepareOptions,\n  IExtractorConfigLoadForFolderOptions,\n  ExtractorConfig\n} from './api/ExtractorConfig';\n\nexport { ExtractorLogLevel } from './api/ExtractorLogLevel';\n\nexport {\n  ExtractorMessage,\n  IExtractorMessageProperties,\n  ExtractorMessageCategory\n} from './api/ExtractorMessage';\n\nexport { ExtractorMessageId } from './api/ExtractorMessageId';\n\nexport {\n  IConfigCompiler,\n  IConfigApiReport,\n  IConfigDocModel,\n  IConfigDtsRollup,\n  IConfigTsdocMetadata,\n  IConfigMessageReportingRule,\n  IConfigMessageReportingTable,\n  IExtractorMessagesConfig,\n  IConfigFile\n} from './api/IConfigFile';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAY3D,qDAAiF;AAAxE,8GAAA,aAAa,OAAA;AAEtB,6CAAsF;AAA7E,sGAAA,SAAS,OAAA;AAA2B,4GAAA,eAAe,OAAA;AAE5D,yDAI+B;AAD7B,kHAAA,eAAe,OAAA;AAKjB,2DAIgC;AAH9B,oHAAA,gBAAgB,OAAA","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/**\r\n * API Extractor helps with validation, documentation, and reviewing of the exported API for a TypeScript library.\r\n * The `@microsoft/api-extractor` package provides the command-line tool.  It also exposes a developer API that you\r\n * can use to invoke API Extractor programmatically.\r\n *\r\n * @packageDocumentation\r\n */\r\n\r\nexport { ConsoleMessageId } from './api/ConsoleMessageId';\r\n\r\nexport { CompilerState, ICompilerStateCreateOptions } from './api/CompilerState';\r\n\r\nexport { Extractor, IExtractorInvokeOptions, ExtractorResult } from './api/Extractor';\r\n\r\nexport {\r\n  IExtractorConfigPrepareOptions,\r\n  IExtractorConfigLoadForFolderOptions,\r\n  ExtractorConfig\r\n} from './api/ExtractorConfig';\r\n\r\nexport { ExtractorLogLevel } from './api/ExtractorLogLevel';\r\n\r\nexport {\r\n  ExtractorMessage,\r\n  IExtractorMessageProperties,\r\n  ExtractorMessageCategory\r\n} from './api/ExtractorMessage';\r\n\r\nexport { ExtractorMessageId } from './api/ExtractorMessageId';\r\n\r\nexport {\r\n  IConfigCompiler,\r\n  IConfigApiReport,\r\n  IConfigDocModel,\r\n  IConfigDtsRollup,\r\n  IConfigTsdocMetadata,\r\n  IConfigMessageReportingRule,\r\n  IConfigMessageReportingTable,\r\n  IExtractorMessagesConfig,\r\n  IConfigFile\r\n} from './api/IConfigFile';\r\n"]}
\ No newline at end of file
diff --git a/lib/schemas/api-extractor.schema.json b/lib/schemas/api-extractor.schema.json
index 2d64af8b313994b392279ef7ed78108c1c2da7ad..a5f502ce2bdb0a671c5b5c92447391d1678517a4 100644
--- a/lib/schemas/api-extractor.schema.json
+++ b/lib/schemas/api-extractor.schema.json
@@ -24,7 +24,7 @@
     },
 
     "bundledPackages": {
-      "description": "A list of NPM package names whose exports should be treated as part of this package.",
+      "description": "A list of NPM package names whose exports should be treated as part of this package. Also supports regular expressions.",
       "type": "array",
       "items": {
         "type": "string"
diff --git a/lib/start.js.map b/lib/start.js.map
index f1d0b0fb67905cdbf261165cc0fac19ab509669d..a65247818015c97216c8a9b8b41979864940c6b2 100644
--- a/lib/start.js.map
+++ b/lib/start.js.map
@@ -1 +1 @@
-{"version":3,"file":"start.js","sourceRoot":"","sources":["../src/start.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,uCAAyB;AACzB,oDAA4B;AAE5B,2EAAwE;AACxE,+CAA4C;AAE5C,OAAO,CAAC,GAAG,CACT,EAAE,CAAC,GAAG;IACJ,gBAAM,CAAC,IAAI,CAAC,iBAAiB,qBAAS,CAAC,OAAO,GAAG,GAAG,gBAAM,CAAC,IAAI,CAAC,+BAA+B,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAC7G,CAAC;AAEF,MAAM,MAAM,GAA4B,IAAI,iDAAuB,EAAE,CAAC;AAEtE,MAAM,CAAC,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;IAC/B,OAAO,CAAC,KAAK,CAAC,gBAAM,CAAC,GAAG,CAAC,iCAAiC,KAAK,EAAE,CAAC,CAAC,CAAC;IACpE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as os from 'os';\nimport colors from 'colors';\n\nimport { ApiExtractorCommandLine } from './cli/ApiExtractorCommandLine';\nimport { Extractor } from './api/Extractor';\n\nconsole.log(\n  os.EOL +\n    colors.bold(`api-extractor ${Extractor.version} ` + colors.cyan(' - https://api-extractor.com/') + os.EOL)\n);\n\nconst parser: ApiExtractorCommandLine = new ApiExtractorCommandLine();\n\nparser.execute().catch((error) => {\n  console.error(colors.red(`An unexpected error occurred: ${error}`));\n  process.exit(1);\n});\n"]}
\ No newline at end of file
+{"version":3,"file":"start.js","sourceRoot":"","sources":["../src/start.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,uCAAyB;AACzB,oDAA4B;AAE5B,2EAAwE;AACxE,+CAA4C;AAE5C,OAAO,CAAC,GAAG,CACT,EAAE,CAAC,GAAG;IACJ,gBAAM,CAAC,IAAI,CAAC,iBAAiB,qBAAS,CAAC,OAAO,GAAG,GAAG,gBAAM,CAAC,IAAI,CAAC,+BAA+B,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAC7G,CAAC;AAEF,MAAM,MAAM,GAA4B,IAAI,iDAAuB,EAAE,CAAC;AAEtE,MAAM,CAAC,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;IAC/B,OAAO,CAAC,KAAK,CAAC,gBAAM,CAAC,GAAG,CAAC,iCAAiC,KAAK,EAAE,CAAC,CAAC,CAAC;IACpE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as os from 'os';\r\nimport colors from 'colors';\r\n\r\nimport { ApiExtractorCommandLine } from './cli/ApiExtractorCommandLine';\r\nimport { Extractor } from './api/Extractor';\r\n\r\nconsole.log(\r\n  os.EOL +\r\n    colors.bold(`api-extractor ${Extractor.version} ` + colors.cyan(' - https://api-extractor.com/') + os.EOL)\r\n);\r\n\r\nconst parser: ApiExtractorCommandLine = new ApiExtractorCommandLine();\r\n\r\nparser.execute().catch((error) => {\r\n  console.error(colors.red(`An unexpected error occurred: ${error}`));\r\n  process.exit(1);\r\n});\r\n"]}