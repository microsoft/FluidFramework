## API Report File for "@fluidframework/container-runtime"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AttachState } from '@fluidframework/container-definitions';
import { ContainerWarning } from '@fluidframework/container-definitions';
import { EventEmitter } from 'events';
import { FluidDataStoreRegistryEntry } from '@fluidframework/runtime-definitions';
import { FlushMode } from '@fluidframework/runtime-definitions';
import { IAudience } from '@fluidframework/container-definitions';
import { IClientDetails } from '@fluidframework/protocol-definitions';
import { IContainerContext } from '@fluidframework/container-definitions';
import { IContainerRuntime } from '@fluidframework/container-runtime-definitions';
import { IContainerRuntimeEvents } from '@fluidframework/container-runtime-definitions';
import { ICriticalContainerError } from '@fluidframework/container-definitions';
import { IDeltaManager } from '@fluidframework/container-definitions';
import { IDisposable } from '@fluidframework/common-definitions';
import { IDocumentMessage } from '@fluidframework/protocol-definitions';
import { IDocumentStorageService } from '@fluidframework/driver-definitions';
import { IEvent } from '@fluidframework/common-definitions';
import { IEventProvider } from '@fluidframework/common-definitions';
import { IFluidConfiguration } from '@fluidframework/core-interfaces';
import { IFluidDataStoreChannel } from '@fluidframework/runtime-definitions';
import { IFluidDataStoreContextDetached } from '@fluidframework/runtime-definitions';
import { IFluidDataStoreRegistry } from '@fluidframework/runtime-definitions';
import { IFluidHandle } from '@fluidframework/core-interfaces';
import { IFluidHandleContext } from '@fluidframework/core-interfaces';
import { IFluidLoadable } from '@fluidframework/core-interfaces';
import { IFluidObject } from '@fluidframework/core-interfaces';
import { IFluidRouter } from '@fluidframework/core-interfaces';
import { IFluidRunnable } from '@fluidframework/core-interfaces';
import { IFluidSerializer } from '@fluidframework/core-interfaces';
import { IFluidTokenProvider } from '@fluidframework/container-definitions';
import { ILoaderOptions } from '@fluidframework/container-definitions';
import { IQuorum } from '@fluidframework/protocol-definitions';
import { IRequest } from '@fluidframework/core-interfaces';
import { IResponse } from '@fluidframework/core-interfaces';
import { IRuntime } from '@fluidframework/container-definitions';
import { ISequencedDocumentMessage } from '@fluidframework/protocol-definitions';
import { ISignalMessage } from '@fluidframework/protocol-definitions';
import { ISummaryAck } from '@fluidframework/protocol-definitions';
import { ISummaryConfiguration } from '@fluidframework/protocol-definitions';
import { ISummaryContent } from '@fluidframework/protocol-definitions';
import { ISummaryNack } from '@fluidframework/protocol-definitions';
import { ISummaryStats } from '@fluidframework/runtime-definitions';
import { ISummaryTree } from '@fluidframework/protocol-definitions';
import { ISummaryTreeWithStats } from '@fluidframework/runtime-definitions';
import { ITelemetryLogger } from '@fluidframework/common-definitions';
import { ITree } from '@fluidframework/protocol-definitions';
import { LoggingError } from '@fluidframework/telemetry-utils';
import { MessageType } from '@fluidframework/protocol-definitions';
import { NamedFluidDataStoreRegistryEntries } from '@fluidframework/runtime-definitions';
import { TypedEventEmitter } from '@fluidframework/common-utils';

// @public
export const agentSchedulerId = "_scheduler";

// @public (undocumented)
export enum ContainerMessageType {
    // (undocumented)
    Attach = "attach",
    // (undocumented)
    BlobAttach = "blobAttach",
    // (undocumented)
    ChunkedOp = "chunkedOp",
    // (undocumented)
    FluidDataStoreOp = "component"
}

// @public
export class ContainerRuntime extends TypedEventEmitter<IContainerRuntimeEvents> implements IContainerRuntime, IRuntime, ISummarizerRuntime, ISummarizerInternalsProvider {
    // (undocumented)
    get attachState(): AttachState;
    // (undocumented)
    get clientDetails(): IClientDetails;
    // (undocumented)
    get clientId(): string | undefined;
    // (undocumented)
    get closeFn(): (error?: ICriticalContainerError) => void;
    collectGarbage(logger: ITelemetryLogger, fullGC?: boolean): Promise<IGCStats>;
    // (undocumented)
    get connected(): boolean;
    // (undocumented)
    createDataStore(pkg: string | string[]): Promise<IFluidRouter>;
    // (undocumented)
    _createDataStoreWithProps(pkg: string | string[], props?: any, id?: string, isRoot?: boolean): Promise<IFluidDataStoreChannel>;
    // (undocumented)
    createDetachedDataStore(pkg: Readonly<string[]>): IFluidDataStoreContextDetached;
    // (undocumented)
    createDetachedRootDataStore(pkg: Readonly<string[]>, rootDataStoreId: string): IFluidDataStoreContextDetached;
    // (undocumented)
    createRootDataStore(pkg: string | string[], rootDataStoreId: string): Promise<IFluidRouter>;
    // (undocumented)
    createSummary(): ISummaryTree;
    // (undocumented)
    get deltaManager(): IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;
    readonly disableIsolatedChannels: boolean;
    // (undocumented)
    dispose(error?: Error): void;
    // (undocumented)
    get disposed(): boolean;
    // (undocumented)
    readonly enqueueSummarize: ISummarizer["enqueueSummarize"];
    // (undocumented)
    flush(): void;
    // (undocumented)
    get flushMode(): FlushMode;
    // (undocumented)
    get gcTestMode(): boolean;
    // (undocumented)
    getAbsoluteUrl(relativeUrl: string): Promise<string | undefined>;
    // (undocumented)
    getAudience(): IAudience;
    // (undocumented)
    protected getDataStore(id: string, wait?: boolean): Promise<IFluidRouter>;
    // (undocumented)
    getPendingLocalState(): IPendingLocalState | undefined;
    // (undocumented)
    getQuorum(): IQuorum;
    // (undocumented)
    getRootDataStore(id: string, wait?: boolean): Promise<IFluidRouter>;
    // (undocumented)
    get IContainerRuntime(): this;
    // (undocumented)
    get id(): string;
    // (undocumented)
    get IFluidConfiguration(): IFluidConfiguration;
    // (undocumented)
    get IFluidDataStoreRegistry(): IFluidDataStoreRegistry;
    // (undocumented)
    readonly IFluidHandleContext: IFluidHandleContext;
    // (undocumented)
    get IFluidRouter(): this;
    // (undocumented)
    readonly IFluidSerializer: IFluidSerializer;
    // (undocumented)
    get IFluidTokenProvider(): IFluidTokenProvider | undefined;
    get isDirty(): boolean;
    // @deprecated (undocumented)
    isDocumentDirty(): boolean;
    static load(context: IContainerContext, registryEntries: NamedFluidDataStoreRegistryEntries, requestHandler?: (request: IRequest, runtime: IContainerRuntime) => Promise<IResponse>, runtimeOptions?: IContainerRuntimeOptions, containerScope?: IFluidObject, existing?: boolean): Promise<ContainerRuntime>;
    // (undocumented)
    readonly logger: ITelemetryLogger;
    // (undocumented)
    get options(): ILoaderOptions;
    // (undocumented)
    orderSequentially(callback: () => void): void;
    // (undocumented)
    process(messageArg: ISequencedDocumentMessage, local: boolean): void;
    // (undocumented)
    processSignal(message: ISignalMessage, local: boolean): void;
    // (undocumented)
    readonly raiseContainerWarning: (warning: ContainerWarning) => void;
    refreshLatestSummaryAck(proposalHandle: string | undefined, ackHandle: string, summaryLogger: ITelemetryLogger): Promise<void>;
    request(request: IRequest): Promise<IResponse>;
    resolveHandle(request: IRequest): Promise<IResponse>;
    // (undocumented)
    get reSubmitFn(): (type: ContainerMessageType, content: any, localOpMetadata: unknown, opMetadata: Record<string, unknown> | undefined) => void;
    // @internal @deprecated (undocumented)
    readonly runtimeVersion: string;
    // (undocumented)
    get scope(): IFluidObject;
    // (undocumented)
    setAttachState(attachState: AttachState.Attaching | AttachState.Attached): void;
    // (undocumented)
    setConnectionState(connected: boolean, clientId?: string): void;
    // (undocumented)
    setFlushMode(mode: FlushMode): void;
    // @deprecated
    snapshot(): Promise<ITree>;
    // @deprecated (undocumented)
    stop(): Promise<{
        snapshot?: never;
        state?: never;
    }>;
    // (undocumented)
    get storage(): IDocumentStorageService;
    // (undocumented)
    submitDataStoreOp(id: string, contents: any, localOpMetadata?: unknown): void;
    // (undocumented)
    submitDataStoreSignal(address: string, type: string, content: any): void;
    submitSignal(type: string, content: any): void;
    submitSummary(options: ISubmitSummaryOptions): Promise<SubmitSummaryResult>;
    summarize(options: {
        summaryLogger: ITelemetryLogger;
        fullTree?: boolean;
        trackState?: boolean;
        runGC?: boolean;
        fullGC?: boolean;
    }): Promise<ISummaryTreeWithStats>;
    // (undocumented)
    readonly summarizeOnDemand: ISummarizer["summarizeOnDemand"];
    // (undocumented)
    get summarizerClientId(): string | undefined;
    // (undocumented)
    uploadBlob(blob: ArrayBufferLike): Promise<IFluidHandle<ArrayBufferLike>>;
    }

// @public (undocumented)
export interface ContainerRuntimeMessage {
    // (undocumented)
    contents: any;
    // (undocumented)
    type: ContainerMessageType;
}

// @public (undocumented)
export const createSummarizingWarning: (details: string, logged: boolean) => SummarizingWarning;

// @public
export class DeltaScheduler {
    constructor(deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>, logger: ITelemetryLogger);
    // (undocumented)
    batchBegin(): void;
    // (undocumented)
    batchEnd(): void;
    // (undocumented)
    static readonly processingTime = 20;
    }

// @public (undocumented)
export type EnqueueSummarizeResult = (ISummarizeResults & {
    readonly alreadyEnqueued?: undefined;
}) | (ISummarizeResults & {
    readonly alreadyEnqueued: true;
    readonly overridden: true;
}) | {
    readonly alreadyEnqueued: true;
    readonly overridden?: undefined;
};

// @public (undocumented)
export class FluidDataStoreRegistry implements IFluidDataStoreRegistry {
    constructor(namedEntries: NamedFluidDataStoreRegistryEntries);
    // (undocumented)
    get(name: string): Promise<FluidDataStoreRegistryEntry | undefined>;
    // (undocumented)
    get IFluidDataStoreRegistry(): this;
    }

// @public
export interface IAckedSummary {
    // (undocumented)
    readonly summaryAck: ISummaryAckMessage;
    // (undocumented)
    readonly summaryOp: ISummaryOpMessage;
}

// @public (undocumented)
export interface IAckNackSummaryResult {
    // (undocumented)
    readonly ackNackDuration: number;
    // (undocumented)
    readonly summaryAckNackOp: ISummaryAckMessage | ISummaryNackMessage;
}

// @public
export interface IBaseSummarizeResult {
    readonly error: any;
    readonly referenceSequenceNumber: number;
    // (undocumented)
    readonly stage: "base";
}

// @public (undocumented)
export interface IBroadcastSummaryResult {
    // (undocumented)
    readonly broadcastDuration: number;
    // (undocumented)
    readonly summarizeOp: ISummaryOpMessage;
}

// @public (undocumented)
export interface ICancellable {
    // (undocumented)
    readonly cancelled: boolean;
    // (undocumented)
    readonly waitCancelled: Promise<void>;
}

// @public (undocumented)
export interface ICancellableController extends ICancellable {
    // (undocumented)
    stop(reason: SummarizerStopReason): void;
}

// @public (undocumented)
export interface IChunkedOp {
    // (undocumented)
    chunkId: number;
    // (undocumented)
    contents: string;
    // (undocumented)
    originalType: MessageType | ContainerMessageType;
    // (undocumented)
    totalChunks: number;
}

// @public
export interface IClientSummaryWatcher extends IDisposable {
    // (undocumented)
    waitFlushed(): Promise<IAckedSummary | undefined>;
    // (undocumented)
    watchSummary(clientSequenceNumber: number): ISummary;
}

// @public (undocumented)
export interface IConnectableRuntime {
    // (undocumented)
    readonly clientId: string | undefined;
    // (undocumented)
    readonly connected: boolean;
    // (undocumented)
    readonly deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;
    // (undocumented)
    readonly disposed: boolean;
    // (undocumented)
    once(event: "connected" | "disconnected", listener: () => void): this;
}

// @public
export interface IContainerRuntimeOptions {
    // (undocumented)
    gcOptions?: IGCRuntimeOptions;
    loadSequenceNumberVerification?: "close" | "log" | "bypass";
    // (undocumented)
    summaryOptions?: ISummaryRuntimeOptions;
}

// @public
export interface IEnqueueSummarizeOptions extends IOnDemandSummarizeOptions {
    readonly afterSequenceNumber?: number;
    readonly override?: boolean;
}

// @public (undocumented)
export interface IGCRuntimeOptions {
    [key: string]: any;
    // (undocumented)
    disableGC?: boolean;
    gcAllowed?: boolean;
    runFullGC?: boolean;
}

// @public
export interface IGCStats {
    deletedDataStores: number;
    deletedNodes: number;
    totalDataStores: number;
    totalNodes: number;
}

// @public
export interface IGeneratedSummaryStats extends ISummaryStats {
    // (undocumented)
    readonly dataStoreCount: number;
    // (undocumented)
    readonly summarizedDataStoreCount: number;
}

// @public
export interface IGenerateSummaryTreeResult extends Omit<IBaseSummarizeResult, "stage"> {
    readonly generateDuration: number;
    // (undocumented)
    readonly stage: "generate";
    readonly summaryStats: IGeneratedSummaryStats;
    readonly summaryTree: ISummaryTree;
}

// @public (undocumented)
export interface IOnDemandSummarizeOptions extends ISummarizeOptions {
    readonly reason: string;
}

// @public
export interface IPendingFlush {
    // (undocumented)
    type: "flush";
}

// @public
export interface IPendingFlushMode {
    // (undocumented)
    flushMode: FlushMode;
    // (undocumented)
    type: "flushMode";
}

// @public (undocumented)
export interface IPendingLocalState {
    clientId?: string;
    pendingStates: IPendingState[];
}

// @public
export interface IPendingMessage {
    // (undocumented)
    clientSequenceNumber: number;
    // (undocumented)
    content: any;
    // (undocumented)
    localOpMetadata: unknown;
    // (undocumented)
    messageType: ContainerMessageType;
    // (undocumented)
    opMetadata: Record<string, unknown> | undefined;
    // (undocumented)
    referenceSequenceNumber: number;
    // (undocumented)
    type: "message";
}

// @public (undocumented)
export type IPendingState = IPendingMessage | IPendingFlushMode | IPendingFlush;

// @public (undocumented)
export interface IProvideSummarizer {
    // (undocumented)
    readonly ISummarizer: ISummarizer;
}

// @public (undocumented)
export function isRuntimeMessage(message: ISequencedDocumentMessage): boolean;

// @public
export interface ISubmitSummaryOpResult extends Omit<IUploadSummaryResult, "stage" | "error"> {
    readonly clientSequenceNumber: number;
    // (undocumented)
    readonly stage: "submit";
    readonly submitOpDuration: number;
}

// @public (undocumented)
export interface ISubmitSummaryOptions extends ISummarizeOptions {
    // (undocumented)
    readonly cancellable: ICancellable;
    readonly summaryLogger: ITelemetryLogger;
}

// @public
export interface ISummarizeAttempt {
    readonly refSequenceNumber: number;
    summarySequenceNumber?: number;
    readonly summaryTime: number;
}

// @public
export interface ISummarizeHeuristicData {
    initialize(lastSummary: ISummarizeAttempt): void;
    readonly lastAttempt: ISummarizeAttempt;
    lastOpSequenceNumber: number;
    readonly lastSuccessfulSummary: Readonly<ISummarizeAttempt>;
    markLastAttemptAsSuccessful(): void;
    recordAttempt(referenceSequenceNumber?: number): void;
}

// @public
export interface ISummarizeHeuristicRunner {
    dispose(): void;
    run(): void;
    runOnClose(): boolean;
}

// @public
export interface ISummarizeOptions {
    readonly fullTree?: boolean;
    readonly refreshLatestAck?: boolean;
}

// @public (undocumented)
export const ISummarizer: keyof IProvideSummarizer;

// @public (undocumented)
export interface ISummarizer extends IEventProvider<ISummarizerEvents>, IFluidRouter, IFluidRunnable, IFluidLoadable {
    enqueueSummarize(options: IEnqueueSummarizeOptions): EnqueueSummarizeResult;
    // (undocumented)
    run(onBehalfOf: string, options?: Readonly<Partial<ISummarizerOptions>>): Promise<void>;
    // (undocumented)
    stop(reason?: SummarizerStopReason): void;
    summarizeOnDemand(options: IOnDemandSummarizeOptions): OnDemandSummarizeResult;
}

// @public (undocumented)
export interface ISummarizeResults {
    readonly receivedSummaryAckOrNack: Promise<SummarizeResultPart<IAckNackSummaryResult>>;
    readonly summaryOpBroadcasted: Promise<SummarizeResultPart<IBroadcastSummaryResult>>;
    readonly summarySubmitted: Promise<SummarizeResultPart<SubmitSummaryResult>>;
}

// @public (undocumented)
export interface ISummarizerEvents extends IEvent {
    (event: "summarizingError", listener: (error: ISummarizingWarning) => void): any;
}

// @public (undocumented)
export interface ISummarizerInternalsProvider {
    refreshLatestSummaryAck(proposalHandle: string, ackHandle: string, summaryLogger: ITelemetryLogger): Promise<void>;
    submitSummary(options: ISubmitSummaryOptions): Promise<SubmitSummaryResult>;
}

// @public
export interface ISummarizerOptions {
    disableHeuristics: boolean;
}

// @public (undocumented)
export interface ISummarizerRuntime extends IConnectableRuntime {
    // (undocumented)
    closeFn(): void;
    // (undocumented)
    readonly logger: ITelemetryLogger;
    // (undocumented)
    on(event: "batchEnd", listener: (error: any, op: ISequencedDocumentMessage) => void): this;
    // (undocumented)
    removeListener(event: "batchEnd", listener: (error: any, op: ISequencedDocumentMessage) => void): this;
    readonly summarizerClientId: string | undefined;
}

// @public (undocumented)
export interface ISummarizingWarning extends ContainerWarning {
    // (undocumented)
    readonly errorType: "summarizingError";
    // (undocumented)
    readonly logged: boolean;
}

// @public
export interface ISummary {
    // (undocumented)
    readonly clientId: string;
    // (undocumented)
    readonly clientSequenceNumber: number;
    // (undocumented)
    waitAckNack(): Promise<ISummaryAckMessage | ISummaryNackMessage>;
    // (undocumented)
    waitBroadcast(): Promise<ISummaryOpMessage>;
}

// @public
export interface ISummaryAckMessage extends ISequencedDocumentMessage {
    // (undocumented)
    contents: ISummaryAck;
    // (undocumented)
    type: MessageType.SummaryAck;
}

// @public (undocumented)
export interface ISummaryCollectionOpEvents extends IEvent {
    // (undocumented)
    (event: OpActionEventName, listener: OpActionEventListener): any;
}

// @public
export interface ISummaryNackMessage extends ISequencedDocumentMessage {
    // (undocumented)
    contents: ISummaryNack;
    // (undocumented)
    type: MessageType.SummaryNack;
}

// @public
export interface ISummaryOpMessage extends ISequencedDocumentMessage {
    // (undocumented)
    contents: ISummaryContent;
    // (undocumented)
    type: MessageType.Summarize;
}

// @public (undocumented)
export interface ISummaryRuntimeOptions {
    // (undocumented)
    disableIsolatedChannels?: boolean;
    generateSummaries?: boolean;
    // (undocumented)
    initialSummarizerDelayMs?: number;
    // (undocumented)
    maxOpsSinceLastSummary?: number;
    summarizerClientElection?: boolean;
    summarizerOptions?: Readonly<Partial<ISummarizerOptions>>;
    summaryConfigOverrides?: Partial<ISummaryConfiguration>;
}

// @public
export interface IUploadSummaryResult extends Omit<IGenerateSummaryTreeResult, "stage"> {
    readonly handle: string;
    // (undocumented)
    readonly stage: "upload";
    readonly uploadDuration: number;
}

// @public (undocumented)
export type OnDemandSummarizeResult = (ISummarizeResults & {
    readonly alreadyRunning?: undefined;
}) | {
    readonly alreadyRunning: Promise<void>;
};

// @public (undocumented)
export type OpActionEventListener = (op: ISequencedDocumentMessage) => void;

// @public (undocumented)
export type OpActionEventName = MessageType.Summarize | MessageType.SummaryAck | MessageType.SummaryNack | "default";

// @public
export class PendingStateManager implements IDisposable {
    constructor(containerRuntime: ContainerRuntime, applyStashedOp: (type: any, content: any) => Promise<unknown>, initialState: IPendingLocalState | undefined);
    applyStashedOpsAt(seqNum: number): Promise<void>;
    // (undocumented)
    readonly dispose: () => void;
    // (undocumented)
    get disposed(): boolean;
    // (undocumented)
    getLocalState(): IPendingLocalState | undefined;
    hasPendingMessages(): boolean;
    onFlush(): void;
    onFlushModeUpdated(flushMode: FlushMode): void;
    onSubmitMessage(type: ContainerMessageType, clientSequenceNumber: number, referenceSequenceNumber: number, content: any, localOpMetadata: unknown, opMetadata: Record<string, unknown> | undefined): void;
    processMessage(message: ISequencedDocumentMessage, local: boolean): {
        localAck: boolean;
        localOpMetadata: unknown;
    };
    replayPendingStates(): void;
}

// @public
export class RunWhileConnectedCoordinator implements ICancellableController {
    constructor(runtime: IConnectableRuntime,
    onBehalfOfClientId: string, logger: ITelemetryLogger);
    // (undocumented)
    get cancelled(): boolean;
    stop(reason: SummarizerStopReason): void;
    get waitCancelled(): Promise<void>;
    waitStart(): Promise<{
        started: boolean;
        message: string;
    } | undefined>;
}

// @public (undocumented)
export class ScheduleManager {
    constructor(deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>, emitter: EventEmitter, logger: ITelemetryLogger);
    // (undocumented)
    beginOperation(message: ISequencedDocumentMessage): void;
    // (undocumented)
    endOperation(error: any | undefined, message: ISequencedDocumentMessage): void;
    // (undocumented)
    setPaused(localPaused: boolean): void;
    }

// @public
export type SubmitSummaryResult = IBaseSummarizeResult | IGenerateSummaryTreeResult | IUploadSummaryResult | ISubmitSummaryOpResult;

// @public
export class Summarizer extends EventEmitter implements ISummarizer {
    constructor(url: string,
    runtime: ISummarizerRuntime, configurationGetter: () => ISummaryConfiguration,
    internalsProvider: ISummarizerInternalsProvider, handleContext: IFluidHandleContext, summaryCollection: SummaryCollection);
    // (undocumented)
    get cancelled(): boolean;
    dispose(): void;
    // (undocumented)
    readonly enqueueSummarize: ISummarizer["enqueueSummarize"];
    // (undocumented)
    get handle(): IFluidHandle<this>;
    // (undocumented)
    get IFluidLoadable(): this;
    // (undocumented)
    get IFluidRouter(): this;
    // (undocumented)
    get ISummarizer(): this;
    // (undocumented)
    request(request: IRequest): Promise<IResponse>;
    // (undocumented)
    run(onBehalfOf: string, options?: Readonly<Partial<ISummarizerOptions>>): Promise<void>;
    // (undocumented)
    stop(reason: SummarizerStopReason): void;
    // (undocumented)
    readonly summarizeOnDemand: ISummarizer["summarizeOnDemand"];
    // (undocumented)
    readonly summaryCollection: SummaryCollection;
    }

// @public (undocumented)
export type SummarizeResultPart<T> = {
    success: true;
    data: T;
} | {
    success: false;
    data: T | undefined;
    message: string;
    error: any;
    retryAfterSeconds?: number;
};

// @public (undocumented)
export type SummarizerStopReason =
/** Summarizer client failed to summarize in all 3 consecutive attempts. */
"failToSummarize"
/**
 * Summarizer client detected that its parent is no longer elected the summarizer.
 * Normally, the parent client would realize it is disconnected first and call stop
 * giving a "parentNotConnected" stop reason. If the summarizer client attempts to
 * generate a summary and realizes at that moment that the parent is not elected,
 * only then will it stop itself with this message.
 */
 | "parentNoLongerSummarizer"
/** Parent client reported that it is no longer connected. */
 | "parentNotConnected"
/**
 * Parent client reported that it is no longer elected the summarizer.
 * This is the normal flow; a disconnect will always trigger the parent
 * client to no longer be elected as responsible for summaries. Then it
 * tries to stop its spawned summarizer client.
 */
 | "parentShouldNotSummarize"
/** Parent client reported that it is disposed. */
 | "disposed" | "summarizeClientDisconnected";

// @public (undocumented)
export class SummarizingWarning extends LoggingError implements ISummarizingWarning {
    constructor(errorMessage: string, logged?: boolean);
    // (undocumented)
    readonly canRetry = true;
    // (undocumented)
    readonly errorType = "summarizingError";
    // (undocumented)
    readonly logged: boolean;
    // (undocumented)
    static wrap(error: any, logged: boolean | undefined, logger: ITelemetryLogger): SummarizingWarning;
}

// @public
export class SummaryCollection extends TypedEventEmitter<ISummaryCollectionOpEvents> {
    constructor(deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>, logger: ITelemetryLogger);
    createWatcher(clientId: string): IClientSummaryWatcher;
    // (undocumented)
    emit(event: OpActionEventName, ...args: Parameters<OpActionEventListener>): boolean;
    // (undocumented)
    get latestAck(): IAckedSummary | undefined;
    // (undocumented)
    get opsSinceLastAck(): number;
    // (undocumented)
    removeWatcher(clientId: string): void;
    // (undocumented)
    setPendingAckTimerTimeoutCallback(maxAckWaitTime: number, timeoutCallback: () => void): void;
    // (undocumented)
    unsetPendingAckTimerTimeoutCallback(): void;
    waitFlushed(): Promise<IAckedSummary | undefined>;
    waitSummaryAck(referenceSequenceNumber: number): Promise<IAckedSummary>;
}

// @public (undocumented)
export function unpackRuntimeMessage(message: ISequencedDocumentMessage): ISequencedDocumentMessage;


// (No @packageDocumentation comment for this package)

```
