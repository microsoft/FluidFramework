## API Report File for "@fluidframework/container-utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { IErrorBase } from '@fluidframework/core-interfaces';
import { IFluidErrorBase } from '@fluidframework/telemetry-utils';
import { IGenericError } from '@fluidframework/core-interfaces';
import { ISequencedDocumentMessage } from '@fluidframework/protocol-definitions';
import { ITelemetryLoggerExt } from '@fluidframework/telemetry-utils';
import { ITelemetryProperties } from '@fluidframework/core-interfaces';
import { IThrottlingWarning } from '@fluidframework/core-interfaces';
import { IUsageError } from '@fluidframework/core-interfaces';
import { LoggingError } from '@fluidframework/telemetry-utils';

// @public
export class ClientSessionExpiredError extends LoggingError implements IFluidErrorBase {
    constructor(message: string, expiryMs: number);
    // (undocumented)
    readonly errorType = ContainerErrorType.clientSessionExpiredError;
    // (undocumented)
    readonly expiryMs: number;
}

// @public
export class DataCorruptionError extends LoggingError implements IErrorBase, IFluidErrorBase {
    constructor(message: string, props: ITelemetryProperties);
    // (undocumented)
    readonly canRetry = false;
    // (undocumented)
    readonly errorType = ContainerErrorType.dataCorruptionError;
}

// @public
export class DataProcessingError extends LoggingError implements IErrorBase, IFluidErrorBase {
    // (undocumented)
    readonly canRetry = false;
    static create(errorMessage: string, dataProcessingCodepath: string, sequencedMessage?: ISequencedDocumentMessage, props?: ITelemetryProperties): IFluidErrorBase;
    // (undocumented)
    readonly errorType = ContainerErrorType.dataProcessingError;
    static wrapIfUnrecognized(originalError: any, dataProcessingCodepath: string, messageLike?: Partial<Pick<ISequencedDocumentMessage, "clientId" | "sequenceNumber" | "clientSequenceNumber" | "referenceSequenceNumber" | "minimumSequenceNumber" | "timestamp">>): IFluidErrorBase;
}

// @public (undocumented)
export const extractSafePropertiesFromMessage: (messageLike: Partial<Pick<ISequencedDocumentMessage, "clientId" | "sequenceNumber" | "clientSequenceNumber" | "referenceSequenceNumber" | "minimumSequenceNumber" | "timestamp">>) => {
    messageClientId: string | undefined;
    messageSequenceNumber: number | undefined;
    messageClientSequenceNumber: number | undefined;
    messageReferenceSequenceNumber: number | undefined;
    messageMinimumSequenceNumber: number | undefined;
    messageTimestamp: number | undefined;
};

// @public
export class GenericError extends LoggingError implements IGenericError, IFluidErrorBase {
    constructor(message: string, error?: any, props?: ITelemetryProperties);
    // (undocumented)
    readonly error?: any;
    // (undocumented)
    readonly errorType = ContainerErrorType.genericError;
}

// @public
export class ThrottlingWarning extends LoggingError implements IThrottlingWarning, IFluidErrorBase {
    // (undocumented)
    readonly errorType = ContainerErrorType.throttlingError;
    // (undocumented)
    readonly retryAfterSeconds: number;
    static wrap(error: unknown, retryAfterSeconds: number, logger: ITelemetryLoggerExt): IThrottlingWarning;
}

// @public
export class UsageError extends LoggingError implements IUsageError, IFluidErrorBase {
    constructor(message: string, props?: ITelemetryProperties);
    // (undocumented)
    readonly errorType = ContainerErrorType.usageError;
}

// (No @packageDocumentation comment for this package)

```
