## API Report File for "@fluidframework/merge-tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { IChannelStorageService } from '@fluidframework/datastore-definitions';
import { IFluidDataStoreRuntime } from '@fluidframework/datastore-definitions';
import { IFluidHandle } from '@fluidframework/core-interfaces';
import { IFluidSerializer } from '@fluidframework/shared-object-base';
import { ISequencedDocumentMessage } from '@fluidframework/protocol-definitions';
import { ISummaryTreeWithStats } from '@fluidframework/runtime-definitions';
import { ITelemetryLogger } from '@fluidframework/common-definitions';

// @public (undocumented)
export function addProperties(oldProps: PropertySet | undefined, newProps: PropertySet, op?: ICombiningOp, seq?: number): PropertySet;

// Warning: (ae-internal-missing-underscore) The name "AugmentedIntervalNode" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export interface AugmentedIntervalNode {
    // (undocumented)
    minmax: IInterval;
}

// @public (undocumented)
export abstract class BaseSegment extends MergeNode implements ISegment {
    // @internal @deprecated (undocumented)
    ack(segmentGroup: SegmentGroup, opArgs: IMergeTreeDeltaOpArgs, mergeTree: MergeTree): boolean;
    // (undocumented)
    addProperties(newProps: PropertySet, op?: ICombiningOp, seq?: number, collabWindow?: CollaborationWindow, rollback?: PropertiesRollback): PropertySet | undefined;
    // (undocumented)
    protected addSerializedProps(jseg: IJSONSegment): void;
    // (undocumented)
    abstract append(segment: ISegment): void;
    // (undocumented)
    canAppend(segment: ISegment): boolean;
    // (undocumented)
    clientId: number;
    // (undocumented)
    abstract clone(): ISegment;
    // (undocumented)
    protected cloneInto(b: ISegment): void;
    // (undocumented)
    protected abstract createSplitSegmentAt(pos: number): BaseSegment | undefined;
    // (undocumented)
    hasProperty(key: string): boolean;
    // (undocumented)
    isLeaf(): boolean;
    // (undocumented)
    localRefs?: LocalReferenceCollection;
    // (undocumented)
    localRemovedSeq?: number;
    // (undocumented)
    localSeq?: number;
    // (undocumented)
    properties?: PropertySet;
    // (undocumented)
    propertyManager?: PropertiesManager;
    // (undocumented)
    removedClientIds?: number[];
    // (undocumented)
    removedSeq?: number;
    // (undocumented)
    readonly segmentGroups: SegmentGroupCollection;
    // (undocumented)
    seq: number;
    // (undocumented)
    splitAt(pos: number): ISegment | undefined;
    // (undocumented)
    abstract toJSONObject(): any;
    // (undocumented)
    readonly trackingCollection: TrackingGroupCollection;
    // (undocumented)
    abstract readonly type: string;
}

// @public (undocumented)
export interface BlockAction<TClientData> {
    // (undocumented)
    (block: IMergeBlock, pos: number, refSeq: number, clientId: number, start: number | undefined, end: number | undefined, accum: TClientData): boolean;
}

// @public (undocumented)
export interface BlockUpdateActions {
    // (undocumented)
    child: (block: IMergeBlock, index: number) => void;
}

// @public (undocumented)
export class Client {
    constructor(specToSegment: (spec: IJSONSegment) => ISegment, logger: ITelemetryLogger, options?: PropertySet);
    // (undocumented)
    accumOps: number;
    // (undocumented)
    accumTime: number;
    // (undocumented)
    accumWindow: number;
    // (undocumented)
    accumWindowTime: number;
    // (undocumented)
    addLongClientId(longClientId: string): void;
    annotateMarker(marker: Marker, props: PropertySet, combiningOp?: ICombiningOp): IMergeTreeAnnotateMsg | undefined;
    annotateMarkerNotifyConsensus(marker: Marker, props: PropertySet, consensusCallback: (m: Marker) => void): IMergeTreeAnnotateMsg | undefined;
    annotateRangeLocal(start: number, end: number, props: PropertySet, combiningOp: ICombiningOp | undefined): IMergeTreeAnnotateMsg | undefined;
    // (undocumented)
    applyMsg(msg: ISequencedDocumentMessage, local?: boolean): void;
    // (undocumented)
    applyStashedOp(op: IMergeTreeDeltaOp): SegmentGroup;
    // (undocumented)
    applyStashedOp(op: IMergeTreeGroupMsg): SegmentGroup[];
    // (undocumented)
    applyStashedOp(op: IMergeTreeOp): SegmentGroup | SegmentGroup[];
    // (undocumented)
    cloneFromSegments(): Client;
    // (undocumented)
    createLocalReferencePosition(segment: ISegment, offset: number | undefined, refType: ReferenceType, properties: PropertySet | undefined): LocalReferencePosition;
    // (undocumented)
    createTextHelper(): IMergeTreeTextHelper;
    protected findReconnectionPosition(segment: ISegment, localSeq: number): number;
    // (undocumented)
    findTile(startPos: number, tileLabel: string, preceding?: boolean): {
        tile: ReferencePosition;
        pos: number;
    } | undefined;
    // (undocumented)
    getClientId(): number;
    // (undocumented)
    getCollabWindow(): CollaborationWindow;
    // (undocumented)
    getContainingSegment<T extends ISegment>(pos: number, op?: ISequencedDocumentMessage, localSeq?: number): {
        segment: T | undefined;
        offset: number | undefined;
    };
    // (undocumented)
    getCurrentSeq(): number;
    // (undocumented)
    getLength(): number;
    // (undocumented)
    getLongClientId(shortClientId: number): string;
    // (undocumented)
    getMarkerFromId(id: string): ISegment | undefined;
    // (undocumented)
    getOrAddShortClientId(longClientId: string): number;
    getPosition(segment: ISegment, localSeq?: number): number;
    // (undocumented)
    getPropertiesAtPosition(pos: number): PropertySet | undefined;
    // (undocumented)
    getRangeExtentsOfPosition(pos: number): {
        posStart: number | undefined;
        posAfterEnd: number | undefined;
    };
    // (undocumented)
    getShortClientId(longClientId: string): number;
    getSlideToSegment(segoff: {
        segment: ISegment | undefined;
        offset: number | undefined;
    }): {
        segment: ISegment | undefined;
        offset: number | undefined;
    };
    // @internal @deprecated (undocumented)
    getStackContext(startPos: number, rangeLabels: string[]): RangeStackMap;
    // (undocumented)
    insertAtReferencePositionLocal(refPos: ReferencePosition, segment: ISegment): IMergeTreeInsertMsg | undefined;
    // (undocumented)
    insertSegmentLocal(pos: number, segment: ISegment): IMergeTreeInsertMsg | undefined;
    // (undocumented)
    load(runtime: IFluidDataStoreRuntime, storage: IChannelStorageService, serializer: IFluidSerializer): Promise<{
        catchupOpsP: Promise<ISequencedDocumentMessage[]>;
    }>;
    // (undocumented)
    localOps: number;
    // (undocumented)
    localReferencePositionToPosition(lref: ReferencePosition): number;
    // (undocumented)
    localTime: number;
    // (undocumented)
    localTransaction(groupOp: IMergeTreeGroupMsg): void;
    // (undocumented)
    readonly logger: ITelemetryLogger;
    // (undocumented)
    longClientId: string | undefined;
    // (undocumented)
    maxWindowTime: number;
    // (undocumented)
    measureOps: boolean;
    // @internal @deprecated (undocumented)
    protected readonly mergeTree: MergeTree;
    // (undocumented)
    get mergeTreeDeltaCallback(): MergeTreeDeltaCallback | undefined;
    set mergeTreeDeltaCallback(callback: MergeTreeDeltaCallback | undefined);
    // (undocumented)
    get mergeTreeMaintenanceCallback(): MergeTreeMaintenanceCallback | undefined;
    set mergeTreeMaintenanceCallback(callback: MergeTreeMaintenanceCallback | undefined);
    peekPendingSegmentGroups(count?: number): SegmentGroup | SegmentGroup[] | undefined;
    posFromRelativePos(relativePos: IRelativePosition): number;
    rebasePosition(pos: number, seqNumberFrom: number, localSeq: number): number;
    regeneratePendingOp(resetOp: IMergeTreeOp, segmentGroup: SegmentGroup | SegmentGroup[]): IMergeTreeOp;
    // (undocumented)
    removeLocalReferencePosition(lref: LocalReferencePosition): LocalReferencePosition | undefined;
    removeRangeLocal(start: number, end: number): IMergeTreeRemoveMsg | undefined;
    resolveRemoteClientPosition(remoteClientPosition: number, remoteClientRefSeq: number, remoteClientId: string): number | undefined;
    rollback?(op: any, localOpMetadata: unknown): void;
    serializeGCData(handle: IFluidHandle, handleCollectingSerializer: IFluidSerializer): void;
    // (undocumented)
    readonly specToSegment: (spec: IJSONSegment) => ISegment;
    // (undocumented)
    startOrUpdateCollaboration(longClientId: string | undefined, minSeq?: number, currentSeq?: number): void;
    // (undocumented)
    summarize(runtime: IFluidDataStoreRuntime, handle: IFluidHandle, serializer: IFluidSerializer, catchUpMsgs: ISequencedDocumentMessage[]): ISummaryTreeWithStats;
    // (undocumented)
    updateConsensusProperty(op: IMergeTreeAnnotateMsg, msg: ISequencedDocumentMessage): void;
    // (undocumented)
    updateMinSeq(minSeq: number): void;
    // (undocumented)
    updateSeqNumbers(min: number, seq: number): void;
    // (undocumented)
    walkSegments<TClientData>(handler: ISegmentAction<TClientData>, start: number | undefined, end: number | undefined, accum: TClientData, splitRange?: boolean): void;
    // (undocumented)
    walkSegments<undefined>(handler: ISegmentAction<undefined>, start?: number, end?: number, accum?: undefined, splitRange?: boolean): void;
}

// Warning: (ae-internal-missing-underscore) The name "ClientSeq" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export interface ClientSeq {
    // (undocumented)
    clientId: string;
    // (undocumented)
    refSeq: number;
}

// Warning: (ae-internal-missing-underscore) The name "clientSeqComparer" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export const clientSeqComparer: Comparer<ClientSeq>;

// @public (undocumented)
export function clone<T>(extension: MapLike<T> | undefined): MapLike<T> | undefined;

// @public (undocumented)
export class CollaborationWindow {
    // (undocumented)
    clientId: number;
    // (undocumented)
    collaborating: boolean;
    // (undocumented)
    currentSeq: number;
    // (undocumented)
    loadFrom(a: CollaborationWindow): void;
    // (undocumented)
    localSeq: number;
    // (undocumented)
    minSeq: number;
}

// @public (undocumented)
export function combine(combiningInfo: ICombiningOp, currentValue: any, newValue: any, seq?: number): any;

// @public (undocumented)
export const compareNumbers: (a: number, b: number) => number;

// Warning: (ae-internal-missing-underscore) The name "Comparer" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export interface Comparer<T> {
    // (undocumented)
    compare(a: T, b: T): number;
    // (undocumented)
    min: T;
}

// @public (undocumented)
export function compareReferencePositions(a: ReferencePosition, b: ReferencePosition): number;

// @public (undocumented)
export const compareStrings: (a: string, b: string) => number;

// Warning: (ae-internal-missing-underscore) The name "ConflictAction" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ConflictAction<TKey, TData> = (key: TKey, currentKey: TKey, data: TData, currentData: TData) => QProperty<TKey, TData>;

// @public
export function createAnnotateMarkerOp(marker: Marker, props: PropertySet, combiningOp?: ICombiningOp): IMergeTreeAnnotateMsg | undefined;

// @public
export function createAnnotateRangeOp(start: number, end: number, props: PropertySet, combiningOp: ICombiningOp | undefined): IMergeTreeAnnotateMsg;

// @public (undocumented)
export function createDetachedLocalReferencePosition(refType?: ReferenceType): LocalReferencePosition;

// @public (undocumented)
export function createGroupOp(...ops: IMergeTreeDeltaOp[]): IMergeTreeGroupMsg;

// @public (undocumented)
export function createInsertOp(pos: number, segSpec: any): IMergeTreeInsertMsg;

// @public (undocumented)
export function createInsertSegmentOp(pos: number, segment: ISegment): IMergeTreeInsertMsg;

// @public (undocumented)
export function createMap<T>(): MapLike<T>;

// @public
export function createRemoveRangeOp(start: number, end: number): IMergeTreeRemoveMsg;

// @public (undocumented)
export const DetachedReferencePosition = -1;

// Warning: (ae-internal-missing-underscore) The name "Dictionary" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface Dictionary<TKey, TData> {
    // (undocumented)
    get(key: TKey): Property<TKey, TData> | undefined;
    // (undocumented)
    map<TAccum>(action: PropertyAction<TKey, TData>, accum?: TAccum): void;
    // (undocumented)
    put(key: TKey, data: TData, conflict?: ConflictAction<TKey, TData>): void;
    // (undocumented)
    remove(key: TKey): void;
}

// @public (undocumented)
export function extend<T>(base: MapLike<T>, extension: MapLike<T> | undefined, combiningOp?: ICombiningOp, seq?: number): MapLike<T>;

// @public (undocumented)
export function extendIfUndefined<T>(base: MapLike<T>, extension: MapLike<T> | undefined): MapLike<T>;

// Warning: (ae-internal-missing-underscore) The name "Heap" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export class Heap<T> {
    constructor(a: T[], comp: Comparer<T>);
    // (undocumented)
    add(x: T): void;
    // (undocumented)
    comp: Comparer<T>;
    // (undocumented)
    count(): number;
    // (undocumented)
    get(): T;
    // (undocumented)
    peek(): T;
}

// @public (undocumented)
export interface ICombiningOp {
    // (undocumented)
    defaultValue?: any;
    // (undocumented)
    maxValue?: any;
    // (undocumented)
    minValue?: any;
    // (undocumented)
    name: string;
}

// @public (undocumented)
export interface IConsensusInfo {
    // (undocumented)
    callback: (m: Marker) => void;
    // (undocumented)
    marker: Marker;
}

// @public (undocumented)
export interface IConsensusValue {
    // (undocumented)
    seq: number;
    // (undocumented)
    value: any;
}

// @public (undocumented)
export interface IHierBlock extends IMergeBlock {
    // @internal @deprecated (undocumented)
    addNodeReferences(mergeTree: MergeTree, node: IMergeNode): void;
    // (undocumented)
    hierToString(indentCount: number): string;
    // (undocumented)
    leftmostTiles: MapLike<ReferencePosition>;
    // @internal @deprecated (undocumented)
    rangeStacks: RangeStackMap;
    // (undocumented)
    rightmostTiles: MapLike<ReferencePosition>;
}

// Warning: (ae-internal-missing-underscore) The name "IIntegerRange" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export interface IIntegerRange {
    // (undocumented)
    end: number;
    // (undocumented)
    start: number;
}

// Warning: (ae-internal-missing-underscore) The name "IInterval" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export interface IInterval {
    // (undocumented)
    clone(): IInterval;
    // (undocumented)
    compare(b: IInterval): number;
    // (undocumented)
    compareEnd(b: IInterval): number;
    // (undocumented)
    compareStart(b: IInterval): number;
    // (undocumented)
    modify(label: string, start: number, end: number, op?: ISequencedDocumentMessage, localSeq?: number): IInterval | undefined;
    // (undocumented)
    overlaps(b: IInterval): boolean;
    // (undocumented)
    union(b: IInterval): IInterval;
}

// @public (undocumented)
export interface IJSONMarkerSegment extends IJSONSegment {
    // (undocumented)
    marker: IMarkerDef;
}

// @public (undocumented)
export interface IJSONSegment {
    // (undocumented)
    props?: Record<string, any>;
}

// @public (undocumented)
export interface IJSONTextSegment extends IJSONSegment {
    // (undocumented)
    text: string;
}

// @public (undocumented)
export interface IMarkerDef {
    // (undocumented)
    refType?: ReferenceType;
}

// @public (undocumented)
export interface IMarkerModifiedAction {
    // (undocumented)
    (marker: Marker): void;
}

// @public
export interface IMergeBlock extends IMergeNodeCommon {
    // (undocumented)
    assignChild(child: IMergeNode, index: number, updateOrdinal?: boolean): void;
    childCount: number;
    children: IMergeNode[];
    // (undocumented)
    hierBlock(): IHierBlock | undefined;
    // (undocumented)
    needsScour?: boolean;
    // Warning: (ae-forgotten-export) The symbol "PartialSequenceLengths" needs to be exported by the entry point index.d.ts
    partialLengths?: PartialSequenceLengths;
    // (undocumented)
    setOrdinal(child: IMergeNode, index: number): void;
}

// @public (undocumented)
export type IMergeNode = IMergeBlock | ISegment;

// @public
export interface IMergeNodeCommon {
    cachedLength: number;
    index: number;
    // (undocumented)
    isLeaf(): this is ISegment;
    ordinal: string;
    // (undocumented)
    parent?: IMergeBlock;
}

// @public (undocumented)
export interface IMergeTreeAnnotateMsg extends IMergeTreeDelta {
    // (undocumented)
    combiningOp?: ICombiningOp;
    // (undocumented)
    pos1?: number;
    // (undocumented)
    pos2?: number;
    // (undocumented)
    props: Record<string, any>;
    // (undocumented)
    relativePos1?: IRelativePosition;
    // (undocumented)
    relativePos2?: IRelativePosition;
    // (undocumented)
    type: typeof MergeTreeDeltaType.ANNOTATE;
}

// @public (undocumented)
export interface IMergeTreeClientSequenceArgs {
    // (undocumented)
    readonly clientId: number;
    // (undocumented)
    readonly referenceSequenceNumber: number;
    // (undocumented)
    readonly sequenceNumber: number;
}

// @public (undocumented)
export interface IMergeTreeDelta {
    type: MergeTreeDeltaType;
}

// @public (undocumented)
export interface IMergeTreeDeltaCallbackArgs<TOperationType extends MergeTreeDeltaOperationTypes = MergeTreeDeltaOperationType> {
    // (undocumented)
    readonly deltaSegments: IMergeTreeSegmentDelta[];
    // (undocumented)
    readonly operation: TOperationType;
}

// @public (undocumented)
export type IMergeTreeDeltaOp = IMergeTreeInsertMsg | IMergeTreeRemoveMsg | IMergeTreeAnnotateMsg;

// @public (undocumented)
export interface IMergeTreeDeltaOpArgs {
    readonly groupOp?: IMergeTreeGroupMsg;
    readonly op: IMergeTreeOp;
    readonly sequencedMessage?: ISequencedDocumentMessage;
}

// @public (undocumented)
export interface IMergeTreeGroupMsg extends IMergeTreeDelta {
    // (undocumented)
    ops: IMergeTreeDeltaOp[];
    // (undocumented)
    type: typeof MergeTreeDeltaType.GROUP;
}

// @public (undocumented)
export interface IMergeTreeInsertMsg extends IMergeTreeDelta {
    // (undocumented)
    pos1?: number;
    // (undocumented)
    pos2?: number;
    // (undocumented)
    relativePos1?: IRelativePosition;
    // (undocumented)
    relativePos2?: IRelativePosition;
    // (undocumented)
    seg?: any;
    // (undocumented)
    type: typeof MergeTreeDeltaType.INSERT;
}

// @public (undocumented)
export interface IMergeTreeMaintenanceCallbackArgs extends IMergeTreeDeltaCallbackArgs<MergeTreeMaintenanceType> {
}

// @public (undocumented)
export type IMergeTreeOp = IMergeTreeDeltaOp | IMergeTreeGroupMsg;

// @public (undocumented)
export interface IMergeTreeRemoveMsg extends IMergeTreeDelta {
    // (undocumented)
    pos1?: number;
    // (undocumented)
    pos2?: number;
    // (undocumented)
    relativePos1?: IRelativePosition;
    // (undocumented)
    relativePos2?: IRelativePosition;
    // (undocumented)
    type: typeof MergeTreeDeltaType.REMOVE;
}

// @public (undocumented)
export interface IMergeTreeSegmentDelta {
    // (undocumented)
    propertyDeltas?: PropertySet;
    // (undocumented)
    segment: ISegment;
}

// @public (undocumented)
export interface IMergeTreeTextHelper {
    // (undocumented)
    getText(refSeq: number, clientId: number, placeholder: string, start?: number, end?: number): string;
    // @deprecated (undocumented)
    getTextAndMarkers(refSeq: number, clientId: number, label: string, start?: number, end?: number): {
        parallelText: string[];
        parallelMarkers: Marker[];
    };
}

// @public (undocumented)
export interface IncrementalBlockAction<TContext> {
    // (undocumented)
    (state: IncrementalMapState<TContext>): any;
}

// @public (undocumented)
export enum IncrementalExecOp {
    // (undocumented)
    Go = 0,
    // (undocumented)
    Stop = 1,
    // (undocumented)
    Yield = 2
}

// @public (undocumented)
export class IncrementalMapState<TContext> {
    constructor(block: IMergeBlock, actions: IncrementalSegmentActions<TContext>, pos: number, refSeq: number, clientId: number, context: TContext, start: number, end: number, childIndex?: number);
    // (undocumented)
    actions: IncrementalSegmentActions<TContext>;
    // (undocumented)
    block: IMergeBlock;
    // (undocumented)
    childIndex: number;
    // (undocumented)
    clientId: number;
    // (undocumented)
    context: TContext;
    // (undocumented)
    end: number;
    // (undocumented)
    op: IncrementalExecOp;
    // (undocumented)
    pos: number;
    // (undocumented)
    refSeq: number;
    // (undocumented)
    start: number;
}

// @public (undocumented)
export interface IncrementalSegmentAction<TContext> {
    // (undocumented)
    (segment: ISegment, state: IncrementalMapState<TContext>): any;
}

// @public (undocumented)
export interface IncrementalSegmentActions<TContext> {
    // (undocumented)
    leaf: IncrementalSegmentAction<TContext>;
    // (undocumented)
    post?: IncrementalBlockAction<TContext>;
    // (undocumented)
    pre?: IncrementalBlockAction<TContext>;
}

// @public (undocumented)
export interface InsertContext {
    // (undocumented)
    candidateSegment?: ISegment;
    // (undocumented)
    continuePredicate?: (continueFromBlock: IMergeBlock) => boolean;
    // (undocumented)
    leaf: (segment: ISegment | undefined, pos: number, ic: InsertContext) => ISegmentChanges;
    // (undocumented)
    prepareEvents?: boolean;
    // (undocumented)
    structureChange?: boolean;
}

// Warning: (ae-internal-missing-underscore) The name "integerRangeToString" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export const integerRangeToString: (range: IIntegerRange) => string;

// @public (undocumented)
export function internedSpaces(n: number): string;

// Warning: (ae-internal-missing-underscore) The name "IntervalConflictResolver" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export type IntervalConflictResolver<TInterval> = (a: TInterval, b: TInterval) => TInterval;

// Warning: (ae-internal-missing-underscore) The name "IntervalNode" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export type IntervalNode<T extends IInterval> = RBNode<T, AugmentedIntervalNode>;

// Warning: (ae-internal-missing-underscore) The name "IntervalTree" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export class IntervalTree<T extends IInterval> implements IRBAugmentation<T, AugmentedIntervalNode>, IRBMatcher<T, AugmentedIntervalNode> {
    // (undocumented)
    continueSubtree(node: IntervalNode<T> | undefined, key: T): boolean;
    // (undocumented)
    intervals: RedBlackTree<T, AugmentedIntervalNode>;
    // (undocumented)
    map(fn: (x: T) => void): void;
    // (undocumented)
    mapBackward(fn: (x: T) => void): void;
    // (undocumented)
    mapUntil(fn: (X: T) => boolean): void;
    // (undocumented)
    match(x: T): RBNode<T, AugmentedIntervalNode>[];
    // (undocumented)
    matchNode(node: IntervalNode<T> | undefined, key: T): boolean;
    // (undocumented)
    put(x: T, conflict?: IntervalConflictResolver<T>): void;
    // (undocumented)
    remove(x: T): void;
    // (undocumented)
    removeExisting(x: T): void;
    // (undocumented)
    update(node: IntervalNode<T>): void;
}

// Warning: (ae-internal-missing-underscore) The name "IRBAugmentation" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface IRBAugmentation<TKey, TData> {
    // (undocumented)
    update(node: RBNode<TKey, TData>): void;
}

// Warning: (ae-internal-missing-underscore) The name "IRBMatcher" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface IRBMatcher<TKey, TData> {
    // (undocumented)
    continueSubtree(node: RBNode<TKey, TData> | undefined, key: TKey): boolean;
    // (undocumented)
    matchNode(node: RBNode<TKey, TData> | undefined, key: TKey): boolean;
}

// @public
export interface IRelativePosition {
    before?: boolean;
    id?: string;
    offset?: number;
}

// @public
export interface IRemovalInfo {
    localRemovedSeq?: number;
    removedClientIds: number[];
    removedSeq: number;
}

// @public
export interface ISegment extends IMergeNodeCommon, Partial<IRemovalInfo> {
    // @internal @deprecated
    ack(segmentGroup: SegmentGroup, opArgs: IMergeTreeDeltaOpArgs, mergeTree: MergeTree): boolean;
    // (undocumented)
    addProperties(newProps: PropertySet, op?: ICombiningOp, seq?: number, collabWindow?: CollaborationWindow, rollback?: PropertiesRollback): PropertySet | undefined;
    // (undocumented)
    append(segment: ISegment): void;
    // (undocumented)
    canAppend(segment: ISegment): boolean;
    clientId: number;
    // (undocumented)
    clone(): ISegment;
    localRefs?: LocalReferenceCollection;
    localRemovedSeq?: number;
    localSeq?: number;
    properties?: PropertySet;
    propertyManager?: PropertiesManager;
    // (undocumented)
    readonly segmentGroups: SegmentGroupCollection;
    seq?: number;
    // (undocumented)
    splitAt(pos: number): ISegment | undefined;
    // (undocumented)
    toJSONObject(): any;
    // (undocumented)
    readonly trackingCollection: TrackingGroupCollection;
    // (undocumented)
    readonly type: string;
}

// @public (undocumented)
export interface ISegmentAction<TClientData> {
    // (undocumented)
    (segment: ISegment, pos: number, refSeq: number, clientId: number, start: number, end: number, accum: TClientData): boolean;
}

// @public (undocumented)
export interface ISegmentChanges {
    // (undocumented)
    next?: ISegment;
    // (undocumented)
    replaceCurrent?: ISegment;
}

// Warning: (ae-internal-missing-underscore) The name "KeyComparer" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface KeyComparer<TKey> {
    // (undocumented)
    (a: TKey, b: TKey): number;
}

// Warning: (ae-internal-missing-underscore) The name "List" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export class List<T> {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<T>;
    constructor(isHead: boolean, data: T | undefined);
    // (undocumented)
    clear(): void;
    // (undocumented)
    count(): number;
    // (undocumented)
    data: T | undefined;
    // (undocumented)
    dequeue(): T | undefined;
    // (undocumented)
    empty(): boolean;
    // (undocumented)
    enqueue(data: T): List<T>;
    // (undocumented)
    first(): T | undefined;
    // (undocumented)
    isHead: boolean;
    // (undocumented)
    last(): T | undefined;
    // (undocumented)
    next: List<T>;
    // (undocumented)
    pop?(): T | undefined;
    // (undocumented)
    prev: List<T>;
    // (undocumented)
    some(fn: (data: T, l: List<T>) => boolean, rev?: boolean): T[];
    // (undocumented)
    unshift(data: T): void;
    // (undocumented)
    walk(fn: (data: T, l: List<T>) => void): void;
}

// Warning: (ae-internal-missing-underscore) The name "ListMakeHead" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export function ListMakeHead<U>(): List<U>;

// Warning: (ae-internal-missing-underscore) The name "ListRemoveEntry" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export function ListRemoveEntry<U>(entry: List<U>): List<U> | undefined;

// @public (undocumented)
export const LocalClientId = -1;

// @public
export class LocalReferenceCollection {
    // @internal (undocumented)
    [Symbol.iterator](): {
        next(): IteratorResult<LocalReferencePosition>;
        [Symbol.iterator](): any;
    };
    // Warning: (ae-forgotten-export) The symbol "IRefsAtOffset" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor(
    segment: ISegment, initialRefsByfOffset?: (IRefsAtOffset | undefined)[]);
    // (undocumented)
    addAfterTombstones(...refs: Iterable<LocalReferencePosition>[]): void;
    // (undocumented)
    addBeforeTombstones(...refs: Iterable<LocalReferencePosition>[]): void;
    // @internal (undocumented)
    addLocalRef(lref: LocalReferencePosition, offset: number): void;
    // (undocumented)
    static append(seg1: ISegment, seg2: ISegment): void;
    // @internal
    append(other: LocalReferenceCollection): void;
    // @internal (undocumented)
    clear(): void;
    // @internal (undocumented)
    createLocalRef(offset: number, refType: ReferenceType, properties: PropertySet | undefined): LocalReferencePosition;
    // @internal (undocumented)
    get empty(): boolean;
    // @internal
    has(lref: ReferencePosition): boolean;
    // @internal (undocumented)
    hierRefCount: number;
    // @internal (undocumented)
    removeLocalRef(lref: LocalReferencePosition): LocalReferencePosition | undefined;
    // @internal
    split(offset: number, splitSeg: ISegment): void;
}

// @public (undocumented)
export interface LocalReferencePosition extends ReferencePosition {
    // (undocumented)
    callbacks?: Partial<Record<"beforeSlide" | "afterSlide", () => void>>;
}

// Warning: (ae-internal-missing-underscore) The name "LRUSegment" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export interface LRUSegment {
    // (undocumented)
    maxSeq: number;
    // (undocumented)
    segment?: ISegment;
}

// @public (undocumented)
export interface MapLike<T> {
    // (undocumented)
    [index: string]: T;
}

// @public (undocumented)
export class Marker extends BaseSegment implements ReferencePosition {
    constructor(refType: ReferenceType);
    // (undocumented)
    append(): void;
    // (undocumented)
    canAppend(segment: ISegment): boolean;
    // (undocumented)
    clone(): Marker;
    // (undocumented)
    protected createSplitSegmentAt(pos: number): undefined;
    // (undocumented)
    static fromJSONObject(spec: any): Marker | undefined;
    // (undocumented)
    getId(): string | undefined;
    // (undocumented)
    getOffset(): number;
    // (undocumented)
    getProperties(): PropertySet | undefined;
    // (undocumented)
    getSegment(): this;
    // (undocumented)
    hasSimpleType(simpleTypeName: string): boolean;
    // (undocumented)
    static is(segment: ISegment): segment is Marker;
    // (undocumented)
    static make(refType: ReferenceType, props?: PropertySet): Marker;
    // (undocumented)
    refType: ReferenceType;
    // (undocumented)
    toJSONObject(): IJSONMarkerSegment;
    // (undocumented)
    toString(): string;
    // (undocumented)
    static readonly type = "Marker";
    // (undocumented)
    readonly type = "Marker";
}

// @public (undocumented)
export function matchProperties(a: PropertySet | undefined, b: PropertySet | undefined): boolean;

// @public (undocumented)
export const MaxNodesInBlock = 8;

// @public (undocumented)
export function maxReferencePosition<T extends ReferencePosition>(a: T, b: T): T;

// @public (undocumented)
export class MergeBlock extends MergeNode implements IMergeBlock {
    constructor(childCount: number);
    // (undocumented)
    assignChild(child: IMergeNode, index: number, updateOrdinal?: boolean): void;
    // (undocumented)
    childCount: number;
    // (undocumented)
    children: IMergeNode[];
    // (undocumented)
    hierBlock(): IHierBlock | undefined;
    // (undocumented)
    setOrdinal(child: IMergeNode, index: number): void;
}

// @public (undocumented)
export class MergeNode implements IMergeNodeCommon {
    // (undocumented)
    cachedLength: number;
    // (undocumented)
    index: number;
    // (undocumented)
    isLeaf(): boolean;
    // (undocumented)
    ordinal: string;
    // (undocumented)
    parent?: IMergeBlock;
}

// Warning: (ae-internal-missing-underscore) The name "MergeTree" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export class MergeTree {
    constructor(options?: PropertySet | undefined);
    ackPendingSegment(opArgs: IMergeTreeDeltaOpArgs): void;
    // (undocumented)
    addMinSeqListener(minRequired: number, onMinGE: (minSeq: number) => void): void;
    annotateRange(start: number, end: number, props: PropertySet, combiningOp: ICombiningOp | undefined, refSeq: number, clientId: number, seq: number, opArgs: IMergeTreeDeltaOpArgs, rollback?: PropertiesRollback): void;
    // (undocumented)
    blockClone(block: IMergeBlock, segments?: ISegment[]): MergeBlock;
    // (undocumented)
    clone(): void;
    // (undocumented)
    readonly collabWindow: CollaborationWindow;
    // (undocumented)
    createLocalReferencePosition(segment: ISegment, offset: number, refType: ReferenceType, properties: PropertySet | undefined): LocalReferencePosition;
    findTile(startPos: number, clientId: number, tileLabel: string, tilePrecedesPos?: boolean): {
        tile: ReferencePosition;
        pos: number;
    } | undefined;
    // (undocumented)
    getCollabWindow(): CollaborationWindow;
    // (undocumented)
    getContainingSegment<T extends ISegment>(pos: number, refSeq: number, clientId: number, localSeq?: number): {
        segment: T | undefined;
        offset: number | undefined;
    };
    // (undocumented)
    getLength(refSeq: number, clientId: number): number;
    // (undocumented)
    getMarkerFromId(id: string): ISegment | undefined;
    // (undocumented)
    getPosition(node: MergeNode, refSeq: number, clientId: number, localSeq?: number): number;
    _getSlideToSegment(segment: ISegment | undefined): ISegment | undefined;
    // @deprecated (undocumented)
    getStackContext(startPos: number, clientId: number, rangeLabels: string[]): RangeStackMap;
    // (undocumented)
    getStats(): MergeTreeStats;
    // @deprecated (undocumented)
    incrementalBlockMap<TContext>(stateStack: Stack<IncrementalMapState<TContext>>): void;
    // (undocumented)
    insertAtReferencePosition(referencePosition: ReferencePosition, insertSegment: ISegment, opArgs: IMergeTreeDeltaOpArgs): void;
    // (undocumented)
    insertSegments(pos: number, segments: ISegment[], refSeq: number, clientId: number, seq: number, opArgs: IMergeTreeDeltaOpArgs | undefined): void;
    get length(): number;
    localNetLength(segment: ISegment, refSeq?: number, localSeq?: number): number;
    // (undocumented)
    map<TClientData>(actions: SegmentActions<TClientData>, refSeq: number, clientId: number, accum: TClientData): void;
    // (undocumented)
    mapIdToSegment(id: string, segment: ISegment): void;
    // (undocumented)
    mapRange<TClientData>(actions: SegmentActions<TClientData>, refSeq: number, clientId: number, accum: TClientData, start?: number, end?: number, splitRange?: boolean): void;
    // (undocumented)
    markRangeRemoved(start: number, end: number, refSeq: number, clientId: number, seq: number, overwrite: boolean | undefined, opArgs: IMergeTreeDeltaOpArgs): void;
    // (undocumented)
    mergeTreeDeltaCallback?: MergeTreeDeltaCallback;
    // (undocumented)
    mergeTreeMaintenanceCallback?: MergeTreeMaintenanceCallback;
    // (undocumented)
    options?: PropertySet | undefined;
    // (undocumented)
    static readonly options: {
        incrementalUpdate: boolean;
        insertAfterRemovedSegs: boolean;
        zamboniSegments: boolean;
    };
    // @deprecated (undocumented)
    pendingSegments: List<SegmentGroup> | undefined;
    posFromRelativePos(relativePos: IRelativePosition, refseq?: number, clientId?: number): number;
    // (undocumented)
    referencePositionToLocalPosition(refPos: ReferencePosition, refSeq?: number, clientId?: number): number;
    // (undocumented)
    reloadFromSegments(segments: ISegment[]): void;
    // (undocumented)
    removeLocalReferencePosition(lref: LocalReferencePosition): LocalReferencePosition | undefined;
    resolveRemoteClientPosition(remoteClientPosition: number, remoteClientRefSeq: number, remoteClientId: number): number | undefined;
    rollback(op: IMergeTreeDeltaOp, localOpMetadata: SegmentGroup): void;
    // (undocumented)
    root: IMergeBlock;
    // (undocumented)
    setMinSeq(minSeq: number): void;
    // (undocumented)
    startCollaboration(localClientId: number, minSeq: number, currentSeq: number): void;
    // (undocumented)
    walkAllSegments<TClientData>(block: IMergeBlock, action: (segment: ISegment, accum?: TClientData) => boolean, accum?: TClientData): boolean;
}

// @public (undocumented)
export type MergeTreeDeltaCallback = (opArgs: IMergeTreeDeltaOpArgs, deltaArgs: IMergeTreeDeltaCallbackArgs) => void;

// @public (undocumented)
export type MergeTreeDeltaOperationType = typeof MergeTreeDeltaType.ANNOTATE | typeof MergeTreeDeltaType.INSERT | typeof MergeTreeDeltaType.REMOVE;

// @public (undocumented)
export type MergeTreeDeltaOperationTypes = MergeTreeDeltaOperationType | MergeTreeMaintenanceType;

// @public (undocumented)
export const MergeTreeDeltaType: {
    readonly INSERT: 0;
    readonly REMOVE: 1;
    readonly ANNOTATE: 2;
    readonly GROUP: 3;
};

// @public (undocumented)
export type MergeTreeDeltaType = typeof MergeTreeDeltaType[keyof typeof MergeTreeDeltaType];

// @public (undocumented)
export type MergeTreeMaintenanceCallback = (MaintenanceArgs: IMergeTreeMaintenanceCallbackArgs, opArgs: IMergeTreeDeltaOpArgs | undefined) => void;

// @public
export const MergeTreeMaintenanceType: {
    readonly APPEND: -1;
    readonly SPLIT: -2;
    readonly UNLINK: -3;
    readonly ACKNOWLEDGED: -4;
};

// @public (undocumented)
export type MergeTreeMaintenanceType = typeof MergeTreeMaintenanceType[keyof typeof MergeTreeMaintenanceType];

// @public (undocumented)
export interface MergeTreeStats {
    // (undocumented)
    histo: number[];
    // (undocumented)
    leafCount: number;
    // (undocumented)
    liveCount: number;
    // (undocumented)
    maxHeight: number;
    // (undocumented)
    maxOrdTime?: number;
    // (undocumented)
    nodeCount: number;
    // (undocumented)
    ordTime?: number;
    // (undocumented)
    packTime?: number;
    // (undocumented)
    removedLeafCount: number;
    // (undocumented)
    windowTime?: number;
}

// Warning: (ae-internal-missing-underscore) The name "MergeTreeTextHelper" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export class MergeTreeTextHelper implements IMergeTreeTextHelper {
    constructor(mergeTree: MergeTree);
    // (undocumented)
    getText(refSeq: number, clientId: number, placeholder?: string, start?: number, end?: number): string;
    // (undocumented)
    getTextAndMarkers(refSeq: number, clientId: number, label: string, start?: number, end?: number): {
        parallelText: string[];
        parallelMarkers: Marker[];
    };
}

// @public (undocumented)
export interface MinListener {
    // (undocumented)
    minRequired: number;
    // (undocumented)
    onMinGE(minSeq: number): void;
}

// @public (undocumented)
export function minReferencePosition<T extends ReferencePosition>(a: T, b: T): T;

// @public (undocumented)
export interface NodeAction<TClientData> {
    // (undocumented)
    (node: IMergeNode, pos: number, refSeq: number, clientId: number, start: number | undefined, end: number | undefined, clientData: TClientData): boolean;
}

// @public (undocumented)
export const NonCollabClient = -2;

// @public (undocumented)
export function ordinalToArray(ord: string): number[];

// @public (undocumented)
export class PropertiesManager {
    constructor();
    // (undocumented)
    ackPendingProperties(annotateOp: IMergeTreeAnnotateMsg): void;
    // (undocumented)
    addProperties(oldProps: PropertySet, newProps: PropertySet, op?: ICombiningOp, seq?: number, collaborating?: boolean, rollback?: PropertiesRollback): PropertySet | undefined;
    // (undocumented)
    copyTo(oldProps: PropertySet, newProps: PropertySet | undefined, newManager: PropertiesManager): PropertySet | undefined;
    // (undocumented)
    hasPendingProperties(): boolean;
}

// @public (undocumented)
export enum PropertiesRollback {
    None = 0,
    Rewrite = 2,
    Rollback = 1
}

// Warning: (ae-internal-missing-underscore) The name "Property" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface Property<TKey, TData> {
    // (undocumented)
    data: TData;
    // (undocumented)
    key: TKey;
}

// Warning: (ae-internal-missing-underscore) The name "PropertyAction" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface PropertyAction<TKey, TData> {
    // (undocumented)
    <TAccum>(p: Property<TKey, TData>, accum?: TAccum): boolean;
}

// @public (undocumented)
export type PropertySet = MapLike<any>;

// Warning: (ae-internal-missing-underscore) The name "ProxString" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export interface ProxString<T> {
    // (undocumented)
    invDistance: number;
    // (undocumented)
    text: string;
    // (undocumented)
    val: T;
}

// Warning: (ae-internal-missing-underscore) The name "QProperty" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface QProperty<TKey, TData> {
    // (undocumented)
    data?: TData;
    // (undocumented)
    key?: TKey;
}

// Warning: (ae-internal-missing-underscore) The name "RangeStackMap" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export type RangeStackMap = MapLike<Stack<ReferencePosition>>;

// Warning: (ae-internal-missing-underscore) The name "RBColor" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const RBColor: {
    readonly RED: 0;
    readonly BLACK: 1;
};

// @internal (undocumented)
export type RBColor = typeof RBColor[keyof typeof RBColor];

// Warning: (ae-internal-missing-underscore) The name "RBNode" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface RBNode<TKey, TData> {
    // (undocumented)
    color: RBColor;
    // (undocumented)
    data: TData;
    // (undocumented)
    key: TKey;
    // (undocumented)
    left: RBNode<TKey, TData> | undefined;
    // (undocumented)
    right: RBNode<TKey, TData> | undefined;
    // (undocumented)
    size: number;
}

// Warning: (ae-internal-missing-underscore) The name "RBNodeActions" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface RBNodeActions<TKey, TData> {
    // (undocumented)
    infix?(node: RBNode<TKey, TData>): boolean;
    // (undocumented)
    post?(node: RBNode<TKey, TData>): boolean;
    // (undocumented)
    pre?(node: RBNode<TKey, TData>): boolean;
    // (undocumented)
    showStructure?: boolean;
}

// Warning: (ae-internal-missing-underscore) The name "RedBlackTree" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class RedBlackTree<TKey, TData> implements SortedDictionary<TKey, TData> {
    constructor(compareKeys: KeyComparer<TKey>, aug?: IRBAugmentation<TKey, TData> | undefined);
    // (undocumented)
    ceil(key: TKey): RBNode<TKey, TData> | undefined;
    // (undocumented)
    floor(key: TKey): RBNode<TKey, TData> | undefined;
    // (undocumented)
    gather(key: TKey, matcher: IRBMatcher<TKey, TData>): RBNode<TKey, TData>[];
    // (undocumented)
    get(key: TKey): RBNode<TKey, TData> | undefined;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    keys(): TKey[];
    // (undocumented)
    map<TAccum>(action: PropertyAction<TKey, TData>, accum?: TAccum): void;
    // (undocumented)
    mapRange<TAccum>(action: PropertyAction<TKey, TData>, accum?: TAccum, start?: TKey, end?: TKey): void;
    // (undocumented)
    max(): RBNode<TKey, TData> | undefined;
    // (undocumented)
    min(): RBNode<TKey, TData> | undefined;
    // (undocumented)
    put(key: TKey, data: TData, conflict?: ConflictAction<TKey, TData>): void;
    // (undocumented)
    remove(key: TKey): void;
    // (undocumented)
    removeExisting(key: TKey): void;
    // (undocumented)
    size(): number;
    walk(actions: RBNodeActions<TKey, TData>): void;
    // (undocumented)
    walkBackward(actions: RBNodeActions<TKey, TData>): void;
    // (undocumented)
    walkExactMatchesBackward(compareFn: (node: RBNode<TKey, TData>) => number, actionFn: (node: RBNode<TKey, TData>) => void, continueLeftFn: (number: number) => boolean, continueRightFn: (number: number) => boolean): void;
    // (undocumented)
    walkExactMatchesForward(compareFn: (node: RBNode<TKey, TData>) => number, actionFn: (node: RBNode<TKey, TData>) => void, continueLeftFn: (number: number) => boolean, continueRightFn: (number: number) => boolean): void;
}

// @public (undocumented)
export interface ReferencePosition {
    // (undocumented)
    addProperties(newProps: PropertySet, op?: ICombiningOp): void;
    // (undocumented)
    getOffset(): number;
    // (undocumented)
    getSegment(): ISegment | undefined;
    // (undocumented)
    isLeaf(): this is ISegment;
    // (undocumented)
    properties?: PropertySet;
    // (undocumented)
    refType: ReferenceType;
}

// @public (undocumented)
export enum ReferenceType {
    // (undocumented)
    NestBegin = 2,
    // (undocumented)
    NestEnd = 4,
    // (undocumented)
    RangeBegin = 16,
    // (undocumented)
    RangeEnd = 32,
    // (undocumented)
    Simple = 0,
    // (undocumented)
    SlideOnRemove = 64,
    // (undocumented)
    StayOnRemove = 128,
    // (undocumented)
    Tile = 1,
    // (undocumented)
    Transient = 256
}

// @public (undocumented)
export const refGetRangeLabels: (refPos: ReferencePosition) => string[] | undefined;

// @public (undocumented)
export const refGetTileLabels: (refPos: ReferencePosition) => string[] | undefined;

// @public (undocumented)
export function refHasRangeLabel(refPos: ReferencePosition, label: string): boolean;

// @public (undocumented)
export function refHasRangeLabels(refPos: ReferencePosition): boolean;

// @public (undocumented)
export function refHasTileLabel(refPos: ReferencePosition, label: string): boolean;

// @public (undocumented)
export function refHasTileLabels(refPos: ReferencePosition): boolean;

// @public (undocumented)
export function refTypeIncludesFlag(refPosOrType: ReferencePosition | ReferenceType, flags: ReferenceType): boolean;

// @public (undocumented)
export const reservedMarkerIdKey = "markerId";

// @public (undocumented)
export const reservedMarkerSimpleTypeKey = "markerSimpleType";

// @public (undocumented)
export const reservedRangeLabelsKey = "referenceRangeLabels";

// @public (undocumented)
export const reservedTileLabelsKey = "referenceTileLabels";

// @public (undocumented)
export interface SearchResult {
    // (undocumented)
    pos: number;
    // (undocumented)
    text: string;
}

// @public (undocumented)
export interface SegmentAccumulator {
    // (undocumented)
    segments: ISegment[];
}

// @public (undocumented)
export interface SegmentActions<TClientData> {
    // (undocumented)
    contains?: NodeAction<TClientData>;
    // (undocumented)
    leaf?: ISegmentAction<TClientData>;
    // (undocumented)
    post?: BlockAction<TClientData>;
    // (undocumented)
    pre?: BlockAction<TClientData>;
    // (undocumented)
    shift?: NodeAction<TClientData>;
}

// @public (undocumented)
export interface SegmentGroup {
    // (undocumented)
    localSeq: number;
    // (undocumented)
    previousProps?: PropertySet[];
    // (undocumented)
    removedReferences?: LocalReferencePosition[];
    // (undocumented)
    segments: ISegment[];
}

// @public (undocumented)
export class SegmentGroupCollection {
    constructor(segment: ISegment);
    // (undocumented)
    clear(): void;
    // (undocumented)
    copyTo(segment: ISegment): void;
    // (undocumented)
    dequeue(): SegmentGroup | undefined;
    // (undocumented)
    get empty(): boolean;
    // (undocumented)
    enqueue(segmentGroup: SegmentGroup): void;
    // (undocumented)
    pop?(): SegmentGroup | undefined;
    // (undocumented)
    get size(): number;
}

// Warning: (ae-internal-missing-underscore) The name "SnapshotLegacy" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export class SnapshotLegacy {
    constructor(mergeTree: MergeTree, logger: ITelemetryLogger, filename?: string | undefined, onCompletion?: (() => void) | undefined);
    // (undocumented)
    static readonly body = "body";
    emit(catchUpMsgs: ISequencedDocumentMessage[], serializer: IFluidSerializer, bind: IFluidHandle): ISummaryTreeWithStats;
    // (undocumented)
    extractSync(): IJSONSegment[];
    // (undocumented)
    filename?: string | undefined;
    // (undocumented)
    static readonly header = "header";
    // (undocumented)
    mergeTree: MergeTree;
    // (undocumented)
    onCompletion?: (() => void) | undefined;
    // (undocumented)
    static readonly sizeOfFirstChunk: number;
}

// Warning: (ae-internal-missing-underscore) The name "SortedDictionary" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface SortedDictionary<TKey, TData> extends Dictionary<TKey, TData> {
    // (undocumented)
    mapRange<TAccum>(action: PropertyAction<TKey, TData>, accum?: TAccum, start?: TKey, end?: TKey): void;
    // (undocumented)
    max(): Property<TKey, TData> | undefined;
    // (undocumented)
    min(): Property<TKey, TData> | undefined;
}

// @public
export class SortedSegmentSet<T extends ISegment | {
    readonly segment: ISegment;
} = ISegment> {
    // (undocumented)
    addOrUpdate(newItem: T, update?: (existingItem: T, newItem: T) => T): void;
    // (undocumented)
    has(item: T): boolean;
    // (undocumented)
    get items(): readonly T[];
    // (undocumented)
    remove(item: T): boolean;
    // (undocumented)
    get size(): number;
}

// Warning: (ae-internal-missing-underscore) The name "Stack" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export class Stack<T> {
    // (undocumented)
    empty(): boolean;
    // (undocumented)
    items: T[];
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    push(val: T): void;
    // (undocumented)
    top(): T | undefined;
}

// @public (undocumented)
export class TextSegment extends BaseSegment {
    constructor(text: string);
    // (undocumented)
    append(segment: ISegment): void;
    // (undocumented)
    canAppend(segment: ISegment): boolean;
    // (undocumented)
    clone(start?: number, end?: number): TextSegment;
    // (undocumented)
    protected createSplitSegmentAt(pos: number): TextSegment | undefined;
    // (undocumented)
    static fromJSONObject(spec: any): TextSegment | undefined;
    // (undocumented)
    static is(segment: ISegment): segment is TextSegment;
    // (undocumented)
    static make(text: string, props?: PropertySet): TextSegment;
    // (undocumented)
    removeRange(start: number, end: number): boolean;
    // (undocumented)
    text: string;
    // (undocumented)
    toJSONObject(): string | {
        text: string;
        props: PropertySet;
    };
    // (undocumented)
    toString(): string;
    // (undocumented)
    static readonly type = "TextSegment";
    // (undocumented)
    readonly type = "TextSegment";
}

// @public (undocumented)
export function toRemovalInfo(maybe: Partial<IRemovalInfo> | undefined): IRemovalInfo | undefined;

// @public (undocumented)
export class TrackingGroup {
    constructor();
    // (undocumented)
    has(segment: ISegment): boolean;
    // (undocumented)
    link(segment: ISegment): void;
    // (undocumented)
    get segments(): readonly ISegment[];
    // (undocumented)
    get size(): number;
    // (undocumented)
    unlink(segment: ISegment): void;
}

// @public (undocumented)
export class TrackingGroupCollection {
    constructor(segment: ISegment);
    // (undocumented)
    copyTo(segment: ISegment): void;
    // (undocumented)
    get empty(): boolean;
    // (undocumented)
    link(trackingGroup: TrackingGroup): void;
    // (undocumented)
    matches(trackingCollection: TrackingGroupCollection): boolean;
    // (undocumented)
    readonly trackingGroups: Set<TrackingGroup>;
    // (undocumented)
    unlink(trackingGroup: TrackingGroup): void;
}

// @public (undocumented)
export const TreeMaintenanceSequenceNumber = -2;

// Warning: (ae-internal-missing-underscore) The name "TST" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export class TST<T> {
    // (undocumented)
    get(key: string): T | undefined;
    // (undocumented)
    keysWithPrefix(text: string): string[];
    // (undocumented)
    map(fn: (key: string, val: T) => void): void;
    // (undocumented)
    neighbors(text: string, distance?: number): ProxString<T>[];
    // (undocumented)
    pairsWithPrefix(text: string): TSTResult<T>[];
    // (undocumented)
    put(key: string, val: T): void;
    // (undocumented)
    size(): number;
}

// Warning: (ae-internal-missing-underscore) The name "TSTNode" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export interface TSTNode<T> {
    // (undocumented)
    c: string;
    // (undocumented)
    left?: TSTNode<T>;
    // (undocumented)
    mid?: TSTNode<T>;
    // (undocumented)
    right?: TSTNode<T>;
    // (undocumented)
    val?: T;
}

// Warning: (ae-internal-missing-underscore) The name "TSTResult" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export interface TSTResult<T> {
    // (undocumented)
    key: string;
    // (undocumented)
    val: T;
}

// @public (undocumented)
export const UnassignedSequenceNumber = -1;

// @public
export const UniversalSequenceNumber = 0;

// (No @packageDocumentation comment for this package)

```
