## API Report File for "@fluid-internal/tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { IChannelAttributes } from '@fluidframework/datastore-definitions';
import { IChannelFactory } from '@fluidframework/datastore-definitions';
import { IChannelServices } from '@fluidframework/datastore-definitions';
import { IFluidDataStoreRuntime } from '@fluidframework/datastore-definitions';
import { ISharedObject } from '@fluidframework/shared-object-base';
import { IsoBuffer } from '@fluidframework/common-utils';
import { Serializable } from '@fluidframework/datastore-definitions';

// @public
export type Anchor = Brand<number, "rebaser.Anchor">;

// @public
export interface AnchorLocator {
    locate(anchor: Anchor): UpPath | undefined;
}

// @public @sealed
export class AnchorSet {
    applyDelta(delta: Delta.Root): void;
    // (undocumented)
    forget(anchor: Anchor): void;
    isEmpty(): boolean;
    // (undocumented)
    locate(anchor: Anchor): UpPath | undefined;
    moveChildren(count: number, srcStart: UpPath | undefined, dst: UpPath | undefined): void;
    track(path: UpPath | null): Anchor;
}

// @public (undocumented)
type Attach<TNodeChange = NodeChangeType> = Insert_2 | ModifyInsert<TNodeChange> | MoveIn_2 | ModifyMoveIn<TNodeChange> | Reattach | ModifyReattach<TNodeChange>;

// @public
export type Brand<ValueType, Name extends string> = ValueType & BrandedType<ValueType, Name>;

// @public
export function brand<T extends Brand<any, string>>(value: T extends BrandedType<infer ValueType, string> ? ValueType : never): T;

// @public @sealed
export abstract class BrandedType<ValueType, Name extends string> {
    protected readonly _type_brand: Name;
    // (undocumented)
    protected _typeCheck?: Invariant<ValueType>;
}

// @public
export function brandOpaque<T extends BrandedType<any, string>>(value: isAny<ValueFromBranded<T>> extends true ? never : ValueFromBranded<T>): BrandedType<ValueFromBranded<T>, NameFromBranded<T>>;

// @public (undocumented)
export function buildForest(schema: StoredSchemaRepository, anchors?: AnchorSet): IEditableForest;

// @public
export abstract class ChangeEncoder<TChange> {
    decodeBinary(formatVersion: number, change: IsoBuffer): TChange;
    abstract decodeJson(formatVersion: number, change: JsonCompatibleReadOnly): TChange;
    encodeBinary(formatVersion: number, change: TChange): IsoBuffer;
    abstract encodeForJson(formatVersion: number, change: TChange): JsonCompatibleReadOnly;
}

// @public (undocumented)
export interface ChangeFamily<TEditor, TChange> {
    // (undocumented)
    buildEditor(changeReceiver: (change: TChange) => void, anchorSet: AnchorSet): TEditor;
    // (undocumented)
    readonly encoder: ChangeEncoder<TChange>;
    // (undocumented)
    intoDelta(change: TChange, repairStore?: ReadonlyRepairDataStore): Delta.Root;
    // (undocumented)
    readonly rebaser: ChangeRebaser<TChange>;
}

// @public
export interface ChangeRebaser<TChangeset> {
    compose(changes: TaggedChange<TChangeset>[]): TChangeset;
    // (undocumented)
    invert(changes: TaggedChange<TChangeset>): TChangeset;
    rebase(change: TChangeset, over: TaggedChange<TChangeset>): TChangeset;
    // (undocumented)
    rebaseAnchors(anchors: AnchorSet, over: TChangeset): void;
    // (undocumented)
    _typeCheck?: Invariant<TChangeset>;
}

// @public (undocumented)
type Changeset<TNodeChange = NodeChangeType> = MarkList_2<TNodeChange>;

// @public
export type ChangesetLocalId = Brand<number, "ChangesetLocalId">;

// @public
export type ChildCollection = FieldKey | RootField;

// @public
export interface ChildLocation {
    // (undocumented)
    readonly container: ChildCollection;
    // (undocumented)
    readonly index: number;
}

// @public (undocumented)
type ClientId = number;

// @public
function compose<TNodeChange>(changes: TaggedChange<Changeset<TNodeChange>>[], composeChild: NodeChangeComposer_2<TNodeChange>): Changeset<TNodeChange>;

// @public
export interface Contravariant<T> {
    // (undocumented)
    _removeCovariance?: (_: T) => void;
}

// @public
export interface Covariant<T> {
    // (undocumented)
    _removeContravariance?: T;
}

// @public
export const createField: unique symbol;

// @public (undocumented)
export const enum CursorLocationType {
    Fields = 1,
    Nodes = 0
}

// @public
export function cursorToJsonObject(reader: ITreeCursor): JsonCompatible;

// @public (undocumented)
function decodeJson<TNodeChange>(formatVersion: number, change: JsonCompatibleReadOnly, decodeChild: NodeChangeDecoder_2<TNodeChange>): Changeset<TNodeChange>;

// @public
export const defaultSchemaPolicy: FullSchemaPolicy;

// @public
interface Delete {
    // (undocumented)
    count: number;
    // (undocumented)
    type: typeof MarkType.Delete;
}

// @public (undocumented)
interface Delete_2 extends HasRevisionTag {
    // (undocumented)
    count: NodeCount;
    // (undocumented)
    tomb?: RevisionTag;
    // (undocumented)
    type: "Delete";
}

declare namespace Delta {
    export {
        inputLength,
        isSkipMark,
        Root,
        empty,
        ProtoNode,
        Mark,
        MarkList,
        Skip,
        Modify,
        Delete,
        ModifyAndDelete,
        MoveOut,
        ModifyAndMoveOut,
        MoveIn,
        MoveInAndModify,
        Insert,
        InsertAndModify,
        MoveId,
        Offset,
        FieldMap,
        FieldMarks,
        MarkType
    }
}
export { Delta }

// @public
export interface Dependee extends NamedComputation {
    registerDependent(dependent: Dependent): boolean;
    removeDependent(dependent: Dependent): void;
}

// @public
export interface Dependent extends NamedComputation {
    markInvalid(token?: InvalidationToken): void;
}

// @public (undocumented)
type Detach = Delete_2 | MoveOut_2;

// @public
export interface DetachedField extends Opaque<Brand<string, "tree.DetachedField">> {
}

// @public
export interface EditableField extends ArrayLike<UnwrappedEditableTree> {
    readonly [proxyTargetSymbol]: object;
    [Symbol.iterator](): IterableIterator<UnwrappedEditableTree>;
    [index: number]: UnwrappedEditableTree;
    deleteNodes(index: number, count?: number): void;
    readonly fieldKey: FieldKey;
    readonly fieldSchema: FieldSchema;
    getNode(index: number): EditableTree;
    insertNodes(index: number, newContent: ITreeCursor | ITreeCursor[]): void;
    readonly primaryType?: TreeSchemaIdentifier;
}

// @public
export interface EditableTree extends Iterable<EditableField> {
    [createField](fieldKey: FieldKey, newContent: ITreeCursor | ITreeCursor[]): void;
    [getField](fieldKey: FieldKey): EditableField;
    readonly [indexSymbol]: number;
    readonly [proxyTargetSymbol]: object;
    [Symbol.iterator](): IterableIterator<EditableField>;
    readonly [typeNameSymbol]: TreeSchemaIdentifier;
    readonly [typeSymbol]: TreeSchema;
    [valueSymbol]: Value;
    [key: FieldKey]: UnwrappedEditableField;
}

// @public
export interface EditableTreeContext {
    attachAfterChangeHandler(afterChangeHandler: (context: EditableTreeContext) => void): void;
    clear(): void;
    free(): void;
    prepareForEdit(): void;
    readonly root: EditableField;
    readonly schema: SchemaDataAndPolicy;
    readonly unwrappedRoot: UnwrappedEditableField;
}

// @public
export type EditableTreeOrPrimitive = EditableTree | PrimitiveValue;

// @public (undocumented)
enum Effects {
    // (undocumented)
    All = "All",
    // (undocumented)
    Delete = "Delete",
    // (undocumented)
    Move = "Move",
    // (undocumented)
    None = "None"
}

// @public (undocumented)
const empty: Root<any>;

// @public
export const emptyField: FieldSchema;

// @public
export const EmptyKey: LocalFieldKey;

// @public (undocumented)
function encodeForJson<TNodeChange>(formatVersion: number, markList: Changeset<TNodeChange>, encodeChild: NodeChangeEncoder_2<TNodeChange>): JsonCompatibleReadOnly;

// @public
export type ExtractFromOpaque<TOpaque extends BrandedType<any, string>> = TOpaque extends BrandedType<infer ValueType, infer Name> ? isAny<ValueType> extends true ? unknown : Brand<ValueType, Name> : never;

// @public
export function extractFromOpaque<TOpaque extends BrandedType<any, string>>(value: TOpaque): ExtractFromOpaque<TOpaque>;

// @public
export interface FieldAnchor {
    // (undocumented)
    fieldKey: FieldKey;
    parent: Anchor | undefined;
}

// @public (undocumented)
export interface FieldChange {
    // (undocumented)
    change: FieldChangeset;
    // (undocumented)
    fieldKind: FieldKindIdentifier;
    revision?: RevisionTag;
}

// @public (undocumented)
export interface FieldChangeEncoder<TChangeset> {
    decodeJson(formatVersion: number, change: JsonCompatibleReadOnly, decodeChild: NodeChangeDecoder): TChangeset;
    encodeForJson(formatVersion: number, change: TChangeset, encodeChild: NodeChangeEncoder): JsonCompatibleReadOnly;
}

// @public
export interface FieldChangeHandler<TChangeset, TEditor extends FieldEditor<TChangeset> = FieldEditor<TChangeset>> {
    // (undocumented)
    editor: TEditor;
    // (undocumented)
    encoder: FieldChangeEncoder<TChangeset>;
    // (undocumented)
    intoDelta(change: TChangeset, deltaFromChild: ToDelta, reviver: NodeReviver): Delta.MarkList;
    // (undocumented)
    rebaser: FieldChangeRebaser<TChangeset>;
    // (undocumented)
    _typeCheck?: Invariant<TChangeset>;
}

// @public (undocumented)
export type FieldChangeMap = Map<FieldKey, FieldChange>;

// @public (undocumented)
export interface FieldChangeRebaser<TChangeset> {
    compose(changes: TaggedChange<TChangeset>[], composeChild: NodeChangeComposer, genId: IdAllocator): TChangeset;
    // (undocumented)
    invert(change: TaggedChange<TChangeset>, invertChild: NodeChangeInverter, genId: IdAllocator): TChangeset;
    rebase(change: TChangeset, over: TaggedChange<TChangeset>, rebaseChild: NodeChangeRebaser, genId: IdAllocator): TChangeset;
}

// @public (undocumented)
export type FieldChangeset = Brand<unknown, "FieldChangeset">;

// @public (undocumented)
export interface FieldEditor<TChangeset> {
    buildChildChange(childIndex: number, change: NodeChangeset): TChangeset;
}

// @public
export type FieldKey = LocalFieldKey | GlobalFieldKeySymbol;

// @public @sealed
export class FieldKind<TEditor extends FieldEditor<any> = FieldEditor<any>> {
    constructor(identifier: FieldKindIdentifier, multiplicity: Multiplicity, changeHandler: FieldChangeHandler<any, TEditor>, allowsTreeSupersetOf: (originalTypes: ReadonlySet<TreeSchemaIdentifier> | undefined, superset: FieldSchema) => boolean, handlesEditsFrom: ReadonlySet<FieldKindIdentifier>);
    // (undocumented)
    allowsFieldSuperset(policy: FullSchemaPolicy, originalData: SchemaData, originalTypes: ReadonlySet<TreeSchemaIdentifier> | undefined, superset: FieldSchema): boolean;
    // (undocumented)
    readonly changeHandler: FieldChangeHandler<any, TEditor>;
    // (undocumented)
    readonly handlesEditsFrom: ReadonlySet<FieldKindIdentifier>;
    // (undocumented)
    readonly identifier: FieldKindIdentifier;
    // (undocumented)
    readonly multiplicity: Multiplicity;
}

// @public
export type FieldKindIdentifier = Brand<string, "tree.FieldKindIdentifier">;

// @public
export interface FieldLocation {
    // (undocumented)
    readonly key: FieldKey;
    // (undocumented)
    readonly parent: ForestLocation;
}

// @public (undocumented)
type FieldMap<T> = Map<FieldKey, T>;

// @public
export interface FieldMapObject<TChild> {
    // (undocumented)
    [key: string]: TChild[];
}

// @public (undocumented)
type FieldMarks<TTree = ProtoNode> = FieldMap<MarkList<TTree>>;

// @public (undocumented)
export interface FieldSchema {
    // (undocumented)
    readonly kind: FieldKindIdentifier;
    readonly types?: TreeTypeSet;
}

// @public
export const enum FieldScope {
    // (undocumented)
    global = "globalFields",
    // (undocumented)
    local = "fields"
}

// @public
export interface FieldUpPath {
    readonly field: FieldKey;
    readonly parent: UpPath | undefined;
}

// @public
export type ForestLocation = ITreeSubscriptionCursor | Anchor;

// @public
export interface FullSchemaPolicy extends SchemaPolicy {
    readonly fieldKinds: ReadonlyMap<FieldKindIdentifier, FieldKind>;
}

// @public (undocumented)
type GapCount = number;

// @public
export interface GenericFieldsNode<TChild> {
    // (undocumented)
    [FieldScope.local]?: FieldMapObject<TChild>;
    // (undocumented)
    [FieldScope.global]?: FieldMapObject<TChild>;
}

// @public
export interface GenericTreeNode<TChild> extends GenericFieldsNode<TChild>, NodeData {
}

// @public
export const getField: unique symbol;

// @public (undocumented)
export function getPrimaryField(schema: TreeSchema): {
    key: LocalFieldKey;
    schema: FieldSchema;
} | undefined;

// @public
export type GlobalFieldKey = Brand<string, "tree.GlobalFieldKey">;

// @public
export type GlobalFieldKeySymbol = Brand<symbol, "GlobalFieldKeySymbol">;

// @public (undocumented)
interface HasChanges<TNodeChange> {
    // (undocumented)
    changes: TNodeChange;
}

// @public (undocumented)
interface HasLength {
    length?: number;
}

// @public (undocumented)
interface HasMoveId {
    id: MoveId_2;
}

// @public (undocumented)
interface HasPlaceFields {
    heed?: Effects | [Effects, Effects];
    lineage?: LineageEvent[];
}

// @public (undocumented)
interface HasReattachFields extends HasPlaceFields {
    detachedBy: RevisionTag | undefined;
    detachIndex: number;
}

// @public (undocumented)
interface HasRevisionTag {
    revision?: RevisionTag;
}

// @public (undocumented)
interface HasTiebreakPolicy extends HasPlaceFields {
    tiebreak?: Tiebreak;
}

// @public (undocumented)
export interface ICheckout<TEditBuilder> {
    readonly forest: IForestSubscription;
    runTransaction(transaction: (forest: IForestSubscription, editor: TEditBuilder) => TransactionResult): TransactionResult;
}

// @public (undocumented)
export type IdAllocator = () => ChangesetLocalId;

// @public
export interface IDefaultEditBuilder {
    // (undocumented)
    optionalField(parent: UpPath | undefined, field: FieldKey): OptionalFieldEditBuilder;
    // (undocumented)
    sequenceField(parent: UpPath | undefined, field: FieldKey): SequenceFieldEditBuilder;
    // (undocumented)
    setValue(path: UpPath, value: Value): void;
    // (undocumented)
    valueField(parent: UpPath | undefined, field: FieldKey): ValueFieldEditBuilder;
}

// @public
export interface IEditableForest extends IForestSubscription {
    readonly anchors: AnchorSet;
    applyDelta(delta: Delta.Root): void;
}

// @public
export interface IForestSubscription extends Dependee {
    allocateCursor(): ITreeSubscriptionCursor;
    clone(schema: StoredSchemaRepository, anchors: AnchorSet): IEditableForest;
    forgetAnchor(anchor: Anchor): void;
    readonly schema: StoredSchemaRepository;
    tryMoveCursorToField(destination: FieldAnchor, cursorToMove: ITreeSubscriptionCursor): TreeNavigationResult;
    tryMoveCursorToNode(destination: Anchor, cursorToMove: ITreeSubscriptionCursor): TreeNavigationResult;
}

// @public
export const indexSymbol: unique symbol;

// @public
function inputLength(mark: Mark<unknown>): number;

// @public
interface Insert<TTree = ProtoNode> {
    // (undocumented)
    content: TTree[];
    // (undocumented)
    type: typeof MarkType.Insert;
}

// @public (undocumented)
interface Insert_2 extends HasTiebreakPolicy, HasRevisionTag {
    // (undocumented)
    content: ProtoNode_2[];
    // (undocumented)
    type: "Insert";
}

// @public
interface InsertAndModify<TTree = ProtoNode> {
    // (undocumented)
    content: TTree;
    // (undocumented)
    fields: FieldMarks<TTree>;
    // (undocumented)
    type: typeof MarkType.InsertAndModify;
}

// @public
export class InvalidationToken {
    constructor(description: string, isSecondaryInvalidation?: boolean);
    // (undocumented)
    readonly description: string;
    // (undocumented)
    readonly isSecondaryInvalidation: boolean;
    // (undocumented)
    protected readonly _typeCheck: MakeNominal;
}

// @public
export interface Invariant<T> extends Contravariant<T>, Covariant<T> {
}

// @public
function invert<TNodeChange>(change: TaggedChange<Changeset<TNodeChange>>, invertChild: NodeChangeInverter_2<TNodeChange>): Changeset<TNodeChange>;

// @public
export type isAny<T> = boolean extends (T extends {} ? true : false) ? true : false;

// @public
export function isEditableField(field: UnwrappedEditableField): field is EditableField;

// @public
export interface ISharedTree extends ICheckout<IDefaultEditBuilder>, ISharedObject, AnchorLocator {
    readonly context: EditableTreeContext;
    readonly root: UnwrappedEditableField;
    readonly storedSchema: StoredSchemaRepository;
}

// @public (undocumented)
export function isNeverField(policy: FullSchemaPolicy, originalData: SchemaData, field: FieldSchema): boolean;

// @public (undocumented)
export function isPrimitive(schema: TreeSchema): boolean;

// @public (undocumented)
export function isPrimitiveValue(nodeValue: Value): nodeValue is PrimitiveValue;

// @public (undocumented)
function isSkipMark(mark: Mark<unknown>): mark is Skip;

// @public
export function isUnwrappedNode(field: UnwrappedEditableField): field is EditableTree;

// @public
export interface ITreeCursor {
    readonly chunkLength: number;
    readonly chunkStart: number;
    enterField(key: FieldKey): void;
    enterNode(childIndex: number): void;
    exitField(): void;
    exitNode(): void;
    readonly fieldIndex: number;
    firstField(): boolean;
    firstNode(): boolean;
    getFieldKey(): FieldKey;
    // (undocumented)
    getFieldLength(): number;
    // (undocumented)
    getFieldPath(): FieldUpPath;
    // (undocumented)
    getPath(): UpPath | undefined;
    readonly mode: CursorLocationType;
    nextField(): boolean;
    nextNode(): boolean;
    // (undocumented)
    readonly pending: boolean;
    seekNodes(offset: number): boolean;
    skipPendingFields(): boolean;
    readonly type: TreeType;
    readonly value: Value;
}

// @public
export interface ITreeCursorSynchronous extends ITreeCursor {
    // (undocumented)
    readonly pending: false;
}

// @public
export interface ITreeSubscriptionCursor extends ITreeCursor {
    buildAnchor(): Anchor;
    buildFieldAnchor(): FieldAnchor;
    clear(): void;
    // (undocumented)
    fork(): ITreeSubscriptionCursor;
    free(): void;
    readonly state: ITreeSubscriptionCursorState;
}

// @public (undocumented)
export enum ITreeSubscriptionCursorState {
    Cleared = 1,
    Current = 0,
    Freed = 2
}

// @public
export interface JsonableTree extends GenericTreeNode<JsonableTree> {
}

// @public
export function jsonableTreeFromCursor(cursor: ITreeCursor): JsonableTree;

// @public (undocumented)
export const jsonArray: NamedTreeSchema;

// @public (undocumented)
export const jsonBoolean: NamedTreeSchema;

// @public
export type JsonCompatible = string | number | boolean | null | JsonCompatible[] | JsonCompatibleObject;

// @public
export type JsonCompatibleObject = {
    [P in string]: JsonCompatible;
};

// @public
export type JsonCompatibleReadOnly = string | number | boolean | null | readonly JsonCompatibleReadOnly[] | {
    readonly [P in string]: JsonCompatibleReadOnly | undefined;
};

// @public (undocumented)
export const jsonNull: NamedTreeSchema;

// @public (undocumented)
export const jsonNumber: NamedTreeSchema;

// @public (undocumented)
export const jsonObject: NamedTreeSchema;

// @public (undocumented)
export const jsonSchemaData: SchemaData;

// @public (undocumented)
export const jsonString: NamedTreeSchema;

// @public (undocumented)
export function keyFromSymbol(key: GlobalFieldKeySymbol): GlobalFieldKey;

// @public
interface LineageEvent {
    readonly offset: number;
    // (undocumented)
    readonly revision: RevisionTag;
}

// @public
export type LocalFieldKey = Brand<string, "tree.LocalFieldKey">;

// @public
export interface MakeNominal {
}

// @public
type Mark<TTree = ProtoNode> = Skip | Modify<TTree> | Delete | MoveOut | MoveIn | Insert<TTree> | ModifyAndDelete<TTree> | ModifyAndMoveOut<TTree> | MoveInAndModify<TTree> | InsertAndModify<TTree>;

// @public (undocumented)
type Mark_2<TNodeChange = NodeChangeType> = SizedMark<TNodeChange> | Attach<TNodeChange>;

// @public
type MarkList<TTree = ProtoNode> = Mark<TTree>[];

// @public (undocumented)
type MarkList_2<TNodeChange = NodeChangeType, TMark = Mark_2<TNodeChange>> = TMark[];

// @public
class MarkListFactory<TNodeChange> {
    // (undocumented)
    readonly list: MarkList_2<TNodeChange>;
    // (undocumented)
    push(...marks: Mark_2<TNodeChange>[]): void;
    // (undocumented)
    pushContent(mark: ObjectMark<TNodeChange>): void;
    // (undocumented)
    pushOffset(offset: Skip_2): void;
}

// @public (undocumented)
const MarkType: {
    readonly Modify: 0;
    readonly Insert: 1;
    readonly InsertAndModify: 2;
    readonly MoveIn: 3;
    readonly MoveInAndModify: 4;
    readonly Delete: 5;
    readonly ModifyAndDelete: 6;
    readonly MoveOut: 7;
    readonly ModifyAndMoveOut: 8;
};

// @public
interface Modify<TTree = ProtoNode> {
    // (undocumented)
    fields?: FieldMarks<TTree>;
    // (undocumented)
    setValue?: Value;
    // (undocumented)
    type: typeof MarkType.Modify;
}

// @public (undocumented)
interface Modify_2<TNodeChange = NodeChangeType> extends HasChanges<TNodeChange>, HasRevisionTag {
    // (undocumented)
    tomb?: RevisionTag;
    // (undocumented)
    type: "Modify";
}

// @public
interface ModifyAndDelete<TTree = ProtoNode> {
    // (undocumented)
    fields: FieldMarks<TTree>;
    // (undocumented)
    type: typeof MarkType.ModifyAndDelete;
}

// @public
interface ModifyAndMoveOut<TTree = ProtoNode> {
    // (undocumented)
    fields?: FieldMarks<TTree>;
    moveId: MoveId;
    // (undocumented)
    setValue?: Value;
    // (undocumented)
    type: typeof MarkType.ModifyAndMoveOut;
}

// @public (undocumented)
interface ModifyDelete<TNodeChange = NodeChangeType> extends HasRevisionTag, HasChanges<TNodeChange> {
    // (undocumented)
    tomb?: RevisionTag;
    // (undocumented)
    type: "MDelete";
}

// @public (undocumented)
type ModifyDetach<TNodeChange> = ModifyDelete<TNodeChange> | ModifyMoveOut<TNodeChange>;

// @public (undocumented)
interface ModifyInsert<TNodeChange = NodeChangeType> extends HasTiebreakPolicy, HasRevisionTag, HasChanges<TNodeChange> {
    // (undocumented)
    content: ProtoNode_2;
    // (undocumented)
    type: "MInsert";
}

// @public (undocumented)
interface ModifyMoveIn<TNodeChange = NodeChangeType> extends HasMoveId, HasPlaceFields, HasRevisionTag, HasChanges<TNodeChange> {
    // (undocumented)
    type: "MMoveIn";
}

// @public (undocumented)
interface ModifyMoveOut<TNodeChange = NodeChangeType> extends HasMoveId, HasRevisionTag, HasChanges<TNodeChange> {
    // (undocumented)
    tomb?: RevisionTag;
    // (undocumented)
    type: "MMoveOut";
}

// @public (undocumented)
interface ModifyReattach<TNodeChange = NodeChangeType> extends HasReattachFields, HasRevisionTag, HasChanges<TNodeChange> {
    // (undocumented)
    type: "MRevive" | "MReturn";
}

// @public @sealed
export class ModularChangeFamily implements ChangeFamily<ModularEditBuilder, ModularChangeset>, ChangeRebaser<ModularChangeset> {
    constructor(fieldKinds: ReadonlyMap<FieldKindIdentifier, FieldKind>);
    // (undocumented)
    buildEditor(changeReceiver: (change: ModularChangeset) => void, anchors: AnchorSet): ModularEditBuilder;
    // (undocumented)
    compose(changes: TaggedChange<ModularChangeset>[]): ModularChangeset;
    // (undocumented)
    readonly encoder: ChangeEncoder<ModularChangeset>;
    // (undocumented)
    readonly fieldKinds: ReadonlyMap<FieldKindIdentifier, FieldKind>;
    // (undocumented)
    intoDelta(change: ModularChangeset, repairStore?: ReadonlyRepairDataStore): Delta.Root;
    // (undocumented)
    invert(change: TaggedChange<ModularChangeset>): ModularChangeset;
    // (undocumented)
    rebase(change: ModularChangeset, over: TaggedChange<ModularChangeset>): ModularChangeset;
    // (undocumented)
    rebaseAnchors(anchors: AnchorSet, over: ModularChangeset): void;
    // (undocumented)
    get rebaser(): ChangeRebaser<ModularChangeset>;
}

// @public (undocumented)
export interface ModularChangeset {
    // (undocumented)
    changes: FieldChangeMap;
    maxId?: ChangesetLocalId;
}

// @public @sealed (undocumented)
export class ModularEditBuilder extends ProgressiveEditBuilderBase<ModularChangeset> implements ProgressiveEditBuilder<ModularChangeset> {
    constructor(family: ChangeFamily<unknown, ModularChangeset>, changeReceiver: (change: ModularChangeset) => void, anchors: AnchorSet);
    // (undocumented)
    apply(change: ModularChangeset): void;
    // (undocumented)
    setValue(path: UpPath, value: Value): void;
    submitChange(path: UpPath | undefined, field: FieldKey, fieldKind: FieldKindIdentifier, change: FieldChangeset, maxId?: ChangesetLocalId): void;
}

// @public
interface MoveId extends Opaque<Brand<number, "delta.MoveId">> {
}

// @public
type MoveId_2 = number;

// @public
interface MoveIn {
    moveId: MoveId;
    // (undocumented)
    type: typeof MarkType.MoveIn;
}

// @public (undocumented)
interface MoveIn_2 extends HasMoveId, HasPlaceFields, HasRevisionTag {
    count: NodeCount;
    // (undocumented)
    type: "MoveIn";
}

// @public
interface MoveInAndModify<TTree = ProtoNode> {
    // (undocumented)
    fields: FieldMarks<TTree>;
    moveId: MoveId;
    // (undocumented)
    type: typeof MarkType.MoveInAndModify;
}

// @public
interface MoveOut {
    // (undocumented)
    count: number;
    moveId: MoveId;
    // (undocumented)
    type: typeof MarkType.MoveOut;
}

// @public (undocumented)
interface MoveOut_2 extends HasRevisionTag, HasMoveId {
    // (undocumented)
    count: NodeCount;
    // (undocumented)
    tomb?: RevisionTag;
    // (undocumented)
    type: "MoveOut";
}

// @public
export enum Multiplicity {
    Forbidden = 3,
    Optional = 1,
    Sequence = 2,
    Value = 0
}

// @public (undocumented)
export interface Named<TName> {
    // (undocumented)
    readonly name: TName;
}

// @public
export interface NamedComputation {
    readonly computationName: string;
    listDependees?(): Iterable<Dependee>;
    listDependents?(): Iterable<Dependent>;
}

// @public (undocumented)
export type NamedTreeSchema = TreeSchema & Named<TreeSchemaIdentifier>;

// @public
export type NameFromBranded<T extends BrandedType<any, string>> = T extends BrandedType<any, infer Name> ? Name : never;

// @public
export const neverTree: TreeSchema;

// @public (undocumented)
export type NodeChangeComposer = (changes: TaggedChange<NodeChangeset>[]) => NodeChangeset;

// @public (undocumented)
type NodeChangeComposer_2<TNodeChange> = (changes: TaggedChange<TNodeChange>[]) => TNodeChange;

// @public (undocumented)
export type NodeChangeDecoder = (change: JsonCompatibleReadOnly) => NodeChangeset;

// @public (undocumented)
type NodeChangeDecoder_2<TNodeChange> = (change: JsonCompatibleReadOnly) => TNodeChange;

// @public (undocumented)
export type NodeChangeEncoder = (change: NodeChangeset) => JsonCompatibleReadOnly;

// @public (undocumented)
type NodeChangeEncoder_2<TNodeChange> = (change: TNodeChange) => JsonCompatibleReadOnly;

// @public (undocumented)
export type NodeChangeInverter = (change: NodeChangeset) => NodeChangeset;

// @public (undocumented)
type NodeChangeInverter_2<TNodeChange> = (change: TNodeChange) => TNodeChange;

// @public (undocumented)
export type NodeChangeRebaser = (change: NodeChangeset, baseChange: NodeChangeset) => NodeChangeset;

// @public (undocumented)
type NodeChangeRebaser_2<TNodeChange> = (change: TNodeChange, baseChange: TNodeChange) => TNodeChange;

// @public
export interface NodeChangeset {
    // (undocumented)
    fieldChanges?: FieldChangeMap;
    // (undocumented)
    valueChange?: ValueChange;
}

// @public (undocumented)
type NodeChangeType = NodeChangeset;

// @public (undocumented)
type NodeCount = number;

// @public
export interface NodeData {
    readonly type: TreeSchemaIdentifier;
    value?: TreeValue;
}

// @public (undocumented)
export type NodeReviver = (revision: RevisionTag, index: number, count: number) => Delta.ProtoNode[];

// @public (undocumented)
type ObjectMark<TNodeChange = NodeChangeType> = SizedObjectMark<TNodeChange> | Attach<TNodeChange>;

// @public
export interface ObservingDependent extends Dependent {
    // @override
    listDependees(): Iterable<Dependee>;
    registerDependee(dependee: Dependee): void;
}

// @public (undocumented)
type Offset = number;

// @public
export type Opaque<T extends Brand<any, string>> = T extends Brand<infer ValueType, infer Name> ? BrandedType<ValueType, Name> : never;

// @public (undocumented)
export interface OptionalFieldEditBuilder {
    set(newContent: ITreeCursor | undefined, wasEmpty: boolean): void;
}

// @public (undocumented)
export type PrimitiveValue = string | boolean | number;

// @public (undocumented)
interface PriorOp {
    // (undocumented)
    change: RevisionTag;
}

// @public (undocumented)
export interface ProgressiveEditBuilder<TChange> {
    // (undocumented)
    getChanges(): TChange[];
}

// @public (undocumented)
export abstract class ProgressiveEditBuilderBase<TChange> implements ProgressiveEditBuilder<TChange> {
    constructor(changeFamily: ChangeFamily<unknown, TChange>, changeReceiver: (change: TChange) => void, anchorSet: AnchorSet);
    // @sealed
    protected applyChange(change: TChange): void;
    // @sealed (undocumented)
    getChanges(): TChange[];
}

// @public
type ProtoNode = ITreeCursorSynchronous;

// @public
type ProtoNode_2 = JsonableTree;

// @public
export const proxyTargetSymbol: unique symbol;

// @public (undocumented)
enum RangeType {
    // (undocumented)
    Set = "Set",
    // (undocumented)
    Slice = "Slice"
}

// @public
export interface ReadonlyRepairDataStore<TTree = Delta.ProtoNode> {
    // (undocumented)
    getNodes(revision: RevisionTag, path: UpPath | undefined, key: FieldKey, index: number, count: number): TTree[];
    // (undocumented)
    getValue(revision: RevisionTag, path: UpPath): Value;
}

// @public (undocumented)
interface Reattach extends HasReattachFields, HasRevisionTag {
    // (undocumented)
    count: NodeCount;
    // (undocumented)
    type: "Revive" | "Return";
}

// @public
function rebase<TNodeChange>(change: Changeset<TNodeChange>, base: TaggedChange<Changeset<TNodeChange>>, rebaseChild: NodeChangeRebaser_2<TNodeChange>): Changeset<TNodeChange>;

// @public
export function recordDependency(dependent: ObservingDependent | undefined, dependee: Dependee): void;

// @public
export interface RepairDataStore<TTree = Delta.ProtoNode> extends ReadonlyRepairDataStore<TTree> {
    capture(change: Delta.Root, revision: RevisionTag): void;
}

// @public
export type RevisionTag = Brand<number, "rebaser.RevisionTag">;

// @public
type Root<TTree = ProtoNode> = FieldMarks<TTree>;

// @public
export interface RootField {
    // (undocumented)
    readonly key: DetachedField;
}

// @public
export const rootFieldKey: GlobalFieldKey;

// @public
export interface SchemaData {
    // (undocumented)
    readonly globalFieldSchema: ReadonlyMap<GlobalFieldKey, FieldSchema>;
    // (undocumented)
    readonly treeSchema: ReadonlyMap<TreeSchemaIdentifier, TreeSchema>;
}

// @public
export interface SchemaDataAndPolicy<TPolicy extends SchemaPolicy = SchemaPolicy> extends SchemaData {
    readonly policy: TPolicy;
}

// @public
export interface SchemaPolicy {
    readonly defaultGlobalFieldSchema: FieldSchema;
    readonly defaultTreeSchema: TreeSchema;
}

// @public (undocumented)
type SequenceChangeRebaser = FieldChangeRebaser<Changeset>;

declare namespace SequenceField {
    export {
        Attach,
        Changeset,
        ClientId,
        Delete_2 as Delete,
        Detach,
        Effects,
        GapCount,
        HasChanges,
        HasMoveId,
        HasLength,
        HasPlaceFields,
        HasRevisionTag,
        HasTiebreakPolicy,
        Insert_2 as Insert,
        Mark_2 as Mark,
        MarkList_2 as MarkList,
        Modify_2 as Modify,
        ModifyDelete,
        ModifyDetach,
        ModifyInsert,
        ModifyMoveIn,
        ModifyMoveOut,
        ModifyReattach,
        MoveIn_2 as MoveIn,
        MoveOut_2 as MoveOut,
        NodeChangeType,
        NodeCount,
        MoveId_2 as MoveId,
        ObjectMark,
        PriorOp,
        ProtoNode_2 as ProtoNode,
        RangeType,
        Reattach,
        SizedMark,
        SizedObjectMark,
        Tiebreak,
        Tombstones,
        TreeForestPath,
        TreeRootPath,
        Skip_2 as Skip,
        LineageEvent,
        HasReattachFields,
        SequenceFieldChangeHandler,
        sequenceFieldChangeHandler,
        SequenceChangeRebaser,
        sequenceFieldChangeRebaser,
        decodeJson,
        encodeForJson,
        NodeChangeDecoder_2 as NodeChangeDecoder,
        NodeChangeEncoder_2 as NodeChangeEncoder,
        sequenceFieldChangeEncoder,
        sequenceFieldToDelta,
        ToDelta_2 as ToDelta,
        SequenceFieldEditor,
        sequenceFieldEditor,
        MarkListFactory,
        NodeChangeRebaser_2 as NodeChangeRebaser,
        rebase,
        invert,
        NodeChangeInverter_2 as NodeChangeInverter,
        compose,
        NodeChangeComposer_2 as NodeChangeComposer
    }
}
export { SequenceField }

// @public (undocumented)
const sequenceFieldChangeEncoder: FieldChangeEncoder<Changeset>;

// @public (undocumented)
type SequenceFieldChangeHandler = FieldChangeHandler<Changeset, SequenceFieldEditor>;

// @public (undocumented)
const sequenceFieldChangeHandler: SequenceFieldChangeHandler;

// @public (undocumented)
const sequenceFieldChangeRebaser: {
    compose: typeof compose;
    invert: typeof invert;
    rebase: typeof rebase;
};

// @public (undocumented)
export interface SequenceFieldEditBuilder {
    delete(index: number, count: number): void;
    insert(index: number, newContent: ITreeCursor | ITreeCursor[]): void;
}

// @public (undocumented)
interface SequenceFieldEditor extends FieldEditor<Changeset> {
    // (undocumented)
    delete(index: number, count: number): Changeset<never>;
    // (undocumented)
    insert(index: number, cursor: ITreeCursor | ITreeCursor[]): Changeset<never>;
    // (undocumented)
    revive(index: number, count: number, detachIndex: number, revision: RevisionTag): Changeset<never>;
}

// @public (undocumented)
const sequenceFieldEditor: {
    buildChildChange: <TNodeChange = NodeChangeset>(index: number, change: TNodeChange) => Changeset<TNodeChange>;
    insert: (index: number, cursors: ITreeCursor | ITreeCursor[]) => Changeset<never>;
    delete: (index: number, count: number) => Changeset<never>;
    revive: (index: number, count: number, detachIndex: number, revision: RevisionTag) => Changeset<never>;
};

// @public (undocumented)
function sequenceFieldToDelta<TNodeChange>(marks: MarkList_2<TNodeChange>, deltaFromChild: ToDelta_2<TNodeChange>, reviver: NodeReviver): Delta.MarkList;

// @public
export class SharedTreeFactory implements IChannelFactory {
    // (undocumented)
    attributes: IChannelAttributes;
    // (undocumented)
    create(runtime: IFluidDataStoreRuntime, id: string): ISharedTree;
    // (undocumented)
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, channelAttributes: Readonly<IChannelAttributes>): Promise<ISharedTree>;
    // (undocumented)
    type: string;
}

// @public
export class SimpleDependee implements Dependee {
    constructor(computationName?: string);
    // (undocumented)
    readonly computationName: string;
    invalidateDependents(token?: InvalidationToken): void;
    // @sealed (undocumented)
    listDependents(): Set<Dependent>;
    // (undocumented)
    registerDependent(dependent: Dependent): boolean;
    // (undocumented)
    removeDependent(dependent: Dependent): void;
}

// @public
export function singleJsonCursor(root: JsonCompatible): ITreeCursorSynchronous;

// @public (undocumented)
type SizedMark<TNodeChange = NodeChangeType> = Skip_2 | SizedObjectMark<TNodeChange>;

// @public (undocumented)
type SizedObjectMark<TNodeChange = NodeChangeType> = Modify_2<TNodeChange> | Detach | ModifyDetach<TNodeChange>;

// @public
type Skip = number;

// @public (undocumented)
type Skip_2 = number;

// @public
export interface StoredSchemaRepository<TPolicy extends SchemaPolicy = SchemaPolicy> extends Dependee, SchemaDataAndPolicy<TPolicy> {
    update(newSchema: SchemaData): void;
}

// @public (undocumented)
export function symbolFromKey(key: GlobalFieldKey): GlobalFieldKeySymbol;

// @public (undocumented)
export interface TaggedChange<TChangeset> {
    // (undocumented)
    readonly change: TChangeset;
    readonly isInverse?: boolean;
    // (undocumented)
    readonly revision: RevisionTag | undefined;
}

// @public (undocumented)
enum Tiebreak {
    // (undocumented)
    Left = 0,
    // (undocumented)
    Right = 1
}

// @public
export type ToDelta = (child: NodeChangeset, index: number | undefined) => Delta.Modify;

// @public (undocumented)
type ToDelta_2<TNodeChange> = (child: TNodeChange, index: number | undefined) => Delta.Modify;

// @public
interface Tombstones {
    // (undocumented)
    change: RevisionTag;
    // (undocumented)
    count: NodeCount;
}

// @public (undocumented)
export enum TransactionResult {
    // (undocumented)
    Abort = 0,
    // (undocumented)
    Apply = 1
}

// @public (undocumented)
interface TreeForestPath {
    // (undocumented)
    [label: string]: TreeRootPath;
}

// @public (undocumented)
export interface TreeLocation {
    // (undocumented)
    readonly index: number;
    // (undocumented)
    readonly range: FieldLocation | DetachedField;
}

// @public (undocumented)
export const enum TreeNavigationResult {
    NotFound = -1,
    Ok = 1,
    Pending = 0
}

// @public (undocumented)
type TreeRootPath = number | {
    [label: number]: TreeForestPath;
};

// @public (undocumented)
export interface TreeSchema {
    readonly extraGlobalFields: boolean;
    readonly extraLocalFields: FieldSchema;
    readonly globalFields: ReadonlySet<GlobalFieldKey>;
    readonly localFields: ReadonlyMap<LocalFieldKey, FieldSchema>;
    readonly value: ValueSchema;
}

// @public
export type TreeSchemaIdentifier = Brand<string, "tree.TreeSchemaIdentifier">;

// @public (undocumented)
export type TreeType = TreeSchemaIdentifier;

// @public
export type TreeTypeSet = ReadonlySet<TreeSchemaIdentifier> | undefined;

// @public
export interface TreeValue extends Serializable {
}

// @public
export const typeNameSymbol: unique symbol;

// @public
export const typeSymbol: unique symbol;

// @public
export type UnwrappedEditableField = UnwrappedEditableTree | undefined | EditableField;

// @public
export type UnwrappedEditableTree = EditableTreeOrPrimitive | EditableField;

// @public
export interface UpPath {
    readonly parent: UpPath | undefined;
    readonly parentField: FieldKey;
    readonly parentIndex: number;
}

// @public
export type Value = undefined | TreeValue;

// @public (undocumented)
export type ValueChange = {
    revision?: RevisionTag;
    value?: Value;
} | {
    revision?: RevisionTag;
    revert: RevisionTag | undefined;
};

// @public (undocumented)
export interface ValueFieldEditBuilder {
    set(newContent: ITreeCursor): void;
}

// @public
export type ValueFromBranded<T extends BrandedType<any, string>> = T extends BrandedType<infer ValueType, string> ? ValueType : never;

// @public
export enum ValueSchema {
    // (undocumented)
    Boolean = 3,
    // (undocumented)
    Nothing = 0,
    // (undocumented)
    Number = 1,
    Serializable = 4,
    // (undocumented)
    String = 2
}

// @public
export const valueSymbol: unique symbol;

// (No @packageDocumentation comment for this package)

```
