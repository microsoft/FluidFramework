## API Report File for "@fluid-internal/tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { IChannelAttributes } from '@fluidframework/datastore-definitions';
import { IChannelFactory } from '@fluidframework/datastore-definitions';
import { IChannelServices } from '@fluidframework/datastore-definitions';
import { IFluidDataStoreRuntime } from '@fluidframework/datastore-definitions';
import { ISharedObject } from '@fluidframework/shared-object-base';
import { IsoBuffer } from '@fluidframework/common-utils';
import { Serializable } from '@fluidframework/datastore-definitions';

// @alpha
export enum AllowedUpdateType {
    None = 0,
    SchemaCompatible = 1
}

// @alpha
type AllowOptional<T> = [FlattenKeys<RequiredFields<T> & OptionalFields<T>>][_dummy];

// @alpha
type AllowOptionalNotFlattened<T> = [RequiredFields<T> & OptionalFields<T>][_dummy];

// @alpha
export type Anchor = Brand<number, "rebaser.Anchor">;

// @alpha
export interface AnchorEvents {
    afterDelete(anchor: AnchorNode): void;
    childrenChanging(anchor: AnchorNode): void;
    subtreeChanging(anchor: AnchorNode): void;
    valueChanging(anchor: AnchorNode, value: Value): void;
}

// @alpha (undocumented)
export type AnchorKeyBrand = Brand<number, "AnchorSlot">;

// @alpha
export interface AnchorLocator {
    locate(anchor: Anchor): AnchorNode | undefined;
}

// @alpha
export interface AnchorNode extends UpPath<AnchorNode>, ISubscribable<AnchorEvents> {
    child(key: FieldKey, index: number): UpPath<AnchorNode>;
    getOrCreateChildRef(key: FieldKey, index: number): [Anchor, AnchorNode];
    readonly slots: BrandedMapSubset<AnchorSlot<any>>;
}

// @alpha @sealed
export class AnchorSet implements ISubscribable<AnchorSetRootEvents> {
    applyDelta(delta: Delta.Root): void;
    // (undocumented)
    forget(anchor: Anchor): void;
    internalizePath(originalPath: UpPath): UpPath;
    isEmpty(): boolean;
    // (undocumented)
    locate(anchor: Anchor): AnchorNode | undefined;
    // (undocumented)
    on<K extends keyof AnchorSetRootEvents>(eventName: K, listener: AnchorSetRootEvents[K]): () => void;
    track(path: UpPath | null): Anchor;
}

// @alpha
export interface AnchorSetRootEvents {
    childrenChanging(anchors: AnchorSet): void;
    treeChanging(anchors: AnchorSet): void;
}

// @alpha
export type AnchorSlot<TContent> = BrandedKey<Opaque<AnchorKeyBrand>, TContent>;

// @alpha
export function anchorSlot<TContent>(): AnchorSlot<TContent>;

// @alpha
const enum ApiMode {
    Editable = 1,
    Flexible = 0,
    Simple = 3,
    Wrapped = 2
}

// @alpha
type ApplyMultiplicity<TMultiplicity extends Multiplicity, TypedChild, Mode extends ApiMode> = {
    [Multiplicity.Forbidden]: undefined;
    [Multiplicity.Optional]: undefined | TypedChild;
    [Multiplicity.Sequence]: Mode extends ApiMode.Editable ? EditableSequenceField<TypedChild> : TypedChild[];
    [Multiplicity.Value]: TypedChild;
}[TMultiplicity];

// @alpha
export interface ArrayLikeMut<TGet, TSet extends TGet = TGet> extends ArrayLike<TGet> {
    // (undocumented)
    [n: number]: TSet;
}

// @alpha
type AsName<T extends unknown | Named<unknown>> = T extends Named<infer Name> ? Name : T;

// @alpha
type AsNames<T extends (unknown | Named<TName>)[], TName = string> = Assume<T extends [infer Head, ...infer Tail] ? [AsName<Head>, ...AsNames<Tail, TName>] : [], TName[]>;

// @alpha
type Assume<TInput, TAssumeToBe> = TInput extends TAssumeToBe ? TInput : TAssumeToBe;

// @alpha
export type Brand<ValueType, Name extends string> = ValueType & BrandedType<ValueType, Name>;

// @alpha
export function brand<T extends Brand<any, string>>(value: T extends BrandedType<infer ValueType, string> ? ValueType : never): T;

// @alpha (undocumented)
export type BrandedKey<TKey, TContent> = TKey & Invariant<TContent>;

// @alpha (undocumented)
export type BrandedKeyContent<TKey extends BrandedKey<unknown, any>> = TKey extends BrandedKey<unknown, infer TContent> ? TContent : never;

// @alpha
export interface BrandedMapSubset<K extends BrandedKey<unknown, any>> {
    // (undocumented)
    delete(key: K): boolean;
    // (undocumented)
    get<K2 extends K>(key: K2): BrandedKeyContent<K2> | undefined;
    // (undocumented)
    has(key: K): boolean;
    // (undocumented)
    set<K2 extends K>(key: K2, value: BrandedKeyContent<K2>): this;
}

// @alpha @sealed
export abstract class BrandedType<ValueType, Name extends string> {
    protected readonly _type_brand: Name;
    // (undocumented)
    protected _typeCheck?: Invariant<ValueType>;
}

// @alpha
export function brandOpaque<T extends BrandedType<any, string>>(value: isAny<ValueFromBranded<T>> extends true ? never : ValueFromBranded<T>): BrandedType<ValueFromBranded<T>, NameFromBranded<T>>;

// @alpha (undocumented)
export function buildForest(schema: StoredSchemaRepository, anchors?: AnchorSet): IEditableForest;

// @alpha
export abstract class ChangeEncoder<TChange> {
    decodeBinary(formatVersion: number, change: IsoBuffer): TChange;
    abstract decodeJson(formatVersion: number, change: JsonCompatibleReadOnly): TChange;
    encodeBinary(formatVersion: number, change: TChange): IsoBuffer;
    abstract encodeForJson(formatVersion: number, change: TChange): JsonCompatibleReadOnly;
}

// @alpha (undocumented)
export interface ChangeFamily<TEditor extends ChangeFamilyEditor, TChange> {
    // (undocumented)
    buildEditor(changeReceiver: (change: TChange) => void, anchorSet: AnchorSet): TEditor;
    // (undocumented)
    readonly encoder: ChangeEncoder<TChange>;
    // (undocumented)
    intoDelta(change: TChange): Delta.Root;
    // (undocumented)
    readonly rebaser: ChangeRebaser<TChange>;
}

// @alpha (undocumented)
export interface ChangeFamilyEditor {
    enterTransaction(): void;
    exitTransaction(): void;
}

// @alpha
export interface ChangeRebaser<TChangeset> {
    compose(changes: TaggedChange<TChangeset>[]): TChangeset;
    // (undocumented)
    invert(changes: TaggedChange<TChangeset>, isRollback: boolean, repairStore?: ReadonlyRepairDataStore): TChangeset;
    rebase(change: TChangeset, over: TaggedChange<TChangeset>): TChangeset;
    // (undocumented)
    rebaseAnchors(anchors: AnchorSet, over: TChangeset): void;
    // (undocumented)
    _typeCheck?: Invariant<TChangeset>;
}

// @alpha
export type ChangesetLocalId = Brand<number, "ChangesetLocalId">;

// @alpha
export type ChildCollection = FieldKey | RootField;

// @alpha
export interface ChildLocation {
    // (undocumented)
    readonly container: ChildCollection;
    // (undocumented)
    readonly index: number;
}

// @alpha
type CollectOptions<Mode extends ApiMode, TTypedFields, TValueSchema extends ValueSchema, TName> = {
    [ApiMode.Flexible]: Record<string, never> extends TTypedFields ? TypedValue<TValueSchema> | FlexibleObject<TValueSchema, TName> : FlexibleObject<TValueSchema, TName> & TypedSchema.AllowOptionalNotFlattened<TTypedFields>;
    [ApiMode.Editable]: [Record<string, never>, TValueSchema] extends [
    TTypedFields,
    PrimitiveValueSchema
    ] ? TypedValue<TValueSchema> : TypedSchema.AllowOptionalNotFlattened<{
        [typeNameSymbol]: TName & TreeSchemaIdentifier;
    } & ValueFieldTreeFromSchema<TValueSchema> & TTypedFields> & UntypedTreeCore;
    [ApiMode.Wrapped]: {
        [typeNameSymbol]: TName;
        [valueSymbol]: TypedValue<TValueSchema>;
    } & TTypedFields;
    [ApiMode.Simple]: Record<string, never> extends TTypedFields ? TypedValue<TValueSchema> : FlexibleObject<TValueSchema, TName> & TypedSchema.AllowOptionalNotFlattened<TTypedFields>;
}[Mode];

// @alpha
export const contextSymbol: unique symbol;

// @alpha
export type ContextuallyTypedFieldData = ContextuallyTypedNodeData | undefined;

// @alpha
export type ContextuallyTypedNodeData = ContextuallyTypedNodeDataObject | PrimitiveValue | readonly ContextuallyTypedNodeData[] | MarkedArrayLike<ContextuallyTypedNodeData>;

// @alpha
export interface ContextuallyTypedNodeDataObject {
    readonly [typeNameSymbol]?: string;
    readonly [valueSymbol]?: Value;
    [key: FieldKey]: ContextuallyTypedFieldData;
    [key: string]: ContextuallyTypedFieldData;
}

// @alpha
export interface Contravariant<T> {
    // (undocumented)
    _removeCovariance?: (_: T) => void;
}

// @alpha
export interface Covariant<T> {
    // (undocumented)
    _removeContravariance?: T;
}

// @alpha
export function createEmitter<E extends Events<E>>(noListeners?: NoListenersCallback<E>): ISubscribable<E> & IEmitter<E> & HasListeners<E>;

// @alpha
export const createField: unique symbol;

// @alpha
export interface CrossFieldManager<T = unknown> {
    get(target: CrossFieldTarget, revision: RevisionTag | undefined, id: ChangesetLocalId, addDependency: boolean): T | undefined;
    getOrCreate(target: CrossFieldTarget, revision: RevisionTag | undefined, id: ChangesetLocalId, newValue: T, invalidateDependents: boolean): T;
}

// @alpha (undocumented)
export enum CrossFieldTarget {
    // (undocumented)
    Destination = 1,
    // (undocumented)
    Source = 0
}

// @alpha
export interface CursorAdapter<TNode> {
    // (undocumented)
    getFieldFromNode(node: TNode, key: FieldKey): readonly TNode[];
    // (undocumented)
    keysFromNode(node: TNode): readonly FieldKey[];
    // (undocumented)
    type(node: TNode): TreeType;
    // (undocumented)
    value(node: TNode): Value;
}

// @alpha
export function cursorFromContextualData(schemaData: SchemaDataAndPolicy, typeSet: TreeTypeSet, data: ContextuallyTypedNodeData): ITreeCursorSynchronous;

// @alpha (undocumented)
export const enum CursorLocationType {
    Fields = 1,
    Nodes = 0
}

// @alpha
export function cursorToJsonObject(reader: ITreeCursor): JsonCompatible;

// @alpha
export interface CursorWithNode<TNode> extends ITreeCursorSynchronous {
    fork(): CursorWithNode<TNode>;
    getNode(): TNode;
}

// @alpha
export const defaultSchemaPolicy: FullSchemaPolicy;

// @alpha
interface Delete<TTree = ProtoNode> extends HasModifications<TTree> {
    readonly count: number;
    // (undocumented)
    readonly type: typeof MarkType.Delete;
}

declare namespace Delta {
    export {
        Root,
        ProtoNode,
        Mark,
        MarkList,
        Skip,
        HasModifications,
        Modify,
        Delete,
        MoveOut,
        MoveIn,
        Insert,
        MoveId,
        FieldMap,
        FieldMarks,
        MarkType
    }
}
export { Delta }

// @alpha
export interface Dependee extends NamedComputation {
    registerDependent(dependent: Dependent): boolean;
    removeDependent(dependent: Dependent): void;
}

// @alpha
export interface Dependent extends NamedComputation {
    markInvalid(token?: InvalidationToken): void;
}

// @alpha
export interface DetachedField extends Opaque<Brand<string, "tree.DetachedField">> {
}

// @alpha
type _dummy = 0;

// @alpha
export interface EditableField extends MarkedArrayLike<UnwrappedEditableTree> {
    readonly [proxyTargetSymbol]: object;
    readonly context: EditableTreeContext;
    deleteNodes(index: number, count?: number): void;
    readonly fieldKey: FieldKey;
    readonly fieldSchema: FieldSchema;
    getNode(index: number): EditableTree;
    insertNodes(index: number, newContent: ITreeCursor | ITreeCursor[]): void;
    readonly parent?: EditableTree;
    replaceNodes(index: number, newContent: ITreeCursor | ITreeCursor[], count?: number): void;
}

// @alpha (undocumented)
type EditableSequenceField<TypedChild> = UntypedSequenceField & MarkedArrayLike<TypedChild>;

// @alpha
export interface EditableTree extends Iterable<EditableField>, ContextuallyTypedNodeDataObject {
    readonly [contextSymbol]: EditableTreeContext;
    [createField](fieldKey: FieldKey, newContent: ITreeCursor | ITreeCursor[]): void;
    [getField](fieldKey: FieldKey): EditableField;
    // (undocumented)
    [on]<K extends keyof EditableTreeEvents>(eventName: K, listener: EditableTreeEvents[K]): () => void;
    readonly [parentField]: {
        readonly parent: EditableField;
        readonly index: number;
    };
    readonly [proxyTargetSymbol]: object;
    [replaceField](fieldKey: FieldKey, newContent: ITreeCursor | ITreeCursor[]): void;
    readonly [typeNameSymbol]: TreeSchemaIdentifier;
    readonly [typeSymbol]: TreeSchema;
    [valueSymbol]: Value;
    [key: FieldKey]: UnwrappedEditableField;
}

// @alpha
export interface EditableTreeContext extends ISubscribable<ForestEvents> {
    clear(): void;
    free(): void;
    prepareForEdit(): void;
    get root(): EditableField;
    set root(data: ContextuallyTypedFieldData);
    readonly schema: SchemaDataAndPolicy;
    get unwrappedRoot(): UnwrappedEditableField;
    set unwrappedRoot(data: ContextuallyTypedFieldData);
}

// @alpha
export interface EditableTreeEvents {
    changing(upPath: UpPath, value: Value): void;
    subtreeChanging(upPath: UpPath): void;
}

// @alpha
export type EditableTreeOrPrimitive = EditableTree | PrimitiveValue;

// @alpha (undocumented)
export interface EditDescription {
    // (undocumented)
    change: FieldChangeset;
    // (undocumented)
    field: FieldKey;
    // (undocumented)
    fieldKind: FieldKindIdentifier;
    // (undocumented)
    path: UpPath | undefined;
}

// @alpha
export const emptyField: FieldSchema;

// @alpha
const emptyField_2: {
    kind: FieldKind<FieldEditor<0>, import("../fieldKind").Multiplicity.Forbidden> & {
        identifier: "Forbidden" & BrandedType<string, "tree.FieldKindIdentifier">;
    };
};

// @alpha
export const EmptyKey: LocalFieldKey;

// @alpha
export type Events<E> = {
    [P in (string | symbol) & keyof E as IsEvent<E[P]> extends true ? P : never]: E[P];
};

// @alpha
export type ExtractFromOpaque<TOpaque extends BrandedType<any, string>> = TOpaque extends BrandedType<infer ValueType, infer Name> ? isAny<ValueType> extends true ? unknown : Brand<ValueType, Name> : never;

// @alpha
export function extractFromOpaque<TOpaque extends BrandedType<any, string>>(value: TOpaque): ExtractFromOpaque<TOpaque>;

// @alpha (undocumented)
export function fail(message: string): never;

// @alpha
export interface FieldAnchor {
    // (undocumented)
    fieldKey: FieldKey;
    parent: Anchor | undefined;
}

// @alpha (undocumented)
export interface FieldChange {
    // (undocumented)
    change: FieldChangeset;
    // (undocumented)
    fieldKind: FieldKindIdentifier;
    revision?: RevisionTag;
}

// @alpha (undocumented)
export interface FieldChangeEncoder<TChangeset> {
    decodeJson(formatVersion: number, change: JsonCompatibleReadOnly, decodeChild: NodeChangeDecoder): TChangeset;
    encodeForJson(formatVersion: number, change: TChangeset, encodeChild: NodeChangeEncoder): JsonCompatibleReadOnly;
}

// @alpha
export interface FieldChangeHandler<TChangeset, TEditor extends FieldEditor<TChangeset> = FieldEditor<TChangeset>> {
    // (undocumented)
    editor: TEditor;
    // (undocumented)
    encoder: FieldChangeEncoder<TChangeset>;
    // (undocumented)
    intoDelta(change: TChangeset, deltaFromChild: ToDelta): Delta.MarkList;
    isEmpty(change: TChangeset): boolean;
    // (undocumented)
    rebaser: FieldChangeRebaser<TChangeset>;
    // (undocumented)
    _typeCheck?: Invariant<TChangeset>;
}

// @alpha (undocumented)
export type FieldChangeMap = Map<FieldKey, FieldChange>;

// @alpha (undocumented)
export interface FieldChangeRebaser<TChangeset> {
    amendCompose(composedChange: TChangeset, composeChild: NodeChangeComposer, genId: IdAllocator, crossFieldManager: CrossFieldManager, revisionMetadata: RevisionMetadataSource): TChangeset;
    amendInvert(invertedChange: TChangeset, originalRevision: RevisionTag | undefined, reviver: NodeReviver, genId: IdAllocator, crossFieldManager: CrossFieldManager): TChangeset;
    amendRebase(rebasedChange: TChangeset, over: TaggedChange<TChangeset>, rebaseChild: NodeChangeRebaser, genId: IdAllocator, crossFieldManager: CrossFieldManager, revisionMetadata: RevisionMetadataSource): TChangeset;
    compose(changes: TaggedChange<TChangeset>[], composeChild: NodeChangeComposer, genId: IdAllocator, crossFieldManager: CrossFieldManager, revisionMetadata: RevisionMetadataSource): TChangeset;
    // (undocumented)
    invert(change: TaggedChange<TChangeset>, invertChild: NodeChangeInverter, reviver: NodeReviver, genId: IdAllocator, crossFieldManager: CrossFieldManager): TChangeset;
    rebase(change: TChangeset, over: TaggedChange<TChangeset>, rebaseChild: NodeChangeRebaser, genId: IdAllocator, crossFieldManager: CrossFieldManager, revisionMetadata: RevisionMetadataSource): TChangeset;
}

// @alpha (undocumented)
export type FieldChangeset = Brand<unknown, "FieldChangeset">;

// @alpha (undocumented)
export interface FieldEditor<TChangeset> {
    buildChildChange(childIndex: number, change: NodeChangeset): TChangeset;
}

// @alpha
export type FieldKey = LocalFieldKey | GlobalFieldKeySymbol;

// @alpha @sealed
export class FieldKind<TEditor extends FieldEditor<any> = FieldEditor<any>, TMultiplicity extends Multiplicity = Multiplicity> implements FieldKindSpecifier {
    constructor(identifier: FieldKindIdentifier, multiplicity: TMultiplicity, changeHandler: FieldChangeHandler<any, TEditor>, allowsTreeSupersetOf: (originalTypes: TreeTypeSet, superset: FieldSchema) => boolean, handlesEditsFrom: ReadonlySet<FieldKindIdentifier>);
    // (undocumented)
    allowsFieldSuperset(policy: FullSchemaPolicy, originalData: SchemaData, originalTypes: TreeTypeSet, superset: FieldSchema): boolean;
    // (undocumented)
    readonly changeHandler: FieldChangeHandler<any, TEditor>;
    // (undocumented)
    readonly handlesEditsFrom: ReadonlySet<FieldKindIdentifier>;
    // (undocumented)
    readonly identifier: FieldKindIdentifier;
    // (undocumented)
    readonly multiplicity: TMultiplicity;
}

// @alpha
export type FieldKindIdentifier = Brand<string, "tree.FieldKindIdentifier">;

// @alpha (undocumented)
export const FieldKinds: {
    readonly value: FieldKind<FieldEditor<any>, Multiplicity.Value>;
    readonly optional: FieldKind<FieldEditor<any>, Multiplicity.Optional>;
    readonly sequence: FieldKind<FieldEditor<any>, Multiplicity.Sequence>;
};

// @alpha
export interface FieldKindSpecifier {
    // (undocumented)
    identifier: FieldKindIdentifier;
}

// @alpha
export interface FieldLocation {
    // (undocumented)
    readonly key: FieldKey;
    // (undocumented)
    readonly parent: ForestLocation;
}

// @alpha (undocumented)
type FieldMap<T> = ReadonlyMap<FieldKey, T>;

// @alpha
export interface FieldMapObject<TChild> {
    // (undocumented)
    [key: string]: TChild[];
}

// @alpha (undocumented)
type FieldMarks<TTree = ProtoNode> = FieldMap<MarkList<TTree>>;

// @alpha (undocumented)
export interface FieldSchema {
    // (undocumented)
    readonly kind: FieldKindSpecifier;
    readonly types?: TreeTypeSet;
}

// @alpha
export function fieldSchema(kind: {
    identifier: FieldKindIdentifier;
}, types?: Iterable<TreeSchemaIdentifier>): FieldSchema;

// @alpha
interface FieldSchemaTypeInfo extends FieldSchema {
    // (undocumented)
    readonly kind: FieldKind;
    // (undocumented)
    readonly types?: NameSet;
}

// @alpha
export const enum FieldScope {
    // (undocumented)
    global = "globalFields",
    // (undocumented)
    local = "fields"
}

// @alpha
export interface FieldUpPath {
    readonly field: FieldKey;
    readonly parent: UpPath | undefined;
}

// @alpha
export interface FieldViewSchema<Kind extends FieldKind = FieldKind> extends FieldSchema {
    // (undocumented)
    readonly kind: Kind;
}

// @alpha
type FlattenKeys<T> = [{
    [Property in keyof T]: T[Property];
}][_dummy];

// @alpha
type FlexibleObject<TValueSchema extends ValueSchema, TName> = [
TypedSchema.FlattenKeys<{
    [typeNameSymbol]?: TName;
} & TypedSchema.AllowOptional<ValueFieldTreeFromSchema<TValueSchema>>>
][TypedSchema._dummy];

// @alpha
export interface ForestEvents {
    afterDelta(delta: Delta.Root): void;
    beforeDelta(delta: Delta.Root): void;
}

// @alpha
export type ForestLocation = ITreeSubscriptionCursor | Anchor;

// @alpha
export interface FullSchemaPolicy extends SchemaPolicy {
    readonly fieldKinds: ReadonlyMap<FieldKindIdentifier, FieldKind>;
}

// @alpha
export interface GenericFieldsNode<TChild> {
    // (undocumented)
    [FieldScope.local]?: FieldMapObject<TChild>;
    // (undocumented)
    [FieldScope.global]?: FieldMapObject<TChild>;
}

// @alpha
export interface GenericTreeNode<TChild> extends GenericFieldsNode<TChild>, NodeData {
}

// @alpha
export const getField: unique symbol;

// @alpha (undocumented)
export function getPrimaryField(schema: TreeSchema): {
    key: LocalFieldKey;
    schema: FieldSchema;
} | undefined;

// @alpha
export type GlobalFieldKey = Brand<string, "tree.GlobalFieldKey">;

// @alpha
export type GlobalFieldKeySymbol = Brand<symbol, "GlobalFieldKeySymbol">;

// @alpha (undocumented)
export interface HasFieldChanges {
    // (undocumented)
    fieldChanges?: FieldChangeMap;
}

// @alpha (undocumented)
export interface HasListeners<E extends Events<E>> {
    hasListeners(eventName?: keyof Events<E>): boolean;
}

// @alpha
interface HasModifications<TTree = ProtoNode> {
    // (undocumented)
    readonly fields?: FieldMarks<TTree>;
    readonly setValue?: Value;
}

// @alpha
export type IdAllocator = (count?: number) => ChangesetLocalId;

// @alpha
export interface IDefaultEditBuilder {
    // (undocumented)
    addValueConstraint(path: UpPath, value: Value): void;
    // (undocumented)
    move(sourcePath: UpPath | undefined, sourceField: FieldKey, sourceIndex: number, count: number, destPath: UpPath | undefined, destField: FieldKey, destIndex: number): void;
    // (undocumented)
    optionalField(parent: UpPath | undefined, field: FieldKey): OptionalFieldEditBuilder;
    // (undocumented)
    sequenceField(parent: UpPath | undefined, field: FieldKey): SequenceFieldEditBuilder;
    // (undocumented)
    setValue(path: UpPath, value: Value): void;
    // (undocumented)
    valueField(parent: UpPath | undefined, field: FieldKey): ValueFieldEditBuilder;
}

// @alpha
export type Identifier = number;

// @alpha
export const identifierKey: GlobalFieldKey;

// @alpha
export const identifierKeySymbol: GlobalFieldKeySymbol;

// @alpha
export interface IEditableForest extends IForestSubscription {
    readonly anchors: AnchorSet;
    applyDelta(delta: Delta.Root): void;
}

// @alpha
export interface IEmitter<E extends Events<E>> {
    emit<K extends keyof Events<E>>(eventName: K, ...args: Parameters<E[K]>): void;
    emitAndCollect<K extends keyof Events<E>>(eventName: K, ...args: Parameters<E[K]>): ReturnType<E[K]>[];
}

// @alpha
export interface IForestSubscription extends Dependee, ISubscribable<ForestEvents> {
    allocateCursor(): ITreeSubscriptionCursor;
    clone(schema: StoredSchemaRepository, anchors: AnchorSet): IEditableForest;
    forgetAnchor(anchor: Anchor): void;
    readonly schema: StoredSchemaRepository;
    tryMoveCursorToField(destination: FieldAnchor, cursorToMove: ITreeSubscriptionCursor): TreeNavigationResult;
    tryMoveCursorToNode(destination: Anchor, cursorToMove: ITreeSubscriptionCursor): TreeNavigationResult;
}

// @alpha
interface Insert<TTree = ProtoNode> extends HasModifications<TTree> {
    readonly content: readonly TTree[];
    // (undocumented)
    readonly type: typeof MarkType.Insert;
}

declare namespace InternalTypes {
    export {
        TypeSetToTypedTrees as TreeTypesToTypedTreeTypes,
        TypedTree,
        CollectOptions,
        TypedFields,
        ApplyMultiplicity,
        ValueFieldTreeFromSchema,
        FlexibleObject,
        EditableSequenceField,
        TypedField,
        NamesFromSchema,
        ValuesOf,
        TypedValue,
        PrimitiveValueSchema,
        UntypedSequenceField
    }
}

// @alpha
export class InvalidationToken {
    constructor(description: string, isSecondaryInvalidation?: boolean);
    // (undocumented)
    readonly description: string;
    // (undocumented)
    readonly isSecondaryInvalidation: boolean;
    // (undocumented)
    protected readonly _typeCheck: MakeNominal;
}

// @alpha
export interface Invariant<T> extends Contravariant<T>, Covariant<T> {
}

// @alpha
export type isAny<T> = boolean extends (T extends {} ? true : false) ? true : false;

// @alpha
export function isContextuallyTypedNodeDataObject(data: ContextuallyTypedNodeData | undefined): data is ContextuallyTypedNodeDataObject;

// @alpha
export function isEditableField(field: UnwrappedEditableField): field is EditableField;

// @alpha
export type IsEvent<Event> = Event extends (...args: any[]) => any ? true : false;

// @alpha
export function isGlobalFieldKey(key: FieldKey): key is GlobalFieldKeySymbol;

// @alpha
export interface ISharedTree extends ISharedObject, ISharedTreeView {
}

// @alpha
export interface ISharedTreeFork extends ISharedTreeView {
    rebaseOnto(view: ISharedTreeView): void;
}

// @alpha
export interface ISharedTreeView extends AnchorLocator {
    readonly context: EditableTreeContext;
    readonly editor: IDefaultEditBuilder;
    readonly events: ISubscribable<ViewEvents>;
    readonly forest: IForestSubscription;
    fork(): ISharedTreeFork;
    readonly identifiedNodes: ReadonlyMap<Identifier, EditableTree>;
    merge(view: ISharedTreeFork): void;
    get root(): UnwrappedEditableField;
    set root(data: ContextuallyTypedNodeData | undefined);
    readonly rootEvents: ISubscribable<AnchorSetRootEvents>;
    schematize<TSchema extends SchemaAware.TypedSchemaData>(config: SchematizeConfiguration<TSchema>): ISharedTreeView;
    readonly storedSchema: StoredSchemaRepository;
    readonly transaction: {
        start(): void;
        commit(): TransactionResult.Commit;
        abort(): TransactionResult.Abort;
        inProgress(): boolean;
    };
}

// @alpha (undocumented)
export function isNeverField(policy: FullSchemaPolicy, originalData: SchemaData, field: FieldSchema): boolean;

// @alpha (undocumented)
export function isPrimitive(schema: TreeSchema): boolean;

// @alpha (undocumented)
export function isPrimitiveValue(nodeValue: Value): nodeValue is PrimitiveValue;

// @alpha
export interface ISubscribable<E extends Events<E>> {
    on<K extends keyof Events<E>>(eventName: K, listener: E[K]): () => void;
}

// @alpha
export function isUnwrappedNode(field: UnwrappedEditableField): field is EditableTree;

// @alpha
export function isWritableArrayLike(data: ContextuallyTypedFieldData): data is MarkedArrayLike<ContextuallyTypedNodeData>;

// @alpha
export interface ITreeCursor {
    readonly chunkLength: number;
    readonly chunkStart: number;
    enterField(key: FieldKey): void;
    enterNode(childIndex: number): void;
    exitField(): void;
    exitNode(): void;
    readonly fieldIndex: number;
    firstField(): boolean;
    firstNode(): boolean;
    getFieldKey(): FieldKey;
    // (undocumented)
    getFieldLength(): number;
    getFieldPath(prefix?: PathRootPrefix): FieldUpPath;
    getPath(prefix?: PathRootPrefix): UpPath | undefined;
    readonly mode: CursorLocationType;
    nextField(): boolean;
    nextNode(): boolean;
    // (undocumented)
    readonly pending: boolean;
    seekNodes(offset: number): boolean;
    skipPendingFields(): boolean;
    readonly type: TreeType;
    readonly value: Value;
}

// @alpha
export interface ITreeCursorSynchronous extends ITreeCursor {
    // (undocumented)
    readonly pending: false;
}

// @alpha
export interface ITreeSubscriptionCursor extends ITreeCursor {
    buildAnchor(): Anchor;
    buildFieldAnchor(): FieldAnchor;
    clear(): void;
    // (undocumented)
    fork(): ITreeSubscriptionCursor;
    free(): void;
    readonly state: ITreeSubscriptionCursorState;
}

// @alpha (undocumented)
export enum ITreeSubscriptionCursorState {
    Cleared = 1,
    Current = 0,
    Freed = 2
}

// @alpha
export interface JsonableTree extends GenericTreeNode<JsonableTree> {
}

// @alpha
export function jsonableTreeFromCursor(cursor: ITreeCursor): JsonableTree;

// @alpha (undocumented)
export const jsonArray: TypedSchema.LabeledTreeSchema<TypedSchema.TreeInfoFromBuilder<{
    local: {
        [x: string]: {
            kind: FieldKind<FieldEditor<any>, import("../../feature-libraries").Multiplicity.Sequence>;
            types: TypedSchema.NameSet<["Json.Object", "Json.Array", "Json.Number", "Json.String", "Json.Null", "Json.Boolean"]>;
        };
    };
}, "Json.Array">>;

// @alpha (undocumented)
export const jsonBoolean: TypedSchema.LabeledTreeSchema<TypedSchema.TreeInfoFromBuilder<{
    value: ValueSchema.Boolean;
}, "Json.Boolean">>;

// @alpha
export type JsonCompatible = string | number | boolean | null | JsonCompatible[] | JsonCompatibleObject;

// @alpha
export type JsonCompatibleObject = {
    [P in string]: JsonCompatible;
};

// @alpha
export type JsonCompatibleReadOnly = string | number | boolean | null | readonly JsonCompatibleReadOnly[] | {
    readonly [P in string]: JsonCompatibleReadOnly | undefined;
};

// @alpha (undocumented)
export const jsonNull: TypedSchema.LabeledTreeSchema<TypedSchema.TreeInfoFromBuilder<{}, "Json.Null">>;

// @alpha (undocumented)
export const jsonNumber: TypedSchema.LabeledTreeSchema<TypedSchema.TreeInfoFromBuilder<{
    value: ValueSchema.Number;
}, "Json.Number">>;

// @alpha (undocumented)
export const jsonObject: TypedSchema.LabeledTreeSchema<TypedSchema.TreeInfoFromBuilder<{
    extraLocalFields: {
        kind: FieldKind<FieldEditor<any>, import("../../feature-libraries").Multiplicity.Optional>;
        types: TypedSchema.NameSet<["Json.Object", "Json.Array", "Json.Number", "Json.String", "Json.Null", "Json.Boolean"]>;
    };
}, "Json.Object">>;

// @alpha (undocumented)
export const jsonSchemaData: SchemaData;

// @alpha (undocumented)
export const jsonString: TypedSchema.LabeledTreeSchema<TypedSchema.TreeInfoFromBuilder<{
    value: ValueSchema.String;
}, "Json.String">>;

// @alpha (undocumented)
export function keyFromSymbol(key: GlobalFieldKeySymbol): GlobalFieldKey;

// @alpha
interface LabeledTreeSchema<T extends TreeSchemaTypeInfo = TreeSchemaTypeInfo> extends NamedTreeSchema {
    // (undocumented)
    readonly localFields: ObjectToMap<T["local"], LocalFieldKey, FieldSchema>;
    // (undocumented)
    readonly name: T["name"] & TreeSchemaIdentifier;
    readonly typeInfo: T;
}

// @alpha
type ListToKeys<T extends readonly (string | symbol)[], TValue> = {
    [key in T[number]]: TValue;
};

// @alpha
export type LocalFieldKey = Brand<string, "tree.LocalFieldKey">;

// @alpha
export interface MakeNominal {
}

// @alpha
type Mark<TTree = ProtoNode> = Skip | Modify<TTree> | Delete<TTree> | MoveOut<TTree> | MoveIn | Insert<TTree>;

// @alpha
export interface MarkedArrayLike<TGet, TSet extends TGet = TGet> extends ArrayLikeMut<TGet, TSet> {
    // (undocumented)
    readonly [arrayLikeMarkerSymbol]: true;
    // (undocumented)
    [Symbol.iterator](): IterableIterator<TGet>;
}

// @alpha
type MarkList<TTree = ProtoNode> = readonly Mark<TTree>[];

// @alpha (undocumented)
const MarkType: {
    readonly Modify: 0;
    readonly Insert: 1;
    readonly MoveIn: 2;
    readonly Delete: 3;
    readonly MoveOut: 4;
};

// @alpha
interface Modify<TTree = ProtoNode> extends HasModifications<TTree> {
    // (undocumented)
    readonly type: typeof MarkType.Modify;
}

// @alpha @sealed
export class ModularChangeFamily implements ChangeFamily<ModularEditBuilder, ModularChangeset>, ChangeRebaser<ModularChangeset> {
    constructor(fieldKinds: ReadonlyMap<FieldKindIdentifier, FieldKind>);
    // (undocumented)
    buildEditor(changeReceiver: (change: ModularChangeset) => void, anchors: AnchorSet): ModularEditBuilder;
    // (undocumented)
    compose(changes: TaggedChange<ModularChangeset>[]): ModularChangeset;
    // (undocumented)
    readonly encoder: ChangeEncoder<ModularChangeset>;
    // (undocumented)
    readonly fieldKinds: ReadonlyMap<FieldKindIdentifier, FieldKind>;
    // (undocumented)
    intoDelta(change: ModularChangeset): Delta.Root;
    // (undocumented)
    invert(change: TaggedChange<ModularChangeset>, isRollback: boolean, repairStore?: ReadonlyRepairDataStore): ModularChangeset;
    // (undocumented)
    rebase(change: ModularChangeset, over: TaggedChange<ModularChangeset>): ModularChangeset;
    // (undocumented)
    rebaseAnchors(anchors: AnchorSet, over: ModularChangeset): void;
    // (undocumented)
    get rebaser(): ChangeRebaser<ModularChangeset>;
}

// @alpha (undocumented)
export interface ModularChangeset extends HasFieldChanges {
    // (undocumented)
    constraintViolationCount?: number;
    // (undocumented)
    fieldChanges: FieldChangeMap;
    maxId?: ChangesetLocalId;
    readonly revisions?: readonly RevisionInfo[];
}

// @alpha @sealed (undocumented)
export class ModularEditBuilder extends ProgressiveEditBuilderBase<ModularChangeset> implements ProgressiveEditBuilder<ModularChangeset> {
    constructor(family: ChangeFamily<ChangeFamilyEditor, ModularChangeset>, changeReceiver: (change: ModularChangeset) => void, anchors: AnchorSet);
    // (undocumented)
    addValueConstraint(path: UpPath, currentValue: Value): void;
    // (undocumented)
    apply(change: ModularChangeset): void;
    // (undocumented)
    enterTransaction(): void;
    // (undocumented)
    exitTransaction(): void;
    // (undocumented)
    generateId(count?: number): ChangesetLocalId;
    // (undocumented)
    setValue(path: UpPath, value: Value): void;
    submitChange(path: UpPath | undefined, field: FieldKey, fieldKind: FieldKindIdentifier, change: FieldChangeset, maxId?: ChangesetLocalId): void;
    // (undocumented)
    submitChanges(changes: EditDescription[], maxId?: ChangesetLocalId): void;
}

// @alpha
interface MoveId extends Opaque<Brand<number, "delta.MoveId">> {
}

// @alpha
interface MoveIn {
    // (undocumented)
    readonly count: number;
    readonly moveId: MoveId;
    // (undocumented)
    readonly type: typeof MarkType.MoveIn;
}

// @alpha
interface MoveOut<TTree = ProtoNode> extends HasModifications<TTree> {
    readonly count: number;
    readonly moveId: MoveId;
    // (undocumented)
    readonly type: typeof MarkType.MoveOut;
}

// @alpha
export enum Multiplicity {
    Forbidden = 3,
    Optional = 1,
    Sequence = 2,
    Value = 0
}

// @alpha (undocumented)
export interface Named<TName> {
    // (undocumented)
    readonly name: TName;
}

// @alpha
export interface NamedComputation {
    readonly computationName: string;
    listDependees?(): Iterable<Dependee>;
    listDependents?(): Iterable<Dependent>;
}

// @alpha (undocumented)
export type NamedTreeSchema = TreeSchema & Named<TreeSchemaIdentifier>;

// @alpha
export function namedTreeSchema(data: Partial<TreeSchemaBuilder> & Named<TreeSchemaIdentifier>): NamedTreeSchema;

// @alpha
export type NameFromBranded<T extends BrandedType<any, string>> = T extends BrandedType<any, infer Name> ? Name : never;

// @alpha
interface NameSet<Names extends string[] = any> extends ReadonlySet<TreeSchemaIdentifier> {
    // (undocumented)
    readonly typeCheck?: Invariant<Names>;
}

// @alpha
function nameSet<T extends [...(string | Named<string>)[]]>(...names: T): NameSet<UnbrandList<AsNames<T>, TreeSchemaIdentifier>>;

// @alpha
type NamesFromSchema<T extends TypedSchema.LabeledTreeSchema[]> = T extends [
infer Head,
...infer Tail
] ? [
TypedSchema.Assume<Head, TypedSchema.LabeledTreeSchema>["typeInfo"]["name"],
...NamesFromSchema<TypedSchema.Assume<Tail, TypedSchema.LabeledTreeSchema[]>>
] : [];

// @alpha
export type NestedMap<Key1, Key2, Value> = Map<Key1, Map<Key2, Value>>;

// @alpha
export const neverTree: TreeSchema;

// @alpha (undocumented)
export type NodeChangeComposer = (changes: TaggedChange<NodeChangeset>[]) => NodeChangeset;

// @alpha (undocumented)
export type NodeChangeDecoder = (change: JsonCompatibleReadOnly) => NodeChangeset;

// @alpha (undocumented)
export type NodeChangeEncoder = (change: NodeChangeset) => JsonCompatibleReadOnly;

// @alpha (undocumented)
export type NodeChangeInverter = (change: NodeChangeset, index: number | undefined) => NodeChangeset;

// @alpha (undocumented)
export type NodeChangeRebaser = (change: NodeChangeset | undefined, baseChange: NodeChangeset | undefined) => NodeChangeset | undefined;

// @alpha
export interface NodeChangeset extends HasFieldChanges {
    // (undocumented)
    valueChange?: ValueChange;
    // (undocumented)
    valueConstraint?: ValueConstraint;
}

// @alpha
export interface NodeData {
    readonly type: TreeSchemaIdentifier;
    value?: TreeValue;
}

// @alpha
type NodeDataFor<TMap extends TypedSchemaData, Mode extends ApiMode, TSchema extends TypedSchema.LabeledTreeSchema> = TypedSchema.FlattenKeys<TypedNode<readonly [TSchema["typeInfo"]["name"]], Mode, TMap>>;

// @alpha (undocumented)
export type NodeReviver = (revision: RevisionTag, index: number, count: number) => Delta.ProtoNode[];

// @alpha
export type NoListenersCallback<E extends Events<E>> = (eventName: keyof Events<E>) => void;

// @alpha
type ObjectToMap<ObjectMap, MapKey extends number | string, MapValue> = ReadonlyMap<MapKey, MapValue> & {
    get<TKey extends keyof ObjectMap>(key: TKey): ObjectMap[TKey];
};

// @alpha
export interface ObservingDependent extends Dependent {
    // @override
    listDependees(): Iterable<Dependee>;
    registerDependee(dependee: Dependee): void;
}

// @alpha
export const on: unique symbol;

// @alpha
export type Opaque<T extends Brand<any, string>> = T extends Brand<infer ValueType, infer Name> ? BrandedType<ValueType, Name> : never;

// @alpha (undocumented)
export interface OptionalFieldEditBuilder {
    set(newContent: ITreeCursor | undefined, wasEmpty: boolean): void;
}

// @alpha
type OptionalFields<T> = [
    {
    [P in keyof T as undefined extends T[P] ? T[P] extends undefined ? never : P : never]?: T[P];
}
][_dummy];

// @alpha
export const parentField: unique symbol;

// @alpha
export interface PathRootPrefix {
    indexOffset?: number;
    parent?: UpPath | undefined;
    rootFieldOverride?: FieldKey;
}

// @alpha
export function prefixFieldPath(prefix: PathRootPrefix | undefined, path: FieldUpPath): FieldUpPath;

// @alpha
export function prefixPath(prefix: PathRootPrefix | undefined, path: UpPath | undefined): UpPath | undefined;

// @alpha (undocumented)
export type PrimitiveValue = string | boolean | number;

// @alpha
type PrimitiveValueSchema = ValueSchema.Number | ValueSchema.String | ValueSchema.Boolean;

// @alpha (undocumented)
export interface ProgressiveEditBuilder<TChange> {
    // (undocumented)
    getChanges(): TChange[];
}

// @alpha (undocumented)
export abstract class ProgressiveEditBuilderBase<TChange> implements ProgressiveEditBuilder<TChange>, ChangeFamilyEditor {
    constructor(changeFamily: ChangeFamily<ChangeFamilyEditor, TChange>, changeReceiver: (change: TChange) => void, anchorSet: AnchorSet);
    // @sealed
    protected applyChange(change: TChange): void;
    // (undocumented)
    protected readonly changeFamily: ChangeFamily<ChangeFamilyEditor, TChange>;
    // (undocumented)
    enterTransaction(): void;
    // (undocumented)
    exitTransaction(): void;
    // @sealed (undocumented)
    getChanges(): TChange[];
}

// @alpha
type ProtoNode = ITreeCursorSynchronous;

// @alpha
export const proxyTargetSymbol: unique symbol;

// @alpha
export interface ReadonlyRepairDataStore<TTree = Delta.ProtoNode, TRevisionTag = unknown> {
    // (undocumented)
    getNodes(revision: TRevisionTag, path: UpPath | undefined, key: FieldKey, index: number, count: number): TTree[];
    // (undocumented)
    getValue(revision: TRevisionTag, path: UpPath): Value;
}

// @alpha
export function recordDependency(dependent: ObservingDependent | undefined, dependee: Dependee): void;

// @alpha
export interface RepairDataStore<TTree = Delta.ProtoNode, TRevisionTag = unknown> extends ReadonlyRepairDataStore<TTree, TRevisionTag> {
    capture(change: Delta.Root, revision: TRevisionTag): void;
}

// @alpha
export const replaceField: unique symbol;

// @alpha
type RequiredFields<T> = [
    {
    [P in keyof T as undefined extends T[P] ? never : P]: T[P];
}
][_dummy];

// @alpha
export type RevisionIndexer = (tag: RevisionTag) => number;

// @alpha (undocumented)
export interface RevisionInfo {
    // (undocumented)
    readonly revision: RevisionTag;
    readonly rollbackOf?: RevisionTag;
}

// @alpha (undocumented)
export interface RevisionMetadataSource {
    // (undocumented)
    readonly getIndex: RevisionIndexer;
    // (undocumented)
    readonly getInfo: (tag: RevisionTag) => RevisionInfo;
}

// Warning: (ae-incompatible-release-tags) The symbol "RevisionTag" is marked as @alpha, but its signature references "StableId" which is marked as @internal
//
// @alpha
export type RevisionTag = StableId;

// @alpha
type Root<TTree = ProtoNode> = FieldMarks<TTree>;

// @alpha
export interface RootField {
    // (undocumented)
    readonly key: DetachedField;
}

// @alpha (undocumented)
export const rootField: DetachedField;

// @alpha
export const rootFieldKey: GlobalFieldKey;

// @alpha (undocumented)
export const rootFieldKeySymbol: GlobalFieldKeySymbol;

// @alpha
export function runSynchronous(view: ISharedTreeView, transaction: (view: ISharedTreeView) => TransactionResult | void): TransactionResult;

declare namespace SchemaAware {
    export {
        ApiMode,
        NodeDataFor,
        typedSchemaData,
        TypedNode,
        TypedField,
        TypedSchemaData,
        InternalTypes
    }
}
export { SchemaAware }

// @alpha
export interface SchemaData {
    // (undocumented)
    readonly globalFieldSchema: ReadonlyMap<GlobalFieldKey, FieldSchema>;
    // (undocumented)
    readonly treeSchema: ReadonlyMap<TreeSchemaIdentifier, TreeSchema>;
}

// @alpha
export interface SchemaDataAndPolicy<TPolicy extends SchemaPolicy = SchemaPolicy> extends SchemaData {
    readonly policy: TPolicy;
}

// @alpha
export interface SchemaEvents {
    afterSchemaChange(newSchema: SchemaData): void;
    beforeSchemaChange(newSchema: SchemaData): void;
}

// @alpha
export interface SchemaPolicy {
    readonly defaultGlobalFieldSchema: FieldSchema;
    readonly defaultTreeSchema: TreeSchema;
}

// @alpha
export interface SchematizeConfiguration<TMap extends ViewSchemaCollection = ViewSchemaCollection> {
    readonly allowedSchemaModifications: AllowedUpdateType;
    readonly initialTree: ContextuallyTypedFieldData;
    readonly schema: TMap;
}

// @alpha (undocumented)
export interface SequenceFieldEditBuilder {
    delete(index: number, count: number): void;
    insert(index: number, newContent: ITreeCursor | ITreeCursor[]): void;
    move(sourceIndex: number, count: number, destIndex: number): void;
    revive(index: number, count: number, detachedBy: RevisionTag, reviver: NodeReviver, detachIndex: number, isIntention?: true): void;
}

// @alpha
export class SharedTreeFactory implements IChannelFactory {
    // (undocumented)
    attributes: IChannelAttributes;
    // (undocumented)
    create(runtime: IFluidDataStoreRuntime, id: string): ISharedTree;
    // (undocumented)
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, channelAttributes: Readonly<IChannelAttributes>): Promise<ISharedTree>;
    // (undocumented)
    type: string;
}

// @alpha
export class SimpleDependee implements Dependee {
    constructor(computationName?: string);
    // (undocumented)
    readonly computationName: string;
    invalidateDependents(token?: InvalidationToken): void;
    // @sealed (undocumented)
    listDependents(): Set<Dependent>;
    // (undocumented)
    registerDependent(dependent: Dependent): boolean;
    // (undocumented)
    removeDependent(dependent: Dependent): void;
}

// @alpha
export function singleJsonCursor(root: JsonCompatible): ITreeCursorSynchronous;

// @alpha
export function singleStackTreeCursor<TNode>(root: TNode, adapter: CursorAdapter<TNode>): CursorWithNode<TNode>;

// @alpha
export function singleTextCursor(root: JsonableTree): ITreeCursorSynchronous;

// @alpha
type Skip = number;

// @internal
export type StableId = UuidString & {
    readonly StableId: "53172b0d-a3d5-41ea-bd75-b43839c97f5a";
};

// @alpha
export interface StoredSchemaRepository<TPolicy extends SchemaPolicy = SchemaPolicy> extends Dependee, ISubscribable<SchemaEvents>, SchemaDataAndPolicy<TPolicy> {
    update(newSchema: SchemaData): void;
}

// @alpha (undocumented)
export function symbolFromKey(key: GlobalFieldKey): GlobalFieldKeySymbol;

// @alpha (undocumented)
export function symbolIsFieldKey(key: symbol): key is GlobalFieldKeySymbol;

// @alpha (undocumented)
export interface TaggedChange<TChangeset> {
    // (undocumented)
    readonly change: TChangeset;
    // (undocumented)
    readonly revision: RevisionTag | undefined;
    readonly rollbackOf?: RevisionTag;
}

// @alpha
export type ToDelta = (child: NodeChangeset) => Delta.Modify;

// @alpha
export enum TransactionResult {
    Abort = 0,
    Commit = 1
}

// @alpha (undocumented)
interface TreeInfoFromBuilder<T extends TypedTreeSchemaBuilder, TName extends string> {
    // (undocumented)
    readonly extraGlobalFields: WithDefault<T["extraGlobalFields"], false>;
    // (undocumented)
    readonly extraLocalFields: WithDefault<T["extraLocalFields"], typeof emptyField_2>;
    // (undocumented)
    readonly global: AsNames<WithDefault<T["global"], []>, GlobalFieldKeySymbol>;
    // (undocumented)
    readonly local: WithDefault<T["local"], Record<string, never>>;
    // (undocumented)
    readonly name: TName;
    // (undocumented)
    readonly value: WithDefault<T["value"], ValueSchema.Nothing>;
}

// @alpha (undocumented)
export interface TreeLocation {
    // (undocumented)
    readonly index: number;
    // (undocumented)
    readonly range: FieldLocation | DetachedField;
}

// @alpha (undocumented)
export const enum TreeNavigationResult {
    NotFound = -1,
    Ok = 1,
    Pending = 0
}

// @alpha (undocumented)
export interface TreeSchema {
    readonly extraGlobalFields: boolean;
    readonly extraLocalFields: FieldSchema;
    readonly globalFields: ReadonlySet<GlobalFieldKey>;
    readonly localFields: ReadonlyMap<LocalFieldKey, FieldSchema>;
    readonly value: ValueSchema;
}

// @alpha
export interface TreeSchemaBuilder {
    // (undocumented)
    readonly extraGlobalFields?: boolean;
    // (undocumented)
    readonly extraLocalFields: FieldSchema;
    // (undocumented)
    readonly globalFields?: Iterable<GlobalFieldKey>;
    // (undocumented)
    readonly localFields?: {
        [key: string]: FieldSchema;
    };
    // (undocumented)
    readonly value?: ValueSchema;
}

// @alpha
export type TreeSchemaIdentifier = Brand<string, "tree.Schema">;

// @alpha
interface TreeSchemaTypeInfo {
    // (undocumented)
    readonly extraGlobalFields: boolean;
    // (undocumented)
    readonly extraLocalFields: FieldSchemaTypeInfo;
    // (undocumented)
    readonly global: readonly GlobalFieldKeySymbol[];
    // (undocumented)
    readonly local: {
        readonly [key: string]: FieldSchemaTypeInfo;
    };
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly value: ValueSchema;
}

// @alpha (undocumented)
export type TreeType = TreeSchemaIdentifier;

// @alpha
export type TreeTypeSet = ReadonlySet<TreeSchemaIdentifier> | undefined;

// @alpha
export interface TreeValue extends Serializable {
}

// @alpha (undocumented)
export interface TreeViewSchema extends TreeSchema {
}

// @alpha
type TypedField<TMap extends TypedSchemaData, Mode extends ApiMode, TField extends TypedSchema.FieldSchemaTypeInfo> = [
ApplyMultiplicity<TField["kind"]["multiplicity"], TypeSetToTypedTrees<TMap, Mode, TField["types"]>, Mode>
][TypedSchema._dummy];

// @alpha
type TypedFields<TMap extends TypedSchemaData, Mode extends ApiMode, TFields extends {
    [key: string]: TypedSchema.FieldSchemaTypeInfo;
}> = [
    {
    [key in keyof TFields]: TypedField<TMap, Mode, TFields[key]>;
}
][TypedSchema._dummy];

// @alpha
function typedFieldSchema<TKind extends FieldKind, TTypes extends [string | Named<string>, ...(string | Named<string>)[]]>(kind: TKind, ...typeArray: TTypes): {
    kind: TKind;
    types: NameSet<UnbrandList<AsNames<TTypes>, TreeSchemaIdentifier>>;
};

// @alpha
type TypedNode<TNames extends readonly string[], Mode extends ApiMode, TMap extends TypedSchemaData> = ValuesOf<{
    [Property in keyof TypedSchema.ListToKeys<TNames, 0>]: TMap["treeSchemaObject"] extends {
        [key in Property]: any;
    } ? TypedTree<TMap, Mode, TMap["treeSchemaObject"][Property]> : never;
}>;

declare namespace TypedSchema {
    export {
        typedTreeSchema as tree,
        typedFieldSchema as field,
        unrestrictedFieldSchema as fieldUnrestricted,
        TreeInfoFromBuilder,
        emptyField_2 as emptyField,
        TypedTreeSchemaBuilder,
        nameSet,
        FieldSchemaTypeInfo,
        LabeledTreeSchema,
        TreeSchemaTypeInfo,
        NameSet,
        ObjectToMap,
        AsNames,
        Assume,
        WithDefault,
        AsName,
        ListToKeys,
        AllowOptional,
        RequiredFields,
        OptionalFields,
        Unbrand,
        UnbrandList,
        _dummy,
        FlattenKeys,
        AllowOptionalNotFlattened
    }
}
export { TypedSchema }

// @alpha
interface TypedSchemaData extends ViewSchemaCollection {
    // (undocumented)
    readonly allTypes: readonly string[];
    // (undocumented)
    readonly policy: FullSchemaPolicy;
    // (undocumented)
    readonly treeSchemaObject: Record<string, any>;
}

// @alpha
function typedSchemaData<T extends TypedSchema.LabeledTreeSchema[]>(globalFieldSchema: [GlobalFieldKey, FieldViewSchema][], ...t: T): SchemaDataAndPolicy<FullSchemaPolicy> & ViewSchemaCollection & {
    treeSchemaObject: {
        [schema in T[number] as schema["typeInfo"]["name"]]: schema;
    };
    allTypes: NamesFromSchema<T>;
};

// @alpha
type TypedTree<TMap extends TypedSchemaData, Mode extends ApiMode, TSchema extends TypedSchema.LabeledTreeSchema> = CollectOptions<Mode, TypedFields<TMap, Mode, TSchema["typeInfo"]["local"]>, TSchema["typeInfo"]["value"], TSchema["typeInfo"]["name"]>;

// @alpha
function typedTreeSchema<T extends TypedTreeSchemaBuilder, TName extends string>(name: TName, t: T): LabeledTreeSchema<TreeInfoFromBuilder<T, TName>>;

// @alpha
interface TypedTreeSchemaBuilder {
    // (undocumented)
    readonly extraGlobalFields?: boolean;
    // (undocumented)
    readonly extraLocalFields?: FieldSchemaTypeInfo;
    // (undocumented)
    readonly global?: (GlobalFieldKeySymbol | Named<GlobalFieldKeySymbol>)[];
    // (undocumented)
    readonly local?: {
        readonly [key: string]: FieldSchemaTypeInfo;
    };
    // (undocumented)
    readonly value?: ValueSchema;
}

// @alpha
type TypedValue<TValue extends ValueSchema> = {
    [ValueSchema.Nothing]: undefined;
    [ValueSchema.Number]: number;
    [ValueSchema.String]: string;
    [ValueSchema.Boolean]: boolean;
    [ValueSchema.Serializable]: Value;
}[TValue];

// @alpha
export const typeNameSymbol: unique symbol;

// @alpha
type TypeSetToTypedTrees<TMap extends TypedSchemaData, Mode extends ApiMode, T extends unknown | TypedSchema.NameSet> = [
TypedNode<T extends TypedSchema.NameSet<infer Names> ? Names : TMap["allTypes"], Mode, TMap>
][TypedSchema._dummy];

// @alpha
export const typeSymbol: unique symbol;

// @alpha
type Unbrand<T, B> = T extends infer S & B ? S : T;

// @alpha
type UnbrandList<T extends unknown[], B> = T extends [infer Head, ...infer Tail] ? [Unbrand<Head, B>, ...UnbrandList<Tail, B>] : [];

// @alpha
function unrestrictedFieldSchema<TKind extends FieldKind>(kind: TKind): {
    kind: TKind;
};

// @alpha
export interface UntypedField extends MarkedArrayLike<UnwrappedUntypedTree> {
    readonly context: UntypedTreeContext;
    readonly fieldKey: FieldKey;
    readonly fieldSchema: FieldSchema;
    getNode(index: number): UntypedTree;
    readonly parent?: UntypedTree;
}

// @alpha
interface UntypedSequenceField extends UntypedField {
    readonly context: UntypedTreeContext;
    deleteNodes(index: number, count?: number): void;
    readonly fieldKey: FieldKey;
    readonly fieldSchema: FieldSchema & {
        readonly kind: FieldKind<FieldEditor<any>, Multiplicity.Sequence>;
    };
    getNode(index: number): UntypedTree;
    insertNodes(index: number, newContent: ITreeCursor | ITreeCursor[]): void;
    readonly parent?: UntypedTree;
    replaceNodes(index: number, newContent: ITreeCursor | ITreeCursor[], count?: number): void;
}

// @alpha
export interface UntypedTree extends UntypedTreeCore {
    readonly [typeNameSymbol]: TreeSchemaIdentifier;
    readonly [valueSymbol]: Value;
    readonly [key: FieldKey]: UnwrappedUntypedField;
}

// @alpha
export interface UntypedTreeContext extends ISubscribable<ForestEvents> {
    clear(): void;
    free(): void;
    prepareForEdit(): void;
    readonly root: UntypedField;
    readonly schema: SchemaDataAndPolicy;
    readonly unwrappedRoot: UnwrappedUntypedField;
}

// @alpha
export interface UntypedTreeCore extends Iterable<UntypedField> {
    readonly [contextSymbol]: UntypedTreeContext;
    [getField](fieldKey: FieldKey): UntypedField;
    // (undocumented)
    [on]<K extends keyof EditableTreeEvents>(eventName: K, listener: EditableTreeEvents[K]): () => void;
    readonly [parentField]: {
        readonly parent: UntypedField;
        readonly index: number;
    };
    readonly [typeSymbol]: TreeSchema;
}

// @alpha
export type UntypedTreeOrPrimitive = UntypedTree | PrimitiveValue;

// @alpha
export type UnwrappedEditableField = UnwrappedEditableTree | undefined | EditableField;

// @alpha
export type UnwrappedEditableTree = EditableTreeOrPrimitive | EditableField;

// @alpha
export type UnwrappedUntypedField = UnwrappedUntypedTree | undefined | UntypedField;

// @alpha
export type UnwrappedUntypedTree = UntypedTreeOrPrimitive | UntypedField;

// @alpha
export interface UpPath<TParent = UpPathDefault> {
    readonly parent: TParent | undefined;
    readonly parentField: FieldKey;
    readonly parentIndex: number;
}

// @alpha
export type UpPathDefault = UpPath;

// @alpha
export type UuidString = string & {
    readonly UuidString: "9d40d0ae-90d9-44b1-9482-9f55d59d5465";
};

// @alpha
export type Value = undefined | TreeValue;

// @alpha (undocumented)
export interface ValueChange {
    revision?: RevisionTag;
    value?: Value;
}

// @alpha (undocumented)
export interface ValueConstraint {
    // (undocumented)
    value: Value;
    // (undocumented)
    violated: boolean;
}

// @alpha (undocumented)
export interface ValueFieldEditBuilder {
    set(newContent: ITreeCursor): void;
}

// @alpha (undocumented)
type ValueFieldTreeFromSchema<TSchema extends ValueSchema> = undefined extends TypedValue<TSchema> ? {
    [valueSymbol]?: TypedValue<TSchema>;
} : {
    [valueSymbol]: TypedValue<TSchema>;
};

// @alpha
export type ValueFromBranded<T extends BrandedType<any, string>> = T extends BrandedType<infer ValueType, string> ? ValueType : never;

// @alpha
export enum ValueSchema {
    // (undocumented)
    Boolean = 3,
    // (undocumented)
    Nothing = 0,
    // (undocumented)
    Number = 1,
    Serializable = 4,
    // (undocumented)
    String = 2
}

// @alpha (undocumented)
type ValuesOf<T> = T[keyof T];

// @alpha
export const valueSymbol: unique symbol;

// @alpha
export interface ViewEvents {
    afterBatch(): void;
}

// @alpha
export interface ViewSchemaCollection {
    // (undocumented)
    readonly globalFieldSchema: ReadonlyMap<GlobalFieldKey, FieldViewSchema>;
    // (undocumented)
    readonly policy: SchemaPolicy;
    // (undocumented)
    readonly treeSchema: ReadonlyMap<TreeSchemaIdentifier, TreeViewSchema>;
}

// @alpha
type WithDefault<T, Default> = T extends undefined ? Default : unknown extends T ? Default : T;

// (No @packageDocumentation comment for this package)

```
