## API Report File for "@fluid-internal/tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Jsonable } from '@fluidframework/datastore-definitions';
import { Serializable } from '@fluidframework/datastore-definitions';

// @public
export type Anchor = Brand<number, "rebaser.Anchor">;

// @public
export class AnchorSet {
    // (undocumented)
    forget(anchor: Anchor): void;
    locate(anchor: Anchor): UpPath | undefined;
    moveChildren(src: UpPath, srcField: FieldKey, start: number, count: number, dst: UpPath, dstField: FieldKey, dstIndex: number): void;
    track(path: UpPath): Anchor;
}

// @public
export type Brand<ValueType, Name extends string> = ValueType & BrandedType<ValueType, Name>;

// @public
export abstract class BrandedType<ValueType, Name extends string> {
    protected readonly _type_brand: Name;
    // (undocumented)
    protected _typeCheck?: Invariant<ValueType>;
}

// @public (undocumented)
export function buildForest(): IEditableForest;

// @public (undocumented)
export type ChangeFromChangeRebaser<TChangeRebaser extends ChangeRebaser<any, any, any>> = TChangeRebaser extends ChangeRebaser<infer TChange, any, any> ? TChange : never;

// @public
export interface ChangeRebaser<TChange, TFinalChange, TChangeSet> {
    compose(...changes: TChangeSet[]): TChangeSet;
    // (undocumented)
    export(change: TChangeSet): TFinalChange;
    // (undocumented)
    import(change: TChange): TChangeSet;
    invert(changes: TChangeSet): TChangeSet;
    // (undocumented)
    rebase(change: TChangeSet, over: TChangeSet): TChangeSet;
    // (undocumented)
    rebaseAnchors(anchor: AnchorSet, over: TChangeSet): void;
    // (undocumented)
    _typeCheck?: Covariant<TChange> & Contravariant<TFinalChange> & Invariant<TChangeSet>;
}

// @public (undocumented)
export type ChangeSetFromChangeRebaser<TChangeRebaser extends ChangeRebaser<any, any, any>> = TChangeRebaser extends ChangeRebaser<any, any, infer TChangeSet> ? TChangeSet : never;

// @public
export type ChildCollection = FieldKey | RootField;

// @public
export interface ChildLocation {
    // (undocumented)
    readonly container: ChildCollection;
    // (undocumented)
    readonly index: number;
}

// @public
export interface Contravariant<T> {
    // (undocumented)
    _removeCovariance?: (_: T) => void;
}

// @public
export interface Covariant<T> {
    // (undocumented)
    _removeContravariance?: T;
}

// @public
export function cursorToJsonObject(reader: ITreeCursor): unknown;

// @public
interface Delete {
    // (undocumented)
    count: number;
    // (undocumented)
    type: typeof MarkType.Delete;
}

declare namespace Delta {
    export {
        inputLength,
        Root,
        Mark,
        OuterMark,
        InnerModify,
        MarkList,
        Skip,
        Modify,
        ModifyDeleted,
        ModifyMovedOut,
        ModifyMovedIn,
        ModifyInserted,
        Delete,
        ModifyAndDelete,
        MoveOut,
        ModifyAndMoveOut,
        MoveIn,
        MoveInAndModify,
        Insert,
        InsertAndModify,
        ProtoNode,
        MoveId,
        Offset,
        FieldMap_2 as FieldMap,
        FieldMarks,
        MarkType
    }
}
export { Delta }

// @public
export interface Dependee extends NamedComputation {
    registerDependent(dependent: Dependent): boolean;
    removeDependent(dependent: Dependent): void;
}

// @public
export interface Dependent extends NamedComputation {
    markInvalid(token?: InvalidationToken): void;
}

// @public
export interface DetachedField extends Opaque<Brand<string, "tree.DetachedField">> {
}

// @public
export const emptyField: FieldSchema;

// @public
export const EmptyKey: FieldKey;

// @public
export type ExtractFromOpaque<TOpaque extends BrandedType<any, string>> = TOpaque extends BrandedType<infer ValueType, infer Name> ? isAny<ValueType> extends true ? unknown : Brand<ValueType, Name> : never;

// @public
export function extractFromOpaque<TOpaque extends BrandedType<any, string>>(value: TOpaque): ExtractFromOpaque<TOpaque>;

// @public (undocumented)
export type FieldKey = LocalFieldKey | GlobalFieldKey;

// @public
export enum FieldKind {
    Forbidden = 3,
    Optional = 1,
    Sequence = 2,
    Value = 0
}

// @public
export interface FieldLocation {
    // (undocumented)
    readonly key: FieldKey;
    // (undocumented)
    readonly parent: ForestLocation;
}

// @public
export interface FieldMap<TChild> {
    // (undocumented)
    [key: string]: TChild[];
}

// @public (undocumented)
type FieldMap_2<T> = Map<FieldKey, T>;

// @public (undocumented)
type FieldMarks<TMark> = FieldMap_2<MarkList<TMark>>;

// @public (undocumented)
export interface FieldSchema {
    // (undocumented)
    readonly kind: FieldKind;
    readonly types?: ReadonlySet<TreeSchemaIdentifier>;
}

// @public (undocumented)
export type FinalFromChangeRebaser<TChangeRebaser extends ChangeRebaser<any, any, any>> = TChangeRebaser extends ChangeRebaser<any, infer TFinal, any> ? TFinal : never;

// @public
export interface ForestAnchor {
    free(): void;
    readonly state: ITreeSubscriptionCursorState;
}

// @public
export type ForestLocation = ITreeSubscriptionCursor | ForestAnchor;

// @public
export interface GenericTreeNode<TChild> extends NodeData {
    // (undocumented)
    fields?: FieldMap<TChild>;
}

// @public
export interface GlobalFieldKey extends Opaque<Brand<string, "tree.GlobalFieldKey">> {
}

// @public
export interface IEditableForest extends IForestSubscription {
    readonly anchors: AnchorSet;
    applyDelta(delta: Delta.Root): void;
    // (undocumented)
    readonly schema: StoredSchemaRepository;
}

// @public
export interface IForestSubscription extends Dependee {
    allocateCursor(): ITreeSubscriptionCursor;
    root(range: DetachedField): ForestAnchor;
    // (undocumented)
    readonly rootField: DetachedField;
    readonly schema: SchemaRepository & Dependee;
    tryGet(destination: ForestAnchor, cursorToMove: ITreeSubscriptionCursor, observer?: ObservingDependent): TreeNavigationResult;
}

// @public
type InnerModify = ModifyDeleted | ModifyInserted | ModifyMovedIn | ModifyMovedOut;

// @public
function inputLength(mark: Mark): number;

// @public
interface Insert {
    // (undocumented)
    content: ProtoNode[];
    // (undocumented)
    type: typeof MarkType.Insert;
}

// @public
interface InsertAndModify {
    // (undocumented)
    content: ProtoNode;
    // (undocumented)
    fields: FieldMarks<Skip | ModifyInserted | MoveIn | MoveInAndModify>;
    // (undocumented)
    type: typeof MarkType.InsertAndModify;
}

// @public
export class InvalidationToken {
    constructor(description: string, isSecondaryInvalidation?: boolean);
    // (undocumented)
    readonly description: string;
    // (undocumented)
    readonly isSecondaryInvalidation: boolean;
    // (undocumented)
    protected readonly _typeCheck: MakeNominal;
}

// @public
export interface Invariant<T> extends Contravariant<T>, Covariant<T> {
}

// @public
export type isAny<T> = boolean extends (T extends {} ? true : false) ? true : false;

// @public
export interface ITreeCursor {
    down(key: FieldKey, index: number): TreeNavigationResult;
    // (undocumented)
    keys: Iterable<FieldKey>;
    // (undocumented)
    length(key: FieldKey): number;
    seek(offset: number): {
        result: TreeNavigationResult;
        moved: number;
    };
    readonly type: TreeType;
    up(): TreeNavigationResult;
    readonly value: Value;
}

// @public
export interface ITreeSubscriptionCursor extends ITreeCursor {
    buildAnchor(): ForestAnchor;
    clear(): void;
    // (undocumented)
    fork(observer?: ObservingDependent): ITreeSubscriptionCursor;
    free(): void;
    observer?: ObservingDependent;
    readonly state: ITreeSubscriptionCursorState;
}

// @public (undocumented)
export enum ITreeSubscriptionCursorState {
    Cleared = 1,
    Current = 0,
    Freed = 2
}

// @public
export interface JsonableTree extends PlaceholderTree {
}

// @public
export function jsonableTreeFromCursor(cursor: ITreeCursor): JsonableTree;

// @public (undocumented)
export const jsonArray: NamedTreeSchema;

// @public (undocumented)
export const jsonBoolean: NamedTreeSchema;

// @public
export class JsonCursor<T> implements ITreeCursor {
    constructor(root: Jsonable<T>);
    // (undocumented)
    down(key: FieldKey, index: number): TreeNavigationResult;
    // (undocumented)
    get keys(): Iterable<FieldKey>;
    // (undocumented)
    length(key: FieldKey): number;
    // (undocumented)
    seek(offset: number): {
        result: TreeNavigationResult;
        moved: number;
    };
    // (undocumented)
    get type(): TreeType;
    // (undocumented)
    up(): TreeNavigationResult;
    // (undocumented)
    get value(): Value;
}

// @public (undocumented)
export const jsonNull: NamedTreeSchema;

// @public (undocumented)
export const jsonNumber: NamedTreeSchema;

// @public (undocumented)
export const jsonObject: NamedTreeSchema;

// @public (undocumented)
export const jsonString: NamedTreeSchema;

// @public (undocumented)
export const jsonTypeSchema: Map<TreeSchemaIdentifier, NamedTreeSchema>;

// @public
export type LocalFieldKey = Brand<string, "tree.LocalFieldKey">;

// @public
export interface MakeNominal {
}

// @public
type Mark = OuterMark | InnerModify;

// @public
type MarkList<TMark = Mark> = TMark[];

// @public (undocumented)
const MarkType: {
    readonly Modify: 0;
    readonly Insert: 1;
    readonly InsertAndModify: 2;
    readonly MoveIn: 3;
    readonly MoveInAndModify: 4;
    readonly Delete: 5;
    readonly ModifyAndDelete: 6;
    readonly MoveOut: 7;
    readonly ModifyAndMoveOut: 8;
};

// @public
interface Modify {
    // (undocumented)
    fields?: FieldMarks<OuterMark>;
    // (undocumented)
    setValue?: Value;
    // (undocumented)
    type: typeof MarkType.Modify;
}

// @public
interface ModifyAndDelete {
    // (undocumented)
    fields: FieldMarks<Skip | ModifyDeleted | MoveOut>;
    // (undocumented)
    type: typeof MarkType.ModifyAndDelete;
}

// @public
interface ModifyAndMoveOut {
    // (undocumented)
    fields?: FieldMarks<Skip | ModifyMovedOut | Delete | MoveOut>;
    moveId: MoveId;
    // (undocumented)
    setValue?: Value;
    // (undocumented)
    type: typeof MarkType.ModifyAndMoveOut;
}

// @public
interface ModifyDeleted {
    // (undocumented)
    fields: FieldMarks<Skip | ModifyDeleted | ModifyAndMoveOut | MoveOut>;
    // (undocumented)
    type: typeof MarkType.Modify;
}

// @public
interface ModifyInserted {
    // (undocumented)
    fields: FieldMarks<Skip | ModifyInserted | MoveIn | MoveInAndModify>;
    // (undocumented)
    type: typeof MarkType.Modify;
}

// @public
interface ModifyMovedIn {
    // (undocumented)
    fields: FieldMarks<Skip | ModifyMovedIn | MoveIn | MoveInAndModify | Insert | InsertAndModify>;
    // (undocumented)
    type: typeof MarkType.Modify;
}

// @public
interface ModifyMovedOut {
    // (undocumented)
    fields?: FieldMarks<Skip | ModifyMovedOut | Delete | ModifyAndDelete | ModifyAndMoveOut | MoveOut>;
    // (undocumented)
    setValue?: Value;
    // (undocumented)
    type: typeof MarkType.Modify;
}

// @public
interface MoveId extends Opaque<Brand<number, "delta.MoveId">> {
}

// @public
interface MoveIn {
    moveId: MoveId;
    // (undocumented)
    type: typeof MarkType.MoveIn;
}

// @public
interface MoveInAndModify {
    // (undocumented)
    fields: FieldMarks<Skip | ModifyMovedIn | MoveIn | Insert>;
    moveId: MoveId;
    // (undocumented)
    type: typeof MarkType.MoveInAndModify;
}

// @public
interface MoveOut {
    // (undocumented)
    count: number;
    moveId: MoveId;
    // (undocumented)
    type: typeof MarkType.MoveOut;
}

// @public (undocumented)
export interface Named<TName> {
    // (undocumented)
    readonly name: TName;
}

// @public
export interface NamedComputation {
    readonly computationName: string;
    listDependees?(): Iterable<Dependee>;
    listDependents?(): Iterable<Dependent>;
}

// @public (undocumented)
export type NamedTreeSchema = TreeSchema & Named<TreeSchemaIdentifier>;

// @public
export const neverTree: TreeSchema;

// @public
export interface NodeData {
    readonly type: TreeSchemaIdentifier;
    value?: TreeValue;
}

// @public
export interface ObservingDependent extends Dependent {
    // @override
    listDependees(): Iterable<Dependee>;
    registerDependee(dependee: Dependee): void;
}

// @public (undocumented)
type Offset = number;

// @public
export type Opaque<T extends Brand<any, string>> = T extends Brand<infer ValueType, infer Name> ? BrandedType<ValueType, Name> : never;

// @public
type OuterMark = Skip | Modify | Delete | MoveOut | MoveIn | Insert | ModifyAndDelete | ModifyAndMoveOut | MoveInAndModify | InsertAndModify;

// @public
export type PlaceholderTree<TPlaceholder = never> = GenericTreeNode<PlaceholderTree<TPlaceholder>> | TPlaceholder;

// @public
type ProtoNode = JsonableTree;

// @public
export class Rebaser<TChangeRebaser extends ChangeRebaser<any, any, any>> {
    constructor(rebaser: TChangeRebaser);
    discardRevision(revision: RevisionTag): void;
    // (undocumented)
    readonly empty: RevisionTag;
    // (undocumented)
    getResolutionPath(from: RevisionTag, to: RevisionTag): ChangeSetFromChangeRebaser<TChangeRebaser>;
    rebase(changes: ChangeFromChangeRebaser<TChangeRebaser>, from: RevisionTag, to: RevisionTag): [RevisionTag, FinalFromChangeRebaser<TChangeRebaser>];
    rebaseAnchors(anchors: AnchorSet, from: RevisionTag, to: RevisionTag): void;
    // (undocumented)
    readonly rebaser: TChangeRebaser;
}

// @public
export function recordDependency(dependent: ObservingDependent | undefined, dependee: Dependee): void;

// @public
export type RevisionTag = Brand<number, "rebaser.RevisionTag">;

// @public
type Root = FieldMarks<OuterMark>;

// @public
export interface RootField {
    // (undocumented)
    readonly key: DetachedField;
}

// @public
export const rootFieldKey: BrandedType<string, "tree.GlobalFieldKey">;

// @public (undocumented)
export interface SchemaRepository {
    // (undocumented)
    readonly globalFieldSchema: ReadonlyMap<GlobalFieldKey, FieldSchema>;
    lookupGlobalFieldSchema(key: GlobalFieldKey): FieldSchema;
    lookupTreeSchema(identifier: TreeSchemaIdentifier): TreeSchema;
    // (undocumented)
    readonly treeSchema: ReadonlyMap<TreeSchemaIdentifier, TreeSchema>;
}

// @public
export class SimpleDependee implements Dependee {
    constructor(computationName?: string);
    // (undocumented)
    readonly computationName: string;
    invalidateDependents(): void;
    // (undocumented)
    listDependents(): Set<Dependent>;
    // (undocumented)
    registerDependent(dependent: Dependent): boolean;
    // (undocumented)
    removeDependent(dependent: Dependent): void;
}

// @public
type Skip = number;

// @public
export class StoredSchemaRepository extends SimpleDependee implements SchemaRepository, Dependee {
    constructor(fields?: Map<GlobalFieldKey, FieldSchema>, trees?: Map<TreeSchemaIdentifier, TreeSchema>);
    // (undocumented)
    clone(): StoredSchemaRepository;
    // (undocumented)
    readonly computationName: string;
    // (undocumented)
    protected readonly fields: Map<GlobalFieldKey, FieldSchema>;
    // (undocumented)
    get globalFieldSchema(): ReadonlyMap<GlobalFieldKey, FieldSchema>;
    // (undocumented)
    lookupGlobalFieldSchema(identifier: GlobalFieldKey): FieldSchema;
    // (undocumented)
    lookupTreeSchema(identifier: TreeSchemaIdentifier): TreeSchema;
    // (undocumented)
    protected readonly trees: Map<TreeSchemaIdentifier, TreeSchema>;
    // (undocumented)
    get treeSchema(): ReadonlyMap<TreeSchemaIdentifier, TreeSchema>;
    tryUpdateFieldSchema(identifier: GlobalFieldKey, schema: FieldSchema): boolean;
    tryUpdateTreeSchema(identifier: TreeSchemaIdentifier, schema: TreeSchema): boolean;
}

// @public
export class TextCursor implements ITreeCursor {
    constructor(root: JsonableTree);
    // (undocumented)
    down(key: FieldKey, index: number): TreeNavigationResult;
    // (undocumented)
    getField(key: FieldKey): readonly JsonableTree[];
    // (undocumented)
    getFields(): Readonly<FieldMap<JsonableTree>>;
    // (undocumented)
    getNode(): JsonableTree;
    // (undocumented)
    get keys(): Iterable<FieldKey>;
    // (undocumented)
    length(key: FieldKey): number;
    // (undocumented)
    seek(offset: number): {
        result: TreeNavigationResult;
        moved: number;
    };
    // (undocumented)
    get type(): TreeType;
    // (undocumented)
    up(): TreeNavigationResult;
    // (undocumented)
    get value(): Value;
}

// @public (undocumented)
export interface TreeLocation {
    // (undocumented)
    readonly index: number;
    // (undocumented)
    readonly range: FieldLocation | DetachedField;
}

// @public (undocumented)
export const enum TreeNavigationResult {
    NotFound = -1,
    Ok = 1,
    Pending = 0
}

// @public (undocumented)
export interface TreeSchema {
    readonly extraGlobalFields: boolean;
    readonly extraLocalFields: FieldSchema;
    readonly globalFields: ReadonlySet<GlobalFieldKey>;
    readonly localFields: ReadonlyMap<LocalFieldKey, FieldSchema>;
    readonly value: ValueSchema;
}

// @public
export type TreeSchemaIdentifier = Brand<string, "tree.TreeSchemaIdentifier">;

// @public (undocumented)
export type TreeType = TreeSchemaIdentifier;

// @public
export interface TreeValue extends Serializable {
}

// @public
export interface UpPath {
    // (undocumented)
    readonly parent: UpPath | undefined;
    readonly parentField: FieldKey;
    readonly parentIndex: number;
}

// @public
export type Value = undefined | TreeValue;

// @public
export enum ValueSchema {
    // (undocumented)
    Boolean = 3,
    // (undocumented)
    Nothing = 0,
    // (undocumented)
    Number = 1,
    Serializable = 4,
    // (undocumented)
    String = 2
}

// (No @packageDocumentation comment for this package)

```
