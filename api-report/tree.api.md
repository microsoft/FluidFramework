## API Report File for "@fluid-internal/tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { IChannelAttributes } from '@fluidframework/datastore-definitions';
import { IChannelFactory } from '@fluidframework/datastore-definitions';
import { IChannelServices } from '@fluidframework/datastore-definitions';
import { IFluidDataStoreRuntime } from '@fluidframework/datastore-definitions';
import { ISharedObject } from '@fluidframework/shared-object-base';
import { IsoBuffer } from '@fluidframework/common-utils';
import { Serializable } from '@fluidframework/datastore-definitions';

// @alpha
export type Anchor = Brand<number, "rebaser.Anchor">;

// @alpha
export interface AnchorLocator {
    locate(anchor: Anchor): UpPath | undefined;
}

// @alpha @sealed
export class AnchorSet {
    applyDelta(delta: Delta.Root): void;
    // (undocumented)
    forget(anchor: Anchor): void;
    isEmpty(): boolean;
    // (undocumented)
    locate(anchor: Anchor): UpPath | undefined;
    moveChildren(count: number, srcStart: UpPath | undefined, dst: UpPath | undefined): void;
    track(path: UpPath | null): Anchor;
}

// @alpha
export type Brand<ValueType, Name extends string> = ValueType & BrandedType<ValueType, Name>;

// @alpha
export function brand<T extends Brand<any, string>>(value: T extends BrandedType<infer ValueType, string> ? ValueType : never): T;

// @alpha @sealed
export abstract class BrandedType<ValueType, Name extends string> {
    protected readonly _type_brand: Name;
    // (undocumented)
    protected _typeCheck?: Invariant<ValueType>;
}

// @alpha
export function brandOpaque<T extends BrandedType<any, string>>(value: isAny<ValueFromBranded<T>> extends true ? never : ValueFromBranded<T>): BrandedType<ValueFromBranded<T>, NameFromBranded<T>>;

// @alpha (undocumented)
export function buildForest(schema: StoredSchemaRepository, anchors?: AnchorSet): IEditableForest;

// @alpha
export abstract class ChangeEncoder<TChange> {
    decodeBinary(formatVersion: number, change: IsoBuffer): TChange;
    abstract decodeJson(formatVersion: number, change: JsonCompatibleReadOnly): TChange;
    encodeBinary(formatVersion: number, change: TChange): IsoBuffer;
    abstract encodeForJson(formatVersion: number, change: TChange): JsonCompatibleReadOnly;
}

// @alpha (undocumented)
export interface ChangeFamily<TEditor, TChange> {
    // (undocumented)
    buildEditor(changeReceiver: (change: TChange) => void, anchorSet: AnchorSet): TEditor;
    // (undocumented)
    readonly encoder: ChangeEncoder<TChange>;
    // (undocumented)
    intoDelta(change: TChange, repairStore?: ReadonlyRepairDataStore): Delta.Root;
    // (undocumented)
    readonly rebaser: ChangeRebaser<TChange>;
}

// @alpha
export interface ChangeRebaser<TChangeset> {
    compose(changes: TaggedChange<TChangeset>[]): TChangeset;
    // (undocumented)
    invert(changes: TaggedChange<TChangeset>): TChangeset;
    rebase(change: TChangeset, over: TaggedChange<TChangeset>): TChangeset;
    // (undocumented)
    rebaseAnchors(anchors: AnchorSet, over: TChangeset): void;
    // (undocumented)
    _typeCheck?: Invariant<TChangeset>;
}

// @alpha
export type ChangesetLocalId = Brand<number, "ChangesetLocalId">;

// @alpha
export type ChildCollection = FieldKey | RootField;

// @alpha
export interface ChildLocation {
    // (undocumented)
    readonly container: ChildCollection;
    // (undocumented)
    readonly index: number;
}

// @alpha
export type ContextuallyTypedNodeData = ContextuallyTypedNodeDataObject | PrimitiveValue | readonly ContextuallyTypedNodeData[] | MarkedArrayLike<ContextuallyTypedNodeData>;

// @alpha
export interface ContextuallyTypedNodeDataObject {
    readonly [typeNameSymbol]?: TreeSchemaIdentifier;
    readonly [valueSymbol]?: Value;
    [key: FieldKey]: ContextuallyTypedNodeData | undefined;
    [key: string]: ContextuallyTypedNodeData | undefined;
}

// @alpha
export interface Contravariant<T> {
    // (undocumented)
    _removeCovariance?: (_: T) => void;
}

// @alpha
export interface Covariant<T> {
    // (undocumented)
    _removeContravariance?: T;
}

// @alpha
export function createEmitter<E extends Events<E>>(): ISubscribable<E> & IEmitter<E>;

// @alpha
export const createField: unique symbol;

// @alpha (undocumented)
export const enum CursorLocationType {
    Fields = 1,
    Nodes = 0
}

// @alpha
export function cursorToJsonObject(reader: ITreeCursor): JsonCompatible;

// @alpha
export const defaultSchemaPolicy: FullSchemaPolicy;

// @alpha
interface Delete {
    // (undocumented)
    readonly count: number;
    // (undocumented)
    readonly type: typeof MarkType.Delete;
}

declare namespace Delta {
    export {
        Root,
        ProtoNode,
        Mark,
        MarkList,
        Skip,
        Modify,
        Delete,
        ModifyAndDelete,
        MoveOut,
        ModifyAndMoveOut,
        MoveIn,
        MoveInAndModify,
        Insert,
        InsertAndModify,
        MoveId,
        FieldMap,
        FieldMarks,
        MarkType
    }
}
export { Delta }

// @alpha
export interface Dependee extends NamedComputation {
    registerDependent(dependent: Dependent): boolean;
    removeDependent(dependent: Dependent): void;
}

// @alpha
export interface Dependent extends NamedComputation {
    markInvalid(token?: InvalidationToken): void;
}

// @alpha
export interface DetachedField extends Opaque<Brand<string, "tree.DetachedField">> {
}

// @alpha
export interface EditableField extends MarkedArrayLike<UnwrappedEditableTree | ContextuallyTypedNodeData> {
    readonly [proxyTargetSymbol]: object;
    deleteNodes(index: number, count?: number): void;
    readonly fieldKey: FieldKey;
    readonly fieldSchema: FieldSchema;
    getNode(index: number): EditableTree;
    insertNodes(index: number, newContent: ITreeCursor | ITreeCursor[]): void;
    readonly primaryType?: TreeSchemaIdentifier;
    replaceNodes(index: number, newContent: ITreeCursor | ITreeCursor[], count?: number): void;
}

// @alpha
export interface EditableTree extends Iterable<EditableField>, ContextuallyTypedNodeDataObject {
    [createField](fieldKey: FieldKey, newContent: ITreeCursor | ITreeCursor[]): void;
    [getField](fieldKey: FieldKey): EditableField;
    readonly [indexSymbol]: number;
    readonly [proxyTargetSymbol]: object;
    [replaceField](fieldKey: FieldKey, newContent: ITreeCursor | ITreeCursor[]): void;
    [Symbol.iterator](): IterableIterator<EditableField>;
    readonly [typeNameSymbol]: TreeSchemaIdentifier;
    readonly [typeSymbol]: TreeSchema;
    [valueSymbol]: Value;
    [key: FieldKey]: UnwrappedEditableField;
}

// @alpha
export interface EditableTreeContext extends ISubscribable<ForestEvents> {
    clear(): void;
    free(): void;
    prepareForEdit(): void;
    get root(): EditableField;
    set root(data: ContextuallyTypedNodeData | undefined);
    readonly schema: SchemaDataAndPolicy;
    get unwrappedRoot(): UnwrappedEditableField;
    set unwrappedRoot(data: ContextuallyTypedNodeData | undefined);
}

// @alpha
export type EditableTreeOrPrimitive = EditableTree | PrimitiveValue;

// @alpha
export const emptyField: FieldSchema;

// @alpha
export const EmptyKey: LocalFieldKey;

// @alpha
export type Events<E> = {
    [P in (string | symbol) & keyof E as IsEvent<E[P]> extends true ? P : never]: E[P];
};

// @alpha
export type ExtractFromOpaque<TOpaque extends BrandedType<any, string>> = TOpaque extends BrandedType<infer ValueType, infer Name> ? isAny<ValueType> extends true ? unknown : Brand<ValueType, Name> : never;

// @alpha
export function extractFromOpaque<TOpaque extends BrandedType<any, string>>(value: TOpaque): ExtractFromOpaque<TOpaque>;

// @alpha
export interface FieldAnchor {
    // (undocumented)
    fieldKey: FieldKey;
    parent: Anchor | undefined;
}

// @alpha (undocumented)
export interface FieldChange {
    // (undocumented)
    change: FieldChangeset;
    // (undocumented)
    fieldKind: FieldKindIdentifier;
    revision?: RevisionTag;
}

// @alpha (undocumented)
export interface FieldChangeEncoder<TChangeset> {
    decodeJson(formatVersion: number, change: JsonCompatibleReadOnly, decodeChild: NodeChangeDecoder): TChangeset;
    encodeForJson(formatVersion: number, change: TChangeset, encodeChild: NodeChangeEncoder): JsonCompatibleReadOnly;
}

// @alpha
export interface FieldChangeHandler<TChangeset, TEditor extends FieldEditor<TChangeset> = FieldEditor<TChangeset>> {
    // (undocumented)
    editor: TEditor;
    // (undocumented)
    encoder: FieldChangeEncoder<TChangeset>;
    // (undocumented)
    intoDelta(change: TChangeset, deltaFromChild: ToDelta, reviver: NodeReviver): Delta.MarkList;
    // (undocumented)
    rebaser: FieldChangeRebaser<TChangeset>;
    // (undocumented)
    _typeCheck?: Invariant<TChangeset>;
}

// @alpha (undocumented)
export type FieldChangeMap = Map<FieldKey, FieldChange>;

// @alpha (undocumented)
export interface FieldChangeRebaser<TChangeset> {
    compose(changes: TaggedChange<TChangeset>[], composeChild: NodeChangeComposer, genId: IdAllocator): TChangeset;
    // (undocumented)
    invert(change: TaggedChange<TChangeset>, invertChild: NodeChangeInverter, genId: IdAllocator): TChangeset;
    rebase(change: TChangeset, over: TaggedChange<TChangeset>, rebaseChild: NodeChangeRebaser, genId: IdAllocator): TChangeset;
}

// @alpha (undocumented)
export type FieldChangeset = Brand<unknown, "FieldChangeset">;

// @alpha (undocumented)
export interface FieldEditor<TChangeset> {
    buildChildChange(childIndex: number, change: NodeChangeset): TChangeset;
}

// @alpha
export type FieldKey = LocalFieldKey | GlobalFieldKeySymbol;

// @alpha @sealed
export class FieldKind<TEditor extends FieldEditor<any> = FieldEditor<any>> {
    constructor(identifier: FieldKindIdentifier, multiplicity: Multiplicity, changeHandler: FieldChangeHandler<any, TEditor>, allowsTreeSupersetOf: (originalTypes: ReadonlySet<TreeSchemaIdentifier> | undefined, superset: FieldSchema) => boolean, handlesEditsFrom: ReadonlySet<FieldKindIdentifier>);
    // (undocumented)
    allowsFieldSuperset(policy: FullSchemaPolicy, originalData: SchemaData, originalTypes: ReadonlySet<TreeSchemaIdentifier> | undefined, superset: FieldSchema): boolean;
    // (undocumented)
    readonly changeHandler: FieldChangeHandler<any, TEditor>;
    // (undocumented)
    readonly handlesEditsFrom: ReadonlySet<FieldKindIdentifier>;
    // (undocumented)
    readonly identifier: FieldKindIdentifier;
    // (undocumented)
    readonly multiplicity: Multiplicity;
}

// @alpha
export type FieldKindIdentifier = Brand<string, "tree.FieldKindIdentifier">;

// @alpha
export interface FieldLocation {
    // (undocumented)
    readonly key: FieldKey;
    // (undocumented)
    readonly parent: ForestLocation;
}

// @alpha (undocumented)
type FieldMap<T> = ReadonlyMap<FieldKey, T>;

// @alpha
export interface FieldMapObject<TChild> {
    // (undocumented)
    [key: string]: TChild[];
}

// @alpha (undocumented)
type FieldMarks<TTree = ProtoNode> = FieldMap<MarkList<TTree>>;

// @alpha (undocumented)
export interface FieldSchema {
    // (undocumented)
    readonly kind: FieldKindIdentifier;
    readonly types?: TreeTypeSet;
}

// @alpha
export const enum FieldScope {
    // (undocumented)
    global = "globalFields",
    // (undocumented)
    local = "fields"
}

// @alpha
export interface FieldUpPath {
    readonly field: FieldKey;
    readonly parent: UpPath | undefined;
}

// @alpha
export interface ForestEvents {
    afterDelta(delta: Delta.Root): void;
    beforeDelta(delta: Delta.Root): void;
}

// @alpha
export type ForestLocation = ITreeSubscriptionCursor | Anchor;

// @alpha
export interface FullSchemaPolicy extends SchemaPolicy {
    readonly fieldKinds: ReadonlyMap<FieldKindIdentifier, FieldKind>;
}

// @alpha
export interface GenericFieldsNode<TChild> {
    // (undocumented)
    [FieldScope.local]?: FieldMapObject<TChild>;
    // (undocumented)
    [FieldScope.global]?: FieldMapObject<TChild>;
}

// @alpha
export interface GenericTreeNode<TChild> extends GenericFieldsNode<TChild>, NodeData {
}

// @alpha
export const getField: unique symbol;

// @alpha (undocumented)
export function getPrimaryField(schema: TreeSchema): {
    key: LocalFieldKey;
    schema: FieldSchema;
} | undefined;

// @alpha
export type GlobalFieldKey = Brand<string, "tree.GlobalFieldKey">;

// @alpha
export type GlobalFieldKeySymbol = Brand<symbol, "GlobalFieldKeySymbol">;

// @alpha (undocumented)
export interface ICheckout<TEditBuilder> {
    readonly forest: IForestSubscription;
    runTransaction(transaction: (forest: IForestSubscription, editor: TEditBuilder) => TransactionResult): TransactionResult;
}

// @alpha (undocumented)
export type IdAllocator = () => ChangesetLocalId;

// @alpha
export interface IDefaultEditBuilder {
    // (undocumented)
    optionalField(parent: UpPath | undefined, field: FieldKey): OptionalFieldEditBuilder;
    // (undocumented)
    sequenceField(parent: UpPath | undefined, field: FieldKey): SequenceFieldEditBuilder;
    // (undocumented)
    setValue(path: UpPath, value: Value): void;
    // (undocumented)
    valueField(parent: UpPath | undefined, field: FieldKey): ValueFieldEditBuilder;
}

// @alpha
export interface IEditableForest extends IForestSubscription {
    readonly anchors: AnchorSet;
    applyDelta(delta: Delta.Root): void;
}

// @alpha
export interface IEmitter<E extends Events<E>> {
    emit<K extends keyof Events<E>>(eventName: K, ...args: Parameters<E[K]>): void;
}

// @alpha
export interface IForestSubscription extends Dependee, ISubscribable<ForestEvents> {
    allocateCursor(): ITreeSubscriptionCursor;
    clone(schema: StoredSchemaRepository, anchors: AnchorSet): IEditableForest;
    forgetAnchor(anchor: Anchor): void;
    readonly schema: StoredSchemaRepository;
    tryMoveCursorToField(destination: FieldAnchor, cursorToMove: ITreeSubscriptionCursor): TreeNavigationResult;
    tryMoveCursorToNode(destination: Anchor, cursorToMove: ITreeSubscriptionCursor): TreeNavigationResult;
}

// @alpha
export const indexSymbol: unique symbol;

// @alpha
interface Insert<TTree = ProtoNode> {
    // (undocumented)
    readonly content: readonly TTree[];
    // (undocumented)
    readonly type: typeof MarkType.Insert;
}

// @alpha
interface InsertAndModify<TTree = ProtoNode> {
    // (undocumented)
    readonly content: TTree;
    // (undocumented)
    readonly fields?: FieldMarks<TTree>;
    // (undocumented)
    readonly setValue?: Value;
    // (undocumented)
    readonly type: typeof MarkType.InsertAndModify;
}

// @alpha
export class InvalidationToken {
    constructor(description: string, isSecondaryInvalidation?: boolean);
    // (undocumented)
    readonly description: string;
    // (undocumented)
    readonly isSecondaryInvalidation: boolean;
    // (undocumented)
    protected readonly _typeCheck: MakeNominal;
}

// @alpha
export interface Invariant<T> extends Contravariant<T>, Covariant<T> {
}

// @alpha
export type isAny<T> = boolean extends (T extends {} ? true : false) ? true : false;

// @alpha
export function isContextuallyTypedNodeDataObject(data: ContextuallyTypedNodeData | undefined): data is ContextuallyTypedNodeDataObject;

// @alpha
export function isEditableField(field: UnwrappedEditableField): field is EditableField;

// @alpha
export type IsEvent<Event> = Event extends (...args: any[]) => any ? true : false;

// @alpha
export function isGlobalFieldKey(key: FieldKey): key is GlobalFieldKeySymbol;

// @alpha
export interface ISharedTree extends ICheckout<IDefaultEditBuilder>, ISharedObject, AnchorLocator {
    readonly context: EditableTreeContext;
    get root(): UnwrappedEditableField;
    set root(data: ContextuallyTypedNodeData | undefined);
    readonly storedSchema: StoredSchemaRepository;
}

// @alpha (undocumented)
export function isNeverField(policy: FullSchemaPolicy, originalData: SchemaData, field: FieldSchema): boolean;

// @alpha (undocumented)
export function isPrimitive(schema: TreeSchema): boolean;

// @alpha (undocumented)
export function isPrimitiveValue(nodeValue: Value): nodeValue is PrimitiveValue;

// @alpha
export interface ISubscribable<E extends Events<E>> {
    on<K extends keyof Events<E>>(eventName: K, listener: E[K]): () => void;
}

// @alpha
export function isUnwrappedNode(field: UnwrappedEditableField): field is EditableTree;

// @alpha
export function isWritableArrayLike(data: ContextuallyTypedNodeData | undefined): data is MarkedArrayLike<ContextuallyTypedNodeData>;

// @alpha
export interface ITreeCursor {
    readonly chunkLength: number;
    readonly chunkStart: number;
    enterField(key: FieldKey): void;
    enterNode(childIndex: number): void;
    exitField(): void;
    exitNode(): void;
    readonly fieldIndex: number;
    firstField(): boolean;
    firstNode(): boolean;
    getFieldKey(): FieldKey;
    // (undocumented)
    getFieldLength(): number;
    getFieldPath(prefix?: PathRootPrefix): FieldUpPath;
    getPath(prefix?: PathRootPrefix): UpPath | undefined;
    readonly mode: CursorLocationType;
    nextField(): boolean;
    nextNode(): boolean;
    // (undocumented)
    readonly pending: boolean;
    seekNodes(offset: number): boolean;
    skipPendingFields(): boolean;
    readonly type: TreeType;
    readonly value: Value;
}

// @alpha
export interface ITreeCursorSynchronous extends ITreeCursor {
    // (undocumented)
    readonly pending: false;
}

// @alpha
export interface ITreeSubscriptionCursor extends ITreeCursor {
    buildAnchor(): Anchor;
    buildFieldAnchor(): FieldAnchor;
    clear(): void;
    // (undocumented)
    fork(): ITreeSubscriptionCursor;
    free(): void;
    readonly state: ITreeSubscriptionCursorState;
}

// @alpha (undocumented)
export enum ITreeSubscriptionCursorState {
    Cleared = 1,
    Current = 0,
    Freed = 2
}

// @alpha
export interface JsonableTree extends GenericTreeNode<JsonableTree> {
}

// @alpha
export function jsonableTreeFromCursor(cursor: ITreeCursor): JsonableTree;

// @alpha (undocumented)
export const jsonArray: NamedTreeSchema;

// @alpha (undocumented)
export const jsonBoolean: NamedTreeSchema;

// @alpha
export type JsonCompatible = string | number | boolean | null | JsonCompatible[] | JsonCompatibleObject;

// @alpha
export type JsonCompatibleObject = {
    [P in string]: JsonCompatible;
};

// @alpha
export type JsonCompatibleReadOnly = string | number | boolean | null | readonly JsonCompatibleReadOnly[] | {
    readonly [P in string]: JsonCompatibleReadOnly | undefined;
};

// @alpha (undocumented)
export const jsonNull: NamedTreeSchema;

// @alpha (undocumented)
export const jsonNumber: NamedTreeSchema;

// @alpha (undocumented)
export const jsonObject: NamedTreeSchema;

// @alpha (undocumented)
export const jsonSchemaData: SchemaData;

// @alpha (undocumented)
export const jsonString: NamedTreeSchema;

// @alpha (undocumented)
export function keyFromSymbol(key: GlobalFieldKeySymbol): GlobalFieldKey;

// @alpha
export type LocalFieldKey = Brand<string, "tree.LocalFieldKey">;

// @alpha
export interface MakeNominal {
}

// @alpha
type Mark<TTree = ProtoNode> = Skip | Modify<TTree> | Delete | MoveOut | MoveIn | Insert<TTree> | ModifyAndDelete<TTree> | ModifyAndMoveOut<TTree> | MoveInAndModify<TTree> | InsertAndModify<TTree>;

// @alpha
export interface MarkedArrayLike<T> extends ArrayLike<T> {
    // (undocumented)
    readonly [arrayLikeMarkerSymbol]: true;
    // (undocumented)
    [Symbol.iterator](): IterableIterator<T>;
    [n: number]: T;
}

// @alpha
type MarkList<TTree = ProtoNode> = readonly Mark<TTree>[];

// @alpha (undocumented)
const MarkType: {
    readonly Modify: 0;
    readonly Insert: 1;
    readonly InsertAndModify: 2;
    readonly MoveIn: 3;
    readonly MoveInAndModify: 4;
    readonly Delete: 5;
    readonly ModifyAndDelete: 6;
    readonly MoveOut: 7;
    readonly ModifyAndMoveOut: 8;
};

// @alpha
interface Modify<TTree = ProtoNode> {
    // (undocumented)
    readonly fields?: FieldMarks<TTree>;
    // (undocumented)
    readonly setValue?: Value;
    // (undocumented)
    readonly type: typeof MarkType.Modify;
}

// @alpha
interface ModifyAndDelete<TTree = ProtoNode> {
    // (undocumented)
    readonly fields: FieldMarks<TTree>;
    // (undocumented)
    readonly type: typeof MarkType.ModifyAndDelete;
}

// @alpha
interface ModifyAndMoveOut<TTree = ProtoNode> {
    // (undocumented)
    readonly fields?: FieldMarks<TTree>;
    readonly moveId: MoveId;
    // (undocumented)
    readonly setValue?: Value;
    // (undocumented)
    readonly type: typeof MarkType.ModifyAndMoveOut;
}

// @alpha @sealed
export class ModularChangeFamily implements ChangeFamily<ModularEditBuilder, ModularChangeset>, ChangeRebaser<ModularChangeset> {
    constructor(fieldKinds: ReadonlyMap<FieldKindIdentifier, FieldKind>);
    // (undocumented)
    buildEditor(changeReceiver: (change: ModularChangeset) => void, anchors: AnchorSet): ModularEditBuilder;
    // (undocumented)
    compose(changes: TaggedChange<ModularChangeset>[]): ModularChangeset;
    // (undocumented)
    readonly encoder: ChangeEncoder<ModularChangeset>;
    // (undocumented)
    readonly fieldKinds: ReadonlyMap<FieldKindIdentifier, FieldKind>;
    // (undocumented)
    intoDelta(change: ModularChangeset, repairStore?: ReadonlyRepairDataStore): Delta.Root;
    // (undocumented)
    invert(change: TaggedChange<ModularChangeset>): ModularChangeset;
    // (undocumented)
    rebase(change: ModularChangeset, over: TaggedChange<ModularChangeset>): ModularChangeset;
    // (undocumented)
    rebaseAnchors(anchors: AnchorSet, over: ModularChangeset): void;
    // (undocumented)
    get rebaser(): ChangeRebaser<ModularChangeset>;
}

// @alpha (undocumented)
export interface ModularChangeset {
    // (undocumented)
    changes: FieldChangeMap;
    maxId?: ChangesetLocalId;
}

// @alpha @sealed (undocumented)
export class ModularEditBuilder extends ProgressiveEditBuilderBase<ModularChangeset> implements ProgressiveEditBuilder<ModularChangeset> {
    constructor(family: ChangeFamily<unknown, ModularChangeset>, changeReceiver: (change: ModularChangeset) => void, anchors: AnchorSet);
    // (undocumented)
    apply(change: ModularChangeset): void;
    // (undocumented)
    setValue(path: UpPath, value: Value): void;
    submitChange(path: UpPath | undefined, field: FieldKey, fieldKind: FieldKindIdentifier, change: FieldChangeset, maxId?: ChangesetLocalId): void;
}

// @alpha
interface MoveId extends Opaque<Brand<number, "delta.MoveId">> {
}

// @alpha
interface MoveIn {
    // (undocumented)
    readonly count: number;
    readonly moveId: MoveId;
    // (undocumented)
    readonly type: typeof MarkType.MoveIn;
}

// @alpha
interface MoveInAndModify<TTree = ProtoNode> {
    // (undocumented)
    readonly fields: FieldMarks<TTree>;
    readonly moveId: MoveId;
    // (undocumented)
    readonly type: typeof MarkType.MoveInAndModify;
}

// @alpha
interface MoveOut {
    // (undocumented)
    readonly count: number;
    readonly moveId: MoveId;
    // (undocumented)
    readonly type: typeof MarkType.MoveOut;
}

// @alpha
export enum Multiplicity {
    Forbidden = 3,
    Optional = 1,
    Sequence = 2,
    Value = 0
}

// @alpha (undocumented)
export interface Named<TName> {
    // (undocumented)
    readonly name: TName;
}

// @alpha
export interface NamedComputation {
    readonly computationName: string;
    listDependees?(): Iterable<Dependee>;
    listDependents?(): Iterable<Dependent>;
}

// @alpha (undocumented)
export type NamedTreeSchema = TreeSchema & Named<TreeSchemaIdentifier>;

// @alpha
export type NameFromBranded<T extends BrandedType<any, string>> = T extends BrandedType<any, infer Name> ? Name : never;

// @alpha
export type NestedMap<Key1, Key2, Value> = Map<Key1, Map<Key2, Value>>;

// @alpha
export const neverTree: TreeSchema;

// @alpha (undocumented)
export type NodeChangeComposer = (changes: TaggedChange<NodeChangeset>[]) => NodeChangeset;

// @alpha (undocumented)
export type NodeChangeDecoder = (change: JsonCompatibleReadOnly) => NodeChangeset;

// @alpha (undocumented)
export type NodeChangeEncoder = (change: NodeChangeset) => JsonCompatibleReadOnly;

// @alpha (undocumented)
export type NodeChangeInverter = (change: NodeChangeset) => NodeChangeset;

// @alpha (undocumented)
export type NodeChangeRebaser = (change: NodeChangeset, baseChange: NodeChangeset) => NodeChangeset;

// @alpha
export interface NodeChangeset {
    // (undocumented)
    fieldChanges?: FieldChangeMap;
    // (undocumented)
    valueChange?: ValueChange;
}

// @alpha
export interface NodeData {
    readonly type: TreeSchemaIdentifier;
    value?: TreeValue;
}

// @alpha (undocumented)
export type NodeReviver = (revision: RevisionTag, index: number, count: number) => Delta.ProtoNode[];

// @alpha
export interface ObservingDependent extends Dependent {
    // @override
    listDependees(): Iterable<Dependee>;
    registerDependee(dependee: Dependee): void;
}

// @alpha
export type Opaque<T extends Brand<any, string>> = T extends Brand<infer ValueType, infer Name> ? BrandedType<ValueType, Name> : never;

// @alpha (undocumented)
export interface OptionalFieldEditBuilder {
    set(newContent: ITreeCursor | undefined, wasEmpty: boolean): void;
}

// @alpha
export interface PathRootPrefix {
    indexOffset?: number;
    parent?: UpPath | undefined;
    rootFieldOverride?: FieldKey;
}

// @alpha
export function prefixFieldPath(prefix: PathRootPrefix | undefined, path: FieldUpPath): FieldUpPath;

// @alpha
export function prefixPath(prefix: PathRootPrefix | undefined, path: UpPath | undefined): UpPath | undefined;

// @alpha (undocumented)
export type PrimitiveValue = string | boolean | number;

// @alpha (undocumented)
export interface ProgressiveEditBuilder<TChange> {
    // (undocumented)
    getChanges(): TChange[];
}

// @alpha (undocumented)
export abstract class ProgressiveEditBuilderBase<TChange> implements ProgressiveEditBuilder<TChange> {
    constructor(changeFamily: ChangeFamily<unknown, TChange>, changeReceiver: (change: TChange) => void, anchorSet: AnchorSet);
    // @sealed
    protected applyChange(change: TChange): void;
    // @sealed (undocumented)
    getChanges(): TChange[];
}

// @alpha
type ProtoNode = ITreeCursorSynchronous;

// @alpha
export const proxyTargetSymbol: unique symbol;

// @alpha
export interface ReadonlyRepairDataStore<TTree = Delta.ProtoNode> {
    // (undocumented)
    getNodes(revision: RevisionTag, path: UpPath | undefined, key: FieldKey, index: number, count: number): TTree[];
    // (undocumented)
    getValue(revision: RevisionTag, path: UpPath): Value;
}

// @alpha
export function recordDependency(dependent: ObservingDependent | undefined, dependee: Dependee): void;

// @alpha
export interface RepairDataStore<TTree = Delta.ProtoNode> extends ReadonlyRepairDataStore<TTree> {
    capture(change: Delta.Root, revision: RevisionTag): void;
}

// @alpha
export const replaceField: unique symbol;

// @alpha
export type RevisionTag = Brand<number, "rebaser.RevisionTag">;

// @alpha
type Root<TTree = ProtoNode> = FieldMarks<TTree>;

// @alpha
export interface RootField {
    // (undocumented)
    readonly key: DetachedField;
}

// @alpha
export const rootFieldKey: GlobalFieldKey;

// @alpha
export interface SchemaData {
    // (undocumented)
    readonly globalFieldSchema: ReadonlyMap<GlobalFieldKey, FieldSchema>;
    // (undocumented)
    readonly treeSchema: ReadonlyMap<TreeSchemaIdentifier, TreeSchema>;
}

// @alpha
export interface SchemaDataAndPolicy<TPolicy extends SchemaPolicy = SchemaPolicy> extends SchemaData {
    readonly policy: TPolicy;
}

// @alpha
export interface SchemaEvents {
    afterSchemaChange(newSchema: SchemaData): void;
    beforeSchemaChange(newSchema: SchemaData): void;
}

// @alpha
export interface SchemaPolicy {
    readonly defaultGlobalFieldSchema: FieldSchema;
    readonly defaultTreeSchema: TreeSchema;
}

// @alpha (undocumented)
export interface SequenceFieldEditBuilder {
    delete(index: number, count: number): void;
    insert(index: number, newContent: ITreeCursor | ITreeCursor[]): void;
    move(sourceIndex: number, count: number, destIndex: number): void;
    revive(index: number, count: number, detachedBy: RevisionTag, detachIndex: number, isIntention?: true): void;
}

// @alpha
export class SharedTreeFactory implements IChannelFactory {
    // (undocumented)
    attributes: IChannelAttributes;
    // (undocumented)
    create(runtime: IFluidDataStoreRuntime, id: string): ISharedTree;
    // (undocumented)
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, channelAttributes: Readonly<IChannelAttributes>): Promise<ISharedTree>;
    // (undocumented)
    type: string;
}

// @alpha
export class SimpleDependee implements Dependee {
    constructor(computationName?: string);
    // (undocumented)
    readonly computationName: string;
    invalidateDependents(token?: InvalidationToken): void;
    // @sealed (undocumented)
    listDependents(): Set<Dependent>;
    // (undocumented)
    registerDependent(dependent: Dependent): boolean;
    // (undocumented)
    removeDependent(dependent: Dependent): void;
}

// @alpha
export function singleJsonCursor(root: JsonCompatible): ITreeCursorSynchronous;

// @alpha
type Skip = number;

// @alpha
export interface StoredSchemaRepository<TPolicy extends SchemaPolicy = SchemaPolicy> extends Dependee, ISubscribable<SchemaEvents>, SchemaDataAndPolicy<TPolicy> {
    update(newSchema: SchemaData): void;
}

// @alpha (undocumented)
export function symbolFromKey(key: GlobalFieldKey): GlobalFieldKeySymbol;

// @alpha (undocumented)
export function symbolIsFieldKey(key: symbol): key is GlobalFieldKeySymbol;

// @alpha (undocumented)
export interface TaggedChange<TChangeset> {
    // (undocumented)
    readonly change: TChangeset;
    readonly isInverse?: boolean;
    // (undocumented)
    readonly revision: RevisionTag | undefined;
}

// @alpha
export type ToDelta = (child: NodeChangeset, index: number | undefined) => Delta.Modify;

// @alpha (undocumented)
export enum TransactionResult {
    // (undocumented)
    Abort = 0,
    // (undocumented)
    Apply = 1
}

// @alpha (undocumented)
export interface TreeLocation {
    // (undocumented)
    readonly index: number;
    // (undocumented)
    readonly range: FieldLocation | DetachedField;
}

// @alpha (undocumented)
export const enum TreeNavigationResult {
    NotFound = -1,
    Ok = 1,
    Pending = 0
}

// @alpha (undocumented)
export interface TreeSchema {
    readonly extraGlobalFields: boolean;
    readonly extraLocalFields: FieldSchema;
    readonly globalFields: ReadonlySet<GlobalFieldKey>;
    readonly localFields: ReadonlyMap<LocalFieldKey, FieldSchema>;
    readonly value: ValueSchema;
}

// @alpha
export type TreeSchemaIdentifier = Brand<string, "tree.TreeSchemaIdentifier">;

// @alpha (undocumented)
export type TreeType = TreeSchemaIdentifier;

// @alpha
export type TreeTypeSet = ReadonlySet<TreeSchemaIdentifier> | undefined;

// @alpha
export interface TreeValue extends Serializable {
}

// @alpha
export const typeNameSymbol: unique symbol;

// @alpha
export const typeSymbol: unique symbol;

// @alpha
export type UnwrappedEditableField = UnwrappedEditableTree | undefined | EditableField;

// @alpha
export type UnwrappedEditableTree = EditableTreeOrPrimitive | EditableField;

// @alpha
export interface UpPath {
    readonly parent: UpPath | undefined;
    readonly parentField: FieldKey;
    readonly parentIndex: number;
}

// @alpha
export type Value = undefined | TreeValue;

// @alpha (undocumented)
export type ValueChange = {
    revision?: RevisionTag;
    value?: Value;
} | {
    revision?: RevisionTag;
    revert: RevisionTag | undefined;
};

// @alpha (undocumented)
export interface ValueFieldEditBuilder {
    set(newContent: ITreeCursor): void;
}

// @alpha
export type ValueFromBranded<T extends BrandedType<any, string>> = T extends BrandedType<infer ValueType, string> ? ValueType : never;

// @alpha
export enum ValueSchema {
    // (undocumented)
    Boolean = 3,
    // (undocumented)
    Nothing = 0,
    // (undocumented)
    Number = 1,
    Serializable = 4,
    // (undocumented)
    String = 2
}

// @alpha
export const valueSymbol: unique symbol;

// (No @packageDocumentation comment for this package)

```
