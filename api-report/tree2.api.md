## API Report File for "@fluid-experimental/tree2"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { IChannelAttributes } from '@fluidframework/datastore-definitions';
import { IChannelFactory } from '@fluidframework/datastore-definitions';
import { IChannelServices } from '@fluidframework/datastore-definitions';
import { IFluidDataStoreRuntime } from '@fluidframework/datastore-definitions';
import { ISharedObject } from '@fluidframework/shared-object-base';
import { IsoBuffer } from '@fluidframework/common-utils';
import { Serializable } from '@fluidframework/datastore-definitions';
import { StableId } from '@fluidframework/runtime-definitions';
import type { Static } from '@sinclair/typebox';
import type { TAnySchema } from '@sinclair/typebox';
import type { TSchema } from '@sinclair/typebox';

// @alpha
export interface Adapters {
    readonly fieldAdapters?: ReadonlyMap<GlobalFieldKey, FieldAdapter>;
    // (undocumented)
    readonly tree?: readonly TreeAdapter[];
}

// @alpha
export type AllowedTypes = [Any] | readonly LazyItem<TreeSchema>[];

// @alpha
type AllowedTypesToTypedTrees<Mode extends ApiMode, T extends AllowedTypes> = [
T extends InternalTypedSchemaTypes.FlexList<TreeSchema> ? InternalTypedSchemaTypes.ArrayToUnion<TypeArrayToTypedTreeArray<Mode, Assume<InternalTypedSchemaTypes.ConstantFlexListToNonLazyArray<T>, readonly TreeSchema[]>>> : UntypedApi<Mode>
][_InlineTrick];

// @alpha
export enum AllowedUpdateType {
    None = 0,
    SchemaCompatible = 1
}

// @alpha
type AllowOptional<T> = [FlattenKeys<RequiredFields<T> & OptionalFields<T>>][_InlineTrick];

// @alpha
type AllowOptionalNotFlattened<T> = [RequiredFields<T> & OptionalFields<T>][_InlineTrick];

// @alpha
export type Anchor = Brand<number, "rebaser.Anchor">;

// @alpha
export interface AnchorEvents {
    afterDelete(anchor: AnchorNode): void;
    childrenChanging(anchor: AnchorNode): void;
    subtreeChanging(anchor: AnchorNode): PathVisitor | void;
    valueChanging(anchor: AnchorNode, value: Value): void;
}

// @alpha (undocumented)
export type AnchorKeyBrand = Brand<number, "AnchorSlot">;

// @alpha
export interface AnchorLocator {
    locate(anchor: Anchor): AnchorNode | undefined;
}

// @alpha
export interface AnchorNode extends UpPath<AnchorNode>, ISubscribable<AnchorEvents> {
    child(key: FieldKey, index: number): UpPath<AnchorNode>;
    getOrCreateChildRef(key: FieldKey, index: number): [Anchor, AnchorNode];
    readonly slots: BrandedMapSubset<AnchorSlot<any>>;
}

// @alpha @sealed
export class AnchorSet implements ISubscribable<AnchorSetRootEvents> {
    applyDelta(delta: Delta.Root): void;
    // (undocumented)
    forget(anchor: Anchor): void;
    internalizePath(originalPath: UpPath): UpPath;
    isEmpty(): boolean;
    // (undocumented)
    locate(anchor: Anchor): AnchorNode | undefined;
    // (undocumented)
    on<K extends keyof AnchorSetRootEvents>(eventName: K, listener: AnchorSetRootEvents[K]): () => void;
    track(path: UpPath | null): Anchor;
}

// @alpha
export interface AnchorSetRootEvents {
    childrenChanging(anchors: AnchorSet): void;
    treeChanging(anchors: AnchorSet): void;
}

// @alpha
export type AnchorSlot<TContent> = BrandedKey<Opaque<AnchorKeyBrand>, TContent>;

// @alpha
export function anchorSlot<TContent>(): AnchorSlot<TContent>;

// @alpha
export const Any: "Any";

// @alpha
export type Any = typeof Any;

// @alpha
const enum ApiMode {
    Editable = 1,
    EditableUnwrapped = 2,
    Flexible = 0,
    Simple = 4,
    Wrapped = 3
}

// @alpha
type ApplyMultiplicity<TMultiplicity extends Multiplicity, TypedChild, Mode extends ApiMode> = {
    [Multiplicity.Forbidden]: undefined;
    [Multiplicity.Optional]: Mode extends ApiMode.Editable ? EditableOptionalField<TypedChild> : undefined | TypedChild;
    [Multiplicity.Sequence]: Mode extends ApiMode.Editable | ApiMode.EditableUnwrapped ? EditableSequenceField<TypedChild> : TypedChild[];
    [Multiplicity.Value]: Mode extends ApiMode.Editable ? EditableValueField<TypedChild> : TypedChild;
}[TMultiplicity];

// @alpha
type ArrayHasFixedLength<List extends readonly unknown[]> = number extends List["length"] ? false : true;

// @alpha
export interface ArrayLikeMut<TGet, TSet extends TGet = TGet> extends ArrayLike<TGet> {
    // (undocumented)
    [n: number]: TSet;
}

// @alpha
type ArrayToUnion<T extends readonly unknown[]> = T extends readonly (infer TValue)[] ? TValue : never;

// @alpha
type Assume<TInput, TAssumeToBe> = TInput extends TAssumeToBe ? TInput : TAssumeToBe;

// @alpha
export type Brand<ValueType, Name extends string> = ValueType & BrandedType<ValueType, Name>;

// @alpha
export function brand<T extends Brand<any, string>>(value: T extends BrandedType<infer ValueType, string> ? ValueType : never): T;

// @alpha (undocumented)
export type BrandedFieldKind<TName extends string, TMultiplicity extends Multiplicity, TEditor extends FieldEditor<any>> = FieldKind<TEditor, TMultiplicity> & {
    identifier: TName & FieldKindIdentifier;
};

// @alpha (undocumented)
export type BrandedKey<TKey, TContent> = TKey & Invariant<TContent>;

// @alpha (undocumented)
export type BrandedKeyContent<TKey extends BrandedKey<unknown, any>> = TKey extends BrandedKey<unknown, infer TContent> ? TContent : never;

// @alpha
export interface BrandedMapSubset<K extends BrandedKey<unknown, any>> {
    // (undocumented)
    delete(key: K): boolean;
    // (undocumented)
    get<K2 extends K>(key: K2): BrandedKeyContent<K2> | undefined;
    // (undocumented)
    has(key: K): boolean;
    // (undocumented)
    set<K2 extends K>(key: K2, value: BrandedKeyContent<K2>): this;
}

// @alpha @sealed
abstract class BrandedType<ValueType, Name extends string> {
    protected readonly _type_brand: Name;
    // (undocumented)
    protected _typeCheck?: Invariant<ValueType>;
}

// @alpha
export function brandOpaque<T extends BrandedType<any, string>>(value: isAny<ValueFromBranded<T>> extends true ? never : ValueFromBranded<T>): BrandedType<ValueFromBranded<T>, NameFromBranded<T>>;

// @alpha (undocumented)
export function buildForest(schema: StoredSchemaRepository, anchors?: AnchorSet): IEditableForest;

// @alpha
export type ChangesetLocalId = Brand<number, "ChangesetLocalId">;

// @alpha
export type ChildCollection = FieldKey | RootField;

// @alpha
export interface ChildLocation {
    // (undocumented)
    readonly container: ChildCollection;
    // (undocumented)
    readonly index: number;
}

// @alpha
type CollectOptions<Mode extends ApiMode, TTypedFields, TValueSchema extends ValueSchema, TName> = {
    [ApiMode.Flexible]: EmptyObject extends TTypedFields ? TypedValue<TValueSchema> | FlexibleObject<TValueSchema, TName> : FlexibleObject<TValueSchema, TName> & TTypedFields;
    [ApiMode.Editable]: {
        [typeNameSymbol]: TName & TreeSchemaIdentifier;
    } & ValuePropertyFromSchema<TValueSchema> & TTypedFields & UntypedTreeCore;
    [ApiMode.EditableUnwrapped]: [EmptyObject, TValueSchema] extends [
    TTypedFields,
    PrimitiveValueSchema
    ] ? TypedValue<TValueSchema> : CollectOptions<ApiMode.Editable, TTypedFields, TValueSchema, TName>;
    [ApiMode.Wrapped]: {
        [typeNameSymbol]: TName;
        [valueSymbol]: TypedValue<TValueSchema>;
    } & TTypedFields;
    [ApiMode.Simple]: EmptyObject extends TTypedFields ? TypedValue<TValueSchema> : FlexibleObject<TValueSchema, TName> & TTypedFields;
}[Mode];

// @alpha
type ConstantFlexListToNonLazyArray<List extends FlexList> = List extends readonly [
infer Head,
...infer Tail
] ? [ExtractItemType<Head>, ...ConstantFlexListToNonLazyArray<Tail>] : [];

// @alpha
export const contextSymbol: unique symbol;

// @alpha
export type ContextuallyTypedFieldData = ContextuallyTypedNodeData | undefined;

// @alpha
export type ContextuallyTypedNodeData = ContextuallyTypedNodeDataObject | PrimitiveValue | readonly ContextuallyTypedNodeData[] | MarkedArrayLike<ContextuallyTypedNodeData>;

// @alpha
export interface ContextuallyTypedNodeDataObject {
    readonly [typeNameSymbol]?: string;
    readonly [valueSymbol]?: Value;
    [key: FieldKey]: ContextuallyTypedFieldData;
    [key: string]: ContextuallyTypedFieldData;
}

// @alpha
interface Contravariant<T> {
    // (undocumented)
    _removeCovariance?: (_: T) => void;
}

// @alpha
interface Covariant<T> {
    // (undocumented)
    _removeContravariance?: T;
}

// @alpha
export function createEmitter<E extends Events<E>>(noListeners?: NoListenersCallback<E>): ISubscribable<E> & IEmitter<E> & HasListeners<E>;

// @alpha
export interface CrossFieldManager<T = unknown> {
    get(target: CrossFieldTarget, revision: RevisionTag | undefined, id: ChangesetLocalId, addDependency: boolean): T | undefined;
    getOrCreate(target: CrossFieldTarget, revision: RevisionTag | undefined, id: ChangesetLocalId, newValue: T, invalidateDependents: boolean): T;
}

// @alpha (undocumented)
export enum CrossFieldTarget {
    // (undocumented)
    Destination = 1,
    // (undocumented)
    Source = 0
}

// @alpha
export interface CursorAdapter<TNode> {
    // (undocumented)
    getFieldFromNode(node: TNode, key: FieldKey): readonly TNode[];
    // (undocumented)
    keysFromNode(node: TNode): readonly FieldKey[];
    // (undocumented)
    type(node: TNode): TreeType;
    // (undocumented)
    value(node: TNode): Value;
}

// @alpha
export function cursorForTypedTreeData<T extends TreeSchema>(context: TreeDataContext, schema: T, data: TypedNode<T, ApiMode.Simple>): ITreeCursorSynchronous;

// @alpha
export function cursorFromContextualData(context: TreeDataContext, typeSet: TreeTypeSet, data: ContextuallyTypedNodeData): ITreeCursorSynchronous;

// @alpha (undocumented)
export const enum CursorLocationType {
    Fields = 1,
    Nodes = 0
}

// @alpha
export function cursorToJsonObject(reader: ITreeCursor): JsonCompatible;

// @alpha
export interface CursorWithNode<TNode> extends ITreeCursorSynchronous {
    fork(): CursorWithNode<TNode>;
    getNode(): TNode;
}

// @alpha
export const defaultSchemaPolicy: FullSchemaPolicy;

// @alpha
interface Delete<TTree = ProtoNode> extends HasModifications<TTree> {
    readonly count: number;
    // (undocumented)
    readonly type: typeof MarkType.Delete;
}

declare namespace Delta {
    export {
        Root,
        ProtoNode,
        ProtoNodes,
        Mark,
        MarkList,
        Skip,
        HasModifications,
        Modify,
        Delete,
        MoveOut,
        MoveIn,
        Insert,
        MoveId,
        FieldMap,
        FieldMarks,
        MarkType
    }
}
export { Delta }

// @alpha
export interface Dependee extends NamedComputation {
    registerDependent(dependent: Dependent): boolean;
    removeDependent(dependent: Dependent): void;
}

// @alpha
export interface Dependent extends NamedComputation {
    markInvalid(token?: InvalidationToken): void;
}

// @alpha
export interface DetachedField extends Opaque<Brand<string, "tree.DetachedField">> {
}

// @alpha
export interface EditableField extends MarkedArrayLike<UnwrappedEditableTree> {
    readonly [proxyTargetSymbol]: object;
    get content(): EditableTree | undefined | EditableField;
    set content(newContent: NewFieldContent);
    readonly context: EditableTreeContext;
    delete(): void;
    deleteNodes(index: number, count?: number): void;
    readonly fieldKey: FieldKey;
    readonly fieldSchema: FieldStoredSchema;
    getNode(index: number): EditableTree;
    insertNodes(index: number, newContent: NewFieldContent): void;
    moveNodes(sourceIndex: number, count: number, destIndex: number, destinationField?: EditableField): void;
    readonly parent?: EditableTree;
    replaceNodes(index: number, newContent: NewFieldContent, count?: number): void;
    setContent(newContent: NewFieldContent): void;
}

// @alpha (undocumented)
type EditableOptionalField<TypedChild> = [
UntypedOptionalField & MarkedArrayLike<TypedChild>
][_InlineTrick];

// @alpha (undocumented)
type EditableSequenceField<TypedChild> = [
UntypedSequenceField & MarkedArrayLike<TypedChild>
][_InlineTrick];

// @alpha
export interface EditableTree extends Iterable<EditableField>, ContextuallyTypedNodeDataObject {
    readonly [contextSymbol]: EditableTreeContext;
    [getField](fieldKey: FieldKey): EditableField;
    // (undocumented)
    [on]<K extends keyof EditableTreeEvents>(eventName: K, listener: EditableTreeEvents[K]): () => void;
    readonly [parentField]: {
        readonly parent: EditableField;
        readonly index: number;
    };
    readonly [proxyTargetSymbol]: object;
    readonly [typeNameSymbol]: TreeSchemaIdentifier;
    readonly [typeSymbol]: NamedTreeSchema;
    [valueSymbol]: Value;
    [key: FieldKey]: UnwrappedEditableField;
}

// @alpha
export interface EditableTreeContext extends ISubscribable<ForestEvents> {
    clear(): void;
    fieldSource?(key: FieldKey, schema: FieldStoredSchema): undefined | FieldGenerator;
    free(): void;
    prepareForEdit(): void;
    get root(): EditableField;
    set root(data: NewFieldContent);
    readonly schema: SchemaDataAndPolicy;
    get unwrappedRoot(): UnwrappedEditableField;
    set unwrappedRoot(data: NewFieldContent);
}

// @alpha
export interface EditableTreeEvents {
    changing(upPath: UpPath, value: Value): void;
    subtreeChanging(upPath: UpPath): PathVisitor | void;
}

// @alpha
export type EditableTreeOrPrimitive = EditableTree | PrimitiveValue;

// @alpha (undocumented)
type EditableValueField<TypedChild> = [
UntypedValueField & MarkedArrayLike<TypedChild>
][_InlineTrick];

// @alpha (undocumented)
export interface EditDescription {
    // (undocumented)
    change: FieldChangeset;
    // (undocumented)
    field: FieldUpPath;
    // (undocumented)
    fieldKind: FieldKindIdentifier;
}

// @alpha
export const emptyField: FieldStoredSchema;

// @alpha
export const EmptyKey: LocalFieldKey;

// @alpha
type EmptyObject = {};

// @alpha
export type Events<E> = {
    [P in (string | symbol) & keyof E as IsEvent<E[P]> extends true ? P : never]: E[P];
};

// @alpha
type ExtractFromOpaque<TOpaque extends BrandedType<any, string>> = TOpaque extends BrandedType<infer ValueType, infer Name> ? isAny<ValueType> extends true ? unknown : Brand<ValueType, Name> : never;

// @alpha
export function extractFromOpaque<TOpaque extends BrandedType<any, string>>(value: TOpaque): ExtractFromOpaque<TOpaque>;

// @alpha (undocumented)
type ExtractItemType<Item extends LazyItem> = Item extends () => infer Result ? Result : Item;

// @alpha (undocumented)
type ExtractListItemType<List extends FlexList> = List extends FlexList<infer Item> ? Item : unknown;

// @alpha (undocumented)
export function fail(message: string): never;

// @alpha (undocumented)
export interface FieldAdapter {
    // (undocumented)
    convert(stored: FieldStoredSchema): FieldStoredSchema;
    // (undocumented)
    readonly field: GlobalFieldKey;
}

// @alpha
export interface FieldAnchor {
    // (undocumented)
    fieldKey: FieldKey;
    parent: Anchor | undefined;
}

// @alpha (undocumented)
export interface FieldChange {
    // (undocumented)
    change: FieldChangeset;
    // (undocumented)
    fieldKind: FieldKindIdentifier;
    revision?: RevisionTag;
}

// @alpha
export interface FieldChangeHandler<TChangeset, TEditor extends FieldEditor<TChangeset> = FieldEditor<TChangeset>> {
    // (undocumented)
    readonly codecsFactory: (childCodec: IJsonCodec<NodeChangeset>) => ICodecFamily<TChangeset>;
    // (undocumented)
    readonly editor: TEditor;
    // (undocumented)
    intoDelta(change: TChangeset, deltaFromChild: ToDelta): Delta.MarkList;
    isEmpty(change: TChangeset): boolean;
    // (undocumented)
    readonly rebaser: FieldChangeRebaser<TChangeset>;
    // (undocumented)
    _typeCheck?: Invariant<TChangeset>;
}

// @alpha (undocumented)
export type FieldChangeMap = Map<FieldKey, FieldChange>;

// @alpha (undocumented)
export interface FieldChangeRebaser<TChangeset> {
    amendCompose(composedChange: TChangeset, composeChild: NodeChangeComposer, genId: IdAllocator, crossFieldManager: CrossFieldManager, revisionMetadata: RevisionMetadataSource): TChangeset;
    amendInvert(invertedChange: TChangeset, originalRevision: RevisionTag | undefined, reviver: NodeReviver, genId: IdAllocator, crossFieldManager: CrossFieldManager): TChangeset;
    amendRebase(rebasedChange: TChangeset, over: TaggedChange<TChangeset>, rebaseChild: NodeChangeRebaser, genId: IdAllocator, crossFieldManager: CrossFieldManager, revisionMetadata: RevisionMetadataSource): TChangeset;
    compose(changes: TaggedChange<TChangeset>[], composeChild: NodeChangeComposer, genId: IdAllocator, crossFieldManager: CrossFieldManager, revisionMetadata: RevisionMetadataSource): TChangeset;
    // (undocumented)
    invert(change: TaggedChange<TChangeset>, invertChild: NodeChangeInverter, reviver: NodeReviver, genId: IdAllocator, crossFieldManager: CrossFieldManager): TChangeset;
    rebase(change: TChangeset, over: TaggedChange<TChangeset>, rebaseChild: NodeChangeRebaser, genId: IdAllocator, crossFieldManager: CrossFieldManager, revisionMetadata: RevisionMetadataSource): TChangeset;
}

// @alpha (undocumented)
export type FieldChangeset = Brand<unknown, "FieldChangeset">;

// @alpha (undocumented)
export interface FieldEditor<TChangeset> {
    buildChildChange(childIndex: number, change: NodeChangeset): TChangeset;
}

// @alpha
export type FieldGenerator = () => MapTree[];

// @alpha
export type FieldKey = LocalFieldKey | GlobalFieldKeySymbol;

// @alpha @sealed
export class FieldKind<TEditor extends FieldEditor<any> = FieldEditor<any>, TMultiplicity extends Multiplicity = Multiplicity> implements FieldKindSpecifier {
    constructor(identifier: FieldKindIdentifier, multiplicity: TMultiplicity, changeHandler: FieldChangeHandler<any, TEditor>, allowsTreeSupersetOf: (originalTypes: TreeTypeSet, superset: FieldStoredSchema) => boolean, handlesEditsFrom: ReadonlySet<FieldKindIdentifier>);
    // (undocumented)
    allowsFieldSuperset(policy: FullSchemaPolicy, originalData: SchemaData, originalTypes: TreeTypeSet, superset: FieldStoredSchema): boolean;
    // (undocumented)
    readonly changeHandler: FieldChangeHandler<any, TEditor>;
    // (undocumented)
    readonly handlesEditsFrom: ReadonlySet<FieldKindIdentifier>;
    // (undocumented)
    readonly identifier: FieldKindIdentifier;
    // (undocumented)
    readonly multiplicity: TMultiplicity;
}

// @alpha
export type FieldKindIdentifier = Brand<string, "tree.FieldKindIdentifier">;

// @alpha
export const FieldKinds: {
    readonly value: ValueFieldKind;
    readonly optional: Optional;
    readonly sequence: Sequence;
    readonly nodeIdentifier: NodeIdentifierFieldKind;
    readonly forbidden: Forbidden;
};

// @alpha
export interface FieldKindSpecifier<T = FieldKindIdentifier> {
    // (undocumented)
    identifier: T;
}

// @alpha (undocumented)
export type FieldKindTypes = typeof FieldKinds[keyof typeof FieldKinds];

// @alpha
export interface FieldLocation {
    // (undocumented)
    readonly key: FieldKey;
    // (undocumented)
    readonly parent: ForestLocation;
}

// @alpha (undocumented)
type FieldMap<T> = ReadonlyMap<FieldKey, T>;

// @alpha
export interface FieldMapObject<TChild> {
    // (undocumented)
    [key: string]: TChild[];
}

// @alpha (undocumented)
type FieldMarks<TTree = ProtoNode> = FieldMap<MarkList<TTree>>;

// @alpha @sealed
export class FieldSchema<Kind extends FieldKindTypes = FieldKindTypes, Types = AllowedTypes> implements IFieldSchema {
    constructor(kind: Kind, allowedTypes: Types);
    // (undocumented)
    readonly allowedTypes: Types;
    static readonly empty: FieldSchema<Forbidden, never[]>;
    // (undocumented)
    readonly kind: Kind;
    // (undocumented)
    protected _typeCheck?: MakeNominal;
    // (undocumented)
    get types(): TreeTypeSet;
}

// @alpha
export function fieldSchema(kind: {
    identifier: FieldKindIdentifier;
}, types?: Iterable<TreeSchemaIdentifier>): FieldStoredSchema;

// @alpha
export const enum FieldScope {
    // (undocumented)
    global = "globalFields",
    // (undocumented)
    local = "fields"
}

// @alpha (undocumented)
export interface FieldStoredSchema {
    // (undocumented)
    readonly kind: FieldKindSpecifier;
    readonly types?: TreeTypeSet;
}

// @alpha
export interface FieldUpPath {
    readonly field: FieldKey;
    readonly parent: UpPath | undefined;
}

// @alpha
type FlattenKeys<T> = [{
    [Property in keyof T]: T[Property];
}][_InlineTrick];

// @alpha
type FlexibleObject<TValueSchema extends ValueSchema, TName> = [
FlattenKeys<{
    [typeNameSymbol]?: UnbrandedName<TName>;
} & AllowOptional<ValuePropertyFromSchema<TValueSchema>>>
][_InlineTrick];

// @alpha
type FlexList<Item = unknown> = readonly LazyItem<Item>[];

// @alpha
type FlexListToNonLazyArray<List extends FlexList> = ArrayHasFixedLength<List> extends true ? ConstantFlexListToNonLazyArray<List> : NormalizedFlexList<ExtractListItemType<List>>;

// @alpha (undocumented)
export interface Forbidden extends BrandedFieldKind<"Forbidden", Multiplicity.Forbidden, FieldEditor<any>> {
}

// @alpha
export interface ForestEvents {
    afterDelta(delta: Delta.Root): void;
    beforeDelta(delta: Delta.Root): void;
}

// @alpha
export type ForestLocation = ITreeSubscriptionCursor | Anchor;

// @alpha
export interface FullSchemaPolicy extends SchemaPolicy {
    readonly fieldKinds: ReadonlyMap<FieldKindIdentifier, FieldKind>;
}

// @alpha
export interface GenericFieldsNode<TChild> {
    // (undocumented)
    [FieldScope.local]?: FieldMapObject<TChild>;
    // (undocumented)
    [FieldScope.global]?: FieldMapObject<TChild>;
}

// @alpha
export interface GenericTreeNode<TChild> extends GenericFieldsNode<TChild>, NodeData {
}

// @alpha
export const getField: unique symbol;

// @alpha (undocumented)
export function getPrimaryField(schema: TreeStoredSchema): {
    key: LocalFieldKey;
    schema: FieldStoredSchema;
} | undefined;

// @alpha
export type GlobalFieldKey = Brand<string, "tree.GlobalFieldKey">;

// @alpha
export type GlobalFieldKeySymbol = Brand<symbol, "GlobalFieldKeySymbol">;

// @alpha @sealed
export class GlobalFieldSchema<Kind extends FieldKindTypes = FieldKindTypes, Types extends AllowedTypes = AllowedTypes> implements IFieldSchema {
    constructor(builder: Named<string>, key: GlobalFieldKey, schema: FieldSchema<Kind, Types>);
    // (undocumented)
    readonly builder: Named<string>;
    // (undocumented)
    readonly key: GlobalFieldKey;
    // (undocumented)
    get kind(): Kind;
    // (undocumented)
    readonly schema: FieldSchema<Kind, Types>;
    // (undocumented)
    readonly symbol: GlobalFieldKeySymbol;
    // (undocumented)
    protected _typeCheck?: MakeNominal;
    // (undocumented)
    get types(): TreeTypeSet;
}

// @alpha (undocumented)
export interface HasFieldChanges {
    // (undocumented)
    fieldChanges?: FieldChangeMap;
}

// @alpha (undocumented)
export interface HasListeners<E extends Events<E>> {
    hasListeners(eventName?: keyof Events<E>): boolean;
}

// @alpha
interface HasModifications<TTree = ProtoNode> {
    // (undocumented)
    readonly fields?: FieldMarks<TTree>;
    readonly setValue?: Value;
}

// @alpha (undocumented)
export interface IBinaryCodec<TDecoded> extends IEncoder<TDecoded, IsoBuffer>, IDecoder<TDecoded, IsoBuffer> {
}

// @alpha
export interface ICodecFamily<TDecoded> {
    // (undocumented)
    getSupportedFormats(): Iterable<number>;
    // (undocumented)
    resolve(formatVersion: number): IMultiFormatCodec<TDecoded>;
}

// @alpha
export interface ICodecOptions {
    readonly jsonValidator: JsonValidator;
}

// @alpha
export type IdAllocator = (count?: number) => ChangesetLocalId;

// @alpha (undocumented)
export interface IDecoder<TDecoded, TEncoded> {
    decode(obj: TEncoded): TDecoded;
}

// @alpha
export interface IDefaultEditBuilder {
    // (undocumented)
    addNodeExistsConstraint(path: UpPath): void;
    // (undocumented)
    addValueConstraint(path: UpPath, value: Value): void;
    move(sourceField: FieldUpPath, sourceIndex: number, count: number, destinationField: FieldUpPath, destinationIndex: number): void;
    // (undocumented)
    optionalField(field: FieldUpPath): OptionalFieldEditBuilder;
    // (undocumented)
    sequenceField(field: FieldUpPath): SequenceFieldEditBuilder;
    // (undocumented)
    setValue(path: UpPath, value: Value): void;
    // (undocumented)
    valueField(field: FieldUpPath): ValueFieldEditBuilder;
}

// @alpha
export interface IEditableForest extends IForestSubscription {
    readonly anchors: AnchorSet;
    applyDelta(delta: Delta.Root): void;
}

// @alpha
export interface IEmitter<E extends Events<E>> {
    emit<K extends keyof Events<E>>(eventName: K, ...args: Parameters<E[K]>): void;
    emitAndCollect<K extends keyof Events<E>>(eventName: K, ...args: Parameters<E[K]>): ReturnType<E[K]>[];
}

// @alpha (undocumented)
export interface IEncoder<TDecoded, TEncoded> {
    encode(obj: TDecoded): TEncoded;
}

// @alpha
export interface IFieldSchema {
    // (undocumented)
    readonly kind: FieldKind;
    readonly types: TreeTypeSet;
}

// @alpha
export interface IForestSubscription extends Dependee, ISubscribable<ForestEvents> {
    allocateCursor(): ITreeSubscriptionCursor;
    clone(schema: StoredSchemaRepository, anchors: AnchorSet): IEditableForest;
    forgetAnchor(anchor: Anchor): void;
    readonly schema: StoredSchemaRepository;
    tryMoveCursorToField(destination: FieldAnchor, cursorToMove: ITreeSubscriptionCursor): TreeNavigationResult;
    tryMoveCursorToNode(destination: Anchor, cursorToMove: ITreeSubscriptionCursor): TreeNavigationResult;
}

// @alpha (undocumented)
export interface IJsonCodec<TDecoded, TEncoded extends JsonCompatibleReadOnly = JsonCompatibleReadOnly> extends IEncoder<TDecoded, TEncoded>, IDecoder<TDecoded, TEncoded> {
    // (undocumented)
    encodedSchema?: TAnySchema;
}

// @alpha
export interface IMultiFormatCodec<TDecoded, TJsonEncoded extends JsonCompatibleReadOnly = JsonCompatibleReadOnly> {
    // (undocumented)
    binary: IBinaryCodec<TDecoded>;
    decode?: never;
    encode?: never;
    // (undocumented)
    json: IJsonCodec<TDecoded, TJsonEncoded>;
}

// @alpha
type _InlineTrick = 0;

// @alpha
interface Insert<TTree = ProtoNode> extends HasModifications<TTree> {
    readonly content: readonly TTree[];
    readonly isTransient?: true;
    // (undocumented)
    readonly type: typeof MarkType.Insert;
}

declare namespace InternalTypedSchemaTypes {
    export {
        RecursiveTreeSchemaSpecification,
        RecursiveTreeSchema,
        ObjectToMap,
        WithDefault,
        Unbrand,
        UnbrandList,
        ArrayToUnion,
        TreeSchemaSpecification,
        NormalizeLocalFieldsInner,
        NormalizeLocalFields,
        LocalFields,
        NormalizeField,
        FlexList,
        FlexListToNonLazyArray,
        ConstantFlexListToNonLazyArray,
        LazyItem,
        NormalizedFlexList,
        ExtractItemType,
        ArrayHasFixedLength,
        ExtractListItemType
    }
}
export { InternalTypedSchemaTypes }

declare namespace InternalTypes {
    export {
        MakeNominal,
        Invariant,
        Contravariant,
        Covariant,
        BrandedType,
        ExtractFromOpaque,
        Assume,
        AllowOptional,
        RequiredFields,
        OptionalFields,
        _InlineTrick,
        _RecursiveTrick,
        FlattenKeys,
        AllowOptionalNotFlattened,
        isAny,
        RestrictiveReadonlyRecord
    }
}
export { InternalTypes }

declare namespace InternalTypes_2 {
    export {
        AllowedTypesToTypedTrees,
        CollectOptions,
        TypedFields,
        ApplyMultiplicity,
        ValuePropertyFromSchema,
        FlexibleObject,
        EditableSequenceField,
        EditableValueField,
        EditableOptionalField,
        TypedField,
        UnbrandedName,
        TypeArrayToTypedTreeArray,
        UntypedApi,
        EmptyObject,
        ValuesOf,
        TypedValue,
        PrimitiveValueSchema,
        UntypedSequenceField,
        UntypedOptionalField,
        UntypedValueField
    }
}

// @alpha
export class InvalidationToken {
    constructor(description: string, isSecondaryInvalidation?: boolean);
    // (undocumented)
    readonly description: string;
    // (undocumented)
    readonly isSecondaryInvalidation: boolean;
    // (undocumented)
    protected readonly _typeCheck: MakeNominal;
}

// @alpha
interface Invariant<T> extends Contravariant<T>, Covariant<T> {
}

// @alpha
type isAny<T> = boolean extends (T extends {} ? true : false) ? true : false;

// @alpha
export function isContextuallyTypedNodeDataObject(data: ContextuallyTypedNodeData | undefined): data is ContextuallyTypedNodeDataObject;

// @alpha
export function isEditableField(field: UnwrappedEditableField): field is EditableField;

// @alpha
export function isEditableTree(field: UnwrappedEditableField): field is EditableTree;

// @alpha
export type IsEvent<Event> = Event extends (...args: any[]) => any ? true : false;

// @alpha
export function isGlobalFieldKey(key: FieldKey): key is GlobalFieldKeySymbol;

// @alpha
export interface ISharedTree extends ISharedObject, ISharedTreeView {
}

// @alpha
export interface ISharedTreeView extends AnchorLocator {
    readonly context: EditableTreeContext;
    readonly editor: IDefaultEditBuilder;
    readonly events: ISubscribable<ViewEvents>;
    readonly forest: IForestSubscription;
    fork(): SharedTreeView;
    generateNodeIdentifier(): NodeIdentifier;
    readonly identifiedNodes: ReadonlyMap<NodeIdentifier, EditableTree>;
    merge(view: SharedTreeView): void;
    rebase(view: SharedTreeView): void;
    redo(): void;
    get root(): UnwrappedEditableField;
    set root(data: NewFieldContent);
    readonly rootEvents: ISubscribable<AnchorSetRootEvents>;
    schematize<TRoot extends GlobalFieldSchema>(config: SchematizeConfiguration<TRoot>): ISharedTreeView;
    readonly storedSchema: StoredSchemaRepository;
    readonly transaction: {
        start(): void;
        commit(): TransactionResult.Commit;
        abort(): TransactionResult.Abort;
        inProgress(): boolean;
    };
    undo(): void;
}

// @alpha (undocumented)
export function isNeverField(policy: FullSchemaPolicy, originalData: SchemaData, field: FieldStoredSchema): boolean;

// @alpha (undocumented)
export function isPrimitive(schema: TreeStoredSchema): boolean;

// @alpha (undocumented)
export function isPrimitiveValue(nodeValue: Value): nodeValue is PrimitiveValue;

// @alpha
export interface ISubscribable<E extends Events<E>> {
    on<K extends keyof Events<E>>(eventName: K, listener: E[K]): () => void;
}

// @alpha
export interface ITreeCursor {
    readonly [CursorMarker]: true;
    readonly chunkLength: number;
    readonly chunkStart: number;
    enterField(key: FieldKey): void;
    enterNode(childIndex: number): void;
    exitField(): void;
    exitNode(): void;
    readonly fieldIndex: number;
    firstField(): boolean;
    firstNode(): boolean;
    getFieldKey(): FieldKey;
    // (undocumented)
    getFieldLength(): number;
    getFieldPath(prefix?: PathRootPrefix): FieldUpPath;
    getPath(prefix?: PathRootPrefix): UpPath | undefined;
    readonly mode: CursorLocationType;
    nextField(): boolean;
    nextNode(): boolean;
    // (undocumented)
    readonly pending: boolean;
    seekNodes(offset: number): boolean;
    skipPendingFields(): boolean;
    readonly type: TreeType;
    readonly value: Value;
}

// @alpha
export interface ITreeCursorSynchronous extends ITreeCursor {
    // (undocumented)
    readonly pending: false;
}

// @alpha (undocumented)
export interface ITreeSchema extends NamedTreeSchema, Sourced {
    // (undocumented)
    readonly extraLocalFields: IFieldSchema;
    // (undocumented)
    readonly globalFields: ReadonlySet<GlobalFieldKey>;
    // (undocumented)
    readonly localFields: ReadonlyMap<LocalFieldKey, IFieldSchema>;
}

// @alpha
export interface ITreeSubscriptionCursor extends ITreeCursor {
    buildAnchor(): Anchor;
    buildFieldAnchor(): FieldAnchor;
    clear(): void;
    // (undocumented)
    fork(): ITreeSubscriptionCursor;
    free(): void;
    readonly state: ITreeSubscriptionCursorState;
}

// @alpha (undocumented)
export enum ITreeSubscriptionCursorState {
    Cleared = 1,
    Current = 0,
    Freed = 2
}

// @alpha
export interface JsonableTree extends GenericTreeNode<JsonableTree> {
}

// @alpha
export function jsonableTreeFromCursor(cursor: ITreeCursor): JsonableTree;

// @alpha (undocumented)
export const jsonArray: TreeSchema<"Json.Array", {
local: {
[x: string]: FieldSchema<Sequence, [any, any, TreeSchema<"Json.Number", {
value: ValueSchema.Number;
}>, TreeSchema<"Json.String", {
value: ValueSchema.String;
}>, TreeSchema<"Json.Null", {}>, TreeSchema<"Json.Boolean", {
value: ValueSchema.Boolean;
}>]>;
};
}>;

// @alpha (undocumented)
export const jsonBoolean: TreeSchema<"Json.Boolean", {
value: ValueSchema.Boolean;
}>;

// @alpha
export type JsonCompatible = string | number | boolean | null | JsonCompatible[] | JsonCompatibleObject;

// @alpha
export type JsonCompatibleObject = {
    [P in string]?: JsonCompatible;
};

// @alpha
export type JsonCompatibleReadOnly = string | number | boolean | null | readonly JsonCompatibleReadOnly[] | {
    readonly [P in string]?: JsonCompatibleReadOnly;
};

// @alpha (undocumented)
export const jsonNull: TreeSchema<"Json.Null", {}>;

// @alpha (undocumented)
export const jsonNumber: TreeSchema<"Json.Number", {
value: ValueSchema.Number;
}>;

// @alpha (undocumented)
export const jsonObject: TreeSchema<"Json.Object", {
extraLocalFields: FieldSchema<Optional, [any, () => TreeSchema<"Json.Array", {
local: {
[x: string]: FieldSchema<Sequence, [any, any, TreeSchema<"Json.Number", {
value: ValueSchema.Number;
}>, TreeSchema<"Json.String", {
value: ValueSchema.String;
}>, TreeSchema<"Json.Null", {}>, TreeSchema<"Json.Boolean", {
value: ValueSchema.Boolean;
}>]>;
};
}>, TreeSchema<"Json.Number", {
value: ValueSchema.Number;
}>, TreeSchema<"Json.String", {
value: ValueSchema.String;
}>, TreeSchema<"Json.Null", {}>, TreeSchema<"Json.Boolean", {
value: ValueSchema.Boolean;
}>]>;
}>;

// @alpha (undocumented)
export const jsonSchema: SchemaLibrary;

// @alpha (undocumented)
export const jsonString: TreeSchema<"Json.String", {
value: ValueSchema.String;
}>;

// @alpha
export interface JsonValidator {
    compile<Schema extends TSchema>(schema: Schema): SchemaValidationFunction<Schema>;
}

// @alpha (undocumented)
export function keyFromSymbol(key: GlobalFieldKeySymbol): GlobalFieldKey;

// @alpha
type LazyItem<Item = unknown> = Item | (() => Item);

// @alpha
export type LocalFieldKey = Brand<string, "tree.LocalFieldKey">;

// @alpha (undocumented)
interface LocalFields {
    // (undocumented)
    readonly [key: string]: FieldSchema;
}

// @alpha
interface MakeNominal {
}

// @alpha
export interface MapTree extends NodeData {
    // (undocumented)
    fields: Map<FieldKey, MapTree[]>;
}

// @alpha
type Mark<TTree = ProtoNode> = Skip | Modify<TTree> | Delete<TTree> | MoveOut<TTree> | MoveIn | Insert<TTree>;

// @alpha
export interface MarkedArrayLike<TGet, TSet extends TGet = TGet> extends ArrayLikeMut<TGet, TSet> {
    // (undocumented)
    readonly [arrayLikeMarkerSymbol]: true;
    // (undocumented)
    [Symbol.iterator](): IterableIterator<TGet>;
}

// @alpha
type MarkList<TTree = ProtoNode> = readonly Mark<TTree>[];

// @alpha (undocumented)
const MarkType: {
    readonly Modify: 0;
    readonly Insert: 1;
    readonly MoveIn: 2;
    readonly Delete: 3;
    readonly MoveOut: 4;
};

// @alpha
interface Modify<TTree = ProtoNode> extends HasModifications<TTree> {
    // (undocumented)
    readonly type: typeof MarkType.Modify;
}

// @alpha (undocumented)
export interface ModularChangeset extends HasFieldChanges {
    // (undocumented)
    constraintViolationCount?: number;
    // (undocumented)
    fieldChanges: FieldChangeMap;
    maxId?: ChangesetLocalId;
    readonly revisions?: readonly RevisionInfo[];
}

// @alpha
interface MoveId extends Opaque<Brand<number, "delta.MoveId">> {
}

// @alpha
interface MoveIn {
    // (undocumented)
    readonly count: number;
    readonly moveId: MoveId;
    // (undocumented)
    readonly type: typeof MarkType.MoveIn;
}

// @alpha
interface MoveOut<TTree = ProtoNode> extends HasModifications<TTree> {
    readonly count: number;
    readonly moveId: MoveId;
    // (undocumented)
    readonly type: typeof MarkType.MoveOut;
}

// @alpha
export enum Multiplicity {
    Forbidden = 3,
    Optional = 1,
    Sequence = 2,
    Value = 0
}

// @alpha (undocumented)
export interface Named<TName> {
    // (undocumented)
    readonly name: TName;
}

// @alpha
export interface NamedComputation {
    readonly computationName: string;
    listDependees?(): Iterable<Dependee>;
    listDependents?(): Iterable<Dependent>;
}

// @alpha (undocumented)
export type NamedTreeSchema = Named<TreeSchemaIdentifier> & TreeStoredSchema;

// @alpha
export function namedTreeSchema(data: Partial<TreeSchemaBuilder> & Named<TreeSchemaIdentifier>): NamedTreeSchema;

// @alpha
export type NameFromBranded<T extends BrandedType<any, string>> = T extends BrandedType<any, infer Name> ? Name : never;

// @alpha
export type NestedMap<Key1, Key2, Value> = Map<Key1, Map<Key2, Value>>;

// @alpha
export const neverTree: TreeStoredSchema;

// @alpha
export type NewFieldContent = ITreeCursor | readonly ITreeCursor[] | ContextuallyTypedFieldData;

// @alpha (undocumented)
export type NodeChangeComposer = (changes: TaggedChange<NodeChangeset>[]) => NodeChangeset;

// @alpha (undocumented)
export type NodeChangeInverter = (change: NodeChangeset, index: number | undefined) => NodeChangeset;

// @alpha (undocumented)
export type NodeChangeRebaser = (change: NodeChangeset | undefined, baseChange: NodeChangeset | undefined,
state?: NodeExistenceState) => NodeChangeset | undefined;

// @alpha
export interface NodeChangeset extends HasFieldChanges {
    // (undocumented)
    nodeExistsConstraint?: NodeExistsConstraint;
    // (undocumented)
    valueChange?: ValueChange;
    // (undocumented)
    valueConstraint?: ValueConstraint;
}

// @alpha
export interface NodeData {
    readonly type: TreeSchemaIdentifier;
    value?: TreeValue;
}

// @alpha @deprecated
type NodeDataFor<Mode extends ApiMode, TSchema extends TreeSchema> = TypedNode<TSchema, Mode>;

// @alpha (undocumented)
export enum NodeExistenceState {
    // (undocumented)
    Alive = 0,
    // (undocumented)
    Dead = 1
}

// @alpha (undocumented)
export interface NodeExistsConstraint {
    // (undocumented)
    violated: boolean;
}

// @alpha
export type NodeIdentifier = Brand<StableId, "Node Identifier">;

// @alpha (undocumented)
export interface NodeIdentifierFieldKind extends BrandedFieldKind<"NodeIdentifier", Multiplicity.Value, FieldEditor<any>> {
}

// @alpha
export const nodeIdentifierKey: GlobalFieldKey;

// @alpha
export function nodeIdentifierSchema(): {
    schema: SchemaLibrary;
    field: GlobalFieldSchema<NodeIdentifierFieldKind>;
    type: TreeSchemaIdentifier;
};

// @alpha (undocumented)
export type NodeReviver = (revision: RevisionTag, index: number, count: number) => Delta.ProtoNode[];

// @alpha
export type NoListenersCallback<E extends Events<E>> = (eventName: keyof Events<E>) => void;

// @alpha
export const noopValidator: JsonValidator;

// @alpha (undocumented)
type NormalizedFlexList<Item> = readonly Item[];

// @alpha
type NormalizeField<T extends FieldSchema | undefined> = T extends FieldSchema ? T : FieldSchema<typeof FieldKinds.forbidden, []>;

// @alpha (undocumented)
type NormalizeLocalFields<T extends LocalFields | undefined> = NormalizeLocalFieldsInner<WithDefault<T, Record<string, never>>>;

// @alpha (undocumented)
type NormalizeLocalFieldsInner<T extends LocalFields> = {
    [Property in keyof T]: NormalizeField<T[Property]>;
};

// @alpha
type ObjectToMap<ObjectMap, MapKey extends number | string, MapValue> = ReadonlyMap<MapKey, MapValue> & {
    get<TKey extends keyof ObjectMap>(key: TKey): ObjectMap[TKey];
};

// @alpha
export interface ObservingDependent extends Dependent {
    // @override
    listDependees(): Iterable<Dependee>;
    registerDependee(dependee: Dependee): void;
}

// @alpha
export const on: unique symbol;

// @alpha
export type Opaque<T extends Brand<any, string>> = T extends Brand<infer ValueType, infer Name> ? BrandedType<ValueType, Name> : never;

// @alpha (undocumented)
export interface Optional extends BrandedFieldKind<"Optional", Multiplicity.Optional, FieldEditor<any>> {
}

// @alpha (undocumented)
export interface OptionalFieldEditBuilder {
    set(newContent: ITreeCursor | undefined, wasEmpty: boolean): void;
}

// @alpha
type OptionalFields<T> = [
    {
    [P in keyof T as undefined extends T[P] ? T[P] extends undefined ? never : P : never]?: T[P];
}
][_InlineTrick];

// @alpha
export const parentField: unique symbol;

// @alpha
export interface PathRootPrefix {
    indexOffset?: number;
    parent?: UpPath | undefined;
    rootFieldOverride?: FieldKey;
}

// @alpha
export interface PathVisitor {
    onDelete(path: UpPath, count: number): void;
    // (undocumented)
    onInsert(path: UpPath, content: Delta.ProtoNodes): void;
    onSetValue(path: UpPath, value: Value): void;
}

// @alpha
export function prefixFieldPath(prefix: PathRootPrefix | undefined, path: FieldUpPath): FieldUpPath;

// @alpha
export function prefixPath(prefix: PathRootPrefix | undefined, path: UpPath | undefined): UpPath | undefined;

// @alpha (undocumented)
export type PrimitiveValue = string | boolean | number;

// @alpha
type PrimitiveValueSchema = ValueSchema.Number | ValueSchema.String | ValueSchema.Boolean;

// @alpha
type ProtoNode = ITreeCursorSynchronous;

// @alpha
type ProtoNodes = readonly ProtoNode[];

// @alpha
export const proxyTargetSymbol: unique symbol;

// @alpha
export interface ReadonlyRepairDataStore<TTree = Delta.ProtoNode, TRevisionTag = unknown> {
    // (undocumented)
    getNodes(revision: TRevisionTag, path: UpPath | undefined, key: FieldKey, index: number, count: number): TTree[];
    // (undocumented)
    getValue(revision: TRevisionTag, path: UpPath): Value;
}

// @alpha
export function recordDependency(dependent: ObservingDependent | undefined, dependee: Dependee): void;

// @alpha
type RecursiveTreeSchema = unknown;

// @alpha
type RecursiveTreeSchemaSpecification = unknown;

// @alpha
type _RecursiveTrick = never;

// @alpha
export interface RepairDataStore<TChange, TTree = Delta.ProtoNode, TRevisionTag = unknown> extends ReadonlyRepairDataStore<TTree, TRevisionTag> {
    capture(change: TChange, revision: TRevisionTag): void;
}

// @alpha
type RequiredFields<T> = [
    {
    [P in keyof T as undefined extends T[P] ? never : P]: T[P];
}
][_InlineTrick];

// @alpha
type RestrictiveReadonlyRecord<K extends symbol | string, T> = {
    readonly [P in symbol | string]: P extends K ? T : never;
};

// @alpha
export type RevisionIndexer = (tag: RevisionTag) => number;

// @alpha (undocumented)
export interface RevisionInfo {
    // (undocumented)
    readonly revision: RevisionTag;
    readonly rollbackOf?: RevisionTag;
}

// @alpha (undocumented)
export interface RevisionMetadataSource {
    // (undocumented)
    readonly getIndex: RevisionIndexer;
    // (undocumented)
    readonly getInfo: (tag: RevisionTag) => RevisionInfo;
}

// @alpha
export type RevisionTag = StableId;

// @alpha
type Root<TTree = ProtoNode> = FieldMarks<TTree>;

// @alpha
export interface RootField {
    // (undocumented)
    readonly key: DetachedField;
}

// @alpha (undocumented)
export const rootField: DetachedField;

// @alpha
export const rootFieldKey: GlobalFieldKey;

// @alpha (undocumented)
export const rootFieldKeySymbol: GlobalFieldKeySymbol;

// @alpha
export function runSynchronous(view: ISharedTreeView, transaction: (view: ISharedTreeView) => TransactionResult | void): TransactionResult;

declare namespace SchemaAware {
    export {
        ApiMode,
        NodeDataFor,
        TypedNode,
        TypedField,
        AllowedTypesToTypedTrees,
        InternalTypes_2 as InternalTypes
    }
}
export { SchemaAware }

// @alpha @sealed
export class SchemaBuilder {
    constructor(name: string, ...libraries: SchemaLibrary[]);
    addLibraries(...libraries: SchemaLibrary[]): void;
    static field<Kind extends FieldKindTypes, T extends AllowedTypes>(kind: Kind, ...allowedTypes: T): FieldSchema<Kind, T>;
    static fieldOptional<T extends AllowedTypes>(...allowedTypes: T): FieldSchema<typeof FieldKinds.optional, T>;
    static fieldRecursive<Kind extends FieldKindTypes, T extends FlexList<RecursiveTreeSchema>>(kind: Kind, ...allowedTypes: T): FieldSchema<Kind, T>;
    static fieldSequence<T extends AllowedTypes>(...t: T): FieldSchema<typeof FieldKinds.sequence, T>;
    static fieldValue<T extends AllowedTypes>(...allowedTypes: T): FieldSchema<typeof FieldKinds.value, T>;
    globalField<Kind extends FieldKindTypes, Types extends AllowedTypes>(key: string, field: FieldSchema<Kind, Types>): GlobalFieldSchema<Kind, Types>;
    intoDocumentSchema<Kind extends FieldKindTypes, Types extends AllowedTypes>(root: FieldSchema<Kind, Types>): TypedSchemaCollection<GlobalFieldSchema<Kind, Types>>;
    intoLibrary(): SchemaLibrary;
    // (undocumented)
    readonly name: string;
    object<Name extends string, T extends TreeSchemaSpecification>(name: Name, t: T): TreeSchema<Name, T>;
    objectRecursive<Name extends string, T extends RecursiveTreeSchemaSpecification>(name: Name, t: T): TreeSchema<Name, T>;
    primitive<Name extends string, T extends InternalTypes_2.PrimitiveValueSchema>(name: Name, t: T): TreeSchema<Name, {
        value: T;
    }>;
}

// @alpha
export interface SchemaCollection {
    // (undocumented)
    readonly adapters: Adapters;
    // (undocumented)
    readonly globalFieldSchema: ReadonlyMap<GlobalFieldKey, IFieldSchema>;
    // (undocumented)
    readonly policy: FullSchemaPolicy;
    // (undocumented)
    readonly treeSchema: ReadonlyMap<TreeSchemaIdentifier, ITreeSchema>;
}

// @alpha
export interface SchemaData {
    // (undocumented)
    readonly globalFieldSchema: ReadonlyMap<GlobalFieldKey, FieldStoredSchema>;
    // (undocumented)
    readonly treeSchema: ReadonlyMap<TreeSchemaIdentifier, TreeStoredSchema>;
}

// @alpha
export interface SchemaDataAndPolicy<TPolicy extends SchemaPolicy = SchemaPolicy> extends SchemaData {
    readonly policy: TPolicy;
}

// @alpha
export interface SchemaEvents {
    afterSchemaChange(newSchema: SchemaData): void;
    beforeSchemaChange(newSchema: SchemaData): void;
}

// @alpha
export interface SchemaLibrary extends SchemaCollection {
    readonly libraries: ReadonlySet<SchemaLibraryData>;
}

// @alpha
export interface SchemaLibraryData {
    // (undocumented)
    readonly adapters: Adapters;
    // (undocumented)
    readonly globalFieldSchema: ReadonlyMap<GlobalFieldKey, GlobalFieldSchema>;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly treeSchema: ReadonlyMap<TreeSchemaIdentifier, TreeSchema>;
}

// @alpha
export interface SchemaPolicy {
    readonly defaultGlobalFieldSchema: FieldStoredSchema;
    readonly defaultTreeSchema: TreeStoredSchema;
}

// @alpha
export interface SchematizeConfiguration<TRoot extends GlobalFieldSchema = GlobalFieldSchema> {
    readonly allowedSchemaModifications: AllowedUpdateType;
    readonly initialTree: SchemaAware.TypedField<TRoot["schema"], SchemaAware.ApiMode.Simple> | readonly ITreeCursor[];
    readonly schema: TypedSchemaCollection<TRoot>;
}

// @alpha
export interface SchemaValidationFunction<Schema extends TSchema> {
    // (undocumented)
    check(data: unknown): data is Static<Schema>;
}

// @alpha (undocumented)
export interface Sequence extends BrandedFieldKind<"Sequence", Multiplicity.Sequence, FieldEditor<any>> {
}

// @alpha (undocumented)
export interface SequenceFieldEditBuilder {
    delete(index: number, count: number): void;
    insert(index: number, newContent: ITreeCursor | readonly ITreeCursor[]): void;
    move(sourceIndex: number, count: number, destIndex: number): void;
    revive(index: number, count: number, detachedBy: RevisionTag, reviver: NodeReviver, detachIndex: number, isIntention?: true): void;
}

// @alpha
export class SharedTreeFactory implements IChannelFactory {
    constructor(options?: SharedTreeOptions);
    // (undocumented)
    attributes: IChannelAttributes;
    // (undocumented)
    create(runtime: IFluidDataStoreRuntime, id: string): ISharedTree;
    // (undocumented)
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, channelAttributes: Readonly<IChannelAttributes>): Promise<ISharedTree>;
    // (undocumented)
    type: string;
}

// @alpha (undocumented)
export interface SharedTreeOptions extends Partial<ICodecOptions> {
}

// @alpha
export class SharedTreeView implements ISharedTreeView {
    // (undocumented)
    readonly context: EditableTreeContext;
    dispose(): void;
    // (undocumented)
    get editor(): IDefaultEditBuilder;
    // (undocumented)
    get events(): ISubscribable<ViewEvents>;
    // (undocumented)
    get forest(): IForestSubscription;
    // (undocumented)
    fork(): SharedTreeView;
    // (undocumented)
    generateNodeIdentifier(): NodeIdentifier;
    // (undocumented)
    get identifiedNodes(): ReadonlyMap<NodeIdentifier, EditableTree>;
    // (undocumented)
    locate(anchor: Anchor): AnchorNode | undefined;
    // (undocumented)
    merge(fork: SharedTreeView): void;
    // (undocumented)
    rebase(fork: SharedTreeView): void;
    rebaseOnto(view: ISharedTreeView): void;
    // (undocumented)
    redo(): void;
    // (undocumented)
    get root(): UnwrappedEditableField;
    set root(data: NewFieldContent);
    // (undocumented)
    get rootEvents(): ISubscribable<AnchorSetRootEvents>;
    // (undocumented)
    schematize<TRoot extends GlobalFieldSchema>(config: SchematizeConfiguration<TRoot>): ISharedTreeView;
    // (undocumented)
    get storedSchema(): StoredSchemaRepository;
    // (undocumented)
    readonly transaction: ISharedTreeView["transaction"];
    // (undocumented)
    undo(): void;
}

// @alpha
export class SimpleDependee implements Dependee {
    constructor(computationName?: string);
    // (undocumented)
    readonly computationName: string;
    invalidateDependents(token?: InvalidationToken): void;
    // @sealed (undocumented)
    listDependents(): Set<Dependent>;
    // (undocumented)
    registerDependent(dependent: Dependent): boolean;
    // (undocumented)
    removeDependent(dependent: Dependent): void;
}

// @alpha
export function singleJsonCursor(root: JsonCompatible): ITreeCursorSynchronous;

// @alpha
export function singleStackTreeCursor<TNode>(root: TNode, adapter: CursorAdapter<TNode>): CursorWithNode<TNode>;

// @alpha
export function singleTextCursor(root: JsonableTree): ITreeCursorSynchronous;

// @alpha
type Skip = number;

// @alpha
export interface Sourced {
    // (undocumented)
    readonly builder: Named<string>;
}

// @alpha
export interface StoredSchemaRepository<TPolicy extends SchemaPolicy = SchemaPolicy> extends Dependee, ISubscribable<SchemaEvents>, SchemaDataAndPolicy<TPolicy> {
    update(newSchema: SchemaData): void;
}

// @alpha (undocumented)
export function symbolFromKey(key: GlobalFieldKey): GlobalFieldKeySymbol;

// @alpha (undocumented)
export function symbolIsFieldKey(key: symbol): key is GlobalFieldKeySymbol;

// @alpha (undocumented)
export interface TaggedChange<TChangeset> {
    // (undocumented)
    readonly change: TChangeset;
    // (undocumented)
    readonly revision: RevisionTag | undefined;
    readonly rollbackOf?: RevisionTag;
}

// @alpha
export type ToDelta = (child: NodeChangeset) => Delta.Modify;

// @alpha
export enum TransactionResult {
    Abort = 0,
    Commit = 1
}

// @alpha (undocumented)
export interface TreeAdapter {
    // (undocumented)
    readonly input: TreeSchemaIdentifier;
    // (undocumented)
    readonly output: TreeSchemaIdentifier;
}

// @alpha
export interface TreeDataContext {
    fieldSource?(key: FieldKey, schema: FieldStoredSchema): undefined | FieldGenerator;
    readonly schema: SchemaDataAndPolicy;
}

// @alpha (undocumented)
export interface TreeLocation {
    // (undocumented)
    readonly index: number;
    // (undocumented)
    readonly range: FieldLocation | DetachedField;
}

// @alpha (undocumented)
export const enum TreeNavigationResult {
    NotFound = -1,
    Ok = 1,
    Pending = 0
}

// @alpha
export class TreeSchema<Name extends string = string, T extends RecursiveTreeSchemaSpecification = TreeSchemaSpecification> implements ITreeSchema {
    constructor(builder: Named<string>, name: Name, info: T);
    // (undocumented)
    readonly builder: Named<string>;
    // (undocumented)
    readonly extraGlobalFields: boolean;
    // (undocumented)
    readonly extraLocalFields: FieldSchema;
    // (undocumented)
    get globalFields(): ReadonlySet<GlobalFieldKey>;
    // (undocumented)
    readonly info: Assume<T, TreeSchemaSpecification>;
    // (undocumented)
    readonly localFields: ObjectToMap<NormalizeLocalFields<Assume<T, TreeSchemaSpecification>["local"]>, LocalFieldKey, FieldSchema>;
    // (undocumented)
    readonly localFieldsObject: NormalizeLocalFields<Assume<T, TreeSchemaSpecification>["local"]>;
    // (undocumented)
    readonly name: Name & TreeSchemaIdentifier;
    // (undocumented)
    readonly value: WithDefault<Assume<T, TreeSchemaSpecification>["value"], ValueSchema.Nothing>;
}

// @alpha
export interface TreeSchemaBuilder {
    // (undocumented)
    readonly extraGlobalFields?: boolean;
    // (undocumented)
    readonly extraLocalFields: FieldStoredSchema;
    // (undocumented)
    readonly globalFields?: Iterable<GlobalFieldKey>;
    // (undocumented)
    readonly localFields?: {
        [key: string]: FieldStoredSchema;
    };
    // (undocumented)
    readonly value?: ValueSchema;
}

// @alpha
export type TreeSchemaIdentifier = Brand<string, "tree.Schema">;

// @alpha
interface TreeSchemaSpecification {
    // (undocumented)
    readonly extraGlobalFields?: boolean;
    // (undocumented)
    readonly extraLocalFields?: FieldSchema;
    // (undocumented)
    readonly global?: FlexList<GlobalFieldSchema>;
    // (undocumented)
    readonly local?: RestrictiveReadonlyRecord<string, FieldSchema>;
    // (undocumented)
    readonly value?: ValueSchema;
}

// @alpha (undocumented)
export interface TreeStoredSchema {
    readonly extraGlobalFields: boolean;
    readonly extraLocalFields: FieldStoredSchema;
    readonly globalFields: ReadonlySet<GlobalFieldKey>;
    readonly localFields: ReadonlyMap<LocalFieldKey, FieldStoredSchema>;
    readonly value: ValueSchema;
}

// @alpha (undocumented)
export type TreeType = TreeSchemaIdentifier;

// @alpha
export type TreeTypeSet = ReadonlySet<TreeSchemaIdentifier> | undefined;

// @alpha
export interface TreeValue extends Serializable {
}

// @alpha
type TypeArrayToTypedTreeArray<Mode extends ApiMode, T extends readonly TreeSchema[]> = [
T extends readonly [infer Head, ...infer Tail] ? [
TypedNode<Assume<Head, TreeSchema>, Mode>,
...TypeArrayToTypedTreeArray<Mode, Assume<Tail, readonly TreeSchema[]>>
] : []
][_InlineTrick];

// @alpha
export const typeboxValidator: JsonValidator;

// @alpha
type TypedField<TField extends FieldSchema, Mode extends ApiMode = ApiMode.Editable> = [
ApplyMultiplicity<TField["kind"]["multiplicity"], AllowedTypesToTypedTrees<Mode, TField["allowedTypes"]>, Mode>
][_InlineTrick];

// @alpha
type TypedFields<Mode extends ApiMode, TFields extends undefined | {
    [key: string]: FieldSchema;
}> = [
TFields extends {
    [key: string]: FieldSchema;
} ? {
    [key in keyof TFields]: TypedField<TFields[key], Mode extends ApiMode.Editable ? ApiMode.EditableUnwrapped : Mode>;
} : EmptyObject
][_InlineTrick];

// @alpha
type TypedNode<TSchema extends TreeSchema, Mode extends ApiMode = ApiMode.Editable> = FlattenKeys<CollectOptions<Mode, TypedFields<Mode extends ApiMode.Editable ? ApiMode.EditableUnwrapped : Mode, TSchema["localFieldsObject"]>, TSchema["value"], TSchema["name"]>>;

// @alpha (undocumented)
export interface TypedSchemaCollection<T extends GlobalFieldSchema> extends SchemaCollection {
    readonly root: T;
}

// @alpha
type TypedValue<TValue extends ValueSchema> = {
    [ValueSchema.Nothing]: undefined;
    [ValueSchema.Number]: number;
    [ValueSchema.String]: string;
    [ValueSchema.Boolean]: boolean;
    [ValueSchema.Serializable]: Value;
}[TValue];

// @alpha
export const typeNameSymbol: unique symbol;

// @alpha
export const typeSymbol: unique symbol;

// @alpha
type Unbrand<T, B> = T extends infer S & B ? S : T;

// @alpha
type UnbrandedName<TName> = [
TName extends infer S & TreeSchemaIdentifier ? S : string
][_InlineTrick];

// @alpha
type UnbrandList<T extends unknown[], B> = T extends [infer Head, ...infer Tail] ? [Unbrand<Head, B>, ...UnbrandList<Tail, B>] : [];

// @alpha
type UntypedApi<Mode extends ApiMode> = {
    [ApiMode.Editable]: UntypedTree;
    [ApiMode.EditableUnwrapped]: UntypedTree | PrimitiveValue;
    [ApiMode.Flexible]: ContextuallyTypedNodeData;
    [ApiMode.Simple]: ContextuallyTypedNodeData;
    [ApiMode.Wrapped]: UntypedTree;
}[Mode];

// @alpha
export interface UntypedField extends MarkedArrayLike<UnwrappedUntypedTree> {
    readonly context: UntypedTreeContext;
    readonly fieldKey: FieldKey;
    readonly fieldSchema: FieldStoredSchema;
    getNode(index: number): UntypedTree;
    readonly parent?: UntypedTree;
}

// @alpha
interface UntypedOptionalField extends UntypedField {
    readonly content: UntypedTreeCore;
    delete(): void;
    readonly fieldSchema: FieldStoredSchema & {
        readonly kind: Optional;
    };
    setContent(newContent: ITreeCursor | ContextuallyTypedNodeData | undefined): void;
}

// @alpha
interface UntypedSequenceField extends UntypedField {
    delete(): void;
    deleteNodes(index: number, count?: number): void;
    readonly fieldSchema: FieldStoredSchema & {
        readonly kind: Sequence;
    };
    insertNodes(index: number, newContent: NewFieldContent): void;
    moveNodes(sourceIndex: number, count: number, destIndex: number, destinationField?: UntypedField): void;
    replaceNodes(index: number, newContent: NewFieldContent, count?: number): void;
    setContent(newContent: NewFieldContent): void;
}

// @alpha
export interface UntypedTree extends UntypedTreeCore {
    readonly [typeNameSymbol]: TreeSchemaIdentifier;
    readonly [valueSymbol]: Value;
    readonly [key: FieldKey]: UnwrappedUntypedField;
}

// @alpha
export interface UntypedTreeContext extends ISubscribable<ForestEvents> {
    clear(): void;
    free(): void;
    prepareForEdit(): void;
    readonly root: UntypedField;
    readonly schema: SchemaDataAndPolicy;
    readonly unwrappedRoot: UnwrappedUntypedField;
}

// @alpha
export interface UntypedTreeCore extends Iterable<UntypedField> {
    readonly [contextSymbol]: UntypedTreeContext;
    [getField](fieldKey: FieldKey): UntypedField;
    // (undocumented)
    [on]<K extends keyof EditableTreeEvents>(eventName: K, listener: EditableTreeEvents[K]): () => void;
    readonly [parentField]: {
        readonly parent: UntypedField;
        readonly index: number;
    };
    readonly [typeSymbol]: NamedTreeSchema;
}

// @alpha
export type UntypedTreeOrPrimitive = UntypedTree | PrimitiveValue;

// @alpha
interface UntypedValueField extends UntypedField {
    readonly content: UntypedTreeCore;
    readonly fieldSchema: FieldStoredSchema & {
        readonly kind: ValueFieldKind;
    };
    setContent(newContent: ITreeCursor | ContextuallyTypedNodeData): void;
}

// @alpha
export type UnwrappedEditableField = UnwrappedEditableTree | undefined | EditableField;

// @alpha
export type UnwrappedEditableTree = EditableTreeOrPrimitive | EditableField;

// @alpha
export type UnwrappedUntypedField = UnwrappedUntypedTree | undefined | UntypedField;

// @alpha
export type UnwrappedUntypedTree = UntypedTreeOrPrimitive | UntypedField;

// @alpha
export interface UpPath<TParent = UpPathDefault> {
    readonly parent: TParent | undefined;
    readonly parentField: FieldKey;
    readonly parentIndex: number;
}

// @alpha
export type UpPathDefault = UpPath;

// @alpha
export type Value = undefined | TreeValue;

// @alpha (undocumented)
export interface ValueChange {
    revision?: RevisionTag;
    value?: Value;
}

// @alpha (undocumented)
export interface ValueConstraint {
    // (undocumented)
    value: Value;
    // (undocumented)
    violated: boolean;
}

// @alpha (undocumented)
export interface ValueFieldEditBuilder {
    set(newContent: ITreeCursor): void;
}

// @alpha (undocumented)
export interface ValueFieldKind extends BrandedFieldKind<"Value", Multiplicity.Value, FieldEditor<any>> {
}

// @alpha
export type ValueFromBranded<T extends BrandedType<any, string>> = T extends BrandedType<infer ValueType, string> ? ValueType : never;

// @alpha (undocumented)
type ValuePropertyFromSchema<TSchema extends ValueSchema> = TSchema extends ValueSchema.Nothing ? EmptyObject : undefined extends TypedValue<TSchema> ? {
    [valueSymbol]?: TypedValue<TSchema>;
} : {
    [valueSymbol]: TypedValue<TSchema>;
};

// @alpha
export enum ValueSchema {
    // (undocumented)
    Boolean = 3,
    // (undocumented)
    Nothing = 0,
    // (undocumented)
    Number = 1,
    Serializable = 4,
    // (undocumented)
    String = 2
}

// @alpha (undocumented)
type ValuesOf<T> = T[keyof T];

// @alpha
export const valueSymbol: unique symbol;

// @alpha
export interface ViewEvents {
    afterBatch(): void;
}

// @alpha
type WithDefault<T, Default> = T extends undefined ? Default : unknown extends T ? Default : T;

// (No @packageDocumentation comment for this package)

```
