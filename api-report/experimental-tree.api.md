## API Report File for "@fluid-experimental/tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { EventEmitterWithErrorHandling } from '@fluidframework/telemetry-utils';
import { IChannel } from '@fluidframework/datastore-definitions';
import { IChannelAttributes } from '@fluidframework/datastore-definitions';
import { IChannelFactory } from '@fluidframework/datastore-definitions';
import { IChannelServices } from '@fluidframework/datastore-definitions';
import { IChannelStorageService } from '@fluidframework/datastore-definitions';
import { IDisposable } from '@fluidframework/common-definitions';
import { IErrorEvent } from '@fluidframework/common-definitions';
import { IFluidDataStoreRuntime } from '@fluidframework/datastore-definitions';
import { IFluidSerializer } from '@fluidframework/shared-object-base';
import { ISharedObjectEvents } from '@fluidframework/shared-object-base';
import { ISummaryTreeWithStats } from '@fluidframework/runtime-definitions';
import { ITelemetryBaseEvent } from '@fluidframework/common-definitions';
import { ITelemetryLogger } from '@fluidframework/common-definitions';
import { ITelemetryProperties } from '@fluidframework/common-definitions';
import type { Serializable } from '@fluidframework/datastore-definitions';
import { SharedObject } from '@fluidframework/shared-object-base';
import { TypedEventEmitter } from '@fluidframework/common-utils';

// @public
export function areRevisionViewsSemanticallyEqual(treeViewA: TreeView, idConverterA: NodeIdConverter, treeViewB: TreeView, idConverterB: NodeIdConverter): boolean;

// @public
export type AttributionId = UuidString;

// @public
export type BadPlaceValidationResult = Exclude<PlaceValidationResult, PlaceValidationResult.Valid>;

// @public
export type BadRangeValidationResult = Exclude<RangeValidationResult, RangeValidationResultKind.Valid>;

// @public
export interface Build {
    // (undocumented)
    readonly destination: number;
    // (undocumented)
    readonly source: BuildNode | TreeNodeSequence<BuildNode>;
    // (undocumented)
    readonly type: typeof ChangeType.Build;
}

// @public
export interface BuildInternal extends Omit<BuildInternal_0_0_2, 'source'> {
    // (undocumented)
    readonly source: TreeNodeSequence<BuildNodeInternal>;
}

// @public
export interface BuildInternal_0_0_2 {
    // (undocumented)
    readonly destination: DetachedSequenceId;
    // (undocumented)
    readonly source: TreeNodeSequence<BuildNodeInternal_0_0_2>;
    // (undocumented)
    readonly type: typeof ChangeTypeInternal.Build;
}

// @public
export type BuildNode = BuildTreeNode | number;

// @public
export type BuildNodeInternal = TreeNode<BuildNodeInternal, NodeId> | DetachedSequenceId;

// @public
export type BuildNodeInternal_0_0_2 = TreeNode<BuildNodeInternal_0_0_2, StableNodeId> | DetachedSequenceId;

// @public
export interface BuildTreeNode extends HasVariadicTraits<BuildNode> {
    // (undocumented)
    definition: string;
    // (undocumented)
    identifier?: NodeId;
    // (undocumented)
    payload?: Payload;
}

// @public
export type Change = Insert | Detach | Build | SetValue | Constraint;

// @public (undocumented)
export const Change: {
    build: (source: BuildNode | TreeNodeSequence<BuildNode>, destination: number) => Build;
    insert: (source: number, destination: StablePlace) => Insert;
    detach: (source: StableRange, destination?: number | undefined) => Detach;
    setPayload: (nodeToModify: NodeId, payload: Payload) => SetValue;
    clearPayload: (nodeToModify: NodeId) => SetValue;
    constraint: (toConstrain: StableRange, effect: ConstraintEffect, identityHash?: UuidString | undefined, length?: number | undefined, contentHash?: UuidString | undefined, parentNode?: NodeId | undefined, label?: TraitLabel | undefined) => Constraint;
    delete: (stableRange: StableRange) => Change;
    insertTree: (nodes: BuildNode | TreeNodeSequence<BuildNode>, destination: StablePlace) => Change[];
    move: (source: StableRange, destination: StablePlace) => Change[];
};

// @public
export type ChangeInternal = InsertInternal | DetachInternal | BuildInternal | SetValueInternal | ConstraintInternal;

// @public (undocumented)
export const ChangeInternal: {
    build: (source: TreeNodeSequence<BuildNodeInternal>, destination: DetachedSequenceId) => BuildInternal;
    insert: (source: DetachedSequenceId, destination: StablePlaceInternal) => InsertInternal;
    detach: (source: StableRangeInternal, destination?: DetachedSequenceId | undefined) => DetachInternal;
    setPayload: (nodeToModify: NodeData<NodeId> | NodeId, payload: Payload) => SetValueInternal;
    clearPayload: (nodeToModify: NodeData<NodeId> | NodeId) => SetValueInternal;
    constraint: (toConstrain: StableRangeInternal, effect: ConstraintEffect, identityHash?: UuidString | undefined, length?: number | undefined, contentHash?: UuidString | undefined, parentNode?: NodeId | undefined, label?: TraitLabel | undefined) => ConstraintInternal;
    delete: (stableRange: StableRangeInternal) => ChangeInternal;
    insertTree: (nodes: TreeNodeSequence<BuildNodeInternal>, destination: StablePlaceInternal) => ChangeInternal[];
    move: (source: StableRangeInternal, destination: StablePlaceInternal) => ChangeInternal[];
};

// @public
export type ChangeNode = TreeNode<ChangeNode, NodeId>;

// @public
export type ChangeNode_0_0_2 = TreeNode<ChangeNode_0_0_2, StableNodeId>;

// @public
export type ChangeResult = Result<TransactionView, TransactionFailure>;

// @public
export enum ChangeType {
    // (undocumented)
    Build = 2,
    // (undocumented)
    Constraint = 4,
    // (undocumented)
    Detach = 1,
    // (undocumented)
    Insert = 0,
    // (undocumented)
    SetValue = 3
}

// @public
export enum ChangeTypeInternal {
    // (undocumented)
    Build = 2,
    // (undocumented)
    CompressedBuild = 5,
    // (undocumented)
    Constraint = 4,
    // (undocumented)
    Detach = 1,
    // (undocumented)
    Insert = 0,
    // (undocumented)
    SetValue = 3
}

// @public
export abstract class Checkout extends EventEmitterWithErrorHandling<ICheckoutEvents> implements IDisposable {
    protected constructor(tree: SharedTree, currentView: RevisionView, onEditCommitted: EditCommittedHandler);
    abortEdit(): void;
    applyChanges(changes: readonly Change[]): void;
    // (undocumented)
    applyChanges(...changes: readonly Change[]): void;
    applyEdit(changes: readonly Change[]): EditId;
    // (undocumented)
    applyEdit(...changes: readonly Change[]): EditId;
    closeEdit(): EditId;
    // (undocumented)
    get currentView(): TreeView;
    dispose(error?: Error): void;
    // (undocumented)
    disposed: boolean;
    protected emitChange(): void;
    // (undocumented)
    getEditStatus(): EditStatus;
    protected handleNewEdit(id: EditId, result: ValidEditingResult): void;
    // @internal (undocumented)
    hasOpenEdit(): boolean;
    protected hintKnownEditingResult(edit: Edit<ChangeInternal>, result: ValidEditingResult): void;
    protected abstract get latestCommittedView(): RevisionView;
    openEdit(): void;
    rebaseCurrentEdit(): EditValidationResult.Valid | EditValidationResult.Invalid;
    revert(editId: EditId): void;
    readonly tree: SharedTree;
    protected tryApplyChangesInternal(changes: readonly ChangeInternal[]): EditStatus;
    // (undocumented)
    protected tryApplyChangesInternal(...changes: readonly ChangeInternal[]): EditStatus;
    tryApplyEdit(changes: readonly Change[]): EditId | undefined;
    // (undocumented)
    tryApplyEdit(...changes: readonly Change[]): EditId | undefined;
    // (undocumented)
    abstract waitForEditsToSubmit(): Promise<void>;
    // (undocumented)
    abstract waitForPendingUpdates(): Promise<void>;
}

// @public
export enum CheckoutEvent {
    ViewChange = "viewChange"
}

// @public (undocumented)
export function comparePayloads(a: Payload, b: Payload): boolean;

// @public
export type CompressedId = FinalCompressedId | LocalCompressedId;

// @public
export interface Constraint {
    readonly contentHash?: UuidString;
    readonly effect: ConstraintEffect;
    readonly identityHash?: UuidString;
    readonly label?: TraitLabel;
    readonly length?: number;
    readonly parentNode?: NodeId;
    readonly toConstrain: StableRange;
    readonly type: typeof ChangeType.Constraint;
}

// @public
export enum ConstraintEffect {
    InvalidAndDiscard = 0,
    InvalidRetry = 1,
    ValidRetry = 2
}

// @public
export interface ConstraintInternal extends Omit<ConstraintInternal_0_0_2, 'toConstrain' | 'parentNode'> {
    readonly parentNode?: NodeId;
    readonly toConstrain: StableRangeInternal;
}

// @public
export interface ConstraintInternal_0_0_2 {
    readonly contentHash?: UuidString;
    readonly effect: ConstraintEffect;
    readonly identityHash?: UuidString;
    readonly label?: TraitLabel;
    readonly length?: number;
    readonly parentNode?: StableNodeId;
    readonly toConstrain: StableRangeInternal_0_0_2;
    readonly type: typeof ChangeTypeInternal.Constraint;
}

// @public
export type Definition = UuidString & {
    readonly Definition: 'c0ef9488-2a78-482d-aeed-37fba996354c';
};

// @public
export interface Delta<NodeId> {
    readonly added: readonly NodeId[];
    readonly changed: readonly NodeId[];
    readonly removed: readonly NodeId[];
}

// @public
export interface Detach {
    // (undocumented)
    readonly destination?: number;
    // (undocumented)
    readonly source: StableRange;
    // (undocumented)
    readonly type: typeof ChangeType.Detach;
}

// @public
export type DetachedSequenceId = number & {
    readonly DetachedSequenceId: 'f7d7903a-194e-45e7-8e82-c9ef4333577d';
};

// @public
export interface DetachInternal extends Omit<DetachInternal_0_0_2, 'source'> {
    // (undocumented)
    readonly source: StableRangeInternal;
}

// @public
export interface DetachInternal_0_0_2 {
    // (undocumented)
    readonly destination?: DetachedSequenceId;
    // (undocumented)
    readonly source: StableRangeInternal_0_0_2;
    // (undocumented)
    readonly type: typeof ChangeTypeInternal.Detach;
}

// @public @sealed
export class EagerCheckout extends Checkout {
    constructor(tree: SharedTree);
    // (undocumented)
    protected get latestCommittedView(): RevisionView;
    // (undocumented)
    waitForEditsToSubmit(): Promise<void>;
    // (undocumented)
    waitForPendingUpdates(): Promise<void>;
}

// @public
export interface Edit<TChange> extends EditBase<TChange> {
    readonly id: EditId;
}

// @public
export type EditApplicationOutcome = {
    readonly view: RevisionView;
    readonly status: EditStatus.Applied;
} | {
    readonly failure: TransactionInternal.Failure;
    readonly status: EditStatus.Invalid | EditStatus.Malformed;
};

// @public
export interface EditBase<TChange> {
    readonly changes: readonly TChange[];
    readonly pastAttemptCount?: number;
}

// @public
export interface EditCommittedEventArguments {
    readonly editId: EditId;
    readonly local: boolean;
    readonly tree: SharedTree;
}

// @public
export type EditCommittedHandler = (args: EditCommittedEventArguments) => void;

// @public
export interface EditHandle<TChange> {
    // (undocumented)
    readonly baseHandle: FluidEditHandle;
    // (undocumented)
    readonly get: () => Promise<EditWithoutId<TChange>[]>;
}

// @public
export type EditId = UuidString & {
    readonly EditId: '56897beb-53e4-4e66-85da-4bf5cd5d0d49';
};

// @public
export type EditingResult = FailedEditingResult | ValidEditingResult;

// @public
export interface EditingResultBase {
    readonly before: RevisionView;
    readonly changes: readonly ChangeInternal[];
    readonly status: EditStatus;
    readonly steps: readonly ReconciliationChange[];
}

// @public
export interface EditLogSummary<TChange, THandle> {
    readonly editChunks: readonly {
        readonly startRevision: number;
        readonly chunk: THandle | readonly EditWithoutId<TChange>[];
    }[];
    readonly editIds: readonly EditId[];
}

// @public
export enum EditStatus {
    Applied = 2,
    Invalid = 1,
    Malformed = 0
}

// @public
export enum EditValidationResult {
    Invalid = 1,
    Malformed = 0,
    Valid = 2
}

// @public
export interface EditWithoutId<TChange> extends EditBase<TChange> {
    readonly id?: never;
}

// @public
export interface FailedEditingResult extends EditingResultBase {
    readonly changes: readonly ChangeInternal[];
    readonly failure: TransactionInternal.Failure;
    readonly status: EditStatus.Invalid | EditStatus.Malformed;
    readonly steps: readonly ReconciliationChange[];
}

// @public
export interface FailingTransactionState extends TransactionFailure {
    readonly changes: readonly ChangeInternal[];
    readonly steps: readonly ReconciliationChange[];
    readonly view: TransactionView;
}

// @public
export type FinalCompressedId = number & {
    readonly FinalCompressedId: '5d83d1e2-98b7-4e4e-a889-54c855cfa73d';
    readonly OpNormalized: '9209432d-a959-4df7-b2ad-767ead4dbcae';
};

// @public
export interface FluidEditHandle {
    // (undocumented)
    readonly absolutePath: string;
    // (undocumented)
    readonly get: () => Promise<ArrayBuffer>;
}

// @public
export class Forest {
    add(nodes: Iterable<ForestNode>): Forest;
    assertConsistent(): void;
    attachRangeOfChildren(parentId: NodeId, label: TraitLabel, index: number, childIds: readonly NodeId[]): Forest;
    static create(expensiveValidation?: boolean): Forest;
    delete(ids: Iterable<NodeId>, deleteChildren: boolean): Forest;
    delta(forest: Forest): Delta<NodeId>;
    detachRangeOfChildren(parentId: NodeId, label: TraitLabel, startIndex: number, endIndex: number): {
        forest: Forest;
        detached: readonly NodeId[];
    };
    equals(forest: Forest): boolean;
    // (undocumented)
    get(id: NodeId): ForestNode;
    // (undocumented)
    getParent(id: NodeId): ParentData;
    // (undocumented)
    has(id: NodeId): boolean;
    setValue(nodeId: NodeId, value: Payload | null): Forest;
    get size(): number;
    // (undocumented)
    tryGet(id: NodeId): ForestNode | undefined;
    // (undocumented)
    tryGetParent(id: NodeId): ParentData | undefined;
}

// @public
export interface ForestNode extends NodeData<NodeId> {
    // (undocumented)
    readonly traits: ReadonlyMap<TraitLabel, readonly NodeId[]>;
}

// @public
export class GenericTransaction {
    constructor(view: RevisionView, policy: GenericTransactionPolicy);
    applyChange(change: ChangeInternal, path?: ReconciliationPath): this;
    applyChanges(changes: Iterable<ChangeInternal>, path?: ReconciliationPath): this;
    // (undocumented)
    protected readonly before: RevisionView;
    get changes(): readonly ChangeInternal[];
    // (undocumented)
    close(): EditingResult;
    get isOpen(): boolean;
    get status(): EditStatus;
    get steps(): readonly ReconciliationChange[];
    get view(): TransactionView;
}

// @public
export interface GenericTransactionPolicy {
    dispatchChange(state: SucceedingTransactionState, change: ChangeInternal): ChangeResult;
    tryResolveChange(state: SucceedingTransactionState, change: ChangeInternal, path: ReconciliationPath): Result<ChangeInternal, TransactionFailure>;
    validateOnClose(state: SucceedingTransactionState): ChangeResult;
}

// @public
function getSerializedUploadedEditChunkContents(sharedTree: SharedTree): Promise<string>;
export { getSerializedUploadedEditChunkContents }
export { getSerializedUploadedEditChunkContents as getUploadedEditChunkContents }

// @public
export function getTraitLocationOfRange(view: TreeView, range: StableRange): TraitLocation;

// @public
export interface HasTraits<TChild> {
    // (undocumented)
    readonly traits: TraitMap<TChild>;
}

// @public
export interface HasVariadicTraits<TChild> {
    // (undocumented)
    readonly traits?: {
        readonly [key: string]: TChild | TreeNodeSequence<TChild> | undefined;
    };
}

// @public
export interface ICheckoutEvents extends IErrorEvent {
    // (undocumented)
    (event: 'viewChange', listener: (before: TreeView, after: TreeView) => void): any;
}

// @public
export const initialTree: ChangeNode_0_0_2;

// @public
export interface Insert {
    // (undocumented)
    readonly destination: StablePlace;
    // (undocumented)
    readonly source: number;
    // (undocumented)
    readonly type: typeof ChangeType.Insert;
}

// @public
export interface InsertInternal extends Omit<InsertInternal_0_0_2, 'destination'> {
    // (undocumented)
    readonly destination: StablePlaceInternal;
}

// @public
export interface InsertInternal_0_0_2 {
    // (undocumented)
    readonly destination: StablePlaceInternal_0_0_2;
    // (undocumented)
    readonly source: DetachedSequenceId;
    // (undocumented)
    readonly type: typeof ChangeTypeInternal.Insert;
}

// @public
export interface InternalizedChange {
    // (undocumented)
    InternalChangeBrand: '2cae1045-61cf-4ef7-a6a3-8ad920cb7ab3';
}

// @public
export type InternedStringId = number & {
    readonly InternedStringId: 'e221abc9-9d17-4493-8db0-70c871a1c27c';
};

// Warning: (ae-internal-missing-underscore) The name "isDetachedSequenceId" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function isDetachedSequenceId(node: DetachedSequenceId | object): node is DetachedSequenceId;

// @public
export interface ISharedTreeEvents extends ISharedObjectEvents {
    // (undocumented)
    (event: 'committedEdit', listener: EditCommittedHandler): any;
    // (undocumented)
    (event: 'appliedSequencedEdit', listener: SequencedEditAppliedHandler): any;
}

// @public
export function isSharedTreeEvent(event: ITelemetryBaseEvent): boolean;

// @public @sealed
export class LazyCheckout extends Checkout {
    constructor(tree: SharedTree);
    // (undocumented)
    protected handleNewEdit(id: EditId, result: ValidEditingResult): void;
    // (undocumented)
    protected get latestCommittedView(): RevisionView;
    // (undocumented)
    waitForEditsToSubmit(): Promise<void>;
    // (undocumented)
    waitForPendingUpdates(): Promise<void>;
}

// @public
export type LocalCompressedId = number & {
    readonly LocalCompressedId: '6fccb42f-e2a4-4243-bd29-f13d12b9c6d1';
} & SessionUnique;

// @public
export interface LogViewer {
    getRevisionView(revision: Revision): Promise<RevisionView>;
    getRevisionViewInSession(revision: Revision): RevisionView;
}

// @public
export interface MergeHealthStats {
    badPlaceCount: number;
    badRangeCount: number;
    constraintViolationCount: number;
    deletedAncestorBadPlaceCount: number;
    deletedAncestorBadRangeCount: number;
    deletedSiblingBadPlaceCount: number;
    deletedSiblingBadRangeCount: number;
    editCount: number;
    failedEditCount: number;
    idAlreadyInUseCount: number;
    labelConstraintViolationCount: number;
    lengthConstraintViolationCount: number;
    malformedEditCount: number;
    maxAttemptCount: number;
    parentConstraintViolationCount: number;
    pathLengths: number[];
    rangeConstraintViolationCount: number;
    unknownIdCount: number;
    updatedRangeBadPlaceCount: number;
    updatedRangeHasPlacesInDifferentTraitsCount: number;
    updatedRangeInvertedCount: number;
    updatedRangeNeverValidPlaceCount: number;
}

// @public
export interface NodeData<TId> {
    readonly definition: Definition;
    readonly identifier: TId;
    readonly payload?: Payload;
}

// @public
export type NodeId = number & SessionSpaceCompressedId & NodeIdBrand;

// @public (undocumented)
export interface NodeIdBrand {
    // (undocumented)
    readonly NodeId: 'e53e7d6b-c8b9-431a-8805-4843fc639342';
}

// @public
export interface NodeIdContext extends NodeIdGenerator, NodeIdConverter {
}

// @public
export interface NodeIdConverter {
    convertToNodeId(id: StableNodeId): NodeId;
    convertToStableNodeId(id: NodeId): StableNodeId;
    tryConvertToNodeId(id: StableNodeId): NodeId | undefined;
    tryConvertToStableNodeId(id: NodeId): StableNodeId | undefined;
}

// @public
export interface NodeIdGenerator {
    generateNodeId(override?: string): NodeId;
}

// @public
export interface NodeInTrait {
    // (undocumented)
    readonly index: TraitNodeIndex;
    // (undocumented)
    readonly trait: TraitLocation;
}

// @public @sealed
export interface OrderedEditSet<TChange = unknown> {
    readonly editIds: readonly EditId[];
    // (undocumented)
    getEditAtIndex(index: number): Promise<Edit<TChange>>;
    // (undocumented)
    getEditInSessionAtIndex(index: number): Edit<TChange>;
    // (undocumented)
    getIdAtIndex(index: number): EditId;
    // (undocumented)
    getIndexOfId(editId: EditId): number;
    readonly length: number;
    // (undocumented)
    tryGetEdit(editId: EditId): Promise<Edit<TChange> | undefined>;
    // (undocumented)
    tryGetIndexOfId(editId: EditId): number | undefined;
}

// @public
export interface ParentData {
    // (undocumented)
    readonly parentId: NodeId;
    // (undocumented)
    readonly traitParent: TraitLabel;
}

// @public
export type Payload = Serializable;

// @public
export function placeFromStablePlace(view: TreeView, stablePlace: StablePlace): TreeViewPlace;

// @public
export type PlaceholderTree<TPlaceholder = never> = TreeNode<PlaceholderTree<TPlaceholder>, NodeId> | TPlaceholder;

// @public
export type PlaceIndex = number & {
    readonly PlaceIndex: unique symbol;
};

// @public
export enum PlaceValidationResult {
    // (undocumented)
    Malformed = "Malformed",
    // (undocumented)
    MissingParent = "MissingParent",
    // (undocumented)
    MissingSibling = "MissingSibling",
    // (undocumented)
    SiblingIsRootOrDetached = "SiblingIsRootOrDetached",
    // (undocumented)
    Valid = "Valid"
}

// @public
export function rangeFromStableRange(view: TreeView, range: StableRange): TreeViewRange;

// @public
export type RangeValidationResult = RangeValidationResultKind.Valid | RangeValidationResultKind.PlacesInDifferentTraits | RangeValidationResultKind.Inverted | {
    kind: RangeValidationResultKind.BadPlace;
    place: StablePlaceInternal;
    placeFailure: BadPlaceValidationResult;
};

// @public
export enum RangeValidationResultKind {
    // (undocumented)
    BadPlace = "BadPlace",
    // (undocumented)
    Inverted = "Inverted",
    // (undocumented)
    PlacesInDifferentTraits = "PlacesInDifferentTraits",
    // (undocumented)
    Valid = "Valid"
}

// @public
export interface ReconciliationChange {
    readonly after: TransactionView;
    readonly resolvedChange: ChangeInternal;
}

// @public
export interface ReconciliationEdit {
    readonly [index: number]: ReconciliationChange;
    readonly after: TreeView;
    readonly before: TreeView;
    readonly length: number;
}

// @public
export interface ReconciliationPath {
    readonly [index: number]: ReconciliationEdit;
    readonly length: number;
}

// @public
export type Result<TOk, TError> = Result.Ok<TOk> | Result.Error<TError>;

// @public (undocumented)
export namespace Result {
    export interface Error<TError> {
        // (undocumented)
        readonly error: TError;
        // (undocumented)
        readonly type: ResultType.Error;
    }
    export function error<TError>(error: TError): Error<TError>;
    export function isError<TOk, TError>(result: Result<TOk, TError>): result is Error<TError>;
    export function isOk<TOk, TError>(result: Result<TOk, TError>): result is Ok<TOk>;
    export function mapError<TOk, TErrorIn, TErrorOut>(result: Result<TOk, TErrorIn>, map: (error: TErrorIn) => TErrorOut): Result<TOk, TErrorOut>;
    export function mapOk<TOkIn, TOkOut, TError>(result: Result<TOkIn, TError>, map: (ok: TOkIn) => TOkOut): Result<TOkOut, TError>;
    export interface Ok<TOk> {
        // (undocumented)
        readonly result: TOk;
        // (undocumented)
        readonly type: ResultType.Ok;
    }
    export function ok<TOk>(result: TOk): Ok<TOk>;
    export enum ResultType {
        Error = 1,
        Ok = 0
    }
}

// @public
export type Revision = number;

// @public
export class RevisionView extends TreeView {
    // (undocumented)
    equals(view: TreeView): boolean;
    static fromTree<T extends TreeNode<T, NodeId>>(root: T, expensiveValidation?: boolean): RevisionView;
    static fromTree<T extends TreeNode<T, StableNodeId>>(root: T, idConverter: NodeIdConverter, expensiveValidation?: boolean): RevisionView;
    openForTransaction(): TransactionView;
}

// @public
export interface SequencedEditAppliedEventArguments {
    readonly edit: Edit<ChangeInternal>;
    readonly logger: ITelemetryLogger;
    readonly outcome: EditApplicationOutcome;
    readonly reconciliationPath: ReconciliationPath;
    readonly tree: SharedTree;
    readonly wasLocal: boolean;
}

// @public
export type SequencedEditAppliedHandler = (args: SequencedEditAppliedEventArguments) => void;

// @public
export type SessionSpaceCompressedId = CompressedId & SessionUnique;

// @public
export interface SessionUnique {
    // (undocumented)
    readonly SessionUnique: 'cea55054-6b82-4cbf-ad19-1fa645ea3b3e';
}

// @public
export function setTrait(trait: TraitLocation, nodes: BuildNode | TreeNodeSequence<BuildNode>): Change[];

// @public
export interface SetValue {
    // (undocumented)
    readonly nodeToModify: NodeId;
    readonly payload: Payload | null;
    // (undocumented)
    readonly type: typeof ChangeType.SetValue;
}

// @public
export interface SetValueInternal extends Omit<SetValueInternal_0_0_2, 'nodeToModify'> {
    // (undocumented)
    readonly nodeToModify: NodeId;
}

// @public
export interface SetValueInternal_0_0_2 {
    // (undocumented)
    readonly nodeToModify: StableNodeId;
    readonly payload: Payload | null;
    // (undocumented)
    readonly type: typeof ChangeTypeInternal.SetValue;
}

// @public
export class SharedTree extends SharedObject<ISharedTreeEvents> implements NodeIdContext {
    constructor(runtime: IFluidDataStoreRuntime, id: string, ...args: SharedTreeArgs<WriteFormat.v0_0_2>);
    constructor(runtime: IFluidDataStoreRuntime, id: string, ...args: SharedTreeArgs<WriteFormat.v0_1_1>);
    applyEdit(...changes: readonly Change[]): Edit<InternalizedChange>;
    // (undocumented)
    applyEdit(changes: readonly Change[]): Edit<InternalizedChange>;
    // @internal
    applyEditInternal(editOrChanges: Edit<ChangeInternal> | readonly ChangeInternal[]): Edit<ChangeInternal>;
    protected applyStashedOp(op: unknown): StashedLocalOpMetadata;
    attributeNodeId(id: NodeId): AttributionId;
    get attributionId(): AttributionId;
    convertToNodeId(id: StableNodeId): NodeId;
    convertToStableNodeId(id: NodeId): StableNodeId;
    static create(runtime: IFluidDataStoreRuntime, id?: string): SharedTree;
    // (undocumented)
    get currentView(): RevisionView;
    // (undocumented)
    get edits(): OrderedEditSet<InternalizedChange>;
    // @internal
    equals(sharedTree: SharedTree): boolean;
    generateNodeId(override?: string): NodeId;
    static getFactory(...args: SharedTreeArgs<WriteFormat.v0_0_2>): SharedTreeFactory;
    // (undocumented)
    static getFactory(...args: SharedTreeArgs<WriteFormat.v0_1_1>): SharedTreeFactory;
    // (undocumented)
    getRuntime(): IFluidDataStoreRuntime;
    getWriteFormat(): WriteFormat;
    // @internal
    internalizeChange(change: Change): ChangeInternal;
    // (undocumented)
    protected loadCore(storage: IChannelStorageService): Promise<void>;
    // @internal
    loadSerializedSummary(blobData: string): ITelemetryProperties;
    // @internal
    loadSummary(summary: SharedTreeSummaryBase): void;
    readonly logger: ITelemetryLogger;
    get logViewer(): LogViewer;
    mergeEditsFrom(other: SharedTree, edits: Iterable<Edit<InternalizedChange>>, stableIdRemapper?: (id: StableNodeId) => StableNodeId): EditId[];
    // (undocumented)
    protected onDisconnect(): void;
    // (undocumented)
    protected processCore(message: unknown, local: boolean): void;
    // (undocumented)
    protected registerCore(): void;
    // (undocumented)
    protected reSubmitCore(op: unknown, localOpMetadata?: StashedLocalOpMetadata): void;
    revert(editId: EditId): EditId | undefined;
    // @internal
    revertChanges(changes: readonly InternalizedChange[], before: RevisionView): ChangeInternal[] | undefined;
    // @internal
    saveSerializedSummary(options?: {
        serializer?: IFluidSerializer;
    }): string;
    // @internal
    saveSummary(): SharedTreeSummaryBase;
    // (undocumented)
    summarizeCore(serializer: IFluidSerializer): ISummaryTreeWithStats;
    tryConvertToNodeId(id: StableNodeId): NodeId | undefined;
    tryConvertToStableNodeId(id: NodeId): StableNodeId | undefined;
}

// @public
export type SharedTreeArgs<WF extends WriteFormat = WriteFormat> = [writeFormat: WF, options?: SharedTreeOptions<WF>];

// @public
export const sharedTreeAssertionErrorType = "SharedTreeAssertion";

// @public
export enum SharedTreeDiagnosticEvent {
    AppliedEdit = "appliedEdit",
    CatchUpBlobUploaded = "uploadedCatchUpBlob",
    DroppedInvalidEdit = "droppedInvalidEdit",
    DroppedMalformedEdit = "droppedMalformedEdit",
    EditChunkUploaded = "uploadedEditChunk",
    UnexpectedHistoryChunk = "unexpectedHistoryChunk",
    WriteVersionChanged = "writeVersionChanged"
}

// @public
export enum SharedTreeEvent {
    EditCommitted = "committedEdit",
    SequencedEditApplied = "sequencedEditApplied"
}

// @public
export class SharedTreeFactory implements IChannelFactory {
    constructor(...args: SharedTreeArgs<WriteFormat.v0_0_2>);
    constructor(...args: SharedTreeArgs<WriteFormat.v0_1_1>);
    // (undocumented)
    static Attributes: IChannelAttributes;
    // (undocumented)
    get attributes(): IChannelAttributes;
    create(runtime: IFluidDataStoreRuntime, id: string): SharedTree;
    // (undocumented)
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, _channelAttributes: Readonly<IChannelAttributes>): Promise<IChannel>;
    // (undocumented)
    static Type: string;
    // (undocumented)
    get type(): string;
}

// @public
export class SharedTreeMergeHealthTelemetryHeartbeat {
    attachTree(tree: SharedTree): void;
    clearData(): void;
    detachAllTrees(): void;
    detachTree(tree: SharedTree): void;
    flushHeartbeat(): void;
    getStats(tree: SharedTree): MergeHealthStats;
    resetTreeData(tree: SharedTree): void;
    startHeartbeat(interval?: number): void;
    stopHeartbeat(): void;
}

// @public
export type SharedTreeOptions<WF extends WriteFormat, HistoryCompatibility extends 'Forwards' | 'None' = 'Forwards'> = Omit<WF extends WriteFormat.v0_0_2 ? SharedTreeOptions_0_0_2 : WF extends WriteFormat.v0_1_1 ? SharedTreeOptions_0_1_1 : never, HistoryCompatibility extends 'Forwards' ? 'summarizeHistory' : never>;

// @public
export interface SharedTreeOptions_0_0_2 {
    summarizeHistory?: boolean;
}

// @public
export interface SharedTreeOptions_0_1_1 {
    attributionId?: AttributionId;
    summarizeHistory?: false | {
        uploadEditChunks: boolean;
    };
}

// @public
export interface SharedTreeSummaryBase {
    readonly version: WriteFormat;
}

// @public
export enum Side {
    // (undocumented)
    After = 1,
    // (undocumented)
    Before = 0
}

// @public
export type StableNodeId = string & {
    readonly StableNodeId: 'a0843b38-699d-4bb2-aa7a-16c502a71151';
};

// @public
export interface StablePlace {
    readonly referenceSibling?: NodeId;
    readonly referenceTrait?: TraitLocation;
    readonly side: Side;
}

// @public (undocumented)
export const StablePlace: {
    before: (node: NodeData<NodeId> | NodeId) => StablePlace;
    after: (node: NodeData<NodeId> | NodeId) => StablePlace;
    atStartOf: (trait: TraitLocation) => StablePlace;
    atEndOf: (trait: TraitLocation) => StablePlace;
};

// @public
export interface StablePlaceInternal extends Omit<StablePlaceInternal_0_0_2, 'referenceSibling' | 'referenceTrait'> {
    readonly referenceSibling?: NodeId;
    readonly referenceTrait?: TraitLocationInternal;
}

// @public (undocumented)
export const StablePlaceInternal: {
    before: (node: NodeData<NodeId> | NodeId) => StablePlaceInternal;
    after: (node: NodeData<NodeId> | NodeId) => StablePlaceInternal;
    atStartOf: (trait: TraitLocationInternal) => StablePlaceInternal;
    atEndOf: (trait: TraitLocationInternal) => StablePlaceInternal;
};

// @public
export interface StablePlaceInternal_0_0_2 {
    readonly referenceSibling?: StableNodeId;
    readonly referenceTrait?: TraitLocationInternal_0_0_2;
    readonly side: Side;
}

// @public
export interface StableRange {
    // (undocumented)
    readonly end: StablePlace;
    // (undocumented)
    readonly start: StablePlace;
}

// @public (undocumented)
export const StableRange: {
    from: (start: StablePlace) => {
        to: (end: StablePlace) => StableRange;
    };
    only: (node: NodeData<NodeId> | NodeId) => StableRange;
    all: (trait: TraitLocation) => StableRange;
};

// @public
export interface StableRangeInternal {
    // (undocumented)
    readonly end: StablePlaceInternal;
    // (undocumented)
    readonly start: StablePlaceInternal;
}

// @public (undocumented)
export const StableRangeInternal: {
    from: (start: StablePlaceInternal) => {
        to: (end: StablePlaceInternal) => StableRangeInternal;
    };
    only: (node: NodeData<NodeId> | NodeId) => StableRangeInternal;
    all: (trait: TraitLocationInternal) => StableRangeInternal;
};

// @public
export interface StableRangeInternal_0_0_2 {
    // (undocumented)
    readonly end: StablePlaceInternal_0_0_2;
    // (undocumented)
    readonly start: StablePlaceInternal_0_0_2;
}

// @public
export interface StashedLocalOpMetadata {
    transformedEdit?: Edit<ChangeInternal>;
}

// @public
export interface StringInterner {
    // (undocumented)
    getInternedId(input: string): InternedStringId | undefined;
    // (undocumented)
    getSerializable(): readonly string[];
    // (undocumented)
    getString(internedId: number): string;
}

// @public
export interface SucceedingTransactionState {
    readonly changes: readonly ChangeInternal[];
    readonly status: EditStatus.Applied;
    readonly steps: readonly ReconciliationChange[];
    readonly view: TransactionView;
}

// @public
export type TraitLabel = UuidString & {
    readonly TraitLabel: '613826ed-49cc-4df3-b2b8-bfc6866af8e3';
};

// @public
export interface TraitLocation {
    // (undocumented)
    readonly label: TraitLabel;
    // (undocumented)
    readonly parent: NodeId;
}

// @public
export interface TraitLocationInternal extends Omit<TraitLocationInternal_0_0_2, 'parent'> {
    // (undocumented)
    readonly parent: NodeId;
}

// @public
export interface TraitLocationInternal_0_0_2 {
    // (undocumented)
    readonly label: TraitLabel;
    // (undocumented)
    readonly parent: StableNodeId;
}

// @public
export interface TraitMap<TChild> {
    // (undocumented)
    readonly [key: string]: TreeNodeSequence<TChild>;
}

// @public
export type TraitNodeIndex = number & {
    readonly TraitNodeIndex: unique symbol;
};

// @public
export class Transaction extends TypedEventEmitter<TransactionEvents> {
    constructor(tree: SharedTree);
    apply(...changes: readonly Change[]): EditStatus;
    // (undocumented)
    apply(changes: readonly Change[]): EditStatus;
    closeAndCommit(): void;
    get currentView(): TreeView;
    get isOpen(): boolean;
    readonly startingView: TreeView;
    get status(): EditStatus;
    // (undocumented)
    readonly tree: SharedTree;
}

// @public
export enum TransactionEvent {
    ViewChange = "viewChange"
}

// @public
export interface TransactionEvents extends IErrorEvent {
    // (undocumented)
    (event: TransactionEvent.ViewChange, listener: (before: TreeView, after: TreeView) => void): any;
}

// @public
export interface TransactionFailure {
    readonly failure: TransactionInternal.Failure;
    readonly status: EditStatus.Invalid | EditStatus.Malformed;
}

// @public
export namespace TransactionInternal {
    export interface BadPlaceFailure {
        readonly change: ChangeInternal;
        readonly kind: FailureKind.BadPlace;
        readonly place: StablePlaceInternal;
        readonly placeFailure: BadPlaceValidationResult;
    }
    export interface BadRangeFailure {
        readonly change: ChangeInternal;
        readonly kind: FailureKind.BadRange;
        readonly range: StableRangeInternal;
        readonly rangeFailure: BadRangeValidationResult;
    }
    export interface ConstraintViolationFailure {
        readonly constraint: ConstraintInternal;
        readonly kind: FailureKind.ConstraintViolation;
        readonly violation: ConstraintViolationResult;
    }
    export enum ConstraintViolationKind {
        BadLabel = "BadLabel",
        BadLength = "BadLength",
        BadParent = "BadParent",
        BadRange = "BadRange"
    }
    export type ConstraintViolationResult = {
        readonly kind: ConstraintViolationKind.BadRange;
        readonly rangeFailure: BadRangeValidationResult;
    } | {
        readonly kind: ConstraintViolationKind.BadLength;
        readonly actual: number;
    } | {
        readonly kind: ConstraintViolationKind.BadParent;
        readonly actual: NodeId;
    } | {
        readonly kind: ConstraintViolationKind.BadLabel;
        readonly actual: TraitLabel;
    };
    export interface DetachedSequenceIdAlreadyInUseFailure {
        readonly change: ChangeInternal;
        readonly kind: FailureKind.DetachedSequenceIdAlreadyInUse;
        readonly sequenceId: DetachedSequenceId;
    }
    export interface DetachedSequenceNotFoundFailure {
        readonly change: ChangeInternal;
        readonly kind: FailureKind.DetachedSequenceNotFound;
        readonly sequenceId: DetachedSequenceId;
    }
    export interface DuplicateIdInBuildFailure {
        readonly change: ChangeInternal;
        readonly id: NodeId;
        readonly kind: FailureKind.DuplicateIdInBuild;
    }
    export function factory(view: RevisionView): GenericTransaction;
    export type Failure = UnusedDetachedSequenceFailure | DetachedSequenceIdAlreadyInUseFailure | DetachedSequenceNotFoundFailure | DuplicateIdInBuildFailure | IdAlreadyInUseFailure | UnknownIdFailure | BadPlaceFailure | BadRangeFailure | ConstraintViolationFailure;
    export enum FailureKind {
        BadPlace = "BadPlace",
        BadRange = "BadRange",
        ConstraintViolation = "ConstraintViolation",
        DetachedSequenceIdAlreadyInUse = "DetachedSequenceIdAlreadyInUse",
        DetachedSequenceNotFound = "DetachedSequenceNotFound",
        DuplicateIdInBuild = "DuplicateIdInBuild",
        IdAlreadyInUse = "IdAlreadyInUse",
        UnknownId = "UnknownId",
        UnusedDetachedSequence = "UnusedDetachedSequence"
    }
    export interface IdAlreadyInUseFailure {
        readonly change: ChangeInternal;
        readonly id: NodeId;
        readonly kind: FailureKind.IdAlreadyInUse;
    }
    export class Policy implements GenericTransactionPolicy {
        protected createViewNodesForTree(sequence: Iterable<BuildNodeInternal>, onCreateNode: (stableId: NodeId, node: TreeViewNode) => boolean, onInvalidDetachedId: (sequenceId: DetachedSequenceId) => void): NodeId[] | undefined;
        protected readonly detached: Map<DetachedSequenceId, readonly NodeId[]>;
        dispatchChange(state: ValidState, change: ChangeInternal): ChangeResult;
        tryResolveChange(state: ValidState, change: ChangeInternal): Result.Ok<ChangeInternal>;
        validateOnClose(state: ValidState): ChangeResult;
    }
    export interface UnknownIdFailure {
        readonly change: ChangeInternal;
        readonly id: NodeId;
        readonly kind: FailureKind.UnknownId;
    }
    export interface UnusedDetachedSequenceFailure {
        readonly kind: FailureKind.UnusedDetachedSequence;
        readonly sequenceId: DetachedSequenceId;
    }
    // (undocumented)
    export type ValidState = SucceedingTransactionState;
        {};
}

// @public
export type TransactionState = SucceedingTransactionState | FailingTransactionState;

// @public
export class TransactionView extends TreeView {
    addNodes(sequence: Iterable<TreeViewNode>): TransactionView;
    attachRange(nodesToAttach: readonly NodeId[], place: TreeViewPlace): TransactionView;
    close(): RevisionView;
    deleteNodes(nodes: Iterable<NodeId>): TransactionView;
    detachRange(rangeToDetach: TreeViewRange): {
        view: TransactionView;
        detached: readonly NodeId[];
    };
    // (undocumented)
    equals(view: TreeView): boolean;
    setNodeValue(nodeId: NodeId, value: Payload): TransactionView;
}

// @public
export interface TreeNode<TChild, TId> extends NodeData<TId>, HasTraits<TChild> {
}

// @public
export class TreeNodeHandle implements TreeNode<TreeNodeHandle, NodeId> {
    constructor(view: TreeView, nodeId: NodeId);
    // (undocumented)
    get definition(): Definition;
    // (undocumented)
    get identifier(): NodeId;
    get node(): TreeViewNode;
    // (undocumented)
    get payload(): Payload | undefined;
    // (undocumented)
    get traits(): TraitMap<TreeNodeHandle>;
}

// @public
export type TreeNodeSequence<TChild> = readonly TChild[];

// @public
export abstract class TreeView {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<TreeViewNode>;
    protected constructor(root: NodeId, forest: Forest);
    assertConsistent(): void;
    delta(view: TreeView): Delta<NodeId>;
    // (undocumented)
    abstract equals(view: TreeView): boolean;
    // (undocumented)
    findIndexWithinTrait(place: TreeViewPlace): PlaceIndex;
    // (undocumented)
    protected readonly forest: Forest;
    // (undocumented)
    getIndexInTrait(id: NodeId): TraitNodeIndex;
    // (undocumented)
    getParentViewNode(id: NodeId): TreeViewNode;
    // (undocumented)
    getTrait(traitLocation: TraitLocation): readonly NodeId[];
    // (undocumented)
    getTraitLabel(id: NodeId): TraitLabel;
    // (undocumented)
    getTraitLocation(id: NodeId): TraitLocation;
    // (undocumented)
    getViewNode(id: NodeId): TreeViewNode;
    // (undocumented)
    hasEqualForest(view: TreeView, strict?: boolean): boolean;
    // (undocumented)
    hasNode(id: NodeId): boolean;
    // (undocumented)
    readonly root: NodeId;
    // (undocumented)
    get size(): number;
    // (undocumented)
    tryGetIndexInTrait(id: NodeId): TraitNodeIndex | undefined;
    // (undocumented)
    tryGetParentViewNode(id: NodeId): TreeViewNode | undefined;
    // (undocumented)
    tryGetTraitLabel(id: NodeId): TraitLabel | undefined;
    // (undocumented)
    tryGetTraitLocation(id: NodeId): TraitLocation | undefined;
    // (undocumented)
    tryGetViewNode(id: NodeId): TreeViewNode | undefined;
}

// @public
export interface TreeViewNode extends NodeData<NodeId> {
    readonly parentage?: TraitLocation;
    readonly traits: ReadonlyMap<TraitLabel, readonly NodeId[]>;
}

// @public
export interface TreeViewPlace {
    // (undocumented)
    readonly sibling?: NodeId;
    // (undocumented)
    readonly side: Side;
    // (undocumented)
    readonly trait: TraitLocation;
}

// @public
export interface TreeViewRange {
    // (undocumented)
    readonly end: TreeViewPlace;
    // (undocumented)
    readonly start: TreeViewPlace;
}

// @public
export function useFailedSequencedEditTelemetry(tree: SharedTree): {
    disable: () => void;
};

// @public
export type UuidString = string & {
    readonly UuidString: '9d40d0ae-90d9-44b1-9482-9f55d59d5465';
};

// @public
export interface ValidEditingResult extends EditingResultBase {
    readonly after: RevisionView;
    readonly status: EditStatus.Applied;
}

// @public
export enum WriteFormat {
    v0_0_2 = "0.0.2",
    v0_1_1 = "0.1.1"
}

```
