## API Report File for "@fluidframework/telemetry-utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { EventEmitter } from 'events';
import { EventEmitterEventType } from '@fluidframework/common-utils';
import { extractLogSafeErrorProperties } from '@fluidframework/core-interfaces';
import { generateErrorWithStack } from '@fluidframework/core-interfaces';
import { generateStack } from '@fluidframework/core-interfaces';
import { getCircularReplacer } from '@fluidframework/core-interfaces';
import { hasErrorInstanceId } from '@fluidframework/core-interfaces';
import { IDisposable } from '@fluidframework/core-interfaces';
import { IEvent } from '@fluidframework/common-definitions';
import { IFluidErrorAnnotations } from '@fluidframework/core-interfaces';
import { IFluidErrorBase } from '@fluidframework/core-interfaces';
import { isExternalError } from '@fluidframework/core-interfaces';
import { isFluidError } from '@fluidframework/core-interfaces';
import { isILoggingError } from '@fluidframework/core-interfaces';
import { isTaggedTelemetryPropertyValue } from '@fluidframework/core-interfaces';
import { isValidLegacyError } from '@fluidframework/core-interfaces';
import { ITaggedTelemetryPropertyType } from '@fluidframework/core-interfaces';
import { ITaggedTelemetryPropertyTypeExt } from '@fluidframework/core-interfaces';
import { ITelemetryBaseEvent } from '@fluidframework/core-interfaces';
import { ITelemetryBaseLogger } from '@fluidframework/core-interfaces';
import { ITelemetryErrorEventExt } from '@fluidframework/core-interfaces';
import { ITelemetryGenericEvent } from '@fluidframework/core-interfaces';
import { ITelemetryGenericEventExt } from '@fluidframework/core-interfaces';
import { ITelemetryLoggerExt } from '@fluidframework/core-interfaces';
import { ITelemetryPerformanceEventExt } from '@fluidframework/core-interfaces';
import { ITelemetryProperties } from '@fluidframework/core-interfaces';
import { ITelemetryPropertiesExt } from '@fluidframework/core-interfaces';
import { Lazy } from '@fluidframework/core-utils';
import { LoggingError } from '@fluidframework/core-interfaces';
import { normalizeError } from '@fluidframework/core-interfaces';
import { TelemetryEventPropertyType } from '@fluidframework/core-interfaces';
import { TelemetryEventPropertyTypeExt } from '@fluidframework/core-interfaces';
import { TypedEventEmitter } from '@fluidframework/common-utils';
import { wrapError } from '@fluidframework/core-interfaces';
import { wrapErrorAndLog } from '@fluidframework/core-interfaces';

// @public (undocumented)
export type ConfigTypes = string | number | boolean | number[] | string[] | boolean[] | undefined;

// @public (undocumented)
export const connectedEventName = "connected";

// @public
export function createChildLogger(props?: {
    logger?: ITelemetryBaseLogger;
    namespace?: string;
    properties?: ITelemetryLoggerPropertyBags;
}): ITelemetryLoggerExt;

// @public (undocumented)
export function createChildMonitoringContext(props: Parameters<typeof createChildLogger>[0]): MonitoringContext;

// @public
export function createMultiSinkLogger(props: {
    namespace?: string;
    properties?: ITelemetryLoggerPropertyBags;
    loggers?: (ITelemetryBaseLogger | undefined)[];
    tryInheritProperties?: true;
}): ITelemetryLoggerExt;

// @public (undocumented)
export const disconnectedEventName = "disconnected";

// @public
export class EventEmitterWithErrorHandling<TEvent extends IEvent = IEvent> extends TypedEventEmitter<TEvent> {
    constructor(errorHandler: (eventName: EventEmitterEventType, error: any) => void);
    // (undocumented)
    emit(event: EventEmitterEventType, ...args: any[]): boolean;
}

// @public (undocumented)
export const eventNamespaceSeparator: ":";

export { extractLogSafeErrorProperties }

// @public (undocumented)
export function formatTick(tick: number): number;

export { generateErrorWithStack }

export { generateStack }

export { getCircularReplacer }

export { hasErrorInstanceId }

// @public
export interface IConfigProvider extends IConfigProviderBase {
    // (undocumented)
    getBoolean(name: string): boolean | undefined;
    // (undocumented)
    getBooleanArray(name: string): boolean[] | undefined;
    // (undocumented)
    getNumber(name: string): number | undefined;
    // (undocumented)
    getNumberArray(name: string): number[] | undefined;
    // (undocumented)
    getString(name: string): string | undefined;
    // (undocumented)
    getStringArray(name: string): string[] | undefined;
}

// @public
export interface IConfigProviderBase {
    // (undocumented)
    getRawConfig(name: string): ConfigTypes;
}

export { IFluidErrorAnnotations }

export { IFluidErrorBase }

// @public
export interface IPerformanceEventMarkers {
    // (undocumented)
    cancel?: "generic" | "error";
    // (undocumented)
    end?: true;
    // (undocumented)
    start?: true;
}

export { isExternalError }

export { isFluidError }

export { isILoggingError }

export { isTaggedTelemetryPropertyValue }

export { isValidLegacyError }

export { ITaggedTelemetryPropertyTypeExt }

export { ITelemetryErrorEventExt }

// @public
export interface ITelemetryEventExt extends ITelemetryPropertiesExt {
    // (undocumented)
    category: string;
    // (undocumented)
    eventName: string;
}

export { ITelemetryGenericEventExt }

export { ITelemetryLoggerExt }

// @public (undocumented)
export interface ITelemetryLoggerPropertyBag {
    // (undocumented)
    [index: string]: TelemetryEventPropertyTypes | (() => TelemetryEventPropertyTypes);
}

// @public (undocumented)
export interface ITelemetryLoggerPropertyBags {
    // (undocumented)
    all?: ITelemetryLoggerPropertyBag;
    // (undocumented)
    error?: ITelemetryLoggerPropertyBag;
}

export { ITelemetryPerformanceEventExt }

export { ITelemetryPropertiesExt }

// @public (undocumented)
export function loggerToMonitoringContext<L extends ITelemetryBaseLogger = ITelemetryLoggerExt>(logger: L): MonitoringContext<L>;

export { LoggingError }

// @public
export function logIfFalse(condition: any, logger: ITelemetryBaseLogger, event: string | ITelemetryGenericEvent): condition is true;

// @public (undocumented)
export function mixinMonitoringContext<L extends ITelemetryBaseLogger = ITelemetryLoggerExt>(logger: L, ...configs: (IConfigProviderBase | undefined)[]): MonitoringContext<L>;

// @public
export class MockLogger implements ITelemetryBaseLogger {
    assertMatch(expectedEvents: Omit<ITelemetryBaseEvent, "category">[], message?: string, inlineDetailsProp?: boolean): void;
    assertMatchAny(expectedEvents: Omit<ITelemetryBaseEvent, "category">[], message?: string, inlineDetailsProp?: boolean): void;
    assertMatchNone(disallowedEvents: Omit<ITelemetryBaseEvent, "category">[], message?: string, inlineDetailsProp?: boolean): void;
    assertMatchStrict(expectedEvents: Omit<ITelemetryBaseEvent, "category">[], message?: string, inlineDetailsProp?: boolean): void;
    // (undocumented)
    clear(): void;
    // (undocumented)
    events: ITelemetryBaseEvent[];
    matchAnyEvent(expectedEvents: Omit<ITelemetryBaseEvent, "category">[], inlineDetailsProp?: boolean): boolean;
    matchEvents(expectedEvents: Omit<ITelemetryBaseEvent, "category">[], inlineDetailsProp?: boolean): boolean;
    matchEventStrict(expectedEvents: Omit<ITelemetryBaseEvent, "category">[], inlineDetailsProp?: boolean): boolean;
    // (undocumented)
    send(event: ITelemetryBaseEvent): void;
    // (undocumented)
    toTelemetryLogger(): ITelemetryLoggerExt;
}

// @public
export interface MonitoringContext<L extends ITelemetryBaseLogger = ITelemetryLoggerExt> {
    // (undocumented)
    config: IConfigProvider;
    // (undocumented)
    logger: L;
}

export { normalizeError }

// @public
export function numberFromString(str: string | null | undefined): string | number | undefined;

// @public
export class PerformanceEvent {
    protected constructor(logger: ITelemetryLoggerExt, event: ITelemetryGenericEvent, markers?: IPerformanceEventMarkers, recordHeapSize?: boolean);
    // (undocumented)
    cancel(props?: ITelemetryProperties, error?: any): void;
    // (undocumented)
    get duration(): number;
    // (undocumented)
    end(props?: ITelemetryProperties): void;
    reportEvent(eventNameSuffix: string, props?: ITelemetryProperties, error?: any): void;
    // (undocumented)
    reportProgress(props?: ITelemetryProperties, eventNameSuffix?: string): void;
    // (undocumented)
    static start(logger: ITelemetryLoggerExt, event: ITelemetryGenericEvent, markers?: IPerformanceEventMarkers, recordHeapSize?: boolean): PerformanceEvent;
    // (undocumented)
    static timedExec<T>(logger: ITelemetryLoggerExt, event: ITelemetryGenericEvent, callback: (event: PerformanceEvent) => T, markers?: IPerformanceEventMarkers): T;
    // (undocumented)
    static timedExecAsync<T>(logger: ITelemetryLoggerExt, event: ITelemetryGenericEvent, callback: (event: PerformanceEvent) => Promise<T>, markers?: IPerformanceEventMarkers, recordHeapSize?: boolean): Promise<T>;
}

// @public
export function raiseConnectedEvent(logger: ITelemetryLoggerExt, emitter: EventEmitter, connected: boolean, clientId?: string, disconnectedReason?: string): void;

// @public (undocumented)
export function safeRaiseEvent(emitter: EventEmitter, logger: ITelemetryLoggerExt, event: string, ...args: any[]): void;

// @public
export class SampledTelemetryHelper implements IDisposable {
    constructor(eventBase: ITelemetryGenericEvent, logger: ITelemetryLoggerExt, sampleThreshold: number, includeAggregateMetrics?: boolean, perBucketProperties?: Map<string, ITelemetryProperties>);
    // (undocumented)
    dispose(error?: Error | undefined): void;
    // (undocumented)
    disposed: boolean;
    // (undocumented)
    measure<T>(codeToMeasure: () => T, bucket?: string): T;
}

// @public
export const sessionStorageConfigProvider: Lazy<IConfigProviderBase>;

// @public (undocumented)
export const tagCodeArtifacts: <T extends Record<string, TelemetryEventPropertyTypeExt>>(values: T) => { [P in keyof T]: {
        value: Exclude<T[P], undefined>;
        tag: TelemetryDataTag.CodeArtifact;
    } | (T[P] extends undefined ? undefined : never); };

// @public (undocumented)
export const tagData: <T extends TelemetryDataTag, V extends Record<string, TelemetryEventPropertyTypeExt>>(tag: T, values: V) => { [P in keyof V]: {
        value: Exclude<V[P], undefined>;
        tag: T;
    } | (V[P] extends undefined ? undefined : never); };

// @public @deprecated (undocumented)
export class TaggedLoggerAdapter implements ITelemetryBaseLogger {
    constructor(logger: ITelemetryBaseLogger);
    // (undocumented)
    send(eventWithTagsMaybe: ITelemetryBaseEvent): void;
}

// @public
export enum TelemetryDataTag {
    CodeArtifact = "CodeArtifact",
    UserData = "UserData"
}

export { TelemetryEventPropertyTypeExt }

// @public (undocumented)
export type TelemetryEventPropertyTypes = TelemetryEventPropertyType | ITaggedTelemetryPropertyType;

// @public
export class ThresholdCounter {
    constructor(threshold: number, logger: ITelemetryLoggerExt, thresholdMultiple?: number);
    send(eventName: string, value: number): void;
    sendIfMultiple(eventName: string, value: number): void;
}

export { wrapError }

export { wrapErrorAndLog }

// (No @packageDocumentation comment for this package)

```
