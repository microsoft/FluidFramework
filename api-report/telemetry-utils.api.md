## API Report File for "@fluidframework/telemetry-utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { EventEmitter } from 'events';
import { EventEmitterEventType } from '@fluidframework/common-utils';
import { IDebugger } from 'debug';
import { IEvent } from '@fluidframework/common-definitions';
import { ILoggingError } from '@fluidframework/common-definitions';
import { ITaggedTelemetryPropertyType } from '@fluidframework/common-definitions';
import { ITelemetryBaseEvent } from '@fluidframework/common-definitions';
import { ITelemetryBaseLogger } from '@fluidframework/common-definitions';
import { ITelemetryErrorEvent } from '@fluidframework/common-definitions';
import { ITelemetryGenericEvent } from '@fluidframework/common-definitions';
import { ITelemetryLogger } from '@fluidframework/common-definitions';
import { ITelemetryPerformanceEvent } from '@fluidframework/common-definitions';
import { ITelemetryProperties } from '@fluidframework/common-definitions';
import { TelemetryEventPropertyType } from '@fluidframework/common-definitions';
import { TypedEventEmitter } from '@fluidframework/common-utils';

// @public
export function annotateError(error: unknown, props: ITelemetryProperties): ILoggingError;

// @public
export class ChildLogger extends TelemetryLogger {
    // (undocumented)
    protected readonly baseLogger: ITelemetryBaseLogger;
    static create(baseLogger?: ITelemetryBaseLogger, namespace?: string, properties?: ITelemetryLoggerPropertyBags): TelemetryLogger;
    send(event: ITelemetryBaseEvent): void;
}

// @public (undocumented)
export const connectedEventName = "connected";

// @public
export class DebugLogger extends TelemetryLogger {
    constructor(debug: IDebugger, debugErr: IDebugger, properties?: ITelemetryLoggerPropertyBags);
    static create(namespace: string, properties?: ITelemetryLoggerPropertyBags): TelemetryLogger;
    static mixinDebugLogger(namespace: string, baseLogger?: ITelemetryBaseLogger, properties?: ITelemetryLoggerPropertyBags): TelemetryLogger;
    send(event: ITelemetryBaseEvent): void;
    }

// @public (undocumented)
export const disconnectedEventName = "disconnected";

// @public
export class EventEmitterWithErrorHandling<TEvent extends IEvent = IEvent> extends TypedEventEmitter<TEvent> {
    // (undocumented)
    emit(event: EventEmitterEventType, ...args: any[]): boolean;
}

// @public
export function extractLogSafeErrorProperties(error: any): {
    message: string;
    errorType?: string | undefined;
    stack?: string | undefined;
};

// @public
export interface IPerformanceEventMarkers {
    // (undocumented)
    cancel?: "generic" | "error";
    // (undocumented)
    end?: true;
    // (undocumented)
    start?: true;
}

// @public
export const isILoggingError: (x: any) => x is ILoggingError;

// @public
export function isTaggedTelemetryPropertyValue(x: any): x is ITaggedTelemetryPropertyType;

// @public (undocumented)
export interface ITelemetryLoggerPropertyBag {
    // (undocumented)
    [index: string]: TelemetryEventPropertyType | (() => TelemetryEventPropertyType);
}

// @public (undocumented)
export interface ITelemetryLoggerPropertyBags {
    // (undocumented)
    all?: ITelemetryLoggerPropertyBag;
    // (undocumented)
    error?: ITelemetryLoggerPropertyBag;
}

// @public
export class LoggingError extends Error implements ILoggingError {
    constructor(message: string, props?: ITelemetryProperties);
    addTelemetryProperties(props: ITelemetryProperties): void;
    getTelemetryProperties(): ITelemetryProperties;
}

// @public
export function logIfFalse(condition: any, logger: ITelemetryBaseLogger, event: string | ITelemetryGenericEvent): condition is true;

// @public
export class MultiSinkLogger extends TelemetryLogger {
    constructor(namespace?: string, properties?: ITelemetryLoggerPropertyBags);
    addLogger(logger?: ITelemetryBaseLogger): void;
    // (undocumented)
    protected loggers: ITelemetryBaseLogger[];
    send(event: ITelemetryBaseEvent): void;
}

// @public
export class PerformanceEvent {
    protected constructor(logger: ITelemetryLogger, event: ITelemetryGenericEvent, markers?: IPerformanceEventMarkers);
    // (undocumented)
    cancel(props?: ITelemetryProperties, error?: any): void;
    // (undocumented)
    get duration(): number;
    // (undocumented)
    end(props?: ITelemetryProperties): void;
    reportEvent(eventNameSuffix: string, props?: ITelemetryProperties, error?: any): void;
    // (undocumented)
    reportProgress(props?: ITelemetryProperties, eventNameSuffix?: string): void;
    // (undocumented)
    static start(logger: ITelemetryLogger, event: ITelemetryGenericEvent, markers?: IPerformanceEventMarkers): PerformanceEvent;
    // (undocumented)
    static timedExec<T>(logger: ITelemetryLogger, event: ITelemetryGenericEvent, callback: (event: PerformanceEvent) => T, markers?: IPerformanceEventMarkers): T;
    // (undocumented)
    static timedExecAsync<T>(logger: ITelemetryLogger, event: ITelemetryGenericEvent, callback: (event: PerformanceEvent) => Promise<T>, markers?: IPerformanceEventMarkers): Promise<T>;
}

// @public (undocumented)
export function raiseConnectedEvent(logger: ITelemetryLogger, emitter: EventEmitter, connected: boolean, clientId?: string): void;

// @public (undocumented)
export function safeRaiseEvent(emitter: EventEmitter, logger: ITelemetryLogger, event: string, ...args: any[]): void;

// @public
export enum TelemetryDataTag {
    PackageData = "PackageData",
    UserData = "UserData"
}

// @public
export abstract class TelemetryLogger implements ITelemetryLogger {
    constructor(namespace?: string | undefined, properties?: ITelemetryLoggerPropertyBags | undefined);
    // (undocumented)
    static readonly eventNamespaceSeparator = ":";
    // (undocumented)
    static formatTick(tick: number): number;
    // (undocumented)
    protected static getStack(): string | undefined;
    // (undocumented)
    protected readonly namespace?: string | undefined;
    static numberFromString(str: string | null | undefined): string | number | undefined;
    static prepareErrorObject(event: ITelemetryBaseEvent, error: any, fetchStack: boolean): void;
    // (undocumented)
    protected prepareEvent(event: ITelemetryBaseEvent): ITelemetryBaseEvent;
    // (undocumented)
    protected readonly properties?: ITelemetryLoggerPropertyBags | undefined;
    // (undocumented)
    static sanitizePkgName(name: string): string;
    abstract send(event: ITelemetryBaseEvent): void;
    sendErrorEvent(event: ITelemetryErrorEvent, error?: any): void;
    sendPerformanceEvent(event: ITelemetryPerformanceEvent, error?: any): void;
    sendTelemetryEvent(event: ITelemetryGenericEvent, error?: any): void;
}

// @public
export class TelemetryUTLogger implements ITelemetryLogger {
    // (undocumented)
    debugAssert(condition: boolean, event?: ITelemetryErrorEvent): void;
    // (undocumented)
    logException(event: ITelemetryErrorEvent, exception: any): void;
    // (undocumented)
    logGenericError(eventName: string, error: any): void;
    // (undocumented)
    send(event: ITelemetryBaseEvent): void;
    // (undocumented)
    sendErrorEvent(event: ITelemetryErrorEvent, error?: any): void;
    // (undocumented)
    sendPerformanceEvent(event: ITelemetryPerformanceEvent, error?: any): void;
    // (undocumented)
    sendTelemetryEvent(event: ITelemetryGenericEvent, error?: any): void;
    // (undocumented)
    shipAssert(condition: boolean, event?: ITelemetryErrorEvent): void;
}


// (No @packageDocumentation comment for this package)

```
