## API Report File for "@fluidframework/container-loader"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AttachState } from '@fluidframework/container-definitions';
import { ConnectionMode } from '@fluidframework/protocol-definitions';
import { ContainerWarning } from '@fluidframework/container-definitions';
import { EventEmitter } from 'events';
import { EventEmitterWithErrorHandling } from '@fluidframework/telemetry-utils';
import { IAudience } from '@fluidframework/container-definitions';
import { IClient } from '@fluidframework/protocol-definitions';
import { IClientConfiguration } from '@fluidframework/protocol-definitions';
import { IClientDetails } from '@fluidframework/protocol-definitions';
import { ICodeLoader } from '@fluidframework/container-definitions';
import { IConnectionDetails } from '@fluidframework/container-definitions';
import { IContainer } from '@fluidframework/container-definitions';
import { IContainerEvents } from '@fluidframework/container-definitions';
import { IContainerLoadMode } from '@fluidframework/container-definitions';
import { ICreateBlobResponse } from '@fluidframework/protocol-definitions';
import { ICriticalContainerError } from '@fluidframework/container-definitions';
import { IDeltaHandlerStrategy } from '@fluidframework/container-definitions';
import { IDeltaManager } from '@fluidframework/container-definitions';
import { IDeltaManagerEvents } from '@fluidframework/container-definitions';
import { IDeltaQueue } from '@fluidframework/container-definitions';
import { IDisposable } from '@fluidframework/common-definitions';
import { IDocumentMessage } from '@fluidframework/protocol-definitions';
import { IDocumentService } from '@fluidframework/driver-definitions';
import { IDocumentServiceFactory } from '@fluidframework/driver-definitions';
import { IDocumentStorageService } from '@fluidframework/driver-definitions';
import { IDocumentStorageServicePolicies } from '@fluidframework/driver-definitions';
import { IEventProvider } from '@fluidframework/common-definitions';
import { IFluidCodeDetails } from '@fluidframework/core-interfaces';
import { IFluidObject } from '@fluidframework/core-interfaces';
import { IFluidResolvedUrl } from '@fluidframework/driver-definitions';
import { IFluidRouter } from '@fluidframework/core-interfaces';
import { IHostLoader } from '@fluidframework/container-definitions';
import { ILoader } from '@fluidframework/container-definitions';
import { ILoaderOptions } from '@fluidframework/container-definitions';
import { IProxyLoaderFactory } from '@fluidframework/container-definitions';
import { IQuorum } from '@fluidframework/protocol-definitions';
import { IRequest } from '@fluidframework/core-interfaces';
import { IResolvedUrl } from '@fluidframework/driver-definitions';
import { IResponse } from '@fluidframework/core-interfaces';
import { ISequencedDocumentMessage } from '@fluidframework/protocol-definitions';
import { ISignalMessage } from '@fluidframework/protocol-definitions';
import { ISnapshotTree } from '@fluidframework/protocol-definitions';
import { ISummaryContext } from '@fluidframework/driver-definitions';
import { ISummaryHandle } from '@fluidframework/protocol-definitions';
import { ISummaryTree } from '@fluidframework/protocol-definitions';
import { ITelemetryBaseLogger } from '@fluidframework/common-definitions';
import { ITelemetryLogger } from '@fluidframework/common-definitions';
import { IThrottlingWarning } from '@fluidframework/container-definitions';
import { ITree } from '@fluidframework/protocol-definitions';
import { IUrlResolver } from '@fluidframework/driver-definitions';
import { IVersion } from '@fluidframework/protocol-definitions';
import { MessageType } from '@fluidframework/protocol-definitions';
import { ReadOnlyInfo } from '@fluidframework/container-definitions';
import { TelemetryLogger } from '@fluidframework/telemetry-utils';
import { TypedEventEmitter } from '@fluidframework/common-utils';

// @public
export class Audience extends EventEmitter implements IAudience {
    addMember(clientId: string, details: IClient): void;
    clear(): void;
    getMember(clientId: string): IClient | undefined;
    getMembers(): Map<string, IClient>;
    // (undocumented)
    on(event: "addMember", listener: (clientId: string, details: IClient) => void): this;
    // (undocumented)
    on(event: "removeMember", listener: (clientId: string) => void): this;
    removeMember(clientId: string): void;
}

// @public (undocumented)
export class CollabWindowTracker {
    constructor(submit: (type: MessageType, contents: any) => void, activeConnection: () => boolean, NoopTimeFrequency?: number, NoopCountFrequency?: number);
    scheduleSequenceNumberUpdate(message: ISequencedDocumentMessage, immediateNoOp: boolean): void;
    // (undocumented)
    stopSequenceNumberUpdate(): void;
    }

// @public (undocumented)
export enum ConnectionState {
    Connected = 2,
    Connecting = 1,
    Disconnected = 0
}

// @public (undocumented)
export class Container extends EventEmitterWithErrorHandling<IContainerEvents> implements IContainer {
    constructor(loader: Loader, config: IContainerConfig);
    // (undocumented)
    attach(request: IRequest): Promise<void>;
    // (undocumented)
    get attachState(): AttachState;
    get audience(): IAudience;
    // @deprecated (undocumented)
    get chaincodePackage(): IFluidCodeDetails | undefined;
    // (undocumented)
    get clientDetails(): IClientDetails;
    get clientId(): string | undefined;
    // (undocumented)
    close(error?: ICriticalContainerError): void;
    // (undocumented)
    closeAndGetPendingLocalState(): string;
    // (undocumented)
    get closed(): boolean;
    // (undocumented)
    get codeDetails(): IFluidCodeDetails | undefined;
    // (undocumented)
    get connected(): boolean;
    // (undocumented)
    get connectionState(): ConnectionState;
    static createDetached(loader: Loader, codeDetails: IFluidCodeDetails): Promise<Container>;
    // (undocumented)
    get deltaManager(): IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;
    get existing(): boolean | undefined;
    forceReadonly(readonly: boolean): void;
    // (undocumented)
    getAbsoluteUrl(relativeUrl: string): Promise<string | undefined>;
    getQuorum(): IQuorum;
    // (undocumented)
    get id(): string;
    // (undocumented)
    get IFluidRouter(): IFluidRouter;
    get isDirty(): boolean;
    static load(loader: Loader, loadOptions: IContainerLoadOptions, pendingLocalState?: unknown): Promise<Container>;
    // (undocumented)
    get loadedFromVersion(): IVersion | undefined;
    // (undocumented)
    get options(): ILoaderOptions;
    // (undocumented)
    proposeCodeDetails(codeDetails: IFluidCodeDetails): Promise<boolean>;
    raiseContainerWarning(warning: ContainerWarning): void;
    // @deprecated
    get readonly(): boolean | undefined;
    // (undocumented)
    get readOnlyInfo(): ReadOnlyInfo;
    // @deprecated
    get readonlyPermissions(): boolean | undefined;
    static rehydrateDetachedFromSnapshot(loader: Loader, snapshot: string): Promise<Container>;
    // (undocumented)
    request(path: IRequest): Promise<IResponse>;
    // (undocumented)
    get resolvedUrl(): IResolvedUrl | undefined;
    // (undocumented)
    resume(): void;
    // (undocumented)
    protected resumeInternal(args: IConnectionArgs): void;
    get scopes(): string[] | undefined;
    // (undocumented)
    serialize(): string;
    get serviceConfiguration(): IClientConfiguration | undefined;
    // (undocumented)
    setAutoReconnect(reconnect: boolean): void;
    // (undocumented)
    snapshot(tagMessage: string, fullTree?: boolean): Promise<void>;
    // (undocumented)
    get storage(): IDocumentStorageService | undefined;
    // (undocumented)
    subLogger: TelemetryLogger;
    // (undocumented)
    static version: string;
}

// @public
export function convertProtocolAndAppSummaryToSnapshotTree(protocolSummaryTree: ISummaryTree, appSummaryTree: ISummaryTree): ISnapshotTree;

// @public
export class DeltaManager extends TypedEventEmitter<IDeltaManagerInternalEvents> implements IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>, IEventProvider<IDeltaManagerInternalEvents> {
    constructor(serviceProvider: () => IDocumentService | undefined, client: IClient, logger: ITelemetryLogger, reconnectAllowed: boolean, _active: () => boolean);
    // (undocumented)
    get active(): boolean;
    attachOpHandler(minSequenceNumber: number, sequenceNumber: number, term: number, handler: IDeltaHandlerStrategy): void;
    // (undocumented)
    readonly clientDetails: IClientDetails;
    close(error?: ICriticalContainerError): void;
    // (undocumented)
    connect(args: IConnectionArgs): Promise<IConnectionDetails>;
    get connectionMode(): ConnectionMode;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    // (undocumented)
    emitDelayInfo(id: string, delaySeconds: number, error: ICriticalContainerError): void;
    // (undocumented)
    flush(): void;
    forceReadonly(readonly: boolean): void;
    get hasCheckpointSequenceNumber(): boolean;
    // (undocumented)
    get IDeltaSender(): this;
    // (undocumented)
    get inbound(): IDeltaQueue<ISequencedDocumentMessage>;
    // (undocumented)
    get inboundSignal(): IDeltaQueue<ISignalMessage>;
    // (undocumented)
    get initialSequenceNumber(): number;
    // (undocumented)
    get lastKnownSeqNumber(): number;
    // (undocumented)
    get lastMessage(): ISequencedDocumentMessage | undefined;
    // (undocumented)
    get lastSequenceNumber(): number;
    // (undocumented)
    get maxMessageSize(): number;
    // (undocumented)
    get minimumSequenceNumber(): number;
    // (undocumented)
    get outbound(): IDeltaQueue<IDocumentMessage[]>;
    // (undocumented)
    preFetchOps(cacheOnly: boolean): Promise<void>;
    // @deprecated
    get readonly(): boolean | undefined;
    // (undocumented)
    get readOnlyInfo(): ReadOnlyInfo;
    // @deprecated
    get readonlyPermissions(): boolean | undefined;
    get reconnectMode(): ReconnectMode;
    // (undocumented)
    get referenceTerm(): number;
    // (undocumented)
    refreshDelayInfo(id: string): void;
    // (undocumented)
    get scopes(): string[] | undefined;
    // (undocumented)
    get serviceConfiguration(): IClientConfiguration | undefined;
    setAutomaticReconnect(reconnect: boolean): void;
    // (undocumented)
    shouldJoinWrite(): boolean;
    // (undocumented)
    get socketDocumentId(): string | undefined;
    submit(type: MessageType, contents: any, batch?: boolean, metadata?: any): number;
    // (undocumented)
    submitSignal(content: any): void;
    // (undocumented)
    get version(): string;
}

// @public (undocumented)
export const getSnapshotTreeFromSerializedContainer: (detachedContainerSnapshot: ISummaryTree) => ISnapshotTree;

// @public (undocumented)
export interface IConnectionArgs {
    // (undocumented)
    fetchOpsFromStorage?: boolean;
    // (undocumented)
    mode?: ConnectionMode;
    // (undocumented)
    reason: string;
}

// @public (undocumented)
export interface IContainerConfig {
    // (undocumented)
    canReconnect?: boolean;
    clientDetailsOverride?: IClientDetails;
    // (undocumented)
    resolvedUrl?: IFluidResolvedUrl;
}

// @public (undocumented)
export interface IContainerLoadOptions {
    canReconnect?: boolean;
    clientDetailsOverride?: IClientDetails;
    loadMode?: IContainerLoadMode;
    // (undocumented)
    resolvedUrl: IFluidResolvedUrl;
    version?: string | null | undefined;
}

// @public
export interface IDeltaManagerInternalEvents extends IDeltaManagerEvents {
    // (undocumented)
    (event: "throttled", listener: (error: IThrottlingWarning) => void): any;
    // (undocumented)
    (event: "closed", listener: (error?: ICriticalContainerError) => void): any;
}

// @public
export interface ILoaderProps {
    readonly codeLoader: ICodeLoader;
    readonly documentServiceFactory: IDocumentServiceFactory;
    readonly logger?: ITelemetryBaseLogger;
    readonly options?: ILoaderOptions;
    readonly proxyLoaderFactories?: Map<string, IProxyLoaderFactory>;
    readonly scope?: IFluidObject;
    readonly urlResolver: IUrlResolver;
}

// @public
export interface ILoaderServices {
    readonly codeLoader: ICodeLoader;
    readonly documentServiceFactory: IDocumentServiceFactory;
    readonly options: ILoaderOptions;
    readonly proxyLoaderFactories: Map<string, IProxyLoaderFactory>;
    readonly scope: IFluidObject;
    readonly subLogger: ITelemetryLogger;
    readonly urlResolver: IUrlResolver;
}

// @public (undocumented)
export interface IParsedUrl {
    // (undocumented)
    id: string;
    // (undocumented)
    path: string;
    // (undocumented)
    query: string;
    version: string | null | undefined;
}

// @public
export class Loader implements IHostLoader {
    constructor(loaderProps: ILoaderProps);
    // @deprecated (undocumented)
    static _create(resolver: IUrlResolver | IUrlResolver[], documentServiceFactory: IDocumentServiceFactory | IDocumentServiceFactory[], codeLoader: ICodeLoader, options: ILoaderOptions, scope: IFluidObject, proxyLoaderFactories: Map<string, IProxyLoaderFactory>, logger?: ITelemetryBaseLogger): Loader;
    // (undocumented)
    createDetachedContainer(codeDetails: IFluidCodeDetails): Promise<Container>;
    // (undocumented)
    get IFluidRouter(): IFluidRouter;
    // (undocumented)
    rehydrateDetachedContainerFromSnapshot(snapshot: string): Promise<Container>;
    // (undocumented)
    request(request: IRequest): Promise<IResponse>;
    // (undocumented)
    resolve(request: IRequest, pendingLocalState?: string): Promise<Container>;
    // (undocumented)
    readonly services: ILoaderServices;
}

// @public (undocumented)
export function parseUrl(url: string): IParsedUrl | undefined;

// @public (undocumented)
export enum ReconnectMode {
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled",
    // (undocumented)
    Never = "Never"
}

// @public (undocumented)
export class RelativeLoader implements ILoader {
    constructor(container: Container, loader: ILoader | undefined);
    // (undocumented)
    get IFluidRouter(): IFluidRouter;
    // (undocumented)
    request(request: IRequest): Promise<IResponse>;
    // (undocumented)
    resolve(request: IRequest): Promise<IContainer>;
}

// @public (undocumented)
export class RetriableDocumentStorageService implements IDocumentStorageService, IDisposable {
    constructor(internalStorageService: IDocumentStorageService, deltaManager: Pick<DeltaManager, "emitDelayInfo" | "refreshDelayInfo">, logger: ITelemetryLogger);
    // (undocumented)
    createBlob(file: ArrayBufferLike): Promise<ICreateBlobResponse>;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    // (undocumented)
    downloadSummary(handle: ISummaryHandle): Promise<ISummaryTree>;
    // (undocumented)
    getSnapshotTree(version?: IVersion): Promise<ISnapshotTree | null>;
    // (undocumented)
    getVersions(versionId: string, count: number): Promise<IVersion[]>;
    // (undocumented)
    get policies(): IDocumentStorageServicePolicies | undefined;
    // (undocumented)
    readBlob(id: string): Promise<ArrayBufferLike>;
    // (undocumented)
    get repositoryUrl(): string;
    // (undocumented)
    uploadSummaryWithContext(summary: ISummaryTree, context: ISummaryContext): Promise<string>;
    // (undocumented)
    write(tree: ITree, parents: string[], message: string, ref: string): Promise<IVersion>;
}

// @public (undocumented)
export function runWithRetry<T>(api: () => Promise<T>, fetchCallName: string, deltaManager: Pick<DeltaManager, "emitDelayInfo" | "refreshDelayInfo">, logger: ITelemetryLogger, shouldRetry?: () => {
    retry: boolean;
    error: any | undefined;
}): Promise<T>;

// @public
export function waitContainerToCatchUp(container: Container): Promise<boolean>;


// (No @packageDocumentation comment for this package)

```
