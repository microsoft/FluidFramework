{"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-version-utils\\\\dist\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-version-utils\\\\dist\\\\compatOptions.mjs\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[],\"presets\":[]}:7.22.6:development":{"value":{"code":"/*!\r\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nimport nconf from \"nconf\";\nimport { resolveVersion } from \"./versionUtils.js\";\nimport { pkgVersion } from \"./packageVersion.js\";\n/**\r\n * Different kind of compat version config\r\n */\nexport var CompatKind;\n(function (CompatKind) {\n  CompatKind[\"None\"] = \"None\";\n  CompatKind[\"Loader\"] = \"Loader\";\n  CompatKind[\"NewLoader\"] = \"NewLoader\";\n  CompatKind[\"Driver\"] = \"Driver\";\n  CompatKind[\"NewDriver\"] = \"NewDriver\";\n  CompatKind[\"ContainerRuntime\"] = \"ContainerRuntime\";\n  CompatKind[\"NewContainerRuntime\"] = \"NewContainerRuntime\";\n  CompatKind[\"DataRuntime\"] = \"DataRuntime\";\n  CompatKind[\"NewDataRuntime\"] = \"NewDataRuntime\";\n  CompatKind[\"LoaderDriver\"] = \"LoaderDriver\";\n})(CompatKind || (CompatKind = {}));\n/*\r\n * Parse the command line argument and environment variables.  Arguments take precedent over environment variable\r\n * NOTE: Please update this packages README.md if the default versions and config combination changes\r\n */\nconst options = {\n  compatKind: {\n    description: \"Compat kind to run\",\n    choices: [CompatKind.None, CompatKind.Loader, CompatKind.NewLoader, CompatKind.Driver, CompatKind.NewDriver, CompatKind.ContainerRuntime, CompatKind.NewContainerRuntime, CompatKind.DataRuntime, CompatKind.NewDataRuntime, CompatKind.LoaderDriver],\n    requiresArg: true,\n    array: true\n  },\n  compatVersion: {\n    description: \"Compat version to run\",\n    requiresArg: true,\n    array: true,\n    type: \"string\"\n  },\n  reinstall: {\n    default: false,\n    description: \"Force compat package to be installed\",\n    boolean: true\n  },\n  driver: {\n    choices: [\"tinylicious\", \"t9s\", \"routerlicious\", \"r11s\", \"odsp\", \"local\"],\n    requiresArg: true\n  },\n  r11sEndpointName: {\n    type: \"string\"\n  },\n  tenantIndex: {\n    type: \"number\"\n  },\n  baseVersion: {\n    type: \"string\"\n  }\n};\nnconf.argv(Object.assign(Object.assign({}, options), {\n  transform: obj => {\n    if (options[obj.key] !== undefined) {\n      obj.key = `fluid:test:${obj.key}`;\n    }\n    return obj;\n  }\n})).env({\n  separator: \"__\",\n  whitelist: [\"fluid__test__compatKind\", \"fluid__test__compatVersion\", \"fluid__test__backCompat\", \"fluid__test__driver\", \"fluid__test__r11sEndpointName\", \"fluid__test__baseVersion\"],\n  transform: obj => {\n    var _a;\n    if (!obj.key.startsWith(\"fluid__test__\")) {\n      return obj;\n    }\n    const key = obj.key.substring(\"fluid__test__\".length);\n    if ((_a = options[key]) === null || _a === void 0 ? void 0 : _a.array) {\n      try {\n        obj.value = JSON.parse(obj.value);\n      } catch (_b) {\n        // ignore\n      }\n    }\n    return obj;\n  }\n}).defaults({\n  fluid: {\n    test: {\n      driver: \"local\",\n      baseVersion: pkgVersion,\n      r11sEndpointName: \"r11s\",\n      tenantIndex: 0\n    }\n  }\n});\nexport const compatKind = nconf.get(\"fluid:test:compatKind\");\nexport const compatVersions = nconf.get(\"fluid:test:compatVersion\");\nexport const driver = nconf.get(\"fluid:test:driver\");\nexport const r11sEndpointName = nconf.get(\"fluid:test:r11sEndpointName\");\nexport const baseVersion = resolveVersion(nconf.get(\"fluid:test:baseVersion\"), false);\nexport const reinstall = nconf.get(\"fluid:test:reinstall\");\nexport const tenantIndex = nconf.get(\"fluid:test:tenantIndex\");\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJuY29uZiIsInJlc29sdmVWZXJzaW9uIiwicGtnVmVyc2lvbiIsIkNvbXBhdEtpbmQiLCJvcHRpb25zIiwiY29tcGF0S2luZCIsImRlc2NyaXB0aW9uIiwiY2hvaWNlcyIsIk5vbmUiLCJMb2FkZXIiLCJOZXdMb2FkZXIiLCJEcml2ZXIiLCJOZXdEcml2ZXIiLCJDb250YWluZXJSdW50aW1lIiwiTmV3Q29udGFpbmVyUnVudGltZSIsIkRhdGFSdW50aW1lIiwiTmV3RGF0YVJ1bnRpbWUiLCJMb2FkZXJEcml2ZXIiLCJyZXF1aXJlc0FyZyIsImFycmF5IiwiY29tcGF0VmVyc2lvbiIsInR5cGUiLCJyZWluc3RhbGwiLCJkZWZhdWx0IiwiYm9vbGVhbiIsImRyaXZlciIsInIxMXNFbmRwb2ludE5hbWUiLCJ0ZW5hbnRJbmRleCIsImJhc2VWZXJzaW9uIiwiYXJndiIsIk9iamVjdCIsImFzc2lnbiIsInRyYW5zZm9ybSIsIm9iaiIsImtleSIsInVuZGVmaW5lZCIsImVudiIsInNlcGFyYXRvciIsIndoaXRlbGlzdCIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJfYSIsInZhbHVlIiwiSlNPTiIsInBhcnNlIiwiX2IiLCJkZWZhdWx0cyIsImZsdWlkIiwidGVzdCIsImdldCIsImNvbXBhdFZlcnNpb25zIl0sInNvdXJjZVJvb3QiOiJDOlxcY29kZVxcRmx1aWRGcmFtZXdvcms1XFxwYWNrYWdlc1xcdGVzdFxcdGVzdC12ZXJzaW9uLXV0aWxzXFxkaXN0XFwiLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21wYXRPcHRpb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24gYW5kIGNvbnRyaWJ1dG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgbmNvbmYgZnJvbSBcIm5jb25mXCI7XG5pbXBvcnQgeyBSb3V0ZXJsaWNpb3VzRW5kcG9pbnQsIFRlc3REcml2ZXJUeXBlcyB9IGZyb20gXCJAZmx1aWRmcmFtZXdvcmsvdGVzdC1kcml2ZXItZGVmaW5pdGlvbnNcIjtcbmltcG9ydCB7IHJlc29sdmVWZXJzaW9uIH0gZnJvbSBcIi4vdmVyc2lvblV0aWxzLmpzXCI7XG5pbXBvcnQgeyBwa2dWZXJzaW9uIH0gZnJvbSBcIi4vcGFja2FnZVZlcnNpb24uanNcIjtcblxuLyoqXG4gKiBEaWZmZXJlbnQga2luZCBvZiBjb21wYXQgdmVyc2lvbiBjb25maWdcbiAqL1xuZXhwb3J0IGVudW0gQ29tcGF0S2luZCB7XG5cdE5vbmUgPSBcIk5vbmVcIixcblx0TG9hZGVyID0gXCJMb2FkZXJcIixcblx0TmV3TG9hZGVyID0gXCJOZXdMb2FkZXJcIixcblx0RHJpdmVyID0gXCJEcml2ZXJcIixcblx0TmV3RHJpdmVyID0gXCJOZXdEcml2ZXJcIixcblx0Q29udGFpbmVyUnVudGltZSA9IFwiQ29udGFpbmVyUnVudGltZVwiLFxuXHROZXdDb250YWluZXJSdW50aW1lID0gXCJOZXdDb250YWluZXJSdW50aW1lXCIsXG5cdERhdGFSdW50aW1lID0gXCJEYXRhUnVudGltZVwiLFxuXHROZXdEYXRhUnVudGltZSA9IFwiTmV3RGF0YVJ1bnRpbWVcIixcblx0TG9hZGVyRHJpdmVyID0gXCJMb2FkZXJEcml2ZXJcIixcbn1cblxuLypcbiAqIFBhcnNlIHRoZSBjb21tYW5kIGxpbmUgYXJndW1lbnQgYW5kIGVudmlyb25tZW50IHZhcmlhYmxlcy4gIEFyZ3VtZW50cyB0YWtlIHByZWNlZGVudCBvdmVyIGVudmlyb25tZW50IHZhcmlhYmxlXG4gKiBOT1RFOiBQbGVhc2UgdXBkYXRlIHRoaXMgcGFja2FnZXMgUkVBRE1FLm1kIGlmIHRoZSBkZWZhdWx0IHZlcnNpb25zIGFuZCBjb25maWcgY29tYmluYXRpb24gY2hhbmdlc1xuICovXG5jb25zdCBvcHRpb25zID0ge1xuXHRjb21wYXRLaW5kOiB7XG5cdFx0ZGVzY3JpcHRpb246IFwiQ29tcGF0IGtpbmQgdG8gcnVuXCIsXG5cdFx0Y2hvaWNlczogW1xuXHRcdFx0Q29tcGF0S2luZC5Ob25lLFxuXHRcdFx0Q29tcGF0S2luZC5Mb2FkZXIsXG5cdFx0XHRDb21wYXRLaW5kLk5ld0xvYWRlcixcblx0XHRcdENvbXBhdEtpbmQuRHJpdmVyLFxuXHRcdFx0Q29tcGF0S2luZC5OZXdEcml2ZXIsXG5cdFx0XHRDb21wYXRLaW5kLkNvbnRhaW5lclJ1bnRpbWUsXG5cdFx0XHRDb21wYXRLaW5kLk5ld0NvbnRhaW5lclJ1bnRpbWUsXG5cdFx0XHRDb21wYXRLaW5kLkRhdGFSdW50aW1lLFxuXHRcdFx0Q29tcGF0S2luZC5OZXdEYXRhUnVudGltZSxcblx0XHRcdENvbXBhdEtpbmQuTG9hZGVyRHJpdmVyLFxuXHRcdF0sXG5cdFx0cmVxdWlyZXNBcmc6IHRydWUsXG5cdFx0YXJyYXk6IHRydWUsXG5cdH0sXG5cdGNvbXBhdFZlcnNpb246IHtcblx0XHRkZXNjcmlwdGlvbjogXCJDb21wYXQgdmVyc2lvbiB0byBydW5cIixcblx0XHRyZXF1aXJlc0FyZzogdHJ1ZSxcblx0XHRhcnJheTogdHJ1ZSxcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHR9LFxuXHRyZWluc3RhbGw6IHtcblx0XHRkZWZhdWx0OiBmYWxzZSxcblx0XHRkZXNjcmlwdGlvbjogXCJGb3JjZSBjb21wYXQgcGFja2FnZSB0byBiZSBpbnN0YWxsZWRcIixcblx0XHRib29sZWFuOiB0cnVlLFxuXHR9LFxuXHRkcml2ZXI6IHtcblx0XHRjaG9pY2VzOiBbXCJ0aW55bGljaW91c1wiLCBcInQ5c1wiLCBcInJvdXRlcmxpY2lvdXNcIiwgXCJyMTFzXCIsIFwib2RzcFwiLCBcImxvY2FsXCJdLFxuXHRcdHJlcXVpcmVzQXJnOiB0cnVlLFxuXHR9LFxuXHRyMTFzRW5kcG9pbnROYW1lOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0fSxcblx0dGVuYW50SW5kZXg6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHR9LFxuXHRiYXNlVmVyc2lvbjoge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdH0sXG59O1xuXG5uY29uZlxuXHQuYXJndih7XG5cdFx0Li4ub3B0aW9ucyxcblx0XHR0cmFuc2Zvcm06IChvYmo6IHsga2V5OiBzdHJpbmc7IHZhbHVlOiBzdHJpbmcgfSkgPT4ge1xuXHRcdFx0aWYgKG9wdGlvbnNbb2JqLmtleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRvYmoua2V5ID0gYGZsdWlkOnRlc3Q6JHtvYmoua2V5fWA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH0sXG5cdH0pXG5cdC5lbnYoe1xuXHRcdHNlcGFyYXRvcjogXCJfX1wiLFxuXHRcdHdoaXRlbGlzdDogW1xuXHRcdFx0XCJmbHVpZF9fdGVzdF9fY29tcGF0S2luZFwiLFxuXHRcdFx0XCJmbHVpZF9fdGVzdF9fY29tcGF0VmVyc2lvblwiLFxuXHRcdFx0XCJmbHVpZF9fdGVzdF9fYmFja0NvbXBhdFwiLFxuXHRcdFx0XCJmbHVpZF9fdGVzdF9fZHJpdmVyXCIsXG5cdFx0XHRcImZsdWlkX190ZXN0X19yMTFzRW5kcG9pbnROYW1lXCIsXG5cdFx0XHRcImZsdWlkX190ZXN0X19iYXNlVmVyc2lvblwiLFxuXHRcdF0sXG5cdFx0dHJhbnNmb3JtOiAob2JqOiB7IGtleTogc3RyaW5nOyB2YWx1ZTogc3RyaW5nIH0pID0+IHtcblx0XHRcdGlmICghb2JqLmtleS5zdGFydHNXaXRoKFwiZmx1aWRfX3Rlc3RfX1wiKSkge1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3Qga2V5ID0gb2JqLmtleS5zdWJzdHJpbmcoXCJmbHVpZF9fdGVzdF9fXCIubGVuZ3RoKTtcblx0XHRcdGlmIChvcHRpb25zW2tleV0/LmFycmF5KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0b2JqLnZhbHVlID0gSlNPTi5wYXJzZShvYmoudmFsdWUpO1xuXHRcdFx0XHR9IGNhdGNoIHtcblx0XHRcdFx0XHQvLyBpZ25vcmVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LFxuXHR9KVxuXHQuZGVmYXVsdHMoe1xuXHRcdGZsdWlkOiB7XG5cdFx0XHR0ZXN0OiB7XG5cdFx0XHRcdGRyaXZlcjogXCJsb2NhbFwiLFxuXHRcdFx0XHRiYXNlVmVyc2lvbjogcGtnVmVyc2lvbixcblx0XHRcdFx0cjExc0VuZHBvaW50TmFtZTogXCJyMTFzXCIsXG5cdFx0XHRcdHRlbmFudEluZGV4OiAwLFxuXHRcdFx0fSxcblx0XHR9LFxuXHR9KTtcblxuZXhwb3J0IGNvbnN0IGNvbXBhdEtpbmQgPSBuY29uZi5nZXQoXCJmbHVpZDp0ZXN0OmNvbXBhdEtpbmRcIikgYXMgQ29tcGF0S2luZFtdIHwgdW5kZWZpbmVkO1xuZXhwb3J0IGNvbnN0IGNvbXBhdFZlcnNpb25zID0gbmNvbmYuZ2V0KFwiZmx1aWQ6dGVzdDpjb21wYXRWZXJzaW9uXCIpIGFzIHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xuZXhwb3J0IGNvbnN0IGRyaXZlciA9IG5jb25mLmdldChcImZsdWlkOnRlc3Q6ZHJpdmVyXCIpIGFzIFRlc3REcml2ZXJUeXBlcztcbmV4cG9ydCBjb25zdCByMTFzRW5kcG9pbnROYW1lID0gbmNvbmYuZ2V0KFwiZmx1aWQ6dGVzdDpyMTFzRW5kcG9pbnROYW1lXCIpIGFzIFJvdXRlcmxpY2lvdXNFbmRwb2ludDtcbmV4cG9ydCBjb25zdCBiYXNlVmVyc2lvbiA9IHJlc29sdmVWZXJzaW9uKG5jb25mLmdldChcImZsdWlkOnRlc3Q6YmFzZVZlcnNpb25cIikgYXMgc3RyaW5nLCBmYWxzZSk7XG5leHBvcnQgY29uc3QgcmVpbnN0YWxsID0gbmNvbmYuZ2V0KFwiZmx1aWQ6dGVzdDpyZWluc3RhbGxcIik7XG5leHBvcnQgY29uc3QgdGVuYW50SW5kZXggPSBuY29uZi5nZXQoXCJmbHVpZDp0ZXN0OnRlbmFudEluZGV4XCIpIGFzIG51bWJlcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFLQSxPQUFPQSxLQUFLLE1BQU0s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","map":{"version":3,"names":["nconf","resolveVersion","pkgVersion","CompatKind","options","compatKind","description","choices","None","Loader","NewLoader","Driver","NewDriver","ContainerRuntime","NewContainerRuntime","DataRuntime","NewDataRuntime","LoaderDriver","requiresArg","array","compatVersion","type","reinstall","default","boolean","driver","r11sEndpointName","tenantIndex","baseVersion","argv","Object","assign","transform","obj","key","undefined","env","separator","whitelist","startsWith","substring","length","_a","value","JSON","parse","_b","defaults","fluid","test","get","compatVersions"],"sourceRoot":"C:\\code\\FluidFramework5\\packages\\test\\test-version-utils\\dist\\","sources":["../src/compatOptions.ts"],"sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport nconf from \"nconf\";\nimport { RouterliciousEndpoint, TestDriverTypes } from \"@fluidframework/test-driver-definitions\";\nimport { resolveVersion } from \"./versionUtils.js\";\nimport { pkgVersion } from \"./packageVersion.js\";\n\n/**\n * Different kind of compat version config\n */\nexport enum CompatKind {\n\tNone = \"None\",\n\tLoader = \"Loader\",\n\tNewLoader = \"NewLoader\",\n\tDriver = \"Driver\",\n\tNewDriver = \"NewDriver\",\n\tContainerRuntime = \"ContainerRuntime\",\n\tNewContainerRuntime = \"NewContainerRuntime\",\n\tDataRuntime = \"DataRuntime\",\n\tNewDataRuntime = \"NewDataRuntime\",\n\tLoaderDriver = \"LoaderDriver\",\n}\n\n/*\n * Parse the command line argument and environment variables.  Arguments take precedent over environment variable\n * NOTE: Please update this packages README.md if the default versions and config combination changes\n */\nconst options = {\n\tcompatKind: {\n\t\tdescription: \"Compat kind to run\",\n\t\tchoices: [\n\t\t\tCompatKind.None,\n\t\t\tCompatKind.Loader,\n\t\t\tCompatKind.NewLoader,\n\t\t\tCompatKind.Driver,\n\t\t\tCompatKind.NewDriver,\n\t\t\tCompatKind.ContainerRuntime,\n\t\t\tCompatKind.NewContainerRuntime,\n\t\t\tCompatKind.DataRuntime,\n\t\t\tCompatKind.NewDataRuntime,\n\t\t\tCompatKind.LoaderDriver,\n\t\t],\n\t\trequiresArg: true,\n\t\tarray: true,\n\t},\n\tcompatVersion: {\n\t\tdescription: \"Compat version to run\",\n\t\trequiresArg: true,\n\t\tarray: true,\n\t\ttype: \"string\",\n\t},\n\treinstall: {\n\t\tdefault: false,\n\t\tdescription: \"Force compat package to be installed\",\n\t\tboolean: true,\n\t},\n\tdriver: {\n\t\tchoices: [\"tinylicious\", \"t9s\", \"routerlicious\", \"r11s\", \"odsp\", \"local\"],\n\t\trequiresArg: true,\n\t},\n\tr11sEndpointName: {\n\t\ttype: \"string\",\n\t},\n\ttenantIndex: {\n\t\ttype: \"number\",\n\t},\n\tbaseVersion: {\n\t\ttype: \"string\",\n\t},\n};\n\nnconf\n\t.argv({\n\t\t...options,\n\t\ttransform: (obj: { key: string; value: string }) => {\n\t\t\tif (options[obj.key] !== undefined) {\n\t\t\t\tobj.key = `fluid:test:${obj.key}`;\n\t\t\t}\n\t\t\treturn obj;\n\t\t},\n\t})\n\t.env({\n\t\tseparator: \"__\",\n\t\twhitelist: [\n\t\t\t\"fluid__test__compatKind\",\n\t\t\t\"fluid__test__compatVersion\",\n\t\t\t\"fluid__test__backCompat\",\n\t\t\t\"fluid__test__driver\",\n\t\t\t\"fluid__test__r11sEndpointName\",\n\t\t\t\"fluid__test__baseVersion\",\n\t\t],\n\t\ttransform: (obj: { key: string; value: string }) => {\n\t\t\tif (!obj.key.startsWith(\"fluid__test__\")) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\tconst key = obj.key.substring(\"fluid__test__\".length);\n\t\t\tif (options[key]?.array) {\n\t\t\t\ttry {\n\t\t\t\t\tobj.value = JSON.parse(obj.value);\n\t\t\t\t} catch {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\t},\n\t})\n\t.defaults({\n\t\tfluid: {\n\t\t\ttest: {\n\t\t\t\tdriver: \"local\",\n\t\t\t\tbaseVersion: pkgVersion,\n\t\t\t\tr11sEndpointName: \"r11s\",\n\t\t\t\ttenantIndex: 0,\n\t\t\t},\n\t\t},\n\t});\n\nexport const compatKind = nconf.get(\"fluid:test:compatKind\") as CompatKind[] | undefined;\nexport const compatVersions = nconf.get(\"fluid:test:compatVersion\") as string[] | undefined;\nexport const driver = nconf.get(\"fluid:test:driver\") as TestDriverTypes;\nexport const r11sEndpointName = nconf.get(\"fluid:test:r11sEndpointName\") as RouterliciousEndpoint;\nexport const baseVersion = resolveVersion(nconf.get(\"fluid:test:baseVersion\") as string, false);\nexport const reinstall = nconf.get(\"fluid:test:reinstall\");\nexport const tenantIndex = nconf.get(\"fluid:test:tenantIndex\") as number;\n"],"mappings":"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"}},"mtime":1688579758629},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-version-utils\\\\dist\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-version-utils\\\\dist\\\\compatOptions.mjs\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tenantIndex = exports.reinstall = exports.r11sEndpointName = exports.driver = exports.compatVersions = exports.compatKind = exports.CompatKind = void 0;\nvar _nconf = _interopRequireDefault(require(\"nconf\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/*!\r\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Different kind of compat version config\r\n */\nvar CompatKind;\nexports.CompatKind = CompatKind;\n(function (CompatKind) {\n  CompatKind[\"None\"] = \"None\";\n  CompatKind[\"Loader\"] = \"Loader\";\n  CompatKind[\"NewLoader\"] = \"NewLoader\";\n  CompatKind[\"Driver\"] = \"Driver\";\n  CompatKind[\"NewDriver\"] = \"NewDriver\";\n  CompatKind[\"ContainerRuntime\"] = \"ContainerRuntime\";\n  CompatKind[\"NewContainerRuntime\"] = \"NewContainerRuntime\";\n  CompatKind[\"DataRuntime\"] = \"DataRuntime\";\n  CompatKind[\"NewDataRuntime\"] = \"NewDataRuntime\";\n  CompatKind[\"LoaderDriver\"] = \"LoaderDriver\";\n})(CompatKind || (exports.CompatKind = CompatKind = {}));\n/*\r\n * Parse the command line argument and environment variables. Arguments take precedent over environment variable\r\n * NOTE: Please update this packages README.md if the default versions and config combination changes\r\n */\nconst options = {\n  compatKind: {\n    description: \"Compat kind to run\",\n    choices: [CompatKind.None, CompatKind.Loader, CompatKind.NewLoader, CompatKind.Driver, CompatKind.NewDriver, CompatKind.ContainerRuntime, CompatKind.NewContainerRuntime, CompatKind.DataRuntime, CompatKind.NewDataRuntime, CompatKind.LoaderDriver],\n    requiresArg: true,\n    array: true\n  },\n  compatVersion: {\n    description: \"Compat version to run\",\n    requiresArg: true,\n    array: true,\n    type: \"string\"\n  },\n  reinstall: {\n    default: false,\n    description: \"Force compat package to be installed\",\n    boolean: true\n  },\n  driver: {\n    choices: [\"tinylicious\", \"t9s\", \"routerlicious\", \"r11s\", \"odsp\", \"local\"],\n    requiresArg: true\n  },\n  r11sEndpointName: {\n    type: \"string\"\n  },\n  tenantIndex: {\n    type: \"number\"\n  },\n  baseVersion: {\n    type: \"string\"\n  }\n};\n_nconf.default.argv(Object.assign(Object.assign({}, options), {\n  transform: obj => {\n    if (options[obj.key] !== undefined) {\n      obj.key = `fluid:test:${obj.key}`;\n    }\n    return obj;\n  }\n})).env({\n  separator: \"__\",\n  whitelist: [\"fluid__test__compatKind\", \"fluid__test__compatVersion\", \"fluid__test__backCompat\", \"fluid__test__driver\", \"fluid__test__r11sEndpointName\", \"fluid__test__baseVersion\"],\n  transform: obj => {\n    var _a;\n    if (!obj.key.startsWith(\"fluid__test__\")) {\n      return obj;\n    }\n    const key = obj.key.substring(\"fluid__test__\".length);\n    if ((_a = options[key]) === null || _a === void 0 ? void 0 : _a.array) {\n      try {\n        obj.value = JSON.parse(obj.value);\n      } catch (_b) {\n        // ignore\n      }\n    }\n    return obj;\n  }\n}).defaults({\n  fluid: {\n    test: {\n      driver: \"local\",\n      r11sEndpointName: \"r11s\",\n      tenantIndex: 0\n    }\n  }\n});\nconst compatKind = _nconf.default.get(\"fluid:test:compatKind\");\nexports.compatKind = compatKind;\nconst compatVersions = _nconf.default.get(\"fluid:test:compatVersion\");\nexports.compatVersions = compatVersions;\nconst driver = _nconf.default.get(\"fluid:test:driver\");\nexports.driver = driver;\nconst r11sEndpointName = _nconf.default.get(\"fluid:test:r11sEndpointName\");\nexports.r11sEndpointName = r11sEndpointName;\nconst reinstall = _nconf.default.get(\"fluid:test:reinstall\");\nexports.reinstall = reinstall;\nconst tenantIndex = _nconf.default.get(\"fluid:test:tenantIndex\");\nexports.tenantIndex = tenantIndex;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfbmNvbmYiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIm9iaiIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiQ29tcGF0S2luZCIsImV4cG9ydHMiLCJvcHRpb25zIiwiY29tcGF0S2luZCIsImRlc2NyaXB0aW9uIiwiY2hvaWNlcyIsIk5vbmUiLCJMb2FkZXIiLCJOZXdMb2FkZXIiLCJEcml2ZXIiLCJOZXdEcml2ZXIiLCJDb250YWluZXJSdW50aW1lIiwiTmV3Q29udGFpbmVyUnVudGltZSIsIkRhdGFSdW50aW1lIiwiTmV3RGF0YVJ1bnRpbWUiLCJMb2FkZXJEcml2ZXIiLCJyZXF1aXJlc0FyZyIsImFycmF5IiwiY29tcGF0VmVyc2lvbiIsInR5cGUiLCJyZWluc3RhbGwiLCJib29sZWFuIiwiZHJpdmVyIiwicjExc0VuZHBvaW50TmFtZSIsInRlbmFudEluZGV4IiwiYmFzZVZlcnNpb24iLCJuY29uZiIsImFyZ3YiLCJPYmplY3QiLCJhc3NpZ24iLCJ0cmFuc2Zvcm0iLCJrZXkiLCJ1bmRlZmluZWQiLCJlbnYiLCJzZXBhcmF0b3IiLCJ3aGl0ZWxpc3QiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiX2EiLCJ2YWx1ZSIsIkpTT04iLCJwYXJzZSIsIl9iIiwiZGVmYXVsdHMiLCJmbHVpZCIsInRlc3QiLCJnZXQiLCJjb21wYXRWZXJzaW9ucyJdLCJzb3VyY2VSb290IjoiQzpcXGNvZGVcXEZsdWlkRnJhbWV3b3JrNVxccGFja2FnZXNcXHRlc3RcXHRlc3QtdmVyc2lvbi11dGlsc1xcZGlzdFxcIiwic291cmNlcyI6WyIuLi9zcmMvY29tcGF0T3B0aW9ucy5tdHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbiBhbmQgY29udHJpYnV0b3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBuY29uZiBmcm9tIFwibmNvbmZcIjtcbmltcG9ydCB7IFJvdXRlcmxpY2lvdXNFbmRwb2ludCwgVGVzdERyaXZlclR5cGVzIH0gZnJvbSBcIkBmbHVpZGZyYW1ld29yay90ZXN0LWRyaXZlci1kZWZpbml0aW9uc1wiO1xuXG4vKipcbiAqIERpZmZlcmVudCBraW5kIG9mIGNvbXBhdCB2ZXJzaW9uIGNvbmZpZ1xuICovXG5leHBvcnQgZW51bSBDb21wYXRLaW5kIHtcblx0Tm9uZSA9IFwiTm9uZVwiLFxuXHRMb2FkZXIgPSBcIkxvYWRlclwiLFxuXHROZXdMb2FkZXIgPSBcIk5ld0xvYWRlclwiLFxuXHREcml2ZXIgPSBcIkRyaXZlclwiLFxuXHROZXdEcml2ZXIgPSBcIk5ld0RyaXZlclwiLFxuXHRDb250YWluZXJSdW50aW1lID0gXCJDb250YWluZXJSdW50aW1lXCIsXG5cdE5ld0NvbnRhaW5lclJ1bnRpbWUgPSBcIk5ld0NvbnRhaW5lclJ1bnRpbWVcIixcblx0RGF0YVJ1bnRpbWUgPSBcIkRhdGFSdW50aW1lXCIsXG5cdE5ld0RhdGFSdW50aW1lID0gXCJOZXdEYXRhUnVudGltZVwiLFxuXHRMb2FkZXJEcml2ZXIgPSBcIkxvYWRlckRyaXZlclwiLFxufVxuXG4vKlxuICogUGFyc2UgdGhlIGNvbW1hbmQgbGluZSBhcmd1bWVudCBhbmQgZW52aXJvbm1lbnQgdmFyaWFibGVzLiBBcmd1bWVudHMgdGFrZSBwcmVjZWRlbnQgb3ZlciBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICogTk9URTogUGxlYXNlIHVwZGF0ZSB0aGlzIHBhY2thZ2VzIFJFQURNRS5tZCBpZiB0aGUgZGVmYXVsdCB2ZXJzaW9ucyBhbmQgY29uZmlnIGNvbWJpbmF0aW9uIGNoYW5nZXNcbiAqL1xuY29uc3Qgb3B0aW9ucyA9IHtcblx0Y29tcGF0S2luZDoge1xuXHRcdGRlc2NyaXB0aW9uOiBcIkNvbXBhdCBraW5kIHRvIHJ1blwiLFxuXHRcdGNob2ljZXM6IFtcblx0XHRcdENvbXBhdEtpbmQuTm9uZSxcblx0XHRcdENvbXBhdEtpbmQuTG9hZGVyLFxuXHRcdFx0Q29tcGF0S2luZC5OZXdMb2FkZXIsXG5cdFx0XHRDb21wYXRLaW5kLkRyaXZlcixcblx0XHRcdENvbXBhdEtpbmQuTmV3RHJpdmVyLFxuXHRcdFx0Q29tcGF0S2luZC5Db250YWluZXJSdW50aW1lLFxuXHRcdFx0Q29tcGF0S2luZC5OZXdDb250YWluZXJSdW50aW1lLFxuXHRcdFx0Q29tcGF0S2luZC5EYXRhUnVudGltZSxcblx0XHRcdENvbXBhdEtpbmQuTmV3RGF0YVJ1bnRpbWUsXG5cdFx0XHRDb21wYXRLaW5kLkxvYWRlckRyaXZlcixcblx0XHRdLFxuXHRcdHJlcXVpcmVzQXJnOiB0cnVlLFxuXHRcdGFycmF5OiB0cnVlLFxuXHR9LFxuXHRjb21wYXRWZXJzaW9uOiB7XG5cdFx0ZGVzY3JpcHRpb246IFwiQ29tcGF0IHZlcnNpb24gdG8gcnVuXCIsXG5cdFx0cmVxdWlyZXNBcmc6IHRydWUsXG5cdFx0YXJyYXk6IHRydWUsXG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0fSxcblx0cmVpbnN0YWxsOiB7XG5cdFx0ZGVmYXVsdDogZmFsc2UsXG5cdFx0ZGVzY3JpcHRpb246IFwiRm9yY2UgY29tcGF0IHBhY2thZ2UgdG8gYmUgaW5zdGFsbGVkXCIsXG5cdFx0Ym9vbGVhbjogdHJ1ZSxcblx0fSxcblx0ZHJpdmVyOiB7XG5cdFx0Y2hvaWNlczogW1widGlueWxpY2lvdXNcIiwgXCJ0OXNcIiwgXCJyb3V0ZXJsaWNpb3VzXCIsIFwicjExc1wiLCBcIm9kc3BcIiwgXCJsb2NhbFwiXSxcblx0XHRyZXF1aXJlc0FyZzogdHJ1ZSxcblx0fSxcblx0cjExc0VuZHBvaW50TmFtZToge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdH0sXG5cdHRlbmFudEluZGV4OiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0fSxcblx0YmFzZVZlcnNpb246IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHR9LFxufTtcblxubmNvbmZcblx0LmFyZ3Yoe1xuXHRcdC4uLm9wdGlvbnMsXG5cdFx0dHJhbnNmb3JtOiAob2JqOiB7IGtleTogc3RyaW5nOyB2YWx1ZTogc3RyaW5nIH0pID0+IHtcblx0XHRcdGlmIChvcHRpb25zW29iai5rZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0b2JqLmtleSA9IGBmbHVpZDp0ZXN0OiR7b2JqLmtleX1gO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LFxuXHR9KVxuXHQuZW52KHtcblx0XHRzZXBhcmF0b3I6IFwiX19cIixcblx0XHR3aGl0ZWxpc3Q6IFtcblx0XHRcdFwiZmx1aWRfX3Rlc3RfX2NvbXBhdEtpbmRcIixcblx0XHRcdFwiZmx1aWRfX3Rlc3RfX2NvbXBhdFZlcnNpb25cIixcblx0XHRcdFwiZmx1aWRfX3Rlc3RfX2JhY2tDb21wYXRcIixcblx0XHRcdFwiZmx1aWRfX3Rlc3RfX2RyaXZlclwiLFxuXHRcdFx0XCJmbHVpZF9fdGVzdF9fcjExc0VuZHBvaW50TmFtZVwiLFxuXHRcdFx0XCJmbHVpZF9fdGVzdF9fYmFzZVZlcnNpb25cIixcblx0XHRdLFxuXHRcdHRyYW5zZm9ybTogKG9iajogeyBrZXk6IHN0cmluZzsgdmFsdWU6IHN0cmluZyB9KSA9PiB7XG5cdFx0XHRpZiAoIW9iai5rZXkuc3RhcnRzV2l0aChcImZsdWlkX190ZXN0X19cIikpIHtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH1cblx0XHRcdGNvbnN0IGtleSA9IG9iai5rZXkuc3Vic3RyaW5nKFwiZmx1aWRfX3Rlc3RfX1wiLmxlbmd0aCk7XG5cdFx0XHRpZiAob3B0aW9uc1trZXldPy5hcnJheSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdG9iai52YWx1ZSA9IEpTT04ucGFyc2Uob2JqLnZhbHVlKTtcblx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0Ly8gaWdub3JlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblx0fSlcblx0LmRlZmF1bHRzKHtcblx0XHRmbHVpZDoge1xuXHRcdFx0dGVzdDoge1xuXHRcdFx0XHRkcml2ZXI6IFwibG9jYWxcIixcblx0XHRcdFx0cjExc0VuZHBvaW50TmFtZTogXCJyMTFzXCIsXG5cdFx0XHRcdHRlbmFudEluZGV4OiAwLFxuXHRcdFx0fSxcblx0XHR9LFxuXHR9KTtcblxuZXhwb3J0IGNvbnN0IGNvbXBhdEtpbmQgPSBuY29uZi5nZXQoXCJmbHVpZDp0ZXN0OmNvbXBhdEtpbmRcIikgYXMgQ29tcGF0S2luZFtdIHwgdW5kZWZpbmVkO1xuZXhwb3J0IGNvbnN0IGNvbXBhdFZlcnNpb25zID0gbmNvbmYuZ2V0KFwiZmx1aWQ6dGVzdDpjb21wYXRWZXJzaW9uXCIpIGFzIHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xuZXhwb3J0IGNvbnN0IGRyaXZlciA9IG5jb25mLmdldChcImZsdWlkOnRlc3Q6ZHJpdmVyXCIpIGFzIFRlc3REcml2ZXJUeXBlcztcbmV4cG9ydCBjb25zdCByMTFzRW5kcG9pbnROYW1lID0gbmNvbmYuZ2V0KFwiZmx1aWQ6dGVzdDpyMTFzRW5kcG9pbnROYW1lXCIpIGFzIFJvdXRlcmxpY2lvdXNFbmRwb2ludDtcbmV4cG9ydCBjb25zdCByZWluc3RhbGwgPSBuY29uZi5nZXQoXCJmbHVpZDp0ZXN0OnJlaW5zdGFsbFwiKTtcbmV4cG9ydCBjb25zdCB0ZW5hbnRJbmRleCA9IG5jb25mLmdldChcImZsdWlkOnRlc3Q6dGVuYW50SW5kZXhcIikgYXMgbnVtYmVyO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFLQSxJQUFBQSxNQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFBMEIsU0FBQUQsdUJBQUFFLEdBQUEsV0FBQUEsR0FBQSxJQUFBQSxHQUFBLENBQUFDLFVBQUEsR0FBQUQsR0FBQSxLQUFBRSxPQUFBLEVBQUFGLEdBQUE7QUFMMUI7Ozs7O0FBUUE7OztBQUdBLElBQVlHLFVBV1g7QUFBQUMsT0FBQSxDQUFBRCxVQUFBLEdBQUFBLFVBQUE7QUFYRCxXQUFZQSxVQUFVO0VBQ3JCQSxVQUFBLGlCQUFh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","map":{"version":3,"names":["_nconf","_interopRequireDefault","require","obj","__esModule","default","CompatKind","exports","options","compatKind","description","choices","None","Loader","NewLoader","Driver","NewDriver","ContainerRuntime","NewContainerRuntime","DataRuntime","NewDataRuntime","LoaderDriver","requiresArg","array","compatVersion","type","reinstall","boolean","driver","r11sEndpointName","tenantIndex","baseVersion","nconf","argv","Object","assign","transform","key","undefined","env","separator","whitelist","startsWith","substring","length","_a","value","JSON","parse","_b","defaults","fluid","test","get","compatVersions"],"sourceRoot":"C:\\code\\FluidFramework5\\packages\\test\\test-version-utils\\dist\\","sources":["../src/compatOptions.mts"],"sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport nconf from \"nconf\";\nimport { RouterliciousEndpoint, TestDriverTypes } from \"@fluidframework/test-driver-definitions\";\n\n/**\n * Different kind of compat version config\n */\nexport enum CompatKind {\n\tNone = \"None\",\n\tLoader = \"Loader\",\n\tNewLoader = \"NewLoader\",\n\tDriver = \"Driver\",\n\tNewDriver = \"NewDriver\",\n\tContainerRuntime = \"ContainerRuntime\",\n\tNewContainerRuntime = \"NewContainerRuntime\",\n\tDataRuntime = \"DataRuntime\",\n\tNewDataRuntime = \"NewDataRuntime\",\n\tLoaderDriver = \"LoaderDriver\",\n}\n\n/*\n * Parse the command line argument and environment variables. Arguments take precedent over environment variable\n * NOTE: Please update this packages README.md if the default versions and config combination changes\n */\nconst options = {\n\tcompatKind: {\n\t\tdescription: \"Compat kind to run\",\n\t\tchoices: [\n\t\t\tCompatKind.None,\n\t\t\tCompatKind.Loader,\n\t\t\tCompatKind.NewLoader,\n\t\t\tCompatKind.Driver,\n\t\t\tCompatKind.NewDriver,\n\t\t\tCompatKind.ContainerRuntime,\n\t\t\tCompatKind.NewContainerRuntime,\n\t\t\tCompatKind.DataRuntime,\n\t\t\tCompatKind.NewDataRuntime,\n\t\t\tCompatKind.LoaderDriver,\n\t\t],\n\t\trequiresArg: true,\n\t\tarray: true,\n\t},\n\tcompatVersion: {\n\t\tdescription: \"Compat version to run\",\n\t\trequiresArg: true,\n\t\tarray: true,\n\t\ttype: \"string\",\n\t},\n\treinstall: {\n\t\tdefault: false,\n\t\tdescription: \"Force compat package to be installed\",\n\t\tboolean: true,\n\t},\n\tdriver: {\n\t\tchoices: [\"tinylicious\", \"t9s\", \"routerlicious\", \"r11s\", \"odsp\", \"local\"],\n\t\trequiresArg: true,\n\t},\n\tr11sEndpointName: {\n\t\ttype: \"string\",\n\t},\n\ttenantIndex: {\n\t\ttype: \"number\",\n\t},\n\tbaseVersion: {\n\t\ttype: \"string\",\n\t},\n};\n\nnconf\n\t.argv({\n\t\t...options,\n\t\ttransform: (obj: { key: string; value: string }) => {\n\t\t\tif (options[obj.key] !== undefined) {\n\t\t\t\tobj.key = `fluid:test:${obj.key}`;\n\t\t\t}\n\t\t\treturn obj;\n\t\t},\n\t})\n\t.env({\n\t\tseparator: \"__\",\n\t\twhitelist: [\n\t\t\t\"fluid__test__compatKind\",\n\t\t\t\"fluid__test__compatVersion\",\n\t\t\t\"fluid__test__backCompat\",\n\t\t\t\"fluid__test__driver\",\n\t\t\t\"fluid__test__r11sEndpointName\",\n\t\t\t\"fluid__test__baseVersion\",\n\t\t],\n\t\ttransform: (obj: { key: string; value: string }) => {\n\t\t\tif (!obj.key.startsWith(\"fluid__test__\")) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\tconst key = obj.key.substring(\"fluid__test__\".length);\n\t\t\tif (options[key]?.array) {\n\t\t\t\ttry {\n\t\t\t\t\tobj.value = JSON.parse(obj.value);\n\t\t\t\t} catch {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\t},\n\t})\n\t.defaults({\n\t\tfluid: {\n\t\t\ttest: {\n\t\t\t\tdriver: \"local\",\n\t\t\t\tr11sEndpointName: \"r11s\",\n\t\t\t\ttenantIndex: 0,\n\t\t\t},\n\t\t},\n\t});\n\nexport const compatKind = nconf.get(\"fluid:test:compatKind\") as CompatKind[] | undefined;\nexport const compatVersions = nconf.get(\"fluid:test:compatVersion\") as string[] | undefined;\nexport const driver = nconf.get(\"fluid:test:driver\") as TestDriverTypes;\nexport const r11sEndpointName = nconf.get(\"fluid:test:r11sEndpointName\") as RouterliciousEndpoint;\nexport const reinstall = nconf.get(\"fluid:test:reinstall\");\nexport const tenantIndex = nconf.get(\"fluid:test:tenantIndex\") as number;\n"],"mappings":"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"}},"mtime":1688583781488},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"\"use strict\";\n\n/*\n * nconf.js: Top-level include for the nconf module\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar common = require('./nconf/common'),\n  Provider = require('./nconf/provider').Provider;\n\n//\n// `nconf` is by default an instance of `nconf.Provider`.\n//\nvar nconf = module.exports = new Provider();\n\n//\n// Expose the version from the package.json\n//\nnconf.version = require('../package.json').version;\n\n//\n// Setup all stores as lazy-loaded getters.\n//\n['argv', 'env', 'file', 'literal', 'memory'].forEach(function (store) {\n  var name = common.capitalize(store);\n  nconf.__defineGetter__(name, function () {\n    return require('./nconf/stores/' + store)[name];\n  });\n});\n\n//\n// Expose the various components included with nconf\n//\nnconf.key = common.key;\nnconf.path = common.path;\nnconf.loadFiles = common.loadFiles;\nnconf.loadFilesSync = common.loadFilesSync;\nnconf.formats = require('./nconf/formats');\nnconf.Provider = Provider;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjb21tb24iLCJyZXF1aXJlIiwiUHJvdmlkZXIiLCJuY29uZiIsIm1vZHVsZSIsImV4cG9ydHMiLCJ2ZXJzaW9uIiwiZm9yRWFjaCIsInN0b3JlIiwibmFtZSIsImNhcGl0YWxpemUiLCJfX2RlZmluZUdldHRlcl9fIiwia2V5IiwicGF0aCIsImxvYWRGaWxlcyIsImxvYWRGaWxlc1N5bmMiLCJmb3JtYXRzIl0sInNvdXJjZVJvb3QiOiJDOlxcY29kZVxcRmx1aWRGcmFtZXdvcms1XFxub2RlX21vZHVsZXNcXC5wbnBtXFxuY29uZkAwLjEyLjBcXG5vZGVfbW9kdWxlc1xcbmNvbmZcXGxpYlxcIiwic291cmNlcyI6WyJuY29uZi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogbmNvbmYuanM6IFRvcC1sZXZlbCBpbmNsdWRlIGZvciB0aGUgbmNvbmYgbW9kdWxlXG4gKlxuICogKEMpIDIwMTEsIENoYXJsaWUgUm9iYmlucyBhbmQgdGhlIENvbnRyaWJ1dG9ycy5cbiAqXG4gKi9cblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vbmNvbmYvY29tbW9uJyksXG4gICAgUHJvdmlkZXIgPSByZXF1aXJlKCcuL25jb25mL3Byb3ZpZGVyJykuUHJvdmlkZXI7XG5cbi8vXG4vLyBgbmNvbmZgIGlzIGJ5IGRlZmF1bHQgYW4gaW5zdGFuY2Ugb2YgYG5jb25mLlByb3ZpZGVyYC5cbi8vXG52YXIgbmNvbmYgPSBtb2R1bGUuZXhwb3J0cyA9IG5ldyBQcm92aWRlcigpO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSB2ZXJzaW9uIGZyb20gdGhlIHBhY2thZ2UuanNvblxuLy9cbm5jb25mLnZlcnNpb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuXG4vL1xuLy8gU2V0dXAgYWxsIHN0b3JlcyBhcyBsYXp5LWxvYWRlZCBnZXR0ZXJzLlxuLy9cblsnYXJndicsICdlbnYnLCAnZmlsZScsICdsaXRlcmFsJywgJ21lbW9yeSddLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgdmFyIG5hbWUgPSBjb21tb24uY2FwaXRhbGl6ZShzdG9yZSk7XG5cbiAgICBuY29uZi5fX2RlZmluZUdldHRlcl9fKG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJy4vbmNvbmYvc3RvcmVzLycgKyBzdG9yZSlbbmFtZV07XG4gICAgfSk7XG59KTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgdmFyaW91cyBjb21wb25lbnRzIGluY2x1ZGVkIHdpdGggbmNvbmZcbi8vXG5uY29uZi5rZXkgICAgICAgICAgID0gY29tbW9uLmtleTtcbm5jb25mLnBhdGggICAgICAgICAgPSBjb21tb24ucGF0aDtcbm5jb25mLmxvYWRGaWxlcyAgICAgPSBjb21tb24ubG9hZEZpbGVzO1xubmNvbmYubG9hZEZpbGVzU3luYyA9IGNvbW1vbi5sb2FkRmlsZXNTeW5jO1xubmNvbmYuZm9ybWF0cyAgICAgICA9IHJlcXVpcmUoJy4vbmNvbmYvZm9ybWF0cycpO1xubmNvbmYuUHJvdmlkZXIgICAgICA9IFByb3ZpZGVyO1xuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJQSxNQUFNLEdBQUdDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztFQUNsQ0MsUUFBUSxHQUFHRCxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQ0MsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0EsSUFBSUMsS0FBSyxHQUFHQyxNQUFNLENBQUNDLE9BQU8sR0FBRyxJQUFJSCxRQUFRLENBQUMsQ0FBQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0FDLEtBQUssQ0FBQ0csT0FBTyxHQUFHTCxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQ0ssT0FBTzs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUNDLE9BQU8sQ0FBQyxVQUFVQyxLQUFLLEVBQUU7RUFDbEUsSUFBSUMsSUFBSSxHQUFHVCxNQUFNLENBQUNVLFVBQVUsQ0FBQ0YsS0FBSyxDQUFDO0VBRW5DTCxLQUFLLENBQUNRLGdCQUFnQixDQUFDRixJQUFJLEVBQUUsWUFBWTtJQUNyQyxPQUFPUixPQUFPLENBQUMsaUJBQWlCLEdBQUdPLEtBQUssQ0FBQyxDQUFDQyxJQUFJLENBQUM7RUFDbkQsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDOztBQUVGO0FBQ0E7QUFDQTtBQUNBTixLQUFLLENBQUNTLEdBQUcsR0FBYVosTUFBTSxDQUFDWSxHQUFHO0FBQ2hDVCxLQUFLLENBQUNVLElBQUksR0FBWWIsTUFBTSxDQUFDYSxJQUFJO0FBQ2pDVixLQUFLLENBQUNXLFNBQVMsR0FBT2QsTUFBTSxDQUFDYyxTQUFTO0FBQ3RDWCxLQUFLLENBQUNZLGFBQWEsR0FBR2YsTUFBTSxDQUFDZSxhQUFhO0FBQzFDWixLQUFLLENBQUNhLE9BQU8sR0FBU2YsT0FBTyxDQUFDLGlCQUFpQixDQUFDO0FBQ2hERSxLQUFLLENBQUNELFFBQVEsR0FBUUEsUUFBUSJ9","map":{"version":3,"names":["common","require","Provider","nconf","module","exports","version","forEach","store","name","capitalize","__defineGetter__","key","path","loadFiles","loadFilesSync","formats"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\nconf@0.12.0\\node_modules\\nconf\\lib\\","sources":["nconf.js"],"sourcesContent":["/*\n * nconf.js: Top-level include for the nconf module\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar common = require('./nconf/common'),\n    Provider = require('./nconf/provider').Provider;\n\n//\n// `nconf` is by default an instance of `nconf.Provider`.\n//\nvar nconf = module.exports = new Provider();\n\n//\n// Expose the version from the package.json\n//\nnconf.version = require('../package.json').version;\n\n//\n// Setup all stores as lazy-loaded getters.\n//\n['argv', 'env', 'file', 'literal', 'memory'].forEach(function (store) {\n    var name = common.capitalize(store);\n\n    nconf.__defineGetter__(name, function () {\n        return require('./nconf/stores/' + store)[name];\n    });\n});\n\n//\n// Expose the various components included with nconf\n//\nnconf.key           = common.key;\nnconf.path          = common.path;\nnconf.loadFiles     = common.loadFiles;\nnconf.loadFilesSync = common.loadFilesSync;\nnconf.formats       = require('./nconf/formats');\nnconf.Provider      = Provider;\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,gBAAgB,CAAC;EAClCC,QAAQ,GAAGD,OAAO,CAAC,kBAAkB,CAAC,CAACC,QAAQ;;AAEnD;AACA;AACA;AACA,IAAIC,KAAK,GAAGC,MAAM,CAACC,OAAO,GAAG,IAAIH,QAAQ,CAAC,CAAC;;AAE3C;AACA;AACA;AACAC,KAAK,CAACG,OAAO,GAAGL,OAAO,CAAC,iBAAiB,CAAC,CAACK,OAAO;;AAElD;AACA;AACA;AACA,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,SAAS,EAAE,QAAQ,CAAC,CAACC,OAAO,CAAC,UAAUC,KAAK,EAAE;EAClE,IAAIC,IAAI,GAAGT,MAAM,CAACU,UAAU,CAACF,KAAK,CAAC;EAEnCL,KAAK,CAACQ,gBAAgB,CAACF,IAAI,EAAE,YAAY;IACrC,OAAOR,OAAO,CAAC,iBAAiB,GAAGO,KAAK,CAAC,CAACC,IAAI,CAAC;EACnD,CAAC,CAAC;AACN,CAAC,CAAC;;AAEF;AACA;AACA;AACAN,KAAK,CAACS,GAAG,GAAaZ,MAAM,CAACY,GAAG;AAChCT,KAAK,CAACU,IAAI,GAAYb,MAAM,CAACa,IAAI;AACjCV,KAAK,CAACW,SAAS,GAAOd,MAAM,CAACc,SAAS;AACtCX,KAAK,CAACY,aAAa,GAAGf,MAAM,CAACe,aAAa;AAC1CZ,KAAK,CAACa,OAAO,GAASf,OAAO,CAAC,iBAAiB,CAAC;AAChDE,KAAK,CAACD,QAAQ,GAAQA,QAAQ"}},"mtime":1674865250595},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf\\\\common.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"\"use strict\";\n\n/*\n * utils.js: Utility functions for the nconf module.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar fs = require('fs'),\n  async = require('async'),\n  formats = require('./formats'),\n  Memory = require('./stores/memory').Memory;\nvar common = exports;\n\n//\n// ### function path (key)\n// #### @key {string} The ':' delimited key to split\n// Returns a fully-qualified path to a nested nconf key.\n// If given null or undefined it should return an empty path.\n// '' should still be respected as a path.\n//\ncommon.path = function (key, separator) {\n  separator = separator || ':';\n  return key == null ? [] : key.split(separator);\n};\n\n//\n// ### function key (arguments)\n// Returns a `:` joined string from the `arguments`.\n//\ncommon.key = function () {\n  return Array.prototype.slice.call(arguments).join(':');\n};\n\n//\n// ### function key (arguments)\n// Returns a joined string from the `arguments`,\n// first argument is the join delimiter.\n//\ncommon.keyed = function () {\n  return Array.prototype.slice.call(arguments, 1).join(arguments[0]);\n};\n\n//\n// ### function loadFiles (files, callback)\n// #### @files {Object|Array} List of files (or settings object) to load.\n// #### @callback {function} Continuation to respond to when complete.\n// Loads all the data in the specified `files`.\n//\ncommon.loadFiles = function (files, callback) {\n  if (!files) {\n    return callback(null, {});\n  }\n  var options = Array.isArray(files) ? {\n    files: files\n  } : files;\n\n  //\n  // Set the default JSON format if not already\n  // specified\n  //\n  options.format = options.format || formats.json;\n  function parseFile(file, next) {\n    fs.readFile(file, function (err, data) {\n      return !err ? next(null, options.format.parse(data.toString())) : next(err);\n    });\n  }\n  async.map(options.files, parseFile, function (err, objs) {\n    return err ? callback(err) : callback(null, common.merge(objs));\n  });\n};\n\n//\n// ### function loadFilesSync (files)\n// #### @files {Object|Array} List of files (or settings object) to load.\n// Loads all the data in the specified `files` synchronously.\n//\ncommon.loadFilesSync = function (files) {\n  if (!files) {\n    return;\n  }\n\n  //\n  // Set the default JSON format if not already\n  // specified\n  //\n  var options = Array.isArray(files) ? {\n    files: files\n  } : files;\n  options.format = options.format || formats.json;\n  return common.merge(options.files.map(function (file) {\n    return options.format.parse(fs.readFileSync(file, 'utf8'));\n  }));\n};\n\n//\n// ### function merge (objs)\n// #### @objs {Array} Array of object literals to merge\n// Merges the specified `objs` using a temporary instance\n// of `stores.Memory`.\n//\ncommon.merge = function (objs) {\n  var store = new Memory();\n  objs.forEach(function (obj) {\n    Object.keys(obj).forEach(function (key) {\n      store.merge(key, obj[key]);\n    });\n  });\n  return store.store;\n};\n\n//\n// ### function capitalize (str)\n// #### @str {string} String to capitalize\n// Capitalizes the specified `str`.\n//\ncommon.capitalize = function (str) {\n  return str && str[0].toUpperCase() + str.slice(1);\n};\n\n//\n// ### function parseValues (any)\n// #### @any {string} String to parse as native data-type or return as is\n// try to parse `any` as a native data-type\n//\ncommon.parseValues = function (value) {\n  var val = value;\n  try {\n    val = JSON.parse(value);\n  } catch (ignore) {\n    // Check for any other well-known strings that should be \"parsed\"\n    if (value === 'undefined') {\n      val = void 0;\n    }\n  }\n  return val;\n};\n\n//\n// ### function transform(map, fn)\n// #### @map {object} Object of key/value pairs to apply `fn` to\n// #### @fn {function} Transformation function that will be applied to every key/value pair\n// transform a set of key/value pairs and return the transformed result\ncommon.transform = function (map, fn) {\n  var pairs = Object.keys(map).map(function (key) {\n    var obj = {\n      key: key,\n      value: map[key]\n    };\n    var result = fn.call(null, obj);\n    if (!result) {\n      return null;\n    } else if (result.key) {\n      return result;\n    }\n    var error = new Error('Transform function passed to store returned an invalid format: ' + JSON.stringify(result));\n    error.name = 'RuntimeError';\n    throw error;\n  });\n  return pairs.filter(function (pair) {\n    return pair !== null;\n  }).reduce(function (accumulator, pair) {\n    accumulator[pair.key] = pair.value;\n    return accumulator;\n  }, {});\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJhc3luYyIsImZvcm1hdHMiLCJNZW1vcnkiLCJjb21tb24iLCJleHBvcnRzIiwicGF0aCIsImtleSIsInNlcGFyYXRvciIsInNwbGl0IiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJqb2luIiwia2V5ZWQiLCJsb2FkRmlsZXMiLCJmaWxlcyIsImNhbGxiYWNrIiwib3B0aW9ucyIsImlzQXJyYXkiLCJmb3JtYXQiLCJqc29uIiwicGFyc2VGaWxlIiwiZmlsZSIsIm5leHQiLCJyZWFkRmlsZSIsImVyciIsImRhdGEiLCJwYXJzZSIsInRvU3RyaW5nIiwibWFwIiwib2JqcyIsIm1lcmdlIiwibG9hZEZpbGVzU3luYyIsInJlYWRGaWxlU3luYyIsInN0b3JlIiwiZm9yRWFjaCIsIm9iaiIsIk9iamVjdCIsImtleXMiLCJjYXBpdGFsaXplIiwic3RyIiwidG9VcHBlckNhc2UiLCJwYXJzZVZhbHVlcyIsInZhbHVlIiwidmFsIiwiSlNPTiIsImlnbm9yZSIsInRyYW5zZm9ybSIsImZuIiwicGFpcnMiLCJyZXN1bHQiLCJlcnJvciIsIkVycm9yIiwic3RyaW5naWZ5IiwibmFtZSIsImZpbHRlciIsInBhaXIiLCJyZWR1Y2UiLCJhY2N1bXVsYXRvciJdLCJzb3VyY2VSb290IjoiQzpcXGNvZGVcXEZsdWlkRnJhbWV3b3JrNVxcbm9kZV9tb2R1bGVzXFwucG5wbVxcbmNvbmZAMC4xMi4wXFxub2RlX21vZHVsZXNcXG5jb25mXFxsaWJcXG5jb25mXFwiLCJzb3VyY2VzIjpbImNvbW1vbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogdXRpbHMuanM6IFV0aWxpdHkgZnVuY3Rpb25zIGZvciB0aGUgbmNvbmYgbW9kdWxlLlxuICpcbiAqIChDKSAyMDExLCBDaGFybGllIFJvYmJpbnMgYW5kIHRoZSBDb250cmlidXRvcnMuXG4gKlxuICovXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyksXG4gICAgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpLFxuICAgIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKSxcbiAgICBNZW1vcnkgPSByZXF1aXJlKCcuL3N0b3Jlcy9tZW1vcnknKS5NZW1vcnk7XG5cbnZhciBjb21tb24gPSBleHBvcnRzO1xuXG4vL1xuLy8gIyMjIGZ1bmN0aW9uIHBhdGggKGtleSlcbi8vICMjIyMgQGtleSB7c3RyaW5nfSBUaGUgJzonIGRlbGltaXRlZCBrZXkgdG8gc3BsaXRcbi8vIFJldHVybnMgYSBmdWxseS1xdWFsaWZpZWQgcGF0aCB0byBhIG5lc3RlZCBuY29uZiBrZXkuXG4vLyBJZiBnaXZlbiBudWxsIG9yIHVuZGVmaW5lZCBpdCBzaG91bGQgcmV0dXJuIGFuIGVtcHR5IHBhdGguXG4vLyAnJyBzaG91bGQgc3RpbGwgYmUgcmVzcGVjdGVkIGFzIGEgcGF0aC5cbi8vXG5jb21tb24ucGF0aCA9IGZ1bmN0aW9uIChrZXksIHNlcGFyYXRvcikge1xuICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgJzonO1xuICByZXR1cm4ga2V5ID09IG51bGwgPyBbXSA6IGtleS5zcGxpdChzZXBhcmF0b3IpO1xufTtcblxuLy9cbi8vICMjIyBmdW5jdGlvbiBrZXkgKGFyZ3VtZW50cylcbi8vIFJldHVybnMgYSBgOmAgam9pbmVkIHN0cmluZyBmcm9tIHRoZSBgYXJndW1lbnRzYC5cbi8vXG5jb21tb24ua2V5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCc6Jyk7XG59O1xuXG4vL1xuLy8gIyMjIGZ1bmN0aW9uIGtleSAoYXJndW1lbnRzKVxuLy8gUmV0dXJucyBhIGpvaW5lZCBzdHJpbmcgZnJvbSB0aGUgYGFyZ3VtZW50c2AsXG4vLyBmaXJzdCBhcmd1bWVudCBpcyB0aGUgam9pbiBkZWxpbWl0ZXIuXG4vL1xuY29tbW9uLmtleWVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKS5qb2luKGFyZ3VtZW50c1swXSk7XG59O1xuXG4vL1xuLy8gIyMjIGZ1bmN0aW9uIGxvYWRGaWxlcyAoZmlsZXMsIGNhbGxiYWNrKVxuLy8gIyMjIyBAZmlsZXMge09iamVjdHxBcnJheX0gTGlzdCBvZiBmaWxlcyAob3Igc2V0dGluZ3Mgb2JqZWN0KSB0byBsb2FkLlxuLy8gIyMjIyBAY2FsbGJhY2sge2Z1bmN0aW9ufSBDb250aW51YXRpb24gdG8gcmVzcG9uZCB0byB3aGVuIGNvbXBsZXRlLlxuLy8gTG9hZHMgYWxsIHRoZSBkYXRhIGluIHRoZSBzcGVjaWZpZWQgYGZpbGVzYC5cbi8vXG5jb21tb24ubG9hZEZpbGVzID0gZnVuY3Rpb24gKGZpbGVzLCBjYWxsYmFjaykge1xuICBpZiAoIWZpbGVzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHt9KTtcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gQXJyYXkuaXNBcnJheShmaWxlcykgPyB7IGZpbGVzOiBmaWxlcyB9IDogZmlsZXM7XG5cbiAgLy9cbiAgLy8gU2V0IHRoZSBkZWZhdWx0IEpTT04gZm9ybWF0IGlmIG5vdCBhbHJlYWR5XG4gIC8vIHNwZWNpZmllZFxuICAvL1xuICBvcHRpb25zLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGZvcm1hdHMuanNvbjtcblxuICBmdW5jdGlvbiBwYXJzZUZpbGUgKGZpbGUsIG5leHQpIHtcbiAgICBmcy5yZWFkRmlsZShmaWxlLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICByZXR1cm4gIWVyclxuICAgICAgICA/IG5leHQobnVsbCwgb3B0aW9ucy5mb3JtYXQucGFyc2UoZGF0YS50b1N0cmluZygpKSlcbiAgICAgICAgOiBuZXh0KGVycik7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYy5tYXAob3B0aW9ucy5maWxlcywgcGFyc2VGaWxlLCBmdW5jdGlvbiAoZXJyLCBvYmpzKSB7XG4gICAgcmV0dXJuIGVyciA/IGNhbGxiYWNrKGVycikgOiBjYWxsYmFjayhudWxsLCBjb21tb24ubWVyZ2Uob2JqcykpO1xuICB9KTtcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gbG9hZEZpbGVzU3luYyAoZmlsZXMpXG4vLyAjIyMjIEBmaWxlcyB7T2JqZWN0fEFycmF5fSBMaXN0IG9mIGZpbGVzIChvciBzZXR0aW5ncyBvYmplY3QpIHRvIGxvYWQuXG4vLyBMb2FkcyBhbGwgdGhlIGRhdGEgaW4gdGhlIHNwZWNpZmllZCBgZmlsZXNgIHN5bmNocm9ub3VzbHkuXG4vL1xuY29tbW9uLmxvYWRGaWxlc1N5bmMgPSBmdW5jdGlvbiAoZmlsZXMpIHtcbiAgaWYgKCFmaWxlcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vXG4gIC8vIFNldCB0aGUgZGVmYXVsdCBKU09OIGZvcm1hdCBpZiBub3QgYWxyZWFkeVxuICAvLyBzcGVjaWZpZWRcbiAgLy9cbiAgdmFyIG9wdGlvbnMgPSBBcnJheS5pc0FycmF5KGZpbGVzKSA/IHsgZmlsZXM6IGZpbGVzIH0gOiBmaWxlcztcbiAgb3B0aW9ucy5mb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBmb3JtYXRzLmpzb247XG5cbiAgcmV0dXJuIGNvbW1vbi5tZXJnZShvcHRpb25zLmZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSkge1xuICAgIHJldHVybiBvcHRpb25zLmZvcm1hdC5wYXJzZShmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKSk7XG4gIH0pKTtcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gbWVyZ2UgKG9ianMpXG4vLyAjIyMjIEBvYmpzIHtBcnJheX0gQXJyYXkgb2Ygb2JqZWN0IGxpdGVyYWxzIHRvIG1lcmdlXG4vLyBNZXJnZXMgdGhlIHNwZWNpZmllZCBgb2Jqc2AgdXNpbmcgYSB0ZW1wb3JhcnkgaW5zdGFuY2Vcbi8vIG9mIGBzdG9yZXMuTWVtb3J5YC5cbi8vXG5jb21tb24ubWVyZ2UgPSBmdW5jdGlvbiAob2Jqcykge1xuICB2YXIgc3RvcmUgPSBuZXcgTWVtb3J5KCk7XG5cbiAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgc3RvcmUubWVyZ2Uoa2V5LCBvYmpba2V5XSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzdG9yZS5zdG9yZTtcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gY2FwaXRhbGl6ZSAoc3RyKVxuLy8gIyMjIyBAc3RyIHtzdHJpbmd9IFN0cmluZyB0byBjYXBpdGFsaXplXG4vLyBDYXBpdGFsaXplcyB0aGUgc3BlY2lmaWVkIGBzdHJgLlxuLy9cbmNvbW1vbi5jYXBpdGFsaXplID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyICYmIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcblxuLy9cbi8vICMjIyBmdW5jdGlvbiBwYXJzZVZhbHVlcyAoYW55KVxuLy8gIyMjIyBAYW55IHtzdHJpbmd9IFN0cmluZyB0byBwYXJzZSBhcyBuYXRpdmUgZGF0YS10eXBlIG9yIHJldHVybiBhcyBpc1xuLy8gdHJ5IHRvIHBhcnNlIGBhbnlgIGFzIGEgbmF0aXZlIGRhdGEtdHlwZVxuLy9cbmNvbW1vbi5wYXJzZVZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgdmFsID0gdmFsdWU7XG4gIFxuICB0cnkge1xuICAgIHZhbCA9IEpTT04ucGFyc2UodmFsdWUpO1xuICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICAvLyBDaGVjayBmb3IgYW55IG90aGVyIHdlbGwta25vd24gc3RyaW5ncyB0aGF0IHNob3VsZCBiZSBcInBhcnNlZFwiXG4gICAgaWYgKHZhbHVlID09PSAndW5kZWZpbmVkJyl7XG4gICAgICB2YWwgPSB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gdHJhbnNmb3JtKG1hcCwgZm4pXG4vLyAjIyMjIEBtYXAge29iamVjdH0gT2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyB0byBhcHBseSBgZm5gIHRvXG4vLyAjIyMjIEBmbiB7ZnVuY3Rpb259IFRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGV2ZXJ5IGtleS92YWx1ZSBwYWlyXG4vLyB0cmFuc2Zvcm0gYSBzZXQgb2Yga2V5L3ZhbHVlIHBhaXJzIGFuZCByZXR1cm4gdGhlIHRyYW5zZm9ybWVkIHJlc3VsdFxuY29tbW9uLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKG1hcCwgZm4pIHtcbiAgdmFyIHBhaXJzID0gT2JqZWN0LmtleXMobWFwKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIG9iaiA9IHsga2V5OiBrZXksIHZhbHVlOiBtYXBba2V5XX07XG4gICAgdmFyIHJlc3VsdCA9IGZuLmNhbGwobnVsbCwgb2JqKTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5rZXkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdUcmFuc2Zvcm0gZnVuY3Rpb24gcGFzc2VkIHRvIHN0b3JlIHJldHVybmVkIGFuIGludmFsaWQgZm9ybWF0OiAnICsgSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgZXJyb3IubmFtZSA9ICdSdW50aW1lRXJyb3InO1xuICAgIHRocm93IGVycm9yO1xuICB9KTtcblxuXG4gIHJldHVybiBwYWlyc1xuICAgIC5maWx0ZXIoZnVuY3Rpb24ocGFpcikge1xuICAgICAgcmV0dXJuIHBhaXIgIT09IG51bGw7XG4gICAgfSlcbiAgICAucmVkdWNlKGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCBwYWlyKSB7XG4gICAgICBhY2N1bXVsYXRvcltwYWlyLmtleV0gPSBwYWlyLnZhbHVlO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH0sIHt9KTtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtB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","map":{"version":3,"names":["fs","require","async","formats","Memory","common","exports","path","key","separator","split","Array","prototype","slice","call","arguments","join","keyed","loadFiles","files","callback","options","isArray","format","json","parseFile","file","next","readFile","err","data","parse","toString","map","objs","merge","loadFilesSync","readFileSync","store","forEach","obj","Object","keys","capitalize","str","toUpperCase","parseValues","value","val","JSON","ignore","transform","fn","pairs","result","error","Error","stringify","name","filter","pair","reduce","accumulator"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\nconf@0.12.0\\node_modules\\nconf\\lib\\nconf\\","sources":["common.js"],"sourcesContent":["/*\n * utils.js: Utility functions for the nconf module.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar fs = require('fs'),\n    async = require('async'),\n    formats = require('./formats'),\n    Memory = require('./stores/memory').Memory;\n\nvar common = exports;\n\n//\n// ### function path (key)\n// #### @key {string} The ':' delimited key to split\n// Returns a fully-qualified path to a nested nconf key.\n// If given null or undefined it should return an empty path.\n// '' should still be respected as a path.\n//\ncommon.path = function (key, separator) {\n  separator = separator || ':';\n  return key == null ? [] : key.split(separator);\n};\n\n//\n// ### function key (arguments)\n// Returns a `:` joined string from the `arguments`.\n//\ncommon.key = function () {\n  return Array.prototype.slice.call(arguments).join(':');\n};\n\n//\n// ### function key (arguments)\n// Returns a joined string from the `arguments`,\n// first argument is the join delimiter.\n//\ncommon.keyed = function () {\n  return Array.prototype.slice.call(arguments, 1).join(arguments[0]);\n};\n\n//\n// ### function loadFiles (files, callback)\n// #### @files {Object|Array} List of files (or settings object) to load.\n// #### @callback {function} Continuation to respond to when complete.\n// Loads all the data in the specified `files`.\n//\ncommon.loadFiles = function (files, callback) {\n  if (!files) {\n    return callback(null, {});\n  }\n\n  var options = Array.isArray(files) ? { files: files } : files;\n\n  //\n  // Set the default JSON format if not already\n  // specified\n  //\n  options.format = options.format || formats.json;\n\n  function parseFile (file, next) {\n    fs.readFile(file, function (err, data) {\n      return !err\n        ? next(null, options.format.parse(data.toString()))\n        : next(err);\n    });\n  }\n\n  async.map(options.files, parseFile, function (err, objs) {\n    return err ? callback(err) : callback(null, common.merge(objs));\n  });\n};\n\n//\n// ### function loadFilesSync (files)\n// #### @files {Object|Array} List of files (or settings object) to load.\n// Loads all the data in the specified `files` synchronously.\n//\ncommon.loadFilesSync = function (files) {\n  if (!files) {\n    return;\n  }\n\n  //\n  // Set the default JSON format if not already\n  // specified\n  //\n  var options = Array.isArray(files) ? { files: files } : files;\n  options.format = options.format || formats.json;\n\n  return common.merge(options.files.map(function (file) {\n    return options.format.parse(fs.readFileSync(file, 'utf8'));\n  }));\n};\n\n//\n// ### function merge (objs)\n// #### @objs {Array} Array of object literals to merge\n// Merges the specified `objs` using a temporary instance\n// of `stores.Memory`.\n//\ncommon.merge = function (objs) {\n  var store = new Memory();\n\n  objs.forEach(function (obj) {\n    Object.keys(obj).forEach(function (key) {\n      store.merge(key, obj[key]);\n    });\n  });\n\n  return store.store;\n};\n\n//\n// ### function capitalize (str)\n// #### @str {string} String to capitalize\n// Capitalizes the specified `str`.\n//\ncommon.capitalize = function (str) {\n  return str && str[0].toUpperCase() + str.slice(1);\n};\n\n//\n// ### function parseValues (any)\n// #### @any {string} String to parse as native data-type or return as is\n// try to parse `any` as a native data-type\n//\ncommon.parseValues = function (value) {\n  var val = value;\n  \n  try {\n    val = JSON.parse(value);\n  } catch (ignore) {\n    // Check for any other well-known strings that should be \"parsed\"\n    if (value === 'undefined'){\n      val = void 0;\n    }\n  }\n\n  return val;\n};\n\n//\n// ### function transform(map, fn)\n// #### @map {object} Object of key/value pairs to apply `fn` to\n// #### @fn {function} Transformation function that will be applied to every key/value pair\n// transform a set of key/value pairs and return the transformed result\ncommon.transform = function(map, fn) {\n  var pairs = Object.keys(map).map(function(key) {\n    var obj = { key: key, value: map[key]};\n    var result = fn.call(null, obj);\n\n    if (!result) {\n      return null;\n    } else if (result.key) {\n      return result;\n    }\n\n    var error = new Error('Transform function passed to store returned an invalid format: ' + JSON.stringify(result));\n    error.name = 'RuntimeError';\n    throw error;\n  });\n\n\n  return pairs\n    .filter(function(pair) {\n      return pair !== null;\n    })\n    .reduce(function(accumulator, pair) {\n      accumulator[pair.key] = pair.value;\n      return accumulator;\n    }, {});\n}\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC;EAClBC,KAAK,GAAGD,OAAO,CAAC,OAAO,CAAC;EACxBE,OAAO,GAAGF,OAAO,CAAC,WAAW,CAAC;EAC9BG,MAAM,GAAGH,OAAO,CAAC,iBAAiB,CAAC,CAACG,MAAM;AAE9C,IAAIC,MAAM,GAAGC,OAAO;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACAD,MAAM,CAACE,IAAI,GAAG,UAAUC,GAAG,EAAEC,SAAS,EAAE;EACtCA,SAAS,GAAGA,SAAS,IAAI,GAAG;EAC5B,OAAOD,GAAG,IAAI,IAAI,GAAG,EAAE,GAAGA,GAAG,CAACE,KAAK,CAACD,SAAS,CAAC;AAChD,CAAC;;AAED;AACA;AACA;AACA;AACAJ,MAAM,CAACG,GAAG,GAAG,YAAY;EACvB,OAAOG,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACC,SAAS,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;AACxD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAX,MAAM,CAACY,KAAK,GAAG,YAAY;EACzB,OAAON,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACC,SAAS,EAAE,CAAC,CAAC,CAACC,IAAI,CAACD,SAAS,CAAC,CAAC,CAAC,CAAC;AACpE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAV,MAAM,CAACa,SAAS,GAAG,UAAUC,KAAK,EAAEC,QAAQ,EAAE;EAC5C,IAAI,CAACD,KAAK,EAAE;IACV,OAAOC,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;EAC3B;EAEA,IAAIC,OAAO,GAAGV,KAAK,CAACW,OAAO,CAACH,KAAK,CAAC,GAAG;IAAEA,KAAK,EAAEA;EAAM,CAAC,GAAGA,KAAK;;EAE7D;EACA;EACA;EACA;EACAE,OAAO,CAACE,MAAM,GAAGF,OAAO,CAACE,MAAM,IAAIpB,OAAO,CAACqB,IAAI;EAE/C,SAASC,SAASA,CAAEC,IAAI,EAAEC,IAAI,EAAE;IAC9B3B,EAAE,CAAC4B,QAAQ,CAACF,IAAI,EAAE,UAAUG,GAAG,EAAEC,IAAI,EAAE;MACrC,OAAO,CAACD,GAAG,GACPF,IAAI,CAAC,IAAI,EAAEN,OAAO,CAACE,MAAM,CAACQ,KAAK,CAACD,IAAI,CAACE,QAAQ,CAAC,CAAC,CAAC,CAAC,GACjDL,IAAI,CAACE,GAAG,CAAC;IACf,CAAC,CAAC;EACJ;EAEA3B,KAAK,CAAC+B,GAAG,CAACZ,OAAO,CAACF,KAAK,EAAEM,SAAS,EAAE,UAAUI,GAAG,EAAEK,IAAI,EAAE;IACvD,OAAOL,GAAG,GAAGT,QAAQ,CAACS,GAAG,CAAC,GAAGT,QAAQ,CAAC,IAAI,EAAEf,MAAM,CAAC8B,KAAK,CAACD,IAAI,CAAC,CAAC;EACjE,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA7B,MAAM,CAAC+B,aAAa,GAAG,UAAUjB,KAAK,EAAE;EACtC,IAAI,CAACA,KAAK,EAAE;IACV;EACF;;EAEA;EACA;EACA;EACA;EACA,IAAIE,OAAO,GAAGV,KAAK,CAACW,OAAO,CAACH,KAAK,CAAC,GAAG;IAAEA,KAAK,EAAEA;EAAM,CAAC,GAAGA,KAAK;EAC7DE,OAAO,CAACE,MAAM,GAAGF,OAAO,CAACE,MAAM,IAAIpB,OAAO,CAACqB,IAAI;EAE/C,OAAOnB,MAAM,CAAC8B,KAAK,CAACd,OAAO,CAACF,KAAK,CAACc,GAAG,CAAC,UAAUP,IAAI,EAAE;IACpD,OAAOL,OAAO,CAACE,MAAM,CAACQ,KAAK,CAAC/B,EAAE,CAACqC,YAAY,CAACX,IAAI,EAAE,MAAM,CAAC,CAAC;EAC5D,CAAC,CAAC,CAAC;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACArB,MAAM,CAAC8B,KAAK,GAAG,UAAUD,IAAI,EAAE;EAC7B,IAAII,KAAK,GAAG,IAAIlC,MAAM,CAAC,CAAC;EAExB8B,IAAI,CAACK,OAAO,CAAC,UAAUC,GAAG,EAAE;IAC1BC,MAAM,CAACC,IAAI,CAACF,GAAG,CAAC,CAACD,OAAO,CAAC,UAAU/B,GAAG,EAAE;MACtC8B,KAAK,CAACH,KAAK,CAAC3B,GAAG,EAAEgC,GAAG,CAAChC,GAAG,CAAC,CAAC;IAC5B,CAAC,CAAC;EACJ,CAAC,CAAC;EAEF,OAAO8B,KAAK,CAACA,KAAK;AACpB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAjC,MAAM,CAACsC,UAAU,GAAG,UAAUC,GAAG,EAAE;EACjC,OAAOA,GAAG,IAAIA,GAAG,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAGD,GAAG,CAAC/B,KAAK,CAAC,CAAC,CAAC;AACnD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAR,MAAM,CAACyC,WAAW,GAAG,UAAUC,KAAK,EAAE;EACpC,IAAIC,GAAG,GAAGD,KAAK;EAEf,IAAI;IACFC,GAAG,GAAGC,IAAI,CAAClB,KAAK,CAACgB,KAAK,CAAC;EACzB,CAAC,CAAC,OAAOG,MAAM,EAAE;IACf;IACA,IAAIH,KAAK,KAAK,WAAW,EAAC;MACxBC,GAAG,GAAG,KAAK,CAAC;IACd;EACF;EAEA,OAAOA,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA3C,MAAM,CAAC8C,SAAS,GAAG,UAASlB,GAAG,EAAEmB,EAAE,EAAE;EACnC,IAAIC,KAAK,GAAGZ,MAAM,CAACC,IAAI,CAACT,GAAG,CAAC,CAACA,GAAG,CAAC,UAASzB,GAAG,EAAE;IAC7C,IAAIgC,GAAG,GAAG;MAAEhC,GAAG,EAAEA,GAAG;MAAEuC,KAAK,EAAEd,GAAG,CAACzB,GAAG;IAAC,CAAC;IACtC,IAAI8C,MAAM,GAAGF,EAAE,CAACtC,IAAI,CAAC,IAAI,EAAE0B,GAAG,CAAC;IAE/B,IAAI,CAACc,MAAM,EAAE;MACX,OAAO,IAAI;IACb,CAAC,MAAM,IAAIA,MAAM,CAAC9C,GAAG,EAAE;MACrB,OAAO8C,MAAM;IACf;IAEA,IAAIC,KAAK,GAAG,IAAIC,KAAK,CAAC,iEAAiE,GAAGP,IAAI,CAACQ,SAAS,CAACH,MAAM,CAAC,CAAC;IACjHC,KAAK,CAACG,IAAI,GAAG,cAAc;IAC3B,MAAMH,KAAK;EACb,CAAC,CAAC;EAGF,OAAOF,KAAK,CACTM,MAAM,CAAC,UAASC,IAAI,EAAE;IACrB,OAAOA,IAAI,KAAK,IAAI;EACtB,CAAC,CAAC,CACDC,MAAM,CAAC,UAASC,WAAW,EAAEF,IAAI,EAAE;IAClCE,WAAW,CAACF,IAAI,CAACpD,GAAG,CAAC,GAAGoD,IAAI,CAACb,KAAK;IAClC,OAAOe,WAAW;EACpB,CAAC,EAAE,CAAC,CAAC,CAAC;AACV,CAAC"}},"mtime":1674865250449},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\async@3.2.4\\\\node_modules\\\\async\\\\dist\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\async@3.2.4\\\\node_modules\\\\async\\\\dist\\\\async.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"\"use strict\";\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.async = {});\n})(void 0, function (exports) {\n  'use strict';\n\n  /**\n   * Creates a continuation function with some arguments already applied.\n   *\n   * Useful as a shorthand when combined with other control flow functions. Any\n   * arguments passed to the returned function are added to the arguments\n   * originally passed to apply.\n   *\n   * @name apply\n   * @static\n   * @memberOf module:Utils\n   * @method\n   * @category Util\n   * @param {Function} fn - The function you want to eventually apply all\n   * arguments to. Invokes with (arguments...).\n   * @param {...*} arguments... - Any number of arguments to automatically apply\n   * when the continuation is called.\n   * @returns {Function} the partially-applied function\n   * @example\n   *\n   * // using apply\n   * async.parallel([\n   *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n   *     async.apply(fs.writeFile, 'testfile2', 'test2')\n   * ]);\n   *\n   *\n   * // the same process without using apply\n   * async.parallel([\n   *     function(callback) {\n   *         fs.writeFile('testfile1', 'test1', callback);\n   *     },\n   *     function(callback) {\n   *         fs.writeFile('testfile2', 'test2', callback);\n   *     }\n   * ]);\n   *\n   * // It's possible to pass any number of additional arguments when calling the\n   * // continuation:\n   *\n   * node> var fn = async.apply(sys.puts, 'one');\n   * node> fn('two', 'three');\n   * one\n   * two\n   * three\n   */\n  function apply(fn, ...args) {\n    return (...callArgs) => fn(...args, ...callArgs);\n  }\n  function initialParams(fn) {\n    return function (...args /*, callback*/) {\n      var callback = args.pop();\n      return fn.call(this, args, callback);\n    };\n  }\n\n  /* istanbul ignore file */\n\n  var hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;\n  var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\n  var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n  function fallback(fn) {\n    setTimeout(fn, 0);\n  }\n  function wrap(defer) {\n    return (fn, ...args) => defer(() => fn(...args));\n  }\n  var _defer;\n  if (hasQueueMicrotask) {\n    _defer = queueMicrotask;\n  } else if (hasSetImmediate) {\n    _defer = setImmediate;\n  } else if (hasNextTick) {\n    _defer = process.nextTick;\n  } else {\n    _defer = fallback;\n  }\n  var setImmediate$1 = wrap(_defer);\n\n  /**\n   * Take a sync function and make it async, passing its return value to a\n   * callback. This is useful for plugging sync functions into a waterfall,\n   * series, or other async functions. Any arguments passed to the generated\n   * function will be passed to the wrapped function (except for the final\n   * callback argument). Errors thrown will be passed to the callback.\n   *\n   * If the function passed to `asyncify` returns a Promise, that promises's\n   * resolved/rejected state will be used to call the callback, rather than simply\n   * the synchronous return value.\n   *\n   * This also means you can asyncify ES2017 `async` functions.\n   *\n   * @name asyncify\n   * @static\n   * @memberOf module:Utils\n   * @method\n   * @alias wrapSync\n   * @category Util\n   * @param {Function} func - The synchronous function, or Promise-returning\n   * function to convert to an {@link AsyncFunction}.\n   * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n   * invoked with `(args..., callback)`.\n   * @example\n   *\n   * // passing a regular synchronous function\n   * async.waterfall([\n   *     async.apply(fs.readFile, filename, \"utf8\"),\n   *     async.asyncify(JSON.parse),\n   *     function (data, next) {\n   *         // data is the result of parsing the text.\n   *         // If there was a parsing error, it would have been caught.\n   *     }\n   * ], callback);\n   *\n   * // passing a function returning a promise\n   * async.waterfall([\n   *     async.apply(fs.readFile, filename, \"utf8\"),\n   *     async.asyncify(function (contents) {\n   *         return db.model.create(contents);\n   *     }),\n   *     function (model, next) {\n   *         // `model` is the instantiated model object.\n   *         // If there was an error, this function would be skipped.\n   *     }\n   * ], callback);\n   *\n   * // es2017 example, though `asyncify` is not needed if your JS environment\n   * // supports async functions out of the box\n   * var q = async.queue(async.asyncify(async function(file) {\n   *     var intermediateStep = await processFile(file);\n   *     return await somePromise(intermediateStep)\n   * }));\n   *\n   * q.push(files);\n   */\n  function asyncify(func) {\n    if (isAsync(func)) {\n      return function (...args /*, callback*/) {\n        const callback = args.pop();\n        const promise = func.apply(this, args);\n        return handlePromise(promise, callback);\n      };\n    }\n    return initialParams(function (args, callback) {\n      var result;\n      try {\n        result = func.apply(this, args);\n      } catch (e) {\n        return callback(e);\n      }\n      // if result is Promise object\n      if (result && typeof result.then === 'function') {\n        return handlePromise(result, callback);\n      } else {\n        callback(null, result);\n      }\n    });\n  }\n  function handlePromise(promise, callback) {\n    return promise.then(value => {\n      invokeCallback(callback, null, value);\n    }, err => {\n      invokeCallback(callback, err && err.message ? err : new Error(err));\n    });\n  }\n  function invokeCallback(callback, error, value) {\n    try {\n      callback(error, value);\n    } catch (err) {\n      setImmediate$1(e => {\n        throw e;\n      }, err);\n    }\n  }\n  function isAsync(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncFunction';\n  }\n  function isAsyncGenerator(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncGenerator';\n  }\n  function isAsyncIterable(obj) {\n    return typeof obj[Symbol.asyncIterator] === 'function';\n  }\n  function wrapAsync(asyncFn) {\n    if (typeof asyncFn !== 'function') throw new Error('expected a function');\n    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n  }\n\n  // conditionally promisify a function.\n  // only return a promise if a callback is omitted\n  function awaitify(asyncFn, arity = asyncFn.length) {\n    if (!arity) throw new Error('arity is undefined');\n    function awaitable(...args) {\n      if (typeof args[arity - 1] === 'function') {\n        return asyncFn.apply(this, args);\n      }\n      return new Promise((resolve, reject) => {\n        args[arity - 1] = (err, ...cbArgs) => {\n          if (err) return reject(err);\n          resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);\n        };\n        asyncFn.apply(this, args);\n      });\n    }\n    return awaitable;\n  }\n  function applyEach(eachfn) {\n    return function applyEach(fns, ...callArgs) {\n      const go = awaitify(function (callback) {\n        var that = this;\n        return eachfn(fns, (fn, cb) => {\n          wrapAsync(fn).apply(that, callArgs.concat(cb));\n        }, callback);\n      });\n      return go;\n    };\n  }\n  function _asyncMap(eachfn, arr, iteratee, callback) {\n    arr = arr || [];\n    var results = [];\n    var counter = 0;\n    var _iteratee = wrapAsync(iteratee);\n    return eachfn(arr, (value, _, iterCb) => {\n      var index = counter++;\n      _iteratee(value, (err, v) => {\n        results[index] = v;\n        iterCb(err);\n      });\n    }, err => {\n      callback(err, results);\n    });\n  }\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;\n  }\n\n  // A temporary value used to identify if the loop should be broken.\n  // See #1064, #1293\n  const breakLoop = {};\n  function once(fn) {\n    function wrapper(...args) {\n      if (fn === null) return;\n      var callFn = fn;\n      fn = null;\n      callFn.apply(this, args);\n    }\n    Object.assign(wrapper, fn);\n    return wrapper;\n  }\n  function getIterator(coll) {\n    return coll[Symbol.iterator] && coll[Symbol.iterator]();\n  }\n  function createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n      return ++i < len ? {\n        value: coll[i],\n        key: i\n      } : null;\n    };\n  }\n  function createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n      var item = iterator.next();\n      if (item.done) return null;\n      i++;\n      return {\n        value: item.value,\n        key: i\n      };\n    };\n  }\n  function createObjectIterator(obj) {\n    var okeys = obj ? Object.keys(obj) : [];\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n      var key = okeys[++i];\n      if (key === '__proto__') {\n        return next();\n      }\n      return i < len ? {\n        value: obj[key],\n        key\n      } : null;\n    };\n  }\n  function createIterator(coll) {\n    if (isArrayLike(coll)) {\n      return createArrayIterator(coll);\n    }\n    var iterator = getIterator(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n  }\n  function onlyOnce(fn) {\n    return function (...args) {\n      if (fn === null) throw new Error(\"Callback was already called.\");\n      var callFn = fn;\n      fn = null;\n      callFn.apply(this, args);\n    };\n  }\n\n  // for async generators\n  function asyncEachOfLimit(generator, limit, iteratee, callback) {\n    let done = false;\n    let canceled = false;\n    let awaiting = false;\n    let running = 0;\n    let idx = 0;\n    function replenish() {\n      //console.log('replenish')\n      if (running >= limit || awaiting || done) return;\n      //console.log('replenish awaiting')\n      awaiting = true;\n      generator.next().then(({\n        value,\n        done: iterDone\n      }) => {\n        //console.log('got value', value)\n        if (canceled || done) return;\n        awaiting = false;\n        if (iterDone) {\n          done = true;\n          if (running <= 0) {\n            //console.log('done nextCb')\n            callback(null);\n          }\n          return;\n        }\n        running++;\n        iteratee(value, idx, iterateeCallback);\n        idx++;\n        replenish();\n      }).catch(handleError);\n    }\n    function iterateeCallback(err, result) {\n      //console.log('iterateeCallback')\n      running -= 1;\n      if (canceled) return;\n      if (err) return handleError(err);\n      if (err === false) {\n        done = true;\n        canceled = true;\n        return;\n      }\n      if (result === breakLoop || done && running <= 0) {\n        done = true;\n        //console.log('done iterCb')\n        return callback(null);\n      }\n      replenish();\n    }\n    function handleError(err) {\n      if (canceled) return;\n      awaiting = false;\n      done = true;\n      callback(err);\n    }\n    replenish();\n  }\n  var eachOfLimit = limit => {\n    return (obj, iteratee, callback) => {\n      callback = once(callback);\n      if (limit <= 0) {\n        throw new RangeError('concurrency limit cannot be less than 1');\n      }\n      if (!obj) {\n        return callback(null);\n      }\n      if (isAsyncGenerator(obj)) {\n        return asyncEachOfLimit(obj, limit, iteratee, callback);\n      }\n      if (isAsyncIterable(obj)) {\n        return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);\n      }\n      var nextElem = createIterator(obj);\n      var done = false;\n      var canceled = false;\n      var running = 0;\n      var looping = false;\n      function iterateeCallback(err, value) {\n        if (canceled) return;\n        running -= 1;\n        if (err) {\n          done = true;\n          callback(err);\n        } else if (err === false) {\n          done = true;\n          canceled = true;\n        } else if (value === breakLoop || done && running <= 0) {\n          done = true;\n          return callback(null);\n        } else if (!looping) {\n          replenish();\n        }\n      }\n      function replenish() {\n        looping = true;\n        while (running < limit && !done) {\n          var elem = nextElem();\n          if (elem === null) {\n            done = true;\n            if (running <= 0) {\n              callback(null);\n            }\n            return;\n          }\n          running += 1;\n          iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n        }\n        looping = false;\n      }\n      replenish();\n    };\n  };\n\n  /**\n   * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n   * time.\n   *\n   * @name eachOfLimit\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.eachOf]{@link module:Collections.eachOf}\n   * @alias forEachOfLimit\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {number} limit - The maximum number of async operations at a time.\n   * @param {AsyncFunction} iteratee - An async function to apply to each\n   * item in `coll`. The `key` is the item's key, or index in the case of an\n   * array.\n   * Invoked with (item, key, callback).\n   * @param {Function} [callback] - A callback which is called when all\n   * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n   * @returns {Promise} a promise, if a callback is omitted\n   */\n  function eachOfLimit$1(coll, limit, iteratee, callback) {\n    return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);\n  }\n  var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);\n\n  // eachOf implementation optimized for array-likes\n  function eachOfArrayLike(coll, iteratee, callback) {\n    callback = once(callback);\n    var index = 0,\n      completed = 0,\n      {\n        length\n      } = coll,\n      canceled = false;\n    if (length === 0) {\n      callback(null);\n    }\n    function iteratorCallback(err, value) {\n      if (err === false) {\n        canceled = true;\n      }\n      if (canceled === true) return;\n      if (err) {\n        callback(err);\n      } else if (++completed === length || value === breakLoop) {\n        callback(null);\n      }\n    }\n    for (; index < length; index++) {\n      iteratee(coll[index], index, onlyOnce(iteratorCallback));\n    }\n  }\n\n  // a generic version of eachOf which can handle array, object, and iterator cases.\n  function eachOfGeneric(coll, iteratee, callback) {\n    return eachOfLimit$2(coll, Infinity, iteratee, callback);\n  }\n\n  /**\n   * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n   * to the iteratee.\n   *\n   * @name eachOf\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @alias forEachOf\n   * @category Collection\n   * @see [async.each]{@link module:Collections.each}\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - A function to apply to each\n   * item in `coll`.\n   * The `key` is the item's key, or index in the case of an array.\n   * Invoked with (item, key, callback).\n   * @param {Function} [callback] - A callback which is called when all\n   * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n   * @returns {Promise} a promise, if a callback is omitted\n   * @example\n   *\n   * // dev.json is a file containing a valid json object config for dev environment\n   * // dev.json is a file containing a valid json object config for test environment\n   * // prod.json is a file containing a valid json object config for prod environment\n   * // invalid.json is a file with a malformed json object\n   *\n   * let configs = {}; //global variable\n   * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};\n   * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};\n   *\n   * // asynchronous function that reads a json file and parses the contents as json object\n   * function parseFile(file, key, callback) {\n   *     fs.readFile(file, \"utf8\", function(err, data) {\n   *         if (err) return calback(err);\n   *         try {\n   *             configs[key] = JSON.parse(data);\n   *         } catch (e) {\n   *             return callback(e);\n   *         }\n   *         callback();\n   *     });\n   * }\n   *\n   * // Using callbacks\n   * async.forEachOf(validConfigFileMap, parseFile, function (err) {\n   *     if (err) {\n   *         console.error(err);\n   *     } else {\n   *         console.log(configs);\n   *         // configs is now a map of JSON data, e.g.\n   *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n   *     }\n   * });\n   *\n   * //Error handing\n   * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {\n   *     if (err) {\n   *         console.error(err);\n   *         // JSON parse error exception\n   *     } else {\n   *         console.log(configs);\n   *     }\n   * });\n   *\n   * // Using Promises\n   * async.forEachOf(validConfigFileMap, parseFile)\n   * .then( () => {\n   *     console.log(configs);\n   *     // configs is now a map of JSON data, e.g.\n   *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n   * }).catch( err => {\n   *     console.error(err);\n   * });\n   *\n   * //Error handing\n   * async.forEachOf(invalidConfigFileMap, parseFile)\n   * .then( () => {\n   *     console.log(configs);\n   * }).catch( err => {\n   *     console.error(err);\n   *     // JSON parse error exception\n   * });\n   *\n   * // Using async/await\n   * async () => {\n   *     try {\n   *         let result = await async.forEachOf(validConfigFileMap, parseFile);\n   *         console.log(configs);\n   *         // configs is now a map of JSON data, e.g.\n   *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   * //Error handing\n   * async () => {\n   *     try {\n   *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);\n   *         console.log(configs);\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *         // JSON parse error exception\n   *     }\n   * }\n   *\n   */\n  function eachOf(coll, iteratee, callback) {\n    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n    return eachOfImplementation(coll, wrapAsync(iteratee), callback);\n  }\n  var eachOf$1 = awaitify(eachOf, 3);\n\n  /**\n   * Produces a new collection of values by mapping each value in `coll` through\n   * the `iteratee` function. The `iteratee` is called with an item from `coll`\n   * and a callback for when it has finished processing. Each of these callbacks\n   * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n   * `iteratee` passes an error to its callback, the main `callback` (for the\n   * `map` function) is immediately called with the error.\n   *\n   * Note, that since this function applies the `iteratee` to each item in\n   * parallel, there is no guarantee that the `iteratee` functions will complete\n   * in order. However, the results array will be in the same order as the\n   * original `coll`.\n   *\n   * If `map` is passed an Object, the results will be an Array.  The results\n   * will roughly be in the order of the original Objects' keys (but this can\n   * vary across JavaScript engines).\n   *\n   * @name map\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - An async function to apply to each item in\n   * `coll`.\n   * The iteratee should complete with the transformed item.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called when all `iteratee`\n   * functions have finished, or an error occurs. Results is an Array of the\n   * transformed items from the `coll`. Invoked with (err, results).\n   * @returns {Promise} a promise, if no callback is passed\n   * @example\n   *\n   * // file1.txt is a file that is 1000 bytes in size\n   * // file2.txt is a file that is 2000 bytes in size\n   * // file3.txt is a file that is 3000 bytes in size\n   * // file4.txt does not exist\n   *\n   * const fileList = ['file1.txt','file2.txt','file3.txt'];\n   * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];\n   *\n   * // asynchronous function that returns the file size in bytes\n   * function getFileSizeInBytes(file, callback) {\n   *     fs.stat(file, function(err, stat) {\n   *         if (err) {\n   *             return callback(err);\n   *         }\n   *         callback(null, stat.size);\n   *     });\n   * }\n   *\n   * // Using callbacks\n   * async.map(fileList, getFileSizeInBytes, function(err, results) {\n   *     if (err) {\n   *         console.log(err);\n   *     } else {\n   *         console.log(results);\n   *         // results is now an array of the file size in bytes for each file, e.g.\n   *         // [ 1000, 2000, 3000]\n   *     }\n   * });\n   *\n   * // Error Handling\n   * async.map(withMissingFileList, getFileSizeInBytes, function(err, results) {\n   *     if (err) {\n   *         console.log(err);\n   *         // [ Error: ENOENT: no such file or directory ]\n   *     } else {\n   *         console.log(results);\n   *     }\n   * });\n   *\n   * // Using Promises\n   * async.map(fileList, getFileSizeInBytes)\n   * .then( results => {\n   *     console.log(results);\n   *     // results is now an array of the file size in bytes for each file, e.g.\n   *     // [ 1000, 2000, 3000]\n   * }).catch( err => {\n   *     console.log(err);\n   * });\n   *\n   * // Error Handling\n   * async.map(withMissingFileList, getFileSizeInBytes)\n   * .then( results => {\n   *     console.log(results);\n   * }).catch( err => {\n   *     console.log(err);\n   *     // [ Error: ENOENT: no such file or directory ]\n   * });\n   *\n   * // Using async/await\n   * async () => {\n   *     try {\n   *         let results = await async.map(fileList, getFileSizeInBytes);\n   *         console.log(results);\n   *         // results is now an array of the file size in bytes for each file, e.g.\n   *         // [ 1000, 2000, 3000]\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   * // Error Handling\n   * async () => {\n   *     try {\n   *         let results = await async.map(withMissingFileList, getFileSizeInBytes);\n   *         console.log(results);\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *         // [ Error: ENOENT: no such file or directory ]\n   *     }\n   * }\n   *\n   */\n  function map(coll, iteratee, callback) {\n    return _asyncMap(eachOf$1, coll, iteratee, callback);\n  }\n  var map$1 = awaitify(map, 3);\n\n  /**\n   * Applies the provided arguments to each function in the array, calling\n   * `callback` after all functions have completed. If you only provide the first\n   * argument, `fns`, then it will return a function which lets you pass in the\n   * arguments as if it were a single function call. If more arguments are\n   * provided, `callback` is required while `args` is still optional. The results\n   * for each of the applied async functions are passed to the final callback\n   * as an array.\n   *\n   * @name applyEach\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @category Control Flow\n   * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s\n   * to all call with the same arguments\n   * @param {...*} [args] - any number of separate arguments to pass to the\n   * function.\n   * @param {Function} [callback] - the final argument should be the callback,\n   * called when all functions have completed processing.\n   * @returns {AsyncFunction} - Returns a function that takes no args other than\n   * an optional callback, that is the result of applying the `args` to each\n   * of the functions.\n   * @example\n   *\n   * const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket')\n   *\n   * appliedFn((err, results) => {\n   *     // results[0] is the results for `enableSearch`\n   *     // results[1] is the results for `updateSchema`\n   * });\n   *\n   * // partial application example:\n   * async.each(\n   *     buckets,\n   *     async (bucket) => async.applyEach([enableSearch, updateSchema], bucket)(),\n   *     callback\n   * );\n   */\n  var applyEach$1 = applyEach(map$1);\n\n  /**\n   * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n   *\n   * @name eachOfSeries\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.eachOf]{@link module:Collections.eachOf}\n   * @alias forEachOfSeries\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - An async function to apply to each item in\n   * `coll`.\n   * Invoked with (item, key, callback).\n   * @param {Function} [callback] - A callback which is called when all `iteratee`\n   * functions have finished, or an error occurs. Invoked with (err).\n   * @returns {Promise} a promise, if a callback is omitted\n   */\n  function eachOfSeries(coll, iteratee, callback) {\n    return eachOfLimit$2(coll, 1, iteratee, callback);\n  }\n  var eachOfSeries$1 = awaitify(eachOfSeries, 3);\n\n  /**\n   * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n   *\n   * @name mapSeries\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.map]{@link module:Collections.map}\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - An async function to apply to each item in\n   * `coll`.\n   * The iteratee should complete with the transformed item.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called when all `iteratee`\n   * functions have finished, or an error occurs. Results is an array of the\n   * transformed items from the `coll`. Invoked with (err, results).\n   * @returns {Promise} a promise, if no callback is passed\n   */\n  function mapSeries(coll, iteratee, callback) {\n    return _asyncMap(eachOfSeries$1, coll, iteratee, callback);\n  }\n  var mapSeries$1 = awaitify(mapSeries, 3);\n\n  /**\n   * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n   *\n   * @name applyEachSeries\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n   * @category Control Flow\n   * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s to all\n   * call with the same arguments\n   * @param {...*} [args] - any number of separate arguments to pass to the\n   * function.\n   * @param {Function} [callback] - the final argument should be the callback,\n   * called when all functions have completed processing.\n   * @returns {AsyncFunction} - A function, that when called, is the result of\n   * appling the `args` to the list of functions.  It takes no args, other than\n   * a callback.\n   */\n  var applyEachSeries = applyEach(mapSeries$1);\n  const PROMISE_SYMBOL = Symbol('promiseCallback');\n  function promiseCallback() {\n    let resolve, reject;\n    function callback(err, ...args) {\n      if (err) return reject(err);\n      resolve(args.length > 1 ? args : args[0]);\n    }\n    callback[PROMISE_SYMBOL] = new Promise((res, rej) => {\n      resolve = res, reject = rej;\n    });\n    return callback;\n  }\n\n  /**\n   * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n   * their requirements. Each function can optionally depend on other functions\n   * being completed first, and each function is run as soon as its requirements\n   * are satisfied.\n   *\n   * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n   * will stop. Further tasks will not execute (so any other functions depending\n   * on it will not run), and the main `callback` is immediately called with the\n   * error.\n   *\n   * {@link AsyncFunction}s also receive an object containing the results of functions which\n   * have completed so far as the first argument, if they have dependencies. If a\n   * task function has no dependencies, it will only be passed a callback.\n   *\n   * @name auto\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @category Control Flow\n   * @param {Object} tasks - An object. Each of its properties is either a\n   * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n   * in the array. The object's key of a property serves as the name of the task\n   * defined by that property, i.e. can be used when specifying requirements for\n   * other tasks. The function receives one or two arguments:\n   * * a `results` object, containing the results of the previously executed\n   *   functions, only passed if the task has any dependencies,\n   * * a `callback(err, result)` function, which must be called when finished,\n   *   passing an `error` (which can be `null`) and the result of the function's\n   *   execution.\n   * @param {number} [concurrency=Infinity] - An optional `integer` for\n   * determining the maximum number of tasks that can be run in parallel. By\n   * default, as many as possible.\n   * @param {Function} [callback] - An optional callback which is called when all\n   * the tasks have been completed. It receives the `err` argument if any `tasks`\n   * pass an error to their callback. Results are always returned; however, if an\n   * error occurs, no further `tasks` will be performed, and the results object\n   * will only contain partial results. Invoked with (err, results).\n   * @returns {Promise} a promise, if a callback is not passed\n   * @example\n   *\n   * //Using Callbacks\n   * async.auto({\n   *     get_data: function(callback) {\n   *         // async code to get some data\n   *         callback(null, 'data', 'converted to array');\n   *     },\n   *     make_folder: function(callback) {\n   *         // async code to create a directory to store a file in\n   *         // this is run at the same time as getting the data\n   *         callback(null, 'folder');\n   *     },\n   *     write_file: ['get_data', 'make_folder', function(results, callback) {\n   *         // once there is some data and the directory exists,\n   *         // write the data to a file in the directory\n   *         callback(null, 'filename');\n   *     }],\n   *     email_link: ['write_file', function(results, callback) {\n   *         // once the file is written let's email a link to it...\n   *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n   *     }]\n   * }, function(err, results) {\n   *     if (err) {\n   *         console.log('err = ', err);\n   *     }\n   *     console.log('results = ', results);\n   *     // results = {\n   *     //     get_data: ['data', 'converted to array']\n   *     //     make_folder; 'folder',\n   *     //     write_file: 'filename'\n   *     //     email_link: { file: 'filename', email: 'user@example.com' }\n   *     // }\n   * });\n   *\n   * //Using Promises\n   * async.auto({\n   *     get_data: function(callback) {\n   *         console.log('in get_data');\n   *         // async code to get some data\n   *         callback(null, 'data', 'converted to array');\n   *     },\n   *     make_folder: function(callback) {\n   *         console.log('in make_folder');\n   *         // async code to create a directory to store a file in\n   *         // this is run at the same time as getting the data\n   *         callback(null, 'folder');\n   *     },\n   *     write_file: ['get_data', 'make_folder', function(results, callback) {\n   *         // once there is some data and the directory exists,\n   *         // write the data to a file in the directory\n   *         callback(null, 'filename');\n   *     }],\n   *     email_link: ['write_file', function(results, callback) {\n   *         // once the file is written let's email a link to it...\n   *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n   *     }]\n   * }).then(results => {\n   *     console.log('results = ', results);\n   *     // results = {\n   *     //     get_data: ['data', 'converted to array']\n   *     //     make_folder; 'folder',\n   *     //     write_file: 'filename'\n   *     //     email_link: { file: 'filename', email: 'user@example.com' }\n   *     // }\n   * }).catch(err => {\n   *     console.log('err = ', err);\n   * });\n   *\n   * //Using async/await\n   * async () => {\n   *     try {\n   *         let results = await async.auto({\n   *             get_data: function(callback) {\n   *                 // async code to get some data\n   *                 callback(null, 'data', 'converted to array');\n   *             },\n   *             make_folder: function(callback) {\n   *                 // async code to create a directory to store a file in\n   *                 // this is run at the same time as getting the data\n   *                 callback(null, 'folder');\n   *             },\n   *             write_file: ['get_data', 'make_folder', function(results, callback) {\n   *                 // once there is some data and the directory exists,\n   *                 // write the data to a file in the directory\n   *                 callback(null, 'filename');\n   *             }],\n   *             email_link: ['write_file', function(results, callback) {\n   *                 // once the file is written let's email a link to it...\n   *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});\n   *             }]\n   *         });\n   *         console.log('results = ', results);\n   *         // results = {\n   *         //     get_data: ['data', 'converted to array']\n   *         //     make_folder; 'folder',\n   *         //     write_file: 'filename'\n   *         //     email_link: { file: 'filename', email: 'user@example.com' }\n   *         // }\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   */\n  function auto(tasks, concurrency, callback) {\n    if (typeof concurrency !== 'number') {\n      // concurrency is optional, shift the args.\n      callback = concurrency;\n      concurrency = null;\n    }\n    callback = once(callback || promiseCallback());\n    var numTasks = Object.keys(tasks).length;\n    if (!numTasks) {\n      return callback(null);\n    }\n    if (!concurrency) {\n      concurrency = numTasks;\n    }\n    var results = {};\n    var runningTasks = 0;\n    var canceled = false;\n    var hasError = false;\n    var listeners = Object.create(null);\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n    Object.keys(tasks).forEach(key => {\n      var task = tasks[key];\n      if (!Array.isArray(task)) {\n        // no dependencies\n        enqueueTask(key, [task]);\n        readyToCheck.push(key);\n        return;\n      }\n      var dependencies = task.slice(0, task.length - 1);\n      var remainingDependencies = dependencies.length;\n      if (remainingDependencies === 0) {\n        enqueueTask(key, task);\n        readyToCheck.push(key);\n        return;\n      }\n      uncheckedDependencies[key] = remainingDependencies;\n      dependencies.forEach(dependencyName => {\n        if (!tasks[dependencyName]) {\n          throw new Error('async.auto task `' + key + '` has a non-existent dependency `' + dependencyName + '` in ' + dependencies.join(', '));\n        }\n        addListener(dependencyName, () => {\n          remainingDependencies--;\n          if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n          }\n        });\n      });\n    });\n    checkForDeadlocks();\n    processQueue();\n    function enqueueTask(key, task) {\n      readyTasks.push(() => runTask(key, task));\n    }\n    function processQueue() {\n      if (canceled) return;\n      if (readyTasks.length === 0 && runningTasks === 0) {\n        return callback(null, results);\n      }\n      while (readyTasks.length && runningTasks < concurrency) {\n        var run = readyTasks.shift();\n        run();\n      }\n    }\n    function addListener(taskName, fn) {\n      var taskListeners = listeners[taskName];\n      if (!taskListeners) {\n        taskListeners = listeners[taskName] = [];\n      }\n      taskListeners.push(fn);\n    }\n    function taskComplete(taskName) {\n      var taskListeners = listeners[taskName] || [];\n      taskListeners.forEach(fn => fn());\n      processQueue();\n    }\n    function runTask(key, task) {\n      if (hasError) return;\n      var taskCallback = onlyOnce((err, ...result) => {\n        runningTasks--;\n        if (err === false) {\n          canceled = true;\n          return;\n        }\n        if (result.length < 2) {\n          [result] = result;\n        }\n        if (err) {\n          var safeResults = {};\n          Object.keys(results).forEach(rkey => {\n            safeResults[rkey] = results[rkey];\n          });\n          safeResults[key] = result;\n          hasError = true;\n          listeners = Object.create(null);\n          if (canceled) return;\n          callback(err, safeResults);\n        } else {\n          results[key] = result;\n          taskComplete(key);\n        }\n      });\n      runningTasks++;\n      var taskFn = wrapAsync(task[task.length - 1]);\n      if (task.length > 1) {\n        taskFn(results, taskCallback);\n      } else {\n        taskFn(taskCallback);\n      }\n    }\n    function checkForDeadlocks() {\n      // Kahn's algorithm\n      // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n      // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n      var currentTask;\n      var counter = 0;\n      while (readyToCheck.length) {\n        currentTask = readyToCheck.pop();\n        counter++;\n        getDependents(currentTask).forEach(dependent => {\n          if (--uncheckedDependencies[dependent] === 0) {\n            readyToCheck.push(dependent);\n          }\n        });\n      }\n      if (counter !== numTasks) {\n        throw new Error('async.auto cannot execute tasks due to a recursive dependency');\n      }\n    }\n    function getDependents(taskName) {\n      var result = [];\n      Object.keys(tasks).forEach(key => {\n        const task = tasks[key];\n        if (Array.isArray(task) && task.indexOf(taskName) >= 0) {\n          result.push(key);\n        }\n      });\n      return result;\n    }\n    return callback[PROMISE_SYMBOL];\n  }\n  var FN_ARGS = /^(?:async\\s+)?(?:function)?\\s*\\w*\\s*\\(\\s*([^)]+)\\s*\\)(?:\\s*{)/;\n  var ARROW_FN_ARGS = /^(?:async\\s+)?\\(?\\s*([^)=]+)\\s*\\)?(?:\\s*=>)/;\n  var FN_ARG_SPLIT = /,/;\n  var FN_ARG = /(=.+)?(\\s*)$/;\n  function stripComments(string) {\n    let stripped = '';\n    let index = 0;\n    let endBlockComment = string.indexOf('*/');\n    while (index < string.length) {\n      if (string[index] === '/' && string[index + 1] === '/') {\n        // inline comment\n        let endIndex = string.indexOf('\\n', index);\n        index = endIndex === -1 ? string.length : endIndex;\n      } else if (endBlockComment !== -1 && string[index] === '/' && string[index + 1] === '*') {\n        // block comment\n        let endIndex = string.indexOf('*/', index);\n        if (endIndex !== -1) {\n          index = endIndex + 2;\n          endBlockComment = string.indexOf('*/', index);\n        } else {\n          stripped += string[index];\n          index++;\n        }\n      } else {\n        stripped += string[index];\n        index++;\n      }\n    }\n    return stripped;\n  }\n  function parseParams(func) {\n    const src = stripComments(func.toString());\n    let match = src.match(FN_ARGS);\n    if (!match) {\n      match = src.match(ARROW_FN_ARGS);\n    }\n    if (!match) throw new Error('could not parse args in autoInject\\nSource:\\n' + src);\n    let [, args] = match;\n    return args.replace(/\\s/g, '').split(FN_ARG_SPLIT).map(arg => arg.replace(FN_ARG, '').trim());\n  }\n\n  /**\n   * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n   * tasks are specified as parameters to the function, after the usual callback\n   * parameter, with the parameter names matching the names of the tasks it\n   * depends on. This can provide even more readable task graphs which can be\n   * easier to maintain.\n   *\n   * If a final callback is specified, the task results are similarly injected,\n   * specified as named parameters after the initial error parameter.\n   *\n   * The autoInject function is purely syntactic sugar and its semantics are\n   * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n   *\n   * @name autoInject\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @see [async.auto]{@link module:ControlFlow.auto}\n   * @category Control Flow\n   * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n   * the form 'func([dependencies...], callback). The object's key of a property\n   * serves as the name of the task defined by that property, i.e. can be used\n   * when specifying requirements for other tasks.\n   * * The `callback` parameter is a `callback(err, result)` which must be called\n   *   when finished, passing an `error` (which can be `null`) and the result of\n   *   the function's execution. The remaining parameters name other tasks on\n   *   which the task is dependent, and the results from those tasks are the\n   *   arguments of those parameters.\n   * @param {Function} [callback] - An optional callback which is called when all\n   * the tasks have been completed. It receives the `err` argument if any `tasks`\n   * pass an error to their callback, and a `results` object with any completed\n   * task results, similar to `auto`.\n   * @returns {Promise} a promise, if no callback is passed\n   * @example\n   *\n   * //  The example from `auto` can be rewritten as follows:\n   * async.autoInject({\n   *     get_data: function(callback) {\n   *         // async code to get some data\n   *         callback(null, 'data', 'converted to array');\n   *     },\n   *     make_folder: function(callback) {\n   *         // async code to create a directory to store a file in\n   *         // this is run at the same time as getting the data\n   *         callback(null, 'folder');\n   *     },\n   *     write_file: function(get_data, make_folder, callback) {\n   *         // once there is some data and the directory exists,\n   *         // write the data to a file in the directory\n   *         callback(null, 'filename');\n   *     },\n   *     email_link: function(write_file, callback) {\n   *         // once the file is written let's email a link to it...\n   *         // write_file contains the filename returned by write_file.\n   *         callback(null, {'file':write_file, 'email':'user@example.com'});\n   *     }\n   * }, function(err, results) {\n   *     console.log('err = ', err);\n   *     console.log('email_link = ', results.email_link);\n   * });\n   *\n   * // If you are using a JS minifier that mangles parameter names, `autoInject`\n   * // will not work with plain functions, since the parameter names will be\n   * // collapsed to a single letter identifier.  To work around this, you can\n   * // explicitly specify the names of the parameters your task function needs\n   * // in an array, similar to Angular.js dependency injection.\n   *\n   * // This still has an advantage over plain `auto`, since the results a task\n   * // depends on are still spread into arguments.\n   * async.autoInject({\n   *     //...\n   *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n   *         callback(null, 'filename');\n   *     }],\n   *     email_link: ['write_file', function(write_file, callback) {\n   *         callback(null, {'file':write_file, 'email':'user@example.com'});\n   *     }]\n   *     //...\n   * }, function(err, results) {\n   *     console.log('err = ', err);\n   *     console.log('email_link = ', results.email_link);\n   * });\n   */\n  function autoInject(tasks, callback) {\n    var newTasks = {};\n    Object.keys(tasks).forEach(key => {\n      var taskFn = tasks[key];\n      var params;\n      var fnIsAsync = isAsync(taskFn);\n      var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;\n      if (Array.isArray(taskFn)) {\n        params = [...taskFn];\n        taskFn = params.pop();\n        newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n      } else if (hasNoDeps) {\n        // no dependencies, use the function as-is\n        newTasks[key] = taskFn;\n      } else {\n        params = parseParams(taskFn);\n        if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n          throw new Error(\"autoInject task functions require explicit parameters.\");\n        }\n\n        // remove callback param\n        if (!fnIsAsync) params.pop();\n        newTasks[key] = params.concat(newTask);\n      }\n      function newTask(results, taskCb) {\n        var newArgs = params.map(name => results[name]);\n        newArgs.push(taskCb);\n        wrapAsync(taskFn)(...newArgs);\n      }\n    });\n    return auto(newTasks, callback);\n  }\n\n  // Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n  // used for queues. This implementation assumes that the node provided by the user can be modified\n  // to adjust the next and last properties. We implement only the minimal functionality\n  // for queue support.\n  class DLL {\n    constructor() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n    removeLink(node) {\n      if (node.prev) node.prev.next = node.next;else this.head = node.next;\n      if (node.next) node.next.prev = node.prev;else this.tail = node.prev;\n      node.prev = node.next = null;\n      this.length -= 1;\n      return node;\n    }\n    empty() {\n      while (this.head) this.shift();\n      return this;\n    }\n    insertAfter(node, newNode) {\n      newNode.prev = node;\n      newNode.next = node.next;\n      if (node.next) node.next.prev = newNode;else this.tail = newNode;\n      node.next = newNode;\n      this.length += 1;\n    }\n    insertBefore(node, newNode) {\n      newNode.prev = node.prev;\n      newNode.next = node;\n      if (node.prev) node.prev.next = newNode;else this.head = newNode;\n      node.prev = newNode;\n      this.length += 1;\n    }\n    unshift(node) {\n      if (this.head) this.insertBefore(this.head, node);else setInitial(this, node);\n    }\n    push(node) {\n      if (this.tail) this.insertAfter(this.tail, node);else setInitial(this, node);\n    }\n    shift() {\n      return this.head && this.removeLink(this.head);\n    }\n    pop() {\n      return this.tail && this.removeLink(this.tail);\n    }\n    toArray() {\n      return [...this];\n    }\n    *[Symbol.iterator]() {\n      var cur = this.head;\n      while (cur) {\n        yield cur.data;\n        cur = cur.next;\n      }\n    }\n    remove(testFn) {\n      var curr = this.head;\n      while (curr) {\n        var {\n          next\n        } = curr;\n        if (testFn(curr)) {\n          this.removeLink(curr);\n        }\n        curr = next;\n      }\n      return this;\n    }\n  }\n  function setInitial(dll, node) {\n    dll.length = 1;\n    dll.head = dll.tail = node;\n  }\n  function queue(worker, concurrency, payload) {\n    if (concurrency == null) {\n      concurrency = 1;\n    } else if (concurrency === 0) {\n      throw new RangeError('Concurrency must not be zero');\n    }\n    var _worker = wrapAsync(worker);\n    var numRunning = 0;\n    var workersList = [];\n    const events = {\n      error: [],\n      drain: [],\n      saturated: [],\n      unsaturated: [],\n      empty: []\n    };\n    function on(event, handler) {\n      events[event].push(handler);\n    }\n    function once(event, handler) {\n      const handleAndRemove = (...args) => {\n        off(event, handleAndRemove);\n        handler(...args);\n      };\n      events[event].push(handleAndRemove);\n    }\n    function off(event, handler) {\n      if (!event) return Object.keys(events).forEach(ev => events[ev] = []);\n      if (!handler) return events[event] = [];\n      events[event] = events[event].filter(ev => ev !== handler);\n    }\n    function trigger(event, ...args) {\n      events[event].forEach(handler => handler(...args));\n    }\n    var processingScheduled = false;\n    function _insert(data, insertAtFront, rejectOnError, callback) {\n      if (callback != null && typeof callback !== 'function') {\n        throw new Error('task callback must be a function');\n      }\n      q.started = true;\n      var res, rej;\n      function promiseCallback(err, ...args) {\n        // we don't care about the error, let the global error handler\n        // deal with it\n        if (err) return rejectOnError ? rej(err) : res();\n        if (args.length <= 1) return res(args[0]);\n        res(args);\n      }\n      var item = q._createTaskItem(data, rejectOnError ? promiseCallback : callback || promiseCallback);\n      if (insertAtFront) {\n        q._tasks.unshift(item);\n      } else {\n        q._tasks.push(item);\n      }\n      if (!processingScheduled) {\n        processingScheduled = true;\n        setImmediate$1(() => {\n          processingScheduled = false;\n          q.process();\n        });\n      }\n      if (rejectOnError || !callback) {\n        return new Promise((resolve, reject) => {\n          res = resolve;\n          rej = reject;\n        });\n      }\n    }\n    function _createCB(tasks) {\n      return function (err, ...args) {\n        numRunning -= 1;\n        for (var i = 0, l = tasks.length; i < l; i++) {\n          var task = tasks[i];\n          var index = workersList.indexOf(task);\n          if (index === 0) {\n            workersList.shift();\n          } else if (index > 0) {\n            workersList.splice(index, 1);\n          }\n          task.callback(err, ...args);\n          if (err != null) {\n            trigger('error', err, task.data);\n          }\n        }\n        if (numRunning <= q.concurrency - q.buffer) {\n          trigger('unsaturated');\n        }\n        if (q.idle()) {\n          trigger('drain');\n        }\n        q.process();\n      };\n    }\n    function _maybeDrain(data) {\n      if (data.length === 0 && q.idle()) {\n        // call drain immediately if there are no tasks\n        setImmediate$1(() => trigger('drain'));\n        return true;\n      }\n      return false;\n    }\n    const eventMethod = name => handler => {\n      if (!handler) {\n        return new Promise((resolve, reject) => {\n          once(name, (err, data) => {\n            if (err) return reject(err);\n            resolve(data);\n          });\n        });\n      }\n      off(name);\n      on(name, handler);\n    };\n    var isProcessing = false;\n    var q = {\n      _tasks: new DLL(),\n      _createTaskItem(data, callback) {\n        return {\n          data,\n          callback\n        };\n      },\n      *[Symbol.iterator]() {\n        yield* q._tasks[Symbol.iterator]();\n      },\n      concurrency,\n      payload,\n      buffer: concurrency / 4,\n      started: false,\n      paused: false,\n      push(data, callback) {\n        if (Array.isArray(data)) {\n          if (_maybeDrain(data)) return;\n          return data.map(datum => _insert(datum, false, false, callback));\n        }\n        return _insert(data, false, false, callback);\n      },\n      pushAsync(data, callback) {\n        if (Array.isArray(data)) {\n          if (_maybeDrain(data)) return;\n          return data.map(datum => _insert(datum, false, true, callback));\n        }\n        return _insert(data, false, true, callback);\n      },\n      kill() {\n        off();\n        q._tasks.empty();\n      },\n      unshift(data, callback) {\n        if (Array.isArray(data)) {\n          if (_maybeDrain(data)) return;\n          return data.map(datum => _insert(datum, true, false, callback));\n        }\n        return _insert(data, true, false, callback);\n      },\n      unshiftAsync(data, callback) {\n        if (Array.isArray(data)) {\n          if (_maybeDrain(data)) return;\n          return data.map(datum => _insert(datum, true, true, callback));\n        }\n        return _insert(data, true, true, callback);\n      },\n      remove(testFn) {\n        q._tasks.remove(testFn);\n      },\n      process() {\n        // Avoid trying to start too many processing operations. This can occur\n        // when callbacks resolve synchronously (#1267).\n        if (isProcessing) {\n          return;\n        }\n        isProcessing = true;\n        while (!q.paused && numRunning < q.concurrency && q._tasks.length) {\n          var tasks = [],\n            data = [];\n          var l = q._tasks.length;\n          if (q.payload) l = Math.min(l, q.payload);\n          for (var i = 0; i < l; i++) {\n            var node = q._tasks.shift();\n            tasks.push(node);\n            workersList.push(node);\n            data.push(node.data);\n          }\n          numRunning += 1;\n          if (q._tasks.length === 0) {\n            trigger('empty');\n          }\n          if (numRunning === q.concurrency) {\n            trigger('saturated');\n          }\n          var cb = onlyOnce(_createCB(tasks));\n          _worker(data, cb);\n        }\n        isProcessing = false;\n      },\n      length() {\n        return q._tasks.length;\n      },\n      running() {\n        return numRunning;\n      },\n      workersList() {\n        return workersList;\n      },\n      idle() {\n        return q._tasks.length + numRunning === 0;\n      },\n      pause() {\n        q.paused = true;\n      },\n      resume() {\n        if (q.paused === false) {\n          return;\n        }\n        q.paused = false;\n        setImmediate$1(q.process);\n      }\n    };\n    // define these as fixed properties, so people get useful errors when updating\n    Object.defineProperties(q, {\n      saturated: {\n        writable: false,\n        value: eventMethod('saturated')\n      },\n      unsaturated: {\n        writable: false,\n        value: eventMethod('unsaturated')\n      },\n      empty: {\n        writable: false,\n        value: eventMethod('empty')\n      },\n      drain: {\n        writable: false,\n        value: eventMethod('drain')\n      },\n      error: {\n        writable: false,\n        value: eventMethod('error')\n      }\n    });\n    return q;\n  }\n\n  /**\n   * Creates a `cargo` object with the specified payload. Tasks added to the\n   * cargo will be processed altogether (up to the `payload` limit). If the\n   * `worker` is in progress, the task is queued until it becomes available. Once\n   * the `worker` has completed some tasks, each callback of those tasks is\n   * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n   * for how `cargo` and `queue` work.\n   *\n   * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n   * at a time, cargo passes an array of tasks to a single worker, repeating\n   * when the worker is finished.\n   *\n   * @name cargo\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @see [async.queue]{@link module:ControlFlow.queue}\n   * @category Control Flow\n   * @param {AsyncFunction} worker - An asynchronous function for processing an array\n   * of queued tasks. Invoked with `(tasks, callback)`.\n   * @param {number} [payload=Infinity] - An optional `integer` for determining\n   * how many tasks should be processed per round; if omitted, the default is\n   * unlimited.\n   * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can\n   * attached as certain properties to listen for specific events during the\n   * lifecycle of the cargo and inner queue.\n   * @example\n   *\n   * // create a cargo object with payload 2\n   * var cargo = async.cargo(function(tasks, callback) {\n   *     for (var i=0; i<tasks.length; i++) {\n   *         console.log('hello ' + tasks[i].name);\n   *     }\n   *     callback();\n   * }, 2);\n   *\n   * // add some items\n   * cargo.push({name: 'foo'}, function(err) {\n   *     console.log('finished processing foo');\n   * });\n   * cargo.push({name: 'bar'}, function(err) {\n   *     console.log('finished processing bar');\n   * });\n   * await cargo.push({name: 'baz'});\n   * console.log('finished processing baz');\n   */\n  function cargo(worker, payload) {\n    return queue(worker, 1, payload);\n  }\n\n  /**\n   * Creates a `cargoQueue` object with the specified payload. Tasks added to the\n   * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.\n   * If the all `workers` are in progress, the task is queued until one becomes available. Once\n   * a `worker` has completed some tasks, each callback of those tasks is\n   * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n   * for how `cargo` and `queue` work.\n   *\n   * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n   * at a time, and [`cargo`]{@link module:ControlFlow.cargo} passes an array of tasks to a single worker,\n   * the cargoQueue passes an array of tasks to multiple parallel workers.\n   *\n   * @name cargoQueue\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @see [async.queue]{@link module:ControlFlow.queue}\n   * @see [async.cargo]{@link module:ControlFLow.cargo}\n   * @category Control Flow\n   * @param {AsyncFunction} worker - An asynchronous function for processing an array\n   * of queued tasks. Invoked with `(tasks, callback)`.\n   * @param {number} [concurrency=1] - An `integer` for determining how many\n   * `worker` functions should be run in parallel.  If omitted, the concurrency\n   * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n   * @param {number} [payload=Infinity] - An optional `integer` for determining\n   * how many tasks should be processed per round; if omitted, the default is\n   * unlimited.\n   * @returns {module:ControlFlow.QueueObject} A cargoQueue object to manage the tasks. Callbacks can\n   * attached as certain properties to listen for specific events during the\n   * lifecycle of the cargoQueue and inner queue.\n   * @example\n   *\n   * // create a cargoQueue object with payload 2 and concurrency 2\n   * var cargoQueue = async.cargoQueue(function(tasks, callback) {\n   *     for (var i=0; i<tasks.length; i++) {\n   *         console.log('hello ' + tasks[i].name);\n   *     }\n   *     callback();\n   * }, 2, 2);\n   *\n   * // add some items\n   * cargoQueue.push({name: 'foo'}, function(err) {\n   *     console.log('finished processing foo');\n   * });\n   * cargoQueue.push({name: 'bar'}, function(err) {\n   *     console.log('finished processing bar');\n   * });\n   * cargoQueue.push({name: 'baz'}, function(err) {\n   *     console.log('finished processing baz');\n   * });\n   * cargoQueue.push({name: 'boo'}, function(err) {\n   *     console.log('finished processing boo');\n   * });\n   */\n  function cargo$1(worker, concurrency, payload) {\n    return queue(worker, concurrency, payload);\n  }\n\n  /**\n   * Reduces `coll` into a single value using an async `iteratee` to return each\n   * successive step. `memo` is the initial state of the reduction. This function\n   * only operates in series.\n   *\n   * For performance reasons, it may make sense to split a call to this function\n   * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n   * results. This function is for situations where each step in the reduction\n   * needs to be async; if you can get the data before reducing it, then it's\n   * probably a good idea to do so.\n   *\n   * @name reduce\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @alias inject\n   * @alias foldl\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {*} memo - The initial state of the reduction.\n   * @param {AsyncFunction} iteratee - A function applied to each item in the\n   * array to produce the next step in the reduction.\n   * The `iteratee` should complete with the next state of the reduction.\n   * If the iteratee completes with an error, the reduction is stopped and the\n   * main `callback` is immediately called with the error.\n   * Invoked with (memo, item, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished. Result is the reduced value. Invoked with\n   * (err, result).\n   * @returns {Promise} a promise, if no callback is passed\n   * @example\n   *\n   * // file1.txt is a file that is 1000 bytes in size\n   * // file2.txt is a file that is 2000 bytes in size\n   * // file3.txt is a file that is 3000 bytes in size\n   * // file4.txt does not exist\n   *\n   * const fileList = ['file1.txt','file2.txt','file3.txt'];\n   * const withMissingFileList = ['file1.txt','file2.txt','file3.txt', 'file4.txt'];\n   *\n   * // asynchronous function that computes the file size in bytes\n   * // file size is added to the memoized value, then returned\n   * function getFileSizeInBytes(memo, file, callback) {\n   *     fs.stat(file, function(err, stat) {\n   *         if (err) {\n   *             return callback(err);\n   *         }\n   *         callback(null, memo + stat.size);\n   *     });\n   * }\n   *\n   * // Using callbacks\n   * async.reduce(fileList, 0, getFileSizeInBytes, function(err, result) {\n   *     if (err) {\n   *         console.log(err);\n   *     } else {\n   *         console.log(result);\n   *         // 6000\n   *         // which is the sum of the file sizes of the three files\n   *     }\n   * });\n   *\n   * // Error Handling\n   * async.reduce(withMissingFileList, 0, getFileSizeInBytes, function(err, result) {\n   *     if (err) {\n   *         console.log(err);\n   *         // [ Error: ENOENT: no such file or directory ]\n   *     } else {\n   *         console.log(result);\n   *     }\n   * });\n   *\n   * // Using Promises\n   * async.reduce(fileList, 0, getFileSizeInBytes)\n   * .then( result => {\n   *     console.log(result);\n   *     // 6000\n   *     // which is the sum of the file sizes of the three files\n   * }).catch( err => {\n   *     console.log(err);\n   * });\n   *\n   * // Error Handling\n   * async.reduce(withMissingFileList, 0, getFileSizeInBytes)\n   * .then( result => {\n   *     console.log(result);\n   * }).catch( err => {\n   *     console.log(err);\n   *     // [ Error: ENOENT: no such file or directory ]\n   * });\n   *\n   * // Using async/await\n   * async () => {\n   *     try {\n   *         let result = await async.reduce(fileList, 0, getFileSizeInBytes);\n   *         console.log(result);\n   *         // 6000\n   *         // which is the sum of the file sizes of the three files\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   * // Error Handling\n   * async () => {\n   *     try {\n   *         let result = await async.reduce(withMissingFileList, 0, getFileSizeInBytes);\n   *         console.log(result);\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *         // [ Error: ENOENT: no such file or directory ]\n   *     }\n   * }\n   *\n   */\n  function reduce(coll, memo, iteratee, callback) {\n    callback = once(callback);\n    var _iteratee = wrapAsync(iteratee);\n    return eachOfSeries$1(coll, (x, i, iterCb) => {\n      _iteratee(memo, x, (err, v) => {\n        memo = v;\n        iterCb(err);\n      });\n    }, err => callback(err, memo));\n  }\n  var reduce$1 = awaitify(reduce, 4);\n\n  /**\n   * Version of the compose function that is more natural to read. Each function\n   * consumes the return value of the previous function. It is the equivalent of\n   * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n   *\n   * Each function is executed with the `this` binding of the composed function.\n   *\n   * @name seq\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @see [async.compose]{@link module:ControlFlow.compose}\n   * @category Control Flow\n   * @param {...AsyncFunction} functions - the asynchronous functions to compose\n   * @returns {Function} a function that composes the `functions` in order\n   * @example\n   *\n   * // Requires lodash (or underscore), express3 and dresende's orm2.\n   * // Part of an app, that fetches cats of the logged user.\n   * // This example uses `seq` function to avoid overnesting and error\n   * // handling clutter.\n   * app.get('/cats', function(request, response) {\n   *     var User = request.models.User;\n   *     async.seq(\n   *         User.get.bind(User),  // 'User.get' has signature (id, callback(err, data))\n   *         function(user, fn) {\n   *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n   *         }\n   *     )(req.session.user_id, function (err, cats) {\n   *         if (err) {\n   *             console.error(err);\n   *             response.json({ status: 'error', message: err.message });\n   *         } else {\n   *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n   *         }\n   *     });\n   * });\n   */\n  function seq(...functions) {\n    var _functions = functions.map(wrapAsync);\n    return function (...args) {\n      var that = this;\n      var cb = args[args.length - 1];\n      if (typeof cb == 'function') {\n        args.pop();\n      } else {\n        cb = promiseCallback();\n      }\n      reduce$1(_functions, args, (newargs, fn, iterCb) => {\n        fn.apply(that, newargs.concat((err, ...nextargs) => {\n          iterCb(err, nextargs);\n        }));\n      }, (err, results) => cb(err, ...results));\n      return cb[PROMISE_SYMBOL];\n    };\n  }\n\n  /**\n   * Creates a function which is a composition of the passed asynchronous\n   * functions. Each function consumes the return value of the function that\n   * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n   * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n   *\n   * If the last argument to the composed function is not a function, a promise\n   * is returned when you call it.\n   *\n   * Each function is executed with the `this` binding of the composed function.\n   *\n   * @name compose\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @category Control Flow\n   * @param {...AsyncFunction} functions - the asynchronous functions to compose\n   * @returns {Function} an asynchronous function that is the composed\n   * asynchronous `functions`\n   * @example\n   *\n   * function add1(n, callback) {\n   *     setTimeout(function () {\n   *         callback(null, n + 1);\n   *     }, 10);\n   * }\n   *\n   * function mul3(n, callback) {\n   *     setTimeout(function () {\n   *         callback(null, n * 3);\n   *     }, 10);\n   * }\n   *\n   * var add1mul3 = async.compose(mul3, add1);\n   * add1mul3(4, function (err, result) {\n   *     // result now equals 15\n   * });\n   */\n  function compose(...args) {\n    return seq(...args.reverse());\n  }\n\n  /**\n   * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n   *\n   * @name mapLimit\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.map]{@link module:Collections.map}\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {number} limit - The maximum number of async operations at a time.\n   * @param {AsyncFunction} iteratee - An async function to apply to each item in\n   * `coll`.\n   * The iteratee should complete with the transformed item.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called when all `iteratee`\n   * functions have finished, or an error occurs. Results is an array of the\n   * transformed items from the `coll`. Invoked with (err, results).\n   * @returns {Promise} a promise, if no callback is passed\n   */\n  function mapLimit(coll, limit, iteratee, callback) {\n    return _asyncMap(eachOfLimit(limit), coll, iteratee, callback);\n  }\n  var mapLimit$1 = awaitify(mapLimit, 4);\n\n  /**\n   * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.\n   *\n   * @name concatLimit\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.concat]{@link module:Collections.concat}\n   * @category Collection\n   * @alias flatMapLimit\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {number} limit - The maximum number of async operations at a time.\n   * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n   * which should use an array as its result. Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished, or an error occurs. Results is an array\n   * containing the concatenated results of the `iteratee` function. Invoked with\n   * (err, results).\n   * @returns A Promise, if no callback is passed\n   */\n  function concatLimit(coll, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return mapLimit$1(coll, limit, (val, iterCb) => {\n      _iteratee(val, (err, ...args) => {\n        if (err) return iterCb(err);\n        return iterCb(err, args);\n      });\n    }, (err, mapResults) => {\n      var result = [];\n      for (var i = 0; i < mapResults.length; i++) {\n        if (mapResults[i]) {\n          result = result.concat(...mapResults[i]);\n        }\n      }\n      return callback(err, result);\n    });\n  }\n  var concatLimit$1 = awaitify(concatLimit, 4);\n\n  /**\n   * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n   * the concatenated list. The `iteratee`s are called in parallel, and the\n   * results are concatenated as they return. The results array will be returned in\n   * the original order of `coll` passed to the `iteratee` function.\n   *\n   * @name concat\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @category Collection\n   * @alias flatMap\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n   * which should use an array as its result. Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished, or an error occurs. Results is an array\n   * containing the concatenated results of the `iteratee` function. Invoked with\n   * (err, results).\n   * @returns A Promise, if no callback is passed\n   * @example\n   *\n   * // dir1 is a directory that contains file1.txt, file2.txt\n   * // dir2 is a directory that contains file3.txt, file4.txt\n   * // dir3 is a directory that contains file5.txt\n   * // dir4 does not exist\n   *\n   * let directoryList = ['dir1','dir2','dir3'];\n   * let withMissingDirectoryList = ['dir1','dir2','dir3', 'dir4'];\n   *\n   * // Using callbacks\n   * async.concat(directoryList, fs.readdir, function(err, results) {\n   *    if (err) {\n   *        console.log(err);\n   *    } else {\n   *        console.log(results);\n   *        // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n   *    }\n   * });\n   *\n   * // Error Handling\n   * async.concat(withMissingDirectoryList, fs.readdir, function(err, results) {\n   *    if (err) {\n   *        console.log(err);\n   *        // [ Error: ENOENT: no such file or directory ]\n   *        // since dir4 does not exist\n   *    } else {\n   *        console.log(results);\n   *    }\n   * });\n   *\n   * // Using Promises\n   * async.concat(directoryList, fs.readdir)\n   * .then(results => {\n   *     console.log(results);\n   *     // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n   * }).catch(err => {\n   *      console.log(err);\n   * });\n   *\n   * // Error Handling\n   * async.concat(withMissingDirectoryList, fs.readdir)\n   * .then(results => {\n   *     console.log(results);\n   * }).catch(err => {\n   *     console.log(err);\n   *     // [ Error: ENOENT: no such file or directory ]\n   *     // since dir4 does not exist\n   * });\n   *\n   * // Using async/await\n   * async () => {\n   *     try {\n   *         let results = await async.concat(directoryList, fs.readdir);\n   *         console.log(results);\n   *         // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n   *     } catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   * // Error Handling\n   * async () => {\n   *     try {\n   *         let results = await async.concat(withMissingDirectoryList, fs.readdir);\n   *         console.log(results);\n   *     } catch (err) {\n   *         console.log(err);\n   *         // [ Error: ENOENT: no such file or directory ]\n   *         // since dir4 does not exist\n   *     }\n   * }\n   *\n   */\n  function concat(coll, iteratee, callback) {\n    return concatLimit$1(coll, Infinity, iteratee, callback);\n  }\n  var concat$1 = awaitify(concat, 3);\n\n  /**\n   * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n   *\n   * @name concatSeries\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.concat]{@link module:Collections.concat}\n   * @category Collection\n   * @alias flatMapSeries\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n   * The iteratee should complete with an array an array of results.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished, or an error occurs. Results is an array\n   * containing the concatenated results of the `iteratee` function. Invoked with\n   * (err, results).\n   * @returns A Promise, if no callback is passed\n   */\n  function concatSeries(coll, iteratee, callback) {\n    return concatLimit$1(coll, 1, iteratee, callback);\n  }\n  var concatSeries$1 = awaitify(concatSeries, 3);\n\n  /**\n   * Returns a function that when called, calls-back with the values provided.\n   * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n   * [`auto`]{@link module:ControlFlow.auto}.\n   *\n   * @name constant\n   * @static\n   * @memberOf module:Utils\n   * @method\n   * @category Util\n   * @param {...*} arguments... - Any number of arguments to automatically invoke\n   * callback with.\n   * @returns {AsyncFunction} Returns a function that when invoked, automatically\n   * invokes the callback with the previous given arguments.\n   * @example\n   *\n   * async.waterfall([\n   *     async.constant(42),\n   *     function (value, next) {\n   *         // value === 42\n   *     },\n   *     //...\n   * ], callback);\n   *\n   * async.waterfall([\n   *     async.constant(filename, \"utf8\"),\n   *     fs.readFile,\n   *     function (fileData, next) {\n   *         //...\n   *     }\n   *     //...\n   * ], callback);\n   *\n   * async.auto({\n   *     hostname: async.constant(\"https://server.net/\"),\n   *     port: findFreePort,\n   *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n   *         startServer(options, cb);\n   *     }],\n   *     //...\n   * }, callback);\n   */\n  function constant(...args) {\n    return function (...ignoredArgs /*, callback*/) {\n      var callback = ignoredArgs.pop();\n      return callback(null, ...args);\n    };\n  }\n  function _createTester(check, getResult) {\n    return (eachfn, arr, _iteratee, cb) => {\n      var testPassed = false;\n      var testResult;\n      const iteratee = wrapAsync(_iteratee);\n      eachfn(arr, (value, _, callback) => {\n        iteratee(value, (err, result) => {\n          if (err || err === false) return callback(err);\n          if (check(result) && !testResult) {\n            testPassed = true;\n            testResult = getResult(true, value);\n            return callback(null, breakLoop);\n          }\n          callback();\n        });\n      }, err => {\n        if (err) return cb(err);\n        cb(null, testPassed ? testResult : getResult(false));\n      });\n    };\n  }\n\n  /**\n   * Returns the first value in `coll` that passes an async truth test. The\n   * `iteratee` is applied in parallel, meaning the first iteratee to return\n   * `true` will fire the detect `callback` with that result. That means the\n   * result might not be the first item in the original `coll` (in terms of order)\n   * that passes the test.\n    * If order within the original `coll` is important, then look at\n   * [`detectSeries`]{@link module:Collections.detectSeries}.\n   *\n   * @name detect\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @alias find\n   * @category Collections\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n   * The iteratee must complete with a boolean value as its result.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called as soon as any\n   * iteratee returns `true`, or after all the `iteratee` functions have finished.\n   * Result will be the first item in the array that passes the truth test\n   * (iteratee) or the value `undefined` if none passed. Invoked with\n   * (err, result).\n   * @returns {Promise} a promise, if a callback is omitted\n   * @example\n   *\n   * // dir1 is a directory that contains file1.txt, file2.txt\n   * // dir2 is a directory that contains file3.txt, file4.txt\n   * // dir3 is a directory that contains file5.txt\n   *\n   * // asynchronous function that checks if a file exists\n   * function fileExists(file, callback) {\n   *    fs.access(file, fs.constants.F_OK, (err) => {\n   *        callback(null, !err);\n   *    });\n   * }\n   *\n   * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists,\n   *    function(err, result) {\n   *        console.log(result);\n   *        // dir1/file1.txt\n   *        // result now equals the first file in the list that exists\n   *    }\n   *);\n   *\n   * // Using Promises\n   * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists)\n   * .then(result => {\n   *     console.log(result);\n   *     // dir1/file1.txt\n   *     // result now equals the first file in the list that exists\n   * }).catch(err => {\n   *     console.log(err);\n   * });\n   *\n   * // Using async/await\n   * async () => {\n   *     try {\n   *         let result = await async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists);\n   *         console.log(result);\n   *         // dir1/file1.txt\n   *         // result now equals the file in the list that exists\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   */\n  function detect(coll, iteratee, callback) {\n    return _createTester(bool => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);\n  }\n  var detect$1 = awaitify(detect, 3);\n\n  /**\n   * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n   * time.\n   *\n   * @name detectLimit\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.detect]{@link module:Collections.detect}\n   * @alias findLimit\n   * @category Collections\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {number} limit - The maximum number of async operations at a time.\n   * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n   * The iteratee must complete with a boolean value as its result.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called as soon as any\n   * iteratee returns `true`, or after all the `iteratee` functions have finished.\n   * Result will be the first item in the array that passes the truth test\n   * (iteratee) or the value `undefined` if none passed. Invoked with\n   * (err, result).\n   * @returns {Promise} a promise, if a callback is omitted\n   */\n  function detectLimit(coll, limit, iteratee, callback) {\n    return _createTester(bool => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback);\n  }\n  var detectLimit$1 = awaitify(detectLimit, 4);\n\n  /**\n   * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n   *\n   * @name detectSeries\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.detect]{@link module:Collections.detect}\n   * @alias findSeries\n   * @category Collections\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n   * The iteratee must complete with a boolean value as its result.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called as soon as any\n   * iteratee returns `true`, or after all the `iteratee` functions have finished.\n   * Result will be the first item in the array that passes the truth test\n   * (iteratee) or the value `undefined` if none passed. Invoked with\n   * (err, result).\n   * @returns {Promise} a promise, if a callback is omitted\n   */\n  function detectSeries(coll, iteratee, callback) {\n    return _createTester(bool => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback);\n  }\n  var detectSeries$1 = awaitify(detectSeries, 3);\n  function consoleFunc(name) {\n    return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {\n      /* istanbul ignore else */\n      if (typeof console === 'object') {\n        /* istanbul ignore else */\n        if (err) {\n          /* istanbul ignore else */\n          if (console.error) {\n            console.error(err);\n          }\n        } else if (console[name]) {\n          /* istanbul ignore else */\n          resultArgs.forEach(x => console[name](x));\n        }\n      }\n    });\n  }\n\n  /**\n   * Logs the result of an [`async` function]{@link AsyncFunction} to the\n   * `console` using `console.dir` to display the properties of the resulting object.\n   * Only works in Node.js or in browsers that support `console.dir` and\n   * `console.error` (such as FF and Chrome).\n   * If multiple arguments are returned from the async function,\n   * `console.dir` is called on each argument in order.\n   *\n   * @name dir\n   * @static\n   * @memberOf module:Utils\n   * @method\n   * @category Util\n   * @param {AsyncFunction} function - The function you want to eventually apply\n   * all arguments to.\n   * @param {...*} arguments... - Any number of arguments to apply to the function.\n   * @example\n   *\n   * // in a module\n   * var hello = function(name, callback) {\n   *     setTimeout(function() {\n   *         callback(null, {hello: name});\n   *     }, 1000);\n   * };\n   *\n   * // in the node repl\n   * node> async.dir(hello, 'world');\n   * {hello: 'world'}\n   */\n  var dir = consoleFunc('dir');\n\n  /**\n   * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n   * the order of operations, the arguments `test` and `iteratee` are switched.\n   *\n   * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n   *\n   * @name doWhilst\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @see [async.whilst]{@link module:ControlFlow.whilst}\n   * @category Control Flow\n   * @param {AsyncFunction} iteratee - A function which is called each time `test`\n   * passes. Invoked with (callback).\n   * @param {AsyncFunction} test - asynchronous truth test to perform after each\n   * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the\n   * non-error args from the previous callback of `iteratee`.\n   * @param {Function} [callback] - A callback which is called after the test\n   * function has failed and repeated execution of `iteratee` has stopped.\n   * `callback` will be passed an error and any arguments passed to the final\n   * `iteratee`'s callback. Invoked with (err, [results]);\n   * @returns {Promise} a promise, if no callback is passed\n   */\n  function doWhilst(iteratee, test, callback) {\n    callback = onlyOnce(callback);\n    var _fn = wrapAsync(iteratee);\n    var _test = wrapAsync(test);\n    var results;\n    function next(err, ...args) {\n      if (err) return callback(err);\n      if (err === false) return;\n      results = args;\n      _test(...args, check);\n    }\n    function check(err, truth) {\n      if (err) return callback(err);\n      if (err === false) return;\n      if (!truth) return callback(null, ...results);\n      _fn(next);\n    }\n    return check(null, true);\n  }\n  var doWhilst$1 = awaitify(doWhilst, 3);\n\n  /**\n   * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n   * argument ordering differs from `until`.\n   *\n   * @name doUntil\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n   * @category Control Flow\n   * @param {AsyncFunction} iteratee - An async function which is called each time\n   * `test` fails. Invoked with (callback).\n   * @param {AsyncFunction} test - asynchronous truth test to perform after each\n   * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the\n   * non-error args from the previous callback of `iteratee`\n   * @param {Function} [callback] - A callback which is called after the test\n   * function has passed and repeated execution of `iteratee` has stopped. `callback`\n   * will be passed an error and any arguments passed to the final `iteratee`'s\n   * callback. Invoked with (err, [results]);\n   * @returns {Promise} a promise, if no callback is passed\n   */\n  function doUntil(iteratee, test, callback) {\n    const _test = wrapAsync(test);\n    return doWhilst$1(iteratee, (...args) => {\n      const cb = args.pop();\n      _test(...args, (err, truth) => cb(err, !truth));\n    }, callback);\n  }\n  function _withoutIndex(iteratee) {\n    return (value, index, callback) => iteratee(value, callback);\n  }\n\n  /**\n   * Applies the function `iteratee` to each item in `coll`, in parallel.\n   * The `iteratee` is called with an item from the list, and a callback for when\n   * it has finished. If the `iteratee` passes an error to its `callback`, the\n   * main `callback` (for the `each` function) is immediately called with the\n   * error.\n   *\n   * Note, that since this function applies `iteratee` to each item in parallel,\n   * there is no guarantee that the iteratee functions will complete in order.\n   *\n   * @name each\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @alias forEach\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - An async function to apply to\n   * each item in `coll`. Invoked with (item, callback).\n   * The array index is not passed to the iteratee.\n   * If you need the index, use `eachOf`.\n   * @param {Function} [callback] - A callback which is called when all\n   * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n   * @returns {Promise} a promise, if a callback is omitted\n   * @example\n   *\n   * // dir1 is a directory that contains file1.txt, file2.txt\n   * // dir2 is a directory that contains file3.txt, file4.txt\n   * // dir3 is a directory that contains file5.txt\n   * // dir4 does not exist\n   *\n   * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];\n   * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];\n   *\n   * // asynchronous function that deletes a file\n   * const deleteFile = function(file, callback) {\n   *     fs.unlink(file, callback);\n   * };\n   *\n   * // Using callbacks\n   * async.each(fileList, deleteFile, function(err) {\n   *     if( err ) {\n   *         console.log(err);\n   *     } else {\n   *         console.log('All files have been deleted successfully');\n   *     }\n   * });\n   *\n   * // Error Handling\n   * async.each(withMissingFileList, deleteFile, function(err){\n   *     console.log(err);\n   *     // [ Error: ENOENT: no such file or directory ]\n   *     // since dir4/file2.txt does not exist\n   *     // dir1/file1.txt could have been deleted\n   * });\n   *\n   * // Using Promises\n   * async.each(fileList, deleteFile)\n   * .then( () => {\n   *     console.log('All files have been deleted successfully');\n   * }).catch( err => {\n   *     console.log(err);\n   * });\n   *\n   * // Error Handling\n   * async.each(fileList, deleteFile)\n   * .then( () => {\n   *     console.log('All files have been deleted successfully');\n   * }).catch( err => {\n   *     console.log(err);\n   *     // [ Error: ENOENT: no such file or directory ]\n   *     // since dir4/file2.txt does not exist\n   *     // dir1/file1.txt could have been deleted\n   * });\n   *\n   * // Using async/await\n   * async () => {\n   *     try {\n   *         await async.each(files, deleteFile);\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   * // Error Handling\n   * async () => {\n   *     try {\n   *         await async.each(withMissingFileList, deleteFile);\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *         // [ Error: ENOENT: no such file or directory ]\n   *         // since dir4/file2.txt does not exist\n   *         // dir1/file1.txt could have been deleted\n   *     }\n   * }\n   *\n   */\n  function eachLimit(coll, iteratee, callback) {\n    return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n  }\n  var each = awaitify(eachLimit, 3);\n\n  /**\n   * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n   *\n   * @name eachLimit\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.each]{@link module:Collections.each}\n   * @alias forEachLimit\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {number} limit - The maximum number of async operations at a time.\n   * @param {AsyncFunction} iteratee - An async function to apply to each item in\n   * `coll`.\n   * The array index is not passed to the iteratee.\n   * If you need the index, use `eachOfLimit`.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called when all\n   * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n   * @returns {Promise} a promise, if a callback is omitted\n   */\n  function eachLimit$1(coll, limit, iteratee, callback) {\n    return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n  }\n  var eachLimit$2 = awaitify(eachLimit$1, 4);\n\n  /**\n   * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n   *\n   * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item\n   * in series and therefore the iteratee functions will complete in order.\n    * @name eachSeries\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.each]{@link module:Collections.each}\n   * @alias forEachSeries\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - An async function to apply to each\n   * item in `coll`.\n   * The array index is not passed to the iteratee.\n   * If you need the index, use `eachOfSeries`.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called when all\n   * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n   * @returns {Promise} a promise, if a callback is omitted\n   */\n  function eachSeries(coll, iteratee, callback) {\n    return eachLimit$2(coll, 1, iteratee, callback);\n  }\n  var eachSeries$1 = awaitify(eachSeries, 3);\n\n  /**\n   * Wrap an async function and ensure it calls its callback on a later tick of\n   * the event loop.  If the function already calls its callback on a next tick,\n   * no extra deferral is added. This is useful for preventing stack overflows\n   * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n   * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n   * contained. ES2017 `async` functions are returned as-is -- they are immune\n   * to Zalgo's corrupting influences, as they always resolve on a later tick.\n   *\n   * @name ensureAsync\n   * @static\n   * @memberOf module:Utils\n   * @method\n   * @category Util\n   * @param {AsyncFunction} fn - an async function, one that expects a node-style\n   * callback as its last argument.\n   * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n   * signature as the function passed in.\n   * @example\n   *\n   * function sometimesAsync(arg, callback) {\n   *     if (cache[arg]) {\n   *         return callback(null, cache[arg]); // this would be synchronous!!\n   *     } else {\n   *         doSomeIO(arg, callback); // this IO would be asynchronous\n   *     }\n   * }\n   *\n   * // this has a risk of stack overflows if many results are cached in a row\n   * async.mapSeries(args, sometimesAsync, done);\n   *\n   * // this will defer sometimesAsync's callback if necessary,\n   * // preventing stack overflows\n   * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n   */\n  function ensureAsync(fn) {\n    if (isAsync(fn)) return fn;\n    return function (...args /*, callback*/) {\n      var callback = args.pop();\n      var sync = true;\n      args.push((...innerArgs) => {\n        if (sync) {\n          setImmediate$1(() => callback(...innerArgs));\n        } else {\n          callback(...innerArgs);\n        }\n      });\n      fn.apply(this, args);\n      sync = false;\n    };\n  }\n\n  /**\n   * Returns `true` if every element in `coll` satisfies an async test. If any\n   * iteratee call returns `false`, the main `callback` is immediately called.\n   *\n   * @name every\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @alias all\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n   * in the collection in parallel.\n   * The iteratee must complete with a boolean result value.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished. Result will be either `true` or `false`\n   * depending on the values of the async tests. Invoked with (err, result).\n   * @returns {Promise} a promise, if no callback provided\n   * @example\n   *\n   * // dir1 is a directory that contains file1.txt, file2.txt\n   * // dir2 is a directory that contains file3.txt, file4.txt\n   * // dir3 is a directory that contains file5.txt\n   * // dir4 does not exist\n   *\n   * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file5.txt'];\n   * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];\n   *\n   * // asynchronous function that checks if a file exists\n   * function fileExists(file, callback) {\n   *    fs.access(file, fs.constants.F_OK, (err) => {\n   *        callback(null, !err);\n   *    });\n   * }\n   *\n   * // Using callbacks\n   * async.every(fileList, fileExists, function(err, result) {\n   *     console.log(result);\n   *     // true\n   *     // result is true since every file exists\n   * });\n   *\n   * async.every(withMissingFileList, fileExists, function(err, result) {\n   *     console.log(result);\n   *     // false\n   *     // result is false since NOT every file exists\n   * });\n   *\n   * // Using Promises\n   * async.every(fileList, fileExists)\n   * .then( result => {\n   *     console.log(result);\n   *     // true\n   *     // result is true since every file exists\n   * }).catch( err => {\n   *     console.log(err);\n   * });\n   *\n   * async.every(withMissingFileList, fileExists)\n   * .then( result => {\n   *     console.log(result);\n   *     // false\n   *     // result is false since NOT every file exists\n   * }).catch( err => {\n   *     console.log(err);\n   * });\n   *\n   * // Using async/await\n   * async () => {\n   *     try {\n   *         let result = await async.every(fileList, fileExists);\n   *         console.log(result);\n   *         // true\n   *         // result is true since every file exists\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   * async () => {\n   *     try {\n   *         let result = await async.every(withMissingFileList, fileExists);\n   *         console.log(result);\n   *         // false\n   *         // result is false since NOT every file exists\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   */\n  function every(coll, iteratee, callback) {\n    return _createTester(bool => !bool, res => !res)(eachOf$1, coll, iteratee, callback);\n  }\n  var every$1 = awaitify(every, 3);\n\n  /**\n   * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n   *\n   * @name everyLimit\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.every]{@link module:Collections.every}\n   * @alias allLimit\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {number} limit - The maximum number of async operations at a time.\n   * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n   * in the collection in parallel.\n   * The iteratee must complete with a boolean result value.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished. Result will be either `true` or `false`\n   * depending on the values of the async tests. Invoked with (err, result).\n   * @returns {Promise} a promise, if no callback provided\n   */\n  function everyLimit(coll, limit, iteratee, callback) {\n    return _createTester(bool => !bool, res => !res)(eachOfLimit(limit), coll, iteratee, callback);\n  }\n  var everyLimit$1 = awaitify(everyLimit, 4);\n\n  /**\n   * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n   *\n   * @name everySeries\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.every]{@link module:Collections.every}\n   * @alias allSeries\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n   * in the collection in series.\n   * The iteratee must complete with a boolean result value.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished. Result will be either `true` or `false`\n   * depending on the values of the async tests. Invoked with (err, result).\n   * @returns {Promise} a promise, if no callback provided\n   */\n  function everySeries(coll, iteratee, callback) {\n    return _createTester(bool => !bool, res => !res)(eachOfSeries$1, coll, iteratee, callback);\n  }\n  var everySeries$1 = awaitify(everySeries, 3);\n  function filterArray(eachfn, arr, iteratee, callback) {\n    var truthValues = new Array(arr.length);\n    eachfn(arr, (x, index, iterCb) => {\n      iteratee(x, (err, v) => {\n        truthValues[index] = !!v;\n        iterCb(err);\n      });\n    }, err => {\n      if (err) return callback(err);\n      var results = [];\n      for (var i = 0; i < arr.length; i++) {\n        if (truthValues[i]) results.push(arr[i]);\n      }\n      callback(null, results);\n    });\n  }\n  function filterGeneric(eachfn, coll, iteratee, callback) {\n    var results = [];\n    eachfn(coll, (x, index, iterCb) => {\n      iteratee(x, (err, v) => {\n        if (err) return iterCb(err);\n        if (v) {\n          results.push({\n            index,\n            value: x\n          });\n        }\n        iterCb(err);\n      });\n    }, err => {\n      if (err) return callback(err);\n      callback(null, results.sort((a, b) => a.index - b.index).map(v => v.value));\n    });\n  }\n  function _filter(eachfn, coll, iteratee, callback) {\n    var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n    return filter(eachfn, coll, wrapAsync(iteratee), callback);\n  }\n\n  /**\n   * Returns a new array of all the values in `coll` which pass an async truth\n   * test. This operation is performed in parallel, but the results array will be\n   * in the same order as the original.\n   *\n   * @name filter\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @alias select\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n   * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n   * with a boolean argument once it has completed. Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished. Invoked with (err, results).\n   * @returns {Promise} a promise, if no callback provided\n   * @example\n   *\n   * // dir1 is a directory that contains file1.txt, file2.txt\n   * // dir2 is a directory that contains file3.txt, file4.txt\n   * // dir3 is a directory that contains file5.txt\n   *\n   * const files = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];\n   *\n   * // asynchronous function that checks if a file exists\n   * function fileExists(file, callback) {\n   *    fs.access(file, fs.constants.F_OK, (err) => {\n   *        callback(null, !err);\n   *    });\n   * }\n   *\n   * // Using callbacks\n   * async.filter(files, fileExists, function(err, results) {\n   *    if(err) {\n   *        console.log(err);\n   *    } else {\n   *        console.log(results);\n   *        // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n   *        // results is now an array of the existing files\n   *    }\n   * });\n   *\n   * // Using Promises\n   * async.filter(files, fileExists)\n   * .then(results => {\n   *     console.log(results);\n   *     // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n   *     // results is now an array of the existing files\n   * }).catch(err => {\n   *     console.log(err);\n   * });\n   *\n   * // Using async/await\n   * async () => {\n   *     try {\n   *         let results = await async.filter(files, fileExists);\n   *         console.log(results);\n   *         // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n   *         // results is now an array of the existing files\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   */\n  function filter(coll, iteratee, callback) {\n    return _filter(eachOf$1, coll, iteratee, callback);\n  }\n  var filter$1 = awaitify(filter, 3);\n\n  /**\n   * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n   * time.\n   *\n   * @name filterLimit\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.filter]{@link module:Collections.filter}\n   * @alias selectLimit\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {number} limit - The maximum number of async operations at a time.\n   * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n   * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n   * with a boolean argument once it has completed. Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished. Invoked with (err, results).\n   * @returns {Promise} a promise, if no callback provided\n   */\n  function filterLimit(coll, limit, iteratee, callback) {\n    return _filter(eachOfLimit(limit), coll, iteratee, callback);\n  }\n  var filterLimit$1 = awaitify(filterLimit, 4);\n\n  /**\n   * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n   *\n   * @name filterSeries\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.filter]{@link module:Collections.filter}\n   * @alias selectSeries\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n   * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n   * with a boolean argument once it has completed. Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished. Invoked with (err, results)\n   * @returns {Promise} a promise, if no callback provided\n   */\n  function filterSeries(coll, iteratee, callback) {\n    return _filter(eachOfSeries$1, coll, iteratee, callback);\n  }\n  var filterSeries$1 = awaitify(filterSeries, 3);\n\n  /**\n   * Calls the asynchronous function `fn` with a callback parameter that allows it\n   * to call itself again, in series, indefinitely.\n    * If an error is passed to the callback then `errback` is called with the\n   * error, and execution stops, otherwise it will never be called.\n   *\n   * @name forever\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @category Control Flow\n   * @param {AsyncFunction} fn - an async function to call repeatedly.\n   * Invoked with (next).\n   * @param {Function} [errback] - when `fn` passes an error to it's callback,\n   * this function will be called, and execution stops. Invoked with (err).\n   * @returns {Promise} a promise that rejects if an error occurs and an errback\n   * is not passed\n   * @example\n   *\n   * async.forever(\n   *     function(next) {\n   *         // next is suitable for passing to things that need a callback(err [, whatever]);\n   *         // it will result in this function being called again.\n   *     },\n   *     function(err) {\n   *         // if next is called with a value in its first parameter, it will appear\n   *         // in here as 'err', and execution will stop.\n   *     }\n   * );\n   */\n  function forever(fn, errback) {\n    var done = onlyOnce(errback);\n    var task = wrapAsync(ensureAsync(fn));\n    function next(err) {\n      if (err) return done(err);\n      if (err === false) return;\n      task(next);\n    }\n    return next();\n  }\n  var forever$1 = awaitify(forever, 2);\n\n  /**\n   * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n   *\n   * @name groupByLimit\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.groupBy]{@link module:Collections.groupBy}\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {number} limit - The maximum number of async operations at a time.\n   * @param {AsyncFunction} iteratee - An async function to apply to each item in\n   * `coll`.\n   * The iteratee should complete with a `key` to group the value under.\n   * Invoked with (value, callback).\n   * @param {Function} [callback] - A callback which is called when all `iteratee`\n   * functions have finished, or an error occurs. Result is an `Object` whoses\n   * properties are arrays of values which returned the corresponding key.\n   * @returns {Promise} a promise, if no callback is passed\n   */\n  function groupByLimit(coll, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return mapLimit$1(coll, limit, (val, iterCb) => {\n      _iteratee(val, (err, key) => {\n        if (err) return iterCb(err);\n        return iterCb(err, {\n          key,\n          val\n        });\n      });\n    }, (err, mapResults) => {\n      var result = {};\n      // from MDN, handle object having an `hasOwnProperty` prop\n      var {\n        hasOwnProperty\n      } = Object.prototype;\n      for (var i = 0; i < mapResults.length; i++) {\n        if (mapResults[i]) {\n          var {\n            key\n          } = mapResults[i];\n          var {\n            val\n          } = mapResults[i];\n          if (hasOwnProperty.call(result, key)) {\n            result[key].push(val);\n          } else {\n            result[key] = [val];\n          }\n        }\n      }\n      return callback(err, result);\n    });\n  }\n  var groupByLimit$1 = awaitify(groupByLimit, 4);\n\n  /**\n   * Returns a new object, where each value corresponds to an array of items, from\n   * `coll`, that returned the corresponding key. That is, the keys of the object\n   * correspond to the values passed to the `iteratee` callback.\n   *\n   * Note: Since this function applies the `iteratee` to each item in parallel,\n   * there is no guarantee that the `iteratee` functions will complete in order.\n   * However, the values for each key in the `result` will be in the same order as\n   * the original `coll`. For Objects, the values will roughly be in the order of\n   * the original Objects' keys (but this can vary across JavaScript engines).\n   *\n   * @name groupBy\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - An async function to apply to each item in\n   * `coll`.\n   * The iteratee should complete with a `key` to group the value under.\n   * Invoked with (value, callback).\n   * @param {Function} [callback] - A callback which is called when all `iteratee`\n   * functions have finished, or an error occurs. Result is an `Object` whoses\n   * properties are arrays of values which returned the corresponding key.\n   * @returns {Promise} a promise, if no callback is passed\n   * @example\n   *\n   * // dir1 is a directory that contains file1.txt, file2.txt\n   * // dir2 is a directory that contains file3.txt, file4.txt\n   * // dir3 is a directory that contains file5.txt\n   * // dir4 does not exist\n   *\n   * const files = ['dir1/file1.txt','dir2','dir4']\n   *\n   * // asynchronous function that detects file type as none, file, or directory\n   * function detectFile(file, callback) {\n   *     fs.stat(file, function(err, stat) {\n   *         if (err) {\n   *             return callback(null, 'none');\n   *         }\n   *         callback(null, stat.isDirectory() ? 'directory' : 'file');\n   *     });\n   * }\n   *\n   * //Using callbacks\n   * async.groupBy(files, detectFile, function(err, result) {\n   *     if(err) {\n   *         console.log(err);\n   *     } else {\n   *\t       console.log(result);\n   *         // {\n   *         //     file: [ 'dir1/file1.txt' ],\n   *         //     none: [ 'dir4' ],\n   *         //     directory: [ 'dir2']\n   *         // }\n   *         // result is object containing the files grouped by type\n   *     }\n   * });\n   *\n   * // Using Promises\n   * async.groupBy(files, detectFile)\n   * .then( result => {\n   *     console.log(result);\n   *     // {\n   *     //     file: [ 'dir1/file1.txt' ],\n   *     //     none: [ 'dir4' ],\n   *     //     directory: [ 'dir2']\n   *     // }\n   *     // result is object containing the files grouped by type\n   * }).catch( err => {\n   *     console.log(err);\n   * });\n   *\n   * // Using async/await\n   * async () => {\n   *     try {\n   *         let result = await async.groupBy(files, detectFile);\n   *         console.log(result);\n   *         // {\n   *         //     file: [ 'dir1/file1.txt' ],\n   *         //     none: [ 'dir4' ],\n   *         //     directory: [ 'dir2']\n   *         // }\n   *         // result is object containing the files grouped by type\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   */\n  function groupBy(coll, iteratee, callback) {\n    return groupByLimit$1(coll, Infinity, iteratee, callback);\n  }\n\n  /**\n   * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n   *\n   * @name groupBySeries\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.groupBy]{@link module:Collections.groupBy}\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - An async function to apply to each item in\n   * `coll`.\n   * The iteratee should complete with a `key` to group the value under.\n   * Invoked with (value, callback).\n   * @param {Function} [callback] - A callback which is called when all `iteratee`\n   * functions have finished, or an error occurs. Result is an `Object` whose\n   * properties are arrays of values which returned the corresponding key.\n   * @returns {Promise} a promise, if no callback is passed\n   */\n  function groupBySeries(coll, iteratee, callback) {\n    return groupByLimit$1(coll, 1, iteratee, callback);\n  }\n\n  /**\n   * Logs the result of an `async` function to the `console`. Only works in\n   * Node.js or in browsers that support `console.log` and `console.error` (such\n   * as FF and Chrome). If multiple arguments are returned from the async\n   * function, `console.log` is called on each argument in order.\n   *\n   * @name log\n   * @static\n   * @memberOf module:Utils\n   * @method\n   * @category Util\n   * @param {AsyncFunction} function - The function you want to eventually apply\n   * all arguments to.\n   * @param {...*} arguments... - Any number of arguments to apply to the function.\n   * @example\n   *\n   * // in a module\n   * var hello = function(name, callback) {\n   *     setTimeout(function() {\n   *         callback(null, 'hello ' + name);\n   *     }, 1000);\n   * };\n   *\n   * // in the node repl\n   * node> async.log(hello, 'world');\n   * 'hello world'\n   */\n  var log = consoleFunc('log');\n\n  /**\n   * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n   * time.\n   *\n   * @name mapValuesLimit\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.mapValues]{@link module:Collections.mapValues}\n   * @category Collection\n   * @param {Object} obj - A collection to iterate over.\n   * @param {number} limit - The maximum number of async operations at a time.\n   * @param {AsyncFunction} iteratee - A function to apply to each value and key\n   * in `coll`.\n   * The iteratee should complete with the transformed value as its result.\n   * Invoked with (value, key, callback).\n   * @param {Function} [callback] - A callback which is called when all `iteratee`\n   * functions have finished, or an error occurs. `result` is a new object consisting\n   * of each key from `obj`, with each transformed value on the right-hand side.\n   * Invoked with (err, result).\n   * @returns {Promise} a promise, if no callback is passed\n   */\n  function mapValuesLimit(obj, limit, iteratee, callback) {\n    callback = once(callback);\n    var newObj = {};\n    var _iteratee = wrapAsync(iteratee);\n    return eachOfLimit(limit)(obj, (val, key, next) => {\n      _iteratee(val, key, (err, result) => {\n        if (err) return next(err);\n        newObj[key] = result;\n        next(err);\n      });\n    }, err => callback(err, newObj));\n  }\n  var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);\n\n  /**\n   * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n   *\n   * Produces a new Object by mapping each value of `obj` through the `iteratee`\n   * function. The `iteratee` is called each `value` and `key` from `obj` and a\n   * callback for when it has finished processing. Each of these callbacks takes\n   * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n   * passes an error to its callback, the main `callback` (for the `mapValues`\n   * function) is immediately called with the error.\n   *\n   * Note, the order of the keys in the result is not guaranteed.  The keys will\n   * be roughly in the order they complete, (but this is very engine-specific)\n   *\n   * @name mapValues\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @category Collection\n   * @param {Object} obj - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - A function to apply to each value and key\n   * in `coll`.\n   * The iteratee should complete with the transformed value as its result.\n   * Invoked with (value, key, callback).\n   * @param {Function} [callback] - A callback which is called when all `iteratee`\n   * functions have finished, or an error occurs. `result` is a new object consisting\n   * of each key from `obj`, with each transformed value on the right-hand side.\n   * Invoked with (err, result).\n   * @returns {Promise} a promise, if no callback is passed\n   * @example\n   *\n   * // file1.txt is a file that is 1000 bytes in size\n   * // file2.txt is a file that is 2000 bytes in size\n   * // file3.txt is a file that is 3000 bytes in size\n   * // file4.txt does not exist\n   *\n   * const fileMap = {\n   *     f1: 'file1.txt',\n   *     f2: 'file2.txt',\n   *     f3: 'file3.txt'\n   * };\n   *\n   * const withMissingFileMap = {\n   *     f1: 'file1.txt',\n   *     f2: 'file2.txt',\n   *     f3: 'file4.txt'\n   * };\n   *\n   * // asynchronous function that returns the file size in bytes\n   * function getFileSizeInBytes(file, key, callback) {\n   *     fs.stat(file, function(err, stat) {\n   *         if (err) {\n   *             return callback(err);\n   *         }\n   *         callback(null, stat.size);\n   *     });\n   * }\n   *\n   * // Using callbacks\n   * async.mapValues(fileMap, getFileSizeInBytes, function(err, result) {\n   *     if (err) {\n   *         console.log(err);\n   *     } else {\n   *         console.log(result);\n   *         // result is now a map of file size in bytes for each file, e.g.\n   *         // {\n   *         //     f1: 1000,\n   *         //     f2: 2000,\n   *         //     f3: 3000\n   *         // }\n   *     }\n   * });\n   *\n   * // Error handling\n   * async.mapValues(withMissingFileMap, getFileSizeInBytes, function(err, result) {\n   *     if (err) {\n   *         console.log(err);\n   *         // [ Error: ENOENT: no such file or directory ]\n   *     } else {\n   *         console.log(result);\n   *     }\n   * });\n   *\n   * // Using Promises\n   * async.mapValues(fileMap, getFileSizeInBytes)\n   * .then( result => {\n   *     console.log(result);\n   *     // result is now a map of file size in bytes for each file, e.g.\n   *     // {\n   *     //     f1: 1000,\n   *     //     f2: 2000,\n   *     //     f3: 3000\n   *     // }\n   * }).catch (err => {\n   *     console.log(err);\n   * });\n   *\n   * // Error Handling\n   * async.mapValues(withMissingFileMap, getFileSizeInBytes)\n   * .then( result => {\n   *     console.log(result);\n   * }).catch (err => {\n   *     console.log(err);\n   *     // [ Error: ENOENT: no such file or directory ]\n   * });\n   *\n   * // Using async/await\n   * async () => {\n   *     try {\n   *         let result = await async.mapValues(fileMap, getFileSizeInBytes);\n   *         console.log(result);\n   *         // result is now a map of file size in bytes for each file, e.g.\n   *         // {\n   *         //     f1: 1000,\n   *         //     f2: 2000,\n   *         //     f3: 3000\n   *         // }\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   * // Error Handling\n   * async () => {\n   *     try {\n   *         let result = await async.mapValues(withMissingFileMap, getFileSizeInBytes);\n   *         console.log(result);\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *         // [ Error: ENOENT: no such file or directory ]\n   *     }\n   * }\n   *\n   */\n  function mapValues(obj, iteratee, callback) {\n    return mapValuesLimit$1(obj, Infinity, iteratee, callback);\n  }\n\n  /**\n   * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n   *\n   * @name mapValuesSeries\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.mapValues]{@link module:Collections.mapValues}\n   * @category Collection\n   * @param {Object} obj - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - A function to apply to each value and key\n   * in `coll`.\n   * The iteratee should complete with the transformed value as its result.\n   * Invoked with (value, key, callback).\n   * @param {Function} [callback] - A callback which is called when all `iteratee`\n   * functions have finished, or an error occurs. `result` is a new object consisting\n   * of each key from `obj`, with each transformed value on the right-hand side.\n   * Invoked with (err, result).\n   * @returns {Promise} a promise, if no callback is passed\n   */\n  function mapValuesSeries(obj, iteratee, callback) {\n    return mapValuesLimit$1(obj, 1, iteratee, callback);\n  }\n\n  /**\n   * Caches the results of an async function. When creating a hash to store\n   * function results against, the callback is omitted from the hash and an\n   * optional hash function can be used.\n   *\n   * **Note: if the async function errs, the result will not be cached and\n   * subsequent calls will call the wrapped function.**\n   *\n   * If no hash function is specified, the first argument is used as a hash key,\n   * which may work reasonably if it is a string or a data type that converts to a\n   * distinct string. Note that objects and arrays will not behave reasonably.\n   * Neither will cases where the other arguments are significant. In such cases,\n   * specify your own hash function.\n   *\n   * The cache of results is exposed as the `memo` property of the function\n   * returned by `memoize`.\n   *\n   * @name memoize\n   * @static\n   * @memberOf module:Utils\n   * @method\n   * @category Util\n   * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n   * @param {Function} hasher - An optional function for generating a custom hash\n   * for storing results. It has all the arguments applied to it apart from the\n   * callback, and must be synchronous.\n   * @returns {AsyncFunction} a memoized version of `fn`\n   * @example\n   *\n   * var slow_fn = function(name, callback) {\n   *     // do something\n   *     callback(null, result);\n   * };\n   * var fn = async.memoize(slow_fn);\n   *\n   * // fn can now be used as if it were slow_fn\n   * fn('some name', function() {\n   *     // callback\n   * });\n   */\n  function memoize(fn, hasher = v => v) {\n    var memo = Object.create(null);\n    var queues = Object.create(null);\n    var _fn = wrapAsync(fn);\n    var memoized = initialParams((args, callback) => {\n      var key = hasher(...args);\n      if (key in memo) {\n        setImmediate$1(() => callback(null, ...memo[key]));\n      } else if (key in queues) {\n        queues[key].push(callback);\n      } else {\n        queues[key] = [callback];\n        _fn(...args, (err, ...resultArgs) => {\n          // #1465 don't memoize if an error occurred\n          if (!err) {\n            memo[key] = resultArgs;\n          }\n          var q = queues[key];\n          delete queues[key];\n          for (var i = 0, l = q.length; i < l; i++) {\n            q[i](err, ...resultArgs);\n          }\n        });\n      }\n    });\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n  }\n\n  /* istanbul ignore file */\n\n  /**\n   * Calls `callback` on a later loop around the event loop. In Node.js this just\n   * calls `process.nextTick`.  In the browser it will use `setImmediate` if\n   * available, otherwise `setTimeout(callback, 0)`, which means other higher\n   * priority events may precede the execution of `callback`.\n   *\n   * This is used internally for browser-compatibility purposes.\n   *\n   * @name nextTick\n   * @static\n   * @memberOf module:Utils\n   * @method\n   * @see [async.setImmediate]{@link module:Utils.setImmediate}\n   * @category Util\n   * @param {Function} callback - The function to call on a later loop around\n   * the event loop. Invoked with (args...).\n   * @param {...*} args... - any number of additional arguments to pass to the\n   * callback on the next tick.\n   * @example\n   *\n   * var call_order = [];\n   * async.nextTick(function() {\n   *     call_order.push('two');\n   *     // call_order now equals ['one','two']\n   * });\n   * call_order.push('one');\n   *\n   * async.setImmediate(function (a, b, c) {\n   *     // a, b, and c equal 1, 2, and 3\n   * }, 1, 2, 3);\n   */\n  var _defer$1;\n  if (hasNextTick) {\n    _defer$1 = process.nextTick;\n  } else if (hasSetImmediate) {\n    _defer$1 = setImmediate;\n  } else {\n    _defer$1 = fallback;\n  }\n  var nextTick = wrap(_defer$1);\n  var parallel = awaitify((eachfn, tasks, callback) => {\n    var results = isArrayLike(tasks) ? [] : {};\n    eachfn(tasks, (task, key, taskCb) => {\n      wrapAsync(task)((err, ...result) => {\n        if (result.length < 2) {\n          [result] = result;\n        }\n        results[key] = result;\n        taskCb(err);\n      });\n    }, err => callback(err, results));\n  }, 3);\n\n  /**\n   * Run the `tasks` collection of functions in parallel, without waiting until\n   * the previous function has completed. If any of the functions pass an error to\n   * its callback, the main `callback` is immediately called with the value of the\n   * error. Once the `tasks` have completed, the results are passed to the final\n   * `callback` as an array.\n   *\n   * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n   * parallel execution of code.  If your tasks do not use any timers or perform\n   * any I/O, they will actually be executed in series.  Any synchronous setup\n   * sections for each task will happen one after the other.  JavaScript remains\n   * single-threaded.\n   *\n   * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n   * execution of other tasks when a task fails.\n   *\n   * It is also possible to use an object instead of an array. Each property will\n   * be run as a function and the results will be passed to the final `callback`\n   * as an object instead of an array. This can be a more readable way of handling\n   * results from {@link async.parallel}.\n   *\n   * @name parallel\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @category Control Flow\n   * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of\n   * [async functions]{@link AsyncFunction} to run.\n   * Each async function can complete with any number of optional `result` values.\n   * @param {Function} [callback] - An optional callback to run once all the\n   * functions have completed successfully. This function gets a results array\n   * (or object) containing all the result arguments passed to the task callbacks.\n   * Invoked with (err, results).\n   * @returns {Promise} a promise, if a callback is not passed\n   *\n   * @example\n   *\n   * //Using Callbacks\n   * async.parallel([\n   *     function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 'one');\n   *         }, 200);\n   *     },\n   *     function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 'two');\n   *         }, 100);\n   *     }\n   * ], function(err, results) {\n   *     console.log(results);\n   *     // results is equal to ['one','two'] even though\n   *     // the second function had a shorter timeout.\n   * });\n   *\n   * // an example using an object instead of an array\n   * async.parallel({\n   *     one: function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 1);\n   *         }, 200);\n   *     },\n   *     two: function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 2);\n   *         }, 100);\n   *     }\n   * }, function(err, results) {\n   *     console.log(results);\n   *     // results is equal to: { one: 1, two: 2 }\n   * });\n   *\n   * //Using Promises\n   * async.parallel([\n   *     function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 'one');\n   *         }, 200);\n   *     },\n   *     function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 'two');\n   *         }, 100);\n   *     }\n   * ]).then(results => {\n   *     console.log(results);\n   *     // results is equal to ['one','two'] even though\n   *     // the second function had a shorter timeout.\n   * }).catch(err => {\n   *     console.log(err);\n   * });\n   *\n   * // an example using an object instead of an array\n   * async.parallel({\n   *     one: function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 1);\n   *         }, 200);\n   *     },\n   *     two: function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 2);\n   *         }, 100);\n   *     }\n   * }).then(results => {\n   *     console.log(results);\n   *     // results is equal to: { one: 1, two: 2 }\n   * }).catch(err => {\n   *     console.log(err);\n   * });\n   *\n   * //Using async/await\n   * async () => {\n   *     try {\n   *         let results = await async.parallel([\n   *             function(callback) {\n   *                 setTimeout(function() {\n   *                     callback(null, 'one');\n   *                 }, 200);\n   *             },\n   *             function(callback) {\n   *                 setTimeout(function() {\n   *                     callback(null, 'two');\n   *                 }, 100);\n   *             }\n   *         ]);\n   *         console.log(results);\n   *         // results is equal to ['one','two'] even though\n   *         // the second function had a shorter timeout.\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   * // an example using an object instead of an array\n   * async () => {\n   *     try {\n   *         let results = await async.parallel({\n   *             one: function(callback) {\n   *                 setTimeout(function() {\n   *                     callback(null, 1);\n   *                 }, 200);\n   *             },\n   *            two: function(callback) {\n   *                 setTimeout(function() {\n   *                     callback(null, 2);\n   *                 }, 100);\n   *            }\n   *         });\n   *         console.log(results);\n   *         // results is equal to: { one: 1, two: 2 }\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   */\n  function parallel$1(tasks, callback) {\n    return parallel(eachOf$1, tasks, callback);\n  }\n\n  /**\n   * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n   * time.\n   *\n   * @name parallelLimit\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @see [async.parallel]{@link module:ControlFlow.parallel}\n   * @category Control Flow\n   * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of\n   * [async functions]{@link AsyncFunction} to run.\n   * Each async function can complete with any number of optional `result` values.\n   * @param {number} limit - The maximum number of async operations at a time.\n   * @param {Function} [callback] - An optional callback to run once all the\n   * functions have completed successfully. This function gets a results array\n   * (or object) containing all the result arguments passed to the task callbacks.\n   * Invoked with (err, results).\n   * @returns {Promise} a promise, if a callback is not passed\n   */\n  function parallelLimit(tasks, limit, callback) {\n    return parallel(eachOfLimit(limit), tasks, callback);\n  }\n\n  /**\n   * A queue of tasks for the worker function to complete.\n   * @typedef {Iterable} QueueObject\n   * @memberOf module:ControlFlow\n   * @property {Function} length - a function returning the number of items\n   * waiting to be processed. Invoke with `queue.length()`.\n   * @property {boolean} started - a boolean indicating whether or not any\n   * items have been pushed and processed by the queue.\n   * @property {Function} running - a function returning the number of items\n   * currently being processed. Invoke with `queue.running()`.\n   * @property {Function} workersList - a function returning the array of items\n   * currently being processed. Invoke with `queue.workersList()`.\n   * @property {Function} idle - a function returning false if there are items\n   * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n   * @property {number} concurrency - an integer for determining how many `worker`\n   * functions should be run in parallel. This property can be changed after a\n   * `queue` is created to alter the concurrency on-the-fly.\n   * @property {number} payload - an integer that specifies how many items are\n   * passed to the worker function at a time. only applies if this is a\n   * [cargo]{@link module:ControlFlow.cargo} object\n   * @property {AsyncFunction} push - add a new task to the `queue`. Calls `callback`\n   * once the `worker` has finished processing the task. Instead of a single task,\n   * a `tasks` array can be submitted. The respective callback is used for every\n   * task in the list. Invoke with `queue.push(task, [callback])`,\n   * @property {AsyncFunction} unshift - add a new task to the front of the `queue`.\n   * Invoke with `queue.unshift(task, [callback])`.\n   * @property {AsyncFunction} pushAsync - the same as `q.push`, except this returns\n   * a promise that rejects if an error occurs.\n   * @property {AsyncFunction} unshiftAsync - the same as `q.unshift`, except this returns\n   * a promise that rejects if an error occurs.\n   * @property {Function} remove - remove items from the queue that match a test\n   * function.  The test function will be passed an object with a `data` property,\n   * and a `priority` property, if this is a\n   * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.\n   * Invoked with `queue.remove(testFn)`, where `testFn` is of the form\n   * `function ({data, priority}) {}` and returns a Boolean.\n   * @property {Function} saturated - a function that sets a callback that is\n   * called when the number of running workers hits the `concurrency` limit, and\n   * further tasks will be queued.  If the callback is omitted, `q.saturated()`\n   * returns a promise for the next occurrence.\n   * @property {Function} unsaturated - a function that sets a callback that is\n   * called when the number of running workers is less than the `concurrency` &\n   * `buffer` limits, and further tasks will not be queued. If the callback is\n   * omitted, `q.unsaturated()` returns a promise for the next occurrence.\n   * @property {number} buffer - A minimum threshold buffer in order to say that\n   * the `queue` is `unsaturated`.\n   * @property {Function} empty - a function that sets a callback that is called\n   * when the last item from the `queue` is given to a `worker`. If the callback\n   * is omitted, `q.empty()` returns a promise for the next occurrence.\n   * @property {Function} drain - a function that sets a callback that is called\n   * when the last item from the `queue` has returned from the `worker`. If the\n   * callback is omitted, `q.drain()` returns a promise for the next occurrence.\n   * @property {Function} error - a function that sets a callback that is called\n   * when a task errors. Has the signature `function(error, task)`. If the\n   * callback is omitted, `error()` returns a promise that rejects on the next\n   * error.\n   * @property {boolean} paused - a boolean for determining whether the queue is\n   * in a paused state.\n   * @property {Function} pause - a function that pauses the processing of tasks\n   * until `resume()` is called. Invoke with `queue.pause()`.\n   * @property {Function} resume - a function that resumes the processing of\n   * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n   * @property {Function} kill - a function that removes the `drain` callback and\n   * empties remaining tasks from the queue forcing it to go idle. No more tasks\n   * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.\n   *\n   * @example\n   * const q = async.queue(worker, 2)\n   * q.push(item1)\n   * q.push(item2)\n   * q.push(item3)\n   * // queues are iterable, spread into an array to inspect\n   * const items = [...q] // [item1, item2, item3]\n   * // or use for of\n   * for (let item of q) {\n   *     console.log(item)\n   * }\n   *\n   * q.drain(() => {\n   *     console.log('all done')\n   * })\n   * // or\n   * await q.drain()\n   */\n\n  /**\n   * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n   * `queue` are processed in parallel (up to the `concurrency` limit). If all\n   * `worker`s are in progress, the task is queued until one becomes available.\n   * Once a `worker` completes a `task`, that `task`'s callback is called.\n   *\n   * @name queue\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @category Control Flow\n   * @param {AsyncFunction} worker - An async function for processing a queued task.\n   * If you want to handle errors from an individual task, pass a callback to\n   * `q.push()`. Invoked with (task, callback).\n   * @param {number} [concurrency=1] - An `integer` for determining how many\n   * `worker` functions should be run in parallel.  If omitted, the concurrency\n   * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n   * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be\n   * attached as certain properties to listen for specific events during the\n   * lifecycle of the queue.\n   * @example\n   *\n   * // create a queue object with concurrency 2\n   * var q = async.queue(function(task, callback) {\n   *     console.log('hello ' + task.name);\n   *     callback();\n   * }, 2);\n   *\n   * // assign a callback\n   * q.drain(function() {\n   *     console.log('all items have been processed');\n   * });\n   * // or await the end\n   * await q.drain()\n   *\n   * // assign an error callback\n   * q.error(function(err, task) {\n   *     console.error('task experienced an error');\n   * });\n   *\n   * // add some items to the queue\n   * q.push({name: 'foo'}, function(err) {\n   *     console.log('finished processing foo');\n   * });\n   * // callback is optional\n   * q.push({name: 'bar'});\n   *\n   * // add some items to the queue (batch-wise)\n   * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n   *     console.log('finished processing item');\n   * });\n   *\n   * // add some items to the front of the queue\n   * q.unshift({name: 'bar'}, function (err) {\n   *     console.log('finished processing bar');\n   * });\n   */\n  function queue$1(worker, concurrency) {\n    var _worker = wrapAsync(worker);\n    return queue((items, cb) => {\n      _worker(items[0], cb);\n    }, concurrency, 1);\n  }\n\n  // Binary min-heap implementation used for priority queue.\n  // Implementation is stable, i.e. push time is considered for equal priorities\n  class Heap {\n    constructor() {\n      this.heap = [];\n      this.pushCount = Number.MIN_SAFE_INTEGER;\n    }\n    get length() {\n      return this.heap.length;\n    }\n    empty() {\n      this.heap = [];\n      return this;\n    }\n    percUp(index) {\n      let p;\n      while (index > 0 && smaller(this.heap[index], this.heap[p = parent(index)])) {\n        let t = this.heap[index];\n        this.heap[index] = this.heap[p];\n        this.heap[p] = t;\n        index = p;\n      }\n    }\n    percDown(index) {\n      let l;\n      while ((l = leftChi(index)) < this.heap.length) {\n        if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {\n          l = l + 1;\n        }\n        if (smaller(this.heap[index], this.heap[l])) {\n          break;\n        }\n        let t = this.heap[index];\n        this.heap[index] = this.heap[l];\n        this.heap[l] = t;\n        index = l;\n      }\n    }\n    push(node) {\n      node.pushCount = ++this.pushCount;\n      this.heap.push(node);\n      this.percUp(this.heap.length - 1);\n    }\n    unshift(node) {\n      return this.heap.push(node);\n    }\n    shift() {\n      let [top] = this.heap;\n      this.heap[0] = this.heap[this.heap.length - 1];\n      this.heap.pop();\n      this.percDown(0);\n      return top;\n    }\n    toArray() {\n      return [...this];\n    }\n    *[Symbol.iterator]() {\n      for (let i = 0; i < this.heap.length; i++) {\n        yield this.heap[i].data;\n      }\n    }\n    remove(testFn) {\n      let j = 0;\n      for (let i = 0; i < this.heap.length; i++) {\n        if (!testFn(this.heap[i])) {\n          this.heap[j] = this.heap[i];\n          j++;\n        }\n      }\n      this.heap.splice(j);\n      for (let i = parent(this.heap.length - 1); i >= 0; i--) {\n        this.percDown(i);\n      }\n      return this;\n    }\n  }\n  function leftChi(i) {\n    return (i << 1) + 1;\n  }\n  function parent(i) {\n    return (i + 1 >> 1) - 1;\n  }\n  function smaller(x, y) {\n    if (x.priority !== y.priority) {\n      return x.priority < y.priority;\n    } else {\n      return x.pushCount < y.pushCount;\n    }\n  }\n\n  /**\n   * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n   * completed in ascending priority order.\n   *\n   * @name priorityQueue\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @see [async.queue]{@link module:ControlFlow.queue}\n   * @category Control Flow\n   * @param {AsyncFunction} worker - An async function for processing a queued task.\n   * If you want to handle errors from an individual task, pass a callback to\n   * `q.push()`.\n   * Invoked with (task, callback).\n   * @param {number} concurrency - An `integer` for determining how many `worker`\n   * functions should be run in parallel.  If omitted, the concurrency defaults to\n   * `1`.  If the concurrency is `0`, an error is thrown.\n   * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are three\n   * differences between `queue` and `priorityQueue` objects:\n   * * `push(task, priority, [callback])` - `priority` should be a number. If an\n   *   array of `tasks` is given, all tasks will be assigned the same priority.\n   * * `pushAsync(task, priority, [callback])` - the same as `priorityQueue.push`,\n   *   except this returns a promise that rejects if an error occurs.\n   * * The `unshift` and `unshiftAsync` methods were removed.\n   */\n  function priorityQueue(worker, concurrency) {\n    // Start with a normal queue\n    var q = queue$1(worker, concurrency);\n    var {\n      push,\n      pushAsync\n    } = q;\n    q._tasks = new Heap();\n    q._createTaskItem = ({\n      data,\n      priority\n    }, callback) => {\n      return {\n        data,\n        priority,\n        callback\n      };\n    };\n    function createDataItems(tasks, priority) {\n      if (!Array.isArray(tasks)) {\n        return {\n          data: tasks,\n          priority\n        };\n      }\n      return tasks.map(data => {\n        return {\n          data,\n          priority\n        };\n      });\n    }\n\n    // Override push to accept second parameter representing priority\n    q.push = function (data, priority = 0, callback) {\n      return push(createDataItems(data, priority), callback);\n    };\n    q.pushAsync = function (data, priority = 0, callback) {\n      return pushAsync(createDataItems(data, priority), callback);\n    };\n\n    // Remove unshift functions\n    delete q.unshift;\n    delete q.unshiftAsync;\n    return q;\n  }\n\n  /**\n   * Runs the `tasks` array of functions in parallel, without waiting until the\n   * previous function has completed. Once any of the `tasks` complete or pass an\n   * error to its callback, the main `callback` is immediately called. It's\n   * equivalent to `Promise.race()`.\n   *\n   * @name race\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @category Control Flow\n   * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n   * to run. Each function can complete with an optional `result` value.\n   * @param {Function} callback - A callback to run once any of the functions have\n   * completed. This function gets an error or result from the first function that\n   * completed. Invoked with (err, result).\n   * @returns {Promise} a promise, if a callback is omitted\n   * @example\n   *\n   * async.race([\n   *     function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 'one');\n   *         }, 200);\n   *     },\n   *     function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 'two');\n   *         }, 100);\n   *     }\n   * ],\n   * // main callback\n   * function(err, result) {\n   *     // the result will be equal to 'two' as it finishes earlier\n   * });\n   */\n  function race(tasks, callback) {\n    callback = once(callback);\n    if (!Array.isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n    if (!tasks.length) return callback();\n    for (var i = 0, l = tasks.length; i < l; i++) {\n      wrapAsync(tasks[i])(callback);\n    }\n  }\n  var race$1 = awaitify(race, 2);\n\n  /**\n   * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n   *\n   * @name reduceRight\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.reduce]{@link module:Collections.reduce}\n   * @alias foldr\n   * @category Collection\n   * @param {Array} array - A collection to iterate over.\n   * @param {*} memo - The initial state of the reduction.\n   * @param {AsyncFunction} iteratee - A function applied to each item in the\n   * array to produce the next step in the reduction.\n   * The `iteratee` should complete with the next state of the reduction.\n   * If the iteratee completes with an error, the reduction is stopped and the\n   * main `callback` is immediately called with the error.\n   * Invoked with (memo, item, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished. Result is the reduced value. Invoked with\n   * (err, result).\n   * @returns {Promise} a promise, if no callback is passed\n   */\n  function reduceRight(array, memo, iteratee, callback) {\n    var reversed = [...array].reverse();\n    return reduce$1(reversed, memo, iteratee, callback);\n  }\n\n  /**\n   * Wraps the async function in another function that always completes with a\n   * result object, even when it errors.\n   *\n   * The result object has either the property `error` or `value`.\n   *\n   * @name reflect\n   * @static\n   * @memberOf module:Utils\n   * @method\n   * @category Util\n   * @param {AsyncFunction} fn - The async function you want to wrap\n   * @returns {Function} - A function that always passes null to it's callback as\n   * the error. The second argument to the callback will be an `object` with\n   * either an `error` or a `value` property.\n   * @example\n   *\n   * async.parallel([\n   *     async.reflect(function(callback) {\n   *         // do some stuff ...\n   *         callback(null, 'one');\n   *     }),\n   *     async.reflect(function(callback) {\n   *         // do some more stuff but error ...\n   *         callback('bad stuff happened');\n   *     }),\n   *     async.reflect(function(callback) {\n   *         // do some more stuff ...\n   *         callback(null, 'two');\n   *     })\n   * ],\n   * // optional callback\n   * function(err, results) {\n   *     // values\n   *     // results[0].value = 'one'\n   *     // results[1].error = 'bad stuff happened'\n   *     // results[2].value = 'two'\n   * });\n   */\n  function reflect(fn) {\n    var _fn = wrapAsync(fn);\n    return initialParams(function reflectOn(args, reflectCallback) {\n      args.push((error, ...cbArgs) => {\n        let retVal = {};\n        if (error) {\n          retVal.error = error;\n        }\n        if (cbArgs.length > 0) {\n          var value = cbArgs;\n          if (cbArgs.length <= 1) {\n            [value] = cbArgs;\n          }\n          retVal.value = value;\n        }\n        reflectCallback(null, retVal);\n      });\n      return _fn.apply(this, args);\n    });\n  }\n\n  /**\n   * A helper function that wraps an array or an object of functions with `reflect`.\n   *\n   * @name reflectAll\n   * @static\n   * @memberOf module:Utils\n   * @method\n   * @see [async.reflect]{@link module:Utils.reflect}\n   * @category Util\n   * @param {Array|Object|Iterable} tasks - The collection of\n   * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n   * @returns {Array} Returns an array of async functions, each wrapped in\n   * `async.reflect`\n   * @example\n   *\n   * let tasks = [\n   *     function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 'one');\n   *         }, 200);\n   *     },\n   *     function(callback) {\n   *         // do some more stuff but error ...\n   *         callback(new Error('bad stuff happened'));\n   *     },\n   *     function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 'two');\n   *         }, 100);\n   *     }\n   * ];\n   *\n   * async.parallel(async.reflectAll(tasks),\n   * // optional callback\n   * function(err, results) {\n   *     // values\n   *     // results[0].value = 'one'\n   *     // results[1].error = Error('bad stuff happened')\n   *     // results[2].value = 'two'\n   * });\n   *\n   * // an example using an object instead of an array\n   * let tasks = {\n   *     one: function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 'one');\n   *         }, 200);\n   *     },\n   *     two: function(callback) {\n   *         callback('two');\n   *     },\n   *     three: function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 'three');\n   *         }, 100);\n   *     }\n   * };\n   *\n   * async.parallel(async.reflectAll(tasks),\n   * // optional callback\n   * function(err, results) {\n   *     // values\n   *     // results.one.value = 'one'\n   *     // results.two.error = 'two'\n   *     // results.three.value = 'three'\n   * });\n   */\n  function reflectAll(tasks) {\n    var results;\n    if (Array.isArray(tasks)) {\n      results = tasks.map(reflect);\n    } else {\n      results = {};\n      Object.keys(tasks).forEach(key => {\n        results[key] = reflect.call(this, tasks[key]);\n      });\n    }\n    return results;\n  }\n  function reject(eachfn, arr, _iteratee, callback) {\n    const iteratee = wrapAsync(_iteratee);\n    return _filter(eachfn, arr, (value, cb) => {\n      iteratee(value, (err, v) => {\n        cb(err, !v);\n      });\n    }, callback);\n  }\n\n  /**\n   * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n   *\n   * @name reject\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.filter]{@link module:Collections.filter}\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {Function} iteratee - An async truth test to apply to each item in\n   * `coll`.\n   * The should complete with a boolean value as its `result`.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished. Invoked with (err, results).\n   * @returns {Promise} a promise, if no callback is passed\n   * @example\n   *\n   * // dir1 is a directory that contains file1.txt, file2.txt\n   * // dir2 is a directory that contains file3.txt, file4.txt\n   * // dir3 is a directory that contains file5.txt\n   *\n   * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];\n   *\n   * // asynchronous function that checks if a file exists\n   * function fileExists(file, callback) {\n   *    fs.access(file, fs.constants.F_OK, (err) => {\n   *        callback(null, !err);\n   *    });\n   * }\n   *\n   * // Using callbacks\n   * async.reject(fileList, fileExists, function(err, results) {\n   *    // [ 'dir3/file6.txt' ]\n   *    // results now equals an array of the non-existing files\n   * });\n   *\n   * // Using Promises\n   * async.reject(fileList, fileExists)\n   * .then( results => {\n   *     console.log(results);\n   *     // [ 'dir3/file6.txt' ]\n   *     // results now equals an array of the non-existing files\n   * }).catch( err => {\n   *     console.log(err);\n   * });\n   *\n   * // Using async/await\n   * async () => {\n   *     try {\n   *         let results = await async.reject(fileList, fileExists);\n   *         console.log(results);\n   *         // [ 'dir3/file6.txt' ]\n   *         // results now equals an array of the non-existing files\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   */\n  function reject$1(coll, iteratee, callback) {\n    return reject(eachOf$1, coll, iteratee, callback);\n  }\n  var reject$2 = awaitify(reject$1, 3);\n\n  /**\n   * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n   * time.\n   *\n   * @name rejectLimit\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.reject]{@link module:Collections.reject}\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {number} limit - The maximum number of async operations at a time.\n   * @param {Function} iteratee - An async truth test to apply to each item in\n   * `coll`.\n   * The should complete with a boolean value as its `result`.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished. Invoked with (err, results).\n   * @returns {Promise} a promise, if no callback is passed\n   */\n  function rejectLimit(coll, limit, iteratee, callback) {\n    return reject(eachOfLimit(limit), coll, iteratee, callback);\n  }\n  var rejectLimit$1 = awaitify(rejectLimit, 4);\n\n  /**\n   * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n   *\n   * @name rejectSeries\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.reject]{@link module:Collections.reject}\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {Function} iteratee - An async truth test to apply to each item in\n   * `coll`.\n   * The should complete with a boolean value as its `result`.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished. Invoked with (err, results).\n   * @returns {Promise} a promise, if no callback is passed\n   */\n  function rejectSeries(coll, iteratee, callback) {\n    return reject(eachOfSeries$1, coll, iteratee, callback);\n  }\n  var rejectSeries$1 = awaitify(rejectSeries, 3);\n  function constant$1(value) {\n    return function () {\n      return value;\n    };\n  }\n\n  /**\n   * Attempts to get a successful response from `task` no more than `times` times\n   * before returning an error. If the task is successful, the `callback` will be\n   * passed the result of the successful task. If all attempts fail, the callback\n   * will be passed the error and result (if any) of the final attempt.\n   *\n   * @name retry\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @category Control Flow\n   * @see [async.retryable]{@link module:ControlFlow.retryable}\n   * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n   * object with `times` and `interval` or a number.\n   * * `times` - The number of attempts to make before giving up.  The default\n   *   is `5`.\n   * * `interval` - The time to wait between retries, in milliseconds.  The\n   *   default is `0`. The interval may also be specified as a function of the\n   *   retry count (see example).\n   * * `errorFilter` - An optional synchronous function that is invoked on\n   *   erroneous result. If it returns `true` the retry attempts will continue;\n   *   if the function returns `false` the retry flow is aborted with the current\n   *   attempt's error and result being returned to the final callback.\n   *   Invoked with (err).\n   * * If `opts` is a number, the number specifies the number of times to retry,\n   *   with the default interval of `0`.\n   * @param {AsyncFunction} task - An async function to retry.\n   * Invoked with (callback).\n   * @param {Function} [callback] - An optional callback which is called when the\n   * task has succeeded, or after the final failed attempt. It receives the `err`\n   * and `result` arguments of the last attempt at completing the `task`. Invoked\n   * with (err, results).\n   * @returns {Promise} a promise if no callback provided\n   *\n   * @example\n   *\n   * // The `retry` function can be used as a stand-alone control flow by passing\n   * // a callback, as shown below:\n   *\n   * // try calling apiMethod 3 times\n   * async.retry(3, apiMethod, function(err, result) {\n   *     // do something with the result\n   * });\n   *\n   * // try calling apiMethod 3 times, waiting 200 ms between each retry\n   * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n   *     // do something with the result\n   * });\n   *\n   * // try calling apiMethod 10 times with exponential backoff\n   * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n   * async.retry({\n   *   times: 10,\n   *   interval: function(retryCount) {\n   *     return 50 * Math.pow(2, retryCount);\n   *   }\n   * }, apiMethod, function(err, result) {\n   *     // do something with the result\n   * });\n   *\n   * // try calling apiMethod the default 5 times no delay between each retry\n   * async.retry(apiMethod, function(err, result) {\n   *     // do something with the result\n   * });\n   *\n   * // try calling apiMethod only when error condition satisfies, all other\n   * // errors will abort the retry control flow and return to final callback\n   * async.retry({\n   *   errorFilter: function(err) {\n   *     return err.message === 'Temporary error'; // only retry on a specific error\n   *   }\n   * }, apiMethod, function(err, result) {\n   *     // do something with the result\n   * });\n   *\n   * // to retry individual methods that are not as reliable within other\n   * // control flow functions, use the `retryable` wrapper:\n   * async.auto({\n   *     users: api.getUsers.bind(api),\n   *     payments: async.retryable(3, api.getPayments.bind(api))\n   * }, function(err, results) {\n   *     // do something with the results\n   * });\n   *\n   */\n  const DEFAULT_TIMES = 5;\n  const DEFAULT_INTERVAL = 0;\n  function retry(opts, task, callback) {\n    var options = {\n      times: DEFAULT_TIMES,\n      intervalFunc: constant$1(DEFAULT_INTERVAL)\n    };\n    if (arguments.length < 3 && typeof opts === 'function') {\n      callback = task || promiseCallback();\n      task = opts;\n    } else {\n      parseTimes(options, opts);\n      callback = callback || promiseCallback();\n    }\n    if (typeof task !== 'function') {\n      throw new Error(\"Invalid arguments for async.retry\");\n    }\n    var _task = wrapAsync(task);\n    var attempt = 1;\n    function retryAttempt() {\n      _task((err, ...args) => {\n        if (err === false) return;\n        if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {\n          setTimeout(retryAttempt, options.intervalFunc(attempt - 1));\n        } else {\n          callback(err, ...args);\n        }\n      });\n    }\n    retryAttempt();\n    return callback[PROMISE_SYMBOL];\n  }\n  function parseTimes(acc, t) {\n    if (typeof t === 'object') {\n      acc.times = +t.times || DEFAULT_TIMES;\n      acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);\n      acc.errorFilter = t.errorFilter;\n    } else if (typeof t === 'number' || typeof t === 'string') {\n      acc.times = +t || DEFAULT_TIMES;\n    } else {\n      throw new Error(\"Invalid arguments for async.retry\");\n    }\n  }\n\n  /**\n   * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n   * wraps a task and makes it retryable, rather than immediately calling it\n   * with retries.\n   *\n   * @name retryable\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @see [async.retry]{@link module:ControlFlow.retry}\n   * @category Control Flow\n   * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n   * options, exactly the same as from `retry`, except for a `opts.arity` that\n   * is the arity of the `task` function, defaulting to `task.length`\n   * @param {AsyncFunction} task - the asynchronous function to wrap.\n   * This function will be passed any arguments passed to the returned wrapper.\n   * Invoked with (...args, callback).\n   * @returns {AsyncFunction} The wrapped function, which when invoked, will\n   * retry on an error, based on the parameters specified in `opts`.\n   * This function will accept the same parameters as `task`.\n   * @example\n   *\n   * async.auto({\n   *     dep1: async.retryable(3, getFromFlakyService),\n   *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n   *         maybeProcessData(results.dep1, cb);\n   *     })]\n   * }, callback);\n   */\n  function retryable(opts, task) {\n    if (!task) {\n      task = opts;\n      opts = null;\n    }\n    let arity = opts && opts.arity || task.length;\n    if (isAsync(task)) {\n      arity += 1;\n    }\n    var _task = wrapAsync(task);\n    return initialParams((args, callback) => {\n      if (args.length < arity - 1 || callback == null) {\n        args.push(callback);\n        callback = promiseCallback();\n      }\n      function taskFn(cb) {\n        _task(...args, cb);\n      }\n      if (opts) retry(opts, taskFn, callback);else retry(taskFn, callback);\n      return callback[PROMISE_SYMBOL];\n    });\n  }\n\n  /**\n   * Run the functions in the `tasks` collection in series, each one running once\n   * the previous function has completed. If any functions in the series pass an\n   * error to its callback, no more functions are run, and `callback` is\n   * immediately called with the value of the error. Otherwise, `callback`\n   * receives an array of results when `tasks` have completed.\n   *\n   * It is also possible to use an object instead of an array. Each property will\n   * be run as a function, and the results will be passed to the final `callback`\n   * as an object instead of an array. This can be a more readable way of handling\n   *  results from {@link async.series}.\n   *\n   * **Note** that while many implementations preserve the order of object\n   * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n   * explicitly states that\n   *\n   * > The mechanics and order of enumerating the properties is not specified.\n   *\n   * So if you rely on the order in which your series of functions are executed,\n   * and want this to work on all platforms, consider using an array.\n   *\n   * @name series\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @category Control Flow\n   * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing\n   * [async functions]{@link AsyncFunction} to run in series.\n   * Each function can complete with any number of optional `result` values.\n   * @param {Function} [callback] - An optional callback to run once all the\n   * functions have completed. This function gets a results array (or object)\n   * containing all the result arguments passed to the `task` callbacks. Invoked\n   * with (err, result).\n   * @return {Promise} a promise, if no callback is passed\n   * @example\n   *\n   * //Using Callbacks\n   * async.series([\n   *     function(callback) {\n   *         setTimeout(function() {\n   *             // do some async task\n   *             callback(null, 'one');\n   *         }, 200);\n   *     },\n   *     function(callback) {\n   *         setTimeout(function() {\n   *             // then do another async task\n   *             callback(null, 'two');\n   *         }, 100);\n   *     }\n   * ], function(err, results) {\n   *     console.log(results);\n   *     // results is equal to ['one','two']\n   * });\n   *\n   * // an example using objects instead of arrays\n   * async.series({\n   *     one: function(callback) {\n   *         setTimeout(function() {\n   *             // do some async task\n   *             callback(null, 1);\n   *         }, 200);\n   *     },\n   *     two: function(callback) {\n   *         setTimeout(function() {\n   *             // then do another async task\n   *             callback(null, 2);\n   *         }, 100);\n   *     }\n   * }, function(err, results) {\n   *     console.log(results);\n   *     // results is equal to: { one: 1, two: 2 }\n   * });\n   *\n   * //Using Promises\n   * async.series([\n   *     function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 'one');\n   *         }, 200);\n   *     },\n   *     function(callback) {\n   *         setTimeout(function() {\n   *             callback(null, 'two');\n   *         }, 100);\n   *     }\n   * ]).then(results => {\n   *     console.log(results);\n   *     // results is equal to ['one','two']\n   * }).catch(err => {\n   *     console.log(err);\n   * });\n   *\n   * // an example using an object instead of an array\n   * async.series({\n   *     one: function(callback) {\n   *         setTimeout(function() {\n   *             // do some async task\n   *             callback(null, 1);\n   *         }, 200);\n   *     },\n   *     two: function(callback) {\n   *         setTimeout(function() {\n   *             // then do another async task\n   *             callback(null, 2);\n   *         }, 100);\n   *     }\n   * }).then(results => {\n   *     console.log(results);\n   *     // results is equal to: { one: 1, two: 2 }\n   * }).catch(err => {\n   *     console.log(err);\n   * });\n   *\n   * //Using async/await\n   * async () => {\n   *     try {\n   *         let results = await async.series([\n   *             function(callback) {\n   *                 setTimeout(function() {\n   *                     // do some async task\n   *                     callback(null, 'one');\n   *                 }, 200);\n   *             },\n   *             function(callback) {\n   *                 setTimeout(function() {\n   *                     // then do another async task\n   *                     callback(null, 'two');\n   *                 }, 100);\n   *             }\n   *         ]);\n   *         console.log(results);\n   *         // results is equal to ['one','two']\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   * // an example using an object instead of an array\n   * async () => {\n   *     try {\n   *         let results = await async.parallel({\n   *             one: function(callback) {\n   *                 setTimeout(function() {\n   *                     // do some async task\n   *                     callback(null, 1);\n   *                 }, 200);\n   *             },\n   *            two: function(callback) {\n   *                 setTimeout(function() {\n   *                     // then do another async task\n   *                     callback(null, 2);\n   *                 }, 100);\n   *            }\n   *         });\n   *         console.log(results);\n   *         // results is equal to: { one: 1, two: 2 }\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   */\n  function series(tasks, callback) {\n    return parallel(eachOfSeries$1, tasks, callback);\n  }\n\n  /**\n   * Returns `true` if at least one element in the `coll` satisfies an async test.\n   * If any iteratee call returns `true`, the main `callback` is immediately\n   * called.\n   *\n   * @name some\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @alias any\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n   * in the collections in parallel.\n   * The iteratee should complete with a boolean `result` value.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called as soon as any\n   * iteratee returns `true`, or after all the iteratee functions have finished.\n   * Result will be either `true` or `false` depending on the values of the async\n   * tests. Invoked with (err, result).\n   * @returns {Promise} a promise, if no callback provided\n   * @example\n   *\n   * // dir1 is a directory that contains file1.txt, file2.txt\n   * // dir2 is a directory that contains file3.txt, file4.txt\n   * // dir3 is a directory that contains file5.txt\n   * // dir4 does not exist\n   *\n   * // asynchronous function that checks if a file exists\n   * function fileExists(file, callback) {\n   *    fs.access(file, fs.constants.F_OK, (err) => {\n   *        callback(null, !err);\n   *    });\n   * }\n   *\n   * // Using callbacks\n   * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists,\n   *    function(err, result) {\n   *        console.log(result);\n   *        // true\n   *        // result is true since some file in the list exists\n   *    }\n   *);\n   *\n   * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists,\n   *    function(err, result) {\n   *        console.log(result);\n   *        // false\n   *        // result is false since none of the files exists\n   *    }\n   *);\n   *\n   * // Using Promises\n   * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists)\n   * .then( result => {\n   *     console.log(result);\n   *     // true\n   *     // result is true since some file in the list exists\n   * }).catch( err => {\n   *     console.log(err);\n   * });\n   *\n   * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists)\n   * .then( result => {\n   *     console.log(result);\n   *     // false\n   *     // result is false since none of the files exists\n   * }).catch( err => {\n   *     console.log(err);\n   * });\n   *\n   * // Using async/await\n   * async () => {\n   *     try {\n   *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists);\n   *         console.log(result);\n   *         // true\n   *         // result is true since some file in the list exists\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   * async () => {\n   *     try {\n   *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists);\n   *         console.log(result);\n   *         // false\n   *         // result is false since none of the files exists\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   */\n  function some(coll, iteratee, callback) {\n    return _createTester(Boolean, res => res)(eachOf$1, coll, iteratee, callback);\n  }\n  var some$1 = awaitify(some, 3);\n\n  /**\n   * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n   *\n   * @name someLimit\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.some]{@link module:Collections.some}\n   * @alias anyLimit\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {number} limit - The maximum number of async operations at a time.\n   * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n   * in the collections in parallel.\n   * The iteratee should complete with a boolean `result` value.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called as soon as any\n   * iteratee returns `true`, or after all the iteratee functions have finished.\n   * Result will be either `true` or `false` depending on the values of the async\n   * tests. Invoked with (err, result).\n   * @returns {Promise} a promise, if no callback provided\n   */\n  function someLimit(coll, limit, iteratee, callback) {\n    return _createTester(Boolean, res => res)(eachOfLimit(limit), coll, iteratee, callback);\n  }\n  var someLimit$1 = awaitify(someLimit, 4);\n\n  /**\n   * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n   *\n   * @name someSeries\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @see [async.some]{@link module:Collections.some}\n   * @alias anySeries\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n   * in the collections in series.\n   * The iteratee should complete with a boolean `result` value.\n   * Invoked with (item, callback).\n   * @param {Function} [callback] - A callback which is called as soon as any\n   * iteratee returns `true`, or after all the iteratee functions have finished.\n   * Result will be either `true` or `false` depending on the values of the async\n   * tests. Invoked with (err, result).\n   * @returns {Promise} a promise, if no callback provided\n   */\n  function someSeries(coll, iteratee, callback) {\n    return _createTester(Boolean, res => res)(eachOfSeries$1, coll, iteratee, callback);\n  }\n  var someSeries$1 = awaitify(someSeries, 3);\n\n  /**\n   * Sorts a list by the results of running each `coll` value through an async\n   * `iteratee`.\n   *\n   * @name sortBy\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {AsyncFunction} iteratee - An async function to apply to each item in\n   * `coll`.\n   * The iteratee should complete with a value to use as the sort criteria as\n   * its `result`.\n   * Invoked with (item, callback).\n   * @param {Function} callback - A callback which is called after all the\n   * `iteratee` functions have finished, or an error occurs. Results is the items\n   * from the original `coll` sorted by the values returned by the `iteratee`\n   * calls. Invoked with (err, results).\n   * @returns {Promise} a promise, if no callback passed\n   * @example\n   *\n   * // bigfile.txt is a file that is 251100 bytes in size\n   * // mediumfile.txt is a file that is 11000 bytes in size\n   * // smallfile.txt is a file that is 121 bytes in size\n   *\n   * // asynchronous function that returns the file size in bytes\n   * function getFileSizeInBytes(file, callback) {\n   *     fs.stat(file, function(err, stat) {\n   *         if (err) {\n   *             return callback(err);\n   *         }\n   *         callback(null, stat.size);\n   *     });\n   * }\n   *\n   * // Using callbacks\n   * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes,\n   *     function(err, results) {\n   *         if (err) {\n   *             console.log(err);\n   *         } else {\n   *             console.log(results);\n   *             // results is now the original array of files sorted by\n   *             // file size (ascending by default), e.g.\n   *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n   *         }\n   *     }\n   * );\n   *\n   * // By modifying the callback parameter the\n   * // sorting order can be influenced:\n   *\n   * // ascending order\n   * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], function(file, callback) {\n   *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {\n   *         if (getFileSizeErr) return callback(getFileSizeErr);\n   *         callback(null, fileSize);\n   *     });\n   * }, function(err, results) {\n   *         if (err) {\n   *             console.log(err);\n   *         } else {\n   *             console.log(results);\n   *             // results is now the original array of files sorted by\n   *             // file size (ascending by default), e.g.\n   *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n   *         }\n   *     }\n   * );\n   *\n   * // descending order\n   * async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], function(file, callback) {\n   *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {\n   *         if (getFileSizeErr) {\n   *             return callback(getFileSizeErr);\n   *         }\n   *         callback(null, fileSize * -1);\n   *     });\n   * }, function(err, results) {\n   *         if (err) {\n   *             console.log(err);\n   *         } else {\n   *             console.log(results);\n   *             // results is now the original array of files sorted by\n   *             // file size (ascending by default), e.g.\n   *             // [ 'bigfile.txt', 'mediumfile.txt', 'smallfile.txt']\n   *         }\n   *     }\n   * );\n   *\n   * // Error handling\n   * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes,\n   *     function(err, results) {\n   *         if (err) {\n   *             console.log(err);\n   *             // [ Error: ENOENT: no such file or directory ]\n   *         } else {\n   *             console.log(results);\n   *         }\n   *     }\n   * );\n   *\n   * // Using Promises\n   * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes)\n   * .then( results => {\n   *     console.log(results);\n   *     // results is now the original array of files sorted by\n   *     // file size (ascending by default), e.g.\n   *     // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n   * }).catch( err => {\n   *     console.log(err);\n   * });\n   *\n   * // Error handling\n   * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes)\n   * .then( results => {\n   *     console.log(results);\n   * }).catch( err => {\n   *     console.log(err);\n   *     // [ Error: ENOENT: no such file or directory ]\n   * });\n   *\n   * // Using async/await\n   * (async () => {\n   *     try {\n   *         let results = await async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);\n   *         console.log(results);\n   *         // results is now the original array of files sorted by\n   *         // file size (ascending by default), e.g.\n   *         // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * })();\n   *\n   * // Error handling\n   * async () => {\n   *     try {\n   *         let results = await async.sortBy(['missingfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);\n   *         console.log(results);\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *         // [ Error: ENOENT: no such file or directory ]\n   *     }\n   * }\n   *\n   */\n  function sortBy(coll, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return map$1(coll, (x, iterCb) => {\n      _iteratee(x, (err, criteria) => {\n        if (err) return iterCb(err);\n        iterCb(err, {\n          value: x,\n          criteria\n        });\n      });\n    }, (err, results) => {\n      if (err) return callback(err);\n      callback(null, results.sort(comparator).map(v => v.value));\n    });\n    function comparator(left, right) {\n      var a = left.criteria,\n        b = right.criteria;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }\n  }\n  var sortBy$1 = awaitify(sortBy, 3);\n\n  /**\n   * Sets a time limit on an asynchronous function. If the function does not call\n   * its callback within the specified milliseconds, it will be called with a\n   * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n   *\n   * @name timeout\n   * @static\n   * @memberOf module:Utils\n   * @method\n   * @category Util\n   * @param {AsyncFunction} asyncFn - The async function to limit in time.\n   * @param {number} milliseconds - The specified time limit.\n   * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n   * to timeout Error for more information..\n   * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n   * of the control flow functions.\n   * Invoke this function with the same parameters as you would `asyncFunc`.\n   * @example\n   *\n   * function myFunction(foo, callback) {\n   *     doAsyncTask(foo, function(err, data) {\n   *         // handle errors\n   *         if (err) return callback(err);\n   *\n   *         // do some stuff ...\n   *\n   *         // return processed data\n   *         return callback(null, data);\n   *     });\n   * }\n   *\n   * var wrapped = async.timeout(myFunction, 1000);\n   *\n   * // call `wrapped` as you would `myFunction`\n   * wrapped({ bar: 'bar' }, function(err, data) {\n   *     // if `myFunction` takes < 1000 ms to execute, `err`\n   *     // and `data` will have their expected values\n   *\n   *     // else `err` will be an Error with the code 'ETIMEDOUT'\n   * });\n   */\n  function timeout(asyncFn, milliseconds, info) {\n    var fn = wrapAsync(asyncFn);\n    return initialParams((args, callback) => {\n      var timedOut = false;\n      var timer;\n      function timeoutCallback() {\n        var name = asyncFn.name || 'anonymous';\n        var error = new Error('Callback function \"' + name + '\" timed out.');\n        error.code = 'ETIMEDOUT';\n        if (info) {\n          error.info = info;\n        }\n        timedOut = true;\n        callback(error);\n      }\n      args.push((...cbArgs) => {\n        if (!timedOut) {\n          callback(...cbArgs);\n          clearTimeout(timer);\n        }\n      });\n\n      // setup timer and call original function\n      timer = setTimeout(timeoutCallback, milliseconds);\n      fn(...args);\n    });\n  }\n  function range(size) {\n    var result = Array(size);\n    while (size--) {\n      result[size] = size;\n    }\n    return result;\n  }\n\n  /**\n   * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n   * time.\n   *\n   * @name timesLimit\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @see [async.times]{@link module:ControlFlow.times}\n   * @category Control Flow\n   * @param {number} count - The number of times to run the function.\n   * @param {number} limit - The maximum number of async operations at a time.\n   * @param {AsyncFunction} iteratee - The async function to call `n` times.\n   * Invoked with the iteration index and a callback: (n, next).\n   * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n   * @returns {Promise} a promise, if no callback is provided\n   */\n  function timesLimit(count, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return mapLimit$1(range(count), limit, _iteratee, callback);\n  }\n\n  /**\n   * Calls the `iteratee` function `n` times, and accumulates results in the same\n   * manner you would use with [map]{@link module:Collections.map}.\n   *\n   * @name times\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @see [async.map]{@link module:Collections.map}\n   * @category Control Flow\n   * @param {number} n - The number of times to run the function.\n   * @param {AsyncFunction} iteratee - The async function to call `n` times.\n   * Invoked with the iteration index and a callback: (n, next).\n   * @param {Function} callback - see {@link module:Collections.map}.\n   * @returns {Promise} a promise, if no callback is provided\n   * @example\n   *\n   * // Pretend this is some complicated async factory\n   * var createUser = function(id, callback) {\n   *     callback(null, {\n   *         id: 'user' + id\n   *     });\n   * };\n   *\n   * // generate 5 users\n   * async.times(5, function(n, next) {\n   *     createUser(n, function(err, user) {\n   *         next(err, user);\n   *     });\n   * }, function(err, users) {\n   *     // we should now have 5 users\n   * });\n   */\n  function times(n, iteratee, callback) {\n    return timesLimit(n, Infinity, iteratee, callback);\n  }\n\n  /**\n   * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n   *\n   * @name timesSeries\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @see [async.times]{@link module:ControlFlow.times}\n   * @category Control Flow\n   * @param {number} n - The number of times to run the function.\n   * @param {AsyncFunction} iteratee - The async function to call `n` times.\n   * Invoked with the iteration index and a callback: (n, next).\n   * @param {Function} callback - see {@link module:Collections.map}.\n   * @returns {Promise} a promise, if no callback is provided\n   */\n  function timesSeries(n, iteratee, callback) {\n    return timesLimit(n, 1, iteratee, callback);\n  }\n\n  /**\n   * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n   * element in parallel, each step potentially mutating an `accumulator` value.\n   * The type of the accumulator defaults to the type of collection passed in.\n   *\n   * @name transform\n   * @static\n   * @memberOf module:Collections\n   * @method\n   * @category Collection\n   * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n   * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n   * it will default to an empty Object or Array, depending on the type of `coll`\n   * @param {AsyncFunction} iteratee - A function applied to each item in the\n   * collection that potentially modifies the accumulator.\n   * Invoked with (accumulator, item, key, callback).\n   * @param {Function} [callback] - A callback which is called after all the\n   * `iteratee` functions have finished. Result is the transformed accumulator.\n   * Invoked with (err, result).\n   * @returns {Promise} a promise, if no callback provided\n   * @example\n   *\n   * // file1.txt is a file that is 1000 bytes in size\n   * // file2.txt is a file that is 2000 bytes in size\n   * // file3.txt is a file that is 3000 bytes in size\n   *\n   * // helper function that returns human-readable size format from bytes\n   * function formatBytes(bytes, decimals = 2) {\n   *   // implementation not included for brevity\n   *   return humanReadbleFilesize;\n   * }\n   *\n   * const fileList = ['file1.txt','file2.txt','file3.txt'];\n   *\n   * // asynchronous function that returns the file size, transformed to human-readable format\n   * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.\n   * function transformFileSize(acc, value, key, callback) {\n   *     fs.stat(value, function(err, stat) {\n   *         if (err) {\n   *             return callback(err);\n   *         }\n   *         acc[key] = formatBytes(stat.size);\n   *         callback(null);\n   *     });\n   * }\n   *\n   * // Using callbacks\n   * async.transform(fileList, transformFileSize, function(err, result) {\n   *     if(err) {\n   *         console.log(err);\n   *     } else {\n   *         console.log(result);\n   *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n   *     }\n   * });\n   *\n   * // Using Promises\n   * async.transform(fileList, transformFileSize)\n   * .then(result => {\n   *     console.log(result);\n   *     // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n   * }).catch(err => {\n   *     console.log(err);\n   * });\n   *\n   * // Using async/await\n   * (async () => {\n   *     try {\n   *         let result = await async.transform(fileList, transformFileSize);\n   *         console.log(result);\n   *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * })();\n   *\n   * @example\n   *\n   * // file1.txt is a file that is 1000 bytes in size\n   * // file2.txt is a file that is 2000 bytes in size\n   * // file3.txt is a file that is 3000 bytes in size\n   *\n   * // helper function that returns human-readable size format from bytes\n   * function formatBytes(bytes, decimals = 2) {\n   *   // implementation not included for brevity\n   *   return humanReadbleFilesize;\n   * }\n   *\n   * const fileMap = { f1: 'file1.txt', f2: 'file2.txt', f3: 'file3.txt' };\n   *\n   * // asynchronous function that returns the file size, transformed to human-readable format\n   * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.\n   * function transformFileSize(acc, value, key, callback) {\n   *     fs.stat(value, function(err, stat) {\n   *         if (err) {\n   *             return callback(err);\n   *         }\n   *         acc[key] = formatBytes(stat.size);\n   *         callback(null);\n   *     });\n   * }\n   *\n   * // Using callbacks\n   * async.transform(fileMap, transformFileSize, function(err, result) {\n   *     if(err) {\n   *         console.log(err);\n   *     } else {\n   *         console.log(result);\n   *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n   *     }\n   * });\n   *\n   * // Using Promises\n   * async.transform(fileMap, transformFileSize)\n   * .then(result => {\n   *     console.log(result);\n   *     // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n   * }).catch(err => {\n   *     console.log(err);\n   * });\n   *\n   * // Using async/await\n   * async () => {\n   *     try {\n   *         let result = await async.transform(fileMap, transformFileSize);\n   *         console.log(result);\n   *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n   *     }\n   *     catch (err) {\n   *         console.log(err);\n   *     }\n   * }\n   *\n   */\n  function transform(coll, accumulator, iteratee, callback) {\n    if (arguments.length <= 3 && typeof accumulator === 'function') {\n      callback = iteratee;\n      iteratee = accumulator;\n      accumulator = Array.isArray(coll) ? [] : {};\n    }\n    callback = once(callback || promiseCallback());\n    var _iteratee = wrapAsync(iteratee);\n    eachOf$1(coll, (v, k, cb) => {\n      _iteratee(accumulator, v, k, cb);\n    }, err => callback(err, accumulator));\n    return callback[PROMISE_SYMBOL];\n  }\n\n  /**\n   * It runs each task in series but stops whenever any of the functions were\n   * successful. If one of the tasks were successful, the `callback` will be\n   * passed the result of the successful task. If all tasks fail, the callback\n   * will be passed the error and result (if any) of the final attempt.\n   *\n   * @name tryEach\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @category Control Flow\n   * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing functions to\n   * run, each function is passed a `callback(err, result)` it must call on\n   * completion with an error `err` (which can be `null`) and an optional `result`\n   * value.\n   * @param {Function} [callback] - An optional callback which is called when one\n   * of the tasks has succeeded, or all have failed. It receives the `err` and\n   * `result` arguments of the last attempt at completing the `task`. Invoked with\n   * (err, results).\n   * @returns {Promise} a promise, if no callback is passed\n   * @example\n   * async.tryEach([\n   *     function getDataFromFirstWebsite(callback) {\n   *         // Try getting the data from the first website\n   *         callback(err, data);\n   *     },\n   *     function getDataFromSecondWebsite(callback) {\n   *         // First website failed,\n   *         // Try getting the data from the backup website\n   *         callback(err, data);\n   *     }\n   * ],\n   * // optional callback\n   * function(err, results) {\n   *     Now do something with the data.\n   * });\n   *\n   */\n  function tryEach(tasks, callback) {\n    var error = null;\n    var result;\n    return eachSeries$1(tasks, (task, taskCb) => {\n      wrapAsync(task)((err, ...args) => {\n        if (err === false) return taskCb(err);\n        if (args.length < 2) {\n          [result] = args;\n        } else {\n          result = args;\n        }\n        error = err;\n        taskCb(err ? null : {});\n      });\n    }, () => callback(error, result));\n  }\n  var tryEach$1 = awaitify(tryEach);\n\n  /**\n   * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n   * unmemoized form. Handy for testing.\n   *\n   * @name unmemoize\n   * @static\n   * @memberOf module:Utils\n   * @method\n   * @see [async.memoize]{@link module:Utils.memoize}\n   * @category Util\n   * @param {AsyncFunction} fn - the memoized function\n   * @returns {AsyncFunction} a function that calls the original unmemoized function\n   */\n  function unmemoize(fn) {\n    return (...args) => {\n      return (fn.unmemoized || fn)(...args);\n    };\n  }\n\n  /**\n   * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n   * stopped, or an error occurs.\n   *\n   * @name whilst\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @category Control Flow\n   * @param {AsyncFunction} test - asynchronous truth test to perform before each\n   * execution of `iteratee`. Invoked with ().\n   * @param {AsyncFunction} iteratee - An async function which is called each time\n   * `test` passes. Invoked with (callback).\n   * @param {Function} [callback] - A callback which is called after the test\n   * function has failed and repeated execution of `iteratee` has stopped. `callback`\n   * will be passed an error and any arguments passed to the final `iteratee`'s\n   * callback. Invoked with (err, [results]);\n   * @returns {Promise} a promise, if no callback is passed\n   * @example\n   *\n   * var count = 0;\n   * async.whilst(\n   *     function test(cb) { cb(null, count < 5); },\n   *     function iter(callback) {\n   *         count++;\n   *         setTimeout(function() {\n   *             callback(null, count);\n   *         }, 1000);\n   *     },\n   *     function (err, n) {\n   *         // 5 seconds have passed, n = 5\n   *     }\n   * );\n   */\n  function whilst(test, iteratee, callback) {\n    callback = onlyOnce(callback);\n    var _fn = wrapAsync(iteratee);\n    var _test = wrapAsync(test);\n    var results = [];\n    function next(err, ...rest) {\n      if (err) return callback(err);\n      results = rest;\n      if (err === false) return;\n      _test(check);\n    }\n    function check(err, truth) {\n      if (err) return callback(err);\n      if (err === false) return;\n      if (!truth) return callback(null, ...results);\n      _fn(next);\n    }\n    return _test(check);\n  }\n  var whilst$1 = awaitify(whilst, 3);\n\n  /**\n   * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n   * stopped, or an error occurs. `callback` will be passed an error and any\n   * arguments passed to the final `iteratee`'s callback.\n   *\n   * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n   *\n   * @name until\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @see [async.whilst]{@link module:ControlFlow.whilst}\n   * @category Control Flow\n   * @param {AsyncFunction} test - asynchronous truth test to perform before each\n   * execution of `iteratee`. Invoked with (callback).\n   * @param {AsyncFunction} iteratee - An async function which is called each time\n   * `test` fails. Invoked with (callback).\n   * @param {Function} [callback] - A callback which is called after the test\n   * function has passed and repeated execution of `iteratee` has stopped. `callback`\n   * will be passed an error and any arguments passed to the final `iteratee`'s\n   * callback. Invoked with (err, [results]);\n   * @returns {Promise} a promise, if a callback is not passed\n   *\n   * @example\n   * const results = []\n   * let finished = false\n   * async.until(function test(cb) {\n   *     cb(null, finished)\n   * }, function iter(next) {\n   *     fetchPage(url, (err, body) => {\n   *         if (err) return next(err)\n   *         results = results.concat(body.objects)\n   *         finished = !!body.next\n   *         next(err)\n   *     })\n   * }, function done (err) {\n   *     // all pages have been fetched\n   * })\n   */\n  function until(test, iteratee, callback) {\n    const _test = wrapAsync(test);\n    return whilst$1(cb => _test((err, truth) => cb(err, !truth)), iteratee, callback);\n  }\n\n  /**\n   * Runs the `tasks` array of functions in series, each passing their results to\n   * the next in the array. However, if any of the `tasks` pass an error to their\n   * own callback, the next function is not executed, and the main `callback` is\n   * immediately called with the error.\n   *\n   * @name waterfall\n   * @static\n   * @memberOf module:ControlFlow\n   * @method\n   * @category Control Flow\n   * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n   * to run.\n   * Each function should complete with any number of `result` values.\n   * The `result` values will be passed as arguments, in order, to the next task.\n   * @param {Function} [callback] - An optional callback to run once all the\n   * functions have completed. This will be passed the results of the last task's\n   * callback. Invoked with (err, [results]).\n   * @returns {Promise} a promise, if a callback is omitted\n   * @example\n   *\n   * async.waterfall([\n   *     function(callback) {\n   *         callback(null, 'one', 'two');\n   *     },\n   *     function(arg1, arg2, callback) {\n   *         // arg1 now equals 'one' and arg2 now equals 'two'\n   *         callback(null, 'three');\n   *     },\n   *     function(arg1, callback) {\n   *         // arg1 now equals 'three'\n   *         callback(null, 'done');\n   *     }\n   * ], function (err, result) {\n   *     // result now equals 'done'\n   * });\n   *\n   * // Or, with named functions:\n   * async.waterfall([\n   *     myFirstFunction,\n   *     mySecondFunction,\n   *     myLastFunction,\n   * ], function (err, result) {\n   *     // result now equals 'done'\n   * });\n   * function myFirstFunction(callback) {\n   *     callback(null, 'one', 'two');\n   * }\n   * function mySecondFunction(arg1, arg2, callback) {\n   *     // arg1 now equals 'one' and arg2 now equals 'two'\n   *     callback(null, 'three');\n   * }\n   * function myLastFunction(arg1, callback) {\n   *     // arg1 now equals 'three'\n   *     callback(null, 'done');\n   * }\n   */\n  function waterfall(tasks, callback) {\n    callback = once(callback);\n    if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n    function nextTask(args) {\n      var task = wrapAsync(tasks[taskIndex++]);\n      task(...args, onlyOnce(next));\n    }\n    function next(err, ...args) {\n      if (err === false) return;\n      if (err || taskIndex === tasks.length) {\n        return callback(err, ...args);\n      }\n      nextTask(args);\n    }\n    nextTask([]);\n  }\n  var waterfall$1 = awaitify(waterfall);\n\n  /**\n   * An \"async function\" in the context of Async is an asynchronous function with\n   * a variable number of parameters, with the final parameter being a callback.\n   * (`function (arg1, arg2, ..., callback) {}`)\n   * The final callback is of the form `callback(err, results...)`, which must be\n   * called once the function is completed.  The callback should be called with a\n   * Error as its first argument to signal that an error occurred.\n   * Otherwise, if no error occurred, it should be called with `null` as the first\n   * argument, and any additional `result` arguments that may apply, to signal\n   * successful completion.\n   * The callback must be called exactly once, ideally on a later tick of the\n   * JavaScript event loop.\n   *\n   * This type of function is also referred to as a \"Node-style async function\",\n   * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n   * library are themselves CPS/Node-style async functions, or functions that\n   * return CPS/Node-style async functions.\n   *\n   * Wherever we accept a Node-style async function, we also directly accept an\n   * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n   * In this case, the `async` function will not be passed a final callback\n   * argument, and any thrown error will be used as the `err` argument of the\n   * implicit callback, and the return value will be used as the `result` value.\n   * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n   * argument, and a `resolved` value becomes the `result`.)\n   *\n   * Note, due to JavaScript limitations, we can only detect native `async`\n   * functions and not transpilied implementations.\n   * Your environment must have `async`/`await` support for this to work.\n   * (e.g. Node > v7.6, or a recent version of a modern browser).\n   * If you are using `async` functions through a transpiler (e.g. Babel), you\n   * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n   * because the `async function` will be compiled to an ordinary function that\n   * returns a promise.\n   *\n   * @typedef {Function} AsyncFunction\n   * @static\n   */\n\n  var index = {\n    apply,\n    applyEach: applyEach$1,\n    applyEachSeries,\n    asyncify,\n    auto,\n    autoInject,\n    cargo,\n    cargoQueue: cargo$1,\n    compose,\n    concat: concat$1,\n    concatLimit: concatLimit$1,\n    concatSeries: concatSeries$1,\n    constant,\n    detect: detect$1,\n    detectLimit: detectLimit$1,\n    detectSeries: detectSeries$1,\n    dir,\n    doUntil,\n    doWhilst: doWhilst$1,\n    each,\n    eachLimit: eachLimit$2,\n    eachOf: eachOf$1,\n    eachOfLimit: eachOfLimit$2,\n    eachOfSeries: eachOfSeries$1,\n    eachSeries: eachSeries$1,\n    ensureAsync,\n    every: every$1,\n    everyLimit: everyLimit$1,\n    everySeries: everySeries$1,\n    filter: filter$1,\n    filterLimit: filterLimit$1,\n    filterSeries: filterSeries$1,\n    forever: forever$1,\n    groupBy,\n    groupByLimit: groupByLimit$1,\n    groupBySeries,\n    log,\n    map: map$1,\n    mapLimit: mapLimit$1,\n    mapSeries: mapSeries$1,\n    mapValues,\n    mapValuesLimit: mapValuesLimit$1,\n    mapValuesSeries,\n    memoize,\n    nextTick,\n    parallel: parallel$1,\n    parallelLimit,\n    priorityQueue,\n    queue: queue$1,\n    race: race$1,\n    reduce: reduce$1,\n    reduceRight,\n    reflect,\n    reflectAll,\n    reject: reject$2,\n    rejectLimit: rejectLimit$1,\n    rejectSeries: rejectSeries$1,\n    retry,\n    retryable,\n    seq,\n    series,\n    setImmediate: setImmediate$1,\n    some: some$1,\n    someLimit: someLimit$1,\n    someSeries: someSeries$1,\n    sortBy: sortBy$1,\n    timeout,\n    times,\n    timesLimit,\n    timesSeries,\n    transform,\n    tryEach: tryEach$1,\n    unmemoize,\n    until,\n    waterfall: waterfall$1,\n    whilst: whilst$1,\n    // aliases\n    all: every$1,\n    allLimit: everyLimit$1,\n    allSeries: everySeries$1,\n    any: some$1,\n    anyLimit: someLimit$1,\n    anySeries: someSeries$1,\n    find: detect$1,\n    findLimit: detectLimit$1,\n    findSeries: detectSeries$1,\n    flatMap: concat$1,\n    flatMapLimit: concatLimit$1,\n    flatMapSeries: concatSeries$1,\n    forEach: each,\n    forEachSeries: eachSeries$1,\n    forEachLimit: eachLimit$2,\n    forEachOf: eachOf$1,\n    forEachOfSeries: eachOfSeries$1,\n    forEachOfLimit: eachOfLimit$2,\n    inject: reduce$1,\n    foldl: reduce$1,\n    foldr: reduceRight,\n    select: filter$1,\n    selectLimit: filterLimit$1,\n    selectSeries: filterSeries$1,\n    wrapSync: asyncify,\n    during: whilst$1,\n    doDuring: doWhilst$1\n  };\n  exports.default = index;\n  exports.apply = apply;\n  exports.applyEach = applyEach$1;\n  exports.applyEachSeries = applyEachSeries;\n  exports.asyncify = asyncify;\n  exports.auto = auto;\n  exports.autoInject = autoInject;\n  exports.cargo = cargo;\n  exports.cargoQueue = cargo$1;\n  exports.compose = compose;\n  exports.concat = concat$1;\n  exports.concatLimit = concatLimit$1;\n  exports.concatSeries = concatSeries$1;\n  exports.constant = constant;\n  exports.detect = detect$1;\n  exports.detectLimit = detectLimit$1;\n  exports.detectSeries = detectSeries$1;\n  exports.dir = dir;\n  exports.doUntil = doUntil;\n  exports.doWhilst = doWhilst$1;\n  exports.each = each;\n  exports.eachLimit = eachLimit$2;\n  exports.eachOf = eachOf$1;\n  exports.eachOfLimit = eachOfLimit$2;\n  exports.eachOfSeries = eachOfSeries$1;\n  exports.eachSeries = eachSeries$1;\n  exports.ensureAsync = ensureAsync;\n  exports.every = every$1;\n  exports.everyLimit = everyLimit$1;\n  exports.everySeries = everySeries$1;\n  exports.filter = filter$1;\n  exports.filterLimit = filterLimit$1;\n  exports.filterSeries = filterSeries$1;\n  exports.forever = forever$1;\n  exports.groupBy = groupBy;\n  exports.groupByLimit = groupByLimit$1;\n  exports.groupBySeries = groupBySeries;\n  exports.log = log;\n  exports.map = map$1;\n  exports.mapLimit = mapLimit$1;\n  exports.mapSeries = mapSeries$1;\n  exports.mapValues = mapValues;\n  exports.mapValuesLimit = mapValuesLimit$1;\n  exports.mapValuesSeries = mapValuesSeries;\n  exports.memoize = memoize;\n  exports.nextTick = nextTick;\n  exports.parallel = parallel$1;\n  exports.parallelLimit = parallelLimit;\n  exports.priorityQueue = priorityQueue;\n  exports.queue = queue$1;\n  exports.race = race$1;\n  exports.reduce = reduce$1;\n  exports.reduceRight = reduceRight;\n  exports.reflect = reflect;\n  exports.reflectAll = reflectAll;\n  exports.reject = reject$2;\n  exports.rejectLimit = rejectLimit$1;\n  exports.rejectSeries = rejectSeries$1;\n  exports.retry = retry;\n  exports.retryable = retryable;\n  exports.seq = seq;\n  exports.series = series;\n  exports.setImmediate = setImmediate$1;\n  exports.some = some$1;\n  exports.someLimit = someLimit$1;\n  exports.someSeries = someSeries$1;\n  exports.sortBy = sortBy$1;\n  exports.timeout = timeout;\n  exports.times = times;\n  exports.timesLimit = timesLimit;\n  exports.timesSeries = timesSeries;\n  exports.transform = transform;\n  exports.tryEach = tryEach$1;\n  exports.unmemoize = unmemoize;\n  exports.until = until;\n  exports.waterfall = waterfall$1;\n  exports.whilst = whilst$1;\n  exports.all = every$1;\n  exports.allLimit = everyLimit$1;\n  exports.allSeries = everySeries$1;\n  exports.any = some$1;\n  exports.anyLimit = someLimit$1;\n  exports.anySeries = someSeries$1;\n  exports.find = detect$1;\n  exports.findLimit = detectLimit$1;\n  exports.findSeries = detectSeries$1;\n  exports.flatMap = concat$1;\n  exports.flatMapLimit = concatLimit$1;\n  exports.flatMapSeries = concatSeries$1;\n  exports.forEach = each;\n  exports.forEachSeries = eachSeries$1;\n  exports.forEachLimit = eachLimit$2;\n  exports.forEachOf = eachOf$1;\n  exports.forEachOfSeries = eachOfSeries$1;\n  exports.forEachOfLimit = eachOfLimit$2;\n  exports.inject = reduce$1;\n  exports.foldl = reduce$1;\n  exports.foldr = reduceRight;\n  exports.select = filter$1;\n  exports.selectLimit = filterLimit$1;\n  exports.selectSeries = filterSeries$1;\n  exports.wrapSync = asyncify;\n  exports.during = whilst$1;\n  exports.doDuring = doWhilst$1;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImFzeW5jIiwiYXBwbHkiLCJmbiIsImFyZ3MiLCJjYWxsQXJncyIsImluaXRpYWxQYXJhbXMiLCJjYWxsYmFjayIsInBvcCIsImNhbGwiLCJoYXNRdWV1ZU1pY3JvdGFzayIsInF1ZXVlTWljcm90YXNrIiwiaGFzU2V0SW1tZWRpYXRlIiwic2V0SW1tZWRpYXRlIiwiaGFzTmV4dFRpY2siLCJwcm9jZXNzIiwibmV4dFRpY2siLCJmYWxsYmFjayIsInNldFRpbWVvdXQiLCJ3cmFwIiwiZGVmZXIiLCJfZGVmZXIiLCJzZXRJbW1lZGlhdGUkMSIsImFzeW5jaWZ5IiwiZnVuYyIsImlzQXN5bmMiLCJwcm9taXNlIiwiaGFuZGxlUHJvbWlzZSIsInJlc3VsdCIsImUiLCJ0aGVuIiwidmFsdWUiLCJpbnZva2VDYWxsYmFjayIsImVyciIsIm1lc3NhZ2UiLCJFcnJvciIsImVycm9yIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJpc0FzeW5jR2VuZXJhdG9yIiwiaXNBc3luY0l0ZXJhYmxlIiwib2JqIiwiYXN5bmNJdGVyYXRvciIsIndyYXBBc3luYyIsImFzeW5jRm4iLCJhd2FpdGlmeSIsImFyaXR5IiwibGVuZ3RoIiwiYXdhaXRhYmxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYkFyZ3MiLCJhcHBseUVhY2giLCJlYWNoZm4iLCJmbnMiLCJnbyIsInRoYXQiLCJjYiIsImNvbmNhdCIsIl9hc3luY01hcCIsImFyciIsIml0ZXJhdGVlIiwicmVzdWx0cyIsImNvdW50ZXIiLCJfaXRlcmF0ZWUiLCJfIiwiaXRlckNiIiwiaW5kZXgiLCJ2IiwiaXNBcnJheUxpa2UiLCJicmVha0xvb3AiLCJvbmNlIiwid3JhcHBlciIsImNhbGxGbiIsIk9iamVjdCIsImFzc2lnbiIsImdldEl0ZXJhdG9yIiwiY29sbCIsIml0ZXJhdG9yIiwiY3JlYXRlQXJyYXlJdGVyYXRvciIsImkiLCJsZW4iLCJuZXh0Iiwia2V5IiwiY3JlYXRlRVMyMDE1SXRlcmF0b3IiLCJpdGVtIiwiZG9uZSIsImNyZWF0ZU9iamVjdEl0ZXJhdG9yIiwib2tleXMiLCJrZXlzIiwiY3JlYXRlSXRlcmF0b3IiLCJvbmx5T25jZSIsImFzeW5jRWFjaE9mTGltaXQiLCJnZW5lcmF0b3IiLCJsaW1pdCIsImNhbmNlbGVkIiwiYXdhaXRpbmciLCJydW5uaW5nIiwiaWR4IiwicmVwbGVuaXNoIiwiaXRlckRvbmUiLCJpdGVyYXRlZUNhbGxiYWNrIiwiY2F0Y2giLCJoYW5kbGVFcnJvciIsImVhY2hPZkxpbWl0IiwiUmFuZ2VFcnJvciIsIm5leHRFbGVtIiwibG9vcGluZyIsImVsZW0iLCJlYWNoT2ZMaW1pdCQxIiwiZWFjaE9mTGltaXQkMiIsImVhY2hPZkFycmF5TGlrZSIsImNvbXBsZXRlZCIsIml0ZXJhdG9yQ2FsbGJhY2siLCJlYWNoT2ZHZW5lcmljIiwiSW5maW5pdHkiLCJlYWNoT2YiLCJlYWNoT2ZJbXBsZW1lbnRhdGlvbiIsImVhY2hPZiQxIiwibWFwIiwibWFwJDEiLCJhcHBseUVhY2gkMSIsImVhY2hPZlNlcmllcyIsImVhY2hPZlNlcmllcyQxIiwibWFwU2VyaWVzIiwibWFwU2VyaWVzJDEiLCJhcHBseUVhY2hTZXJpZXMiLCJQUk9NSVNFX1NZTUJPTCIsInByb21pc2VDYWxsYmFjayIsInJlcyIsInJlaiIsImF1dG8iLCJ0YXNrcyIsImNvbmN1cnJlbmN5IiwibnVtVGFza3MiLCJydW5uaW5nVGFza3MiLCJoYXNFcnJvciIsImxpc3RlbmVycyIsImNyZWF0ZSIsInJlYWR5VGFza3MiLCJyZWFkeVRvQ2hlY2siLCJ1bmNoZWNrZWREZXBlbmRlbmNpZXMiLCJmb3JFYWNoIiwidGFzayIsIkFycmF5IiwiaXNBcnJheSIsImVucXVldWVUYXNrIiwicHVzaCIsImRlcGVuZGVuY2llcyIsInNsaWNlIiwicmVtYWluaW5nRGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jeU5hbWUiLCJqb2luIiwiYWRkTGlzdGVuZXIiLCJjaGVja0ZvckRlYWRsb2NrcyIsInByb2Nlc3NRdWV1ZSIsInJ1blRhc2siLCJydW4iLCJzaGlmdCIsInRhc2tOYW1lIiwidGFza0xpc3RlbmVycyIsInRhc2tDb21wbGV0ZSIsInRhc2tDYWxsYmFjayIsInNhZmVSZXN1bHRzIiwicmtleSIsInRhc2tGbiIsImN1cnJlbnRUYXNrIiwiZ2V0RGVwZW5kZW50cyIsImRlcGVuZGVudCIsImluZGV4T2YiLCJGTl9BUkdTIiwiQVJST1dfRk5fQVJHUyIsIkZOX0FSR19TUExJVCIsIkZOX0FSRyIsInN0cmlwQ29tbWVudHMiLCJzdHJpbmciLCJzdHJpcHBlZCIsImVuZEJsb2NrQ29tbWVudCIsImVuZEluZGV4IiwicGFyc2VQYXJhbXMiLCJzcmMiLCJ0b1N0cmluZyIsIm1hdGNoIiwicmVwbGFjZSIsInNwbGl0IiwiYXJnIiwidHJpbSIsImF1dG9JbmplY3QiLCJuZXdUYXNrcyIsInBhcmFtcyIsImZuSXNBc3luYyIsImhhc05vRGVwcyIsIm5ld1Rhc2siLCJ0YXNrQ2IiLCJuZXdBcmdzIiwibmFtZSIsIkRMTCIsImNvbnN0cnVjdG9yIiwiaGVhZCIsInRhaWwiLCJyZW1vdmVMaW5rIiwibm9kZSIsInByZXYiLCJlbXB0eSIsImluc2VydEFmdGVyIiwibmV3Tm9kZSIsImluc2VydEJlZm9yZSIsInVuc2hpZnQiLCJzZXRJbml0aWFsIiwidG9BcnJheSIsImN1ciIsImRhdGEiLCJyZW1vdmUiLCJ0ZXN0Rm4iLCJjdXJyIiwiZGxsIiwicXVldWUiLCJ3b3JrZXIiLCJwYXlsb2FkIiwiX3dvcmtlciIsIm51bVJ1bm5pbmciLCJ3b3JrZXJzTGlzdCIsImV2ZW50cyIsImRyYWluIiwic2F0dXJhdGVkIiwidW5zYXR1cmF0ZWQiLCJvbiIsImV2ZW50IiwiaGFuZGxlciIsImhhbmRsZUFuZFJlbW92ZSIsIm9mZiIsImV2IiwiZmlsdGVyIiwidHJpZ2dlciIsInByb2Nlc3NpbmdTY2hlZHVsZWQiLCJfaW5zZXJ0IiwiaW5zZXJ0QXRGcm9udCIsInJlamVjdE9uRXJyb3IiLCJxIiwic3RhcnRlZCIsIl9jcmVhdGVUYXNrSXRlbSIsIl90YXNrcyIsIl9jcmVhdGVDQiIsImwiLCJzcGxpY2UiLCJidWZmZXIiLCJpZGxlIiwiX21heWJlRHJhaW4iLCJldmVudE1ldGhvZCIsImlzUHJvY2Vzc2luZyIsInBhdXNlZCIsImRhdHVtIiwicHVzaEFzeW5jIiwia2lsbCIsInVuc2hpZnRBc3luYyIsIk1hdGgiLCJtaW4iLCJwYXVzZSIsInJlc3VtZSIsImRlZmluZVByb3BlcnRpZXMiLCJ3cml0YWJsZSIsImNhcmdvIiwiY2FyZ28kMSIsInJlZHVjZSIsIm1lbW8iLCJ4IiwicmVkdWNlJDEiLCJzZXEiLCJmdW5jdGlvbnMiLCJfZnVuY3Rpb25zIiwibmV3YXJncyIsIm5leHRhcmdzIiwiY29tcG9zZSIsInJldmVyc2UiLCJtYXBMaW1pdCIsIm1hcExpbWl0JDEiLCJjb25jYXRMaW1pdCIsInZhbCIsIm1hcFJlc3VsdHMiLCJjb25jYXRMaW1pdCQxIiwiY29uY2F0JDEiLCJjb25jYXRTZXJpZXMiLCJjb25jYXRTZXJpZXMkMSIsImNvbnN0YW50IiwiaWdub3JlZEFyZ3MiLCJfY3JlYXRlVGVzdGVyIiwiY2hlY2siLCJnZXRSZXN1bHQiLCJ0ZXN0UGFzc2VkIiwidGVzdFJlc3VsdCIsImRldGVjdCIsImJvb2wiLCJkZXRlY3QkMSIsImRldGVjdExpbWl0IiwiZGV0ZWN0TGltaXQkMSIsImRldGVjdFNlcmllcyIsImRldGVjdFNlcmllcyQxIiwiY29uc29sZUZ1bmMiLCJyZXN1bHRBcmdzIiwiY29uc29sZSIsImRpciIsImRvV2hpbHN0IiwidGVzdCIsIl9mbiIsIl90ZXN0IiwidHJ1dGgiLCJkb1doaWxzdCQxIiwiZG9VbnRpbCIsIl93aXRob3V0SW5kZXgiLCJlYWNoTGltaXQiLCJlYWNoIiwiZWFjaExpbWl0JDEiLCJlYWNoTGltaXQkMiIsImVhY2hTZXJpZXMiLCJlYWNoU2VyaWVzJDEiLCJlbnN1cmVBc3luYyIsInN5bmMiLCJpbm5lckFyZ3MiLCJldmVyeSIsImV2ZXJ5JDEiLCJldmVyeUxpbWl0IiwiZXZlcnlMaW1pdCQxIiwiZXZlcnlTZXJpZXMiLCJldmVyeVNlcmllcyQxIiwiZmlsdGVyQXJyYXkiLCJ0cnV0aFZhbHVlcyIsImZpbHRlckdlbmVyaWMiLCJzb3J0IiwiYSIsImIiLCJfZmlsdGVyIiwiZmlsdGVyJDEiLCJmaWx0ZXJMaW1pdCIsImZpbHRlckxpbWl0JDEiLCJmaWx0ZXJTZXJpZXMiLCJmaWx0ZXJTZXJpZXMkMSIsImZvcmV2ZXIiLCJlcnJiYWNrIiwiZm9yZXZlciQxIiwiZ3JvdXBCeUxpbWl0IiwiaGFzT3duUHJvcGVydHkiLCJwcm90b3R5cGUiLCJncm91cEJ5TGltaXQkMSIsImdyb3VwQnkiLCJncm91cEJ5U2VyaWVzIiwibG9nIiwibWFwVmFsdWVzTGltaXQiLCJuZXdPYmoiLCJtYXBWYWx1ZXNMaW1pdCQxIiwibWFwVmFsdWVzIiwibWFwVmFsdWVzU2VyaWVzIiwibWVtb2l6ZSIsImhhc2hlciIsInF1ZXVlcyIsIm1lbW9pemVkIiwidW5tZW1vaXplZCIsIl9kZWZlciQxIiwicGFyYWxsZWwiLCJwYXJhbGxlbCQxIiwicGFyYWxsZWxMaW1pdCIsInF1ZXVlJDEiLCJpdGVtcyIsIkhlYXAiLCJoZWFwIiwicHVzaENvdW50IiwiTnVtYmVyIiwiTUlOX1NBRkVfSU5URUdFUiIsInBlcmNVcCIsInAiLCJzbWFsbGVyIiwicGFyZW50IiwidCIsInBlcmNEb3duIiwibGVmdENoaSIsInRvcCIsImoiLCJ5IiwicHJpb3JpdHkiLCJwcmlvcml0eVF1ZXVlIiwiY3JlYXRlRGF0YUl0ZW1zIiwicmFjZSIsIlR5cGVFcnJvciIsInJhY2UkMSIsInJlZHVjZVJpZ2h0IiwiYXJyYXkiLCJyZXZlcnNlZCIsInJlZmxlY3QiLCJyZWZsZWN0T24iLCJyZWZsZWN0Q2FsbGJhY2siLCJyZXRWYWwiLCJyZWZsZWN0QWxsIiwicmVqZWN0JDEiLCJyZWplY3QkMiIsInJlamVjdExpbWl0IiwicmVqZWN0TGltaXQkMSIsInJlamVjdFNlcmllcyIsInJlamVjdFNlcmllcyQxIiwiY29uc3RhbnQkMSIsIkRFRkFVTFRfVElNRVMiLCJERUZBVUxUX0lOVEVSVkFMIiwicmV0cnkiLCJvcHRzIiwib3B0aW9ucyIsInRpbWVzIiwiaW50ZXJ2YWxGdW5jIiwiYXJndW1lbnRzIiwicGFyc2VUaW1lcyIsIl90YXNrIiwiYXR0ZW1wdCIsInJldHJ5QXR0ZW1wdCIsImVycm9yRmlsdGVyIiwiYWNjIiwiaW50ZXJ2YWwiLCJyZXRyeWFibGUiLCJzZXJpZXMiLCJzb21lIiwiQm9vbGVhbiIsInNvbWUkMSIsInNvbWVMaW1pdCIsInNvbWVMaW1pdCQxIiwic29tZVNlcmllcyIsInNvbWVTZXJpZXMkMSIsInNvcnRCeSIsImNyaXRlcmlhIiwiY29tcGFyYXRvciIsImxlZnQiLCJyaWdodCIsInNvcnRCeSQxIiwidGltZW91dCIsIm1pbGxpc2Vjb25kcyIsImluZm8iLCJ0aW1lZE91dCIsInRpbWVyIiwidGltZW91dENhbGxiYWNrIiwiY29kZSIsImNsZWFyVGltZW91dCIsInJhbmdlIiwic2l6ZSIsInRpbWVzTGltaXQiLCJjb3VudCIsIm4iLCJ0aW1lc1NlcmllcyIsInRyYW5zZm9ybSIsImFjY3VtdWxhdG9yIiwiayIsInRyeUVhY2giLCJ0cnlFYWNoJDEiLCJ1bm1lbW9pemUiLCJ3aGlsc3QiLCJyZXN0Iiwid2hpbHN0JDEiLCJ1bnRpbCIsIndhdGVyZmFsbCIsInRhc2tJbmRleCIsIm5leHRUYXNrIiwid2F0ZXJmYWxsJDEiLCJjYXJnb1F1ZXVlIiwiYWxsIiwiYWxsTGltaXQiLCJhbGxTZXJpZXMiLCJhbnkiLCJhbnlMaW1pdCIsImFueVNlcmllcyIsImZpbmQiLCJmaW5kTGltaXQiLCJmaW5kU2VyaWVzIiwiZmxhdE1hcCIsImZsYXRNYXBMaW1pdCIsImZsYXRNYXBTZXJpZXMiLCJmb3JFYWNoU2VyaWVzIiwiZm9yRWFjaExpbWl0IiwiZm9yRWFjaE9mIiwiZm9yRWFjaE9mU2VyaWVzIiwiZm9yRWFjaE9mTGltaXQiLCJpbmplY3QiLCJmb2xkbCIsImZvbGRyIiwic2VsZWN0Iiwic2VsZWN0TGltaXQiLCJzZWxlY3RTZXJpZXMiLCJ3cmFwU3luYyIsImR1cmluZyIsImRvRHVyaW5nIiwiZGVmYXVsdCIsImRlZmluZVByb3BlcnR5Il0sInNvdXJjZVJvb3QiOiJDOlxcY29kZVxcRmx1aWRGcmFtZXdvcms1XFxub2RlX21vZHVsZXNcXC5wbnBtXFxhc3luY0AzLjIuNFxcbm9kZV9tb2R1bGVzXFxhc3luY1xcZGlzdFxcIiwic291cmNlcyI6WyJhc3luYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwuYXN5bmMgPSB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb250aW51YXRpb24gZnVuY3Rpb24gd2l0aCBzb21lIGFyZ3VtZW50cyBhbHJlYWR5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBVc2VmdWwgYXMgYSBzaG9ydGhhbmQgd2hlbiBjb21iaW5lZCB3aXRoIG90aGVyIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMuIEFueVxuICAgICAqIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHJldHVybmVkIGZ1bmN0aW9uIGFyZSBhZGRlZCB0byB0aGUgYXJndW1lbnRzXG4gICAgICogb3JpZ2luYWxseSBwYXNzZWQgdG8gYXBwbHkuXG4gICAgICpcbiAgICAgKiBAbmFtZSBhcHBseVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24geW91IHdhbnQgdG8gZXZlbnR1YWxseSBhcHBseSBhbGxcbiAgICAgKiBhcmd1bWVudHMgdG8uIEludm9rZXMgd2l0aCAoYXJndW1lbnRzLi4uKS5cbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHlcbiAgICAgKiB3aGVuIHRoZSBjb250aW51YXRpb24gaXMgY2FsbGVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gdGhlIHBhcnRpYWxseS1hcHBsaWVkIGZ1bmN0aW9uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGFwcGx5XG4gICAgICogYXN5bmMucGFyYWxsZWwoW1xuICAgICAqICAgICBhc3luYy5hcHBseShmcy53cml0ZUZpbGUsICd0ZXN0ZmlsZTEnLCAndGVzdDEnKSxcbiAgICAgKiAgICAgYXN5bmMuYXBwbHkoZnMud3JpdGVGaWxlLCAndGVzdGZpbGUyJywgJ3Rlc3QyJylcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqXG4gICAgICogLy8gdGhlIHNhbWUgcHJvY2VzcyB3aXRob3V0IHVzaW5nIGFwcGx5XG4gICAgICogYXN5bmMucGFyYWxsZWwoW1xuICAgICAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgZnMud3JpdGVGaWxlKCd0ZXN0ZmlsZTEnLCAndGVzdDEnLCBjYWxsYmFjayk7XG4gICAgICogICAgIH0sXG4gICAgICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICBmcy53cml0ZUZpbGUoJ3Rlc3RmaWxlMicsICd0ZXN0MicsIGNhbGxiYWNrKTtcbiAgICAgKiAgICAgfVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogLy8gSXQncyBwb3NzaWJsZSB0byBwYXNzIGFueSBudW1iZXIgb2YgYWRkaXRpb25hbCBhcmd1bWVudHMgd2hlbiBjYWxsaW5nIHRoZVxuICAgICAqIC8vIGNvbnRpbnVhdGlvbjpcbiAgICAgKlxuICAgICAqIG5vZGU+IHZhciBmbiA9IGFzeW5jLmFwcGx5KHN5cy5wdXRzLCAnb25lJyk7XG4gICAgICogbm9kZT4gZm4oJ3R3bycsICd0aHJlZScpO1xuICAgICAqIG9uZVxuICAgICAqIHR3b1xuICAgICAqIHRocmVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwbHkoZm4sIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuICguLi5jYWxsQXJncykgPT4gZm4oLi4uYXJncywuLi5jYWxsQXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdGlhbFBhcmFtcyAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzLyosIGNhbGxiYWNrKi8pIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhcmdzLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cblxuICAgIHZhciBoYXNRdWV1ZU1pY3JvdGFzayA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJyAmJiBxdWV1ZU1pY3JvdGFzaztcbiAgICB2YXIgaGFzU2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXRJbW1lZGlhdGU7XG4gICAgdmFyIGhhc05leHRUaWNrID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nO1xuXG4gICAgZnVuY3Rpb24gZmFsbGJhY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcChkZWZlcikge1xuICAgICAgICByZXR1cm4gKGZuLCAuLi5hcmdzKSA9PiBkZWZlcigoKSA9PiBmbiguLi5hcmdzKSk7XG4gICAgfVxuXG4gICAgdmFyIF9kZWZlcjtcblxuICAgIGlmIChoYXNRdWV1ZU1pY3JvdGFzaykge1xuICAgICAgICBfZGVmZXIgPSBxdWV1ZU1pY3JvdGFzaztcbiAgICB9IGVsc2UgaWYgKGhhc1NldEltbWVkaWF0ZSkge1xuICAgICAgICBfZGVmZXIgPSBzZXRJbW1lZGlhdGU7XG4gICAgfSBlbHNlIGlmIChoYXNOZXh0VGljaykge1xuICAgICAgICBfZGVmZXIgPSBwcm9jZXNzLm5leHRUaWNrO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9kZWZlciA9IGZhbGxiYWNrO1xuICAgIH1cblxuICAgIHZhciBzZXRJbW1lZGlhdGUkMSA9IHdyYXAoX2RlZmVyKTtcblxuICAgIC8qKlxuICAgICAqIFRha2UgYSBzeW5jIGZ1bmN0aW9uIGFuZCBtYWtlIGl0IGFzeW5jLCBwYXNzaW5nIGl0cyByZXR1cm4gdmFsdWUgdG8gYVxuICAgICAqIGNhbGxiYWNrLiBUaGlzIGlzIHVzZWZ1bCBmb3IgcGx1Z2dpbmcgc3luYyBmdW5jdGlvbnMgaW50byBhIHdhdGVyZmFsbCxcbiAgICAgKiBzZXJpZXMsIG9yIG90aGVyIGFzeW5jIGZ1bmN0aW9ucy4gQW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGdlbmVyYXRlZFxuICAgICAqIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIChleGNlcHQgZm9yIHRoZSBmaW5hbFxuICAgICAqIGNhbGxiYWNrIGFyZ3VtZW50KS4gRXJyb3JzIHRocm93biB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGBhc3luY2lmeWAgcmV0dXJucyBhIFByb21pc2UsIHRoYXQgcHJvbWlzZXMnc1xuICAgICAqIHJlc29sdmVkL3JlamVjdGVkIHN0YXRlIHdpbGwgYmUgdXNlZCB0byBjYWxsIHRoZSBjYWxsYmFjaywgcmF0aGVyIHRoYW4gc2ltcGx5XG4gICAgICogdGhlIHN5bmNocm9ub3VzIHJldHVybiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgYWxzbyBtZWFucyB5b3UgY2FuIGFzeW5jaWZ5IEVTMjAxNyBgYXN5bmNgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBuYW1lIGFzeW5jaWZ5XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQGFsaWFzIHdyYXBTeW5jXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gVGhlIHN5bmNocm9ub3VzIGZ1bmN0aW9uLCBvciBQcm9taXNlLXJldHVybmluZ1xuICAgICAqIGZ1bmN0aW9uIHRvIGNvbnZlcnQgdG8gYW4ge0BsaW5rIEFzeW5jRnVuY3Rpb259LlxuICAgICAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBBbiBhc3luY2hyb25vdXMgd3JhcHBlciBvZiB0aGUgYGZ1bmNgLiBUbyBiZVxuICAgICAqIGludm9rZWQgd2l0aCBgKGFyZ3MuLi4sIGNhbGxiYWNrKWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIHBhc3NpbmcgYSByZWd1bGFyIHN5bmNocm9ub3VzIGZ1bmN0aW9uXG4gICAgICogYXN5bmMud2F0ZXJmYWxsKFtcbiAgICAgKiAgICAgYXN5bmMuYXBwbHkoZnMucmVhZEZpbGUsIGZpbGVuYW1lLCBcInV0ZjhcIiksXG4gICAgICogICAgIGFzeW5jLmFzeW5jaWZ5KEpTT04ucGFyc2UpLFxuICAgICAqICAgICBmdW5jdGlvbiAoZGF0YSwgbmV4dCkge1xuICAgICAqICAgICAgICAgLy8gZGF0YSBpcyB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdGhlIHRleHQuXG4gICAgICogICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwYXJzaW5nIGVycm9yLCBpdCB3b3VsZCBoYXZlIGJlZW4gY2F1Z2h0LlxuICAgICAqICAgICB9XG4gICAgICogXSwgY2FsbGJhY2spO1xuICAgICAqXG4gICAgICogLy8gcGFzc2luZyBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHByb21pc2VcbiAgICAgKiBhc3luYy53YXRlcmZhbGwoW1xuICAgICAqICAgICBhc3luYy5hcHBseShmcy5yZWFkRmlsZSwgZmlsZW5hbWUsIFwidXRmOFwiKSxcbiAgICAgKiAgICAgYXN5bmMuYXN5bmNpZnkoZnVuY3Rpb24gKGNvbnRlbnRzKSB7XG4gICAgICogICAgICAgICByZXR1cm4gZGIubW9kZWwuY3JlYXRlKGNvbnRlbnRzKTtcbiAgICAgKiAgICAgfSksXG4gICAgICogICAgIGZ1bmN0aW9uIChtb2RlbCwgbmV4dCkge1xuICAgICAqICAgICAgICAgLy8gYG1vZGVsYCBpcyB0aGUgaW5zdGFudGlhdGVkIG1vZGVsIG9iamVjdC5cbiAgICAgKiAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciwgdGhpcyBmdW5jdGlvbiB3b3VsZCBiZSBza2lwcGVkLlxuICAgICAqICAgICB9XG4gICAgICogXSwgY2FsbGJhY2spO1xuICAgICAqXG4gICAgICogLy8gZXMyMDE3IGV4YW1wbGUsIHRob3VnaCBgYXN5bmNpZnlgIGlzIG5vdCBuZWVkZWQgaWYgeW91ciBKUyBlbnZpcm9ubWVudFxuICAgICAqIC8vIHN1cHBvcnRzIGFzeW5jIGZ1bmN0aW9ucyBvdXQgb2YgdGhlIGJveFxuICAgICAqIHZhciBxID0gYXN5bmMucXVldWUoYXN5bmMuYXN5bmNpZnkoYXN5bmMgZnVuY3Rpb24oZmlsZSkge1xuICAgICAqICAgICB2YXIgaW50ZXJtZWRpYXRlU3RlcCA9IGF3YWl0IHByb2Nlc3NGaWxlKGZpbGUpO1xuICAgICAqICAgICByZXR1cm4gYXdhaXQgc29tZVByb21pc2UoaW50ZXJtZWRpYXRlU3RlcClcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiBxLnB1c2goZmlsZXMpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzeW5jaWZ5KGZ1bmMpIHtcbiAgICAgICAgaWYgKGlzQXN5bmMoZnVuYykpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncy8qLCBjYWxsYmFjayovKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVQcm9taXNlKHByb21pc2UsIGNhbGxiYWNrKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHJlc3VsdCBpcyBQcm9taXNlIG9iamVjdFxuICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUHJvbWlzZShyZXN1bHQsIGNhbGxiYWNrKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVQcm9taXNlKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIG51bGwsIHZhbHVlKTtcbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBlcnIgJiYgZXJyLm1lc3NhZ2UgPyBlcnIgOiBuZXcgRXJyb3IoZXJyKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBlcnJvciwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCB2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEoZSA9PiB7IHRocm93IGUgfSwgZXJyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXN5bmMoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FzeW5jR2VuZXJhdG9yKGZuKSB7XG4gICAgICAgIHJldHVybiBmbltTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQXN5bmNHZW5lcmF0b3InO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZShvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBBc3luYyhhc3luY0ZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXN5bmNGbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBhIGZ1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIGlzQXN5bmMoYXN5bmNGbikgPyBhc3luY2lmeShhc3luY0ZuKSA6IGFzeW5jRm47XG4gICAgfVxuXG4gICAgLy8gY29uZGl0aW9uYWxseSBwcm9taXNpZnkgYSBmdW5jdGlvbi5cbiAgICAvLyBvbmx5IHJldHVybiBhIHByb21pc2UgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gICAgZnVuY3Rpb24gYXdhaXRpZnkgKGFzeW5jRm4sIGFyaXR5ID0gYXN5bmNGbi5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFhcml0eSkgdGhyb3cgbmV3IEVycm9yKCdhcml0eSBpcyB1bmRlZmluZWQnKVxuICAgICAgICBmdW5jdGlvbiBhd2FpdGFibGUgKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1thcml0eSAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzeW5jRm4uYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBhcmdzW2FyaXR5IC0gMV0gPSAoZXJyLCAuLi5jYkFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY2JBcmdzLmxlbmd0aCA+IDEgPyBjYkFyZ3MgOiBjYkFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXN5bmNGbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXRhYmxlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlFYWNoIChlYWNoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5RWFjaChmbnMsIC4uLmNhbGxBcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBnbyA9IGF3YWl0aWZ5KGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgKGZuLCBjYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3cmFwQXN5bmMoZm4pLmFwcGx5KHRoYXQsIGNhbGxBcmdzLmNvbmNhdChjYikpO1xuICAgICAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGdvO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hc3luY01hcChlYWNoZm4sIGFyciwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFyciA9IGFyciB8fCBbXTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcblxuICAgICAgICByZXR1cm4gZWFjaGZuKGFyciwgKHZhbHVlLCBfLCBpdGVyQ2IpID0+IHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICAgICAgICAgIF9pdGVyYXRlZSh2YWx1ZSwgKGVyciwgdikgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdjtcbiAgICAgICAgICAgICAgICBpdGVyQ2IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAgICAgICAgIHZhbHVlLmxlbmd0aCAlIDEgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gQSB0ZW1wb3JhcnkgdmFsdWUgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgbG9vcCBzaG91bGQgYmUgYnJva2VuLlxuICAgIC8vIFNlZSAjMTA2NCwgIzEyOTNcbiAgICBjb25zdCBicmVha0xvb3AgPSB7fTtcblxuICAgIGZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgICAgICAgZnVuY3Rpb24gd3JhcHBlciAoLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKGZuID09PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgY2FsbEZuID0gZm47XG4gICAgICAgICAgICBmbiA9IG51bGw7XG4gICAgICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih3cmFwcGVyLCBmbik7XG4gICAgICAgIHJldHVybiB3cmFwcGVyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0b3IgKGNvbGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxbU3ltYm9sLml0ZXJhdG9yXSAmJiBjb2xsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVBcnJheUl0ZXJhdG9yKGNvbGwpIHtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgdmFyIGxlbiA9IGNvbGwubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiArK2kgPCBsZW4gPyB7dmFsdWU6IGNvbGxbaV0sIGtleTogaX0gOiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbHVlOiBpdGVtLnZhbHVlLCBrZXk6IGl9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0SXRlcmF0b3Iob2JqKSB7XG4gICAgICAgIHZhciBva2V5cyA9IG9iaiA/IE9iamVjdC5rZXlzKG9iaikgOiBbXTtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgdmFyIGxlbiA9IG9rZXlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gb2tleXNbKytpXTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpIDwgbGVuID8ge3ZhbHVlOiBvYmpba2V5XSwga2V5fSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3IoY29sbCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2UoY29sbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVBcnJheUl0ZXJhdG9yKGNvbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoY29sbCk7XG4gICAgICAgIHJldHVybiBpdGVyYXRvciA/IGNyZWF0ZUVTMjAxNUl0ZXJhdG9yKGl0ZXJhdG9yKSA6IGNyZWF0ZU9iamVjdEl0ZXJhdG9yKGNvbGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ubHlPbmNlKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKGZuID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xuICAgICAgICAgICAgdmFyIGNhbGxGbiA9IGZuO1xuICAgICAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICAgICAgY2FsbEZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvciBhc3luYyBnZW5lcmF0b3JzXG4gICAgZnVuY3Rpb24gYXN5bmNFYWNoT2ZMaW1pdChnZW5lcmF0b3IsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBhd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICBsZXQgcnVubmluZyA9IDA7XG4gICAgICAgIGxldCBpZHggPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxlbmlzaCgpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3JlcGxlbmlzaCcpXG4gICAgICAgICAgICBpZiAocnVubmluZyA+PSBsaW1pdCB8fCBhd2FpdGluZyB8fCBkb25lKSByZXR1cm5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3JlcGxlbmlzaCBhd2FpdGluZycpXG4gICAgICAgICAgICBhd2FpdGluZyA9IHRydWU7XG4gICAgICAgICAgICBnZW5lcmF0b3IubmV4dCgpLnRoZW4oKHt2YWx1ZSwgZG9uZTogaXRlckRvbmV9KSA9PiB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZ290IHZhbHVlJywgdmFsdWUpXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGVkIHx8IGRvbmUpIHJldHVyblxuICAgICAgICAgICAgICAgIGF3YWl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJEb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkb25lIG5leHRDYicpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bm5pbmcrKztcbiAgICAgICAgICAgICAgICBpdGVyYXRlZSh2YWx1ZSwgaWR4LCBpdGVyYXRlZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICAgICAgICByZXBsZW5pc2goKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGhhbmRsZUVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVlQ2FsbGJhY2soZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2l0ZXJhdGVlQ2FsbGJhY2snKVxuICAgICAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICAgICAgaWYgKGNhbmNlbGVkKSByZXR1cm5cbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBoYW5kbGVFcnJvcihlcnIpXG5cbiAgICAgICAgICAgIGlmIChlcnIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBicmVha0xvb3AgfHwgKGRvbmUgJiYgcnVubmluZyA8PSAwKSkge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RvbmUgaXRlckNiJylcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBsZW5pc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycikge1xuICAgICAgICAgICAgaWYgKGNhbmNlbGVkKSByZXR1cm5cbiAgICAgICAgICAgIGF3YWl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXBsZW5pc2goKTtcbiAgICB9XG5cbiAgICB2YXIgZWFjaE9mTGltaXQgPSAobGltaXQpID0+IHtcbiAgICAgICAgcmV0dXJuIChvYmosIGl0ZXJhdGVlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2NvbmN1cnJlbmN5IGxpbWl0IGNhbm5vdCBiZSBsZXNzIHRoYW4gMScpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FzeW5jR2VuZXJhdG9yKG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmNFYWNoT2ZMaW1pdChvYmosIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNBc3luY0l0ZXJhYmxlKG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmNFYWNoT2ZMaW1pdChvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCksIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV4dEVsZW0gPSBjcmVhdGVJdGVyYXRvcihvYmopO1xuICAgICAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjYW5jZWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHJ1bm5pbmcgPSAwO1xuICAgICAgICAgICAgdmFyIGxvb3BpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZWVDYWxsYmFjayhlcnIsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGVkKSByZXR1cm5cbiAgICAgICAgICAgICAgICBydW5uaW5nIC09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gYnJlYWtMb29wIHx8IChkb25lICYmIHJ1bm5pbmcgPD0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWxvb3BpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZXBsZW5pc2ggKCkge1xuICAgICAgICAgICAgICAgIGxvb3BpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBuZXh0RWxlbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlZShlbGVtLnZhbHVlLCBlbGVtLmtleSwgb25seU9uY2UoaXRlcmF0ZWVDYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb29waW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBhcyBbYGVhY2hPZmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYVxuICAgICAqIHRpbWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBlYWNoT2ZMaW1pdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLmVhY2hPZl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn1cbiAgICAgKiBAYWxpYXMgZm9yRWFjaE9mTGltaXRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaFxuICAgICAqIGl0ZW0gaW4gYGNvbGxgLiBUaGUgYGtleWAgaXMgdGhlIGl0ZW0ncyBrZXksIG9yIGluZGV4IGluIHRoZSBjYXNlIG9mIGFuXG4gICAgICogYXJyYXkuXG4gICAgICogSW52b2tlZCB3aXRoIChpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAgICAgKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYWNoT2ZMaW1pdCQxKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGVhY2hPZkxpbWl0KGxpbWl0KShjb2xsLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdmFyIGVhY2hPZkxpbWl0JDIgPSBhd2FpdGlmeShlYWNoT2ZMaW1pdCQxLCA0KTtcblxuICAgIC8vIGVhY2hPZiBpbXBsZW1lbnRhdGlvbiBvcHRpbWl6ZWQgZm9yIGFycmF5LWxpa2VzXG4gICAgZnVuY3Rpb24gZWFjaE9mQXJyYXlMaWtlKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgY29tcGxldGVkID0gMCxcbiAgICAgICAgICAgIHtsZW5ndGh9ID0gY29sbCxcbiAgICAgICAgICAgIGNhbmNlbGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXRlcmF0b3JDYWxsYmFjayhlcnIsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5jZWxlZCA9PT0gdHJ1ZSkgcmV0dXJuXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKCsrY29tcGxldGVkID09PSBsZW5ndGgpIHx8IHZhbHVlID09PSBicmVha0xvb3ApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaXRlcmF0ZWUoY29sbFtpbmRleF0sIGluZGV4LCBvbmx5T25jZShpdGVyYXRvckNhbGxiYWNrKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhIGdlbmVyaWMgdmVyc2lvbiBvZiBlYWNoT2Ygd2hpY2ggY2FuIGhhbmRsZSBhcnJheSwgb2JqZWN0LCBhbmQgaXRlcmF0b3IgY2FzZXMuXG4gICAgZnVuY3Rpb24gZWFjaE9mR2VuZXJpYyAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBlYWNoT2ZMaW1pdCQyKGNvbGwsIEluZmluaXR5LCBpdGVyYXRlZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpa2UgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9LCBleGNlcHQgdGhhdCBpdCBwYXNzZXMgdGhlIGtleSAob3IgaW5kZXgpIGFzIHRoZSBzZWNvbmQgYXJndW1lbnRcbiAgICAgKiB0byB0aGUgaXRlcmF0ZWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBlYWNoT2ZcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAYWxpYXMgZm9yRWFjaE9mXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH1cbiAgICAgKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gICAgICogaXRlbSBpbiBgY29sbGAuXG4gICAgICogVGhlIGBrZXlgIGlzIHRoZSBpdGVtJ3Mga2V5LCBvciBpbmRleCBpbiB0aGUgY2FzZSBvZiBhbiBhcnJheS5cbiAgICAgKiBJbnZva2VkIHdpdGggKGl0ZW0sIGtleSwgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICAgICAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBkZXYuanNvbiBpcyBhIGZpbGUgY29udGFpbmluZyBhIHZhbGlkIGpzb24gb2JqZWN0IGNvbmZpZyBmb3IgZGV2IGVudmlyb25tZW50XG4gICAgICogLy8gZGV2Lmpzb24gaXMgYSBmaWxlIGNvbnRhaW5pbmcgYSB2YWxpZCBqc29uIG9iamVjdCBjb25maWcgZm9yIHRlc3QgZW52aXJvbm1lbnRcbiAgICAgKiAvLyBwcm9kLmpzb24gaXMgYSBmaWxlIGNvbnRhaW5pbmcgYSB2YWxpZCBqc29uIG9iamVjdCBjb25maWcgZm9yIHByb2QgZW52aXJvbm1lbnRcbiAgICAgKiAvLyBpbnZhbGlkLmpzb24gaXMgYSBmaWxlIHdpdGggYSBtYWxmb3JtZWQganNvbiBvYmplY3RcbiAgICAgKlxuICAgICAqIGxldCBjb25maWdzID0ge307IC8vZ2xvYmFsIHZhcmlhYmxlXG4gICAgICogbGV0IHZhbGlkQ29uZmlnRmlsZU1hcCA9IHtkZXY6ICdkZXYuanNvbicsIHRlc3Q6ICd0ZXN0Lmpzb24nLCBwcm9kOiAncHJvZC5qc29uJ307XG4gICAgICogbGV0IGludmFsaWRDb25maWdGaWxlTWFwID0ge2RldjogJ2Rldi5qc29uJywgdGVzdDogJ3Rlc3QuanNvbicsIGludmFsaWQ6ICdpbnZhbGlkLmpzb24nfTtcbiAgICAgKlxuICAgICAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IHJlYWRzIGEganNvbiBmaWxlIGFuZCBwYXJzZXMgdGhlIGNvbnRlbnRzIGFzIGpzb24gb2JqZWN0XG4gICAgICogZnVuY3Rpb24gcGFyc2VGaWxlKGZpbGUsIGtleSwgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgZnMucmVhZEZpbGUoZmlsZSwgXCJ1dGY4XCIsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAqICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGJhY2soZXJyKTtcbiAgICAgKiAgICAgICAgIHRyeSB7XG4gICAgICogICAgICAgICAgICAgY29uZmlnc1trZXldID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgKiAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICogICAgICAgICB9XG4gICAgICogICAgICAgICBjYWxsYmFjaygpO1xuICAgICAqICAgICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyBjYWxsYmFja3NcbiAgICAgKiBhc3luYy5mb3JFYWNoT2YodmFsaWRDb25maWdGaWxlTWFwLCBwYXJzZUZpbGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgKiAgICAgaWYgKGVycikge1xuICAgICAqICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAqICAgICB9IGVsc2Uge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coY29uZmlncyk7XG4gICAgICogICAgICAgICAvLyBjb25maWdzIGlzIG5vdyBhIG1hcCBvZiBKU09OIGRhdGEsIGUuZy5cbiAgICAgKiAgICAgICAgIC8vIHsgZGV2OiAvL3BhcnNlZCBkZXYuanNvbiwgdGVzdDogLy9wYXJzZWQgdGVzdC5qc29uLCBwcm9kOiAvL3BhcnNlZCBwcm9kLmpzb259XG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vRXJyb3IgaGFuZGluZ1xuICAgICAqIGFzeW5jLmZvckVhY2hPZihpbnZhbGlkQ29uZmlnRmlsZU1hcCwgcGFyc2VGaWxlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICogICAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgKiAgICAgICAgIC8vIEpTT04gcGFyc2UgZXJyb3IgZXhjZXB0aW9uXG4gICAgICogICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhjb25maWdzKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gVXNpbmcgUHJvbWlzZXNcbiAgICAgKiBhc3luYy5mb3JFYWNoT2YodmFsaWRDb25maWdGaWxlTWFwLCBwYXJzZUZpbGUpXG4gICAgICogLnRoZW4oICgpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coY29uZmlncyk7XG4gICAgICogICAgIC8vIGNvbmZpZ3MgaXMgbm93IGEgbWFwIG9mIEpTT04gZGF0YSwgZS5nLlxuICAgICAqICAgICAvLyB7IGRldjogLy9wYXJzZWQgZGV2Lmpzb24sIHRlc3Q6IC8vcGFyc2VkIHRlc3QuanNvbiwgcHJvZDogLy9wYXJzZWQgcHJvZC5qc29ufVxuICAgICAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvL0Vycm9yIGhhbmRpbmdcbiAgICAgKiBhc3luYy5mb3JFYWNoT2YoaW52YWxpZENvbmZpZ0ZpbGVNYXAsIHBhcnNlRmlsZSlcbiAgICAgKiAudGhlbiggKCkgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhjb25maWdzKTtcbiAgICAgKiB9KS5jYXRjaCggZXJyID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAqICAgICAvLyBKU09OIHBhcnNlIGVycm9yIGV4Y2VwdGlvblxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAgICAgKiBhc3luYyAoKSA9PiB7XG4gICAgICogICAgIHRyeSB7XG4gICAgICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMuZm9yRWFjaE9mKHZhbGlkQ29uZmlnRmlsZU1hcCwgcGFyc2VGaWxlKTtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGNvbmZpZ3MpO1xuICAgICAqICAgICAgICAgLy8gY29uZmlncyBpcyBub3cgYSBtYXAgb2YgSlNPTiBkYXRhLCBlLmcuXG4gICAgICogICAgICAgICAvLyB7IGRldjogLy9wYXJzZWQgZGV2Lmpzb24sIHRlc3Q6IC8vcGFyc2VkIHRlc3QuanNvbiwgcHJvZDogLy9wYXJzZWQgcHJvZC5qc29ufVxuICAgICAqICAgICB9XG4gICAgICogICAgIGNhdGNoIChlcnIpIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvL0Vycm9yIGhhbmRpbmdcbiAgICAgKiBhc3luYyAoKSA9PiB7XG4gICAgICogICAgIHRyeSB7XG4gICAgICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMuZm9yRWFjaE9mKGludmFsaWRDb25maWdGaWxlTWFwLCBwYXJzZUZpbGUpO1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coY29uZmlncyk7XG4gICAgICogICAgIH1cbiAgICAgKiAgICAgY2F0Y2ggKGVycikge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgICAgIC8vIEpTT04gcGFyc2UgZXJyb3IgZXhjZXB0aW9uXG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYWNoT2YoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlYWNoT2ZJbXBsZW1lbnRhdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGwpID8gZWFjaE9mQXJyYXlMaWtlIDogZWFjaE9mR2VuZXJpYztcbiAgICAgICAgcmV0dXJuIGVhY2hPZkltcGxlbWVudGF0aW9uKGNvbGwsIHdyYXBBc3luYyhpdGVyYXRlZSksIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICB2YXIgZWFjaE9mJDEgPSBhd2FpdGlmeShlYWNoT2YsIDMpO1xuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSBuZXcgY29sbGVjdGlvbiBvZiB2YWx1ZXMgYnkgbWFwcGluZyBlYWNoIHZhbHVlIGluIGBjb2xsYCB0aHJvdWdoXG4gICAgICogdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIGFuIGl0ZW0gZnJvbSBgY29sbGBcbiAgICAgKiBhbmQgYSBjYWxsYmFjayBmb3Igd2hlbiBpdCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZy4gRWFjaCBvZiB0aGVzZSBjYWxsYmFja3NcbiAgICAgKiB0YWtlcyAyIGFyZ3VtZW50czogYW4gYGVycm9yYCwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBpdGVtIGZyb20gYGNvbGxgLiBJZlxuICAgICAqIGBpdGVyYXRlZWAgcGFzc2VzIGFuIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCAoZm9yIHRoZVxuICAgICAqIGBtYXBgIGZ1bmN0aW9uKSBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuXG4gICAgICpcbiAgICAgKiBOb3RlLCB0aGF0IHNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyB0aGUgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW5cbiAgICAgKiBwYXJhbGxlbCwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIHdpbGwgY29tcGxldGVcbiAgICAgKiBpbiBvcmRlci4gSG93ZXZlciwgdGhlIHJlc3VsdHMgYXJyYXkgd2lsbCBiZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbiAgICAgKiBvcmlnaW5hbCBgY29sbGAuXG4gICAgICpcbiAgICAgKiBJZiBgbWFwYCBpcyBwYXNzZWQgYW4gT2JqZWN0LCB0aGUgcmVzdWx0cyB3aWxsIGJlIGFuIEFycmF5LiAgVGhlIHJlc3VsdHNcbiAgICAgKiB3aWxsIHJvdWdobHkgYmUgaW4gdGhlIG9yZGVyIG9mIHRoZSBvcmlnaW5hbCBPYmplY3RzJyBrZXlzIChidXQgdGhpcyBjYW5cbiAgICAgKiB2YXJ5IGFjcm9zcyBKYXZhU2NyaXB0IGVuZ2luZXMpLlxuICAgICAqXG4gICAgICogQG5hbWUgbWFwXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gICAgICogYGNvbGxgLlxuICAgICAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgaXRlbS5cbiAgICAgKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICAgICAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gQXJyYXkgb2YgdGhlXG4gICAgICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGZpbGUxLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAxMDAwIGJ5dGVzIGluIHNpemVcbiAgICAgKiAvLyBmaWxlMi50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMjAwMCBieXRlcyBpbiBzaXplXG4gICAgICogLy8gZmlsZTMudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDMwMDAgYnl0ZXMgaW4gc2l6ZVxuICAgICAqIC8vIGZpbGU0LnR4dCBkb2VzIG5vdCBleGlzdFxuICAgICAqXG4gICAgICogY29uc3QgZmlsZUxpc3QgPSBbJ2ZpbGUxLnR4dCcsJ2ZpbGUyLnR4dCcsJ2ZpbGUzLnR4dCddO1xuICAgICAqIGNvbnN0IHdpdGhNaXNzaW5nRmlsZUxpc3QgPSBbJ2ZpbGUxLnR4dCcsJ2ZpbGUyLnR4dCcsJ2ZpbGU0LnR4dCddO1xuICAgICAqXG4gICAgICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZmlsZSBzaXplIGluIGJ5dGVzXG4gICAgICogZnVuY3Rpb24gZ2V0RmlsZVNpemVJbkJ5dGVzKGZpbGUsIGNhbGxiYWNrKSB7XG4gICAgICogICAgIGZzLnN0YXQoZmlsZSwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XG4gICAgICogICAgICAgICBpZiAoZXJyKSB7XG4gICAgICogICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICogICAgICAgICB9XG4gICAgICogICAgICAgICBjYWxsYmFjayhudWxsLCBzdGF0LnNpemUpO1xuICAgICAqICAgICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyBjYWxsYmFja3NcbiAgICAgKiBhc3luYy5tYXAoZmlsZUxpc3QsIGdldEZpbGVTaXplSW5CeXRlcywgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgICogICAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgICAgIC8vIHJlc3VsdHMgaXMgbm93IGFuIGFycmF5IG9mIHRoZSBmaWxlIHNpemUgaW4gYnl0ZXMgZm9yIGVhY2ggZmlsZSwgZS5nLlxuICAgICAqICAgICAgICAgLy8gWyAxMDAwLCAyMDAwLCAzMDAwXVxuICAgICAqICAgICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBFcnJvciBIYW5kbGluZ1xuICAgICAqIGFzeW5jLm1hcCh3aXRoTWlzc2luZ0ZpbGVMaXN0LCBnZXRGaWxlU2l6ZUluQnl0ZXMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAqICAgICBpZiAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAgICAgKiAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAgICAqICAgICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyBQcm9taXNlc1xuICAgICAqIGFzeW5jLm1hcChmaWxlTGlzdCwgZ2V0RmlsZVNpemVJbkJ5dGVzKVxuICAgICAqIC50aGVuKCByZXN1bHRzID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gICAgICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGFuIGFycmF5IG9mIHRoZSBmaWxlIHNpemUgaW4gYnl0ZXMgZm9yIGVhY2ggZmlsZSwgZS5nLlxuICAgICAqICAgICAvLyBbIDEwMDAsIDIwMDAsIDMwMDBdXG4gICAgICogfSkuY2F0Y2goIGVyciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBFcnJvciBIYW5kbGluZ1xuICAgICAqIGFzeW5jLm1hcCh3aXRoTWlzc2luZ0ZpbGVMaXN0LCBnZXRGaWxlU2l6ZUluQnl0ZXMpXG4gICAgICogLnRoZW4oIHJlc3VsdHMgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiB9KS5jYXRjaCggZXJyID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gICAgICogYXN5bmMgKCkgPT4ge1xuICAgICAqICAgICB0cnkge1xuICAgICAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5tYXAoZmlsZUxpc3QsIGdldEZpbGVTaXplSW5CeXRlcyk7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgICAgIC8vIHJlc3VsdHMgaXMgbm93IGFuIGFycmF5IG9mIHRoZSBmaWxlIHNpemUgaW4gYnl0ZXMgZm9yIGVhY2ggZmlsZSwgZS5nLlxuICAgICAqICAgICAgICAgLy8gWyAxMDAwLCAyMDAwLCAzMDAwXVxuICAgICAqICAgICB9XG4gICAgICogICAgIGNhdGNoIChlcnIpIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyBFcnJvciBIYW5kbGluZ1xuICAgICAqIGFzeW5jICgpID0+IHtcbiAgICAgKiAgICAgdHJ5IHtcbiAgICAgKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMubWFwKHdpdGhNaXNzaW5nRmlsZUxpc3QsIGdldEZpbGVTaXplSW5CeXRlcyk7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcCAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfYXN5bmNNYXAoZWFjaE9mJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbiAgICB9XG4gICAgdmFyIG1hcCQxID0gYXdhaXRpZnkobWFwLCAzKTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyB0byBlYWNoIGZ1bmN0aW9uIGluIHRoZSBhcnJheSwgY2FsbGluZ1xuICAgICAqIGBjYWxsYmFja2AgYWZ0ZXIgYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZC4gSWYgeW91IG9ubHkgcHJvdmlkZSB0aGUgZmlyc3RcbiAgICAgKiBhcmd1bWVudCwgYGZuc2AsIHRoZW4gaXQgd2lsbCByZXR1cm4gYSBmdW5jdGlvbiB3aGljaCBsZXRzIHlvdSBwYXNzIGluIHRoZVxuICAgICAqIGFyZ3VtZW50cyBhcyBpZiBpdCB3ZXJlIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGwuIElmIG1vcmUgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkLCBgY2FsbGJhY2tgIGlzIHJlcXVpcmVkIHdoaWxlIGBhcmdzYCBpcyBzdGlsbCBvcHRpb25hbC4gVGhlIHJlc3VsdHNcbiAgICAgKiBmb3IgZWFjaCBvZiB0aGUgYXBwbGllZCBhc3luYyBmdW5jdGlvbnMgYXJlIHBhc3NlZCB0byB0aGUgZmluYWwgY2FsbGJhY2tcbiAgICAgKiBhcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBuYW1lIGFwcGx5RWFjaFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAgICAgKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBmbnMgLSBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFzeW5jRnVuY3Rpb259c1xuICAgICAqIHRvIGFsbCBjYWxsIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gLSBhbnkgbnVtYmVyIG9mIHNlcGFyYXRlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZVxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSB0aGUgZmluYWwgYXJndW1lbnQgc2hvdWxkIGJlIHRoZSBjYWxsYmFjayxcbiAgICAgKiBjYWxsZWQgd2hlbiBhbGwgZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkIHByb2Nlc3NpbmcuXG4gICAgICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IC0gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm8gYXJncyBvdGhlciB0aGFuXG4gICAgICogYW4gb3B0aW9uYWwgY2FsbGJhY2ssIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgYGFyZ3NgIHRvIGVhY2hcbiAgICAgKiBvZiB0aGUgZnVuY3Rpb25zLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCBhcHBsaWVkRm4gPSBhc3luYy5hcHBseUVhY2goW2VuYWJsZVNlYXJjaCwgdXBkYXRlU2NoZW1hXSwgJ2J1Y2tldCcpXG4gICAgICpcbiAgICAgKiBhcHBsaWVkRm4oKGVyciwgcmVzdWx0cykgPT4ge1xuICAgICAqICAgICAvLyByZXN1bHRzWzBdIGlzIHRoZSByZXN1bHRzIGZvciBgZW5hYmxlU2VhcmNoYFxuICAgICAqICAgICAvLyByZXN1bHRzWzFdIGlzIHRoZSByZXN1bHRzIGZvciBgdXBkYXRlU2NoZW1hYFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gcGFydGlhbCBhcHBsaWNhdGlvbiBleGFtcGxlOlxuICAgICAqIGFzeW5jLmVhY2goXG4gICAgICogICAgIGJ1Y2tldHMsXG4gICAgICogICAgIGFzeW5jIChidWNrZXQpID0+IGFzeW5jLmFwcGx5RWFjaChbZW5hYmxlU2VhcmNoLCB1cGRhdGVTY2hlbWFdLCBidWNrZXQpKCksXG4gICAgICogICAgIGNhbGxiYWNrXG4gICAgICogKTtcbiAgICAgKi9cbiAgICB2YXIgYXBwbHlFYWNoJDEgPSBhcHBseUVhY2gobWFwJDEpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMgW2BlYWNoT2ZgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBlYWNoT2ZTZXJpZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAc2VlIFthc3luYy5lYWNoT2Zde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9XG4gICAgICogQGFsaWFzIGZvckVhY2hPZlNlcmllc1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICAgICAqIGBjb2xsYC5cbiAgICAgKiBJbnZva2VkIHdpdGggKGl0ZW0sIGtleSwgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gICAgICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVhY2hPZlNlcmllcyhjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGVhY2hPZkxpbWl0JDIoY29sbCwgMSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxuICAgIH1cbiAgICB2YXIgZWFjaE9mU2VyaWVzJDEgPSBhd2FpdGlmeShlYWNoT2ZTZXJpZXMsIDMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMgW2BtYXBgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBtYXBTZXJpZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gICAgICogYGNvbGxgLlxuICAgICAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgaXRlbS5cbiAgICAgKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICAgICAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXkgb2YgdGhlXG4gICAgICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwU2VyaWVzIChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9hc3luY01hcChlYWNoT2ZTZXJpZXMkMSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxuICAgIH1cbiAgICB2YXIgbWFwU2VyaWVzJDEgPSBhd2FpdGlmeShtYXBTZXJpZXMsIDMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMgW2BhcHBseUVhY2hgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXBwbHlFYWNofSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBhcHBseUVhY2hTZXJpZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAc2VlIFthc3luYy5hcHBseUVhY2hde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hcHBseUVhY2h9XG4gICAgICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICAgICAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGZucyAtIEEgY29sbGVjdGlvbiBvZiB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIHRvIGFsbFxuICAgICAqIGNhbGwgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSAtIGFueSBudW1iZXIgb2Ygc2VwYXJhdGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlXG4gICAgICogZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHRoZSBmaW5hbCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGNhbGxiYWNrLFxuICAgICAqIGNhbGxlZCB3aGVuIGFsbCBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgcHJvY2Vzc2luZy5cbiAgICAgKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gLSBBIGZ1bmN0aW9uLCB0aGF0IHdoZW4gY2FsbGVkLCBpcyB0aGUgcmVzdWx0IG9mXG4gICAgICogYXBwbGluZyB0aGUgYGFyZ3NgIHRvIHRoZSBsaXN0IG9mIGZ1bmN0aW9ucy4gIEl0IHRha2VzIG5vIGFyZ3MsIG90aGVyIHRoYW5cbiAgICAgKiBhIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIHZhciBhcHBseUVhY2hTZXJpZXMgPSBhcHBseUVhY2gobWFwU2VyaWVzJDEpO1xuXG4gICAgY29uc3QgUFJPTUlTRV9TWU1CT0wgPSBTeW1ib2woJ3Byb21pc2VDYWxsYmFjaycpO1xuXG4gICAgZnVuY3Rpb24gcHJvbWlzZUNhbGxiYWNrICgpIHtcbiAgICAgICAgbGV0IHJlc29sdmUsIHJlamVjdDtcbiAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2sgKGVyciwgLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgICAgICByZXNvbHZlKGFyZ3MubGVuZ3RoID4gMSA/IGFyZ3MgOiBhcmdzWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrW1BST01JU0VfU1lNQk9MXSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcyxcbiAgICAgICAgICAgIHJlamVjdCA9IHJlajtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgYmVzdCBvcmRlciBmb3IgcnVubmluZyB0aGUge0BsaW5rIEFzeW5jRnVuY3Rpb259cyBpbiBgdGFza3NgLCBiYXNlZCBvblxuICAgICAqIHRoZWlyIHJlcXVpcmVtZW50cy4gRWFjaCBmdW5jdGlvbiBjYW4gb3B0aW9uYWxseSBkZXBlbmQgb24gb3RoZXIgZnVuY3Rpb25zXG4gICAgICogYmVpbmcgY29tcGxldGVkIGZpcnN0LCBhbmQgZWFjaCBmdW5jdGlvbiBpcyBydW4gYXMgc29vbiBhcyBpdHMgcmVxdWlyZW1lbnRzXG4gICAgICogYXJlIHNhdGlzZmllZC5cbiAgICAgKlxuICAgICAqIElmIGFueSBvZiB0aGUge0BsaW5rIEFzeW5jRnVuY3Rpb259cyBwYXNzIGFuIGVycm9yIHRvIHRoZWlyIGNhbGxiYWNrLCB0aGUgYGF1dG9gIHNlcXVlbmNlXG4gICAgICogd2lsbCBzdG9wLiBGdXJ0aGVyIHRhc2tzIHdpbGwgbm90IGV4ZWN1dGUgKHNvIGFueSBvdGhlciBmdW5jdGlvbnMgZGVwZW5kaW5nXG4gICAgICogb24gaXQgd2lsbCBub3QgcnVuKSwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlXG4gICAgICogZXJyb3IuXG4gICAgICpcbiAgICAgKiB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIGFsc28gcmVjZWl2ZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiBmdW5jdGlvbnMgd2hpY2hcbiAgICAgKiBoYXZlIGNvbXBsZXRlZCBzbyBmYXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCBpZiB0aGV5IGhhdmUgZGVwZW5kZW5jaWVzLiBJZiBhXG4gICAgICogdGFzayBmdW5jdGlvbiBoYXMgbm8gZGVwZW5kZW5jaWVzLCBpdCB3aWxsIG9ubHkgYmUgcGFzc2VkIGEgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAbmFtZSBhdXRvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXNrcyAtIEFuIG9iamVjdC4gRWFjaCBvZiBpdHMgcHJvcGVydGllcyBpcyBlaXRoZXIgYVxuICAgICAqIGZ1bmN0aW9uIG9yIGFuIGFycmF5IG9mIHJlcXVpcmVtZW50cywgd2l0aCB0aGUge0BsaW5rIEFzeW5jRnVuY3Rpb259IGl0c2VsZiB0aGUgbGFzdCBpdGVtXG4gICAgICogaW4gdGhlIGFycmF5LiBUaGUgb2JqZWN0J3Mga2V5IG9mIGEgcHJvcGVydHkgc2VydmVzIGFzIHRoZSBuYW1lIG9mIHRoZSB0YXNrXG4gICAgICogZGVmaW5lZCBieSB0aGF0IHByb3BlcnR5LCBpLmUuIGNhbiBiZSB1c2VkIHdoZW4gc3BlY2lmeWluZyByZXF1aXJlbWVudHMgZm9yXG4gICAgICogb3RoZXIgdGFza3MuIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBvbmUgb3IgdHdvIGFyZ3VtZW50czpcbiAgICAgKiAqIGEgYHJlc3VsdHNgIG9iamVjdCwgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXNseSBleGVjdXRlZFxuICAgICAqICAgZnVuY3Rpb25zLCBvbmx5IHBhc3NlZCBpZiB0aGUgdGFzayBoYXMgYW55IGRlcGVuZGVuY2llcyxcbiAgICAgKiAqIGEgYGNhbGxiYWNrKGVyciwgcmVzdWx0KWAgZnVuY3Rpb24sIHdoaWNoIG11c3QgYmUgY2FsbGVkIHdoZW4gZmluaXNoZWQsXG4gICAgICogICBwYXNzaW5nIGFuIGBlcnJvcmAgKHdoaWNoIGNhbiBiZSBgbnVsbGApIGFuZCB0aGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbidzXG4gICAgICogICBleGVjdXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW5jeT1JbmZpbml0eV0gLSBBbiBvcHRpb25hbCBgaW50ZWdlcmAgZm9yXG4gICAgICogZGV0ZXJtaW5pbmcgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRhc2tzIHRoYXQgY2FuIGJlIHJ1biBpbiBwYXJhbGxlbC4gQnlcbiAgICAgKiBkZWZhdWx0LCBhcyBtYW55IGFzIHBvc3NpYmxlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAgICAgKiB0aGUgdGFza3MgaGF2ZSBiZWVuIGNvbXBsZXRlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFyZ3VtZW50IGlmIGFueSBgdGFza3NgXG4gICAgICogcGFzcyBhbiBlcnJvciB0byB0aGVpciBjYWxsYmFjay4gUmVzdWx0cyBhcmUgYWx3YXlzIHJldHVybmVkOyBob3dldmVyLCBpZiBhblxuICAgICAqIGVycm9yIG9jY3Vycywgbm8gZnVydGhlciBgdGFza3NgIHdpbGwgYmUgcGVyZm9ybWVkLCBhbmQgdGhlIHJlc3VsdHMgb2JqZWN0XG4gICAgICogd2lsbCBvbmx5IGNvbnRhaW4gcGFydGlhbCByZXN1bHRzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBub3QgcGFzc2VkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vVXNpbmcgQ2FsbGJhY2tzXG4gICAgICogYXN5bmMuYXV0byh7XG4gICAgICogICAgIGdldF9kYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhXG4gICAgICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZGF0YScsICdjb252ZXJ0ZWQgdG8gYXJyYXknKTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGNyZWF0ZSBhIGRpcmVjdG9yeSB0byBzdG9yZSBhIGZpbGUgaW5cbiAgICAgKiAgICAgICAgIC8vIHRoaXMgaXMgcnVuIGF0IHRoZSBzYW1lIHRpbWUgYXMgZ2V0dGluZyB0aGUgZGF0YVxuICAgICAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZvbGRlcicpO1xuICAgICAqICAgICB9LFxuICAgICAqICAgICB3cml0ZV9maWxlOiBbJ2dldF9kYXRhJywgJ21ha2VfZm9sZGVyJywgZnVuY3Rpb24ocmVzdWx0cywgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIC8vIG9uY2UgdGhlcmUgaXMgc29tZSBkYXRhIGFuZCB0aGUgZGlyZWN0b3J5IGV4aXN0cyxcbiAgICAgKiAgICAgICAgIC8vIHdyaXRlIHRoZSBkYXRhIHRvIGEgZmlsZSBpbiB0aGUgZGlyZWN0b3J5XG4gICAgICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTtcbiAgICAgKiAgICAgfV0sXG4gICAgICogICAgIGVtYWlsX2xpbms6IFsnd3JpdGVfZmlsZScsIGZ1bmN0aW9uKHJlc3VsdHMsIGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICAvLyBvbmNlIHRoZSBmaWxlIGlzIHdyaXR0ZW4gbGV0J3MgZW1haWwgYSBsaW5rIHRvIGl0Li4uXG4gICAgICogICAgICAgICBjYWxsYmFjayhudWxsLCB7J2ZpbGUnOnJlc3VsdHMud3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAgICAgKiAgICAgfV1cbiAgICAgKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICAgKiAgICAgaWYgKGVycikge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coJ2VyciA9ICcsIGVycik7XG4gICAgICogICAgIH1cbiAgICAgKiAgICAgY29uc29sZS5sb2coJ3Jlc3VsdHMgPSAnLCByZXN1bHRzKTtcbiAgICAgKiAgICAgLy8gcmVzdWx0cyA9IHtcbiAgICAgKiAgICAgLy8gICAgIGdldF9kYXRhOiBbJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5J11cbiAgICAgKiAgICAgLy8gICAgIG1ha2VfZm9sZGVyOyAnZm9sZGVyJyxcbiAgICAgKiAgICAgLy8gICAgIHdyaXRlX2ZpbGU6ICdmaWxlbmFtZSdcbiAgICAgKiAgICAgLy8gICAgIGVtYWlsX2xpbms6IHsgZmlsZTogJ2ZpbGVuYW1lJywgZW1haWw6ICd1c2VyQGV4YW1wbGUuY29tJyB9XG4gICAgICogICAgIC8vIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vVXNpbmcgUHJvbWlzZXNcbiAgICAgKiBhc3luYy5hdXRvKHtcbiAgICAgKiAgICAgZ2V0X2RhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZygnaW4gZ2V0X2RhdGEnKTtcbiAgICAgKiAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gZ2V0IHNvbWUgZGF0YVxuICAgICAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7XG4gICAgICogICAgIH0sXG4gICAgICogICAgIG1ha2VfZm9sZGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coJ2luIG1ha2VfZm9sZGVyJyk7XG4gICAgICogICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGNyZWF0ZSBhIGRpcmVjdG9yeSB0byBzdG9yZSBhIGZpbGUgaW5cbiAgICAgKiAgICAgICAgIC8vIHRoaXMgaXMgcnVuIGF0IHRoZSBzYW1lIHRpbWUgYXMgZ2V0dGluZyB0aGUgZGF0YVxuICAgICAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZvbGRlcicpO1xuICAgICAqICAgICB9LFxuICAgICAqICAgICB3cml0ZV9maWxlOiBbJ2dldF9kYXRhJywgJ21ha2VfZm9sZGVyJywgZnVuY3Rpb24ocmVzdWx0cywgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIC8vIG9uY2UgdGhlcmUgaXMgc29tZSBkYXRhIGFuZCB0aGUgZGlyZWN0b3J5IGV4aXN0cyxcbiAgICAgKiAgICAgICAgIC8vIHdyaXRlIHRoZSBkYXRhIHRvIGEgZmlsZSBpbiB0aGUgZGlyZWN0b3J5XG4gICAgICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTtcbiAgICAgKiAgICAgfV0sXG4gICAgICogICAgIGVtYWlsX2xpbms6IFsnd3JpdGVfZmlsZScsIGZ1bmN0aW9uKHJlc3VsdHMsIGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICAvLyBvbmNlIHRoZSBmaWxlIGlzIHdyaXR0ZW4gbGV0J3MgZW1haWwgYSBsaW5rIHRvIGl0Li4uXG4gICAgICogICAgICAgICBjYWxsYmFjayhudWxsLCB7J2ZpbGUnOnJlc3VsdHMud3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAgICAgKiAgICAgfV1cbiAgICAgKiB9KS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZygncmVzdWx0cyA9ICcsIHJlc3VsdHMpO1xuICAgICAqICAgICAvLyByZXN1bHRzID0ge1xuICAgICAqICAgICAvLyAgICAgZ2V0X2RhdGE6IFsnZGF0YScsICdjb252ZXJ0ZWQgdG8gYXJyYXknXVxuICAgICAqICAgICAvLyAgICAgbWFrZV9mb2xkZXI7ICdmb2xkZXInLFxuICAgICAqICAgICAvLyAgICAgd3JpdGVfZmlsZTogJ2ZpbGVuYW1lJ1xuICAgICAqICAgICAvLyAgICAgZW1haWxfbGluazogeyBmaWxlOiAnZmlsZW5hbWUnLCBlbWFpbDogJ3VzZXJAZXhhbXBsZS5jb20nIH1cbiAgICAgKiAgICAgLy8gfVxuICAgICAqIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdlcnIgPSAnLCBlcnIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy9Vc2luZyBhc3luYy9hd2FpdFxuICAgICAqIGFzeW5jICgpID0+IHtcbiAgICAgKiAgICAgdHJ5IHtcbiAgICAgKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMuYXV0byh7XG4gICAgICogICAgICAgICAgICAgZ2V0X2RhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gZ2V0IHNvbWUgZGF0YVxuICAgICAqICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnZGF0YScsICdjb252ZXJ0ZWQgdG8gYXJyYXknKTtcbiAgICAgKiAgICAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgICAgIG1ha2VfZm9sZGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGNyZWF0ZSBhIGRpcmVjdG9yeSB0byBzdG9yZSBhIGZpbGUgaW5cbiAgICAgKiAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBydW4gYXQgdGhlIHNhbWUgdGltZSBhcyBnZXR0aW5nIHRoZSBkYXRhXG4gICAgICogICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmb2xkZXInKTtcbiAgICAgKiAgICAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgICAgIHdyaXRlX2ZpbGU6IFsnZ2V0X2RhdGEnLCAnbWFrZV9mb2xkZXInLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgICAgICAgICAvLyBvbmNlIHRoZXJlIGlzIHNvbWUgZGF0YSBhbmQgdGhlIGRpcmVjdG9yeSBleGlzdHMsXG4gICAgICogICAgICAgICAgICAgICAgIC8vIHdyaXRlIHRoZSBkYXRhIHRvIGEgZmlsZSBpbiB0aGUgZGlyZWN0b3J5XG4gICAgICogICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpO1xuICAgICAqICAgICAgICAgICAgIH1dLFxuICAgICAqICAgICAgICAgICAgIGVtYWlsX2xpbms6IFsnd3JpdGVfZmlsZScsIGZ1bmN0aW9uKHJlc3VsdHMsIGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICAgICAgICAgIC8vIG9uY2UgdGhlIGZpbGUgaXMgd3JpdHRlbiBsZXQncyBlbWFpbCBhIGxpbmsgdG8gaXQuLi5cbiAgICAgKiAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeydmaWxlJzpyZXN1bHRzLndyaXRlX2ZpbGUsICdlbWFpbCc6J3VzZXJAZXhhbXBsZS5jb20nfSk7XG4gICAgICogICAgICAgICAgICAgfV1cbiAgICAgKiAgICAgICAgIH0pO1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coJ3Jlc3VsdHMgPSAnLCByZXN1bHRzKTtcbiAgICAgKiAgICAgICAgIC8vIHJlc3VsdHMgPSB7XG4gICAgICogICAgICAgICAvLyAgICAgZ2V0X2RhdGE6IFsnZGF0YScsICdjb252ZXJ0ZWQgdG8gYXJyYXknXVxuICAgICAqICAgICAgICAgLy8gICAgIG1ha2VfZm9sZGVyOyAnZm9sZGVyJyxcbiAgICAgKiAgICAgICAgIC8vICAgICB3cml0ZV9maWxlOiAnZmlsZW5hbWUnXG4gICAgICogICAgICAgICAvLyAgICAgZW1haWxfbGluazogeyBmaWxlOiAnZmlsZW5hbWUnLCBlbWFpbDogJ3VzZXJAZXhhbXBsZS5jb20nIH1cbiAgICAgKiAgICAgICAgIC8vIH1cbiAgICAgKiAgICAgfVxuICAgICAqICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0byh0YXNrcywgY29uY3VycmVuY3ksIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uY3VycmVuY3kgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBjb25jdXJyZW5jeSBpcyBvcHRpb25hbCwgc2hpZnQgdGhlIGFyZ3MuXG4gICAgICAgICAgICBjYWxsYmFjayA9IGNvbmN1cnJlbmN5O1xuICAgICAgICAgICAgY29uY3VycmVuY3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBwcm9taXNlQ2FsbGJhY2soKSk7XG4gICAgICAgIHZhciBudW1UYXNrcyA9IE9iamVjdC5rZXlzKHRhc2tzKS5sZW5ndGg7XG4gICAgICAgIGlmICghbnVtVGFza3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IG51bVRhc2tzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgdmFyIHJ1bm5pbmdUYXNrcyA9IDA7XG4gICAgICAgIHZhciBjYW5jZWxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgaGFzRXJyb3IgPSBmYWxzZTtcblxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICB2YXIgcmVhZHlUYXNrcyA9IFtdO1xuXG4gICAgICAgIC8vIGZvciBjeWNsZSBkZXRlY3Rpb246XG4gICAgICAgIHZhciByZWFkeVRvQ2hlY2sgPSBbXTsgLy8gdGFza3MgdGhhdCBoYXZlIGJlZW4gaWRlbnRpZmllZCBhcyByZWFjaGFibGVcbiAgICAgICAgLy8gd2l0aG91dCB0aGUgcG9zc2liaWxpdHkgb2YgcmV0dXJuaW5nIHRvIGFuIGFuY2VzdG9yIHRhc2tcbiAgICAgICAgdmFyIHVuY2hlY2tlZERlcGVuZGVuY2llcyA9IHt9O1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHRhc2tzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzW2tleV07XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFzaykpIHtcbiAgICAgICAgICAgICAgICAvLyBubyBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgICAgICBlbnF1ZXVlVGFzayhrZXksIFt0YXNrXSk7XG4gICAgICAgICAgICAgICAgcmVhZHlUb0NoZWNrLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSB0YXNrLnNsaWNlKDAsIHRhc2subGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nRGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdEZXBlbmRlbmNpZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBlbnF1ZXVlVGFzayhrZXksIHRhc2spO1xuICAgICAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5jaGVja2VkRGVwZW5kZW5jaWVzW2tleV0gPSByZW1haW5pbmdEZXBlbmRlbmNpZXM7XG5cbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5mb3JFYWNoKGRlcGVuZGVuY3lOYW1lID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRhc2tzW2RlcGVuZGVuY3lOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jLmF1dG8gdGFzayBgJyArIGtleSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYCBoYXMgYSBub24tZXhpc3RlbnQgZGVwZW5kZW5jeSBgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5TmFtZSArICdgIGluICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRMaXN0ZW5lcihkZXBlbmRlbmN5TmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdEZXBlbmRlbmNpZXMtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0RlcGVuZGVuY2llcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNoZWNrRm9yRGVhZGxvY2tzKCk7XG4gICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGVucXVldWVUYXNrKGtleSwgdGFzaykge1xuICAgICAgICAgICAgcmVhZHlUYXNrcy5wdXNoKCgpID0+IHJ1blRhc2soa2V5LCB0YXNrKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzUXVldWUoKSB7XG4gICAgICAgICAgICBpZiAoY2FuY2VsZWQpIHJldHVyblxuICAgICAgICAgICAgaWYgKHJlYWR5VGFza3MubGVuZ3RoID09PSAwICYmIHJ1bm5pbmdUYXNrcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlKHJlYWR5VGFza3MubGVuZ3RoICYmIHJ1bm5pbmdUYXNrcyA8IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1biA9IHJlYWR5VGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBydW4oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkTGlzdGVuZXIodGFza05hbWUsIGZuKSB7XG4gICAgICAgICAgICB2YXIgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV07XG4gICAgICAgICAgICBpZiAoIXRhc2tMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICB0YXNrTGlzdGVuZXJzID0gbGlzdGVuZXJzW3Rhc2tOYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXNrTGlzdGVuZXJzLnB1c2goZm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdGFza0NvbXBsZXRlKHRhc2tOYW1lKSB7XG4gICAgICAgICAgICB2YXIgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV0gfHwgW107XG4gICAgICAgICAgICB0YXNrTGlzdGVuZXJzLmZvckVhY2goZm4gPT4gZm4oKSk7XG4gICAgICAgICAgICBwcm9jZXNzUXVldWUoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgZnVuY3Rpb24gcnVuVGFzayhrZXksIHRhc2spIHtcbiAgICAgICAgICAgIGlmIChoYXNFcnJvcikgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgdGFza0NhbGxiYWNrID0gb25seU9uY2UoKGVyciwgLi4ucmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcnVubmluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIFtyZXN1bHRdID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYWZlUmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyZXN1bHRzKS5mb3JFYWNoKHJrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNbcmtleV0gPSByZXN1bHRzW3JrZXldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsZWQpIHJldHVyblxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNhZmVSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tDb21wbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBydW5uaW5nVGFza3MrKztcbiAgICAgICAgICAgIHZhciB0YXNrRm4gPSB3cmFwQXN5bmModGFza1t0YXNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIGlmICh0YXNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0YXNrRm4ocmVzdWx0cywgdGFza0NhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFza0ZuKHRhc2tDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGVja0ZvckRlYWRsb2NrcygpIHtcbiAgICAgICAgICAgIC8vIEthaG4ncyBhbGdvcml0aG1cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvcG9sb2dpY2FsX3NvcnRpbmcjS2Fobi4yN3NfYWxnb3JpdGhtXG4gICAgICAgICAgICAvLyBodHRwOi8vY29ubmFsbGUuYmxvZ3Nwb3QuY29tLzIwMTMvMTAvdG9wb2xvZ2ljYWwtc29ydGluZ2thaG4tYWxnb3JpdGhtLmh0bWxcbiAgICAgICAgICAgIHZhciBjdXJyZW50VGFzaztcbiAgICAgICAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkeVRvQ2hlY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRhc2sgPSByZWFkeVRvQ2hlY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgY291bnRlcisrO1xuICAgICAgICAgICAgICAgIGdldERlcGVuZGVudHMoY3VycmVudFRhc2spLmZvckVhY2goZGVwZW5kZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tdW5jaGVja2VkRGVwZW5kZW5jaWVzW2RlcGVuZGVudF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGRlcGVuZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvdW50ZXIgIT09IG51bVRhc2tzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnYXN5bmMuYXV0byBjYW5ub3QgZXhlY3V0ZSB0YXNrcyBkdWUgdG8gYSByZWN1cnNpdmUgZGVwZW5kZW5jeSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGVwZW5kZW50cyh0YXNrTmFtZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGFza3MpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXNrID0gdGFza3Nba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXNrKSAmJiB0YXNrLmluZGV4T2YodGFza05hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2tbUFJPTUlTRV9TWU1CT0xdXG4gICAgfVxuXG4gICAgdmFyIEZOX0FSR1MgPSAvXig/OmFzeW5jXFxzKyk/KD86ZnVuY3Rpb24pP1xccypcXHcqXFxzKlxcKFxccyooW14pXSspXFxzKlxcKSg/Olxccyp7KS87XG4gICAgdmFyIEFSUk9XX0ZOX0FSR1MgPSAvXig/OmFzeW5jXFxzKyk/XFwoP1xccyooW14pPV0rKVxccypcXCk/KD86XFxzKj0+KS87XG4gICAgdmFyIEZOX0FSR19TUExJVCA9IC8sLztcbiAgICB2YXIgRk5fQVJHID0gLyg9LispPyhcXHMqKSQvO1xuXG4gICAgZnVuY3Rpb24gc3RyaXBDb21tZW50cyhzdHJpbmcpIHtcbiAgICAgICAgbGV0IHN0cmlwcGVkID0gJyc7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGxldCBlbmRCbG9ja0NvbW1lbnQgPSBzdHJpbmcuaW5kZXhPZignKi8nKTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHN0cmluZ1tpbmRleF0gPT09ICcvJyAmJiBzdHJpbmdbaW5kZXgrMV0gPT09ICcvJykge1xuICAgICAgICAgICAgICAgIC8vIGlubGluZSBjb21tZW50XG4gICAgICAgICAgICAgICAgbGV0IGVuZEluZGV4ID0gc3RyaW5nLmluZGV4T2YoJ1xcbicsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IChlbmRJbmRleCA9PT0gLTEpID8gc3RyaW5nLmxlbmd0aCA6IGVuZEluZGV4O1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZW5kQmxvY2tDb21tZW50ICE9PSAtMSkgJiYgKHN0cmluZ1tpbmRleF0gPT09ICcvJykgJiYgKHN0cmluZ1tpbmRleCsxXSA9PT0gJyonKSkge1xuICAgICAgICAgICAgICAgIC8vIGJsb2NrIGNvbW1lbnRcbiAgICAgICAgICAgICAgICBsZXQgZW5kSW5kZXggPSBzdHJpbmcuaW5kZXhPZignKi8nLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGVuZEluZGV4ICsgMjtcbiAgICAgICAgICAgICAgICAgICAgZW5kQmxvY2tDb21tZW50ID0gc3RyaW5nLmluZGV4T2YoJyovJywgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmlwcGVkICs9IHN0cmluZ1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpcHBlZCArPSBzdHJpbmdbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmlwcGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGFyYW1zKGZ1bmMpIHtcbiAgICAgICAgY29uc3Qgc3JjID0gc3RyaXBDb21tZW50cyhmdW5jLnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBzcmMubWF0Y2goRk5fQVJHUyk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIG1hdGNoID0gc3JjLm1hdGNoKEFSUk9XX0ZOX0FSR1MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHBhcnNlIGFyZ3MgaW4gYXV0b0luamVjdFxcblNvdXJjZTpcXG4nICsgc3JjKVxuICAgICAgICBsZXQgWywgYXJnc10gPSBtYXRjaDtcbiAgICAgICAgcmV0dXJuIGFyZ3NcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMvZywgJycpXG4gICAgICAgICAgICAuc3BsaXQoRk5fQVJHX1NQTElUKVxuICAgICAgICAgICAgLm1hcCgoYXJnKSA9PiBhcmcucmVwbGFjZShGTl9BUkcsICcnKS50cmltKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZGVwZW5kZW5jeS1pbmplY3RlZCB2ZXJzaW9uIG9mIHRoZSBbYXN5bmMuYXV0b117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99IGZ1bmN0aW9uLiBEZXBlbmRlbnRcbiAgICAgKiB0YXNrcyBhcmUgc3BlY2lmaWVkIGFzIHBhcmFtZXRlcnMgdG8gdGhlIGZ1bmN0aW9uLCBhZnRlciB0aGUgdXN1YWwgY2FsbGJhY2tcbiAgICAgKiBwYXJhbWV0ZXIsIHdpdGggdGhlIHBhcmFtZXRlciBuYW1lcyBtYXRjaGluZyB0aGUgbmFtZXMgb2YgdGhlIHRhc2tzIGl0XG4gICAgICogZGVwZW5kcyBvbi4gVGhpcyBjYW4gcHJvdmlkZSBldmVuIG1vcmUgcmVhZGFibGUgdGFzayBncmFwaHMgd2hpY2ggY2FuIGJlXG4gICAgICogZWFzaWVyIHRvIG1haW50YWluLlxuICAgICAqXG4gICAgICogSWYgYSBmaW5hbCBjYWxsYmFjayBpcyBzcGVjaWZpZWQsIHRoZSB0YXNrIHJlc3VsdHMgYXJlIHNpbWlsYXJseSBpbmplY3RlZCxcbiAgICAgKiBzcGVjaWZpZWQgYXMgbmFtZWQgcGFyYW1ldGVycyBhZnRlciB0aGUgaW5pdGlhbCBlcnJvciBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBUaGUgYXV0b0luamVjdCBmdW5jdGlvbiBpcyBwdXJlbHkgc3ludGFjdGljIHN1Z2FyIGFuZCBpdHMgc2VtYW50aWNzIGFyZVxuICAgICAqIG90aGVyd2lzZSBlcXVpdmFsZW50IHRvIFthc3luYy5hdXRvXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30uXG4gICAgICpcbiAgICAgKiBAbmFtZSBhdXRvSW5qZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMuYXV0b117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99XG4gICAgICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXNrcyAtIEFuIG9iamVjdCwgZWFjaCBvZiB3aG9zZSBwcm9wZXJ0aWVzIGlzIGFuIHtAbGluayBBc3luY0Z1bmN0aW9ufSBvZlxuICAgICAqIHRoZSBmb3JtICdmdW5jKFtkZXBlbmRlbmNpZXMuLi5dLCBjYWxsYmFjaykuIFRoZSBvYmplY3QncyBrZXkgb2YgYSBwcm9wZXJ0eVxuICAgICAqIHNlcnZlcyBhcyB0aGUgbmFtZSBvZiB0aGUgdGFzayBkZWZpbmVkIGJ5IHRoYXQgcHJvcGVydHksIGkuZS4gY2FuIGJlIHVzZWRcbiAgICAgKiB3aGVuIHNwZWNpZnlpbmcgcmVxdWlyZW1lbnRzIGZvciBvdGhlciB0YXNrcy5cbiAgICAgKiAqIFRoZSBgY2FsbGJhY2tgIHBhcmFtZXRlciBpcyBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIHdoaWNoIG11c3QgYmUgY2FsbGVkXG4gICAgICogICB3aGVuIGZpbmlzaGVkLCBwYXNzaW5nIGFuIGBlcnJvcmAgKHdoaWNoIGNhbiBiZSBgbnVsbGApIGFuZCB0aGUgcmVzdWx0IG9mXG4gICAgICogICB0aGUgZnVuY3Rpb24ncyBleGVjdXRpb24uIFRoZSByZW1haW5pbmcgcGFyYW1ldGVycyBuYW1lIG90aGVyIHRhc2tzIG9uXG4gICAgICogICB3aGljaCB0aGUgdGFzayBpcyBkZXBlbmRlbnQsIGFuZCB0aGUgcmVzdWx0cyBmcm9tIHRob3NlIHRhc2tzIGFyZSB0aGVcbiAgICAgKiAgIGFyZ3VtZW50cyBvZiB0aG9zZSBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAgICAgKiB0aGUgdGFza3MgaGF2ZSBiZWVuIGNvbXBsZXRlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFyZ3VtZW50IGlmIGFueSBgdGFza3NgXG4gICAgICogcGFzcyBhbiBlcnJvciB0byB0aGVpciBjYWxsYmFjaywgYW5kIGEgYHJlc3VsdHNgIG9iamVjdCB3aXRoIGFueSBjb21wbGV0ZWRcbiAgICAgKiB0YXNrIHJlc3VsdHMsIHNpbWlsYXIgdG8gYGF1dG9gLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyAgVGhlIGV4YW1wbGUgZnJvbSBgYXV0b2AgY2FuIGJlIHJld3JpdHRlbiBhcyBmb2xsb3dzOlxuICAgICAqIGFzeW5jLmF1dG9JbmplY3Qoe1xuICAgICAqICAgICBnZXRfZGF0YTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gZ2V0IHNvbWUgZGF0YVxuICAgICAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7XG4gICAgICogICAgIH0sXG4gICAgICogICAgIG1ha2VfZm9sZGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdG8gc3RvcmUgYSBmaWxlIGluXG4gICAgICogICAgICAgICAvLyB0aGlzIGlzIHJ1biBhdCB0aGUgc2FtZSB0aW1lIGFzIGdldHRpbmcgdGhlIGRhdGFcbiAgICAgKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmb2xkZXInKTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgd3JpdGVfZmlsZTogZnVuY3Rpb24oZ2V0X2RhdGEsIG1ha2VfZm9sZGVyLCBjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgLy8gb25jZSB0aGVyZSBpcyBzb21lIGRhdGEgYW5kIHRoZSBkaXJlY3RvcnkgZXhpc3RzLFxuICAgICAqICAgICAgICAgLy8gd3JpdGUgdGhlIGRhdGEgdG8gYSBmaWxlIGluIHRoZSBkaXJlY3RvcnlcbiAgICAgKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpO1xuICAgICAqICAgICB9LFxuICAgICAqICAgICBlbWFpbF9saW5rOiBmdW5jdGlvbih3cml0ZV9maWxlLCBjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgLy8gb25jZSB0aGUgZmlsZSBpcyB3cml0dGVuIGxldCdzIGVtYWlsIGEgbGluayB0byBpdC4uLlxuICAgICAqICAgICAgICAgLy8gd3JpdGVfZmlsZSBjb250YWlucyB0aGUgZmlsZW5hbWUgcmV0dXJuZWQgYnkgd3JpdGVfZmlsZS5cbiAgICAgKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAgICAgKiAgICAgfVxuICAgICAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2VtYWlsX2xpbmsgPSAnLCByZXN1bHRzLmVtYWlsX2xpbmspO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gSWYgeW91IGFyZSB1c2luZyBhIEpTIG1pbmlmaWVyIHRoYXQgbWFuZ2xlcyBwYXJhbWV0ZXIgbmFtZXMsIGBhdXRvSW5qZWN0YFxuICAgICAqIC8vIHdpbGwgbm90IHdvcmsgd2l0aCBwbGFpbiBmdW5jdGlvbnMsIHNpbmNlIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbCBiZVxuICAgICAqIC8vIGNvbGxhcHNlZCB0byBhIHNpbmdsZSBsZXR0ZXIgaWRlbnRpZmllci4gIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHlvdSBjYW5cbiAgICAgKiAvLyBleHBsaWNpdGx5IHNwZWNpZnkgdGhlIG5hbWVzIG9mIHRoZSBwYXJhbWV0ZXJzIHlvdXIgdGFzayBmdW5jdGlvbiBuZWVkc1xuICAgICAqIC8vIGluIGFuIGFycmF5LCBzaW1pbGFyIHRvIEFuZ3VsYXIuanMgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gICAgICpcbiAgICAgKiAvLyBUaGlzIHN0aWxsIGhhcyBhbiBhZHZhbnRhZ2Ugb3ZlciBwbGFpbiBgYXV0b2AsIHNpbmNlIHRoZSByZXN1bHRzIGEgdGFza1xuICAgICAqIC8vIGRlcGVuZHMgb24gYXJlIHN0aWxsIHNwcmVhZCBpbnRvIGFyZ3VtZW50cy5cbiAgICAgKiBhc3luYy5hdXRvSW5qZWN0KHtcbiAgICAgKiAgICAgLy8uLi5cbiAgICAgKiAgICAgd3JpdGVfZmlsZTogWydnZXRfZGF0YScsICdtYWtlX2ZvbGRlcicsIGZ1bmN0aW9uKGdldF9kYXRhLCBtYWtlX2ZvbGRlciwgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpO1xuICAgICAqICAgICB9XSxcbiAgICAgKiAgICAgZW1haWxfbGluazogWyd3cml0ZV9maWxlJywgZnVuY3Rpb24od3JpdGVfZmlsZSwgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAgICAgKiAgICAgfV1cbiAgICAgKiAgICAgLy8uLi5cbiAgICAgKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2VyciA9ICcsIGVycik7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdlbWFpbF9saW5rID0gJywgcmVzdWx0cy5lbWFpbF9saW5rKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvSW5qZWN0KHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbmV3VGFza3MgPSB7fTtcblxuICAgICAgICBPYmplY3Qua2V5cyh0YXNrcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgdmFyIHRhc2tGbiA9IHRhc2tzW2tleV07XG4gICAgICAgICAgICB2YXIgcGFyYW1zO1xuICAgICAgICAgICAgdmFyIGZuSXNBc3luYyA9IGlzQXN5bmModGFza0ZuKTtcbiAgICAgICAgICAgIHZhciBoYXNOb0RlcHMgPVxuICAgICAgICAgICAgICAgICghZm5Jc0FzeW5jICYmIHRhc2tGbi5sZW5ndGggPT09IDEpIHx8XG4gICAgICAgICAgICAgICAgKGZuSXNBc3luYyAmJiB0YXNrRm4ubGVuZ3RoID09PSAwKTtcblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFza0ZuKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IFsuLi50YXNrRm5dO1xuICAgICAgICAgICAgICAgIHRhc2tGbiA9IHBhcmFtcy5wb3AoKTtcblxuICAgICAgICAgICAgICAgIG5ld1Rhc2tzW2tleV0gPSBwYXJhbXMuY29uY2F0KHBhcmFtcy5sZW5ndGggPiAwID8gbmV3VGFzayA6IHRhc2tGbik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhc05vRGVwcykge1xuICAgICAgICAgICAgICAgIC8vIG5vIGRlcGVuZGVuY2llcywgdXNlIHRoZSBmdW5jdGlvbiBhcy1pc1xuICAgICAgICAgICAgICAgIG5ld1Rhc2tzW2tleV0gPSB0YXNrRm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHBhcnNlUGFyYW1zKHRhc2tGbik7XG4gICAgICAgICAgICAgICAgaWYgKCh0YXNrRm4ubGVuZ3RoID09PSAwICYmICFmbklzQXN5bmMpICYmIHBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXV0b0luamVjdCB0YXNrIGZ1bmN0aW9ucyByZXF1aXJlIGV4cGxpY2l0IHBhcmFtZXRlcnMuXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBjYWxsYmFjayBwYXJhbVxuICAgICAgICAgICAgICAgIGlmICghZm5Jc0FzeW5jKSBwYXJhbXMucG9wKCk7XG5cbiAgICAgICAgICAgICAgICBuZXdUYXNrc1trZXldID0gcGFyYW1zLmNvbmNhdChuZXdUYXNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbmV3VGFzayhyZXN1bHRzLCB0YXNrQ2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QXJncyA9IHBhcmFtcy5tYXAobmFtZSA9PiByZXN1bHRzW25hbWVdKTtcbiAgICAgICAgICAgICAgICBuZXdBcmdzLnB1c2godGFza0NiKTtcbiAgICAgICAgICAgICAgICB3cmFwQXN5bmModGFza0ZuKSguLi5uZXdBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGF1dG8obmV3VGFza3MsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvLyBTaW1wbGUgZG91Ymx5IGxpbmtlZCBsaXN0IChodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VibHlfbGlua2VkX2xpc3QpIGltcGxlbWVudGF0aW9uXG4gICAgLy8gdXNlZCBmb3IgcXVldWVzLiBUaGlzIGltcGxlbWVudGF0aW9uIGFzc3VtZXMgdGhhdCB0aGUgbm9kZSBwcm92aWRlZCBieSB0aGUgdXNlciBjYW4gYmUgbW9kaWZpZWRcbiAgICAvLyB0byBhZGp1c3QgdGhlIG5leHQgYW5kIGxhc3QgcHJvcGVydGllcy4gV2UgaW1wbGVtZW50IG9ubHkgdGhlIG1pbmltYWwgZnVuY3Rpb25hbGl0eVxuICAgIC8vIGZvciBxdWV1ZSBzdXBwb3J0LlxuICAgIGNsYXNzIERMTCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW92ZUxpbmsobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucHJldikgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICBlbHNlIHRoaXMuaGVhZCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHQpIG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2O1xuICAgICAgICAgICAgZWxzZSB0aGlzLnRhaWwgPSBub2RlLnByZXY7XG5cbiAgICAgICAgICAgIG5vZGUucHJldiA9IG5vZGUubmV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCAtPSAxO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBlbXB0eSAoKSB7XG4gICAgICAgICAgICB3aGlsZSh0aGlzLmhlYWQpIHRoaXMuc2hpZnQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zZXJ0QWZ0ZXIobm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICAgICAgbmV3Tm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIG5ld05vZGUubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHQpIG5vZGUubmV4dC5wcmV2ID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy50YWlsID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IG5ld05vZGU7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zZXJ0QmVmb3JlKG5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgICAgIG5ld05vZGUucHJldiA9IG5vZGUucHJldjtcbiAgICAgICAgICAgIG5ld05vZGUubmV4dCA9IG5vZGU7XG4gICAgICAgICAgICBpZiAobm9kZS5wcmV2KSBub2RlLnByZXYubmV4dCA9IG5ld05vZGU7XG4gICAgICAgICAgICBlbHNlIHRoaXMuaGVhZCA9IG5ld05vZGU7XG4gICAgICAgICAgICBub2RlLnByZXYgPSBuZXdOb2RlO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVuc2hpZnQobm9kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCkgdGhpcy5pbnNlcnRCZWZvcmUodGhpcy5oZWFkLCBub2RlKTtcbiAgICAgICAgICAgIGVsc2Ugc2V0SW5pdGlhbCh0aGlzLCBub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2gobm9kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGFpbCkgdGhpcy5pbnNlcnRBZnRlcih0aGlzLnRhaWwsIG5vZGUpO1xuICAgICAgICAgICAgZWxzZSBzZXRJbml0aWFsKHRoaXMsIG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2hpZnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkICYmIHRoaXMucmVtb3ZlTGluayh0aGlzLmhlYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9wKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFpbCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy50YWlsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvQXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnRoaXNdXG4gICAgICAgIH1cblxuICAgICAgICAqW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgICAgICAgICAgdmFyIGN1ciA9IHRoaXMuaGVhZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXIpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjdXIuZGF0YTtcbiAgICAgICAgICAgICAgICBjdXIgPSBjdXIubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW92ZSAodGVzdEZuKSB7XG4gICAgICAgICAgICB2YXIgY3VyciA9IHRoaXMuaGVhZDtcbiAgICAgICAgICAgIHdoaWxlKGN1cnIpIHtcbiAgICAgICAgICAgICAgICB2YXIge25leHR9ID0gY3VycjtcbiAgICAgICAgICAgICAgICBpZiAodGVzdEZuKGN1cnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGluayhjdXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyciA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEluaXRpYWwoZGxsLCBub2RlKSB7XG4gICAgICAgIGRsbC5sZW5ndGggPSAxO1xuICAgICAgICBkbGwuaGVhZCA9IGRsbC50YWlsID0gbm9kZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5LCBwYXlsb2FkKSB7XG4gICAgICAgIGlmIChjb25jdXJyZW5jeSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihjb25jdXJyZW5jeSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvbmN1cnJlbmN5IG11c3Qgbm90IGJlIHplcm8nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfd29ya2VyID0gd3JhcEFzeW5jKHdvcmtlcik7XG4gICAgICAgIHZhciBudW1SdW5uaW5nID0gMDtcbiAgICAgICAgdmFyIHdvcmtlcnNMaXN0ID0gW107XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHtcbiAgICAgICAgICAgIGVycm9yOiBbXSxcbiAgICAgICAgICAgIGRyYWluOiBbXSxcbiAgICAgICAgICAgIHNhdHVyYXRlZDogW10sXG4gICAgICAgICAgICB1bnNhdHVyYXRlZDogW10sXG4gICAgICAgICAgICBlbXB0eTogW11cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBvbiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGV2ZW50c1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uY2UgKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVBbmRSZW1vdmUgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIG9mZihldmVudCwgaGFuZGxlQW5kUmVtb3ZlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50c1tldmVudF0ucHVzaChoYW5kbGVBbmRSZW1vdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2ZmIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKCFldmVudCkgcmV0dXJuIE9iamVjdC5rZXlzKGV2ZW50cykuZm9yRWFjaChldiA9PiBldmVudHNbZXZdID0gW10pXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHJldHVybiBldmVudHNbZXZlbnRdID0gW11cbiAgICAgICAgICAgIGV2ZW50c1tldmVudF0gPSBldmVudHNbZXZlbnRdLmZpbHRlcihldiA9PiBldiAhPT0gaGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyIChldmVudCwgLi4uYXJncykge1xuICAgICAgICAgICAgZXZlbnRzW2V2ZW50XS5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlciguLi5hcmdzKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvY2Vzc2luZ1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KGRhdGEsIGluc2VydEF0RnJvbnQsIHJlamVjdE9uRXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rhc2sgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB2YXIgcmVzLCByZWo7XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9taXNlQ2FsbGJhY2sgKGVyciwgLi4uYXJncykge1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGVycm9yLCBsZXQgdGhlIGdsb2JhbCBlcnJvciBoYW5kbGVyXG4gICAgICAgICAgICAgICAgLy8gZGVhbCB3aXRoIGl0XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdE9uRXJyb3IgPyByZWooZXJyKSA6IHJlcygpXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHJldHVybiByZXMoYXJnc1swXSlcbiAgICAgICAgICAgICAgICByZXMoYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpdGVtID0gcS5fY3JlYXRlVGFza0l0ZW0oXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICByZWplY3RPbkVycm9yID8gcHJvbWlzZUNhbGxiYWNrIDpcbiAgICAgICAgICAgICAgICAgICAgKGNhbGxiYWNrIHx8IHByb21pc2VDYWxsYmFjaylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChpbnNlcnRBdEZyb250KSB7XG4gICAgICAgICAgICAgICAgcS5fdGFza3MudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcS5fdGFza3MucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFwcm9jZXNzaW5nU2NoZWR1bGVkKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzaW5nU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVqZWN0T25FcnJvciB8fCAhY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICByZWogPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9jcmVhdGVDQih0YXNrcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBudW1SdW5uaW5nIC09IDE7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhc2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHdvcmtlcnNMaXN0LmluZGV4T2YodGFzayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlcnNMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0YXNrLmNhbGxiYWNrKGVyciwgLi4uYXJncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCdlcnJvcicsIGVyciwgdGFzay5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChudW1SdW5uaW5nIDw9IChxLmNvbmN1cnJlbmN5IC0gcS5idWZmZXIpICkge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCd1bnNhdHVyYXRlZCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChxLmlkbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCdkcmFpbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfbWF5YmVEcmFpbihkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDAgJiYgcS5pZGxlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKCgpID0+IHRyaWdnZXIoJ2RyYWluJykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV2ZW50TWV0aG9kID0gKG5hbWUpID0+IChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbmNlKG5hbWUsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZihuYW1lKTtcbiAgICAgICAgICAgIG9uKG5hbWUsIGhhbmRsZXIpO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICB2YXIgcSA9IHtcbiAgICAgICAgICAgIF90YXNrczogbmV3IERMTCgpLFxuICAgICAgICAgICAgX2NyZWF0ZVRhc2tJdGVtIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAqW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBxLl90YXNrc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgYnVmZmVyOiBjb25jdXJyZW5jeSAvIDQsXG4gICAgICAgICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHBhdXNlZDogZmFsc2UsXG4gICAgICAgICAgICBwdXNoIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfbWF5YmVEcmFpbihkYXRhKSkgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcChkYXR1bSA9PiBfaW5zZXJ0KGRhdHVtLCBmYWxzZSwgZmFsc2UsIGNhbGxiYWNrKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9pbnNlcnQoZGF0YSwgZmFsc2UsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHVzaEFzeW5jIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfbWF5YmVEcmFpbihkYXRhKSkgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcChkYXR1bSA9PiBfaW5zZXJ0KGRhdHVtLCBmYWxzZSwgdHJ1ZSwgY2FsbGJhY2spKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX2luc2VydChkYXRhLCBmYWxzZSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtpbGwgKCkge1xuICAgICAgICAgICAgICAgIG9mZigpO1xuICAgICAgICAgICAgICAgIHEuX3Rhc2tzLmVtcHR5KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zaGlmdCAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX21heWJlRHJhaW4oZGF0YSkpIHJldHVyblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5tYXAoZGF0dW0gPT4gX2luc2VydChkYXR1bSwgdHJ1ZSwgZmFsc2UsIGNhbGxiYWNrKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9pbnNlcnQoZGF0YSwgdHJ1ZSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNoaWZ0QXN5bmMgKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9tYXliZURyYWluKGRhdGEpKSByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwKGRhdHVtID0+IF9pbnNlcnQoZGF0dW0sIHRydWUsIHRydWUsIGNhbGxiYWNrKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9pbnNlcnQoZGF0YSwgdHJ1ZSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZSAodGVzdEZuKSB7XG4gICAgICAgICAgICAgICAgcS5fdGFza3MucmVtb3ZlKHRlc3RGbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzcyAoKSB7XG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgdHJ5aW5nIHRvIHN0YXJ0IHRvbyBtYW55IHByb2Nlc3Npbmcgb3BlcmF0aW9ucy4gVGhpcyBjYW4gb2NjdXJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGNhbGxiYWNrcyByZXNvbHZlIHN5bmNocm9ub3VzbHkgKCMxMjY3KS5cbiAgICAgICAgICAgICAgICBpZiAoaXNQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3aGlsZSghcS5wYXVzZWQgJiYgbnVtUnVubmluZyA8IHEuY29uY3VycmVuY3kgJiYgcS5fdGFza3MubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhc2tzID0gW10sIGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBxLl90YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxLnBheWxvYWQpIGwgPSBNYXRoLm1pbihsLCBxLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBxLl90YXNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlcnNMaXN0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2gobm9kZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG51bVJ1bm5pbmcgKz0gMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocS5fdGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCdlbXB0eScpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bVJ1bm5pbmcgPT09IHEuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoJ3NhdHVyYXRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gb25seU9uY2UoX2NyZWF0ZUNCKHRhc2tzKSk7XG4gICAgICAgICAgICAgICAgICAgIF93b3JrZXIoZGF0YSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGggKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLl90YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZyAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bVJ1bm5pbmc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd29ya2Vyc0xpc3QgKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXJzTGlzdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZGxlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLl90YXNrcy5sZW5ndGggKyBudW1SdW5uaW5nID09PSAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdXNlICgpIHtcbiAgICAgICAgICAgICAgICBxLnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdW1lICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIHEucGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEocS5wcm9jZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZGVmaW5lIHRoZXNlIGFzIGZpeGVkIHByb3BlcnRpZXMsIHNvIHBlb3BsZSBnZXQgdXNlZnVsIGVycm9ycyB3aGVuIHVwZGF0aW5nXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHEsIHtcbiAgICAgICAgICAgIHNhdHVyYXRlZDoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXZlbnRNZXRob2QoJ3NhdHVyYXRlZCcpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zYXR1cmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50TWV0aG9kKCd1bnNhdHVyYXRlZCcpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW1wdHk6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50TWV0aG9kKCdlbXB0eScpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHJhaW46IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50TWV0aG9kKCdkcmFpbicpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50TWV0aG9kKCdlcnJvcicpXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBjYXJnb2Agb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBwYXlsb2FkLiBUYXNrcyBhZGRlZCB0byB0aGVcbiAgICAgKiBjYXJnbyB3aWxsIGJlIHByb2Nlc3NlZCBhbHRvZ2V0aGVyICh1cCB0byB0aGUgYHBheWxvYWRgIGxpbWl0KS4gSWYgdGhlXG4gICAgICogYHdvcmtlcmAgaXMgaW4gcHJvZ3Jlc3MsIHRoZSB0YXNrIGlzIHF1ZXVlZCB1bnRpbCBpdCBiZWNvbWVzIGF2YWlsYWJsZS4gT25jZVxuICAgICAqIHRoZSBgd29ya2VyYCBoYXMgY29tcGxldGVkIHNvbWUgdGFza3MsIGVhY2ggY2FsbGJhY2sgb2YgdGhvc2UgdGFza3MgaXNcbiAgICAgKiBjYWxsZWQuIENoZWNrIG91dCBbdGhlc2VdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vNmJiZDM2ZjRjZjViMzVhMGYxMWE5NmRjZDJlOTc3MTFmZmMyZmIzNy82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDM4MmY2MjYyNjMzMDYzNjY2MjMwMmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM5MzczNDY2MmQzMzMzMzkzNzYzMzYzNDY0NjMzODM1MzgyZTY3Njk2NikgW2FuaW1hdGlvbnNdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vZjQ4MTBlMDBlMWM1ZjVmOGFkZGJlM2U5ZjQ5MDY0ZmQ1ZDEwMjY5OS82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDMxMmYzODM0NjMzOTMyMzAzNjM2MmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM4MzEzNDY2MmQzOTY0MzM2NDMwMzIzNDMxMzM2MjY2NjQyZTY3Njk2NilcbiAgICAgKiBmb3IgaG93IGBjYXJnb2AgYW5kIGBxdWV1ZWAgd29yay5cbiAgICAgKlxuICAgICAqIFdoaWxlIFtgcXVldWVgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9IHBhc3NlcyBvbmx5IG9uZSB0YXNrIHRvIG9uZSBvZiBhIGdyb3VwIG9mIHdvcmtlcnNcbiAgICAgKiBhdCBhIHRpbWUsIGNhcmdvIHBhc3NlcyBhbiBhcnJheSBvZiB0YXNrcyB0byBhIHNpbmdsZSB3b3JrZXIsIHJlcGVhdGluZ1xuICAgICAqIHdoZW4gdGhlIHdvcmtlciBpcyBmaW5pc2hlZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNhcmdvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMucXVldWVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX1cbiAgICAgKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgYW4gYXJyYXlcbiAgICAgKiBvZiBxdWV1ZWQgdGFza3MuIEludm9rZWQgd2l0aCBgKHRhc2tzLCBjYWxsYmFjaylgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGF5bG9hZD1JbmZpbml0eV0gLSBBbiBvcHRpb25hbCBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nXG4gICAgICogaG93IG1hbnkgdGFza3Mgc2hvdWxkIGJlIHByb2Nlc3NlZCBwZXIgcm91bmQ7IGlmIG9taXR0ZWQsIHRoZSBkZWZhdWx0IGlzXG4gICAgICogdW5saW1pdGVkLlxuICAgICAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuUXVldWVPYmplY3R9IEEgY2FyZ28gb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIENhbGxiYWNrcyBjYW5cbiAgICAgKiBhdHRhY2hlZCBhcyBjZXJ0YWluIHByb3BlcnRpZXMgdG8gbGlzdGVuIGZvciBzcGVjaWZpYyBldmVudHMgZHVyaW5nIHRoZVxuICAgICAqIGxpZmVjeWNsZSBvZiB0aGUgY2FyZ28gYW5kIGlubmVyIHF1ZXVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBjcmVhdGUgYSBjYXJnbyBvYmplY3Qgd2l0aCBwYXlsb2FkIDJcbiAgICAgKiB2YXIgY2FyZ28gPSBhc3luYy5jYXJnbyhmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgZm9yICh2YXIgaT0wOyBpPHRhc2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZygnaGVsbG8gJyArIHRhc2tzW2ldLm5hbWUpO1xuICAgICAqICAgICB9XG4gICAgICogICAgIGNhbGxiYWNrKCk7XG4gICAgICogfSwgMik7XG4gICAgICpcbiAgICAgKiAvLyBhZGQgc29tZSBpdGVtc1xuICAgICAqIGNhcmdvLnB1c2goe25hbWU6ICdmb28nfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpO1xuICAgICAqIH0pO1xuICAgICAqIGNhcmdvLnB1c2goe25hbWU6ICdiYXInfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICAgICAqIH0pO1xuICAgICAqIGF3YWl0IGNhcmdvLnB1c2goe25hbWU6ICdiYXonfSk7XG4gICAgICogY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmF6Jyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FyZ28od29ya2VyLCBwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBxdWV1ZSh3b3JrZXIsIDEsIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgY2FyZ29RdWV1ZWAgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBwYXlsb2FkLiBUYXNrcyBhZGRlZCB0byB0aGVcbiAgICAgKiBjYXJnb1F1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIHRvZ2V0aGVyICh1cCB0byB0aGUgYHBheWxvYWRgIGxpbWl0KSBpbiBgY29uY3VycmVuY3lgIHBhcmFsbGVsIHdvcmtlcnMuXG4gICAgICogSWYgdGhlIGFsbCBgd29ya2Vyc2AgYXJlIGluIHByb2dyZXNzLCB0aGUgdGFzayBpcyBxdWV1ZWQgdW50aWwgb25lIGJlY29tZXMgYXZhaWxhYmxlLiBPbmNlXG4gICAgICogYSBgd29ya2VyYCBoYXMgY29tcGxldGVkIHNvbWUgdGFza3MsIGVhY2ggY2FsbGJhY2sgb2YgdGhvc2UgdGFza3MgaXNcbiAgICAgKiBjYWxsZWQuIENoZWNrIG91dCBbdGhlc2VdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vNmJiZDM2ZjRjZjViMzVhMGYxMWE5NmRjZDJlOTc3MTFmZmMyZmIzNy82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDM4MmY2MjYyNjMzMDYzNjY2MjMwMmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM5MzczNDY2MmQzMzMzMzkzNzYzMzYzNDY0NjMzODM1MzgyZTY3Njk2NikgW2FuaW1hdGlvbnNdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vZjQ4MTBlMDBlMWM1ZjVmOGFkZGJlM2U5ZjQ5MDY0ZmQ1ZDEwMjY5OS82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDMxMmYzODM0NjMzOTMyMzAzNjM2MmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM4MzEzNDY2MmQzOTY0MzM2NDMwMzIzNDMxMzM2MjY2NjQyZTY3Njk2NilcbiAgICAgKiBmb3IgaG93IGBjYXJnb2AgYW5kIGBxdWV1ZWAgd29yay5cbiAgICAgKlxuICAgICAqIFdoaWxlIFtgcXVldWVgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9IHBhc3NlcyBvbmx5IG9uZSB0YXNrIHRvIG9uZSBvZiBhIGdyb3VwIG9mIHdvcmtlcnNcbiAgICAgKiBhdCBhIHRpbWUsIGFuZCBbYGNhcmdvYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmNhcmdvfSBwYXNzZXMgYW4gYXJyYXkgb2YgdGFza3MgdG8gYSBzaW5nbGUgd29ya2VyLFxuICAgICAqIHRoZSBjYXJnb1F1ZXVlIHBhc3NlcyBhbiBhcnJheSBvZiB0YXNrcyB0byBtdWx0aXBsZSBwYXJhbGxlbCB3b3JrZXJzLlxuICAgICAqXG4gICAgICogQG5hbWUgY2FyZ29RdWV1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9XG4gICAgICogQHNlZSBbYXN5bmMuY2FyZ29de0BsaW5rIG1vZHVsZTpDb250cm9sRkxvdy5jYXJnb31cbiAgICAgKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgYW4gYXJyYXlcbiAgICAgKiBvZiBxdWV1ZWQgdGFza3MuIEludm9rZWQgd2l0aCBgKHRhc2tzLCBjYWxsYmFjaylgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVuY3k9MV0gLSBBbiBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nIGhvdyBtYW55XG4gICAgICogYHdvcmtlcmAgZnVuY3Rpb25zIHNob3VsZCBiZSBydW4gaW4gcGFyYWxsZWwuICBJZiBvbWl0dGVkLCB0aGUgY29uY3VycmVuY3lcbiAgICAgKiBkZWZhdWx0cyB0byBgMWAuICBJZiB0aGUgY29uY3VycmVuY3kgaXMgYDBgLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXlsb2FkPUluZmluaXR5XSAtIEFuIG9wdGlvbmFsIGBpbnRlZ2VyYCBmb3IgZGV0ZXJtaW5pbmdcbiAgICAgKiBob3cgbWFueSB0YXNrcyBzaG91bGQgYmUgcHJvY2Vzc2VkIHBlciByb3VuZDsgaWYgb21pdHRlZCwgdGhlIGRlZmF1bHQgaXNcbiAgICAgKiB1bmxpbWl0ZWQuXG4gICAgICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5RdWV1ZU9iamVjdH0gQSBjYXJnb1F1ZXVlIG9iamVjdCB0byBtYW5hZ2UgdGhlIHRhc2tzLiBDYWxsYmFja3MgY2FuXG4gICAgICogYXR0YWNoZWQgYXMgY2VydGFpbiBwcm9wZXJ0aWVzIHRvIGxpc3RlbiBmb3Igc3BlY2lmaWMgZXZlbnRzIGR1cmluZyB0aGVcbiAgICAgKiBsaWZlY3ljbGUgb2YgdGhlIGNhcmdvUXVldWUgYW5kIGlubmVyIHF1ZXVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBjcmVhdGUgYSBjYXJnb1F1ZXVlIG9iamVjdCB3aXRoIHBheWxvYWQgMiBhbmQgY29uY3VycmVuY3kgMlxuICAgICAqIHZhciBjYXJnb1F1ZXVlID0gYXN5bmMuY2FyZ29RdWV1ZShmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgZm9yICh2YXIgaT0wOyBpPHRhc2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZygnaGVsbG8gJyArIHRhc2tzW2ldLm5hbWUpO1xuICAgICAqICAgICB9XG4gICAgICogICAgIGNhbGxiYWNrKCk7XG4gICAgICogfSwgMiwgMik7XG4gICAgICpcbiAgICAgKiAvLyBhZGQgc29tZSBpdGVtc1xuICAgICAqIGNhcmdvUXVldWUucHVzaCh7bmFtZTogJ2Zvbyd9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgZm9vJyk7XG4gICAgICogfSk7XG4gICAgICogY2FyZ29RdWV1ZS5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uKGVycikge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBiYXInKTtcbiAgICAgKiB9KTtcbiAgICAgKiBjYXJnb1F1ZXVlLnB1c2goe25hbWU6ICdiYXonfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJheicpO1xuICAgICAqIH0pO1xuICAgICAqIGNhcmdvUXVldWUucHVzaCh7bmFtZTogJ2Jvbyd9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYm9vJyk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FyZ28kMSh3b3JrZXIsIGNvbmN1cnJlbmN5LCBwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBxdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGBjb2xsYCBpbnRvIGEgc2luZ2xlIHZhbHVlIHVzaW5nIGFuIGFzeW5jIGBpdGVyYXRlZWAgdG8gcmV0dXJuIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIHN0ZXAuIGBtZW1vYCBpcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLiBUaGlzIGZ1bmN0aW9uXG4gICAgICogb25seSBvcGVyYXRlcyBpbiBzZXJpZXMuXG4gICAgICpcbiAgICAgKiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQgbWF5IG1ha2Ugc2Vuc2UgdG8gc3BsaXQgYSBjYWxsIHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgKiBpbnRvIGEgcGFyYWxsZWwgbWFwLCBhbmQgdGhlbiB1c2UgdGhlIG5vcm1hbCBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgb24gdGhlXG4gICAgICogcmVzdWx0cy4gVGhpcyBmdW5jdGlvbiBpcyBmb3Igc2l0dWF0aW9ucyB3aGVyZSBlYWNoIHN0ZXAgaW4gdGhlIHJlZHVjdGlvblxuICAgICAqIG5lZWRzIHRvIGJlIGFzeW5jOyBpZiB5b3UgY2FuIGdldCB0aGUgZGF0YSBiZWZvcmUgcmVkdWNpbmcgaXQsIHRoZW4gaXQnc1xuICAgICAqIHByb2JhYmx5IGEgZ29vZCBpZGVhIHRvIGRvIHNvLlxuICAgICAqXG4gICAgICogQG5hbWUgcmVkdWNlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQGFsaWFzIGluamVjdFxuICAgICAqIEBhbGlhcyBmb2xkbFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsqfSBtZW1vIC0gVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiBhcHBsaWVkIHRvIGVhY2ggaXRlbSBpbiB0aGVcbiAgICAgKiBhcnJheSB0byBwcm9kdWNlIHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHJlZHVjdGlvbi5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgbmV4dCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLlxuICAgICAqIElmIHRoZSBpdGVyYXRlZSBjb21wbGV0ZXMgd2l0aCBhbiBlcnJvciwgdGhlIHJlZHVjdGlvbiBpcyBzdG9wcGVkIGFuZCB0aGVcbiAgICAgKiBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICAgICAqIEludm9rZWQgd2l0aCAobWVtbywgaXRlbSwgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gICAgICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IGlzIHRoZSByZWR1Y2VkIHZhbHVlLiBJbnZva2VkIHdpdGhcbiAgICAgKiAoZXJyLCByZXN1bHQpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBmaWxlMS50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMTAwMCBieXRlcyBpbiBzaXplXG4gICAgICogLy8gZmlsZTIudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDIwMDAgYnl0ZXMgaW4gc2l6ZVxuICAgICAqIC8vIGZpbGUzLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAzMDAwIGJ5dGVzIGluIHNpemVcbiAgICAgKiAvLyBmaWxlNC50eHQgZG9lcyBub3QgZXhpc3RcbiAgICAgKlxuICAgICAqIGNvbnN0IGZpbGVMaXN0ID0gWydmaWxlMS50eHQnLCdmaWxlMi50eHQnLCdmaWxlMy50eHQnXTtcbiAgICAgKiBjb25zdCB3aXRoTWlzc2luZ0ZpbGVMaXN0ID0gWydmaWxlMS50eHQnLCdmaWxlMi50eHQnLCdmaWxlMy50eHQnLCAnZmlsZTQudHh0J107XG4gICAgICpcbiAgICAgKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBjb21wdXRlcyB0aGUgZmlsZSBzaXplIGluIGJ5dGVzXG4gICAgICogLy8gZmlsZSBzaXplIGlzIGFkZGVkIHRvIHRoZSBtZW1vaXplZCB2YWx1ZSwgdGhlbiByZXR1cm5lZFxuICAgICAqIGZ1bmN0aW9uIGdldEZpbGVTaXplSW5CeXRlcyhtZW1vLCBmaWxlLCBjYWxsYmFjaykge1xuICAgICAqICAgICBmcy5zdGF0KGZpbGUsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuICAgICAqICAgICAgICAgaWYgKGVycikge1xuICAgICAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWVtbyArIHN0YXQuc2l6ZSk7XG4gICAgICogICAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICAgICAqIGFzeW5jLnJlZHVjZShmaWxlTGlzdCwgMCwgZ2V0RmlsZVNpemVJbkJ5dGVzLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAqICAgICBpZiAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICB9IGVsc2Uge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgKiAgICAgICAgIC8vIDYwMDBcbiAgICAgKiAgICAgICAgIC8vIHdoaWNoIGlzIHRoZSBzdW0gb2YgdGhlIGZpbGUgc2l6ZXMgb2YgdGhlIHRocmVlIGZpbGVzXG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIEVycm9yIEhhbmRsaW5nXG4gICAgICogYXN5bmMucmVkdWNlKHdpdGhNaXNzaW5nRmlsZUxpc3QsIDAsIGdldEZpbGVTaXplSW5CeXRlcywgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgKiAgICAgaWYgKGVycikge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gICAgICogICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAqICAgICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyBQcm9taXNlc1xuICAgICAqIGFzeW5jLnJlZHVjZShmaWxlTGlzdCwgMCwgZ2V0RmlsZVNpemVJbkJ5dGVzKVxuICAgICAqIC50aGVuKCByZXN1bHQgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAqICAgICAvLyA2MDAwXG4gICAgICogICAgIC8vIHdoaWNoIGlzIHRoZSBzdW0gb2YgdGhlIGZpbGUgc2l6ZXMgb2YgdGhlIHRocmVlIGZpbGVzXG4gICAgICogfSkuY2F0Y2goIGVyciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBFcnJvciBIYW5kbGluZ1xuICAgICAqIGFzeW5jLnJlZHVjZSh3aXRoTWlzc2luZ0ZpbGVMaXN0LCAwLCBnZXRGaWxlU2l6ZUluQnl0ZXMpXG4gICAgICogLnRoZW4oIHJlc3VsdCA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogfSkuY2F0Y2goIGVyciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICAgICAqIGFzeW5jICgpID0+IHtcbiAgICAgKiAgICAgdHJ5IHtcbiAgICAgKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5yZWR1Y2UoZmlsZUxpc3QsIDAsIGdldEZpbGVTaXplSW5CeXRlcyk7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAqICAgICAgICAgLy8gNjAwMFxuICAgICAqICAgICAgICAgLy8gd2hpY2ggaXMgdGhlIHN1bSBvZiB0aGUgZmlsZSBzaXplcyBvZiB0aGUgdGhyZWUgZmlsZXNcbiAgICAgKiAgICAgfVxuICAgICAqICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gRXJyb3IgSGFuZGxpbmdcbiAgICAgKiBhc3luYyAoKSA9PiB7XG4gICAgICogICAgIHRyeSB7XG4gICAgICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMucmVkdWNlKHdpdGhNaXNzaW5nRmlsZUxpc3QsIDAsIGdldEZpbGVTaXplSW5CeXRlcyk7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAqICAgICB9XG4gICAgICogICAgIGNhdGNoIChlcnIpIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGwsIG1lbW8sIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgICAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICAgICAgcmV0dXJuIGVhY2hPZlNlcmllcyQxKGNvbGwsICh4LCBpLCBpdGVyQ2IpID0+IHtcbiAgICAgICAgICAgIF9pdGVyYXRlZShtZW1vLCB4LCAoZXJyLCB2KSA9PiB7XG4gICAgICAgICAgICAgICAgbWVtbyA9IHY7XG4gICAgICAgICAgICAgICAgaXRlckNiKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZXJyID0+IGNhbGxiYWNrKGVyciwgbWVtbykpO1xuICAgIH1cbiAgICB2YXIgcmVkdWNlJDEgPSBhd2FpdGlmeShyZWR1Y2UsIDQpO1xuXG4gICAgLyoqXG4gICAgICogVmVyc2lvbiBvZiB0aGUgY29tcG9zZSBmdW5jdGlvbiB0aGF0IGlzIG1vcmUgbmF0dXJhbCB0byByZWFkLiBFYWNoIGZ1bmN0aW9uXG4gICAgICogY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgZnVuY3Rpb24uIEl0IGlzIHRoZSBlcXVpdmFsZW50IG9mXG4gICAgICogW2NvbXBvc2Vde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jb21wb3NlfSB3aXRoIHRoZSBhcmd1bWVudHMgcmV2ZXJzZWQuXG4gICAgICpcbiAgICAgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBuYW1lIHNlcVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLmNvbXBvc2Vde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jb21wb3NlfVxuICAgICAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAgICAgKiBAcGFyYW0gey4uLkFzeW5jRnVuY3Rpb259IGZ1bmN0aW9ucyAtIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb25zIHRvIGNvbXBvc2VcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBjb21wb3NlcyB0aGUgYGZ1bmN0aW9uc2AgaW4gb3JkZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gUmVxdWlyZXMgbG9kYXNoIChvciB1bmRlcnNjb3JlKSwgZXhwcmVzczMgYW5kIGRyZXNlbmRlJ3Mgb3JtMi5cbiAgICAgKiAvLyBQYXJ0IG9mIGFuIGFwcCwgdGhhdCBmZXRjaGVzIGNhdHMgb2YgdGhlIGxvZ2dlZCB1c2VyLlxuICAgICAqIC8vIFRoaXMgZXhhbXBsZSB1c2VzIGBzZXFgIGZ1bmN0aW9uIHRvIGF2b2lkIG92ZXJuZXN0aW5nIGFuZCBlcnJvclxuICAgICAqIC8vIGhhbmRsaW5nIGNsdXR0ZXIuXG4gICAgICogYXBwLmdldCgnL2NhdHMnLCBmdW5jdGlvbihyZXF1ZXN0LCByZXNwb25zZSkge1xuICAgICAqICAgICB2YXIgVXNlciA9IHJlcXVlc3QubW9kZWxzLlVzZXI7XG4gICAgICogICAgIGFzeW5jLnNlcShcbiAgICAgKiAgICAgICAgIFVzZXIuZ2V0LmJpbmQoVXNlciksICAvLyAnVXNlci5nZXQnIGhhcyBzaWduYXR1cmUgKGlkLCBjYWxsYmFjayhlcnIsIGRhdGEpKVxuICAgICAqICAgICAgICAgZnVuY3Rpb24odXNlciwgZm4pIHtcbiAgICAgKiAgICAgICAgICAgICB1c2VyLmdldENhdHMoZm4pOyAgICAgIC8vICdnZXRDYXRzJyBoYXMgc2lnbmF0dXJlIChjYWxsYmFjayhlcnIsIGRhdGEpKVxuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICApKHJlcS5zZXNzaW9uLnVzZXJfaWQsIGZ1bmN0aW9uIChlcnIsIGNhdHMpIHtcbiAgICAgKiAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICogICAgICAgICAgICAgcmVzcG9uc2UuanNvbih7IHN0YXR1czogJ2Vycm9yJywgbWVzc2FnZTogZXJyLm1lc3NhZ2UgfSk7XG4gICAgICogICAgICAgICB9IGVsc2Uge1xuICAgICAqICAgICAgICAgICAgIHJlc3BvbnNlLmpzb24oeyBzdGF0dXM6ICdvaycsIG1lc3NhZ2U6ICdDYXRzIGZvdW5kJywgZGF0YTogY2F0cyB9KTtcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgfSk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VxKC4uLmZ1bmN0aW9ucykge1xuICAgICAgICB2YXIgX2Z1bmN0aW9ucyA9IGZ1bmN0aW9ucy5tYXAod3JhcEFzeW5jKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBjYiA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiID0gcHJvbWlzZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZHVjZSQxKF9mdW5jdGlvbnMsIGFyZ3MsIChuZXdhcmdzLCBmbiwgaXRlckNiKSA9PiB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgbmV3YXJncy5jb25jYXQoKGVyciwgLi4ubmV4dGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaXRlckNiKGVyciwgbmV4dGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyLCByZXN1bHRzKSA9PiBjYihlcnIsIC4uLnJlc3VsdHMpKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNiW1BST01JU0VfU1lNQk9MXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCBpcyBhIGNvbXBvc2l0aW9uIG9mIHRoZSBwYXNzZWQgYXN5bmNocm9ub3VzXG4gICAgICogZnVuY3Rpb25zLiBFYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiBmb2xsb3dzLiBDb21wb3NpbmcgZnVuY3Rpb25zIGBmKClgLCBgZygpYCwgYW5kIGBoKClgIHdvdWxkIHByb2R1Y2UgdGhlIHJlc3VsdFxuICAgICAqIG9mIGBmKGcoaCgpKSlgLCBvbmx5IHRoaXMgdmVyc2lvbiB1c2VzIGNhbGxiYWNrcyB0byBvYnRhaW4gdGhlIHJldHVybiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgbGFzdCBhcmd1bWVudCB0byB0aGUgY29tcG9zZWQgZnVuY3Rpb24gaXMgbm90IGEgZnVuY3Rpb24sIGEgcHJvbWlzZVxuICAgICAqIGlzIHJldHVybmVkIHdoZW4geW91IGNhbGwgaXQuXG4gICAgICpcbiAgICAgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbXBvc2VcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gICAgICogQHBhcmFtIHsuLi5Bc3luY0Z1bmN0aW9ufSBmdW5jdGlvbnMgLSB0aGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9ucyB0byBjb21wb3NlXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zZWRcbiAgICAgKiBhc3luY2hyb25vdXMgYGZ1bmN0aW9uc2BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gYWRkMShuLCBjYWxsYmFjaykge1xuICAgICAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIG4gKyAxKTtcbiAgICAgKiAgICAgfSwgMTApO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIG11bDMobiwgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICogICAgICAgICBjYWxsYmFjayhudWxsLCBuICogMyk7XG4gICAgICogICAgIH0sIDEwKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkMW11bDMgPSBhc3luYy5jb21wb3NlKG11bDMsIGFkZDEpO1xuICAgICAqIGFkZDFtdWwzKDQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAxNVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2UoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gc2VxKC4uLmFyZ3MucmV2ZXJzZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICAgICAqXG4gICAgICogQG5hbWUgbWFwTGltaXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICAgICAqIGBjb2xsYC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uXG4gICAgICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAgICAgKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5IG9mIHRoZVxuICAgICAqIHRyYW5zZm9ybWVkIGl0ZW1zIGZyb20gdGhlIGBjb2xsYC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcExpbWl0IChjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfYXN5bmNNYXAoZWFjaE9mTGltaXQobGltaXQpLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG4gICAgfVxuICAgIHZhciBtYXBMaW1pdCQxID0gYXdhaXRpZnkobWFwTGltaXQsIDQpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMgW2Bjb25jYXRgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbmNhdExpbWl0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMuY29uY2F0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQGFsaWFzIGZsYXRNYXBMaW1pdFxuICAgICAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLFxuICAgICAqIHdoaWNoIHNob3VsZCB1c2UgYW4gYXJyYXkgYXMgaXRzIHJlc3VsdC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAgICAgKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXlcbiAgICAgKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoXG4gICAgICogKGVyciwgcmVzdWx0cykuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25jYXRMaW1pdChjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgICAgICByZXR1cm4gbWFwTGltaXQkMShjb2xsLCBsaW1pdCwgKHZhbCwgaXRlckNiKSA9PiB7XG4gICAgICAgICAgICBfaXRlcmF0ZWUodmFsLCAoZXJyLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGl0ZXJDYihlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyQ2IoZXJyLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAoZXJyLCBtYXBSZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcFJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobWFwUmVzdWx0c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KC4uLm1hcFJlc3VsdHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBjb25jYXRMaW1pdCQxID0gYXdhaXRpZnkoY29uY2F0TGltaXQsIDQpO1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbiBgY29sbGAsIGNvbmNhdGVuYXRpbmcgdGhlIHJlc3VsdHMuIFJldHVybnNcbiAgICAgKiB0aGUgY29uY2F0ZW5hdGVkIGxpc3QuIFRoZSBgaXRlcmF0ZWVgcyBhcmUgY2FsbGVkIGluIHBhcmFsbGVsLCBhbmQgdGhlXG4gICAgICogcmVzdWx0cyBhcmUgY29uY2F0ZW5hdGVkIGFzIHRoZXkgcmV0dXJuLiBUaGUgcmVzdWx0cyBhcnJheSB3aWxsIGJlIHJldHVybmVkIGluXG4gICAgICogdGhlIG9yaWdpbmFsIG9yZGVyIG9mIGBjb2xsYCBwYXNzZWQgdG8gdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbmFtZSBjb25jYXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBhbGlhcyBmbGF0TWFwXG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCxcbiAgICAgKiB3aGljaCBzaG91bGQgdXNlIGFuIGFycmF5IGFzIGl0cyByZXN1bHQuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gICAgICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5XG4gICAgICogY29udGFpbmluZyB0aGUgY29uY2F0ZW5hdGVkIHJlc3VsdHMgb2YgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uIEludm9rZWQgd2l0aFxuICAgICAqIChlcnIsIHJlc3VsdHMpLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGRpcjEgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMS50eHQsIGZpbGUyLnR4dFxuICAgICAqIC8vIGRpcjIgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMy50eHQsIGZpbGU0LnR4dFxuICAgICAqIC8vIGRpcjMgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlNS50eHRcbiAgICAgKiAvLyBkaXI0IGRvZXMgbm90IGV4aXN0XG4gICAgICpcbiAgICAgKiBsZXQgZGlyZWN0b3J5TGlzdCA9IFsnZGlyMScsJ2RpcjInLCdkaXIzJ107XG4gICAgICogbGV0IHdpdGhNaXNzaW5nRGlyZWN0b3J5TGlzdCA9IFsnZGlyMScsJ2RpcjInLCdkaXIzJywgJ2RpcjQnXTtcbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICAgICAqIGFzeW5jLmNvbmNhdChkaXJlY3RvcnlMaXN0LCBmcy5yZWFkZGlyLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICAgKiAgICBpZiAoZXJyKSB7XG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gICAgICogICAgICAgIC8vIFsgJ2ZpbGUxLnR4dCcsICdmaWxlMi50eHQnLCAnZmlsZTMudHh0JywgJ2ZpbGU0LnR4dCcsIGZpbGU1LnR4dCBdXG4gICAgICogICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gRXJyb3IgSGFuZGxpbmdcbiAgICAgKiBhc3luYy5jb25jYXQod2l0aE1pc3NpbmdEaXJlY3RvcnlMaXN0LCBmcy5yZWFkZGlyLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICAgKiAgICBpZiAoZXJyKSB7XG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gICAgICogICAgICAgIC8vIHNpbmNlIGRpcjQgZG9lcyBub3QgZXhpc3RcbiAgICAgKiAgICB9IGVsc2Uge1xuICAgICAqICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyBQcm9taXNlc1xuICAgICAqIGFzeW5jLmNvbmNhdChkaXJlY3RvcnlMaXN0LCBmcy5yZWFkZGlyKVxuICAgICAqIC50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgLy8gWyAnZmlsZTEudHh0JywgJ2ZpbGUyLnR4dCcsICdmaWxlMy50eHQnLCAnZmlsZTQudHh0JywgZmlsZTUudHh0IF1cbiAgICAgKiB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAqICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIEVycm9yIEhhbmRsaW5nXG4gICAgICogYXN5bmMuY29uY2F0KHdpdGhNaXNzaW5nRGlyZWN0b3J5TGlzdCwgZnMucmVhZGRpcilcbiAgICAgKiAudGhlbihyZXN1bHRzID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gICAgICogfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAgICAgKiAgICAgLy8gc2luY2UgZGlyNCBkb2VzIG5vdCBleGlzdFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAgICAgKiBhc3luYyAoKSA9PiB7XG4gICAgICogICAgIHRyeSB7XG4gICAgICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLmNvbmNhdChkaXJlY3RvcnlMaXN0LCBmcy5yZWFkZGlyKTtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAgICAqICAgICAgICAgLy8gWyAnZmlsZTEudHh0JywgJ2ZpbGUyLnR4dCcsICdmaWxlMy50eHQnLCAnZmlsZTQudHh0JywgZmlsZTUudHh0IF1cbiAgICAgKiAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gRXJyb3IgSGFuZGxpbmdcbiAgICAgKiBhc3luYyAoKSA9PiB7XG4gICAgICogICAgIHRyeSB7XG4gICAgICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLmNvbmNhdCh3aXRoTWlzc2luZ0RpcmVjdG9yeUxpc3QsIGZzLnJlYWRkaXIpO1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gICAgICogICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gICAgICogICAgICAgICAvLyBzaW5jZSBkaXI0IGRvZXMgbm90IGV4aXN0XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25jYXQoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjb25jYXRMaW1pdCQxKGNvbGwsIEluZmluaXR5LCBpdGVyYXRlZSwgY2FsbGJhY2spXG4gICAgfVxuICAgIHZhciBjb25jYXQkMSA9IGF3YWl0aWZ5KGNvbmNhdCwgMyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBhcyBbYGNvbmNhdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbmNhdFNlcmllc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLmNvbmNhdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmNvbmNhdH1cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBhbGlhcyBmbGF0TWFwU2VyaWVzXG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYW4gYXJyYXkgYW4gYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICAgICAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheVxuICAgICAqIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCByZXN1bHRzIG9mIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBJbnZva2VkIHdpdGhcbiAgICAgKiAoZXJyLCByZXN1bHRzKS5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmNhdFNlcmllcyhjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdExpbWl0JDEoY29sbCwgMSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxuICAgIH1cbiAgICB2YXIgY29uY2F0U2VyaWVzJDEgPSBhd2FpdGlmeShjb25jYXRTZXJpZXMsIDMpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2hlbiBjYWxsZWQsIGNhbGxzLWJhY2sgd2l0aCB0aGUgdmFsdWVzIHByb3ZpZGVkLlxuICAgICAqIFVzZWZ1bCBhcyB0aGUgZmlyc3QgZnVuY3Rpb24gaW4gYSBbYHdhdGVyZmFsbGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53YXRlcmZhbGx9LCBvciBmb3IgcGx1Z2dpbmcgdmFsdWVzIGluIHRvXG4gICAgICogW2BhdXRvYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99LlxuICAgICAqXG4gICAgICogQG5hbWUgY29uc3RhbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzLi4uIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYXV0b21hdGljYWxseSBpbnZva2VcbiAgICAgKiBjYWxsYmFjayB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aGVuIGludm9rZWQsIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBpbnZva2VzIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBwcmV2aW91cyBnaXZlbiBhcmd1bWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGFzeW5jLndhdGVyZmFsbChbXG4gICAgICogICAgIGFzeW5jLmNvbnN0YW50KDQyKSxcbiAgICAgKiAgICAgZnVuY3Rpb24gKHZhbHVlLCBuZXh0KSB7XG4gICAgICogICAgICAgICAvLyB2YWx1ZSA9PT0gNDJcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgLy8uLi5cbiAgICAgKiBdLCBjYWxsYmFjayk7XG4gICAgICpcbiAgICAgKiBhc3luYy53YXRlcmZhbGwoW1xuICAgICAqICAgICBhc3luYy5jb25zdGFudChmaWxlbmFtZSwgXCJ1dGY4XCIpLFxuICAgICAqICAgICBmcy5yZWFkRmlsZSxcbiAgICAgKiAgICAgZnVuY3Rpb24gKGZpbGVEYXRhLCBuZXh0KSB7XG4gICAgICogICAgICAgICAvLy4uLlxuICAgICAqICAgICB9XG4gICAgICogICAgIC8vLi4uXG4gICAgICogXSwgY2FsbGJhY2spO1xuICAgICAqXG4gICAgICogYXN5bmMuYXV0byh7XG4gICAgICogICAgIGhvc3RuYW1lOiBhc3luYy5jb25zdGFudChcImh0dHBzOi8vc2VydmVyLm5ldC9cIiksXG4gICAgICogICAgIHBvcnQ6IGZpbmRGcmVlUG9ydCxcbiAgICAgKiAgICAgbGF1bmNoU2VydmVyOiBbXCJob3N0bmFtZVwiLCBcInBvcnRcIiwgZnVuY3Rpb24gKG9wdGlvbnMsIGNiKSB7XG4gICAgICogICAgICAgICBzdGFydFNlcnZlcihvcHRpb25zLCBjYik7XG4gICAgICogICAgIH1dLFxuICAgICAqICAgICAvLy4uLlxuICAgICAqIH0sIGNhbGxiYWNrKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uaWdub3JlZEFyZ3MvKiwgY2FsbGJhY2sqLykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gaWdub3JlZEFyZ3MucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZVRlc3RlcihjaGVjaywgZ2V0UmVzdWx0KSB7XG4gICAgICAgIHJldHVybiAoZWFjaGZuLCBhcnIsIF9pdGVyYXRlZSwgY2IpID0+IHtcbiAgICAgICAgICAgIHZhciB0ZXN0UGFzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdGVzdFJlc3VsdDtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdGVlID0gd3JhcEFzeW5jKF9pdGVyYXRlZSk7XG4gICAgICAgICAgICBlYWNoZm4oYXJyLCAodmFsdWUsIF8sIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZWUodmFsdWUsIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIHx8IGVyciA9PT0gZmFsc2UpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVjayhyZXN1bHQpICYmICF0ZXN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXN0UGFzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RSZXN1bHQgPSBnZXRSZXN1bHQodHJ1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGJyZWFrTG9vcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgY2IobnVsbCwgdGVzdFBhc3NlZCA/IHRlc3RSZXN1bHQgOiBnZXRSZXN1bHQoZmFsc2UpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGluIGBjb2xsYCB0aGF0IHBhc3NlcyBhbiBhc3luYyB0cnV0aCB0ZXN0LiBUaGVcbiAgICAgKiBgaXRlcmF0ZWVgIGlzIGFwcGxpZWQgaW4gcGFyYWxsZWwsIG1lYW5pbmcgdGhlIGZpcnN0IGl0ZXJhdGVlIHRvIHJldHVyblxuICAgICAqIGB0cnVlYCB3aWxsIGZpcmUgdGhlIGRldGVjdCBgY2FsbGJhY2tgIHdpdGggdGhhdCByZXN1bHQuIFRoYXQgbWVhbnMgdGhlXG4gICAgICogcmVzdWx0IG1pZ2h0IG5vdCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgb3JpZ2luYWwgYGNvbGxgIChpbiB0ZXJtcyBvZiBvcmRlcilcbiAgICAgKiB0aGF0IHBhc3NlcyB0aGUgdGVzdC5cblxuICAgICAqIElmIG9yZGVyIHdpdGhpbiB0aGUgb3JpZ2luYWwgYGNvbGxgIGlzIGltcG9ydGFudCwgdGhlbiBsb29rIGF0XG4gICAgICogW2BkZXRlY3RTZXJpZXNgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0U2VyaWVzfS5cbiAgICAgKlxuICAgICAqIEBuYW1lIGRldGVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBhbGlhcyBmaW5kXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICAgICAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gICAgICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gICAgICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAgICAgKiBSZXN1bHQgd2lsbCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgdGhhdCBwYXNzZXMgdGhlIHRydXRoIHRlc3RcbiAgICAgKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoXG4gICAgICogKGVyciwgcmVzdWx0KS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gZGlyMSBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUxLnR4dCwgZmlsZTIudHh0XG4gICAgICogLy8gZGlyMiBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUzLnR4dCwgZmlsZTQudHh0XG4gICAgICogLy8gZGlyMyBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGU1LnR4dFxuICAgICAqXG4gICAgICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGEgZmlsZSBleGlzdHNcbiAgICAgKiBmdW5jdGlvbiBmaWxlRXhpc3RzKGZpbGUsIGNhbGxiYWNrKSB7XG4gICAgICogICAgZnMuYWNjZXNzKGZpbGUsIGZzLmNvbnN0YW50cy5GX09LLCAoZXJyKSA9PiB7XG4gICAgICogICAgICAgIGNhbGxiYWNrKG51bGwsICFlcnIpO1xuICAgICAqICAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGFzeW5jLmRldGVjdChbJ2ZpbGUzLnR4dCcsJ2ZpbGUyLnR4dCcsJ2RpcjEvZmlsZTEudHh0J10sIGZpbGVFeGlzdHMsXG4gICAgICogICAgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgKiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgKiAgICAgICAgLy8gZGlyMS9maWxlMS50eHRcbiAgICAgKiAgICAgICAgLy8gcmVzdWx0IG5vdyBlcXVhbHMgdGhlIGZpcnN0IGZpbGUgaW4gdGhlIGxpc3QgdGhhdCBleGlzdHNcbiAgICAgKiAgICB9XG4gICAgICopO1xuICAgICAqXG4gICAgICogLy8gVXNpbmcgUHJvbWlzZXNcbiAgICAgKiBhc3luYy5kZXRlY3QoWydmaWxlMy50eHQnLCdmaWxlMi50eHQnLCdkaXIxL2ZpbGUxLnR4dCddLCBmaWxlRXhpc3RzKVxuICAgICAqIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogICAgIC8vIGRpcjEvZmlsZTEudHh0XG4gICAgICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzIHRoZSBmaXJzdCBmaWxlIGluIHRoZSBsaXN0IHRoYXQgZXhpc3RzXG4gICAgICogfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gICAgICogYXN5bmMgKCkgPT4ge1xuICAgICAqICAgICB0cnkge1xuICAgICAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLmRldGVjdChbJ2ZpbGUzLnR4dCcsJ2ZpbGUyLnR4dCcsJ2RpcjEvZmlsZTEudHh0J10sIGZpbGVFeGlzdHMpO1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgKiAgICAgICAgIC8vIGRpcjEvZmlsZTEudHh0XG4gICAgICogICAgICAgICAvLyByZXN1bHQgbm93IGVxdWFscyB0aGUgZmlsZSBpbiB0aGUgbGlzdCB0aGF0IGV4aXN0c1xuICAgICAqICAgICB9XG4gICAgICogICAgIGNhdGNoIChlcnIpIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZXRlY3QoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfY3JlYXRlVGVzdGVyKGJvb2wgPT4gYm9vbCwgKHJlcywgaXRlbSkgPT4gaXRlbSkoZWFjaE9mJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbiAgICB9XG4gICAgdmFyIGRldGVjdCQxID0gYXdhaXRpZnkoZGV0ZWN0LCAzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFtgZGV0ZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gICAgICogdGltZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIGRldGVjdExpbWl0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMuZGV0ZWN0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fVxuICAgICAqIEBhbGlhcyBmaW5kTGltaXRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICAgICAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gICAgICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gICAgICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAgICAgKiBSZXN1bHQgd2lsbCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgdGhhdCBwYXNzZXMgdGhlIHRydXRoIHRlc3RcbiAgICAgKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoXG4gICAgICogKGVyciwgcmVzdWx0KS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZXRlY3RMaW1pdChjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfY3JlYXRlVGVzdGVyKGJvb2wgPT4gYm9vbCwgKHJlcywgaXRlbSkgPT4gaXRlbSkoZWFjaE9mTGltaXQobGltaXQpLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG4gICAgfVxuICAgIHZhciBkZXRlY3RMaW1pdCQxID0gYXdhaXRpZnkoZGV0ZWN0TGltaXQsIDQpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMgW2BkZXRlY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBkZXRlY3RTZXJpZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAc2VlIFthc3luYy5kZXRlY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9XG4gICAgICogQGFsaWFzIGZpbmRTZXJpZXNcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gICAgICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAgICAgKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAgICAgKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICAgICAqIFJlc3VsdCB3aWxsIGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBhcnJheSB0aGF0IHBhc3NlcyB0aGUgdHJ1dGggdGVzdFxuICAgICAqIChpdGVyYXRlZSkgb3IgdGhlIHZhbHVlIGB1bmRlZmluZWRgIGlmIG5vbmUgcGFzc2VkLiBJbnZva2VkIHdpdGhcbiAgICAgKiAoZXJyLCByZXN1bHQpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRldGVjdFNlcmllcyhjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVUZXN0ZXIoYm9vbCA9PiBib29sLCAocmVzLCBpdGVtKSA9PiBpdGVtKShlYWNoT2ZMaW1pdCgxKSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxuICAgIH1cblxuICAgIHZhciBkZXRlY3RTZXJpZXMkMSA9IGF3YWl0aWZ5KGRldGVjdFNlcmllcywgMyk7XG5cbiAgICBmdW5jdGlvbiBjb25zb2xlRnVuYyhuYW1lKSB7XG4gICAgICAgIHJldHVybiAoZm4sIC4uLmFyZ3MpID0+IHdyYXBBc3luYyhmbikoLi4uYXJncywgKGVyciwgLi4ucmVzdWx0QXJncykgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVtuYW1lXSkgeyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRBcmdzLmZvckVhY2goeCA9PiBjb25zb2xlW25hbWVdKHgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyB0aGUgcmVzdWx0IG9mIGFuIFtgYXN5bmNgIGZ1bmN0aW9uXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byB0aGVcbiAgICAgKiBgY29uc29sZWAgdXNpbmcgYGNvbnNvbGUuZGlyYCB0byBkaXNwbGF5IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSByZXN1bHRpbmcgb2JqZWN0LlxuICAgICAqIE9ubHkgd29ya3MgaW4gTm9kZS5qcyBvciBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgYGNvbnNvbGUuZGlyYCBhbmRcbiAgICAgKiBgY29uc29sZS5lcnJvcmAgKHN1Y2ggYXMgRkYgYW5kIENocm9tZSkuXG4gICAgICogSWYgbXVsdGlwbGUgYXJndW1lbnRzIGFyZSByZXR1cm5lZCBmcm9tIHRoZSBhc3luYyBmdW5jdGlvbixcbiAgICAgKiBgY29uc29sZS5kaXJgIGlzIGNhbGxlZCBvbiBlYWNoIGFyZ3VtZW50IGluIG9yZGVyLlxuICAgICAqXG4gICAgICogQG5hbWUgZGlyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZ1bmN0aW9uIC0gVGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGV2ZW50dWFsbHkgYXBwbHlcbiAgICAgKiBhbGwgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzLi4uIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBpbiBhIG1vZHVsZVxuICAgICAqIHZhciBoZWxsbyA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICBjYWxsYmFjayhudWxsLCB7aGVsbG86IG5hbWV9KTtcbiAgICAgKiAgICAgfSwgMTAwMCk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIGluIHRoZSBub2RlIHJlcGxcbiAgICAgKiBub2RlPiBhc3luYy5kaXIoaGVsbG8sICd3b3JsZCcpO1xuICAgICAqIHtoZWxsbzogJ3dvcmxkJ31cbiAgICAgKi9cbiAgICB2YXIgZGlyID0gY29uc29sZUZ1bmMoJ2RpcicpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBvc3QtY2hlY2sgdmVyc2lvbiBvZiBbYHdoaWxzdGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9LiBUbyByZWZsZWN0IHRoZSBkaWZmZXJlbmNlIGluXG4gICAgICogdGhlIG9yZGVyIG9mIG9wZXJhdGlvbnMsIHRoZSBhcmd1bWVudHMgYHRlc3RgIGFuZCBgaXRlcmF0ZWVgIGFyZSBzd2l0Y2hlZC5cbiAgICAgKlxuICAgICAqIGBkb1doaWxzdGAgaXMgdG8gYHdoaWxzdGAgYXMgYGRvIHdoaWxlYCBpcyB0byBgd2hpbGVgIGluIHBsYWluIEphdmFTY3JpcHQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBkb1doaWxzdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLndoaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH1cbiAgICAgKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZSBgdGVzdGBcbiAgICAgKiBwYXNzZXMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGVzdCAtIGFzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYWZ0ZXIgZWFjaFxuICAgICAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKC4uLmFyZ3MsIGNhbGxiYWNrKSwgd2hlcmUgYC4uLmFyZ3NgIGFyZSB0aGVcbiAgICAgKiBub24tZXJyb3IgYXJncyBmcm9tIHRoZSBwcmV2aW91cyBjYWxsYmFjayBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdFxuICAgICAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLlxuICAgICAqIGBjYWxsYmFja2Agd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbFxuICAgICAqIGBpdGVyYXRlZWAncyBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSk7XG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9XaGlsc3QoaXRlcmF0ZWUsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb25seU9uY2UoY2FsbGJhY2spO1xuICAgICAgICB2YXIgX2ZuID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICAgICAgdmFyIF90ZXN0ID0gd3JhcEFzeW5jKHRlc3QpO1xuICAgICAgICB2YXIgcmVzdWx0cztcblxuICAgICAgICBmdW5jdGlvbiBuZXh0KGVyciwgLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICAgICAgcmVzdWx0cyA9IGFyZ3M7XG4gICAgICAgICAgICBfdGVzdCguLi5hcmdzLCBjaGVjayk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGVjayhlcnIsIHRydXRoKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIGlmIChlcnIgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXRydXRoKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgLi4ucmVzdWx0cyk7XG4gICAgICAgICAgICBfZm4obmV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hlY2sobnVsbCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIGRvV2hpbHN0JDEgPSBhd2FpdGlmeShkb1doaWxzdCwgMyk7XG5cbiAgICAvKipcbiAgICAgKiBMaWtlIFsnZG9XaGlsc3QnXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuZG9XaGlsc3R9LCBleGNlcHQgdGhlIGB0ZXN0YCBpcyBpbnZlcnRlZC4gTm90ZSB0aGVcbiAgICAgKiBhcmd1bWVudCBvcmRlcmluZyBkaWZmZXJzIGZyb20gYHVudGlsYC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGRvVW50aWxcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAc2VlIFthc3luYy5kb1doaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fVxuICAgICAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZVxuICAgICAqIGB0ZXN0YCBmYWlscy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0ZXN0IC0gYXN5bmNocm9ub3VzIHRydXRoIHRlc3QgdG8gcGVyZm9ybSBhZnRlciBlYWNoXG4gICAgICogZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAuIEludm9rZWQgd2l0aCAoLi4uYXJncywgY2FsbGJhY2spLCB3aGVyZSBgLi4uYXJnc2AgYXJlIHRoZVxuICAgICAqIG5vbi1lcnJvciBhcmdzIGZyb20gdGhlIHByZXZpb3VzIGNhbGxiYWNrIG9mIGBpdGVyYXRlZWBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3RcbiAgICAgKiBmdW5jdGlvbiBoYXMgcGFzc2VkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICAgICAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzXG4gICAgICogY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pO1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvVW50aWwoaXRlcmF0ZWUsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IF90ZXN0ID0gd3JhcEFzeW5jKHRlc3QpO1xuICAgICAgICByZXR1cm4gZG9XaGlsc3QkMShpdGVyYXRlZSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNiID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIF90ZXN0KC4uLmFyZ3MsIChlcnIsIHRydXRoKSA9PiBjYiAoZXJyLCAhdHJ1dGgpKTtcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF93aXRob3V0SW5kZXgoaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSwgaW5kZXgsIGNhbGxiYWNrKSA9PiBpdGVyYXRlZSh2YWx1ZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGZ1bmN0aW9uIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCwgaW4gcGFyYWxsZWwuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGggYW4gaXRlbSBmcm9tIHRoZSBsaXN0LCBhbmQgYSBjYWxsYmFjayBmb3Igd2hlblxuICAgICAqIGl0IGhhcyBmaW5pc2hlZC4gSWYgdGhlIGBpdGVyYXRlZWAgcGFzc2VzIGFuIGVycm9yIHRvIGl0cyBgY2FsbGJhY2tgLCB0aGVcbiAgICAgKiBtYWluIGBjYWxsYmFja2AgKGZvciB0aGUgYGVhY2hgIGZ1bmN0aW9uKSBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGVcbiAgICAgKiBlcnJvci5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoYXQgc2luY2UgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIHBhcmFsbGVsLFxuICAgICAqIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZSBpbiBvcmRlci5cbiAgICAgKlxuICAgICAqIEBuYW1lIGVhY2hcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAYWxpYXMgZm9yRWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvXG4gICAgICogZWFjaCBpdGVtIGluIGBjb2xsYC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gICAgICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLlxuICAgICAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICAgICAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBkaXIxIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTEudHh0LCBmaWxlMi50eHRcbiAgICAgKiAvLyBkaXIyIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTMudHh0LCBmaWxlNC50eHRcbiAgICAgKiAvLyBkaXIzIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTUudHh0XG4gICAgICogLy8gZGlyNCBkb2VzIG5vdCBleGlzdFxuICAgICAqXG4gICAgICogY29uc3QgZmlsZUxpc3QgPSBbICdkaXIxL2ZpbGUyLnR4dCcsICdkaXIyL2ZpbGUzLnR4dCcsICdkaXIvZmlsZTUudHh0J107XG4gICAgICogY29uc3Qgd2l0aE1pc3NpbmdGaWxlTGlzdCA9IFsnZGlyMS9maWxlMS50eHQnLCAnZGlyNC9maWxlMi50eHQnXTtcbiAgICAgKlxuICAgICAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IGRlbGV0ZXMgYSBmaWxlXG4gICAgICogY29uc3QgZGVsZXRlRmlsZSA9IGZ1bmN0aW9uKGZpbGUsIGNhbGxiYWNrKSB7XG4gICAgICogICAgIGZzLnVubGluayhmaWxlLCBjYWxsYmFjayk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICAgICAqIGFzeW5jLmVhY2goZmlsZUxpc3QsIGRlbGV0ZUZpbGUsIGZ1bmN0aW9uKGVycikge1xuICAgICAqICAgICBpZiggZXJyICkge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsZXMgaGF2ZSBiZWVuIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIEVycm9yIEhhbmRsaW5nXG4gICAgICogYXN5bmMuZWFjaCh3aXRoTWlzc2luZ0ZpbGVMaXN0LCBkZWxldGVGaWxlLCBmdW5jdGlvbihlcnIpe1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICAgICAqICAgICAvLyBzaW5jZSBkaXI0L2ZpbGUyLnR4dCBkb2VzIG5vdCBleGlzdFxuICAgICAqICAgICAvLyBkaXIxL2ZpbGUxLnR4dCBjb3VsZCBoYXZlIGJlZW4gZGVsZXRlZFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gVXNpbmcgUHJvbWlzZXNcbiAgICAgKiBhc3luYy5lYWNoKGZpbGVMaXN0LCBkZWxldGVGaWxlKVxuICAgICAqIC50aGVuKCAoKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsZXMgaGF2ZSBiZWVuIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICogfSkuY2F0Y2goIGVyciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBFcnJvciBIYW5kbGluZ1xuICAgICAqIGFzeW5jLmVhY2goZmlsZUxpc3QsIGRlbGV0ZUZpbGUpXG4gICAgICogLnRoZW4oICgpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ0FsbCBmaWxlcyBoYXZlIGJlZW4gZGVsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgKiB9KS5jYXRjaCggZXJyID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAgICAgKiAgICAgLy8gc2luY2UgZGlyNC9maWxlMi50eHQgZG9lcyBub3QgZXhpc3RcbiAgICAgKiAgICAgLy8gZGlyMS9maWxlMS50eHQgY291bGQgaGF2ZSBiZWVuIGRlbGV0ZWRcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gICAgICogYXN5bmMgKCkgPT4ge1xuICAgICAqICAgICB0cnkge1xuICAgICAqICAgICAgICAgYXdhaXQgYXN5bmMuZWFjaChmaWxlcywgZGVsZXRlRmlsZSk7XG4gICAgICogICAgIH1cbiAgICAgKiAgICAgY2F0Y2ggKGVycikge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIEVycm9yIEhhbmRsaW5nXG4gICAgICogYXN5bmMgKCkgPT4ge1xuICAgICAqICAgICB0cnkge1xuICAgICAqICAgICAgICAgYXdhaXQgYXN5bmMuZWFjaCh3aXRoTWlzc2luZ0ZpbGVMaXN0LCBkZWxldGVGaWxlKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAgICAgKiAgICAgICAgIC8vIHNpbmNlIGRpcjQvZmlsZTIudHh0IGRvZXMgbm90IGV4aXN0XG4gICAgICogICAgICAgICAvLyBkaXIxL2ZpbGUxLnR4dCBjb3VsZCBoYXZlIGJlZW4gZGVsZXRlZFxuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gZWFjaExpbWl0KGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZWFjaE9mJDEoY29sbCwgX3dpdGhvdXRJbmRleCh3cmFwQXN5bmMoaXRlcmF0ZWUpKSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHZhciBlYWNoID0gYXdhaXRpZnkoZWFjaExpbWl0LCAzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIGVhY2hMaW1pdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLmVhY2hde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofVxuICAgICAqIEBhbGlhcyBmb3JFYWNoTGltaXRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gICAgICogYGNvbGxgLlxuICAgICAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS5cbiAgICAgKiBJZiB5b3UgbmVlZCB0aGUgaW5kZXgsIHVzZSBgZWFjaE9mTGltaXRgLlxuICAgICAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICAgICAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVhY2hMaW1pdCQxKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGVhY2hPZkxpbWl0KGxpbWl0KShjb2xsLCBfd2l0aG91dEluZGV4KHdyYXBBc3luYyhpdGVyYXRlZSkpLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHZhciBlYWNoTGltaXQkMiA9IGF3YWl0aWZ5KGVhY2hMaW1pdCQxLCA0KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gICAgICpcbiAgICAgKiBOb3RlLCB0aGF0IHVubGlrZSBbYGVhY2hgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0sIHRoaXMgZnVuY3Rpb24gYXBwbGllcyBpdGVyYXRlZSB0byBlYWNoIGl0ZW1cbiAgICAgKiBpbiBzZXJpZXMgYW5kIHRoZXJlZm9yZSB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIHdpbGwgY29tcGxldGUgaW4gb3JkZXIuXG5cbiAgICAgKiBAbmFtZSBlYWNoU2VyaWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMuZWFjaF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9XG4gICAgICogQGFsaWFzIGZvckVhY2hTZXJpZXNcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gICAgICogaXRlbSBpbiBgY29sbGAuXG4gICAgICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLlxuICAgICAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZTZXJpZXNgLlxuICAgICAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICAgICAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVhY2hTZXJpZXMoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBlYWNoTGltaXQkMihjb2xsLCAxLCBpdGVyYXRlZSwgY2FsbGJhY2spXG4gICAgfVxuICAgIHZhciBlYWNoU2VyaWVzJDEgPSBhd2FpdGlmeShlYWNoU2VyaWVzLCAzKTtcblxuICAgIC8qKlxuICAgICAqIFdyYXAgYW4gYXN5bmMgZnVuY3Rpb24gYW5kIGVuc3VyZSBpdCBjYWxscyBpdHMgY2FsbGJhY2sgb24gYSBsYXRlciB0aWNrIG9mXG4gICAgICogdGhlIGV2ZW50IGxvb3AuICBJZiB0aGUgZnVuY3Rpb24gYWxyZWFkeSBjYWxscyBpdHMgY2FsbGJhY2sgb24gYSBuZXh0IHRpY2ssXG4gICAgICogbm8gZXh0cmEgZGVmZXJyYWwgaXMgYWRkZWQuIFRoaXMgaXMgdXNlZnVsIGZvciBwcmV2ZW50aW5nIHN0YWNrIG92ZXJmbG93c1xuICAgICAqIChgUmFuZ2VFcnJvcjogTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRgKSBhbmQgZ2VuZXJhbGx5IGtlZXBpbmdcbiAgICAgKiBbWmFsZ29dKGh0dHA6Ly9ibG9nLml6cy5tZS9wb3N0LzU5MTQyNzQyMTQzL2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KVxuICAgICAqIGNvbnRhaW5lZC4gRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25zIGFyZSByZXR1cm5lZCBhcy1pcyAtLSB0aGV5IGFyZSBpbW11bmVcbiAgICAgKiB0byBaYWxnbydzIGNvcnJ1cHRpbmcgaW5mbHVlbmNlcywgYXMgdGhleSBhbHdheXMgcmVzb2x2ZSBvbiBhIGxhdGVyIHRpY2suXG4gICAgICpcbiAgICAgKiBAbmFtZSBlbnN1cmVBc3luY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIGFuIGFzeW5jIGZ1bmN0aW9uLCBvbmUgdGhhdCBleHBlY3RzIGEgbm9kZS1zdHlsZVxuICAgICAqIGNhbGxiYWNrIGFzIGl0cyBsYXN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBSZXR1cm5zIGEgd3JhcHBlZCBmdW5jdGlvbiB3aXRoIHRoZSBleGFjdCBzYW1lIGNhbGxcbiAgICAgKiBzaWduYXR1cmUgYXMgdGhlIGZ1bmN0aW9uIHBhc3NlZCBpbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc29tZXRpbWVzQXN5bmMoYXJnLCBjYWxsYmFjaykge1xuICAgICAqICAgICBpZiAoY2FjaGVbYXJnXSkge1xuICAgICAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNhY2hlW2FyZ10pOyAvLyB0aGlzIHdvdWxkIGJlIHN5bmNocm9ub3VzISFcbiAgICAgKiAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICAgIGRvU29tZUlPKGFyZywgY2FsbGJhY2spOyAvLyB0aGlzIElPIHdvdWxkIGJlIGFzeW5jaHJvbm91c1xuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gdGhpcyBoYXMgYSByaXNrIG9mIHN0YWNrIG92ZXJmbG93cyBpZiBtYW55IHJlc3VsdHMgYXJlIGNhY2hlZCBpbiBhIHJvd1xuICAgICAqIGFzeW5jLm1hcFNlcmllcyhhcmdzLCBzb21ldGltZXNBc3luYywgZG9uZSk7XG4gICAgICpcbiAgICAgKiAvLyB0aGlzIHdpbGwgZGVmZXIgc29tZXRpbWVzQXN5bmMncyBjYWxsYmFjayBpZiBuZWNlc3NhcnksXG4gICAgICogLy8gcHJldmVudGluZyBzdGFjayBvdmVyZmxvd3NcbiAgICAgKiBhc3luYy5tYXBTZXJpZXMoYXJncywgYXN5bmMuZW5zdXJlQXN5bmMoc29tZXRpbWVzQXN5bmMpLCBkb25lKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbnN1cmVBc3luYyhmbikge1xuICAgICAgICBpZiAoaXNBc3luYyhmbikpIHJldHVybiBmbjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzLyosIGNhbGxiYWNrKi8pIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB2YXIgc3luYyA9IHRydWU7XG4gICAgICAgICAgICBhcmdzLnB1c2goKC4uLmlubmVyQXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKCgpID0+IGNhbGxiYWNrKC4uLmlubmVyQXJncykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKC4uLmlubmVyQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHN5bmMgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBldmVyeSBlbGVtZW50IGluIGBjb2xsYCBzYXRpc2ZpZXMgYW4gYXN5bmMgdGVzdC4gSWYgYW55XG4gICAgICogaXRlcmF0ZWUgY2FsbCByZXR1cm5zIGBmYWxzZWAsIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICAgICAqXG4gICAgICogQG5hbWUgZXZlcnlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAYWxpYXMgYWxsXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW1cbiAgICAgKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBwYXJhbGxlbC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiByZXN1bHQgdmFsdWUuXG4gICAgICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAgICAgKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWBcbiAgICAgKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMgdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIHByb3ZpZGVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGRpcjEgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMS50eHQsIGZpbGUyLnR4dFxuICAgICAqIC8vIGRpcjIgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMy50eHQsIGZpbGU0LnR4dFxuICAgICAqIC8vIGRpcjMgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlNS50eHRcbiAgICAgKiAvLyBkaXI0IGRvZXMgbm90IGV4aXN0XG4gICAgICpcbiAgICAgKiBjb25zdCBmaWxlTGlzdCA9IFsnZGlyMS9maWxlMS50eHQnLCdkaXIyL2ZpbGUzLnR4dCcsJ2RpcjMvZmlsZTUudHh0J107XG4gICAgICogY29uc3Qgd2l0aE1pc3NpbmdGaWxlTGlzdCA9IFsnZmlsZTEudHh0JywnZmlsZTIudHh0JywnZmlsZTQudHh0J107XG4gICAgICpcbiAgICAgKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSBmaWxlIGV4aXN0c1xuICAgICAqIGZ1bmN0aW9uIGZpbGVFeGlzdHMoZmlsZSwgY2FsbGJhY2spIHtcbiAgICAgKiAgICBmcy5hY2Nlc3MoZmlsZSwgZnMuY29uc3RhbnRzLkZfT0ssIChlcnIpID0+IHtcbiAgICAgKiAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycik7XG4gICAgICogICAgfSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gICAgICogYXN5bmMuZXZlcnkoZmlsZUxpc3QsIGZpbGVFeGlzdHMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogICAgIC8vIHRydWVcbiAgICAgKiAgICAgLy8gcmVzdWx0IGlzIHRydWUgc2luY2UgZXZlcnkgZmlsZSBleGlzdHNcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGFzeW5jLmV2ZXJ5KHdpdGhNaXNzaW5nRmlsZUxpc3QsIGZpbGVFeGlzdHMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogICAgIC8vIGZhbHNlXG4gICAgICogICAgIC8vIHJlc3VsdCBpcyBmYWxzZSBzaW5jZSBOT1QgZXZlcnkgZmlsZSBleGlzdHNcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIFByb21pc2VzXG4gICAgICogYXN5bmMuZXZlcnkoZmlsZUxpc3QsIGZpbGVFeGlzdHMpXG4gICAgICogLnRoZW4oIHJlc3VsdCA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogICAgIC8vIHRydWVcbiAgICAgKiAgICAgLy8gcmVzdWx0IGlzIHRydWUgc2luY2UgZXZlcnkgZmlsZSBleGlzdHNcbiAgICAgKiB9KS5jYXRjaCggZXJyID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGFzeW5jLmV2ZXJ5KHdpdGhNaXNzaW5nRmlsZUxpc3QsIGZpbGVFeGlzdHMpXG4gICAgICogLnRoZW4oIHJlc3VsdCA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogICAgIC8vIGZhbHNlXG4gICAgICogICAgIC8vIHJlc3VsdCBpcyBmYWxzZSBzaW5jZSBOT1QgZXZlcnkgZmlsZSBleGlzdHNcbiAgICAgKiB9KS5jYXRjaCggZXJyID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gICAgICogYXN5bmMgKCkgPT4ge1xuICAgICAqICAgICB0cnkge1xuICAgICAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLmV2ZXJ5KGZpbGVMaXN0LCBmaWxlRXhpc3RzKTtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogICAgICAgICAvLyB0cnVlXG4gICAgICogICAgICAgICAvLyByZXN1bHQgaXMgdHJ1ZSBzaW5jZSBldmVyeSBmaWxlIGV4aXN0c1xuICAgICAqICAgICB9XG4gICAgICogICAgIGNhdGNoIChlcnIpIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBhc3luYyAoKSA9PiB7XG4gICAgICogICAgIHRyeSB7XG4gICAgICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMuZXZlcnkod2l0aE1pc3NpbmdGaWxlTGlzdCwgZmlsZUV4aXN0cyk7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAqICAgICAgICAgLy8gZmFsc2VcbiAgICAgKiAgICAgICAgIC8vIHJlc3VsdCBpcyBmYWxzZSBzaW5jZSBOT1QgZXZlcnkgZmlsZSBleGlzdHNcbiAgICAgKiAgICAgfVxuICAgICAqICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfY3JlYXRlVGVzdGVyKGJvb2wgPT4gIWJvb2wsIHJlcyA9PiAhcmVzKShlYWNoT2YkMSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxuICAgIH1cbiAgICB2YXIgZXZlcnkkMSA9IGF3YWl0aWZ5KGV2ZXJ5LCAzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFtgZXZlcnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICAgICAqXG4gICAgICogQG5hbWUgZXZlcnlMaW1pdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLmV2ZXJ5XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9XG4gICAgICogQGFsaWFzIGFsbExpbWl0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gICAgICogaW4gdGhlIGNvbGxlY3Rpb24gaW4gcGFyYWxsZWwuXG4gICAgICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gcmVzdWx0IHZhbHVlLlxuICAgICAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gICAgICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgXG4gICAgICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBwcm92aWRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5TGltaXQoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX2NyZWF0ZVRlc3Rlcihib29sID0+ICFib29sLCByZXMgPT4gIXJlcykoZWFjaE9mTGltaXQobGltaXQpLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG4gICAgfVxuICAgIHZhciBldmVyeUxpbWl0JDEgPSBhd2FpdGlmeShldmVyeUxpbWl0LCA0KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFtgZXZlcnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIGV2ZXJ5U2VyaWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMuZXZlcnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ldmVyeX1cbiAgICAgKiBAYWxpYXMgYWxsU2VyaWVzXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW1cbiAgICAgKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBzZXJpZXMuXG4gICAgICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gcmVzdWx0IHZhbHVlLlxuICAgICAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gICAgICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgXG4gICAgICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBwcm92aWRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5U2VyaWVzKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX2NyZWF0ZVRlc3Rlcihib29sID0+ICFib29sLCByZXMgPT4gIXJlcykoZWFjaE9mU2VyaWVzJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbiAgICB9XG4gICAgdmFyIGV2ZXJ5U2VyaWVzJDEgPSBhd2FpdGlmeShldmVyeVNlcmllcywgMyk7XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJBcnJheShlYWNoZm4sIGFyciwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0cnV0aFZhbHVlcyA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgICAgICAgZWFjaGZuKGFyciwgKHgsIGluZGV4LCBpdGVyQ2IpID0+IHtcbiAgICAgICAgICAgIGl0ZXJhdGVlKHgsIChlcnIsIHYpID0+IHtcbiAgICAgICAgICAgICAgICB0cnV0aFZhbHVlc1tpbmRleF0gPSAhIXY7XG4gICAgICAgICAgICAgICAgaXRlckNiKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRydXRoVmFsdWVzW2ldKSByZXN1bHRzLnB1c2goYXJyW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJHZW5lcmljKGVhY2hmbiwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGVhY2hmbihjb2xsLCAoeCwgaW5kZXgsIGl0ZXJDYikgPT4ge1xuICAgICAgICAgICAgaXRlcmF0ZWUoeCwgKGVyciwgdikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBpdGVyQ2IoZXJyKTtcbiAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe2luZGV4LCB2YWx1ZTogeH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVyQ2IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggLSBiLmluZGV4KVxuICAgICAgICAgICAgICAgIC5tYXAodiA9PiB2LnZhbHVlKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9maWx0ZXIoZWFjaGZuLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZpbHRlciA9IGlzQXJyYXlMaWtlKGNvbGwpID8gZmlsdGVyQXJyYXkgOiBmaWx0ZXJHZW5lcmljO1xuICAgICAgICByZXR1cm4gZmlsdGVyKGVhY2hmbiwgY29sbCwgd3JhcEFzeW5jKGl0ZXJhdGVlKSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgb2YgYWxsIHRoZSB2YWx1ZXMgaW4gYGNvbGxgIHdoaWNoIHBhc3MgYW4gYXN5bmMgdHJ1dGhcbiAgICAgKiB0ZXN0LiBUaGlzIG9wZXJhdGlvbiBpcyBwZXJmb3JtZWQgaW4gcGFyYWxsZWwsIGJ1dCB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGJlXG4gICAgICogaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIG9yaWdpbmFsLlxuICAgICAqXG4gICAgICogQG5hbWUgZmlsdGVyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQGFsaWFzIHNlbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cnV0aFZhbHVlKWAsIHdoaWNoIG11c3QgYmUgY2FsbGVkXG4gICAgICogd2l0aCBhIGJvb2xlYW4gYXJndW1lbnQgb25jZSBpdCBoYXMgY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICAgICAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBwcm92aWRlZFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBkaXIxIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTEudHh0LCBmaWxlMi50eHRcbiAgICAgKiAvLyBkaXIyIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTMudHh0LCBmaWxlNC50eHRcbiAgICAgKiAvLyBkaXIzIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTUudHh0XG4gICAgICpcbiAgICAgKiBjb25zdCBmaWxlcyA9IFsnZGlyMS9maWxlMS50eHQnLCdkaXIyL2ZpbGUzLnR4dCcsJ2RpcjMvZmlsZTYudHh0J107XG4gICAgICpcbiAgICAgKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSBmaWxlIGV4aXN0c1xuICAgICAqIGZ1bmN0aW9uIGZpbGVFeGlzdHMoZmlsZSwgY2FsbGJhY2spIHtcbiAgICAgKiAgICBmcy5hY2Nlc3MoZmlsZSwgZnMuY29uc3RhbnRzLkZfT0ssIChlcnIpID0+IHtcbiAgICAgKiAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycik7XG4gICAgICogICAgfSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gICAgICogYXN5bmMuZmlsdGVyKGZpbGVzLCBmaWxlRXhpc3RzLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICAgKiAgICBpZihlcnIpIHtcbiAgICAgKiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICB9IGVsc2Uge1xuICAgICAqICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgICAgLy8gWyAnZGlyMS9maWxlMS50eHQnLCAnZGlyMi9maWxlMy50eHQnIF1cbiAgICAgKiAgICAgICAgLy8gcmVzdWx0cyBpcyBub3cgYW4gYXJyYXkgb2YgdGhlIGV4aXN0aW5nIGZpbGVzXG4gICAgICogICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gVXNpbmcgUHJvbWlzZXNcbiAgICAgKiBhc3luYy5maWx0ZXIoZmlsZXMsIGZpbGVFeGlzdHMpXG4gICAgICogLnRoZW4ocmVzdWx0cyA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAgICAqICAgICAvLyBbICdkaXIxL2ZpbGUxLnR4dCcsICdkaXIyL2ZpbGUzLnR4dCcgXVxuICAgICAqICAgICAvLyByZXN1bHRzIGlzIG5vdyBhbiBhcnJheSBvZiB0aGUgZXhpc3RpbmcgZmlsZXNcbiAgICAgKiB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAgICAgKiBhc3luYyAoKSA9PiB7XG4gICAgICogICAgIHRyeSB7XG4gICAgICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLmZpbHRlcihmaWxlcywgZmlsZUV4aXN0cyk7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgICAgIC8vIFsgJ2RpcjEvZmlsZTEudHh0JywgJ2RpcjIvZmlsZTMudHh0JyBdXG4gICAgICogICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyBhbiBhcnJheSBvZiB0aGUgZXhpc3RpbmcgZmlsZXNcbiAgICAgKiAgICAgfVxuICAgICAqICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyIChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9maWx0ZXIoZWFjaE9mJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbiAgICB9XG4gICAgdmFyIGZpbHRlciQxID0gYXdhaXRpZnkoZmlsdGVyLCAzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFtgZmlsdGVyYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gICAgICogdGltZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIGZpbHRlckxpbWl0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfVxuICAgICAqIEBhbGlhcyBzZWxlY3RMaW1pdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgdHJ1dGhWYWx1ZSlgLCB3aGljaCBtdXN0IGJlIGNhbGxlZFxuICAgICAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAgICAgKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXJMaW1pdCAoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX2ZpbHRlcihlYWNoT2ZMaW1pdChsaW1pdCksIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbiAgICB9XG4gICAgdmFyIGZpbHRlckxpbWl0JDEgPSBhd2FpdGlmeShmaWx0ZXJMaW1pdCwgNCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBhcyBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIGZpbHRlclNlcmllc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLmZpbHRlcl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn1cbiAgICAgKiBAYWxpYXMgc2VsZWN0U2VyaWVzXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAgICAgKiB3aXRoIGEgYm9vbGVhbiBhcmd1bWVudCBvbmNlIGl0IGhhcyBjb21wbGV0ZWQuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gICAgICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXJTZXJpZXMgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX2ZpbHRlcihlYWNoT2ZTZXJpZXMkMSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxuICAgIH1cbiAgICB2YXIgZmlsdGVyU2VyaWVzJDEgPSBhd2FpdGlmeShmaWx0ZXJTZXJpZXMsIDMpO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBgZm5gIHdpdGggYSBjYWxsYmFjayBwYXJhbWV0ZXIgdGhhdCBhbGxvd3MgaXRcbiAgICAgKiB0byBjYWxsIGl0c2VsZiBhZ2FpbiwgaW4gc2VyaWVzLCBpbmRlZmluaXRlbHkuXG5cbiAgICAgKiBJZiBhbiBlcnJvciBpcyBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIHRoZW4gYGVycmJhY2tgIGlzIGNhbGxlZCB3aXRoIHRoZVxuICAgICAqIGVycm9yLCBhbmQgZXhlY3V0aW9uIHN0b3BzLCBvdGhlcndpc2UgaXQgd2lsbCBuZXZlciBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBmb3JldmVyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICAgICAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBhbiBhc3luYyBmdW5jdGlvbiB0byBjYWxsIHJlcGVhdGVkbHkuXG4gICAgICogSW52b2tlZCB3aXRoIChuZXh0KS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyYmFja10gLSB3aGVuIGBmbmAgcGFzc2VzIGFuIGVycm9yIHRvIGl0J3MgY2FsbGJhY2ssXG4gICAgICogdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCwgYW5kIGV4ZWN1dGlvbiBzdG9wcy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCByZWplY3RzIGlmIGFuIGVycm9yIG9jY3VycyBhbmQgYW4gZXJyYmFja1xuICAgICAqIGlzIG5vdCBwYXNzZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXN5bmMuZm9yZXZlcihcbiAgICAgKiAgICAgZnVuY3Rpb24obmV4dCkge1xuICAgICAqICAgICAgICAgLy8gbmV4dCBpcyBzdWl0YWJsZSBmb3IgcGFzc2luZyB0byB0aGluZ3MgdGhhdCBuZWVkIGEgY2FsbGJhY2soZXJyIFssIHdoYXRldmVyXSk7XG4gICAgICogICAgICAgICAvLyBpdCB3aWxsIHJlc3VsdCBpbiB0aGlzIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCBhZ2Fpbi5cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICogICAgICAgICAvLyBpZiBuZXh0IGlzIGNhbGxlZCB3aXRoIGEgdmFsdWUgaW4gaXRzIGZpcnN0IHBhcmFtZXRlciwgaXQgd2lsbCBhcHBlYXJcbiAgICAgKiAgICAgICAgIC8vIGluIGhlcmUgYXMgJ2VycicsIGFuZCBleGVjdXRpb24gd2lsbCBzdG9wLlxuICAgICAqICAgICB9XG4gICAgICogKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JldmVyKGZuLCBlcnJiYWNrKSB7XG4gICAgICAgIHZhciBkb25lID0gb25seU9uY2UoZXJyYmFjayk7XG4gICAgICAgIHZhciB0YXNrID0gd3JhcEFzeW5jKGVuc3VyZUFzeW5jKGZuKSk7XG5cbiAgICAgICAgZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICAgICAgdGFzayhuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cbiAgICB2YXIgZm9yZXZlciQxID0gYXdhaXRpZnkoZm9yZXZlciwgMik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBhcyBbYGdyb3VwQnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZ3JvdXBCeX0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBncm91cEJ5TGltaXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAc2VlIFthc3luYy5ncm91cEJ5XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZ3JvdXBCeX1cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gICAgICogYGNvbGxgLlxuICAgICAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci5cbiAgICAgKiBJbnZva2VkIHdpdGggKHZhbHVlLCBjYWxsYmFjaykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAgICAgKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzXG4gICAgICogcHJvcGVydGllcyBhcmUgYXJyYXlzIG9mIHZhbHVlcyB3aGljaCByZXR1cm5lZCB0aGUgY29ycmVzcG9uZGluZyBrZXkuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ3JvdXBCeUxpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG4gICAgICAgIHJldHVybiBtYXBMaW1pdCQxKGNvbGwsIGxpbWl0LCAodmFsLCBpdGVyQ2IpID0+IHtcbiAgICAgICAgICAgIF9pdGVyYXRlZSh2YWwsIChlcnIsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBpdGVyQ2IoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlckNiKGVyciwge2tleSwgdmFsfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgKGVyciwgbWFwUmVzdWx0cykgPT4ge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgLy8gZnJvbSBNRE4sIGhhbmRsZSBvYmplY3QgaGF2aW5nIGFuIGBoYXNPd25Qcm9wZXJ0eWAgcHJvcFxuICAgICAgICAgICAgdmFyIHtoYXNPd25Qcm9wZXJ0eX0gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcFJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobWFwUmVzdWx0c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIge2tleX0gPSBtYXBSZXN1bHRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIge3ZhbH0gPSBtYXBSZXN1bHRzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBbdmFsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwQnlMaW1pdCQxID0gYXdhaXRpZnkoZ3JvdXBCeUxpbWl0LCA0KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0LCB3aGVyZSBlYWNoIHZhbHVlIGNvcnJlc3BvbmRzIHRvIGFuIGFycmF5IG9mIGl0ZW1zLCBmcm9tXG4gICAgICogYGNvbGxgLCB0aGF0IHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS4gVGhhdCBpcywgdGhlIGtleXMgb2YgdGhlIG9iamVjdFxuICAgICAqIGNvcnJlc3BvbmQgdG8gdGhlIHZhbHVlcyBwYXNzZWQgdG8gdGhlIGBpdGVyYXRlZWAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBOb3RlOiBTaW5jZSB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgdGhlIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIHBhcmFsbGVsLFxuICAgICAqIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyB3aWxsIGNvbXBsZXRlIGluIG9yZGVyLlxuICAgICAqIEhvd2V2ZXIsIHRoZSB2YWx1ZXMgZm9yIGVhY2gga2V5IGluIHRoZSBgcmVzdWx0YCB3aWxsIGJlIGluIHRoZSBzYW1lIG9yZGVyIGFzXG4gICAgICogdGhlIG9yaWdpbmFsIGBjb2xsYC4gRm9yIE9iamVjdHMsIHRoZSB2YWx1ZXMgd2lsbCByb3VnaGx5IGJlIGluIHRoZSBvcmRlciBvZlxuICAgICAqIHRoZSBvcmlnaW5hbCBPYmplY3RzJyBrZXlzIChidXQgdGhpcyBjYW4gdmFyeSBhY3Jvc3MgSmF2YVNjcmlwdCBlbmdpbmVzKS5cbiAgICAgKlxuICAgICAqIEBuYW1lIGdyb3VwQnlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAgICAgKiBgY29sbGAuXG4gICAgICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYGtleWAgdG8gZ3JvdXAgdGhlIHZhbHVlIHVuZGVyLlxuICAgICAqIEludm9rZWQgd2l0aCAodmFsdWUsIGNhbGxiYWNrKS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICAgICAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdCBpcyBhbiBgT2JqZWN0YCB3aG9zZXNcbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gZGlyMSBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUxLnR4dCwgZmlsZTIudHh0XG4gICAgICogLy8gZGlyMiBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUzLnR4dCwgZmlsZTQudHh0XG4gICAgICogLy8gZGlyMyBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGU1LnR4dFxuICAgICAqIC8vIGRpcjQgZG9lcyBub3QgZXhpc3RcbiAgICAgKlxuICAgICAqIGNvbnN0IGZpbGVzID0gWydkaXIxL2ZpbGUxLnR4dCcsJ2RpcjInLCdkaXI0J11cbiAgICAgKlxuICAgICAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IGRldGVjdHMgZmlsZSB0eXBlIGFzIG5vbmUsIGZpbGUsIG9yIGRpcmVjdG9yeVxuICAgICAqIGZ1bmN0aW9uIGRldGVjdEZpbGUoZmlsZSwgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcbiAgICAgKiAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgJ25vbmUnKTtcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdkaXJlY3RvcnknIDogJ2ZpbGUnKTtcbiAgICAgKiAgICAgfSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy9Vc2luZyBjYWxsYmFja3NcbiAgICAgKiBhc3luYy5ncm91cEJ5KGZpbGVzLCBkZXRlY3RGaWxlLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAqICAgICBpZihlcnIpIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgIH0gZWxzZSB7XG4gICAgICpcdCAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAqICAgICAgICAgLy8ge1xuICAgICAqICAgICAgICAgLy8gICAgIGZpbGU6IFsgJ2RpcjEvZmlsZTEudHh0JyBdLFxuICAgICAqICAgICAgICAgLy8gICAgIG5vbmU6IFsgJ2RpcjQnIF0sXG4gICAgICogICAgICAgICAvLyAgICAgZGlyZWN0b3J5OiBbICdkaXIyJ11cbiAgICAgKiAgICAgICAgIC8vIH1cbiAgICAgKiAgICAgICAgIC8vIHJlc3VsdCBpcyBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgZ3JvdXBlZCBieSB0eXBlXG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIFByb21pc2VzXG4gICAgICogYXN5bmMuZ3JvdXBCeShmaWxlcywgZGV0ZWN0RmlsZSlcbiAgICAgKiAudGhlbiggcmVzdWx0ID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgKiAgICAgLy8ge1xuICAgICAqICAgICAvLyAgICAgZmlsZTogWyAnZGlyMS9maWxlMS50eHQnIF0sXG4gICAgICogICAgIC8vICAgICBub25lOiBbICdkaXI0JyBdLFxuICAgICAqICAgICAvLyAgICAgZGlyZWN0b3J5OiBbICdkaXIyJ11cbiAgICAgKiAgICAgLy8gfVxuICAgICAqICAgICAvLyByZXN1bHQgaXMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZpbGVzIGdyb3VwZWQgYnkgdHlwZVxuICAgICAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAgICAgKiBhc3luYyAoKSA9PiB7XG4gICAgICogICAgIHRyeSB7XG4gICAgICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMuZ3JvdXBCeShmaWxlcywgZGV0ZWN0RmlsZSk7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAqICAgICAgICAgLy8ge1xuICAgICAqICAgICAgICAgLy8gICAgIGZpbGU6IFsgJ2RpcjEvZmlsZTEudHh0JyBdLFxuICAgICAqICAgICAgICAgLy8gICAgIG5vbmU6IFsgJ2RpcjQnIF0sXG4gICAgICogICAgICAgICAvLyAgICAgZGlyZWN0b3J5OiBbICdkaXIyJ11cbiAgICAgKiAgICAgICAgIC8vIH1cbiAgICAgKiAgICAgICAgIC8vIHJlc3VsdCBpcyBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgZ3JvdXBlZCBieSB0eXBlXG4gICAgICogICAgIH1cbiAgICAgKiAgICAgY2F0Y2ggKGVycikge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdyb3VwQnkgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZ3JvdXBCeUxpbWl0JDEoY29sbCwgSW5maW5pdHksIGl0ZXJhdGVlLCBjYWxsYmFjaylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBhcyBbYGdyb3VwQnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZ3JvdXBCeX0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICAgICAqXG4gICAgICogQG5hbWUgZ3JvdXBCeVNlcmllc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLmdyb3VwQnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICAgICAqIGBjb2xsYC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBga2V5YCB0byBncm91cCB0aGUgdmFsdWUgdW5kZXIuXG4gICAgICogSW52b2tlZCB3aXRoICh2YWx1ZSwgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gICAgICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0IGlzIGFuIGBPYmplY3RgIHdob3NlXG4gICAgICogcHJvcGVydGllcyBhcmUgYXJyYXlzIG9mIHZhbHVlcyB3aGljaCByZXR1cm5lZCB0aGUgY29ycmVzcG9uZGluZyBrZXkuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ3JvdXBCeVNlcmllcyAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBncm91cEJ5TGltaXQkMShjb2xsLCAxLCBpdGVyYXRlZSwgY2FsbGJhY2spXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyB0aGUgcmVzdWx0IG9mIGFuIGBhc3luY2AgZnVuY3Rpb24gdG8gdGhlIGBjb25zb2xlYC4gT25seSB3b3JrcyBpblxuICAgICAqIE5vZGUuanMgb3IgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGBjb25zb2xlLmxvZ2AgYW5kIGBjb25zb2xlLmVycm9yYCAoc3VjaFxuICAgICAqIGFzIEZGIGFuZCBDaHJvbWUpLiBJZiBtdWx0aXBsZSBhcmd1bWVudHMgYXJlIHJldHVybmVkIGZyb20gdGhlIGFzeW5jXG4gICAgICogZnVuY3Rpb24sIGBjb25zb2xlLmxvZ2AgaXMgY2FsbGVkIG9uIGVhY2ggYXJndW1lbnQgaW4gb3JkZXIuXG4gICAgICpcbiAgICAgKiBAbmFtZSBsb2dcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24geW91IHdhbnQgdG8gZXZlbnR1YWxseSBhcHBseVxuICAgICAqIGFsbCBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmd1bWVudHMuLi4gLSBBbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGluIGEgbW9kdWxlXG4gICAgICogdmFyIGhlbGxvID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdoZWxsbyAnICsgbmFtZSk7XG4gICAgICogICAgIH0sIDEwMDApO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiAvLyBpbiB0aGUgbm9kZSByZXBsXG4gICAgICogbm9kZT4gYXN5bmMubG9nKGhlbGxvLCAnd29ybGQnKTtcbiAgICAgKiAnaGVsbG8gd29ybGQnXG4gICAgICovXG4gICAgdmFyIGxvZyA9IGNvbnNvbGVGdW5jKCdsb2cnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFtgbWFwVmFsdWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc30gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gICAgICogdGltZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIG1hcFZhbHVlc0xpbWl0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMubWFwVmFsdWVzXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICAgICAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdmFsdWUgYW5kIGtleVxuICAgICAqIGluIGBjb2xsYC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gICAgICogSW52b2tlZCB3aXRoICh2YWx1ZSwga2V5LCBjYWxsYmFjaykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAgICAgKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgcmVzdWx0YCBpcyBhIG5ldyBvYmplY3QgY29uc2lzdGluZ1xuICAgICAqIG9mIGVhY2gga2V5IGZyb20gYG9iamAsIHdpdGggZWFjaCB0cmFuc2Zvcm1lZCB2YWx1ZSBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlLlxuICAgICAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFZhbHVlc0xpbWl0KG9iaiwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgICAgICB2YXIgbmV3T2JqID0ge307XG4gICAgICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgICAgICByZXR1cm4gZWFjaE9mTGltaXQobGltaXQpKG9iaiwgKHZhbCwga2V5LCBuZXh0KSA9PiB7XG4gICAgICAgICAgICBfaXRlcmF0ZWUodmFsLCBrZXksIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgbmV4dChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGVyciA9PiBjYWxsYmFjayhlcnIsIG5ld09iaikpO1xuICAgIH1cblxuICAgIHZhciBtYXBWYWx1ZXNMaW1pdCQxID0gYXdhaXRpZnkobWFwVmFsdWVzTGltaXQsIDQpO1xuXG4gICAgLyoqXG4gICAgICogQSByZWxhdGl2ZSBvZiBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LCBkZXNpZ25lZCBmb3IgdXNlIHdpdGggb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIFByb2R1Y2VzIGEgbmV3IE9iamVjdCBieSBtYXBwaW5nIGVhY2ggdmFsdWUgb2YgYG9iamAgdGhyb3VnaCB0aGUgYGl0ZXJhdGVlYFxuICAgICAqIGZ1bmN0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgZWFjaCBgdmFsdWVgIGFuZCBga2V5YCBmcm9tIGBvYmpgIGFuZCBhXG4gICAgICogY2FsbGJhY2sgZm9yIHdoZW4gaXQgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcuIEVhY2ggb2YgdGhlc2UgY2FsbGJhY2tzIHRha2VzXG4gICAgICogdHdvIGFyZ3VtZW50czogYW4gYGVycm9yYCwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBpdGVtIGZyb20gYG9iamAuIElmIGBpdGVyYXRlZWBcbiAgICAgKiBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlIGBtYXBWYWx1ZXNgXG4gICAgICogZnVuY3Rpb24pIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoZSBvcmRlciBvZiB0aGUga2V5cyBpbiB0aGUgcmVzdWx0IGlzIG5vdCBndWFyYW50ZWVkLiAgVGhlIGtleXMgd2lsbFxuICAgICAqIGJlIHJvdWdobHkgaW4gdGhlIG9yZGVyIHRoZXkgY29tcGxldGUsIChidXQgdGhpcyBpcyB2ZXJ5IGVuZ2luZS1zcGVjaWZpYylcbiAgICAgKlxuICAgICAqIEBuYW1lIG1hcFZhbHVlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5XG4gICAgICogaW4gYGNvbGxgLlxuICAgICAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAgICAgKiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICAgICAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIGByZXN1bHRgIGlzIGEgbmV3IG9iamVjdCBjb25zaXN0aW5nXG4gICAgICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuXG4gICAgICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGZpbGUxLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAxMDAwIGJ5dGVzIGluIHNpemVcbiAgICAgKiAvLyBmaWxlMi50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMjAwMCBieXRlcyBpbiBzaXplXG4gICAgICogLy8gZmlsZTMudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDMwMDAgYnl0ZXMgaW4gc2l6ZVxuICAgICAqIC8vIGZpbGU0LnR4dCBkb2VzIG5vdCBleGlzdFxuICAgICAqXG4gICAgICogY29uc3QgZmlsZU1hcCA9IHtcbiAgICAgKiAgICAgZjE6ICdmaWxlMS50eHQnLFxuICAgICAqICAgICBmMjogJ2ZpbGUyLnR4dCcsXG4gICAgICogICAgIGYzOiAnZmlsZTMudHh0J1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBjb25zdCB3aXRoTWlzc2luZ0ZpbGVNYXAgPSB7XG4gICAgICogICAgIGYxOiAnZmlsZTEudHh0JyxcbiAgICAgKiAgICAgZjI6ICdmaWxlMi50eHQnLFxuICAgICAqICAgICBmMzogJ2ZpbGU0LnR4dCdcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZmlsZSBzaXplIGluIGJ5dGVzXG4gICAgICogZnVuY3Rpb24gZ2V0RmlsZVNpemVJbkJ5dGVzKGZpbGUsIGtleSwgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcbiAgICAgKiAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXQuc2l6ZSk7XG4gICAgICogICAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICAgICAqIGFzeW5jLm1hcFZhbHVlcyhmaWxlTWFwLCBnZXRGaWxlU2l6ZUluQnl0ZXMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICogICAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAqICAgICAgICAgLy8gcmVzdWx0IGlzIG5vdyBhIG1hcCBvZiBmaWxlIHNpemUgaW4gYnl0ZXMgZm9yIGVhY2ggZmlsZSwgZS5nLlxuICAgICAqICAgICAgICAgLy8ge1xuICAgICAqICAgICAgICAgLy8gICAgIGYxOiAxMDAwLFxuICAgICAqICAgICAgICAgLy8gICAgIGYyOiAyMDAwLFxuICAgICAqICAgICAgICAgLy8gICAgIGYzOiAzMDAwXG4gICAgICogICAgICAgICAvLyB9XG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIEVycm9yIGhhbmRsaW5nXG4gICAgICogYXN5bmMubWFwVmFsdWVzKHdpdGhNaXNzaW5nRmlsZU1hcCwgZ2V0RmlsZVNpemVJbkJ5dGVzLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAqICAgICBpZiAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAgICAgKiAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIFByb21pc2VzXG4gICAgICogYXN5bmMubWFwVmFsdWVzKGZpbGVNYXAsIGdldEZpbGVTaXplSW5CeXRlcylcbiAgICAgKiAudGhlbiggcmVzdWx0ID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgKiAgICAgLy8gcmVzdWx0IGlzIG5vdyBhIG1hcCBvZiBmaWxlIHNpemUgaW4gYnl0ZXMgZm9yIGVhY2ggZmlsZSwgZS5nLlxuICAgICAqICAgICAvLyB7XG4gICAgICogICAgIC8vICAgICBmMTogMTAwMCxcbiAgICAgKiAgICAgLy8gICAgIGYyOiAyMDAwLFxuICAgICAqICAgICAvLyAgICAgZjM6IDMwMDBcbiAgICAgKiAgICAgLy8gfVxuICAgICAqIH0pLmNhdGNoIChlcnIgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gRXJyb3IgSGFuZGxpbmdcbiAgICAgKiBhc3luYy5tYXBWYWx1ZXMod2l0aE1pc3NpbmdGaWxlTWFwLCBnZXRGaWxlU2l6ZUluQnl0ZXMpXG4gICAgICogLnRoZW4oIHJlc3VsdCA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogfSkuY2F0Y2ggKGVyciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICAgICAqIGFzeW5jICgpID0+IHtcbiAgICAgKiAgICAgdHJ5IHtcbiAgICAgKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5tYXBWYWx1ZXMoZmlsZU1hcCwgZ2V0RmlsZVNpemVJbkJ5dGVzKTtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogICAgICAgICAvLyByZXN1bHQgaXMgbm93IGEgbWFwIG9mIGZpbGUgc2l6ZSBpbiBieXRlcyBmb3IgZWFjaCBmaWxlLCBlLmcuXG4gICAgICogICAgICAgICAvLyB7XG4gICAgICogICAgICAgICAvLyAgICAgZjE6IDEwMDAsXG4gICAgICogICAgICAgICAvLyAgICAgZjI6IDIwMDAsXG4gICAgICogICAgICAgICAvLyAgICAgZjM6IDMwMDBcbiAgICAgKiAgICAgICAgIC8vIH1cbiAgICAgKiAgICAgfVxuICAgICAqICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gRXJyb3IgSGFuZGxpbmdcbiAgICAgKiBhc3luYyAoKSA9PiB7XG4gICAgICogICAgIHRyeSB7XG4gICAgICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMubWFwVmFsdWVzKHdpdGhNaXNzaW5nRmlsZU1hcCwgZ2V0RmlsZVNpemVJbkJ5dGVzKTtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogICAgIH1cbiAgICAgKiAgICAgY2F0Y2ggKGVycikge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG1hcFZhbHVlc0xpbWl0JDEob2JqLCBJbmZpbml0eSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFtgbWFwVmFsdWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc30gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICAgICAqXG4gICAgICogQG5hbWUgbWFwVmFsdWVzU2VyaWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMubWFwVmFsdWVzXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5XG4gICAgICogaW4gYGNvbGxgLlxuICAgICAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAgICAgKiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICAgICAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIGByZXN1bHRgIGlzIGEgbmV3IG9iamVjdCBjb25zaXN0aW5nXG4gICAgICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuXG4gICAgICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzU2VyaWVzKG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBtYXBWYWx1ZXNMaW1pdCQxKG9iaiwgMSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhY2hlcyB0aGUgcmVzdWx0cyBvZiBhbiBhc3luYyBmdW5jdGlvbi4gV2hlbiBjcmVhdGluZyBhIGhhc2ggdG8gc3RvcmVcbiAgICAgKiBmdW5jdGlvbiByZXN1bHRzIGFnYWluc3QsIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkIGZyb20gdGhlIGhhc2ggYW5kIGFuXG4gICAgICogb3B0aW9uYWwgaGFzaCBmdW5jdGlvbiBjYW4gYmUgdXNlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZTogaWYgdGhlIGFzeW5jIGZ1bmN0aW9uIGVycnMsIHRoZSByZXN1bHQgd2lsbCBub3QgYmUgY2FjaGVkIGFuZFxuICAgICAqIHN1YnNlcXVlbnQgY2FsbHMgd2lsbCBjYWxsIHRoZSB3cmFwcGVkIGZ1bmN0aW9uLioqXG4gICAgICpcbiAgICAgKiBJZiBubyBoYXNoIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoYXNoIGtleSxcbiAgICAgKiB3aGljaCBtYXkgd29yayByZWFzb25hYmx5IGlmIGl0IGlzIGEgc3RyaW5nIG9yIGEgZGF0YSB0eXBlIHRoYXQgY29udmVydHMgdG8gYVxuICAgICAqIGRpc3RpbmN0IHN0cmluZy4gTm90ZSB0aGF0IG9iamVjdHMgYW5kIGFycmF5cyB3aWxsIG5vdCBiZWhhdmUgcmVhc29uYWJseS5cbiAgICAgKiBOZWl0aGVyIHdpbGwgY2FzZXMgd2hlcmUgdGhlIG90aGVyIGFyZ3VtZW50cyBhcmUgc2lnbmlmaWNhbnQuIEluIHN1Y2ggY2FzZXMsXG4gICAgICogc3BlY2lmeSB5b3VyIG93biBoYXNoIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGNhY2hlIG9mIHJlc3VsdHMgaXMgZXhwb3NlZCBhcyB0aGUgYG1lbW9gIHByb3BlcnR5IG9mIHRoZSBmdW5jdGlvblxuICAgICAqIHJldHVybmVkIGJ5IGBtZW1vaXplYC5cbiAgICAgKlxuICAgICAqIEBuYW1lIG1lbW9pemVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gcHJveHkgYW5kIGNhY2hlIHJlc3VsdHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNoZXIgLSBBbiBvcHRpb25hbCBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBhIGN1c3RvbSBoYXNoXG4gICAgICogZm9yIHN0b3JpbmcgcmVzdWx0cy4gSXQgaGFzIGFsbCB0aGUgYXJndW1lbnRzIGFwcGxpZWQgdG8gaXQgYXBhcnQgZnJvbSB0aGVcbiAgICAgKiBjYWxsYmFjaywgYW5kIG11c3QgYmUgc3luY2hyb25vdXMuXG4gICAgICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IGEgbWVtb2l6ZWQgdmVyc2lvbiBvZiBgZm5gXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzbG93X2ZuID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgLy8gZG8gc29tZXRoaW5nXG4gICAgICogICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICogfTtcbiAgICAgKiB2YXIgZm4gPSBhc3luYy5tZW1vaXplKHNsb3dfZm4pO1xuICAgICAqXG4gICAgICogLy8gZm4gY2FuIG5vdyBiZSB1c2VkIGFzIGlmIGl0IHdlcmUgc2xvd19mblxuICAgICAqIGZuKCdzb21lIG5hbWUnLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgLy8gY2FsbGJhY2tcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZuLCBoYXNoZXIgPSB2ID0+IHYpIHtcbiAgICAgICAgdmFyIG1lbW8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIgcXVldWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdmFyIF9mbiA9IHdyYXBBc3luYyhmbik7XG4gICAgICAgIHZhciBtZW1vaXplZCA9IGluaXRpYWxQYXJhbXMoKGFyZ3MsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICB2YXIga2V5ID0gaGFzaGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgaWYgKGtleSBpbiBtZW1vKSB7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEoKCkgPT4gY2FsbGJhY2sobnVsbCwgLi4ubWVtb1trZXldKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSBpbiBxdWV1ZXMpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgICAgIF9mbiguLi5hcmdzLCAoZXJyLCAuLi5yZXN1bHRBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vICMxNDY1IGRvbid0IG1lbW9pemUgaWYgYW4gZXJyb3Igb2NjdXJyZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IHJlc3VsdEFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxW2ldKGVyciwgLi4ucmVzdWx0QXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lbW9pemVkLm1lbW8gPSBtZW1vO1xuICAgICAgICBtZW1vaXplZC51bm1lbW9pemVkID0gZm47XG4gICAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgYGNhbGxiYWNrYCBvbiBhIGxhdGVyIGxvb3AgYXJvdW5kIHRoZSBldmVudCBsb29wLiBJbiBOb2RlLmpzIHRoaXMganVzdFxuICAgICAqIGNhbGxzIGBwcm9jZXNzLm5leHRUaWNrYC4gIEluIHRoZSBicm93c2VyIGl0IHdpbGwgdXNlIGBzZXRJbW1lZGlhdGVgIGlmXG4gICAgICogYXZhaWxhYmxlLCBvdGhlcndpc2UgYHNldFRpbWVvdXQoY2FsbGJhY2ssIDApYCwgd2hpY2ggbWVhbnMgb3RoZXIgaGlnaGVyXG4gICAgICogcHJpb3JpdHkgZXZlbnRzIG1heSBwcmVjZWRlIHRoZSBleGVjdXRpb24gb2YgYGNhbGxiYWNrYC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IGZvciBicm93c2VyLWNvbXBhdGliaWxpdHkgcHVycG9zZXMuXG4gICAgICpcbiAgICAgKiBAbmFtZSBuZXh0VGlja1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLnNldEltbWVkaWF0ZV17QGxpbmsgbW9kdWxlOlV0aWxzLnNldEltbWVkaWF0ZX1cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gYSBsYXRlciBsb29wIGFyb3VuZFxuICAgICAqIHRoZSBldmVudCBsb29wLiBJbnZva2VkIHdpdGggKGFyZ3MuLi4pLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncy4uLiAtIGFueSBudW1iZXIgb2YgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGVcbiAgICAgKiBjYWxsYmFjayBvbiB0aGUgbmV4dCB0aWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2FsbF9vcmRlciA9IFtdO1xuICAgICAqIGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBjYWxsX29yZGVyLnB1c2goJ3R3bycpO1xuICAgICAqICAgICAvLyBjYWxsX29yZGVyIG5vdyBlcXVhbHMgWydvbmUnLCd0d28nXVxuICAgICAqIH0pO1xuICAgICAqIGNhbGxfb3JkZXIucHVzaCgnb25lJyk7XG4gICAgICpcbiAgICAgKiBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgKiAgICAgLy8gYSwgYiwgYW5kIGMgZXF1YWwgMSwgMiwgYW5kIDNcbiAgICAgKiB9LCAxLCAyLCAzKTtcbiAgICAgKi9cbiAgICB2YXIgX2RlZmVyJDE7XG5cbiAgICBpZiAoaGFzTmV4dFRpY2spIHtcbiAgICAgICAgX2RlZmVyJDEgPSBwcm9jZXNzLm5leHRUaWNrO1xuICAgIH0gZWxzZSBpZiAoaGFzU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIF9kZWZlciQxID0gc2V0SW1tZWRpYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9kZWZlciQxID0gZmFsbGJhY2s7XG4gICAgfVxuXG4gICAgdmFyIG5leHRUaWNrID0gd3JhcChfZGVmZXIkMSk7XG5cbiAgICB2YXIgcGFyYWxsZWwgPSBhd2FpdGlmeSgoZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBpc0FycmF5TGlrZSh0YXNrcykgPyBbXSA6IHt9O1xuXG4gICAgICAgIGVhY2hmbih0YXNrcywgKHRhc2ssIGtleSwgdGFza0NiKSA9PiB7XG4gICAgICAgICAgICB3cmFwQXN5bmModGFzaykoKGVyciwgLi4ucmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIFtyZXN1bHRdID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdGFza0NiKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZXJyID0+IGNhbGxiYWNrKGVyciwgcmVzdWx0cykpO1xuICAgIH0sIDMpO1xuXG4gICAgLyoqXG4gICAgICogUnVuIHRoZSBgdGFza3NgIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIGluIHBhcmFsbGVsLCB3aXRob3V0IHdhaXRpbmcgdW50aWxcbiAgICAgKiB0aGUgcHJldmlvdXMgZnVuY3Rpb24gaGFzIGNvbXBsZXRlZC4gSWYgYW55IG9mIHRoZSBmdW5jdGlvbnMgcGFzcyBhbiBlcnJvciB0b1xuICAgICAqIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICogZXJyb3IuIE9uY2UgdGhlIGB0YXNrc2AgaGF2ZSBjb21wbGV0ZWQsIHRoZSByZXN1bHRzIGFyZSBwYXNzZWQgdG8gdGhlIGZpbmFsXG4gICAgICogYGNhbGxiYWNrYCBhcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBgcGFyYWxsZWxgIGlzIGFib3V0IGtpY2tpbmctb2ZmIEkvTyB0YXNrcyBpbiBwYXJhbGxlbCwgbm90IGFib3V0XG4gICAgICogcGFyYWxsZWwgZXhlY3V0aW9uIG9mIGNvZGUuICBJZiB5b3VyIHRhc2tzIGRvIG5vdCB1c2UgYW55IHRpbWVycyBvciBwZXJmb3JtXG4gICAgICogYW55IEkvTywgdGhleSB3aWxsIGFjdHVhbGx5IGJlIGV4ZWN1dGVkIGluIHNlcmllcy4gIEFueSBzeW5jaHJvbm91cyBzZXR1cFxuICAgICAqIHNlY3Rpb25zIGZvciBlYWNoIHRhc2sgd2lsbCBoYXBwZW4gb25lIGFmdGVyIHRoZSBvdGhlci4gIEphdmFTY3JpcHQgcmVtYWluc1xuICAgICAqIHNpbmdsZS10aHJlYWRlZC5cbiAgICAgKlxuICAgICAqICoqSGludDoqKiBVc2UgW2ByZWZsZWN0YF17QGxpbmsgbW9kdWxlOlV0aWxzLnJlZmxlY3R9IHRvIGNvbnRpbnVlIHRoZVxuICAgICAqIGV4ZWN1dGlvbiBvZiBvdGhlciB0YXNrcyB3aGVuIGEgdGFzayBmYWlscy5cbiAgICAgKlxuICAgICAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gdXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBFYWNoIHByb3BlcnR5IHdpbGxcbiAgICAgKiBiZSBydW4gYXMgYSBmdW5jdGlvbiBhbmQgdGhlIHJlc3VsdHMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZpbmFsIGBjYWxsYmFja2BcbiAgICAgKiBhcyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gVGhpcyBjYW4gYmUgYSBtb3JlIHJlYWRhYmxlIHdheSBvZiBoYW5kbGluZ1xuICAgICAqIHJlc3VsdHMgZnJvbSB7QGxpbmsgYXN5bmMucGFyYWxsZWx9LlxuICAgICAqXG4gICAgICogQG5hbWUgcGFyYWxsZWxcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gb2ZcbiAgICAgKiBbYXN5bmMgZnVuY3Rpb25zXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byBydW4uXG4gICAgICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZVxuICAgICAqIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhIHJlc3VsdHMgYXJyYXlcbiAgICAgKiAob3Igb2JqZWN0KSBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHRhc2sgY2FsbGJhY2tzLlxuICAgICAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG5vdCBwYXNzZWRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvL1VzaW5nIENhbGxiYWNrc1xuICAgICAqIGFzeW5jLnBhcmFsbGVsKFtcbiAgICAgKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICAgICAqICAgICAgICAgfSwgMjAwKTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpO1xuICAgICAqICAgICAgICAgfSwgMTAwKTtcbiAgICAgKiAgICAgfVxuICAgICAqIF0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0byBbJ29uZScsJ3R3byddIGV2ZW4gdGhvdWdoXG4gICAgICogICAgIC8vIHRoZSBzZWNvbmQgZnVuY3Rpb24gaGFkIGEgc2hvcnRlciB0aW1lb3V0LlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gYW4gZXhhbXBsZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheVxuICAgICAqIGFzeW5jLnBhcmFsbGVsKHtcbiAgICAgKiAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTtcbiAgICAgKiAgICAgICAgIH0sIDIwMCk7XG4gICAgICogICAgIH0sXG4gICAgICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7XG4gICAgICogICAgICAgICB9LCAxMDApO1xuICAgICAqICAgICB9XG4gICAgICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAgICAqICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvOiB7IG9uZTogMSwgdHdvOiAyIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vVXNpbmcgUHJvbWlzZXNcbiAgICAgKiBhc3luYy5wYXJhbGxlbChbXG4gICAgICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAgICAgKiAgICAgICAgIH0sIDIwMCk7XG4gICAgICogICAgIH0sXG4gICAgICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAgICAgKiAgICAgICAgIH0sIDEwMCk7XG4gICAgICogICAgIH1cbiAgICAgKiBdKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0byBbJ29uZScsJ3R3byddIGV2ZW4gdGhvdWdoXG4gICAgICogICAgIC8vIHRoZSBzZWNvbmQgZnVuY3Rpb24gaGFkIGEgc2hvcnRlciB0aW1lb3V0LlxuICAgICAqIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBhbiBleGFtcGxlIHVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5XG4gICAgICogYXN5bmMucGFyYWxsZWwoe1xuICAgICAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpO1xuICAgICAqICAgICAgICAgfSwgMjAwKTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAyKTtcbiAgICAgKiAgICAgICAgIH0sIDEwMCk7XG4gICAgICogICAgIH1cbiAgICAgKiB9KS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0bzogeyBvbmU6IDEsIHR3bzogMiB9XG4gICAgICogfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vVXNpbmcgYXN5bmMvYXdhaXRcbiAgICAgKiBhc3luYyAoKSA9PiB7XG4gICAgICogICAgIHRyeSB7XG4gICAgICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLnBhcmFsbGVsKFtcbiAgICAgKiAgICAgICAgICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICAgICAqICAgICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAqICAgICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAgICAgKiAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgKiAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICBdKTtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAgICAqICAgICAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0byBbJ29uZScsJ3R3byddIGV2ZW4gdGhvdWdoXG4gICAgICogICAgICAgICAvLyB0aGUgc2Vjb25kIGZ1bmN0aW9uIGhhZCBhIHNob3J0ZXIgdGltZW91dC5cbiAgICAgKiAgICAgfVxuICAgICAqICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gYW4gZXhhbXBsZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheVxuICAgICAqIGFzeW5jICgpID0+IHtcbiAgICAgKiAgICAgdHJ5IHtcbiAgICAgKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMucGFyYWxsZWwoe1xuICAgICAqICAgICAgICAgICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpO1xuICAgICAqICAgICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAqICAgICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAyKTtcbiAgICAgKiAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgKiAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIH0pO1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gICAgICogICAgICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvOiB7IG9uZTogMSwgdHdvOiAyIH1cbiAgICAgKiAgICAgfVxuICAgICAqICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyYWxsZWwkMSh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHBhcmFsbGVsKGVhY2hPZiQxLCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFtgcGFyYWxsZWxgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucGFyYWxsZWx9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYVxuICAgICAqIHRpbWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBwYXJhbGxlbExpbWl0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMucGFyYWxsZWxde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wYXJhbGxlbH1cbiAgICAgKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gb2ZcbiAgICAgKiBbYXN5bmMgZnVuY3Rpb25zXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byBydW4uXG4gICAgICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFsbCB0aGVcbiAgICAgKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5XG4gICAgICogKG9yIG9iamVjdCkgY29udGFpbmluZyBhbGwgdGhlIHJlc3VsdCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSB0YXNrIGNhbGxiYWNrcy5cbiAgICAgKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBub3QgcGFzc2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyYWxsZWxMaW1pdCh0YXNrcywgbGltaXQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBwYXJhbGxlbChlYWNoT2ZMaW1pdChsaW1pdCksIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBxdWV1ZSBvZiB0YXNrcyBmb3IgdGhlIHdvcmtlciBmdW5jdGlvbiB0byBjb21wbGV0ZS5cbiAgICAgKiBAdHlwZWRlZiB7SXRlcmFibGV9IFF1ZXVlT2JqZWN0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGxlbmd0aCAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBudW1iZXIgb2YgaXRlbXNcbiAgICAgKiB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLmxlbmd0aCgpYC5cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0YXJ0ZWQgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBhbnlcbiAgICAgKiBpdGVtcyBoYXZlIGJlZW4gcHVzaGVkIGFuZCBwcm9jZXNzZWQgYnkgdGhlIHF1ZXVlLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJ1bm5pbmcgLSBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIGl0ZW1zXG4gICAgICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJ1bm5pbmcoKWAuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gd29ya2Vyc0xpc3QgLSBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgYXJyYXkgb2YgaXRlbXNcbiAgICAgKiBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkLiBJbnZva2Ugd2l0aCBgcXVldWUud29ya2Vyc0xpc3QoKWAuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaWRsZSAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlIGlmIHRoZXJlIGFyZSBpdGVtc1xuICAgICAqIHdhaXRpbmcgb3IgYmVpbmcgcHJvY2Vzc2VkLCBvciB0cnVlIGlmIG5vdC4gSW52b2tlIHdpdGggYHF1ZXVlLmlkbGUoKWAuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbmN1cnJlbmN5IC0gYW4gaW50ZWdlciBmb3IgZGV0ZXJtaW5pbmcgaG93IG1hbnkgYHdvcmtlcmBcbiAgICAgKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgY2hhbmdlZCBhZnRlciBhXG4gICAgICogYHF1ZXVlYCBpcyBjcmVhdGVkIHRvIGFsdGVyIHRoZSBjb25jdXJyZW5jeSBvbi10aGUtZmx5LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYXlsb2FkIC0gYW4gaW50ZWdlciB0aGF0IHNwZWNpZmllcyBob3cgbWFueSBpdGVtcyBhcmVcbiAgICAgKiBwYXNzZWQgdG8gdGhlIHdvcmtlciBmdW5jdGlvbiBhdCBhIHRpbWUuIG9ubHkgYXBwbGllcyBpZiB0aGlzIGlzIGFcbiAgICAgKiBbY2FyZ29de0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jYXJnb30gb2JqZWN0XG4gICAgICogQHByb3BlcnR5IHtBc3luY0Z1bmN0aW9ufSBwdXNoIC0gYWRkIGEgbmV3IHRhc2sgdG8gdGhlIGBxdWV1ZWAuIENhbGxzIGBjYWxsYmFja2BcbiAgICAgKiBvbmNlIHRoZSBgd29ya2VyYCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZyB0aGUgdGFzay4gSW5zdGVhZCBvZiBhIHNpbmdsZSB0YXNrLFxuICAgICAqIGEgYHRhc2tzYCBhcnJheSBjYW4gYmUgc3VibWl0dGVkLiBUaGUgcmVzcGVjdGl2ZSBjYWxsYmFjayBpcyB1c2VkIGZvciBldmVyeVxuICAgICAqIHRhc2sgaW4gdGhlIGxpc3QuIEludm9rZSB3aXRoIGBxdWV1ZS5wdXNoKHRhc2ssIFtjYWxsYmFja10pYCxcbiAgICAgKiBAcHJvcGVydHkge0FzeW5jRnVuY3Rpb259IHVuc2hpZnQgLSBhZGQgYSBuZXcgdGFzayB0byB0aGUgZnJvbnQgb2YgdGhlIGBxdWV1ZWAuXG4gICAgICogSW52b2tlIHdpdGggYHF1ZXVlLnVuc2hpZnQodGFzaywgW2NhbGxiYWNrXSlgLlxuICAgICAqIEBwcm9wZXJ0eSB7QXN5bmNGdW5jdGlvbn0gcHVzaEFzeW5jIC0gdGhlIHNhbWUgYXMgYHEucHVzaGAsIGV4Y2VwdCB0aGlzIHJldHVybnNcbiAgICAgKiBhIHByb21pc2UgdGhhdCByZWplY3RzIGlmIGFuIGVycm9yIG9jY3Vycy5cbiAgICAgKiBAcHJvcGVydHkge0FzeW5jRnVuY3Rpb259IHVuc2hpZnRBc3luYyAtIHRoZSBzYW1lIGFzIGBxLnVuc2hpZnRgLCBleGNlcHQgdGhpcyByZXR1cm5zXG4gICAgICogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyBpZiBhbiBlcnJvciBvY2N1cnMuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcmVtb3ZlIC0gcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHF1ZXVlIHRoYXQgbWF0Y2ggYSB0ZXN0XG4gICAgICogZnVuY3Rpb24uICBUaGUgdGVzdCBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBhbiBvYmplY3Qgd2l0aCBhIGBkYXRhYCBwcm9wZXJ0eSxcbiAgICAgKiBhbmQgYSBgcHJpb3JpdHlgIHByb3BlcnR5LCBpZiB0aGlzIGlzIGFcbiAgICAgKiBbcHJpb3JpdHlRdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnByaW9yaXR5UXVldWV9IG9iamVjdC5cbiAgICAgKiBJbnZva2VkIHdpdGggYHF1ZXVlLnJlbW92ZSh0ZXN0Rm4pYCwgd2hlcmUgYHRlc3RGbmAgaXMgb2YgdGhlIGZvcm1cbiAgICAgKiBgZnVuY3Rpb24gKHtkYXRhLCBwcmlvcml0eX0pIHt9YCBhbmQgcmV0dXJucyBhIEJvb2xlYW4uXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc2F0dXJhdGVkIC0gYSBmdW5jdGlvbiB0aGF0IHNldHMgYSBjYWxsYmFjayB0aGF0IGlzXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIG51bWJlciBvZiBydW5uaW5nIHdvcmtlcnMgaGl0cyB0aGUgYGNvbmN1cnJlbmN5YCBsaW1pdCwgYW5kXG4gICAgICogZnVydGhlciB0YXNrcyB3aWxsIGJlIHF1ZXVlZC4gIElmIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkLCBgcS5zYXR1cmF0ZWQoKWBcbiAgICAgKiByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIG5leHQgb2NjdXJyZW5jZS5cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1bnNhdHVyYXRlZCAtIGEgZnVuY3Rpb24gdGhhdCBzZXRzIGEgY2FsbGJhY2sgdGhhdCBpc1xuICAgICAqIGNhbGxlZCB3aGVuIHRoZSBudW1iZXIgb2YgcnVubmluZyB3b3JrZXJzIGlzIGxlc3MgdGhhbiB0aGUgYGNvbmN1cnJlbmN5YCAmXG4gICAgICogYGJ1ZmZlcmAgbGltaXRzLCBhbmQgZnVydGhlciB0YXNrcyB3aWxsIG5vdCBiZSBxdWV1ZWQuIElmIHRoZSBjYWxsYmFjayBpc1xuICAgICAqIG9taXR0ZWQsIGBxLnVuc2F0dXJhdGVkKClgIHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgbmV4dCBvY2N1cnJlbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBidWZmZXIgLSBBIG1pbmltdW0gdGhyZXNob2xkIGJ1ZmZlciBpbiBvcmRlciB0byBzYXkgdGhhdFxuICAgICAqIHRoZSBgcXVldWVgIGlzIGB1bnNhdHVyYXRlZGAuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZW1wdHkgLSBhIGZ1bmN0aW9uIHRoYXQgc2V0cyBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkXG4gICAgICogd2hlbiB0aGUgbGFzdCBpdGVtIGZyb20gdGhlIGBxdWV1ZWAgaXMgZ2l2ZW4gdG8gYSBgd29ya2VyYC4gSWYgdGhlIGNhbGxiYWNrXG4gICAgICogaXMgb21pdHRlZCwgYHEuZW1wdHkoKWAgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBuZXh0IG9jY3VycmVuY2UuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZHJhaW4gLSBhIGZ1bmN0aW9uIHRoYXQgc2V0cyBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkXG4gICAgICogd2hlbiB0aGUgbGFzdCBpdGVtIGZyb20gdGhlIGBxdWV1ZWAgaGFzIHJldHVybmVkIGZyb20gdGhlIGB3b3JrZXJgLiBJZiB0aGVcbiAgICAgKiBjYWxsYmFjayBpcyBvbWl0dGVkLCBgcS5kcmFpbigpYCByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIG5leHQgb2NjdXJyZW5jZS5cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlcnJvciAtIGEgZnVuY3Rpb24gdGhhdCBzZXRzIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWRcbiAgICAgKiB3aGVuIGEgdGFzayBlcnJvcnMuIEhhcyB0aGUgc2lnbmF0dXJlIGBmdW5jdGlvbihlcnJvciwgdGFzaylgLiBJZiB0aGVcbiAgICAgKiBjYWxsYmFjayBpcyBvbWl0dGVkLCBgZXJyb3IoKWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZWplY3RzIG9uIHRoZSBuZXh0XG4gICAgICogZXJyb3IuXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBwYXVzZWQgLSBhIGJvb2xlYW4gZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIHF1ZXVlIGlzXG4gICAgICogaW4gYSBwYXVzZWQgc3RhdGUuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcGF1c2UgLSBhIGZ1bmN0aW9uIHRoYXQgcGF1c2VzIHRoZSBwcm9jZXNzaW5nIG9mIHRhc2tzXG4gICAgICogdW50aWwgYHJlc3VtZSgpYCBpcyBjYWxsZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5wYXVzZSgpYC5cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSByZXN1bWUgLSBhIGZ1bmN0aW9uIHRoYXQgcmVzdW1lcyB0aGUgcHJvY2Vzc2luZyBvZlxuICAgICAqIHF1ZXVlZCB0YXNrcyB3aGVuIHRoZSBxdWV1ZSBpcyBwYXVzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5yZXN1bWUoKWAuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0ga2lsbCAtIGEgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZSBgZHJhaW5gIGNhbGxiYWNrIGFuZFxuICAgICAqIGVtcHRpZXMgcmVtYWluaW5nIHRhc2tzIGZyb20gdGhlIHF1ZXVlIGZvcmNpbmcgaXQgdG8gZ28gaWRsZS4gTm8gbW9yZSB0YXNrc1xuICAgICAqIHNob3VsZCBiZSBwdXNoZWQgdG8gdGhlIHF1ZXVlIGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi4gSW52b2tlIHdpdGggYHF1ZXVlLmtpbGwoKWAuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHEgPSBhc3luYy5xdWV1ZSh3b3JrZXIsIDIpXG4gICAgICogcS5wdXNoKGl0ZW0xKVxuICAgICAqIHEucHVzaChpdGVtMilcbiAgICAgKiBxLnB1c2goaXRlbTMpXG4gICAgICogLy8gcXVldWVzIGFyZSBpdGVyYWJsZSwgc3ByZWFkIGludG8gYW4gYXJyYXkgdG8gaW5zcGVjdFxuICAgICAqIGNvbnN0IGl0ZW1zID0gWy4uLnFdIC8vIFtpdGVtMSwgaXRlbTIsIGl0ZW0zXVxuICAgICAqIC8vIG9yIHVzZSBmb3Igb2ZcbiAgICAgKiBmb3IgKGxldCBpdGVtIG9mIHEpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coaXRlbSlcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBxLmRyYWluKCgpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2FsbCBkb25lJylcbiAgICAgKiB9KVxuICAgICAqIC8vIG9yXG4gICAgICogYXdhaXQgcS5kcmFpbigpXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYHF1ZXVlYCBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIGBjb25jdXJyZW5jeWAuIFRhc2tzIGFkZGVkIHRvIHRoZVxuICAgICAqIGBxdWV1ZWAgYXJlIHByb2Nlc3NlZCBpbiBwYXJhbGxlbCAodXAgdG8gdGhlIGBjb25jdXJyZW5jeWAgbGltaXQpLiBJZiBhbGxcbiAgICAgKiBgd29ya2VyYHMgYXJlIGluIHByb2dyZXNzLCB0aGUgdGFzayBpcyBxdWV1ZWQgdW50aWwgb25lIGJlY29tZXMgYXZhaWxhYmxlLlxuICAgICAqIE9uY2UgYSBgd29ya2VyYCBjb21wbGV0ZXMgYSBgdGFza2AsIHRoYXQgYHRhc2tgJ3MgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQG5hbWUgcXVldWVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luYyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlZCB0YXNrLlxuICAgICAqIElmIHlvdSB3YW50IHRvIGhhbmRsZSBlcnJvcnMgZnJvbSBhbiBpbmRpdmlkdWFsIHRhc2ssIHBhc3MgYSBjYWxsYmFjayB0b1xuICAgICAqIGBxLnB1c2goKWAuIEludm9rZWQgd2l0aCAodGFzaywgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVuY3k9MV0gLSBBbiBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nIGhvdyBtYW55XG4gICAgICogYHdvcmtlcmAgZnVuY3Rpb25zIHNob3VsZCBiZSBydW4gaW4gcGFyYWxsZWwuICBJZiBvbWl0dGVkLCB0aGUgY29uY3VycmVuY3lcbiAgICAgKiBkZWZhdWx0cyB0byBgMWAuICBJZiB0aGUgY29uY3VycmVuY3kgaXMgYDBgLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gICAgICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5RdWV1ZU9iamVjdH0gQSBxdWV1ZSBvYmplY3QgdG8gbWFuYWdlIHRoZSB0YXNrcy4gQ2FsbGJhY2tzIGNhbiBiZVxuICAgICAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlXG4gICAgICogbGlmZWN5Y2xlIG9mIHRoZSBxdWV1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gY3JlYXRlIGEgcXVldWUgb2JqZWN0IHdpdGggY29uY3VycmVuY3kgMlxuICAgICAqIHZhciBxID0gYXN5bmMucXVldWUoZnVuY3Rpb24odGFzaywgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrLm5hbWUpO1xuICAgICAqICAgICBjYWxsYmFjaygpO1xuICAgICAqIH0sIDIpO1xuICAgICAqXG4gICAgICogLy8gYXNzaWduIGEgY2FsbGJhY2tcbiAgICAgKiBxLmRyYWluKGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnYWxsIGl0ZW1zIGhhdmUgYmVlbiBwcm9jZXNzZWQnKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyBvciBhd2FpdCB0aGUgZW5kXG4gICAgICogYXdhaXQgcS5kcmFpbigpXG4gICAgICpcbiAgICAgKiAvLyBhc3NpZ24gYW4gZXJyb3IgY2FsbGJhY2tcbiAgICAgKiBxLmVycm9yKGZ1bmN0aW9uKGVyciwgdGFzaykge1xuICAgICAqICAgICBjb25zb2xlLmVycm9yKCd0YXNrIGV4cGVyaWVuY2VkIGFuIGVycm9yJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgcXVldWVcbiAgICAgKiBxLnB1c2goe25hbWU6ICdmb28nfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpO1xuICAgICAqIH0pO1xuICAgICAqIC8vIGNhbGxiYWNrIGlzIG9wdGlvbmFsXG4gICAgICogcS5wdXNoKHtuYW1lOiAnYmFyJ30pO1xuICAgICAqXG4gICAgICogLy8gYWRkIHNvbWUgaXRlbXMgdG8gdGhlIHF1ZXVlIChiYXRjaC13aXNlKVxuICAgICAqIHEucHVzaChbe25hbWU6ICdiYXonfSx7bmFtZTogJ2JheSd9LHtuYW1lOiAnYmF4J31dLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgaXRlbScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gYWRkIHNvbWUgaXRlbXMgdG8gdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxuICAgICAqIHEudW5zaGlmdCh7bmFtZTogJ2Jhcid9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1ZXVlJDEgKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICAgICAgdmFyIF93b3JrZXIgPSB3cmFwQXN5bmMod29ya2VyKTtcbiAgICAgICAgcmV0dXJuIHF1ZXVlKChpdGVtcywgY2IpID0+IHtcbiAgICAgICAgICAgIF93b3JrZXIoaXRlbXNbMF0sIGNiKTtcbiAgICAgICAgfSwgY29uY3VycmVuY3ksIDEpO1xuICAgIH1cblxuICAgIC8vIEJpbmFyeSBtaW4taGVhcCBpbXBsZW1lbnRhdGlvbiB1c2VkIGZvciBwcmlvcml0eSBxdWV1ZS5cbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBpcyBzdGFibGUsIGkuZS4gcHVzaCB0aW1lIGlzIGNvbnNpZGVyZWQgZm9yIGVxdWFsIHByaW9yaXRpZXNcbiAgICBjbGFzcyBIZWFwIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLmhlYXAgPSBbXTtcbiAgICAgICAgICAgIHRoaXMucHVzaENvdW50ID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cblxuICAgICAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVhcC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBlbXB0eSAoKSB7XG4gICAgICAgICAgICB0aGlzLmhlYXAgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcGVyY1VwKGluZGV4KSB7XG4gICAgICAgICAgICBsZXQgcDtcblxuICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gMCAmJiBzbWFsbGVyKHRoaXMuaGVhcFtpbmRleF0sIHRoaXMuaGVhcFtwPXBhcmVudChpbmRleCldKSkge1xuICAgICAgICAgICAgICAgIGxldCB0ID0gdGhpcy5oZWFwW2luZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYXBbaW5kZXhdID0gdGhpcy5oZWFwW3BdO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhcFtwXSA9IHQ7XG5cbiAgICAgICAgICAgICAgICBpbmRleCA9IHA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwZXJjRG93bihpbmRleCkge1xuICAgICAgICAgICAgbGV0IGw7XG5cbiAgICAgICAgICAgIHdoaWxlICgobD1sZWZ0Q2hpKGluZGV4KSkgPCB0aGlzLmhlYXAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGwrMSA8IHRoaXMuaGVhcC5sZW5ndGggJiYgc21hbGxlcih0aGlzLmhlYXBbbCsxXSwgdGhpcy5oZWFwW2xdKSkge1xuICAgICAgICAgICAgICAgICAgICBsID0gbCsxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzbWFsbGVyKHRoaXMuaGVhcFtpbmRleF0sIHRoaXMuaGVhcFtsXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHQgPSB0aGlzLmhlYXBbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhcFtpbmRleF0gPSB0aGlzLmhlYXBbbF07XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFwW2xdID0gdDtcblxuICAgICAgICAgICAgICAgIGluZGV4ID0gbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2gobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wdXNoQ291bnQgPSArK3RoaXMucHVzaENvdW50O1xuICAgICAgICAgICAgdGhpcy5oZWFwLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB0aGlzLnBlcmNVcCh0aGlzLmhlYXAubGVuZ3RoLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdW5zaGlmdChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFwLnB1c2gobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzaGlmdCgpIHtcbiAgICAgICAgICAgIGxldCBbdG9wXSA9IHRoaXMuaGVhcDtcblxuICAgICAgICAgICAgdGhpcy5oZWFwWzBdID0gdGhpcy5oZWFwW3RoaXMuaGVhcC5sZW5ndGgtMV07XG4gICAgICAgICAgICB0aGlzLmhlYXAucG9wKCk7XG4gICAgICAgICAgICB0aGlzLnBlcmNEb3duKDApO1xuXG4gICAgICAgICAgICByZXR1cm4gdG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9BcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4udGhpc107XG4gICAgICAgIH1cblxuICAgICAgICAqW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmhlYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmhlYXBbaV0uZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW92ZSAodGVzdEZuKSB7XG4gICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaGVhcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdGVzdEZuKHRoaXMuaGVhcFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFwW2pdID0gdGhpcy5oZWFwW2ldO1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmhlYXAuc3BsaWNlKGopO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyZW50KHRoaXMuaGVhcC5sZW5ndGgtMSk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJjRG93bihpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZWZ0Q2hpKGkpIHtcbiAgICAgICAgcmV0dXJuIChpPDwxKSsxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcmVudChpKSB7XG4gICAgICAgIHJldHVybiAoKGkrMSk+PjEpLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc21hbGxlcih4LCB5KSB7XG4gICAgICAgIGlmICh4LnByaW9yaXR5ICE9PSB5LnByaW9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4geC5wcmlvcml0eSA8IHkucHJpb3JpdHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geC5wdXNoQ291bnQgPCB5LnB1c2hDb3VudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFthc3luYy5xdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfSBvbmx5IHRhc2tzIGFyZSBhc3NpZ25lZCBhIHByaW9yaXR5IGFuZFxuICAgICAqIGNvbXBsZXRlZCBpbiBhc2NlbmRpbmcgcHJpb3JpdHkgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAbmFtZSBwcmlvcml0eVF1ZXVlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMucXVldWVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX1cbiAgICAgKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luYyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlZCB0YXNrLlxuICAgICAqIElmIHlvdSB3YW50IHRvIGhhbmRsZSBlcnJvcnMgZnJvbSBhbiBpbmRpdmlkdWFsIHRhc2ssIHBhc3MgYSBjYWxsYmFjayB0b1xuICAgICAqIGBxLnB1c2goKWAuXG4gICAgICogSW52b2tlZCB3aXRoICh0YXNrLCBjYWxsYmFjaykuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmN1cnJlbmN5IC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueSBgd29ya2VyYFxuICAgICAqIGZ1bmN0aW9ucyBzaG91bGQgYmUgcnVuIGluIHBhcmFsbGVsLiAgSWYgb21pdHRlZCwgdGhlIGNvbmN1cnJlbmN5IGRlZmF1bHRzIHRvXG4gICAgICogYDFgLiAgSWYgdGhlIGNvbmN1cnJlbmN5IGlzIGAwYCwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICAgICAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuUXVldWVPYmplY3R9IEEgcHJpb3JpdHlRdWV1ZSBvYmplY3QgdG8gbWFuYWdlIHRoZSB0YXNrcy4gVGhlcmUgYXJlIHRocmVlXG4gICAgICogZGlmZmVyZW5jZXMgYmV0d2VlbiBgcXVldWVgIGFuZCBgcHJpb3JpdHlRdWV1ZWAgb2JqZWN0czpcbiAgICAgKiAqIGBwdXNoKHRhc2ssIHByaW9yaXR5LCBbY2FsbGJhY2tdKWAgLSBgcHJpb3JpdHlgIHNob3VsZCBiZSBhIG51bWJlci4gSWYgYW5cbiAgICAgKiAgIGFycmF5IG9mIGB0YXNrc2AgaXMgZ2l2ZW4sIGFsbCB0YXNrcyB3aWxsIGJlIGFzc2lnbmVkIHRoZSBzYW1lIHByaW9yaXR5LlxuICAgICAqICogYHB1c2hBc3luYyh0YXNrLCBwcmlvcml0eSwgW2NhbGxiYWNrXSlgIC0gdGhlIHNhbWUgYXMgYHByaW9yaXR5UXVldWUucHVzaGAsXG4gICAgICogICBleGNlcHQgdGhpcyByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgaWYgYW4gZXJyb3Igb2NjdXJzLlxuICAgICAqICogVGhlIGB1bnNoaWZ0YCBhbmQgYHVuc2hpZnRBc3luY2AgbWV0aG9kcyB3ZXJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJpb3JpdHlRdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYSBub3JtYWwgcXVldWVcbiAgICAgICAgdmFyIHEgPSBxdWV1ZSQxKHdvcmtlciwgY29uY3VycmVuY3kpO1xuXG4gICAgICAgIHZhciB7XG4gICAgICAgICAgICBwdXNoLFxuICAgICAgICAgICAgcHVzaEFzeW5jXG4gICAgICAgIH0gPSBxO1xuXG4gICAgICAgIHEuX3Rhc2tzID0gbmV3IEhlYXAoKTtcbiAgICAgICAgcS5fY3JlYXRlVGFza0l0ZW0gPSAoe2RhdGEsIHByaW9yaXR5fSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVEYXRhSXRlbXModGFza3MsIHByaW9yaXR5KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFza3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtkYXRhOiB0YXNrcywgcHJpb3JpdHl9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhc2tzLm1hcChkYXRhID0+IHsgcmV0dXJuIHtkYXRhLCBwcmlvcml0eX07IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3ZlcnJpZGUgcHVzaCB0byBhY2NlcHQgc2Vjb25kIHBhcmFtZXRlciByZXByZXNlbnRpbmcgcHJpb3JpdHlcbiAgICAgICAgcS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgcHJpb3JpdHkgPSAwLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHB1c2goY3JlYXRlRGF0YUl0ZW1zKGRhdGEsIHByaW9yaXR5KSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuXG4gICAgICAgIHEucHVzaEFzeW5jID0gZnVuY3Rpb24oZGF0YSwgcHJpb3JpdHkgPSAwLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHB1c2hBc3luYyhjcmVhdGVEYXRhSXRlbXMoZGF0YSwgcHJpb3JpdHkpLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVtb3ZlIHVuc2hpZnQgZnVuY3Rpb25zXG4gICAgICAgIGRlbGV0ZSBxLnVuc2hpZnQ7XG4gICAgICAgIGRlbGV0ZSBxLnVuc2hpZnRBc3luYztcblxuICAgICAgICByZXR1cm4gcTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBgdGFza3NgIGFycmF5IG9mIGZ1bmN0aW9ucyBpbiBwYXJhbGxlbCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZVxuICAgICAqIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIE9uY2UgYW55IG9mIHRoZSBgdGFza3NgIGNvbXBsZXRlIG9yIHBhc3MgYW5cbiAgICAgKiBlcnJvciB0byBpdHMgY2FsbGJhY2ssIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkLiBJdCdzXG4gICAgICogZXF1aXZhbGVudCB0byBgUHJvbWlzZS5yYWNlKClgLlxuICAgICAqXG4gICAgICogQG5hbWUgcmFjZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0YXNrcyAtIEFuIGFycmF5IGNvbnRhaW5pbmcgW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn1cbiAgICAgKiB0byBydW4uIEVhY2ggZnVuY3Rpb24gY2FuIGNvbXBsZXRlIHdpdGggYW4gb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFueSBvZiB0aGUgZnVuY3Rpb25zIGhhdmVcbiAgICAgKiBjb21wbGV0ZWQuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhbiBlcnJvciBvciByZXN1bHQgZnJvbSB0aGUgZmlyc3QgZnVuY3Rpb24gdGhhdFxuICAgICAqIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGFzeW5jLnJhY2UoW1xuICAgICAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gICAgICogICAgICAgICB9LCAyMDApO1xuICAgICAqICAgICB9LFxuICAgICAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gICAgICogICAgICAgICB9LCAxMDApO1xuICAgICAqICAgICB9XG4gICAgICogXSxcbiAgICAgKiAvLyBtYWluIGNhbGxiYWNrXG4gICAgICogZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgKiAgICAgLy8gdGhlIHJlc3VsdCB3aWxsIGJlIGVxdWFsIHRvICd0d28nIGFzIGl0IGZpbmlzaGVzIGVhcmxpZXJcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYWNlKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFza3MpKSByZXR1cm4gY2FsbGJhY2sobmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gcmFjZSBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpKTtcbiAgICAgICAgaWYgKCF0YXNrcy5sZW5ndGgpIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhc2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgd3JhcEFzeW5jKHRhc2tzW2ldKShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmFjZSQxID0gYXdhaXRpZnkocmFjZSwgMik7XG5cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIFtgcmVkdWNlYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlZHVjZX0sIG9ubHkgb3BlcmF0ZXMgb24gYGFycmF5YCBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAqXG4gICAgICogQG5hbWUgcmVkdWNlUmlnaHRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAc2VlIFthc3luYy5yZWR1Y2Vde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWR1Y2V9XG4gICAgICogQGFsaWFzIGZvbGRyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsqfSBtZW1vIC0gVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiBhcHBsaWVkIHRvIGVhY2ggaXRlbSBpbiB0aGVcbiAgICAgKiBhcnJheSB0byBwcm9kdWNlIHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHJlZHVjdGlvbi5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgbmV4dCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLlxuICAgICAqIElmIHRoZSBpdGVyYXRlZSBjb21wbGV0ZXMgd2l0aCBhbiBlcnJvciwgdGhlIHJlZHVjdGlvbiBpcyBzdG9wcGVkIGFuZCB0aGVcbiAgICAgKiBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICAgICAqIEludm9rZWQgd2l0aCAobWVtbywgaXRlbSwgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gICAgICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IGlzIHRoZSByZWR1Y2VkIHZhbHVlLiBJbnZva2VkIHdpdGhcbiAgICAgKiAoZXJyLCByZXN1bHQpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0IChhcnJheSwgbWVtbywgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXZlcnNlZCA9IFsuLi5hcnJheV0ucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gcmVkdWNlJDEocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdGVlLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgdGhlIGFzeW5jIGZ1bmN0aW9uIGluIGFub3RoZXIgZnVuY3Rpb24gdGhhdCBhbHdheXMgY29tcGxldGVzIHdpdGggYVxuICAgICAqIHJlc3VsdCBvYmplY3QsIGV2ZW4gd2hlbiBpdCBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBUaGUgcmVzdWx0IG9iamVjdCBoYXMgZWl0aGVyIHRoZSBwcm9wZXJ0eSBgZXJyb3JgIG9yIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZWZsZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHlvdSB3YW50IHRvIHdyYXBcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gQSBmdW5jdGlvbiB0aGF0IGFsd2F5cyBwYXNzZXMgbnVsbCB0byBpdCdzIGNhbGxiYWNrIGFzXG4gICAgICogdGhlIGVycm9yLiBUaGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjayB3aWxsIGJlIGFuIGBvYmplY3RgIHdpdGhcbiAgICAgKiBlaXRoZXIgYW4gYGVycm9yYCBvciBhIGB2YWx1ZWAgcHJvcGVydHkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGFzeW5jLnBhcmFsbGVsKFtcbiAgICAgKiAgICAgYXN5bmMucmVmbGVjdChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgLy8gZG8gc29tZSBzdHVmZiAuLi5cbiAgICAgKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAgICAgKiAgICAgfSksXG4gICAgICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIC8vIGRvIHNvbWUgbW9yZSBzdHVmZiBidXQgZXJyb3IgLi4uXG4gICAgICogICAgICAgICBjYWxsYmFjaygnYmFkIHN0dWZmIGhhcHBlbmVkJyk7XG4gICAgICogICAgIH0pLFxuICAgICAqICAgICBhc3luYy5yZWZsZWN0KGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICAvLyBkbyBzb21lIG1vcmUgc3R1ZmYgLi4uXG4gICAgICogICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gICAgICogICAgIH0pXG4gICAgICogXSxcbiAgICAgKiAvLyBvcHRpb25hbCBjYWxsYmFja1xuICAgICAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAqICAgICAvLyB2YWx1ZXNcbiAgICAgKiAgICAgLy8gcmVzdWx0c1swXS52YWx1ZSA9ICdvbmUnXG4gICAgICogICAgIC8vIHJlc3VsdHNbMV0uZXJyb3IgPSAnYmFkIHN0dWZmIGhhcHBlbmVkJ1xuICAgICAqICAgICAvLyByZXN1bHRzWzJdLnZhbHVlID0gJ3R3bydcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWZsZWN0KGZuKSB7XG4gICAgICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pO1xuICAgICAgICByZXR1cm4gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiByZWZsZWN0T24oYXJncywgcmVmbGVjdENhbGxiYWNrKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goKGVycm9yLCAuLi5jYkFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmV0VmFsID0ge307XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFZhbC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2JBcmdzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjYkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYkFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZV0gPSBjYkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0VmFsLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlZmxlY3RDYWxsYmFjayhudWxsLCByZXRWYWwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBfZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYW4gYXJyYXkgb3IgYW4gb2JqZWN0IG9mIGZ1bmN0aW9ucyB3aXRoIGByZWZsZWN0YC5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJlZmxlY3RBbGxcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAc2VlIFthc3luYy5yZWZsZWN0XXtAbGluayBtb2R1bGU6VXRpbHMucmVmbGVjdH1cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fEl0ZXJhYmxlfSB0YXNrcyAtIFRoZSBjb2xsZWN0aW9uIG9mXG4gICAgICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gd3JhcCBpbiBgYXN5bmMucmVmbGVjdGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGFzeW5jIGZ1bmN0aW9ucywgZWFjaCB3cmFwcGVkIGluXG4gICAgICogYGFzeW5jLnJlZmxlY3RgXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGxldCB0YXNrcyA9IFtcbiAgICAgKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICAgICAqICAgICAgICAgfSwgMjAwKTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIC8vIGRvIHNvbWUgbW9yZSBzdHVmZiBidXQgZXJyb3IgLi4uXG4gICAgICogICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ2JhZCBzdHVmZiBoYXBwZW5lZCcpKTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpO1xuICAgICAqICAgICAgICAgfSwgMTAwKTtcbiAgICAgKiAgICAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBhc3luYy5wYXJhbGxlbChhc3luYy5yZWZsZWN0QWxsKHRhc2tzKSxcbiAgICAgKiAvLyBvcHRpb25hbCBjYWxsYmFja1xuICAgICAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAqICAgICAvLyB2YWx1ZXNcbiAgICAgKiAgICAgLy8gcmVzdWx0c1swXS52YWx1ZSA9ICdvbmUnXG4gICAgICogICAgIC8vIHJlc3VsdHNbMV0uZXJyb3IgPSBFcnJvcignYmFkIHN0dWZmIGhhcHBlbmVkJylcbiAgICAgKiAgICAgLy8gcmVzdWx0c1syXS52YWx1ZSA9ICd0d28nXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBhbiBleGFtcGxlIHVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5XG4gICAgICogbGV0IHRhc2tzID0ge1xuICAgICAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAgICAgKiAgICAgICAgIH0sIDIwMCk7XG4gICAgICogICAgIH0sXG4gICAgICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIGNhbGxiYWNrKCd0d28nKTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgdGhyZWU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpO1xuICAgICAqICAgICAgICAgfSwgMTAwKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBhc3luYy5wYXJhbGxlbChhc3luYy5yZWZsZWN0QWxsKHRhc2tzKSxcbiAgICAgKiAvLyBvcHRpb25hbCBjYWxsYmFja1xuICAgICAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAqICAgICAvLyB2YWx1ZXNcbiAgICAgKiAgICAgLy8gcmVzdWx0cy5vbmUudmFsdWUgPSAnb25lJ1xuICAgICAqICAgICAvLyByZXN1bHRzLnR3by5lcnJvciA9ICd0d28nXG4gICAgICogICAgIC8vIHJlc3VsdHMudGhyZWUudmFsdWUgPSAndGhyZWUnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVmbGVjdEFsbCh0YXNrcykge1xuICAgICAgICB2YXIgcmVzdWx0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFza3MpKSB7XG4gICAgICAgICAgICByZXN1bHRzID0gdGFza3MubWFwKHJlZmxlY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGFza3MpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZWZsZWN0LmNhbGwodGhpcywgdGFza3Nba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWplY3QoZWFjaGZuLCBhcnIsIF9pdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaXRlcmF0ZWUgPSB3cmFwQXN5bmMoX2l0ZXJhdGVlKTtcbiAgICAgICAgcmV0dXJuIF9maWx0ZXIoZWFjaGZuLCBhcnIsICh2YWx1ZSwgY2IpID0+IHtcbiAgICAgICAgICAgIGl0ZXJhdGVlKHZhbHVlLCAoZXJyLCB2KSA9PiB7XG4gICAgICAgICAgICAgICAgY2IoZXJyLCAhdik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9LiBSZW1vdmVzIHZhbHVlcyB0aGF0IHBhc3MgYW4gYGFzeW5jYCB0cnV0aCB0ZXN0LlxuICAgICAqXG4gICAgICogQG5hbWUgcmVqZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICAgICAqIGBjb2xsYC5cbiAgICAgKiBUaGUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyBgcmVzdWx0YC5cbiAgICAgKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICAgICAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gZGlyMSBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUxLnR4dCwgZmlsZTIudHh0XG4gICAgICogLy8gZGlyMiBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUzLnR4dCwgZmlsZTQudHh0XG4gICAgICogLy8gZGlyMyBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGU1LnR4dFxuICAgICAqXG4gICAgICogY29uc3QgZmlsZUxpc3QgPSBbJ2RpcjEvZmlsZTEudHh0JywnZGlyMi9maWxlMy50eHQnLCdkaXIzL2ZpbGU2LnR4dCddO1xuICAgICAqXG4gICAgICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGEgZmlsZSBleGlzdHNcbiAgICAgKiBmdW5jdGlvbiBmaWxlRXhpc3RzKGZpbGUsIGNhbGxiYWNrKSB7XG4gICAgICogICAgZnMuYWNjZXNzKGZpbGUsIGZzLmNvbnN0YW50cy5GX09LLCAoZXJyKSA9PiB7XG4gICAgICogICAgICAgIGNhbGxiYWNrKG51bGwsICFlcnIpO1xuICAgICAqICAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICAgICAqIGFzeW5jLnJlamVjdChmaWxlTGlzdCwgZmlsZUV4aXN0cywgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgICogICAgLy8gWyAnZGlyMy9maWxlNi50eHQnIF1cbiAgICAgKiAgICAvLyByZXN1bHRzIG5vdyBlcXVhbHMgYW4gYXJyYXkgb2YgdGhlIG5vbi1leGlzdGluZyBmaWxlc1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gVXNpbmcgUHJvbWlzZXNcbiAgICAgKiBhc3luYy5yZWplY3QoZmlsZUxpc3QsIGZpbGVFeGlzdHMpXG4gICAgICogLnRoZW4oIHJlc3VsdHMgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgLy8gWyAnZGlyMy9maWxlNi50eHQnIF1cbiAgICAgKiAgICAgLy8gcmVzdWx0cyBub3cgZXF1YWxzIGFuIGFycmF5IG9mIHRoZSBub24tZXhpc3RpbmcgZmlsZXNcbiAgICAgKiB9KS5jYXRjaCggZXJyID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gICAgICogYXN5bmMgKCkgPT4ge1xuICAgICAqICAgICB0cnkge1xuICAgICAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5yZWplY3QoZmlsZUxpc3QsIGZpbGVFeGlzdHMpO1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gICAgICogICAgICAgICAvLyBbICdkaXIzL2ZpbGU2LnR4dCcgXVxuICAgICAqICAgICAgICAgLy8gcmVzdWx0cyBub3cgZXF1YWxzIGFuIGFycmF5IG9mIHRoZSBub24tZXhpc3RpbmcgZmlsZXNcbiAgICAgKiAgICAgfVxuICAgICAqICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0JDEgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVhY2hPZiQxLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG4gICAgfVxuICAgIHZhciByZWplY3QkMiA9IGF3YWl0aWZ5KHJlamVjdCQxLCAzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFtgcmVqZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlamVjdH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gICAgICogdGltZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJlamVjdExpbWl0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMucmVqZWN0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVqZWN0fVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAgICAgKiBgY29sbGAuXG4gICAgICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuXG4gICAgICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAgICAgKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0TGltaXQgKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlYWNoT2ZMaW1pdChsaW1pdCksIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbiAgICB9XG4gICAgdmFyIHJlamVjdExpbWl0JDEgPSBhd2FpdGlmeShyZWplY3RMaW1pdCwgNCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBhcyBbYHJlamVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJlamVjdFNlcmllc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLnJlamVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlamVjdH1cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAgICAgKiBgY29sbGAuXG4gICAgICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuXG4gICAgICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAgICAgKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0U2VyaWVzIChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlYWNoT2ZTZXJpZXMkMSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxuICAgIH1cbiAgICB2YXIgcmVqZWN0U2VyaWVzJDEgPSBhd2FpdGlmeShyZWplY3RTZXJpZXMsIDMpO1xuXG4gICAgZnVuY3Rpb24gY29uc3RhbnQkMSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gZ2V0IGEgc3VjY2Vzc2Z1bCByZXNwb25zZSBmcm9tIGB0YXNrYCBubyBtb3JlIHRoYW4gYHRpbWVzYCB0aW1lc1xuICAgICAqIGJlZm9yZSByZXR1cm5pbmcgYW4gZXJyb3IuIElmIHRoZSB0YXNrIGlzIHN1Y2Nlc3NmdWwsIHRoZSBgY2FsbGJhY2tgIHdpbGwgYmVcbiAgICAgKiBwYXNzZWQgdGhlIHJlc3VsdCBvZiB0aGUgc3VjY2Vzc2Z1bCB0YXNrLiBJZiBhbGwgYXR0ZW1wdHMgZmFpbCwgdGhlIGNhbGxiYWNrXG4gICAgICogd2lsbCBiZSBwYXNzZWQgdGhlIGVycm9yIGFuZCByZXN1bHQgKGlmIGFueSkgb2YgdGhlIGZpbmFsIGF0dGVtcHQuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXRyeVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAgICAgKiBAc2VlIFthc3luYy5yZXRyeWFibGVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5yZXRyeWFibGV9XG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBbb3B0cyA9IHt0aW1lczogNSwgaW50ZXJ2YWw6IDB9fCA1XSAtIENhbiBiZSBlaXRoZXIgYW5cbiAgICAgKiBvYmplY3Qgd2l0aCBgdGltZXNgIGFuZCBgaW50ZXJ2YWxgIG9yIGEgbnVtYmVyLlxuICAgICAqICogYHRpbWVzYCAtIFRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgdG8gbWFrZSBiZWZvcmUgZ2l2aW5nIHVwLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgIGlzIGA1YC5cbiAgICAgKiAqIGBpbnRlcnZhbGAgLSBUaGUgdGltZSB0byB3YWl0IGJldHdlZW4gcmV0cmllcywgaW4gbWlsbGlzZWNvbmRzLiAgVGhlXG4gICAgICogICBkZWZhdWx0IGlzIGAwYC4gVGhlIGludGVydmFsIG1heSBhbHNvIGJlIHNwZWNpZmllZCBhcyBhIGZ1bmN0aW9uIG9mIHRoZVxuICAgICAqICAgcmV0cnkgY291bnQgKHNlZSBleGFtcGxlKS5cbiAgICAgKiAqIGBlcnJvckZpbHRlcmAgLSBBbiBvcHRpb25hbCBzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IGlzIGludm9rZWQgb25cbiAgICAgKiAgIGVycm9uZW91cyByZXN1bHQuIElmIGl0IHJldHVybnMgYHRydWVgIHRoZSByZXRyeSBhdHRlbXB0cyB3aWxsIGNvbnRpbnVlO1xuICAgICAqICAgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGUgcmV0cnkgZmxvdyBpcyBhYm9ydGVkIHdpdGggdGhlIGN1cnJlbnRcbiAgICAgKiAgIGF0dGVtcHQncyBlcnJvciBhbmQgcmVzdWx0IGJlaW5nIHJldHVybmVkIHRvIHRoZSBmaW5hbCBjYWxsYmFjay5cbiAgICAgKiAgIEludm9rZWQgd2l0aCAoZXJyKS5cbiAgICAgKiAqIElmIGBvcHRzYCBpcyBhIG51bWJlciwgdGhlIG51bWJlciBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSxcbiAgICAgKiAgIHdpdGggdGhlIGRlZmF1bHQgaW50ZXJ2YWwgb2YgYDBgLlxuICAgICAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGFzayAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIHJldHJ5LlxuICAgICAqIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGVcbiAgICAgKiB0YXNrIGhhcyBzdWNjZWVkZWQsIG9yIGFmdGVyIHRoZSBmaW5hbCBmYWlsZWQgYXR0ZW1wdC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgXG4gICAgICogYW5kIGByZXN1bHRgIGFyZ3VtZW50cyBvZiB0aGUgbGFzdCBhdHRlbXB0IGF0IGNvbXBsZXRpbmcgdGhlIGB0YXNrYC4gSW52b2tlZFxuICAgICAqIHdpdGggKGVyciwgcmVzdWx0cykuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBwcm92aWRlZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgcmV0cnlgIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIGFzIGEgc3RhbmQtYWxvbmUgY29udHJvbCBmbG93IGJ5IHBhc3NpbmdcbiAgICAgKiAvLyBhIGNhbGxiYWNrLCBhcyBzaG93biBiZWxvdzpcbiAgICAgKlxuICAgICAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCAzIHRpbWVzXG4gICAgICogYXN5bmMucmV0cnkoMywgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgMyB0aW1lcywgd2FpdGluZyAyMDAgbXMgYmV0d2VlbiBlYWNoIHJldHJ5XG4gICAgICogYXN5bmMucmV0cnkoe3RpbWVzOiAzLCBpbnRlcnZhbDogMjAwfSwgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgMTAgdGltZXMgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICogLy8gKGkuZS4gaW50ZXJ2YWxzIG9mIDEwMCwgMjAwLCA0MDAsIDgwMCwgMTYwMCwgLi4uIG1pbGxpc2Vjb25kcylcbiAgICAgKiBhc3luYy5yZXRyeSh7XG4gICAgICogICB0aW1lczogMTAsXG4gICAgICogICBpbnRlcnZhbDogZnVuY3Rpb24ocmV0cnlDb3VudCkge1xuICAgICAqICAgICByZXR1cm4gNTAgKiBNYXRoLnBvdygyLCByZXRyeUNvdW50KTtcbiAgICAgKiAgIH1cbiAgICAgKiB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCB0aGUgZGVmYXVsdCA1IHRpbWVzIG5vIGRlbGF5IGJldHdlZW4gZWFjaCByZXRyeVxuICAgICAqIGFzeW5jLnJldHJ5KGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIG9ubHkgd2hlbiBlcnJvciBjb25kaXRpb24gc2F0aXNmaWVzLCBhbGwgb3RoZXJcbiAgICAgKiAvLyBlcnJvcnMgd2lsbCBhYm9ydCB0aGUgcmV0cnkgY29udHJvbCBmbG93IGFuZCByZXR1cm4gdG8gZmluYWwgY2FsbGJhY2tcbiAgICAgKiBhc3luYy5yZXRyeSh7XG4gICAgICogICBlcnJvckZpbHRlcjogZnVuY3Rpb24oZXJyKSB7XG4gICAgICogICAgIHJldHVybiBlcnIubWVzc2FnZSA9PT0gJ1RlbXBvcmFyeSBlcnJvcic7IC8vIG9ubHkgcmV0cnkgb24gYSBzcGVjaWZpYyBlcnJvclxuICAgICAqICAgfVxuICAgICAqIH0sIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gdG8gcmV0cnkgaW5kaXZpZHVhbCBtZXRob2RzIHRoYXQgYXJlIG5vdCBhcyByZWxpYWJsZSB3aXRoaW4gb3RoZXJcbiAgICAgKiAvLyBjb250cm9sIGZsb3cgZnVuY3Rpb25zLCB1c2UgdGhlIGByZXRyeWFibGVgIHdyYXBwZXI6XG4gICAgICogYXN5bmMuYXV0byh7XG4gICAgICogICAgIHVzZXJzOiBhcGkuZ2V0VXNlcnMuYmluZChhcGkpLFxuICAgICAqICAgICBwYXltZW50czogYXN5bmMucmV0cnlhYmxlKDMsIGFwaS5nZXRQYXltZW50cy5iaW5kKGFwaSkpXG4gICAgICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRzXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdCBERUZBVUxUX1RJTUVTID0gNTtcbiAgICBjb25zdCBERUZBVUxUX0lOVEVSVkFMID0gMDtcblxuICAgIGZ1bmN0aW9uIHJldHJ5KG9wdHMsIHRhc2ssIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdGltZXM6IERFRkFVTFRfVElNRVMsXG4gICAgICAgICAgICBpbnRlcnZhbEZ1bmM6IGNvbnN0YW50JDEoREVGQVVMVF9JTlRFUlZBTClcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMgJiYgdHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGFzayB8fCBwcm9taXNlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIHRhc2sgPSBvcHRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VUaW1lcyhvcHRpb25zLCBvcHRzKTtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgcHJvbWlzZUNhbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRhc2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIGZvciBhc3luYy5yZXRyeVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfdGFzayA9IHdyYXBBc3luYyh0YXNrKTtcblxuICAgICAgICB2YXIgYXR0ZW1wdCA9IDE7XG4gICAgICAgIGZ1bmN0aW9uIHJldHJ5QXR0ZW1wdCgpIHtcbiAgICAgICAgICAgIF90YXNrKChlcnIsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYgKGVyciAmJiBhdHRlbXB0KysgPCBvcHRpb25zLnRpbWVzICYmXG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2Ygb3B0aW9ucy5lcnJvckZpbHRlciAhPSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmVycm9yRmlsdGVyKGVycikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmV0cnlBdHRlbXB0LCBvcHRpb25zLmludGVydmFsRnVuYyhhdHRlbXB0IC0gMSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXRyeUF0dGVtcHQoKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrW1BST01JU0VfU1lNQk9MXVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVGltZXMoYWNjLCB0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFjYy50aW1lcyA9ICt0LnRpbWVzIHx8IERFRkFVTFRfVElNRVM7XG5cbiAgICAgICAgICAgIGFjYy5pbnRlcnZhbEZ1bmMgPSB0eXBlb2YgdC5pbnRlcnZhbCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgdC5pbnRlcnZhbCA6XG4gICAgICAgICAgICAgICAgY29uc3RhbnQkMSgrdC5pbnRlcnZhbCB8fCBERUZBVUxUX0lOVEVSVkFMKTtcblxuICAgICAgICAgICAgYWNjLmVycm9yRmlsdGVyID0gdC5lcnJvckZpbHRlcjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhY2MudGltZXMgPSArdCB8fCBERUZBVUxUX1RJTUVTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgZm9yIGFzeW5jLnJldHJ5XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBjbG9zZSByZWxhdGl2ZSBvZiBbYHJldHJ5YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnJldHJ5fS4gIFRoaXMgbWV0aG9kXG4gICAgICogd3JhcHMgYSB0YXNrIGFuZCBtYWtlcyBpdCByZXRyeWFibGUsIHJhdGhlciB0aGFuIGltbWVkaWF0ZWx5IGNhbGxpbmcgaXRcbiAgICAgKiB3aXRoIHJldHJpZXMuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXRyeWFibGVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAc2VlIFthc3luYy5yZXRyeV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnJldHJ5fVxuICAgICAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRzID0ge3RpbWVzOiA1LCBpbnRlcnZhbDogMH18IDVdIC0gb3B0aW9uYWxcbiAgICAgKiBvcHRpb25zLCBleGFjdGx5IHRoZSBzYW1lIGFzIGZyb20gYHJldHJ5YCwgZXhjZXB0IGZvciBhIGBvcHRzLmFyaXR5YCB0aGF0XG4gICAgICogaXMgdGhlIGFyaXR5IG9mIHRoZSBgdGFza2AgZnVuY3Rpb24sIGRlZmF1bHRpbmcgdG8gYHRhc2subGVuZ3RoYFxuICAgICAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGFzayAtIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSByZXR1cm5lZCB3cmFwcGVyLlxuICAgICAqIEludm9rZWQgd2l0aCAoLi4uYXJncywgY2FsbGJhY2spLlxuICAgICAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvbiwgd2hpY2ggd2hlbiBpbnZva2VkLCB3aWxsXG4gICAgICogcmV0cnkgb24gYW4gZXJyb3IsIGJhc2VkIG9uIHRoZSBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiBgb3B0c2AuXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGFjY2VwdCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIGB0YXNrYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXN5bmMuYXV0byh7XG4gICAgICogICAgIGRlcDE6IGFzeW5jLnJldHJ5YWJsZSgzLCBnZXRGcm9tRmxha3lTZXJ2aWNlKSxcbiAgICAgKiAgICAgcHJvY2VzczogW1wiZGVwMVwiLCBhc3luYy5yZXRyeWFibGUoMywgZnVuY3Rpb24gKHJlc3VsdHMsIGNiKSB7XG4gICAgICogICAgICAgICBtYXliZVByb2Nlc3NEYXRhKHJlc3VsdHMuZGVwMSwgY2IpO1xuICAgICAqICAgICB9KV1cbiAgICAgKiB9LCBjYWxsYmFjayk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cnlhYmxlIChvcHRzLCB0YXNrKSB7XG4gICAgICAgIGlmICghdGFzaykge1xuICAgICAgICAgICAgdGFzayA9IG9wdHM7XG4gICAgICAgICAgICBvcHRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXJpdHkgPSAob3B0cyAmJiBvcHRzLmFyaXR5KSB8fCB0YXNrLmxlbmd0aDtcbiAgICAgICAgaWYgKGlzQXN5bmModGFzaykpIHtcbiAgICAgICAgICAgIGFyaXR5ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF90YXNrID0gd3JhcEFzeW5jKHRhc2spO1xuICAgICAgICByZXR1cm4gaW5pdGlhbFBhcmFtcygoYXJncywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IGFyaXR5IC0gMSB8fCBjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHByb21pc2VDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdGFza0ZuKGNiKSB7XG4gICAgICAgICAgICAgICAgX3Rhc2soLi4uYXJncywgY2IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0cykgcmV0cnkob3B0cywgdGFza0ZuLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBlbHNlIHJldHJ5KHRhc2tGbiwgY2FsbGJhY2spO1xuXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tbUFJPTUlTRV9TWU1CT0xdXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1biB0aGUgZnVuY3Rpb25zIGluIHRoZSBgdGFza3NgIGNvbGxlY3Rpb24gaW4gc2VyaWVzLCBlYWNoIG9uZSBydW5uaW5nIG9uY2VcbiAgICAgKiB0aGUgcHJldmlvdXMgZnVuY3Rpb24gaGFzIGNvbXBsZXRlZC4gSWYgYW55IGZ1bmN0aW9ucyBpbiB0aGUgc2VyaWVzIHBhc3MgYW5cbiAgICAgKiBlcnJvciB0byBpdHMgY2FsbGJhY2ssIG5vIG1vcmUgZnVuY3Rpb25zIGFyZSBydW4sIGFuZCBgY2FsbGJhY2tgIGlzXG4gICAgICogaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIHZhbHVlIG9mIHRoZSBlcnJvci4gT3RoZXJ3aXNlLCBgY2FsbGJhY2tgXG4gICAgICogcmVjZWl2ZXMgYW4gYXJyYXkgb2YgcmVzdWx0cyB3aGVuIGB0YXNrc2AgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHVzZSBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gRWFjaCBwcm9wZXJ0eSB3aWxsXG4gICAgICogYmUgcnVuIGFzIGEgZnVuY3Rpb24sIGFuZCB0aGUgcmVzdWx0cyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZmluYWwgYGNhbGxiYWNrYFxuICAgICAqIGFzIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBUaGlzIGNhbiBiZSBhIG1vcmUgcmVhZGFibGUgd2F5IG9mIGhhbmRsaW5nXG4gICAgICogIHJlc3VsdHMgZnJvbSB7QGxpbmsgYXN5bmMuc2VyaWVzfS5cbiAgICAgKlxuICAgICAqICoqTm90ZSoqIHRoYXQgd2hpbGUgbWFueSBpbXBsZW1lbnRhdGlvbnMgcHJlc2VydmUgdGhlIG9yZGVyIG9mIG9iamVjdFxuICAgICAqIHByb3BlcnRpZXMsIHRoZSBbRUNNQVNjcmlwdCBMYW5ndWFnZSBTcGVjaWZpY2F0aW9uXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOC42KVxuICAgICAqIGV4cGxpY2l0bHkgc3RhdGVzIHRoYXRcbiAgICAgKlxuICAgICAqID4gVGhlIG1lY2hhbmljcyBhbmQgb3JkZXIgb2YgZW51bWVyYXRpbmcgdGhlIHByb3BlcnRpZXMgaXMgbm90IHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFNvIGlmIHlvdSByZWx5IG9uIHRoZSBvcmRlciBpbiB3aGljaCB5b3VyIHNlcmllcyBvZiBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkLFxuICAgICAqIGFuZCB3YW50IHRoaXMgdG8gd29yayBvbiBhbGwgcGxhdGZvcm1zLCBjb25zaWRlciB1c2luZyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHNlcmllc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAgICAgKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBjb250YWluaW5nXG4gICAgICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuIGluIHNlcmllcy5cbiAgICAgKiBFYWNoIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2Ygb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gICAgICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5IChvciBvYmplY3QpXG4gICAgICogY29udGFpbmluZyBhbGwgdGhlIHJlc3VsdCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBgdGFza2AgY2FsbGJhY2tzLiBJbnZva2VkXG4gICAgICogd2l0aCAoZXJyLCByZXN1bHQpLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vVXNpbmcgQ2FsbGJhY2tzXG4gICAgICogYXN5bmMuc2VyaWVzKFtcbiAgICAgKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgICAgLy8gZG8gc29tZSBhc3luYyB0YXNrXG4gICAgICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICAgICAqICAgICAgICAgfSwgMjAwKTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgICAgLy8gdGhlbiBkbyBhbm90aGVyIGFzeW5jIHRhc2tcbiAgICAgKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gICAgICogICAgICAgICB9LCAxMDApO1xuICAgICAqICAgICB9XG4gICAgICogXSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAgICAqICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvIFsnb25lJywndHdvJ11cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgb2JqZWN0cyBpbnN0ZWFkIG9mIGFycmF5c1xuICAgICAqIGFzeW5jLnNlcmllcyh7XG4gICAgICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgICAgLy8gZG8gc29tZSBhc3luYyB0YXNrXG4gICAgICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMSk7XG4gICAgICogICAgICAgICB9LCAyMDApO1xuICAgICAqICAgICB9LFxuICAgICAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgICAgIC8vIHRoZW4gZG8gYW5vdGhlciBhc3luYyB0YXNrXG4gICAgICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7XG4gICAgICogICAgICAgICB9LCAxMDApO1xuICAgICAqICAgICB9XG4gICAgICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAgICAqICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvOiB7IG9uZTogMSwgdHdvOiAyIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vVXNpbmcgUHJvbWlzZXNcbiAgICAgKiBhc3luYy5zZXJpZXMoW1xuICAgICAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gICAgICogICAgICAgICB9LCAyMDApO1xuICAgICAqICAgICB9LFxuICAgICAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gICAgICogICAgICAgICB9LCAxMDApO1xuICAgICAqICAgICB9XG4gICAgICogXSkudGhlbihyZXN1bHRzID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gICAgICogICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG8gWydvbmUnLCd0d28nXVxuICAgICAqIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBhbiBleGFtcGxlIHVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5XG4gICAgICogYXN5bmMuc2VyaWVzKHtcbiAgICAgKiAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAgICAvLyBkbyBzb21lIGFzeW5jIHRhc2tcbiAgICAgKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTtcbiAgICAgKiAgICAgICAgIH0sIDIwMCk7XG4gICAgICogICAgIH0sXG4gICAgICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgICAgLy8gdGhlbiBkbyBhbm90aGVyIGFzeW5jIHRhc2tcbiAgICAgKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAyKTtcbiAgICAgKiAgICAgICAgIH0sIDEwMCk7XG4gICAgICogICAgIH1cbiAgICAgKiB9KS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0bzogeyBvbmU6IDEsIHR3bzogMiB9XG4gICAgICogfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vVXNpbmcgYXN5bmMvYXdhaXRcbiAgICAgKiBhc3luYyAoKSA9PiB7XG4gICAgICogICAgIHRyeSB7XG4gICAgICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLnNlcmllcyhbXG4gICAgICogICAgICAgICAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIC8vIGRvIHNvbWUgYXN5bmMgdGFza1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICAgICAqICAgICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAqICAgICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gZG8gYW5vdGhlciBhc3luYyB0YXNrXG4gICAgICogICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gICAgICogICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICogICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgXSk7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG8gWydvbmUnLCd0d28nXVxuICAgICAqICAgICB9XG4gICAgICogICAgIGNhdGNoIChlcnIpIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyBhbiBleGFtcGxlIHVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5XG4gICAgICogYXN5bmMgKCkgPT4ge1xuICAgICAqICAgICB0cnkge1xuICAgICAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5wYXJhbGxlbCh7XG4gICAgICogICAgICAgICAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgLy8gZG8gc29tZSBhc3luYyB0YXNrXG4gICAgICogICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTtcbiAgICAgKiAgICAgICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgKiAgICAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBkbyBhbm90aGVyIGFzeW5jIHRhc2tcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpO1xuICAgICAqICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAqICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgfSk7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG86IHsgb25lOiAxLCB0d286IDIgfVxuICAgICAqICAgICB9XG4gICAgICogICAgIGNhdGNoIChlcnIpIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXJpZXModGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBwYXJhbGxlbChlYWNoT2ZTZXJpZXMkMSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgYGNvbGxgIHNhdGlzZmllcyBhbiBhc3luYyB0ZXN0LlxuICAgICAqIElmIGFueSBpdGVyYXRlZSBjYWxsIHJldHVybnMgYHRydWVgLCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5XG4gICAgICogY2FsbGVkLlxuICAgICAqXG4gICAgICogQG5hbWUgc29tZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBhbGlhcyBhbnlcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbVxuICAgICAqIGluIHRoZSBjb2xsZWN0aW9ucyBpbiBwYXJhbGxlbC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIGByZXN1bHRgIHZhbHVlLlxuICAgICAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueVxuICAgICAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICAgICAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAgICAgKiB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gZGlyMSBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUxLnR4dCwgZmlsZTIudHh0XG4gICAgICogLy8gZGlyMiBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUzLnR4dCwgZmlsZTQudHh0XG4gICAgICogLy8gZGlyMyBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGU1LnR4dFxuICAgICAqIC8vIGRpcjQgZG9lcyBub3QgZXhpc3RcbiAgICAgKlxuICAgICAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBhIGZpbGUgZXhpc3RzXG4gICAgICogZnVuY3Rpb24gZmlsZUV4aXN0cyhmaWxlLCBjYWxsYmFjaykge1xuICAgICAqICAgIGZzLmFjY2VzcyhmaWxlLCBmcy5jb25zdGFudHMuRl9PSywgKGVycikgPT4ge1xuICAgICAqICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKTtcbiAgICAgKiAgICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyBjYWxsYmFja3NcbiAgICAgKiBhc3luYy5zb21lKFsnZGlyMS9taXNzaW5nLnR4dCcsJ2RpcjIvbWlzc2luZy50eHQnLCdkaXIzL2ZpbGU1LnR4dCddLCBmaWxlRXhpc3RzLFxuICAgICAqICAgIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogICAgICAgIC8vIHRydWVcbiAgICAgKiAgICAgICAgLy8gcmVzdWx0IGlzIHRydWUgc2luY2Ugc29tZSBmaWxlIGluIHRoZSBsaXN0IGV4aXN0c1xuICAgICAqICAgIH1cbiAgICAgKik7XG4gICAgICpcbiAgICAgKiBhc3luYy5zb21lKFsnZGlyMS9taXNzaW5nLnR4dCcsJ2RpcjIvbWlzc2luZy50eHQnLCdkaXI0L21pc3NpbmcudHh0J10sIGZpbGVFeGlzdHMsXG4gICAgICogICAgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgKiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgKiAgICAgICAgLy8gZmFsc2VcbiAgICAgKiAgICAgICAgLy8gcmVzdWx0IGlzIGZhbHNlIHNpbmNlIG5vbmUgb2YgdGhlIGZpbGVzIGV4aXN0c1xuICAgICAqICAgIH1cbiAgICAgKik7XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyBQcm9taXNlc1xuICAgICAqIGFzeW5jLnNvbWUoWydkaXIxL21pc3NpbmcudHh0JywnZGlyMi9taXNzaW5nLnR4dCcsJ2RpcjMvZmlsZTUudHh0J10sIGZpbGVFeGlzdHMpXG4gICAgICogLnRoZW4oIHJlc3VsdCA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogICAgIC8vIHRydWVcbiAgICAgKiAgICAgLy8gcmVzdWx0IGlzIHRydWUgc2luY2Ugc29tZSBmaWxlIGluIHRoZSBsaXN0IGV4aXN0c1xuICAgICAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogYXN5bmMuc29tZShbJ2RpcjEvbWlzc2luZy50eHQnLCdkaXIyL21pc3NpbmcudHh0JywnZGlyNC9taXNzaW5nLnR4dCddLCBmaWxlRXhpc3RzKVxuICAgICAqIC50aGVuKCByZXN1bHQgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAqICAgICAvLyBmYWxzZVxuICAgICAqICAgICAvLyByZXN1bHQgaXMgZmFsc2Ugc2luY2Ugbm9uZSBvZiB0aGUgZmlsZXMgZXhpc3RzXG4gICAgICogfSkuY2F0Y2goIGVyciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICAgICAqIGFzeW5jICgpID0+IHtcbiAgICAgKiAgICAgdHJ5IHtcbiAgICAgKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5zb21lKFsnZGlyMS9taXNzaW5nLnR4dCcsJ2RpcjIvbWlzc2luZy50eHQnLCdkaXIzL2ZpbGU1LnR4dCddLCBmaWxlRXhpc3RzKTtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogICAgICAgICAvLyB0cnVlXG4gICAgICogICAgICAgICAvLyByZXN1bHQgaXMgdHJ1ZSBzaW5jZSBzb21lIGZpbGUgaW4gdGhlIGxpc3QgZXhpc3RzXG4gICAgICogICAgIH1cbiAgICAgKiAgICAgY2F0Y2ggKGVycikge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGFzeW5jICgpID0+IHtcbiAgICAgKiAgICAgdHJ5IHtcbiAgICAgKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5zb21lKFsnZGlyMS9taXNzaW5nLnR4dCcsJ2RpcjIvbWlzc2luZy50eHQnLCdkaXI0L21pc3NpbmcudHh0J10sIGZpbGVFeGlzdHMpO1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgKiAgICAgICAgIC8vIGZhbHNlXG4gICAgICogICAgICAgICAvLyByZXN1bHQgaXMgZmFsc2Ugc2luY2Ugbm9uZSBvZiB0aGUgZmlsZXMgZXhpc3RzXG4gICAgICogICAgIH1cbiAgICAgKiAgICAgY2F0Y2ggKGVycikge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfY3JlYXRlVGVzdGVyKEJvb2xlYW4sIHJlcyA9PiByZXMpKGVhY2hPZiQxLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG4gICAgfVxuICAgIHZhciBzb21lJDEgPSBhd2FpdGlmeShzb21lLCAzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFtgc29tZWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5zb21lfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHNvbWVMaW1pdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLnNvbWVde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5zb21lfVxuICAgICAqIEBhbGlhcyBhbnlMaW1pdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICAgICAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbVxuICAgICAqIGluIHRoZSBjb2xsZWN0aW9ucyBpbiBwYXJhbGxlbC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIGByZXN1bHRgIHZhbHVlLlxuICAgICAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueVxuICAgICAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICAgICAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAgICAgKiB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lTGltaXQoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX2NyZWF0ZVRlc3RlcihCb29sZWFuLCByZXMgPT4gcmVzKShlYWNoT2ZMaW1pdChsaW1pdCksIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbiAgICB9XG4gICAgdmFyIHNvbWVMaW1pdCQxID0gYXdhaXRpZnkoc29tZUxpbWl0LCA0KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFtgc29tZWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5zb21lfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBzb21lU2VyaWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMuc29tZV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9XG4gICAgICogQGFsaWFzIGFueVNlcmllc1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gICAgICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHNlcmllcy5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIGByZXN1bHRgIHZhbHVlLlxuICAgICAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueVxuICAgICAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICAgICAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAgICAgKiB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lU2VyaWVzKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX2NyZWF0ZVRlc3RlcihCb29sZWFuLCByZXMgPT4gcmVzKShlYWNoT2ZTZXJpZXMkMSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxuICAgIH1cbiAgICB2YXIgc29tZVNlcmllcyQxID0gYXdhaXRpZnkoc29tZVNlcmllcywgMyk7XG5cbiAgICAvKipcbiAgICAgKiBTb3J0cyBhIGxpc3QgYnkgdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGBjb2xsYCB2YWx1ZSB0aHJvdWdoIGFuIGFzeW5jXG4gICAgICogYGl0ZXJhdGVlYC5cbiAgICAgKlxuICAgICAqIEBuYW1lIHNvcnRCeVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICAgICAqIGBjb2xsYC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSB2YWx1ZSB0byB1c2UgYXMgdGhlIHNvcnQgY3JpdGVyaWEgYXNcbiAgICAgKiBpdHMgYHJlc3VsdGAuXG4gICAgICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gICAgICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIHRoZSBpdGVtc1xuICAgICAqIGZyb20gdGhlIG9yaWdpbmFsIGBjb2xsYCBzb3J0ZWQgYnkgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgYGl0ZXJhdGVlYFxuICAgICAqIGNhbGxzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcGFzc2VkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGJpZ2ZpbGUudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDI1MTEwMCBieXRlcyBpbiBzaXplXG4gICAgICogLy8gbWVkaXVtZmlsZS50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMTEwMDAgYnl0ZXMgaW4gc2l6ZVxuICAgICAqIC8vIHNtYWxsZmlsZS50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMTIxIGJ5dGVzIGluIHNpemVcbiAgICAgKlxuICAgICAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGZpbGUgc2l6ZSBpbiBieXRlc1xuICAgICAqIGZ1bmN0aW9uIGdldEZpbGVTaXplSW5CeXRlcyhmaWxlLCBjYWxsYmFjaykge1xuICAgICAqICAgICBmcy5zdGF0KGZpbGUsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuICAgICAqICAgICAgICAgaWYgKGVycikge1xuICAgICAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgc3RhdC5zaXplKTtcbiAgICAgKiAgICAgfSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gICAgICogYXN5bmMuc29ydEJ5KFsnbWVkaXVtZmlsZS50eHQnLCdzbWFsbGZpbGUudHh0JywnYmlnZmlsZS50eHQnXSwgZ2V0RmlsZVNpemVJbkJ5dGVzLFxuICAgICAqICAgICBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICAgKiAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgZmlsZXMgc29ydGVkIGJ5XG4gICAgICogICAgICAgICAgICAgLy8gZmlsZSBzaXplIChhc2NlbmRpbmcgYnkgZGVmYXVsdCksIGUuZy5cbiAgICAgKiAgICAgICAgICAgICAvLyBbICdzbWFsbGZpbGUudHh0JywgJ21lZGl1bWZpbGUudHh0JywgJ2JpZ2ZpbGUudHh0J11cbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiAvLyBCeSBtb2RpZnlpbmcgdGhlIGNhbGxiYWNrIHBhcmFtZXRlciB0aGVcbiAgICAgKiAvLyBzb3J0aW5nIG9yZGVyIGNhbiBiZSBpbmZsdWVuY2VkOlxuICAgICAqXG4gICAgICogLy8gYXNjZW5kaW5nIG9yZGVyXG4gICAgICogYXN5bmMuc29ydEJ5KFsnbWVkaXVtZmlsZS50eHQnLCdzbWFsbGZpbGUudHh0JywnYmlnZmlsZS50eHQnXSwgZnVuY3Rpb24oZmlsZSwgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgZ2V0RmlsZVNpemVJbkJ5dGVzKGZpbGUsIGZ1bmN0aW9uKGdldEZpbGVTaXplRXJyLCBmaWxlU2l6ZSkge1xuICAgICAqICAgICAgICAgaWYgKGdldEZpbGVTaXplRXJyKSByZXR1cm4gY2FsbGJhY2soZ2V0RmlsZVNpemVFcnIpO1xuICAgICAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgZmlsZVNpemUpO1xuICAgICAqICAgICB9KTtcbiAgICAgKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICAgKiAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgZmlsZXMgc29ydGVkIGJ5XG4gICAgICogICAgICAgICAgICAgLy8gZmlsZSBzaXplIChhc2NlbmRpbmcgYnkgZGVmYXVsdCksIGUuZy5cbiAgICAgKiAgICAgICAgICAgICAvLyBbICdzbWFsbGZpbGUudHh0JywgJ21lZGl1bWZpbGUudHh0JywgJ2JpZ2ZpbGUudHh0J11cbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiAvLyBkZXNjZW5kaW5nIG9yZGVyXG4gICAgICogYXN5bmMuc29ydEJ5KFsnYmlnZmlsZS50eHQnLCdtZWRpdW1maWxlLnR4dCcsJ3NtYWxsZmlsZS50eHQnXSwgZnVuY3Rpb24oZmlsZSwgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgZ2V0RmlsZVNpemVJbkJ5dGVzKGZpbGUsIGZ1bmN0aW9uKGdldEZpbGVTaXplRXJyLCBmaWxlU2l6ZSkge1xuICAgICAqICAgICAgICAgaWYgKGdldEZpbGVTaXplRXJyKSB7XG4gICAgICogICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGdldEZpbGVTaXplRXJyKTtcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIGZpbGVTaXplICogLTEpO1xuICAgICAqICAgICB9KTtcbiAgICAgKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICAgKiAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgZmlsZXMgc29ydGVkIGJ5XG4gICAgICogICAgICAgICAgICAgLy8gZmlsZSBzaXplIChhc2NlbmRpbmcgYnkgZGVmYXVsdCksIGUuZy5cbiAgICAgKiAgICAgICAgICAgICAvLyBbICdiaWdmaWxlLnR4dCcsICdtZWRpdW1maWxlLnR4dCcsICdzbWFsbGZpbGUudHh0J11cbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiAvLyBFcnJvciBoYW5kbGluZ1xuICAgICAqIGFzeW5jLnNvcnRCeShbJ21lZGl1bWZpbGUudHh0Jywnc21hbGxmaWxlLnR4dCcsJ21pc3NpbmdmaWxlLnR4dCddLCBnZXRGaWxlU2l6ZUluQnl0ZXMsXG4gICAgICogICAgIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAqICAgICAgICAgaWYgKGVycikge1xuICAgICAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICogICAgICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAgICAgKiAgICAgICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gICAgICogICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiApO1xuICAgICAqXG4gICAgICogLy8gVXNpbmcgUHJvbWlzZXNcbiAgICAgKiBhc3luYy5zb3J0QnkoWydtZWRpdW1maWxlLnR4dCcsJ3NtYWxsZmlsZS50eHQnLCdiaWdmaWxlLnR4dCddLCBnZXRGaWxlU2l6ZUluQnl0ZXMpXG4gICAgICogLnRoZW4oIHJlc3VsdHMgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgdGhlIG9yaWdpbmFsIGFycmF5IG9mIGZpbGVzIHNvcnRlZCBieVxuICAgICAqICAgICAvLyBmaWxlIHNpemUgKGFzY2VuZGluZyBieSBkZWZhdWx0KSwgZS5nLlxuICAgICAqICAgICAvLyBbICdzbWFsbGZpbGUudHh0JywgJ21lZGl1bWZpbGUudHh0JywgJ2JpZ2ZpbGUudHh0J11cbiAgICAgKiB9KS5jYXRjaCggZXJyID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIEVycm9yIGhhbmRsaW5nXG4gICAgICogYXN5bmMuc29ydEJ5KFsnbWVkaXVtZmlsZS50eHQnLCdzbWFsbGZpbGUudHh0JywnbWlzc2luZ2ZpbGUudHh0J10sIGdldEZpbGVTaXplSW5CeXRlcylcbiAgICAgKiAudGhlbiggcmVzdWx0cyA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAgICAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAgICAgKiAoYXN5bmMgKCkgPT4ge1xuICAgICAqICAgICB0cnkge1xuICAgICAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5zb3J0QnkoWydiaWdmaWxlLnR4dCcsJ21lZGl1bWZpbGUudHh0Jywnc21hbGxmaWxlLnR4dCddLCBnZXRGaWxlU2l6ZUluQnl0ZXMpO1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gICAgICogICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgZmlsZXMgc29ydGVkIGJ5XG4gICAgICogICAgICAgICAvLyBmaWxlIHNpemUgKGFzY2VuZGluZyBieSBkZWZhdWx0KSwgZS5nLlxuICAgICAqICAgICAgICAgLy8gWyAnc21hbGxmaWxlLnR4dCcsICdtZWRpdW1maWxlLnR4dCcsICdiaWdmaWxlLnR4dCddXG4gICAgICogICAgIH1cbiAgICAgKiAgICAgY2F0Y2ggKGVycikge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH0pKCk7XG4gICAgICpcbiAgICAgKiAvLyBFcnJvciBoYW5kbGluZ1xuICAgICAqIGFzeW5jICgpID0+IHtcbiAgICAgKiAgICAgdHJ5IHtcbiAgICAgKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMuc29ydEJ5KFsnbWlzc2luZ2ZpbGUudHh0JywnbWVkaXVtZmlsZS50eHQnLCdzbWFsbGZpbGUudHh0J10sIGdldEZpbGVTaXplSW5CeXRlcyk7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRCeSAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgICAgICByZXR1cm4gbWFwJDEoY29sbCwgKHgsIGl0ZXJDYikgPT4ge1xuICAgICAgICAgICAgX2l0ZXJhdGVlKHgsIChlcnIsIGNyaXRlcmlhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGl0ZXJDYihlcnIpO1xuICAgICAgICAgICAgICAgIGl0ZXJDYihlcnIsIHt2YWx1ZTogeCwgY3JpdGVyaWF9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAoZXJyLCByZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMuc29ydChjb21wYXJhdG9yKS5tYXAodiA9PiB2LnZhbHVlKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhcmF0b3IobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzb3J0QnkkMSA9IGF3YWl0aWZ5KHNvcnRCeSwgMyk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdGltZSBsaW1pdCBvbiBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBkb2VzIG5vdCBjYWxsXG4gICAgICogaXRzIGNhbGxiYWNrIHdpdGhpbiB0aGUgc3BlY2lmaWVkIG1pbGxpc2Vjb25kcywgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhXG4gICAgICogdGltZW91dCBlcnJvci4gVGhlIGNvZGUgcHJvcGVydHkgZm9yIHRoZSBlcnJvciBvYmplY3Qgd2lsbCBiZSBgJ0VUSU1FRE9VVCdgLlxuICAgICAqXG4gICAgICogQG5hbWUgdGltZW91dFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBhc3luY0ZuIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHRvIGxpbWl0IGluIHRpbWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpc2Vjb25kcyAtIFRoZSBzcGVjaWZpZWQgdGltZSBsaW1pdC5cbiAgICAgKiBAcGFyYW0geyp9IFtpbmZvXSAtIEFueSB2YXJpYWJsZSB5b3Ugd2FudCBhdHRhY2hlZCAoYHN0cmluZ2AsIGBvYmplY3RgLCBldGMpXG4gICAgICogdG8gdGltZW91dCBFcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4uXG4gICAgICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFJldHVybnMgYSB3cmFwcGVkIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBhbnlcbiAgICAgKiBvZiB0aGUgY29udHJvbCBmbG93IGZ1bmN0aW9ucy5cbiAgICAgKiBJbnZva2UgdGhpcyBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMgeW91IHdvdWxkIGBhc3luY0Z1bmNgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBteUZ1bmN0aW9uKGZvbywgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgZG9Bc3luY1Rhc2soZm9vLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgKiAgICAgICAgIC8vIGhhbmRsZSBlcnJvcnNcbiAgICAgKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAqXG4gICAgICogICAgICAgICAvLyBkbyBzb21lIHN0dWZmIC4uLlxuICAgICAqXG4gICAgICogICAgICAgICAvLyByZXR1cm4gcHJvY2Vzc2VkIGRhdGFcbiAgICAgKiAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICAgKiAgICAgfSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBhc3luYy50aW1lb3V0KG15RnVuY3Rpb24sIDEwMDApO1xuICAgICAqXG4gICAgICogLy8gY2FsbCBgd3JhcHBlZGAgYXMgeW91IHdvdWxkIGBteUZ1bmN0aW9uYFxuICAgICAqIHdyYXBwZWQoeyBiYXI6ICdiYXInIH0sIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAqICAgICAvLyBpZiBgbXlGdW5jdGlvbmAgdGFrZXMgPCAxMDAwIG1zIHRvIGV4ZWN1dGUsIGBlcnJgXG4gICAgICogICAgIC8vIGFuZCBgZGF0YWAgd2lsbCBoYXZlIHRoZWlyIGV4cGVjdGVkIHZhbHVlc1xuICAgICAqXG4gICAgICogICAgIC8vIGVsc2UgYGVycmAgd2lsbCBiZSBhbiBFcnJvciB3aXRoIHRoZSBjb2RlICdFVElNRURPVVQnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZW91dChhc3luY0ZuLCBtaWxsaXNlY29uZHMsIGluZm8pIHtcbiAgICAgICAgdmFyIGZuID0gd3JhcEFzeW5jKGFzeW5jRm4pO1xuXG4gICAgICAgIHJldHVybiBpbml0aWFsUGFyYW1zKChhcmdzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgdmFyIHRpbWVkT3V0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdGltZXI7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGFzeW5jRm4ubmFtZSB8fCAnYW5vbnltb3VzJztcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgID0gbmV3IEVycm9yKCdDYWxsYmFjayBmdW5jdGlvbiBcIicgKyBuYW1lICsgJ1wiIHRpbWVkIG91dC4nKTtcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gJ0VUSU1FRE9VVCc7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuaW5mbyA9IGluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFyZ3MucHVzaCgoLi4uY2JBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aW1lZE91dCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayguLi5jYkFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBzZXR1cCB0aW1lciBhbmQgY2FsbCBvcmlnaW5hbCBmdW5jdGlvblxuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KHRpbWVvdXRDYWxsYmFjaywgbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgICAgIGZuKC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByYW5nZShzaXplKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBBcnJheShzaXplKTtcbiAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgICAgcmVzdWx0W3NpemVdID0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFt0aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAgICAgKiB0aW1lLlxuICAgICAqXG4gICAgICogQG5hbWUgdGltZXNMaW1pdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLnRpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9XG4gICAgICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBjYWxsIGBuYCB0aW1lcy5cbiAgICAgKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXNMaW1pdChjb3VudCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICAgICAgcmV0dXJuIG1hcExpbWl0JDEocmFuZ2UoY291bnQpLCBsaW1pdCwgX2l0ZXJhdGVlLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24gYG5gIHRpbWVzLCBhbmQgYWNjdW11bGF0ZXMgcmVzdWx0cyBpbiB0aGUgc2FtZVxuICAgICAqIG1hbm5lciB5b3Ugd291bGQgdXNlIHdpdGggW21hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0uXG4gICAgICpcbiAgICAgKiBAbmFtZSB0aW1lc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH1cbiAgICAgKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gLSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJ1biB0aGUgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBjYWxsIGBuYCB0aW1lcy5cbiAgICAgKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gc2VlIHtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwcm92aWRlZFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBQcmV0ZW5kIHRoaXMgaXMgc29tZSBjb21wbGljYXRlZCBhc3luYyBmYWN0b3J5XG4gICAgICogdmFyIGNyZWF0ZVVzZXIgPSBmdW5jdGlvbihpZCwgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAqICAgICAgICAgaWQ6ICd1c2VyJyArIGlkXG4gICAgICogICAgIH0pO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiAvLyBnZW5lcmF0ZSA1IHVzZXJzXG4gICAgICogYXN5bmMudGltZXMoNSwgZnVuY3Rpb24obiwgbmV4dCkge1xuICAgICAqICAgICBjcmVhdGVVc2VyKG4sIGZ1bmN0aW9uKGVyciwgdXNlcikge1xuICAgICAqICAgICAgICAgbmV4dChlcnIsIHVzZXIpO1xuICAgICAqICAgICB9KTtcbiAgICAgKiB9LCBmdW5jdGlvbihlcnIsIHVzZXJzKSB7XG4gICAgICogICAgIC8vIHdlIHNob3VsZCBub3cgaGF2ZSA1IHVzZXJzXG4gICAgICogfSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMgKG4sIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGltZXNMaW1pdChuLCBJbmZpbml0eSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIFt0aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB0aW1lc1Nlcmllc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLnRpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9XG4gICAgICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBydW4gdGhlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuXG4gICAgICogSW52b2tlZCB3aXRoIHRoZSBpdGVyYXRpb24gaW5kZXggYW5kIGEgY2FsbGJhY2s6IChuLCBuZXh0KS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIHNlZSB7QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0uXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lc1NlcmllcyAobiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aW1lc0xpbWl0KG4sIDEsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHJlbGF0aXZlIG9mIGByZWR1Y2VgLiAgVGFrZXMgYW4gT2JqZWN0IG9yIEFycmF5LCBhbmQgaXRlcmF0ZXMgb3ZlciBlYWNoXG4gICAgICogZWxlbWVudCBpbiBwYXJhbGxlbCwgZWFjaCBzdGVwIHBvdGVudGlhbGx5IG11dGF0aW5nIGFuIGBhY2N1bXVsYXRvcmAgdmFsdWUuXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIGFjY3VtdWxhdG9yIGRlZmF1bHRzIHRvIHRoZSB0eXBlIG9mIGNvbGxlY3Rpb24gcGFzc2VkIGluLlxuICAgICAqXG4gICAgICogQG5hbWUgdHJhbnNmb3JtXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gLSBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgdHJhbnNmb3JtLiAgSWYgb21pdHRlZCxcbiAgICAgKiBpdCB3aWxsIGRlZmF1bHQgdG8gYW4gZW1wdHkgT2JqZWN0IG9yIEFycmF5LCBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgYGNvbGxgXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGl0ZW0gaW4gdGhlXG4gICAgICogY29sbGVjdGlvbiB0aGF0IHBvdGVudGlhbGx5IG1vZGlmaWVzIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgKiBJbnZva2VkIHdpdGggKGFjY3VtdWxhdG9yLCBpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICAgICAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCBpcyB0aGUgdHJhbnNmb3JtZWQgYWNjdW11bGF0b3IuXG4gICAgICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gZmlsZTEudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDEwMDAgYnl0ZXMgaW4gc2l6ZVxuICAgICAqIC8vIGZpbGUyLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAyMDAwIGJ5dGVzIGluIHNpemVcbiAgICAgKiAvLyBmaWxlMy50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMzAwMCBieXRlcyBpbiBzaXplXG4gICAgICpcbiAgICAgKiAvLyBoZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGh1bWFuLXJlYWRhYmxlIHNpemUgZm9ybWF0IGZyb20gYnl0ZXNcbiAgICAgKiBmdW5jdGlvbiBmb3JtYXRCeXRlcyhieXRlcywgZGVjaW1hbHMgPSAyKSB7XG4gICAgICogICAvLyBpbXBsZW1lbnRhdGlvbiBub3QgaW5jbHVkZWQgZm9yIGJyZXZpdHlcbiAgICAgKiAgIHJldHVybiBodW1hblJlYWRibGVGaWxlc2l6ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBjb25zdCBmaWxlTGlzdCA9IFsnZmlsZTEudHh0JywnZmlsZTIudHh0JywnZmlsZTMudHh0J107XG4gICAgICpcbiAgICAgKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBmaWxlIHNpemUsIHRyYW5zZm9ybWVkIHRvIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICAgICAqIC8vIGUuZy4gMTAyNCBieXRlcyA9IDFLQiwgMTIzNCBieXRlcyA9IDEuMjEgS0IsIDEwNDg1NzYgYnl0ZXMgPSAxTUIsIGV0Yy5cbiAgICAgKiBmdW5jdGlvbiB0cmFuc2Zvcm1GaWxlU2l6ZShhY2MsIHZhbHVlLCBrZXksIGNhbGxiYWNrKSB7XG4gICAgICogICAgIGZzLnN0YXQodmFsdWUsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuICAgICAqICAgICAgICAgaWYgKGVycikge1xuICAgICAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICAgICAgYWNjW2tleV0gPSBmb3JtYXRCeXRlcyhzdGF0LnNpemUpO1xuICAgICAqICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICogICAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICAgICAqIGFzeW5jLnRyYW5zZm9ybShmaWxlTGlzdCwgdHJhbnNmb3JtRmlsZVNpemUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICogICAgIGlmKGVycikge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogICAgICAgICAvLyBbICcxMDAwIEJ5dGVzJywgJzEuOTUgS0InLCAnMi45MyBLQicgXVxuICAgICAqICAgICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyBQcm9taXNlc1xuICAgICAqIGFzeW5jLnRyYW5zZm9ybShmaWxlTGlzdCwgdHJhbnNmb3JtRmlsZVNpemUpXG4gICAgICogLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgKiAgICAgLy8gWyAnMTAwMCBCeXRlcycsICcxLjk1IEtCJywgJzIuOTMgS0InIF1cbiAgICAgKiB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAgICAgKiAoYXN5bmMgKCkgPT4ge1xuICAgICAqICAgICB0cnkge1xuICAgICAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLnRyYW5zZm9ybShmaWxlTGlzdCwgdHJhbnNmb3JtRmlsZVNpemUpO1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgKiAgICAgICAgIC8vIFsgJzEwMDAgQnl0ZXMnLCAnMS45NSBLQicsICcyLjkzIEtCJyBdXG4gICAgICogICAgIH1cbiAgICAgKiAgICAgY2F0Y2ggKGVycikge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH0pKCk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gZmlsZTEudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDEwMDAgYnl0ZXMgaW4gc2l6ZVxuICAgICAqIC8vIGZpbGUyLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAyMDAwIGJ5dGVzIGluIHNpemVcbiAgICAgKiAvLyBmaWxlMy50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMzAwMCBieXRlcyBpbiBzaXplXG4gICAgICpcbiAgICAgKiAvLyBoZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGh1bWFuLXJlYWRhYmxlIHNpemUgZm9ybWF0IGZyb20gYnl0ZXNcbiAgICAgKiBmdW5jdGlvbiBmb3JtYXRCeXRlcyhieXRlcywgZGVjaW1hbHMgPSAyKSB7XG4gICAgICogICAvLyBpbXBsZW1lbnRhdGlvbiBub3QgaW5jbHVkZWQgZm9yIGJyZXZpdHlcbiAgICAgKiAgIHJldHVybiBodW1hblJlYWRibGVGaWxlc2l6ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBjb25zdCBmaWxlTWFwID0geyBmMTogJ2ZpbGUxLnR4dCcsIGYyOiAnZmlsZTIudHh0JywgZjM6ICdmaWxlMy50eHQnIH07XG4gICAgICpcbiAgICAgKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBmaWxlIHNpemUsIHRyYW5zZm9ybWVkIHRvIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICAgICAqIC8vIGUuZy4gMTAyNCBieXRlcyA9IDFLQiwgMTIzNCBieXRlcyA9IDEuMjEgS0IsIDEwNDg1NzYgYnl0ZXMgPSAxTUIsIGV0Yy5cbiAgICAgKiBmdW5jdGlvbiB0cmFuc2Zvcm1GaWxlU2l6ZShhY2MsIHZhbHVlLCBrZXksIGNhbGxiYWNrKSB7XG4gICAgICogICAgIGZzLnN0YXQodmFsdWUsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuICAgICAqICAgICAgICAgaWYgKGVycikge1xuICAgICAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICAgICAgYWNjW2tleV0gPSBmb3JtYXRCeXRlcyhzdGF0LnNpemUpO1xuICAgICAqICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICogICAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICAgICAqIGFzeW5jLnRyYW5zZm9ybShmaWxlTWFwLCB0cmFuc2Zvcm1GaWxlU2l6ZSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgKiAgICAgaWYoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICB9IGVsc2Uge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgKiAgICAgICAgIC8vIHsgZjE6ICcxMDAwIEJ5dGVzJywgZjI6ICcxLjk1IEtCJywgZjM6ICcyLjkzIEtCJyB9XG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIFByb21pc2VzXG4gICAgICogYXN5bmMudHJhbnNmb3JtKGZpbGVNYXAsIHRyYW5zZm9ybUZpbGVTaXplKVxuICAgICAqIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICogICAgIC8vIHsgZjE6ICcxMDAwIEJ5dGVzJywgZjI6ICcxLjk1IEtCJywgZjM6ICcyLjkzIEtCJyB9XG4gICAgICogfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gICAgICogYXN5bmMgKCkgPT4ge1xuICAgICAqICAgICB0cnkge1xuICAgICAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLnRyYW5zZm9ybShmaWxlTWFwLCB0cmFuc2Zvcm1GaWxlU2l6ZSk7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAqICAgICAgICAgLy8geyBmMTogJzEwMDAgQnl0ZXMnLCBmMjogJzEuOTUgS0InLCBmMzogJzIuOTMgS0InIH1cbiAgICAgKiAgICAgfVxuICAgICAqICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtIChjb2xsLCBhY2N1bXVsYXRvciwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDMgJiYgdHlwZW9mIGFjY3VtdWxhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGl0ZXJhdGVlO1xuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhY2N1bXVsYXRvcjtcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gQXJyYXkuaXNBcnJheShjb2xsKSA/IFtdIDoge307XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IHByb21pc2VDYWxsYmFjaygpKTtcbiAgICAgICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG5cbiAgICAgICAgZWFjaE9mJDEoY29sbCwgKHYsIGssIGNiKSA9PiB7XG4gICAgICAgICAgICBfaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHYsIGssIGNiKTtcbiAgICAgICAgfSwgZXJyID0+IGNhbGxiYWNrKGVyciwgYWNjdW11bGF0b3IpKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrW1BST01JU0VfU1lNQk9MXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0IHJ1bnMgZWFjaCB0YXNrIGluIHNlcmllcyBidXQgc3RvcHMgd2hlbmV2ZXIgYW55IG9mIHRoZSBmdW5jdGlvbnMgd2VyZVxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIG9uZSBvZiB0aGUgdGFza3Mgd2VyZSBzdWNjZXNzZnVsLCB0aGUgYGNhbGxiYWNrYCB3aWxsIGJlXG4gICAgICogcGFzc2VkIHRoZSByZXN1bHQgb2YgdGhlIHN1Y2Nlc3NmdWwgdGFzay4gSWYgYWxsIHRhc2tzIGZhaWwsIHRoZSBjYWxsYmFja1xuICAgICAqIHdpbGwgYmUgcGFzc2VkIHRoZSBlcnJvciBhbmQgcmVzdWx0IChpZiBhbnkpIG9mIHRoZSBmaW5hbCBhdHRlbXB0LlxuICAgICAqXG4gICAgICogQG5hbWUgdHJ5RWFjaFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAgICAgKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBjb250YWluaW5nIGZ1bmN0aW9ucyB0b1xuICAgICAqIHJ1biwgZWFjaCBmdW5jdGlvbiBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCByZXN1bHQpYCBpdCBtdXN0IGNhbGwgb25cbiAgICAgKiBjb21wbGV0aW9uIHdpdGggYW4gZXJyb3IgYGVycmAgKHdoaWNoIGNhbiBiZSBgbnVsbGApIGFuZCBhbiBvcHRpb25hbCBgcmVzdWx0YFxuICAgICAqIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBvbmVcbiAgICAgKiBvZiB0aGUgdGFza3MgaGFzIHN1Y2NlZWRlZCwgb3IgYWxsIGhhdmUgZmFpbGVkLiBJdCByZWNlaXZlcyB0aGUgYGVycmAgYW5kXG4gICAgICogYHJlc3VsdGAgYXJndW1lbnRzIG9mIHRoZSBsYXN0IGF0dGVtcHQgYXQgY29tcGxldGluZyB0aGUgYHRhc2tgLiBJbnZva2VkIHdpdGhcbiAgICAgKiAoZXJyLCByZXN1bHRzKS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGFzeW5jLnRyeUVhY2goW1xuICAgICAqICAgICBmdW5jdGlvbiBnZXREYXRhRnJvbUZpcnN0V2Vic2l0ZShjYWxsYmFjaykge1xuICAgICAqICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgZmlyc3Qgd2Vic2l0ZVxuICAgICAqICAgICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgZnVuY3Rpb24gZ2V0RGF0YUZyb21TZWNvbmRXZWJzaXRlKGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICAvLyBGaXJzdCB3ZWJzaXRlIGZhaWxlZCxcbiAgICAgKiAgICAgICAgIC8vIFRyeSBnZXR0aW5nIHRoZSBkYXRhIGZyb20gdGhlIGJhY2t1cCB3ZWJzaXRlXG4gICAgICogICAgICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICAgICAqICAgICB9XG4gICAgICogXSxcbiAgICAgKiAvLyBvcHRpb25hbCBjYWxsYmFja1xuICAgICAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAqICAgICBOb3cgZG8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnlFYWNoKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICByZXR1cm4gZWFjaFNlcmllcyQxKHRhc2tzLCAodGFzaywgdGFza0NiKSA9PiB7XG4gICAgICAgICAgICB3cmFwQXN5bmModGFzaykoKGVyciwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgPT09IGZhbHNlKSByZXR1cm4gdGFza0NiKGVycik7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIFtyZXN1bHRdID0gYXJncztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhcmdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICB0YXNrQ2IoZXJyID8gbnVsbCA6IHt9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAoKSA9PiBjYWxsYmFjayhlcnJvciwgcmVzdWx0KSk7XG4gICAgfVxuXG4gICAgdmFyIHRyeUVhY2gkMSA9IGF3YWl0aWZ5KHRyeUVhY2gpO1xuXG4gICAgLyoqXG4gICAgICogVW5kb2VzIGEgW21lbW9pemVde0BsaW5rIG1vZHVsZTpVdGlscy5tZW1vaXplfWQgZnVuY3Rpb24sIHJldmVydGluZyBpdCB0byB0aGUgb3JpZ2luYWwsXG4gICAgICogdW5tZW1vaXplZCBmb3JtLiBIYW5keSBmb3IgdGVzdGluZy5cbiAgICAgKlxuICAgICAqIEBuYW1lIHVubWVtb2l6ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgW2FzeW5jLm1lbW9pemVde0BsaW5rIG1vZHVsZTpVdGlscy5tZW1vaXplfVxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIHRoZSBtZW1vaXplZCBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIG9yaWdpbmFsIHVubWVtb2l6ZWQgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bm1lbW9pemUoZm4pIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGZuLnVubWVtb2l6ZWQgfHwgZm4pKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdGVkbHkgY2FsbCBgaXRlcmF0ZWVgLCB3aGlsZSBgdGVzdGAgcmV0dXJucyBgdHJ1ZWAuIENhbGxzIGBjYWxsYmFja2Agd2hlblxuICAgICAqIHN0b3BwZWQsIG9yIGFuIGVycm9yIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBuYW1lIHdoaWxzdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoXG4gICAgICogZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAuIEludm9rZWQgd2l0aCAoKS5cbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZVxuICAgICAqIGB0ZXN0YCBwYXNzZXMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdFxuICAgICAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLiBgY2FsbGJhY2tgXG4gICAgICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3NcbiAgICAgKiBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSk7XG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjb3VudCA9IDA7XG4gICAgICogYXN5bmMud2hpbHN0KFxuICAgICAqICAgICBmdW5jdGlvbiB0ZXN0KGNiKSB7IGNiKG51bGwsIGNvdW50IDwgNSk7IH0sXG4gICAgICogICAgIGZ1bmN0aW9uIGl0ZXIoY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIGNvdW50Kys7XG4gICAgICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNvdW50KTtcbiAgICAgKiAgICAgICAgIH0sIDEwMDApO1xuICAgICAqICAgICB9LFxuICAgICAqICAgICBmdW5jdGlvbiAoZXJyLCBuKSB7XG4gICAgICogICAgICAgICAvLyA1IHNlY29uZHMgaGF2ZSBwYXNzZWQsIG4gPSA1XG4gICAgICogICAgIH1cbiAgICAgKiApO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdoaWxzdCh0ZXN0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvbmx5T25jZShjYWxsYmFjayk7XG4gICAgICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgICAgICB2YXIgX3Rlc3QgPSB3cmFwQXN5bmModGVzdCk7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gbmV4dChlcnIsIC4uLnJlc3QpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3Q7XG4gICAgICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICAgICAgX3Rlc3QoY2hlY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2soZXJyLCB0cnV0aCkge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCF0cnV0aCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIC4uLnJlc3VsdHMpO1xuICAgICAgICAgICAgX2ZuKG5leHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90ZXN0KGNoZWNrKTtcbiAgICB9XG4gICAgdmFyIHdoaWxzdCQxID0gYXdhaXRpZnkod2hpbHN0LCAzKTtcblxuICAgIC8qKlxuICAgICAqIFJlcGVhdGVkbHkgY2FsbCBgaXRlcmF0ZWVgIHVudGlsIGB0ZXN0YCByZXR1cm5zIGB0cnVlYC4gQ2FsbHMgYGNhbGxiYWNrYCB3aGVuXG4gICAgICogc3RvcHBlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgY2FsbGJhY2tgIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnlcbiAgICAgKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3MgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBbd2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHVudGlsXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBbYXN5bmMud2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fVxuICAgICAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAgICAgKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoXG4gICAgICogZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICAgICAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lXG4gICAgICogYHRlc3RgIGZhaWxzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3RcbiAgICAgKiBmdW5jdGlvbiBoYXMgcGFzc2VkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICAgICAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzXG4gICAgICogY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pO1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgbm90IHBhc3NlZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCByZXN1bHRzID0gW11cbiAgICAgKiBsZXQgZmluaXNoZWQgPSBmYWxzZVxuICAgICAqIGFzeW5jLnVudGlsKGZ1bmN0aW9uIHRlc3QoY2IpIHtcbiAgICAgKiAgICAgY2IobnVsbCwgZmluaXNoZWQpXG4gICAgICogfSwgZnVuY3Rpb24gaXRlcihuZXh0KSB7XG4gICAgICogICAgIGZldGNoUGFnZSh1cmwsIChlcnIsIGJvZHkpID0+IHtcbiAgICAgKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycilcbiAgICAgKiAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChib2R5Lm9iamVjdHMpXG4gICAgICogICAgICAgICBmaW5pc2hlZCA9ICEhYm9keS5uZXh0XG4gICAgICogICAgICAgICBuZXh0KGVycilcbiAgICAgKiAgICAgfSlcbiAgICAgKiB9LCBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICAgKiAgICAgLy8gYWxsIHBhZ2VzIGhhdmUgYmVlbiBmZXRjaGVkXG4gICAgICogfSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnRpbCh0ZXN0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgX3Rlc3QgPSB3cmFwQXN5bmModGVzdCk7XG4gICAgICAgIHJldHVybiB3aGlsc3QkMSgoY2IpID0+IF90ZXN0KChlcnIsIHRydXRoKSA9PiBjYiAoZXJyLCAhdHJ1dGgpKSwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBgdGFza3NgIGFycmF5IG9mIGZ1bmN0aW9ucyBpbiBzZXJpZXMsIGVhY2ggcGFzc2luZyB0aGVpciByZXN1bHRzIHRvXG4gICAgICogdGhlIG5leHQgaW4gdGhlIGFycmF5LiBIb3dldmVyLCBpZiBhbnkgb2YgdGhlIGB0YXNrc2AgcGFzcyBhbiBlcnJvciB0byB0aGVpclxuICAgICAqIG93biBjYWxsYmFjaywgdGhlIG5leHQgZnVuY3Rpb24gaXMgbm90IGV4ZWN1dGVkLCBhbmQgdGhlIG1haW4gYGNhbGxiYWNrYCBpc1xuICAgICAqIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBuYW1lIHdhdGVyZmFsbFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0YXNrcyAtIEFuIGFycmF5IG9mIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259XG4gICAgICogdG8gcnVuLlxuICAgICAqIEVhY2ggZnVuY3Rpb24gc2hvdWxkIGNvbXBsZXRlIHdpdGggYW55IG51bWJlciBvZiBgcmVzdWx0YCB2YWx1ZXMuXG4gICAgICogVGhlIGByZXN1bHRgIHZhbHVlcyB3aWxsIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMsIGluIG9yZGVyLCB0byB0aGUgbmV4dCB0YXNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gICAgICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIHdpbGwgYmUgcGFzc2VkIHRoZSByZXN1bHRzIG9mIHRoZSBsYXN0IHRhc2snc1xuICAgICAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXN5bmMud2F0ZXJmYWxsKFtcbiAgICAgKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnLCAndHdvJyk7XG4gICAgICogICAgIH0sXG4gICAgICogICAgIGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ29uZScgYW5kIGFyZzIgbm93IGVxdWFscyAndHdvJ1xuICAgICAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3RocmVlJyk7XG4gICAgICogICAgIH0sXG4gICAgICogICAgIGZ1bmN0aW9uKGFyZzEsIGNhbGxiYWNrKSB7XG4gICAgICogICAgICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ3RocmVlJ1xuICAgICAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RvbmUnKTtcbiAgICAgKiAgICAgfVxuICAgICAqIF0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAnZG9uZSdcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIE9yLCB3aXRoIG5hbWVkIGZ1bmN0aW9uczpcbiAgICAgKiBhc3luYy53YXRlcmZhbGwoW1xuICAgICAqICAgICBteUZpcnN0RnVuY3Rpb24sXG4gICAgICogICAgIG15U2Vjb25kRnVuY3Rpb24sXG4gICAgICogICAgIG15TGFzdEZ1bmN0aW9uLFxuICAgICAqIF0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAnZG9uZSdcbiAgICAgKiB9KTtcbiAgICAgKiBmdW5jdGlvbiBteUZpcnN0RnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgKiAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScsICd0d28nKTtcbiAgICAgKiB9XG4gICAgICogZnVuY3Rpb24gbXlTZWNvbmRGdW5jdGlvbihhcmcxLCBhcmcyLCBjYWxsYmFjaykge1xuICAgICAqICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ29uZScgYW5kIGFyZzIgbm93IGVxdWFscyAndHdvJ1xuICAgICAqICAgICBjYWxsYmFjayhudWxsLCAndGhyZWUnKTtcbiAgICAgKiB9XG4gICAgICogZnVuY3Rpb24gbXlMYXN0RnVuY3Rpb24oYXJnMSwgY2FsbGJhY2spIHtcbiAgICAgKiAgICAgLy8gYXJnMSBub3cgZXF1YWxzICd0aHJlZSdcbiAgICAgKiAgICAgY2FsbGJhY2sobnVsbCwgJ2RvbmUnKTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd2F0ZXJmYWxsICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhc2tzKSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJykpO1xuICAgICAgICBpZiAoIXRhc2tzLmxlbmd0aCkgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIHZhciB0YXNrSW5kZXggPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIG5leHRUYXNrKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gd3JhcEFzeW5jKHRhc2tzW3Rhc2tJbmRleCsrXSk7XG4gICAgICAgICAgICB0YXNrKC4uLmFyZ3MsIG9ubHlPbmNlKG5leHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG5leHQoZXJyLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuXG4gICAgICAgICAgICBpZiAoZXJyIHx8IHRhc2tJbmRleCA9PT0gdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0VGFzayhhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRUYXNrKFtdKTtcbiAgICB9XG5cbiAgICB2YXIgd2F0ZXJmYWxsJDEgPSBhd2FpdGlmeSh3YXRlcmZhbGwpO1xuXG4gICAgLyoqXG4gICAgICogQW4gXCJhc3luYyBmdW5jdGlvblwiIGluIHRoZSBjb250ZXh0IG9mIEFzeW5jIGlzIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB3aXRoXG4gICAgICogYSB2YXJpYWJsZSBudW1iZXIgb2YgcGFyYW1ldGVycywgd2l0aCB0aGUgZmluYWwgcGFyYW1ldGVyIGJlaW5nIGEgY2FsbGJhY2suXG4gICAgICogKGBmdW5jdGlvbiAoYXJnMSwgYXJnMiwgLi4uLCBjYWxsYmFjaykge31gKVxuICAgICAqIFRoZSBmaW5hbCBjYWxsYmFjayBpcyBvZiB0aGUgZm9ybSBgY2FsbGJhY2soZXJyLCByZXN1bHRzLi4uKWAsIHdoaWNoIG11c3QgYmVcbiAgICAgKiBjYWxsZWQgb25jZSB0aGUgZnVuY3Rpb24gaXMgY29tcGxldGVkLiAgVGhlIGNhbGxiYWNrIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBhXG4gICAgICogRXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50IHRvIHNpZ25hbCB0aGF0IGFuIGVycm9yIG9jY3VycmVkLlxuICAgICAqIE90aGVyd2lzZSwgaWYgbm8gZXJyb3Igb2NjdXJyZWQsIGl0IHNob3VsZCBiZSBjYWxsZWQgd2l0aCBgbnVsbGAgYXMgdGhlIGZpcnN0XG4gICAgICogYXJndW1lbnQsIGFuZCBhbnkgYWRkaXRpb25hbCBgcmVzdWx0YCBhcmd1bWVudHMgdGhhdCBtYXkgYXBwbHksIHRvIHNpZ25hbFxuICAgICAqIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICAgKiBUaGUgY2FsbGJhY2sgbXVzdCBiZSBjYWxsZWQgZXhhY3RseSBvbmNlLCBpZGVhbGx5IG9uIGEgbGF0ZXIgdGljayBvZiB0aGVcbiAgICAgKiBKYXZhU2NyaXB0IGV2ZW50IGxvb3AuXG4gICAgICpcbiAgICAgKiBUaGlzIHR5cGUgb2YgZnVuY3Rpb24gaXMgYWxzbyByZWZlcnJlZCB0byBhcyBhIFwiTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvblwiLFxuICAgICAqIG9yIGEgXCJjb250aW51YXRpb24gcGFzc2luZy1zdHlsZSBmdW5jdGlvblwiIChDUFMpLiBNb3N0IG9mIHRoZSBtZXRob2RzIG9mIHRoaXNcbiAgICAgKiBsaWJyYXJ5IGFyZSB0aGVtc2VsdmVzIENQUy9Ob2RlLXN0eWxlIGFzeW5jIGZ1bmN0aW9ucywgb3IgZnVuY3Rpb25zIHRoYXRcbiAgICAgKiByZXR1cm4gQ1BTL05vZGUtc3R5bGUgYXN5bmMgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogV2hlcmV2ZXIgd2UgYWNjZXB0IGEgTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvbiwgd2UgYWxzbyBkaXJlY3RseSBhY2NlcHQgYW5cbiAgICAgKiBbRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL1N0YXRlbWVudHMvYXN5bmNfZnVuY3Rpb259LlxuICAgICAqIEluIHRoaXMgY2FzZSwgdGhlIGBhc3luY2AgZnVuY3Rpb24gd2lsbCBub3QgYmUgcGFzc2VkIGEgZmluYWwgY2FsbGJhY2tcbiAgICAgKiBhcmd1bWVudCwgYW5kIGFueSB0aHJvd24gZXJyb3Igd2lsbCBiZSB1c2VkIGFzIHRoZSBgZXJyYCBhcmd1bWVudCBvZiB0aGVcbiAgICAgKiBpbXBsaWNpdCBjYWxsYmFjaywgYW5kIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBgcmVzdWx0YCB2YWx1ZS5cbiAgICAgKiAoaS5lLiBhIGByZWplY3RlZGAgb2YgdGhlIHJldHVybmVkIFByb21pc2UgYmVjb21lcyB0aGUgYGVycmAgY2FsbGJhY2tcbiAgICAgKiBhcmd1bWVudCwgYW5kIGEgYHJlc29sdmVkYCB2YWx1ZSBiZWNvbWVzIHRoZSBgcmVzdWx0YC4pXG4gICAgICpcbiAgICAgKiBOb3RlLCBkdWUgdG8gSmF2YVNjcmlwdCBsaW1pdGF0aW9ucywgd2UgY2FuIG9ubHkgZGV0ZWN0IG5hdGl2ZSBgYXN5bmNgXG4gICAgICogZnVuY3Rpb25zIGFuZCBub3QgdHJhbnNwaWxpZWQgaW1wbGVtZW50YXRpb25zLlxuICAgICAqIFlvdXIgZW52aXJvbm1lbnQgbXVzdCBoYXZlIGBhc3luY2AvYGF3YWl0YCBzdXBwb3J0IGZvciB0aGlzIHRvIHdvcmsuXG4gICAgICogKGUuZy4gTm9kZSA+IHY3LjYsIG9yIGEgcmVjZW50IHZlcnNpb24gb2YgYSBtb2Rlcm4gYnJvd3NlcikuXG4gICAgICogSWYgeW91IGFyZSB1c2luZyBgYXN5bmNgIGZ1bmN0aW9ucyB0aHJvdWdoIGEgdHJhbnNwaWxlciAoZS5nLiBCYWJlbCksIHlvdVxuICAgICAqIG11c3Qgc3RpbGwgd3JhcCB0aGUgZnVuY3Rpb24gd2l0aCBbYXN5bmNpZnlde0BsaW5rIG1vZHVsZTpVdGlscy5hc3luY2lmeX0sXG4gICAgICogYmVjYXVzZSB0aGUgYGFzeW5jIGZ1bmN0aW9uYCB3aWxsIGJlIGNvbXBpbGVkIHRvIGFuIG9yZGluYXJ5IGZ1bmN0aW9uIHRoYXRcbiAgICAgKiByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEB0eXBlZGVmIHtGdW5jdGlvbn0gQXN5bmNGdW5jdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICAgIHZhciBpbmRleCA9IHtcbiAgICAgICAgYXBwbHksXG4gICAgICAgIGFwcGx5RWFjaDogYXBwbHlFYWNoJDEsXG4gICAgICAgIGFwcGx5RWFjaFNlcmllcyxcbiAgICAgICAgYXN5bmNpZnksXG4gICAgICAgIGF1dG8sXG4gICAgICAgIGF1dG9JbmplY3QsXG4gICAgICAgIGNhcmdvLFxuICAgICAgICBjYXJnb1F1ZXVlOiBjYXJnbyQxLFxuICAgICAgICBjb21wb3NlLFxuICAgICAgICBjb25jYXQ6IGNvbmNhdCQxLFxuICAgICAgICBjb25jYXRMaW1pdDogY29uY2F0TGltaXQkMSxcbiAgICAgICAgY29uY2F0U2VyaWVzOiBjb25jYXRTZXJpZXMkMSxcbiAgICAgICAgY29uc3RhbnQsXG4gICAgICAgIGRldGVjdDogZGV0ZWN0JDEsXG4gICAgICAgIGRldGVjdExpbWl0OiBkZXRlY3RMaW1pdCQxLFxuICAgICAgICBkZXRlY3RTZXJpZXM6IGRldGVjdFNlcmllcyQxLFxuICAgICAgICBkaXIsXG4gICAgICAgIGRvVW50aWwsXG4gICAgICAgIGRvV2hpbHN0OiBkb1doaWxzdCQxLFxuICAgICAgICBlYWNoLFxuICAgICAgICBlYWNoTGltaXQ6IGVhY2hMaW1pdCQyLFxuICAgICAgICBlYWNoT2Y6IGVhY2hPZiQxLFxuICAgICAgICBlYWNoT2ZMaW1pdDogZWFjaE9mTGltaXQkMixcbiAgICAgICAgZWFjaE9mU2VyaWVzOiBlYWNoT2ZTZXJpZXMkMSxcbiAgICAgICAgZWFjaFNlcmllczogZWFjaFNlcmllcyQxLFxuICAgICAgICBlbnN1cmVBc3luYyxcbiAgICAgICAgZXZlcnk6IGV2ZXJ5JDEsXG4gICAgICAgIGV2ZXJ5TGltaXQ6IGV2ZXJ5TGltaXQkMSxcbiAgICAgICAgZXZlcnlTZXJpZXM6IGV2ZXJ5U2VyaWVzJDEsXG4gICAgICAgIGZpbHRlcjogZmlsdGVyJDEsXG4gICAgICAgIGZpbHRlckxpbWl0OiBmaWx0ZXJMaW1pdCQxLFxuICAgICAgICBmaWx0ZXJTZXJpZXM6IGZpbHRlclNlcmllcyQxLFxuICAgICAgICBmb3JldmVyOiBmb3JldmVyJDEsXG4gICAgICAgIGdyb3VwQnksXG4gICAgICAgIGdyb3VwQnlMaW1pdDogZ3JvdXBCeUxpbWl0JDEsXG4gICAgICAgIGdyb3VwQnlTZXJpZXMsXG4gICAgICAgIGxvZyxcbiAgICAgICAgbWFwOiBtYXAkMSxcbiAgICAgICAgbWFwTGltaXQ6IG1hcExpbWl0JDEsXG4gICAgICAgIG1hcFNlcmllczogbWFwU2VyaWVzJDEsXG4gICAgICAgIG1hcFZhbHVlcyxcbiAgICAgICAgbWFwVmFsdWVzTGltaXQ6IG1hcFZhbHVlc0xpbWl0JDEsXG4gICAgICAgIG1hcFZhbHVlc1NlcmllcyxcbiAgICAgICAgbWVtb2l6ZSxcbiAgICAgICAgbmV4dFRpY2ssXG4gICAgICAgIHBhcmFsbGVsOiBwYXJhbGxlbCQxLFxuICAgICAgICBwYXJhbGxlbExpbWl0LFxuICAgICAgICBwcmlvcml0eVF1ZXVlLFxuICAgICAgICBxdWV1ZTogcXVldWUkMSxcbiAgICAgICAgcmFjZTogcmFjZSQxLFxuICAgICAgICByZWR1Y2U6IHJlZHVjZSQxLFxuICAgICAgICByZWR1Y2VSaWdodCxcbiAgICAgICAgcmVmbGVjdCxcbiAgICAgICAgcmVmbGVjdEFsbCxcbiAgICAgICAgcmVqZWN0OiByZWplY3QkMixcbiAgICAgICAgcmVqZWN0TGltaXQ6IHJlamVjdExpbWl0JDEsXG4gICAgICAgIHJlamVjdFNlcmllczogcmVqZWN0U2VyaWVzJDEsXG4gICAgICAgIHJldHJ5LFxuICAgICAgICByZXRyeWFibGUsXG4gICAgICAgIHNlcSxcbiAgICAgICAgc2VyaWVzLFxuICAgICAgICBzZXRJbW1lZGlhdGU6IHNldEltbWVkaWF0ZSQxLFxuICAgICAgICBzb21lOiBzb21lJDEsXG4gICAgICAgIHNvbWVMaW1pdDogc29tZUxpbWl0JDEsXG4gICAgICAgIHNvbWVTZXJpZXM6IHNvbWVTZXJpZXMkMSxcbiAgICAgICAgc29ydEJ5OiBzb3J0QnkkMSxcbiAgICAgICAgdGltZW91dCxcbiAgICAgICAgdGltZXMsXG4gICAgICAgIHRpbWVzTGltaXQsXG4gICAgICAgIHRpbWVzU2VyaWVzLFxuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIHRyeUVhY2g6IHRyeUVhY2gkMSxcbiAgICAgICAgdW5tZW1vaXplLFxuICAgICAgICB1bnRpbCxcbiAgICAgICAgd2F0ZXJmYWxsOiB3YXRlcmZhbGwkMSxcbiAgICAgICAgd2hpbHN0OiB3aGlsc3QkMSxcblxuICAgICAgICAvLyBhbGlhc2VzXG4gICAgICAgIGFsbDogZXZlcnkkMSxcbiAgICAgICAgYWxsTGltaXQ6IGV2ZXJ5TGltaXQkMSxcbiAgICAgICAgYWxsU2VyaWVzOiBldmVyeVNlcmllcyQxLFxuICAgICAgICBhbnk6IHNvbWUkMSxcbiAgICAgICAgYW55TGltaXQ6IHNvbWVMaW1pdCQxLFxuICAgICAgICBhbnlTZXJpZXM6IHNvbWVTZXJpZXMkMSxcbiAgICAgICAgZmluZDogZGV0ZWN0JDEsXG4gICAgICAgIGZpbmRMaW1pdDogZGV0ZWN0TGltaXQkMSxcbiAgICAgICAgZmluZFNlcmllczogZGV0ZWN0U2VyaWVzJDEsXG4gICAgICAgIGZsYXRNYXA6IGNvbmNhdCQxLFxuICAgICAgICBmbGF0TWFwTGltaXQ6IGNvbmNhdExpbWl0JDEsXG4gICAgICAgIGZsYXRNYXBTZXJpZXM6IGNvbmNhdFNlcmllcyQxLFxuICAgICAgICBmb3JFYWNoOiBlYWNoLFxuICAgICAgICBmb3JFYWNoU2VyaWVzOiBlYWNoU2VyaWVzJDEsXG4gICAgICAgIGZvckVhY2hMaW1pdDogZWFjaExpbWl0JDIsXG4gICAgICAgIGZvckVhY2hPZjogZWFjaE9mJDEsXG4gICAgICAgIGZvckVhY2hPZlNlcmllczogZWFjaE9mU2VyaWVzJDEsXG4gICAgICAgIGZvckVhY2hPZkxpbWl0OiBlYWNoT2ZMaW1pdCQyLFxuICAgICAgICBpbmplY3Q6IHJlZHVjZSQxLFxuICAgICAgICBmb2xkbDogcmVkdWNlJDEsXG4gICAgICAgIGZvbGRyOiByZWR1Y2VSaWdodCxcbiAgICAgICAgc2VsZWN0OiBmaWx0ZXIkMSxcbiAgICAgICAgc2VsZWN0TGltaXQ6IGZpbHRlckxpbWl0JDEsXG4gICAgICAgIHNlbGVjdFNlcmllczogZmlsdGVyU2VyaWVzJDEsXG4gICAgICAgIHdyYXBTeW5jOiBhc3luY2lmeSxcbiAgICAgICAgZHVyaW5nOiB3aGlsc3QkMSxcbiAgICAgICAgZG9EdXJpbmc6IGRvV2hpbHN0JDFcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5kZWZhdWx0ID0gaW5kZXg7XG4gICAgZXhwb3J0cy5hcHBseSA9IGFwcGx5O1xuICAgIGV4cG9ydHMuYXBwbHlFYWNoID0gYXBwbHlFYWNoJDE7XG4gICAgZXhwb3J0cy5hcHBseUVhY2hTZXJpZXMgPSBhcHBseUVhY2hTZXJpZXM7XG4gICAgZXhwb3J0cy5hc3luY2lmeSA9IGFzeW5jaWZ5O1xuICAgIGV4cG9ydHMuYXV0byA9IGF1dG87XG4gICAgZXhwb3J0cy5hdXRvSW5qZWN0ID0gYXV0b0luamVjdDtcbiAgICBleHBvcnRzLmNhcmdvID0gY2FyZ287XG4gICAgZXhwb3J0cy5jYXJnb1F1ZXVlID0gY2FyZ28kMTtcbiAgICBleHBvcnRzLmNvbXBvc2UgPSBjb21wb3NlO1xuICAgIGV4cG9ydHMuY29uY2F0ID0gY29uY2F0JDE7XG4gICAgZXhwb3J0cy5jb25jYXRMaW1pdCA9IGNvbmNhdExpbWl0JDE7XG4gICAgZXhwb3J0cy5jb25jYXRTZXJpZXMgPSBjb25jYXRTZXJpZXMkMTtcbiAgICBleHBvcnRzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgZXhwb3J0cy5kZXRlY3QgPSBkZXRlY3QkMTtcbiAgICBleHBvcnRzLmRldGVjdExpbWl0ID0gZGV0ZWN0TGltaXQkMTtcbiAgICBleHBvcnRzLmRldGVjdFNlcmllcyA9IGRldGVjdFNlcmllcyQxO1xuICAgIGV4cG9ydHMuZGlyID0gZGlyO1xuICAgIGV4cG9ydHMuZG9VbnRpbCA9IGRvVW50aWw7XG4gICAgZXhwb3J0cy5kb1doaWxzdCA9IGRvV2hpbHN0JDE7XG4gICAgZXhwb3J0cy5lYWNoID0gZWFjaDtcbiAgICBleHBvcnRzLmVhY2hMaW1pdCA9IGVhY2hMaW1pdCQyO1xuICAgIGV4cG9ydHMuZWFjaE9mID0gZWFjaE9mJDE7XG4gICAgZXhwb3J0cy5lYWNoT2ZMaW1pdCA9IGVhY2hPZkxpbWl0JDI7XG4gICAgZXhwb3J0cy5lYWNoT2ZTZXJpZXMgPSBlYWNoT2ZTZXJpZXMkMTtcbiAgICBleHBvcnRzLmVhY2hTZXJpZXMgPSBlYWNoU2VyaWVzJDE7XG4gICAgZXhwb3J0cy5lbnN1cmVBc3luYyA9IGVuc3VyZUFzeW5jO1xuICAgIGV4cG9ydHMuZXZlcnkgPSBldmVyeSQxO1xuICAgIGV4cG9ydHMuZXZlcnlMaW1pdCA9IGV2ZXJ5TGltaXQkMTtcbiAgICBleHBvcnRzLmV2ZXJ5U2VyaWVzID0gZXZlcnlTZXJpZXMkMTtcbiAgICBleHBvcnRzLmZpbHRlciA9IGZpbHRlciQxO1xuICAgIGV4cG9ydHMuZmlsdGVyTGltaXQgPSBmaWx0ZXJMaW1pdCQxO1xuICAgIGV4cG9ydHMuZmlsdGVyU2VyaWVzID0gZmlsdGVyU2VyaWVzJDE7XG4gICAgZXhwb3J0cy5mb3JldmVyID0gZm9yZXZlciQxO1xuICAgIGV4cG9ydHMuZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgZXhwb3J0cy5ncm91cEJ5TGltaXQgPSBncm91cEJ5TGltaXQkMTtcbiAgICBleHBvcnRzLmdyb3VwQnlTZXJpZXMgPSBncm91cEJ5U2VyaWVzO1xuICAgIGV4cG9ydHMubG9nID0gbG9nO1xuICAgIGV4cG9ydHMubWFwID0gbWFwJDE7XG4gICAgZXhwb3J0cy5tYXBMaW1pdCA9IG1hcExpbWl0JDE7XG4gICAgZXhwb3J0cy5tYXBTZXJpZXMgPSBtYXBTZXJpZXMkMTtcbiAgICBleHBvcnRzLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICBleHBvcnRzLm1hcFZhbHVlc0xpbWl0ID0gbWFwVmFsdWVzTGltaXQkMTtcbiAgICBleHBvcnRzLm1hcFZhbHVlc1NlcmllcyA9IG1hcFZhbHVlc1NlcmllcztcbiAgICBleHBvcnRzLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbiAgICBleHBvcnRzLnBhcmFsbGVsID0gcGFyYWxsZWwkMTtcbiAgICBleHBvcnRzLnBhcmFsbGVsTGltaXQgPSBwYXJhbGxlbExpbWl0O1xuICAgIGV4cG9ydHMucHJpb3JpdHlRdWV1ZSA9IHByaW9yaXR5UXVldWU7XG4gICAgZXhwb3J0cy5xdWV1ZSA9IHF1ZXVlJDE7XG4gICAgZXhwb3J0cy5yYWNlID0gcmFjZSQxO1xuICAgIGV4cG9ydHMucmVkdWNlID0gcmVkdWNlJDE7XG4gICAgZXhwb3J0cy5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGV4cG9ydHMucmVmbGVjdCA9IHJlZmxlY3Q7XG4gICAgZXhwb3J0cy5yZWZsZWN0QWxsID0gcmVmbGVjdEFsbDtcbiAgICBleHBvcnRzLnJlamVjdCA9IHJlamVjdCQyO1xuICAgIGV4cG9ydHMucmVqZWN0TGltaXQgPSByZWplY3RMaW1pdCQxO1xuICAgIGV4cG9ydHMucmVqZWN0U2VyaWVzID0gcmVqZWN0U2VyaWVzJDE7XG4gICAgZXhwb3J0cy5yZXRyeSA9IHJldHJ5O1xuICAgIGV4cG9ydHMucmV0cnlhYmxlID0gcmV0cnlhYmxlO1xuICAgIGV4cG9ydHMuc2VxID0gc2VxO1xuICAgIGV4cG9ydHMuc2VyaWVzID0gc2VyaWVzO1xuICAgIGV4cG9ydHMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlJDE7XG4gICAgZXhwb3J0cy5zb21lID0gc29tZSQxO1xuICAgIGV4cG9ydHMuc29tZUxpbWl0ID0gc29tZUxpbWl0JDE7XG4gICAgZXhwb3J0cy5zb21lU2VyaWVzID0gc29tZVNlcmllcyQxO1xuICAgIGV4cG9ydHMuc29ydEJ5ID0gc29ydEJ5JDE7XG4gICAgZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dDtcbiAgICBleHBvcnRzLnRpbWVzID0gdGltZXM7XG4gICAgZXhwb3J0cy50aW1lc0xpbWl0ID0gdGltZXNMaW1pdDtcbiAgICBleHBvcnRzLnRpbWVzU2VyaWVzID0gdGltZXNTZXJpZXM7XG4gICAgZXhwb3J0cy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgZXhwb3J0cy50cnlFYWNoID0gdHJ5RWFjaCQxO1xuICAgIGV4cG9ydHMudW5tZW1vaXplID0gdW5tZW1vaXplO1xuICAgIGV4cG9ydHMudW50aWwgPSB1bnRpbDtcbiAgICBleHBvcnRzLndhdGVyZmFsbCA9IHdhdGVyZmFsbCQxO1xuICAgIGV4cG9ydHMud2hpbHN0ID0gd2hpbHN0JDE7XG4gICAgZXhwb3J0cy5hbGwgPSBldmVyeSQxO1xuICAgIGV4cG9ydHMuYWxsTGltaXQgPSBldmVyeUxpbWl0JDE7XG4gICAgZXhwb3J0cy5hbGxTZXJpZXMgPSBldmVyeVNlcmllcyQxO1xuICAgIGV4cG9ydHMuYW55ID0gc29tZSQxO1xuICAgIGV4cG9ydHMuYW55TGltaXQgPSBzb21lTGltaXQkMTtcbiAgICBleHBvcnRzLmFueVNlcmllcyA9IHNvbWVTZXJpZXMkMTtcbiAgICBleHBvcnRzLmZpbmQgPSBkZXRlY3QkMTtcbiAgICBleHBvcnRzLmZpbmRMaW1pdCA9IGRldGVjdExpbWl0JDE7XG4gICAgZXhwb3J0cy5maW5kU2VyaWVzID0gZGV0ZWN0U2VyaWVzJDE7XG4gICAgZXhwb3J0cy5mbGF0TWFwID0gY29uY2F0JDE7XG4gICAgZXhwb3J0cy5mbGF0TWFwTGltaXQgPSBjb25jYXRMaW1pdCQxO1xuICAgIGV4cG9ydHMuZmxhdE1hcFNlcmllcyA9IGNvbmNhdFNlcmllcyQxO1xuICAgIGV4cG9ydHMuZm9yRWFjaCA9IGVhY2g7XG4gICAgZXhwb3J0cy5mb3JFYWNoU2VyaWVzID0gZWFjaFNlcmllcyQxO1xuICAgIGV4cG9ydHMuZm9yRWFjaExpbWl0ID0gZWFjaExpbWl0JDI7XG4gICAgZXhwb3J0cy5mb3JFYWNoT2YgPSBlYWNoT2YkMTtcbiAgICBleHBvcnRzLmZvckVhY2hPZlNlcmllcyA9IGVhY2hPZlNlcmllcyQxO1xuICAgIGV4cG9ydHMuZm9yRWFjaE9mTGltaXQgPSBlYWNoT2ZMaW1pdCQyO1xuICAgIGV4cG9ydHMuaW5qZWN0ID0gcmVkdWNlJDE7XG4gICAgZXhwb3J0cy5mb2xkbCA9IHJlZHVjZSQxO1xuICAgIGV4cG9ydHMuZm9sZHIgPSByZWR1Y2VSaWdodDtcbiAgICBleHBvcnRzLnNlbGVjdCA9IGZpbHRlciQxO1xuICAgIGV4cG9ydHMuc2VsZWN0TGltaXQgPSBmaWx0ZXJMaW1pdCQxO1xuICAgIGV4cG9ydHMuc2VsZWN0U2VyaWVzID0gZmlsdGVyU2VyaWVzJDE7XG4gICAgZXhwb3J0cy53cmFwU3luYyA9IGFzeW5jaWZ5O1xuICAgIGV4cG9ydHMuZHVyaW5nID0gd2hpbHN0JDE7XG4gICAgZXhwb3J0cy5kb0R1cmluZyA9IGRvV2hpbHN0JDE7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl0sIm1hcHBpbmdzIjoiOztBQUFDLFdBQVVBLE1BQU0sRUFBRUMsT0FBTyxFQUFFO0VBQ3hCLE9BQU9DLE9BQU8sS0FBSyxRQUFRLElBQUksT0FBT0MsTUFBTSxLQUFLLFdBQVcsR0FBR0YsT0FBTyxDQUFDQyxPQUFPLENBQUMsR0FDL0UsT0FBT0UsTUFBTSxLQUFLLFVBQVUsSUFBSUEsTUFBTSxDQUFDQyxHQUFHLEdBQUdELE1BQU0sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFFSCxPQUFPLENBQUMsR0FDeEVB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksU0FBUzRDLE9BQU9BLENBQUM3QyxNQUFNLEVBQUVwRixXQUFXLEVBQUVxRixPQUFPLEVBQUU7SUFDM0MsT0FBT0YsS0FBSyxDQUFDQyxNQUFNLEVBQUVwRixXQUFXLEVBQUVxRixPQUFPLENBQUM7RUFDOUM7O0VBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksU0FB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LENBQUM7SUFDTixDQUFDLEVBQUVBLEdBQUcsSUFBSTFCLFFBQVEsQ0FBQzBCLEdBQUcsRUFBRThCLE9BQU8sQ0FBQyxDQUFDO0VBQ3JDLENBQUMsRUFBRSxDQUFDLENBQUM7O0VBRUw7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0ks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","map":{"version":3,"names":["global","factory","exports","module","define","amd","async","apply","fn","args","callArgs","initialParams","callback","pop","call","hasQueueMicrotask","queueMicrotask","hasSetImmediate","setImmediate","hasNextTick","process","nextTick","fallback","setTimeout","wrap","defer","_defer","setImmediate$1","asyncify","func","isAsync","promise","handlePromise","result","e","then","value","invokeCallback","err","message","Error","error","Symbol","toStringTag","isAsyncGenerator","isAsyncIterable","obj","asyncIterator","wrapAsync","asyncFn","awaitify","arity","length","awaitable","Promise","resolve","reject","cbArgs","applyEach","eachfn","fns","go","that","cb","concat","_asyncMap","arr","iteratee","results","counter","_iteratee","_","iterCb","index","v","isArrayLike","breakLoop","once","wrapper","callFn","Object","assign","getIterator","coll","iterator","createArrayIterator","i","len","next","key","createES2015Iterator","item","done","createObjectIterator","okeys","keys","createIterator","onlyOnce","asyncEachOfLimit","generator","limit","canceled","awaiting","running","idx","replenish","iterDone","iterateeCallback","catch","handleError","eachOfLimit","RangeError","nextElem","looping","elem","eachOfLimit$1","eachOfLimit$2","eachOfArrayLike","completed","iteratorCallback","eachOfGeneric","Infinity","eachOf","eachOfImplementation","eachOf$1","map","map$1","applyEach$1","eachOfSeries","eachOfSeries$1","mapSeries","mapSeries$1","applyEachSeries","PROMISE_SYMBOL","promiseCallback","res","rej","auto","tasks","concurrency","numTasks","runningTasks","hasError","listeners","create","readyTasks","readyToCheck","uncheckedDependencies","forEach","task","Array","isArray","enqueueTask","push","dependencies","slice","remainingDependencies","dependencyName","join","addListener","checkForDeadlocks","processQueue","runTask","run","shift","taskName","taskListeners","taskComplete","taskCallback","safeResults","rkey","taskFn","currentTask","getDependents","dependent","indexOf","FN_ARGS","ARROW_FN_ARGS","FN_ARG_SPLIT","FN_ARG","stripComments","string","stripped","endBlockComment","endIndex","parseParams","src","toString","match","replace","split","arg","trim","autoInject","newTasks","params","fnIsAsync","hasNoDeps","newTask","taskCb","newArgs","name","DLL","constructor","head","tail","removeLink","node","prev","empty","insertAfter","newNode","insertBefore","unshift","setInitial","toArray","cur","data","remove","testFn","curr","dll","queue","worker","payload","_worker","numRunning","workersList","events","drain","saturated","unsaturated","on","event","handler","handleAndRemove","off","ev","filter","trigger","processingScheduled","_insert","insertAtFront","rejectOnError","q","started","_createTaskItem","_tasks","_createCB","l","splice","buffer","idle","_maybeDrain","eventMethod","isProcessing","paused","datum","pushAsync","kill","unshiftAsync","Math","min","pause","resume","defineProperties","writable","cargo","cargo$1","reduce","memo","x","reduce$1","seq","functions","_functions","newargs","nextargs","compose","reverse","mapLimit","mapLimit$1","concatLimit","val","mapResults","concatLimit$1","concat$1","concatSeries","concatSeries$1","constant","ignoredArgs","_createTester","check","getResult","testPassed","testResult","detect","bool","detect$1","detectLimit","detectLimit$1","detectSeries","detectSeries$1","consoleFunc","resultArgs","console","dir","doWhilst","test","_fn","_test","truth","doWhilst$1","doUntil","_withoutIndex","eachLimit","each","eachLimit$1","eachLimit$2","eachSeries","eachSeries$1","ensureAsync","sync","innerArgs","every","every$1","everyLimit","everyLimit$1","everySeries","everySeries$1","filterArray","truthValues","filterGeneric","sort","a","b","_filter","filter$1","filterLimit","filterLimit$1","filterSeries","filterSeries$1","forever","errback","forever$1","groupByLimit","hasOwnProperty","prototype","groupByLimit$1","groupBy","groupBySeries","log","mapValuesLimit","newObj","mapValuesLimit$1","mapValues","mapValuesSeries","memoize","hasher","queues","memoized","unmemoized","_defer$1","parallel","parallel$1","parallelLimit","queue$1","items","Heap","heap","pushCount","Number","MIN_SAFE_INTEGER","percUp","p","smaller","parent","t","percDown","leftChi","top","j","y","priority","priorityQueue","createDataItems","race","TypeError","race$1","reduceRight","array","reversed","reflect","reflectOn","reflectCallback","retVal","reflectAll","reject$1","reject$2","rejectLimit","rejectLimit$1","rejectSeries","rejectSeries$1","constant$1","DEFAULT_TIMES","DEFAULT_INTERVAL","retry","opts","options","times","intervalFunc","arguments","parseTimes","_task","attempt","retryAttempt","errorFilter","acc","interval","retryable","series","some","Boolean","some$1","someLimit","someLimit$1","someSeries","someSeries$1","sortBy","criteria","comparator","left","right","sortBy$1","timeout","milliseconds","info","timedOut","timer","timeoutCallback","code","clearTimeout","range","size","timesLimit","count","n","timesSeries","transform","accumulator","k","tryEach","tryEach$1","unmemoize","whilst","rest","whilst$1","until","waterfall","taskIndex","nextTask","waterfall$1","cargoQueue","all","allLimit","allSeries","any","anyLimit","anySeries","find","findLimit","findSeries","flatMap","flatMapLimit","flatMapSeries","forEachSeries","forEachLimit","forEachOf","forEachOfSeries","forEachOfLimit","inject","foldl","foldr","select","selectLimit","selectSeries","wrapSync","during","doDuring","default","defineProperty"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\async@3.2.4\\node_modules\\async\\dist\\","sources":["async.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (factory((global.async = {})));\n}(this, (function (exports) { 'use strict';\n\n    /**\n     * Creates a continuation function with some arguments already applied.\n     *\n     * Useful as a shorthand when combined with other control flow functions. Any\n     * arguments passed to the returned function are added to the arguments\n     * originally passed to apply.\n     *\n     * @name apply\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {Function} fn - The function you want to eventually apply all\n     * arguments to. Invokes with (arguments...).\n     * @param {...*} arguments... - Any number of arguments to automatically apply\n     * when the continuation is called.\n     * @returns {Function} the partially-applied function\n     * @example\n     *\n     * // using apply\n     * async.parallel([\n     *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n     *     async.apply(fs.writeFile, 'testfile2', 'test2')\n     * ]);\n     *\n     *\n     * // the same process without using apply\n     * async.parallel([\n     *     function(callback) {\n     *         fs.writeFile('testfile1', 'test1', callback);\n     *     },\n     *     function(callback) {\n     *         fs.writeFile('testfile2', 'test2', callback);\n     *     }\n     * ]);\n     *\n     * // It's possible to pass any number of additional arguments when calling the\n     * // continuation:\n     *\n     * node> var fn = async.apply(sys.puts, 'one');\n     * node> fn('two', 'three');\n     * one\n     * two\n     * three\n     */\n    function apply(fn, ...args) {\n        return (...callArgs) => fn(...args,...callArgs);\n    }\n\n    function initialParams (fn) {\n        return function (...args/*, callback*/) {\n            var callback = args.pop();\n            return fn.call(this, args, callback);\n        };\n    }\n\n    /* istanbul ignore file */\n\n    var hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;\n    var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\n    var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\n    function fallback(fn) {\n        setTimeout(fn, 0);\n    }\n\n    function wrap(defer) {\n        return (fn, ...args) => defer(() => fn(...args));\n    }\n\n    var _defer;\n\n    if (hasQueueMicrotask) {\n        _defer = queueMicrotask;\n    } else if (hasSetImmediate) {\n        _defer = setImmediate;\n    } else if (hasNextTick) {\n        _defer = process.nextTick;\n    } else {\n        _defer = fallback;\n    }\n\n    var setImmediate$1 = wrap(_defer);\n\n    /**\n     * Take a sync function and make it async, passing its return value to a\n     * callback. This is useful for plugging sync functions into a waterfall,\n     * series, or other async functions. Any arguments passed to the generated\n     * function will be passed to the wrapped function (except for the final\n     * callback argument). Errors thrown will be passed to the callback.\n     *\n     * If the function passed to `asyncify` returns a Promise, that promises's\n     * resolved/rejected state will be used to call the callback, rather than simply\n     * the synchronous return value.\n     *\n     * This also means you can asyncify ES2017 `async` functions.\n     *\n     * @name asyncify\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @alias wrapSync\n     * @category Util\n     * @param {Function} func - The synchronous function, or Promise-returning\n     * function to convert to an {@link AsyncFunction}.\n     * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n     * invoked with `(args..., callback)`.\n     * @example\n     *\n     * // passing a regular synchronous function\n     * async.waterfall([\n     *     async.apply(fs.readFile, filename, \"utf8\"),\n     *     async.asyncify(JSON.parse),\n     *     function (data, next) {\n     *         // data is the result of parsing the text.\n     *         // If there was a parsing error, it would have been caught.\n     *     }\n     * ], callback);\n     *\n     * // passing a function returning a promise\n     * async.waterfall([\n     *     async.apply(fs.readFile, filename, \"utf8\"),\n     *     async.asyncify(function (contents) {\n     *         return db.model.create(contents);\n     *     }),\n     *     function (model, next) {\n     *         // `model` is the instantiated model object.\n     *         // If there was an error, this function would be skipped.\n     *     }\n     * ], callback);\n     *\n     * // es2017 example, though `asyncify` is not needed if your JS environment\n     * // supports async functions out of the box\n     * var q = async.queue(async.asyncify(async function(file) {\n     *     var intermediateStep = await processFile(file);\n     *     return await somePromise(intermediateStep)\n     * }));\n     *\n     * q.push(files);\n     */\n    function asyncify(func) {\n        if (isAsync(func)) {\n            return function (...args/*, callback*/) {\n                const callback = args.pop();\n                const promise = func.apply(this, args);\n                return handlePromise(promise, callback)\n            }\n        }\n\n        return initialParams(function (args, callback) {\n            var result;\n            try {\n                result = func.apply(this, args);\n            } catch (e) {\n                return callback(e);\n            }\n            // if result is Promise object\n            if (result && typeof result.then === 'function') {\n                return handlePromise(result, callback)\n            } else {\n                callback(null, result);\n            }\n        });\n    }\n\n    function handlePromise(promise, callback) {\n        return promise.then(value => {\n            invokeCallback(callback, null, value);\n        }, err => {\n            invokeCallback(callback, err && err.message ? err : new Error(err));\n        });\n    }\n\n    function invokeCallback(callback, error, value) {\n        try {\n            callback(error, value);\n        } catch (err) {\n            setImmediate$1(e => { throw e }, err);\n        }\n    }\n\n    function isAsync(fn) {\n        return fn[Symbol.toStringTag] === 'AsyncFunction';\n    }\n\n    function isAsyncGenerator(fn) {\n        return fn[Symbol.toStringTag] === 'AsyncGenerator';\n    }\n\n    function isAsyncIterable(obj) {\n        return typeof obj[Symbol.asyncIterator] === 'function';\n    }\n\n    function wrapAsync(asyncFn) {\n        if (typeof asyncFn !== 'function') throw new Error('expected a function')\n        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n    }\n\n    // conditionally promisify a function.\n    // only return a promise if a callback is omitted\n    function awaitify (asyncFn, arity = asyncFn.length) {\n        if (!arity) throw new Error('arity is undefined')\n        function awaitable (...args) {\n            if (typeof args[arity - 1] === 'function') {\n                return asyncFn.apply(this, args)\n            }\n\n            return new Promise((resolve, reject) => {\n                args[arity - 1] = (err, ...cbArgs) => {\n                    if (err) return reject(err)\n                    resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);\n                };\n                asyncFn.apply(this, args);\n            })\n        }\n\n        return awaitable\n    }\n\n    function applyEach (eachfn) {\n        return function applyEach(fns, ...callArgs) {\n            const go = awaitify(function (callback) {\n                var that = this;\n                return eachfn(fns, (fn, cb) => {\n                    wrapAsync(fn).apply(that, callArgs.concat(cb));\n                }, callback);\n            });\n            return go;\n        };\n    }\n\n    function _asyncMap(eachfn, arr, iteratee, callback) {\n        arr = arr || [];\n        var results = [];\n        var counter = 0;\n        var _iteratee = wrapAsync(iteratee);\n\n        return eachfn(arr, (value, _, iterCb) => {\n            var index = counter++;\n            _iteratee(value, (err, v) => {\n                results[index] = v;\n                iterCb(err);\n            });\n        }, err => {\n            callback(err, results);\n        });\n    }\n\n    function isArrayLike(value) {\n        return value &&\n            typeof value.length === 'number' &&\n            value.length >= 0 &&\n            value.length % 1 === 0;\n    }\n\n    // A temporary value used to identify if the loop should be broken.\n    // See #1064, #1293\n    const breakLoop = {};\n\n    function once(fn) {\n        function wrapper (...args) {\n            if (fn === null) return;\n            var callFn = fn;\n            fn = null;\n            callFn.apply(this, args);\n        }\n        Object.assign(wrapper, fn);\n        return wrapper\n    }\n\n    function getIterator (coll) {\n        return coll[Symbol.iterator] && coll[Symbol.iterator]();\n    }\n\n    function createArrayIterator(coll) {\n        var i = -1;\n        var len = coll.length;\n        return function next() {\n            return ++i < len ? {value: coll[i], key: i} : null;\n        }\n    }\n\n    function createES2015Iterator(iterator) {\n        var i = -1;\n        return function next() {\n            var item = iterator.next();\n            if (item.done)\n                return null;\n            i++;\n            return {value: item.value, key: i};\n        }\n    }\n\n    function createObjectIterator(obj) {\n        var okeys = obj ? Object.keys(obj) : [];\n        var i = -1;\n        var len = okeys.length;\n        return function next() {\n            var key = okeys[++i];\n            if (key === '__proto__') {\n                return next();\n            }\n            return i < len ? {value: obj[key], key} : null;\n        };\n    }\n\n    function createIterator(coll) {\n        if (isArrayLike(coll)) {\n            return createArrayIterator(coll);\n        }\n\n        var iterator = getIterator(coll);\n        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n    }\n\n    function onlyOnce(fn) {\n        return function (...args) {\n            if (fn === null) throw new Error(\"Callback was already called.\");\n            var callFn = fn;\n            fn = null;\n            callFn.apply(this, args);\n        };\n    }\n\n    // for async generators\n    function asyncEachOfLimit(generator, limit, iteratee, callback) {\n        let done = false;\n        let canceled = false;\n        let awaiting = false;\n        let running = 0;\n        let idx = 0;\n\n        function replenish() {\n            //console.log('replenish')\n            if (running >= limit || awaiting || done) return\n            //console.log('replenish awaiting')\n            awaiting = true;\n            generator.next().then(({value, done: iterDone}) => {\n                //console.log('got value', value)\n                if (canceled || done) return\n                awaiting = false;\n                if (iterDone) {\n                    done = true;\n                    if (running <= 0) {\n                        //console.log('done nextCb')\n                        callback(null);\n                    }\n                    return;\n                }\n                running++;\n                iteratee(value, idx, iterateeCallback);\n                idx++;\n                replenish();\n            }).catch(handleError);\n        }\n\n        function iterateeCallback(err, result) {\n            //console.log('iterateeCallback')\n            running -= 1;\n            if (canceled) return\n            if (err) return handleError(err)\n\n            if (err === false) {\n                done = true;\n                canceled = true;\n                return\n            }\n\n            if (result === breakLoop || (done && running <= 0)) {\n                done = true;\n                //console.log('done iterCb')\n                return callback(null);\n            }\n            replenish();\n        }\n\n        function handleError(err) {\n            if (canceled) return\n            awaiting = false;\n            done = true;\n            callback(err);\n        }\n\n        replenish();\n    }\n\n    var eachOfLimit = (limit) => {\n        return (obj, iteratee, callback) => {\n            callback = once(callback);\n            if (limit <= 0) {\n                throw new RangeError('concurrency limit cannot be less than 1')\n            }\n            if (!obj) {\n                return callback(null);\n            }\n            if (isAsyncGenerator(obj)) {\n                return asyncEachOfLimit(obj, limit, iteratee, callback)\n            }\n            if (isAsyncIterable(obj)) {\n                return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback)\n            }\n            var nextElem = createIterator(obj);\n            var done = false;\n            var canceled = false;\n            var running = 0;\n            var looping = false;\n\n            function iterateeCallback(err, value) {\n                if (canceled) return\n                running -= 1;\n                if (err) {\n                    done = true;\n                    callback(err);\n                }\n                else if (err === false) {\n                    done = true;\n                    canceled = true;\n                }\n                else if (value === breakLoop || (done && running <= 0)) {\n                    done = true;\n                    return callback(null);\n                }\n                else if (!looping) {\n                    replenish();\n                }\n            }\n\n            function replenish () {\n                looping = true;\n                while (running < limit && !done) {\n                    var elem = nextElem();\n                    if (elem === null) {\n                        done = true;\n                        if (running <= 0) {\n                            callback(null);\n                        }\n                        return;\n                    }\n                    running += 1;\n                    iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n                }\n                looping = false;\n            }\n\n            replenish();\n        };\n    };\n\n    /**\n     * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n     * time.\n     *\n     * @name eachOfLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.eachOf]{@link module:Collections.eachOf}\n     * @alias forEachOfLimit\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - An async function to apply to each\n     * item in `coll`. The `key` is the item's key, or index in the case of an\n     * array.\n     * Invoked with (item, key, callback).\n     * @param {Function} [callback] - A callback which is called when all\n     * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n     * @returns {Promise} a promise, if a callback is omitted\n     */\n    function eachOfLimit$1(coll, limit, iteratee, callback) {\n        return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);\n    }\n\n    var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);\n\n    // eachOf implementation optimized for array-likes\n    function eachOfArrayLike(coll, iteratee, callback) {\n        callback = once(callback);\n        var index = 0,\n            completed = 0,\n            {length} = coll,\n            canceled = false;\n        if (length === 0) {\n            callback(null);\n        }\n\n        function iteratorCallback(err, value) {\n            if (err === false) {\n                canceled = true;\n            }\n            if (canceled === true) return\n            if (err) {\n                callback(err);\n            } else if ((++completed === length) || value === breakLoop) {\n                callback(null);\n            }\n        }\n\n        for (; index < length; index++) {\n            iteratee(coll[index], index, onlyOnce(iteratorCallback));\n        }\n    }\n\n    // a generic version of eachOf which can handle array, object, and iterator cases.\n    function eachOfGeneric (coll, iteratee, callback) {\n        return eachOfLimit$2(coll, Infinity, iteratee, callback);\n    }\n\n    /**\n     * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n     * to the iteratee.\n     *\n     * @name eachOf\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @alias forEachOf\n     * @category Collection\n     * @see [async.each]{@link module:Collections.each}\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - A function to apply to each\n     * item in `coll`.\n     * The `key` is the item's key, or index in the case of an array.\n     * Invoked with (item, key, callback).\n     * @param {Function} [callback] - A callback which is called when all\n     * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n     * @returns {Promise} a promise, if a callback is omitted\n     * @example\n     *\n     * // dev.json is a file containing a valid json object config for dev environment\n     * // dev.json is a file containing a valid json object config for test environment\n     * // prod.json is a file containing a valid json object config for prod environment\n     * // invalid.json is a file with a malformed json object\n     *\n     * let configs = {}; //global variable\n     * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};\n     * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};\n     *\n     * // asynchronous function that reads a json file and parses the contents as json object\n     * function parseFile(file, key, callback) {\n     *     fs.readFile(file, \"utf8\", function(err, data) {\n     *         if (err) return calback(err);\n     *         try {\n     *             configs[key] = JSON.parse(data);\n     *         } catch (e) {\n     *             return callback(e);\n     *         }\n     *         callback();\n     *     });\n     * }\n     *\n     * // Using callbacks\n     * async.forEachOf(validConfigFileMap, parseFile, function (err) {\n     *     if (err) {\n     *         console.error(err);\n     *     } else {\n     *         console.log(configs);\n     *         // configs is now a map of JSON data, e.g.\n     *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n     *     }\n     * });\n     *\n     * //Error handing\n     * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {\n     *     if (err) {\n     *         console.error(err);\n     *         // JSON parse error exception\n     *     } else {\n     *         console.log(configs);\n     *     }\n     * });\n     *\n     * // Using Promises\n     * async.forEachOf(validConfigFileMap, parseFile)\n     * .then( () => {\n     *     console.log(configs);\n     *     // configs is now a map of JSON data, e.g.\n     *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n     * }).catch( err => {\n     *     console.error(err);\n     * });\n     *\n     * //Error handing\n     * async.forEachOf(invalidConfigFileMap, parseFile)\n     * .then( () => {\n     *     console.log(configs);\n     * }).catch( err => {\n     *     console.error(err);\n     *     // JSON parse error exception\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.forEachOf(validConfigFileMap, parseFile);\n     *         console.log(configs);\n     *         // configs is now a map of JSON data, e.g.\n     *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * //Error handing\n     * async () => {\n     *     try {\n     *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);\n     *         console.log(configs);\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *         // JSON parse error exception\n     *     }\n     * }\n     *\n     */\n    function eachOf(coll, iteratee, callback) {\n        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n        return eachOfImplementation(coll, wrapAsync(iteratee), callback);\n    }\n\n    var eachOf$1 = awaitify(eachOf, 3);\n\n    /**\n     * Produces a new collection of values by mapping each value in `coll` through\n     * the `iteratee` function. The `iteratee` is called with an item from `coll`\n     * and a callback for when it has finished processing. Each of these callbacks\n     * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n     * `iteratee` passes an error to its callback, the main `callback` (for the\n     * `map` function) is immediately called with the error.\n     *\n     * Note, that since this function applies the `iteratee` to each item in\n     * parallel, there is no guarantee that the `iteratee` functions will complete\n     * in order. However, the results array will be in the same order as the\n     * original `coll`.\n     *\n     * If `map` is passed an Object, the results will be an Array.  The results\n     * will roughly be in the order of the original Objects' keys (but this can\n     * vary across JavaScript engines).\n     *\n     * @name map\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The iteratee should complete with the transformed item.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. Results is an Array of the\n     * transformed items from the `coll`. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * // file1.txt is a file that is 1000 bytes in size\n     * // file2.txt is a file that is 2000 bytes in size\n     * // file3.txt is a file that is 3000 bytes in size\n     * // file4.txt does not exist\n     *\n     * const fileList = ['file1.txt','file2.txt','file3.txt'];\n     * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];\n     *\n     * // asynchronous function that returns the file size in bytes\n     * function getFileSizeInBytes(file, callback) {\n     *     fs.stat(file, function(err, stat) {\n     *         if (err) {\n     *             return callback(err);\n     *         }\n     *         callback(null, stat.size);\n     *     });\n     * }\n     *\n     * // Using callbacks\n     * async.map(fileList, getFileSizeInBytes, function(err, results) {\n     *     if (err) {\n     *         console.log(err);\n     *     } else {\n     *         console.log(results);\n     *         // results is now an array of the file size in bytes for each file, e.g.\n     *         // [ 1000, 2000, 3000]\n     *     }\n     * });\n     *\n     * // Error Handling\n     * async.map(withMissingFileList, getFileSizeInBytes, function(err, results) {\n     *     if (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *     } else {\n     *         console.log(results);\n     *     }\n     * });\n     *\n     * // Using Promises\n     * async.map(fileList, getFileSizeInBytes)\n     * .then( results => {\n     *     console.log(results);\n     *     // results is now an array of the file size in bytes for each file, e.g.\n     *     // [ 1000, 2000, 3000]\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Error Handling\n     * async.map(withMissingFileList, getFileSizeInBytes)\n     * .then( results => {\n     *     console.log(results);\n     * }).catch( err => {\n     *     console.log(err);\n     *     // [ Error: ENOENT: no such file or directory ]\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let results = await async.map(fileList, getFileSizeInBytes);\n     *         console.log(results);\n     *         // results is now an array of the file size in bytes for each file, e.g.\n     *         // [ 1000, 2000, 3000]\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * // Error Handling\n     * async () => {\n     *     try {\n     *         let results = await async.map(withMissingFileList, getFileSizeInBytes);\n     *         console.log(results);\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *     }\n     * }\n     *\n     */\n    function map (coll, iteratee, callback) {\n        return _asyncMap(eachOf$1, coll, iteratee, callback)\n    }\n    var map$1 = awaitify(map, 3);\n\n    /**\n     * Applies the provided arguments to each function in the array, calling\n     * `callback` after all functions have completed. If you only provide the first\n     * argument, `fns`, then it will return a function which lets you pass in the\n     * arguments as if it were a single function call. If more arguments are\n     * provided, `callback` is required while `args` is still optional. The results\n     * for each of the applied async functions are passed to the final callback\n     * as an array.\n     *\n     * @name applyEach\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s\n     * to all call with the same arguments\n     * @param {...*} [args] - any number of separate arguments to pass to the\n     * function.\n     * @param {Function} [callback] - the final argument should be the callback,\n     * called when all functions have completed processing.\n     * @returns {AsyncFunction} - Returns a function that takes no args other than\n     * an optional callback, that is the result of applying the `args` to each\n     * of the functions.\n     * @example\n     *\n     * const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket')\n     *\n     * appliedFn((err, results) => {\n     *     // results[0] is the results for `enableSearch`\n     *     // results[1] is the results for `updateSchema`\n     * });\n     *\n     * // partial application example:\n     * async.each(\n     *     buckets,\n     *     async (bucket) => async.applyEach([enableSearch, updateSchema], bucket)(),\n     *     callback\n     * );\n     */\n    var applyEach$1 = applyEach(map$1);\n\n    /**\n     * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n     *\n     * @name eachOfSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.eachOf]{@link module:Collections.eachOf}\n     * @alias forEachOfSeries\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * Invoked with (item, key, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. Invoked with (err).\n     * @returns {Promise} a promise, if a callback is omitted\n     */\n    function eachOfSeries(coll, iteratee, callback) {\n        return eachOfLimit$2(coll, 1, iteratee, callback)\n    }\n    var eachOfSeries$1 = awaitify(eachOfSeries, 3);\n\n    /**\n     * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n     *\n     * @name mapSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.map]{@link module:Collections.map}\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The iteratee should complete with the transformed item.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. Results is an array of the\n     * transformed items from the `coll`. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function mapSeries (coll, iteratee, callback) {\n        return _asyncMap(eachOfSeries$1, coll, iteratee, callback)\n    }\n    var mapSeries$1 = awaitify(mapSeries, 3);\n\n    /**\n     * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n     *\n     * @name applyEachSeries\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n     * @category Control Flow\n     * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s to all\n     * call with the same arguments\n     * @param {...*} [args] - any number of separate arguments to pass to the\n     * function.\n     * @param {Function} [callback] - the final argument should be the callback,\n     * called when all functions have completed processing.\n     * @returns {AsyncFunction} - A function, that when called, is the result of\n     * appling the `args` to the list of functions.  It takes no args, other than\n     * a callback.\n     */\n    var applyEachSeries = applyEach(mapSeries$1);\n\n    const PROMISE_SYMBOL = Symbol('promiseCallback');\n\n    function promiseCallback () {\n        let resolve, reject;\n        function callback (err, ...args) {\n            if (err) return reject(err)\n            resolve(args.length > 1 ? args : args[0]);\n        }\n\n        callback[PROMISE_SYMBOL] = new Promise((res, rej) => {\n            resolve = res,\n            reject = rej;\n        });\n\n        return callback\n    }\n\n    /**\n     * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n     * their requirements. Each function can optionally depend on other functions\n     * being completed first, and each function is run as soon as its requirements\n     * are satisfied.\n     *\n     * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n     * will stop. Further tasks will not execute (so any other functions depending\n     * on it will not run), and the main `callback` is immediately called with the\n     * error.\n     *\n     * {@link AsyncFunction}s also receive an object containing the results of functions which\n     * have completed so far as the first argument, if they have dependencies. If a\n     * task function has no dependencies, it will only be passed a callback.\n     *\n     * @name auto\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {Object} tasks - An object. Each of its properties is either a\n     * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n     * in the array. The object's key of a property serves as the name of the task\n     * defined by that property, i.e. can be used when specifying requirements for\n     * other tasks. The function receives one or two arguments:\n     * * a `results` object, containing the results of the previously executed\n     *   functions, only passed if the task has any dependencies,\n     * * a `callback(err, result)` function, which must be called when finished,\n     *   passing an `error` (which can be `null`) and the result of the function's\n     *   execution.\n     * @param {number} [concurrency=Infinity] - An optional `integer` for\n     * determining the maximum number of tasks that can be run in parallel. By\n     * default, as many as possible.\n     * @param {Function} [callback] - An optional callback which is called when all\n     * the tasks have been completed. It receives the `err` argument if any `tasks`\n     * pass an error to their callback. Results are always returned; however, if an\n     * error occurs, no further `tasks` will be performed, and the results object\n     * will only contain partial results. Invoked with (err, results).\n     * @returns {Promise} a promise, if a callback is not passed\n     * @example\n     *\n     * //Using Callbacks\n     * async.auto({\n     *     get_data: function(callback) {\n     *         // async code to get some data\n     *         callback(null, 'data', 'converted to array');\n     *     },\n     *     make_folder: function(callback) {\n     *         // async code to create a directory to store a file in\n     *         // this is run at the same time as getting the data\n     *         callback(null, 'folder');\n     *     },\n     *     write_file: ['get_data', 'make_folder', function(results, callback) {\n     *         // once there is some data and the directory exists,\n     *         // write the data to a file in the directory\n     *         callback(null, 'filename');\n     *     }],\n     *     email_link: ['write_file', function(results, callback) {\n     *         // once the file is written let's email a link to it...\n     *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n     *     }]\n     * }, function(err, results) {\n     *     if (err) {\n     *         console.log('err = ', err);\n     *     }\n     *     console.log('results = ', results);\n     *     // results = {\n     *     //     get_data: ['data', 'converted to array']\n     *     //     make_folder; 'folder',\n     *     //     write_file: 'filename'\n     *     //     email_link: { file: 'filename', email: 'user@example.com' }\n     *     // }\n     * });\n     *\n     * //Using Promises\n     * async.auto({\n     *     get_data: function(callback) {\n     *         console.log('in get_data');\n     *         // async code to get some data\n     *         callback(null, 'data', 'converted to array');\n     *     },\n     *     make_folder: function(callback) {\n     *         console.log('in make_folder');\n     *         // async code to create a directory to store a file in\n     *         // this is run at the same time as getting the data\n     *         callback(null, 'folder');\n     *     },\n     *     write_file: ['get_data', 'make_folder', function(results, callback) {\n     *         // once there is some data and the directory exists,\n     *         // write the data to a file in the directory\n     *         callback(null, 'filename');\n     *     }],\n     *     email_link: ['write_file', function(results, callback) {\n     *         // once the file is written let's email a link to it...\n     *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n     *     }]\n     * }).then(results => {\n     *     console.log('results = ', results);\n     *     // results = {\n     *     //     get_data: ['data', 'converted to array']\n     *     //     make_folder; 'folder',\n     *     //     write_file: 'filename'\n     *     //     email_link: { file: 'filename', email: 'user@example.com' }\n     *     // }\n     * }).catch(err => {\n     *     console.log('err = ', err);\n     * });\n     *\n     * //Using async/await\n     * async () => {\n     *     try {\n     *         let results = await async.auto({\n     *             get_data: function(callback) {\n     *                 // async code to get some data\n     *                 callback(null, 'data', 'converted to array');\n     *             },\n     *             make_folder: function(callback) {\n     *                 // async code to create a directory to store a file in\n     *                 // this is run at the same time as getting the data\n     *                 callback(null, 'folder');\n     *             },\n     *             write_file: ['get_data', 'make_folder', function(results, callback) {\n     *                 // once there is some data and the directory exists,\n     *                 // write the data to a file in the directory\n     *                 callback(null, 'filename');\n     *             }],\n     *             email_link: ['write_file', function(results, callback) {\n     *                 // once the file is written let's email a link to it...\n     *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});\n     *             }]\n     *         });\n     *         console.log('results = ', results);\n     *         // results = {\n     *         //     get_data: ['data', 'converted to array']\n     *         //     make_folder; 'folder',\n     *         //     write_file: 'filename'\n     *         //     email_link: { file: 'filename', email: 'user@example.com' }\n     *         // }\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function auto(tasks, concurrency, callback) {\n        if (typeof concurrency !== 'number') {\n            // concurrency is optional, shift the args.\n            callback = concurrency;\n            concurrency = null;\n        }\n        callback = once(callback || promiseCallback());\n        var numTasks = Object.keys(tasks).length;\n        if (!numTasks) {\n            return callback(null);\n        }\n        if (!concurrency) {\n            concurrency = numTasks;\n        }\n\n        var results = {};\n        var runningTasks = 0;\n        var canceled = false;\n        var hasError = false;\n\n        var listeners = Object.create(null);\n\n        var readyTasks = [];\n\n        // for cycle detection:\n        var readyToCheck = []; // tasks that have been identified as reachable\n        // without the possibility of returning to an ancestor task\n        var uncheckedDependencies = {};\n\n        Object.keys(tasks).forEach(key => {\n            var task = tasks[key];\n            if (!Array.isArray(task)) {\n                // no dependencies\n                enqueueTask(key, [task]);\n                readyToCheck.push(key);\n                return;\n            }\n\n            var dependencies = task.slice(0, task.length - 1);\n            var remainingDependencies = dependencies.length;\n            if (remainingDependencies === 0) {\n                enqueueTask(key, task);\n                readyToCheck.push(key);\n                return;\n            }\n            uncheckedDependencies[key] = remainingDependencies;\n\n            dependencies.forEach(dependencyName => {\n                if (!tasks[dependencyName]) {\n                    throw new Error('async.auto task `' + key +\n                        '` has a non-existent dependency `' +\n                        dependencyName + '` in ' +\n                        dependencies.join(', '));\n                }\n                addListener(dependencyName, () => {\n                    remainingDependencies--;\n                    if (remainingDependencies === 0) {\n                        enqueueTask(key, task);\n                    }\n                });\n            });\n        });\n\n        checkForDeadlocks();\n        processQueue();\n\n        function enqueueTask(key, task) {\n            readyTasks.push(() => runTask(key, task));\n        }\n\n        function processQueue() {\n            if (canceled) return\n            if (readyTasks.length === 0 && runningTasks === 0) {\n                return callback(null, results);\n            }\n            while(readyTasks.length && runningTasks < concurrency) {\n                var run = readyTasks.shift();\n                run();\n            }\n\n        }\n\n        function addListener(taskName, fn) {\n            var taskListeners = listeners[taskName];\n            if (!taskListeners) {\n                taskListeners = listeners[taskName] = [];\n            }\n\n            taskListeners.push(fn);\n        }\n\n        function taskComplete(taskName) {\n            var taskListeners = listeners[taskName] || [];\n            taskListeners.forEach(fn => fn());\n            processQueue();\n        }\n\n\n        function runTask(key, task) {\n            if (hasError) return;\n\n            var taskCallback = onlyOnce((err, ...result) => {\n                runningTasks--;\n                if (err === false) {\n                    canceled = true;\n                    return\n                }\n                if (result.length < 2) {\n                    [result] = result;\n                }\n                if (err) {\n                    var safeResults = {};\n                    Object.keys(results).forEach(rkey => {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[key] = result;\n                    hasError = true;\n                    listeners = Object.create(null);\n                    if (canceled) return\n                    callback(err, safeResults);\n                } else {\n                    results[key] = result;\n                    taskComplete(key);\n                }\n            });\n\n            runningTasks++;\n            var taskFn = wrapAsync(task[task.length - 1]);\n            if (task.length > 1) {\n                taskFn(results, taskCallback);\n            } else {\n                taskFn(taskCallback);\n            }\n        }\n\n        function checkForDeadlocks() {\n            // Kahn's algorithm\n            // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n            // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n            var currentTask;\n            var counter = 0;\n            while (readyToCheck.length) {\n                currentTask = readyToCheck.pop();\n                counter++;\n                getDependents(currentTask).forEach(dependent => {\n                    if (--uncheckedDependencies[dependent] === 0) {\n                        readyToCheck.push(dependent);\n                    }\n                });\n            }\n\n            if (counter !== numTasks) {\n                throw new Error(\n                    'async.auto cannot execute tasks due to a recursive dependency'\n                );\n            }\n        }\n\n        function getDependents(taskName) {\n            var result = [];\n            Object.keys(tasks).forEach(key => {\n                const task = tasks[key];\n                if (Array.isArray(task) && task.indexOf(taskName) >= 0) {\n                    result.push(key);\n                }\n            });\n            return result;\n        }\n\n        return callback[PROMISE_SYMBOL]\n    }\n\n    var FN_ARGS = /^(?:async\\s+)?(?:function)?\\s*\\w*\\s*\\(\\s*([^)]+)\\s*\\)(?:\\s*{)/;\n    var ARROW_FN_ARGS = /^(?:async\\s+)?\\(?\\s*([^)=]+)\\s*\\)?(?:\\s*=>)/;\n    var FN_ARG_SPLIT = /,/;\n    var FN_ARG = /(=.+)?(\\s*)$/;\n\n    function stripComments(string) {\n        let stripped = '';\n        let index = 0;\n        let endBlockComment = string.indexOf('*/');\n        while (index < string.length) {\n            if (string[index] === '/' && string[index+1] === '/') {\n                // inline comment\n                let endIndex = string.indexOf('\\n', index);\n                index = (endIndex === -1) ? string.length : endIndex;\n            } else if ((endBlockComment !== -1) && (string[index] === '/') && (string[index+1] === '*')) {\n                // block comment\n                let endIndex = string.indexOf('*/', index);\n                if (endIndex !== -1) {\n                    index = endIndex + 2;\n                    endBlockComment = string.indexOf('*/', index);\n                } else {\n                    stripped += string[index];\n                    index++;\n                }\n            } else {\n                stripped += string[index];\n                index++;\n            }\n        }\n        return stripped;\n    }\n\n    function parseParams(func) {\n        const src = stripComments(func.toString());\n        let match = src.match(FN_ARGS);\n        if (!match) {\n            match = src.match(ARROW_FN_ARGS);\n        }\n        if (!match) throw new Error('could not parse args in autoInject\\nSource:\\n' + src)\n        let [, args] = match;\n        return args\n            .replace(/\\s/g, '')\n            .split(FN_ARG_SPLIT)\n            .map((arg) => arg.replace(FN_ARG, '').trim());\n    }\n\n    /**\n     * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n     * tasks are specified as parameters to the function, after the usual callback\n     * parameter, with the parameter names matching the names of the tasks it\n     * depends on. This can provide even more readable task graphs which can be\n     * easier to maintain.\n     *\n     * If a final callback is specified, the task results are similarly injected,\n     * specified as named parameters after the initial error parameter.\n     *\n     * The autoInject function is purely syntactic sugar and its semantics are\n     * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n     *\n     * @name autoInject\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.auto]{@link module:ControlFlow.auto}\n     * @category Control Flow\n     * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n     * the form 'func([dependencies...], callback). The object's key of a property\n     * serves as the name of the task defined by that property, i.e. can be used\n     * when specifying requirements for other tasks.\n     * * The `callback` parameter is a `callback(err, result)` which must be called\n     *   when finished, passing an `error` (which can be `null`) and the result of\n     *   the function's execution. The remaining parameters name other tasks on\n     *   which the task is dependent, and the results from those tasks are the\n     *   arguments of those parameters.\n     * @param {Function} [callback] - An optional callback which is called when all\n     * the tasks have been completed. It receives the `err` argument if any `tasks`\n     * pass an error to their callback, and a `results` object with any completed\n     * task results, similar to `auto`.\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * //  The example from `auto` can be rewritten as follows:\n     * async.autoInject({\n     *     get_data: function(callback) {\n     *         // async code to get some data\n     *         callback(null, 'data', 'converted to array');\n     *     },\n     *     make_folder: function(callback) {\n     *         // async code to create a directory to store a file in\n     *         // this is run at the same time as getting the data\n     *         callback(null, 'folder');\n     *     },\n     *     write_file: function(get_data, make_folder, callback) {\n     *         // once there is some data and the directory exists,\n     *         // write the data to a file in the directory\n     *         callback(null, 'filename');\n     *     },\n     *     email_link: function(write_file, callback) {\n     *         // once the file is written let's email a link to it...\n     *         // write_file contains the filename returned by write_file.\n     *         callback(null, {'file':write_file, 'email':'user@example.com'});\n     *     }\n     * }, function(err, results) {\n     *     console.log('err = ', err);\n     *     console.log('email_link = ', results.email_link);\n     * });\n     *\n     * // If you are using a JS minifier that mangles parameter names, `autoInject`\n     * // will not work with plain functions, since the parameter names will be\n     * // collapsed to a single letter identifier.  To work around this, you can\n     * // explicitly specify the names of the parameters your task function needs\n     * // in an array, similar to Angular.js dependency injection.\n     *\n     * // This still has an advantage over plain `auto`, since the results a task\n     * // depends on are still spread into arguments.\n     * async.autoInject({\n     *     //...\n     *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n     *         callback(null, 'filename');\n     *     }],\n     *     email_link: ['write_file', function(write_file, callback) {\n     *         callback(null, {'file':write_file, 'email':'user@example.com'});\n     *     }]\n     *     //...\n     * }, function(err, results) {\n     *     console.log('err = ', err);\n     *     console.log('email_link = ', results.email_link);\n     * });\n     */\n    function autoInject(tasks, callback) {\n        var newTasks = {};\n\n        Object.keys(tasks).forEach(key => {\n            var taskFn = tasks[key];\n            var params;\n            var fnIsAsync = isAsync(taskFn);\n            var hasNoDeps =\n                (!fnIsAsync && taskFn.length === 1) ||\n                (fnIsAsync && taskFn.length === 0);\n\n            if (Array.isArray(taskFn)) {\n                params = [...taskFn];\n                taskFn = params.pop();\n\n                newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n            } else if (hasNoDeps) {\n                // no dependencies, use the function as-is\n                newTasks[key] = taskFn;\n            } else {\n                params = parseParams(taskFn);\n                if ((taskFn.length === 0 && !fnIsAsync) && params.length === 0) {\n                    throw new Error(\"autoInject task functions require explicit parameters.\");\n                }\n\n                // remove callback param\n                if (!fnIsAsync) params.pop();\n\n                newTasks[key] = params.concat(newTask);\n            }\n\n            function newTask(results, taskCb) {\n                var newArgs = params.map(name => results[name]);\n                newArgs.push(taskCb);\n                wrapAsync(taskFn)(...newArgs);\n            }\n        });\n\n        return auto(newTasks, callback);\n    }\n\n    // Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n    // used for queues. This implementation assumes that the node provided by the user can be modified\n    // to adjust the next and last properties. We implement only the minimal functionality\n    // for queue support.\n    class DLL {\n        constructor() {\n            this.head = this.tail = null;\n            this.length = 0;\n        }\n\n        removeLink(node) {\n            if (node.prev) node.prev.next = node.next;\n            else this.head = node.next;\n            if (node.next) node.next.prev = node.prev;\n            else this.tail = node.prev;\n\n            node.prev = node.next = null;\n            this.length -= 1;\n            return node;\n        }\n\n        empty () {\n            while(this.head) this.shift();\n            return this;\n        }\n\n        insertAfter(node, newNode) {\n            newNode.prev = node;\n            newNode.next = node.next;\n            if (node.next) node.next.prev = newNode;\n            else this.tail = newNode;\n            node.next = newNode;\n            this.length += 1;\n        }\n\n        insertBefore(node, newNode) {\n            newNode.prev = node.prev;\n            newNode.next = node;\n            if (node.prev) node.prev.next = newNode;\n            else this.head = newNode;\n            node.prev = newNode;\n            this.length += 1;\n        }\n\n        unshift(node) {\n            if (this.head) this.insertBefore(this.head, node);\n            else setInitial(this, node);\n        }\n\n        push(node) {\n            if (this.tail) this.insertAfter(this.tail, node);\n            else setInitial(this, node);\n        }\n\n        shift() {\n            return this.head && this.removeLink(this.head);\n        }\n\n        pop() {\n            return this.tail && this.removeLink(this.tail);\n        }\n\n        toArray() {\n            return [...this]\n        }\n\n        *[Symbol.iterator] () {\n            var cur = this.head;\n            while (cur) {\n                yield cur.data;\n                cur = cur.next;\n            }\n        }\n\n        remove (testFn) {\n            var curr = this.head;\n            while(curr) {\n                var {next} = curr;\n                if (testFn(curr)) {\n                    this.removeLink(curr);\n                }\n                curr = next;\n            }\n            return this;\n        }\n    }\n\n    function setInitial(dll, node) {\n        dll.length = 1;\n        dll.head = dll.tail = node;\n    }\n\n    function queue(worker, concurrency, payload) {\n        if (concurrency == null) {\n            concurrency = 1;\n        }\n        else if(concurrency === 0) {\n            throw new RangeError('Concurrency must not be zero');\n        }\n\n        var _worker = wrapAsync(worker);\n        var numRunning = 0;\n        var workersList = [];\n        const events = {\n            error: [],\n            drain: [],\n            saturated: [],\n            unsaturated: [],\n            empty: []\n        };\n\n        function on (event, handler) {\n            events[event].push(handler);\n        }\n\n        function once (event, handler) {\n            const handleAndRemove = (...args) => {\n                off(event, handleAndRemove);\n                handler(...args);\n            };\n            events[event].push(handleAndRemove);\n        }\n\n        function off (event, handler) {\n            if (!event) return Object.keys(events).forEach(ev => events[ev] = [])\n            if (!handler) return events[event] = []\n            events[event] = events[event].filter(ev => ev !== handler);\n        }\n\n        function trigger (event, ...args) {\n            events[event].forEach(handler => handler(...args));\n        }\n\n        var processingScheduled = false;\n        function _insert(data, insertAtFront, rejectOnError, callback) {\n            if (callback != null && typeof callback !== 'function') {\n                throw new Error('task callback must be a function');\n            }\n            q.started = true;\n\n            var res, rej;\n            function promiseCallback (err, ...args) {\n                // we don't care about the error, let the global error handler\n                // deal with it\n                if (err) return rejectOnError ? rej(err) : res()\n                if (args.length <= 1) return res(args[0])\n                res(args);\n            }\n\n            var item = q._createTaskItem(\n                data,\n                rejectOnError ? promiseCallback :\n                    (callback || promiseCallback)\n            );\n\n            if (insertAtFront) {\n                q._tasks.unshift(item);\n            } else {\n                q._tasks.push(item);\n            }\n\n            if (!processingScheduled) {\n                processingScheduled = true;\n                setImmediate$1(() => {\n                    processingScheduled = false;\n                    q.process();\n                });\n            }\n\n            if (rejectOnError || !callback) {\n                return new Promise((resolve, reject) => {\n                    res = resolve;\n                    rej = reject;\n                })\n            }\n        }\n\n        function _createCB(tasks) {\n            return function (err, ...args) {\n                numRunning -= 1;\n\n                for (var i = 0, l = tasks.length; i < l; i++) {\n                    var task = tasks[i];\n\n                    var index = workersList.indexOf(task);\n                    if (index === 0) {\n                        workersList.shift();\n                    } else if (index > 0) {\n                        workersList.splice(index, 1);\n                    }\n\n                    task.callback(err, ...args);\n\n                    if (err != null) {\n                        trigger('error', err, task.data);\n                    }\n                }\n\n                if (numRunning <= (q.concurrency - q.buffer) ) {\n                    trigger('unsaturated');\n                }\n\n                if (q.idle()) {\n                    trigger('drain');\n                }\n                q.process();\n            };\n        }\n\n        function _maybeDrain(data) {\n            if (data.length === 0 && q.idle()) {\n                // call drain immediately if there are no tasks\n                setImmediate$1(() => trigger('drain'));\n                return true\n            }\n            return false\n        }\n\n        const eventMethod = (name) => (handler) => {\n            if (!handler) {\n                return new Promise((resolve, reject) => {\n                    once(name, (err, data) => {\n                        if (err) return reject(err)\n                        resolve(data);\n                    });\n                })\n            }\n            off(name);\n            on(name, handler);\n\n        };\n\n        var isProcessing = false;\n        var q = {\n            _tasks: new DLL(),\n            _createTaskItem (data, callback) {\n                return {\n                    data,\n                    callback\n                };\n            },\n            *[Symbol.iterator] () {\n                yield* q._tasks[Symbol.iterator]();\n            },\n            concurrency,\n            payload,\n            buffer: concurrency / 4,\n            started: false,\n            paused: false,\n            push (data, callback) {\n                if (Array.isArray(data)) {\n                    if (_maybeDrain(data)) return\n                    return data.map(datum => _insert(datum, false, false, callback))\n                }\n                return _insert(data, false, false, callback);\n            },\n            pushAsync (data, callback) {\n                if (Array.isArray(data)) {\n                    if (_maybeDrain(data)) return\n                    return data.map(datum => _insert(datum, false, true, callback))\n                }\n                return _insert(data, false, true, callback);\n            },\n            kill () {\n                off();\n                q._tasks.empty();\n            },\n            unshift (data, callback) {\n                if (Array.isArray(data)) {\n                    if (_maybeDrain(data)) return\n                    return data.map(datum => _insert(datum, true, false, callback))\n                }\n                return _insert(data, true, false, callback);\n            },\n            unshiftAsync (data, callback) {\n                if (Array.isArray(data)) {\n                    if (_maybeDrain(data)) return\n                    return data.map(datum => _insert(datum, true, true, callback))\n                }\n                return _insert(data, true, true, callback);\n            },\n            remove (testFn) {\n                q._tasks.remove(testFn);\n            },\n            process () {\n                // Avoid trying to start too many processing operations. This can occur\n                // when callbacks resolve synchronously (#1267).\n                if (isProcessing) {\n                    return;\n                }\n                isProcessing = true;\n                while(!q.paused && numRunning < q.concurrency && q._tasks.length){\n                    var tasks = [], data = [];\n                    var l = q._tasks.length;\n                    if (q.payload) l = Math.min(l, q.payload);\n                    for (var i = 0; i < l; i++) {\n                        var node = q._tasks.shift();\n                        tasks.push(node);\n                        workersList.push(node);\n                        data.push(node.data);\n                    }\n\n                    numRunning += 1;\n\n                    if (q._tasks.length === 0) {\n                        trigger('empty');\n                    }\n\n                    if (numRunning === q.concurrency) {\n                        trigger('saturated');\n                    }\n\n                    var cb = onlyOnce(_createCB(tasks));\n                    _worker(data, cb);\n                }\n                isProcessing = false;\n            },\n            length () {\n                return q._tasks.length;\n            },\n            running () {\n                return numRunning;\n            },\n            workersList () {\n                return workersList;\n            },\n            idle() {\n                return q._tasks.length + numRunning === 0;\n            },\n            pause () {\n                q.paused = true;\n            },\n            resume () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                setImmediate$1(q.process);\n            }\n        };\n        // define these as fixed properties, so people get useful errors when updating\n        Object.defineProperties(q, {\n            saturated: {\n                writable: false,\n                value: eventMethod('saturated')\n            },\n            unsaturated: {\n                writable: false,\n                value: eventMethod('unsaturated')\n            },\n            empty: {\n                writable: false,\n                value: eventMethod('empty')\n            },\n            drain: {\n                writable: false,\n                value: eventMethod('drain')\n            },\n            error: {\n                writable: false,\n                value: eventMethod('error')\n            },\n        });\n        return q;\n    }\n\n    /**\n     * Creates a `cargo` object with the specified payload. Tasks added to the\n     * cargo will be processed altogether (up to the `payload` limit). If the\n     * `worker` is in progress, the task is queued until it becomes available. Once\n     * the `worker` has completed some tasks, each callback of those tasks is\n     * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n     * for how `cargo` and `queue` work.\n     *\n     * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n     * at a time, cargo passes an array of tasks to a single worker, repeating\n     * when the worker is finished.\n     *\n     * @name cargo\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.queue]{@link module:ControlFlow.queue}\n     * @category Control Flow\n     * @param {AsyncFunction} worker - An asynchronous function for processing an array\n     * of queued tasks. Invoked with `(tasks, callback)`.\n     * @param {number} [payload=Infinity] - An optional `integer` for determining\n     * how many tasks should be processed per round; if omitted, the default is\n     * unlimited.\n     * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can\n     * attached as certain properties to listen for specific events during the\n     * lifecycle of the cargo and inner queue.\n     * @example\n     *\n     * // create a cargo object with payload 2\n     * var cargo = async.cargo(function(tasks, callback) {\n     *     for (var i=0; i<tasks.length; i++) {\n     *         console.log('hello ' + tasks[i].name);\n     *     }\n     *     callback();\n     * }, 2);\n     *\n     * // add some items\n     * cargo.push({name: 'foo'}, function(err) {\n     *     console.log('finished processing foo');\n     * });\n     * cargo.push({name: 'bar'}, function(err) {\n     *     console.log('finished processing bar');\n     * });\n     * await cargo.push({name: 'baz'});\n     * console.log('finished processing baz');\n     */\n    function cargo(worker, payload) {\n        return queue(worker, 1, payload);\n    }\n\n    /**\n     * Creates a `cargoQueue` object with the specified payload. Tasks added to the\n     * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.\n     * If the all `workers` are in progress, the task is queued until one becomes available. Once\n     * a `worker` has completed some tasks, each callback of those tasks is\n     * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n     * for how `cargo` and `queue` work.\n     *\n     * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n     * at a time, and [`cargo`]{@link module:ControlFlow.cargo} passes an array of tasks to a single worker,\n     * the cargoQueue passes an array of tasks to multiple parallel workers.\n     *\n     * @name cargoQueue\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.queue]{@link module:ControlFlow.queue}\n     * @see [async.cargo]{@link module:ControlFLow.cargo}\n     * @category Control Flow\n     * @param {AsyncFunction} worker - An asynchronous function for processing an array\n     * of queued tasks. Invoked with `(tasks, callback)`.\n     * @param {number} [concurrency=1] - An `integer` for determining how many\n     * `worker` functions should be run in parallel.  If omitted, the concurrency\n     * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n     * @param {number} [payload=Infinity] - An optional `integer` for determining\n     * how many tasks should be processed per round; if omitted, the default is\n     * unlimited.\n     * @returns {module:ControlFlow.QueueObject} A cargoQueue object to manage the tasks. Callbacks can\n     * attached as certain properties to listen for specific events during the\n     * lifecycle of the cargoQueue and inner queue.\n     * @example\n     *\n     * // create a cargoQueue object with payload 2 and concurrency 2\n     * var cargoQueue = async.cargoQueue(function(tasks, callback) {\n     *     for (var i=0; i<tasks.length; i++) {\n     *         console.log('hello ' + tasks[i].name);\n     *     }\n     *     callback();\n     * }, 2, 2);\n     *\n     * // add some items\n     * cargoQueue.push({name: 'foo'}, function(err) {\n     *     console.log('finished processing foo');\n     * });\n     * cargoQueue.push({name: 'bar'}, function(err) {\n     *     console.log('finished processing bar');\n     * });\n     * cargoQueue.push({name: 'baz'}, function(err) {\n     *     console.log('finished processing baz');\n     * });\n     * cargoQueue.push({name: 'boo'}, function(err) {\n     *     console.log('finished processing boo');\n     * });\n     */\n    function cargo$1(worker, concurrency, payload) {\n        return queue(worker, concurrency, payload);\n    }\n\n    /**\n     * Reduces `coll` into a single value using an async `iteratee` to return each\n     * successive step. `memo` is the initial state of the reduction. This function\n     * only operates in series.\n     *\n     * For performance reasons, it may make sense to split a call to this function\n     * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n     * results. This function is for situations where each step in the reduction\n     * needs to be async; if you can get the data before reducing it, then it's\n     * probably a good idea to do so.\n     *\n     * @name reduce\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @alias inject\n     * @alias foldl\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {*} memo - The initial state of the reduction.\n     * @param {AsyncFunction} iteratee - A function applied to each item in the\n     * array to produce the next step in the reduction.\n     * The `iteratee` should complete with the next state of the reduction.\n     * If the iteratee completes with an error, the reduction is stopped and the\n     * main `callback` is immediately called with the error.\n     * Invoked with (memo, item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Result is the reduced value. Invoked with\n     * (err, result).\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * // file1.txt is a file that is 1000 bytes in size\n     * // file2.txt is a file that is 2000 bytes in size\n     * // file3.txt is a file that is 3000 bytes in size\n     * // file4.txt does not exist\n     *\n     * const fileList = ['file1.txt','file2.txt','file3.txt'];\n     * const withMissingFileList = ['file1.txt','file2.txt','file3.txt', 'file4.txt'];\n     *\n     * // asynchronous function that computes the file size in bytes\n     * // file size is added to the memoized value, then returned\n     * function getFileSizeInBytes(memo, file, callback) {\n     *     fs.stat(file, function(err, stat) {\n     *         if (err) {\n     *             return callback(err);\n     *         }\n     *         callback(null, memo + stat.size);\n     *     });\n     * }\n     *\n     * // Using callbacks\n     * async.reduce(fileList, 0, getFileSizeInBytes, function(err, result) {\n     *     if (err) {\n     *         console.log(err);\n     *     } else {\n     *         console.log(result);\n     *         // 6000\n     *         // which is the sum of the file sizes of the three files\n     *     }\n     * });\n     *\n     * // Error Handling\n     * async.reduce(withMissingFileList, 0, getFileSizeInBytes, function(err, result) {\n     *     if (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *     } else {\n     *         console.log(result);\n     *     }\n     * });\n     *\n     * // Using Promises\n     * async.reduce(fileList, 0, getFileSizeInBytes)\n     * .then( result => {\n     *     console.log(result);\n     *     // 6000\n     *     // which is the sum of the file sizes of the three files\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Error Handling\n     * async.reduce(withMissingFileList, 0, getFileSizeInBytes)\n     * .then( result => {\n     *     console.log(result);\n     * }).catch( err => {\n     *     console.log(err);\n     *     // [ Error: ENOENT: no such file or directory ]\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.reduce(fileList, 0, getFileSizeInBytes);\n     *         console.log(result);\n     *         // 6000\n     *         // which is the sum of the file sizes of the three files\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * // Error Handling\n     * async () => {\n     *     try {\n     *         let result = await async.reduce(withMissingFileList, 0, getFileSizeInBytes);\n     *         console.log(result);\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *     }\n     * }\n     *\n     */\n    function reduce(coll, memo, iteratee, callback) {\n        callback = once(callback);\n        var _iteratee = wrapAsync(iteratee);\n        return eachOfSeries$1(coll, (x, i, iterCb) => {\n            _iteratee(memo, x, (err, v) => {\n                memo = v;\n                iterCb(err);\n            });\n        }, err => callback(err, memo));\n    }\n    var reduce$1 = awaitify(reduce, 4);\n\n    /**\n     * Version of the compose function that is more natural to read. Each function\n     * consumes the return value of the previous function. It is the equivalent of\n     * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n     *\n     * Each function is executed with the `this` binding of the composed function.\n     *\n     * @name seq\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.compose]{@link module:ControlFlow.compose}\n     * @category Control Flow\n     * @param {...AsyncFunction} functions - the asynchronous functions to compose\n     * @returns {Function} a function that composes the `functions` in order\n     * @example\n     *\n     * // Requires lodash (or underscore), express3 and dresende's orm2.\n     * // Part of an app, that fetches cats of the logged user.\n     * // This example uses `seq` function to avoid overnesting and error\n     * // handling clutter.\n     * app.get('/cats', function(request, response) {\n     *     var User = request.models.User;\n     *     async.seq(\n     *         User.get.bind(User),  // 'User.get' has signature (id, callback(err, data))\n     *         function(user, fn) {\n     *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n     *         }\n     *     )(req.session.user_id, function (err, cats) {\n     *         if (err) {\n     *             console.error(err);\n     *             response.json({ status: 'error', message: err.message });\n     *         } else {\n     *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n     *         }\n     *     });\n     * });\n     */\n    function seq(...functions) {\n        var _functions = functions.map(wrapAsync);\n        return function (...args) {\n            var that = this;\n\n            var cb = args[args.length - 1];\n            if (typeof cb == 'function') {\n                args.pop();\n            } else {\n                cb = promiseCallback();\n            }\n\n            reduce$1(_functions, args, (newargs, fn, iterCb) => {\n                fn.apply(that, newargs.concat((err, ...nextargs) => {\n                    iterCb(err, nextargs);\n                }));\n            },\n            (err, results) => cb(err, ...results));\n\n            return cb[PROMISE_SYMBOL]\n        };\n    }\n\n    /**\n     * Creates a function which is a composition of the passed asynchronous\n     * functions. Each function consumes the return value of the function that\n     * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n     * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n     *\n     * If the last argument to the composed function is not a function, a promise\n     * is returned when you call it.\n     *\n     * Each function is executed with the `this` binding of the composed function.\n     *\n     * @name compose\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {...AsyncFunction} functions - the asynchronous functions to compose\n     * @returns {Function} an asynchronous function that is the composed\n     * asynchronous `functions`\n     * @example\n     *\n     * function add1(n, callback) {\n     *     setTimeout(function () {\n     *         callback(null, n + 1);\n     *     }, 10);\n     * }\n     *\n     * function mul3(n, callback) {\n     *     setTimeout(function () {\n     *         callback(null, n * 3);\n     *     }, 10);\n     * }\n     *\n     * var add1mul3 = async.compose(mul3, add1);\n     * add1mul3(4, function (err, result) {\n     *     // result now equals 15\n     * });\n     */\n    function compose(...args) {\n        return seq(...args.reverse());\n    }\n\n    /**\n     * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n     *\n     * @name mapLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.map]{@link module:Collections.map}\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The iteratee should complete with the transformed item.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. Results is an array of the\n     * transformed items from the `coll`. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function mapLimit (coll, limit, iteratee, callback) {\n        return _asyncMap(eachOfLimit(limit), coll, iteratee, callback)\n    }\n    var mapLimit$1 = awaitify(mapLimit, 4);\n\n    /**\n     * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.\n     *\n     * @name concatLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.concat]{@link module:Collections.concat}\n     * @category Collection\n     * @alias flatMapLimit\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n     * which should use an array as its result. Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished, or an error occurs. Results is an array\n     * containing the concatenated results of the `iteratee` function. Invoked with\n     * (err, results).\n     * @returns A Promise, if no callback is passed\n     */\n    function concatLimit(coll, limit, iteratee, callback) {\n        var _iteratee = wrapAsync(iteratee);\n        return mapLimit$1(coll, limit, (val, iterCb) => {\n            _iteratee(val, (err, ...args) => {\n                if (err) return iterCb(err);\n                return iterCb(err, args);\n            });\n        }, (err, mapResults) => {\n            var result = [];\n            for (var i = 0; i < mapResults.length; i++) {\n                if (mapResults[i]) {\n                    result = result.concat(...mapResults[i]);\n                }\n            }\n\n            return callback(err, result);\n        });\n    }\n    var concatLimit$1 = awaitify(concatLimit, 4);\n\n    /**\n     * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n     * the concatenated list. The `iteratee`s are called in parallel, and the\n     * results are concatenated as they return. The results array will be returned in\n     * the original order of `coll` passed to the `iteratee` function.\n     *\n     * @name concat\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @category Collection\n     * @alias flatMap\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n     * which should use an array as its result. Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished, or an error occurs. Results is an array\n     * containing the concatenated results of the `iteratee` function. Invoked with\n     * (err, results).\n     * @returns A Promise, if no callback is passed\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     * // dir4 does not exist\n     *\n     * let directoryList = ['dir1','dir2','dir3'];\n     * let withMissingDirectoryList = ['dir1','dir2','dir3', 'dir4'];\n     *\n     * // Using callbacks\n     * async.concat(directoryList, fs.readdir, function(err, results) {\n     *    if (err) {\n     *        console.log(err);\n     *    } else {\n     *        console.log(results);\n     *        // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n     *    }\n     * });\n     *\n     * // Error Handling\n     * async.concat(withMissingDirectoryList, fs.readdir, function(err, results) {\n     *    if (err) {\n     *        console.log(err);\n     *        // [ Error: ENOENT: no such file or directory ]\n     *        // since dir4 does not exist\n     *    } else {\n     *        console.log(results);\n     *    }\n     * });\n     *\n     * // Using Promises\n     * async.concat(directoryList, fs.readdir)\n     * .then(results => {\n     *     console.log(results);\n     *     // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n     * }).catch(err => {\n     *      console.log(err);\n     * });\n     *\n     * // Error Handling\n     * async.concat(withMissingDirectoryList, fs.readdir)\n     * .then(results => {\n     *     console.log(results);\n     * }).catch(err => {\n     *     console.log(err);\n     *     // [ Error: ENOENT: no such file or directory ]\n     *     // since dir4 does not exist\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let results = await async.concat(directoryList, fs.readdir);\n     *         console.log(results);\n     *         // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n     *     } catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * // Error Handling\n     * async () => {\n     *     try {\n     *         let results = await async.concat(withMissingDirectoryList, fs.readdir);\n     *         console.log(results);\n     *     } catch (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *         // since dir4 does not exist\n     *     }\n     * }\n     *\n     */\n    function concat(coll, iteratee, callback) {\n        return concatLimit$1(coll, Infinity, iteratee, callback)\n    }\n    var concat$1 = awaitify(concat, 3);\n\n    /**\n     * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n     *\n     * @name concatSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.concat]{@link module:Collections.concat}\n     * @category Collection\n     * @alias flatMapSeries\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n     * The iteratee should complete with an array an array of results.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished, or an error occurs. Results is an array\n     * containing the concatenated results of the `iteratee` function. Invoked with\n     * (err, results).\n     * @returns A Promise, if no callback is passed\n     */\n    function concatSeries(coll, iteratee, callback) {\n        return concatLimit$1(coll, 1, iteratee, callback)\n    }\n    var concatSeries$1 = awaitify(concatSeries, 3);\n\n    /**\n     * Returns a function that when called, calls-back with the values provided.\n     * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n     * [`auto`]{@link module:ControlFlow.auto}.\n     *\n     * @name constant\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {...*} arguments... - Any number of arguments to automatically invoke\n     * callback with.\n     * @returns {AsyncFunction} Returns a function that when invoked, automatically\n     * invokes the callback with the previous given arguments.\n     * @example\n     *\n     * async.waterfall([\n     *     async.constant(42),\n     *     function (value, next) {\n     *         // value === 42\n     *     },\n     *     //...\n     * ], callback);\n     *\n     * async.waterfall([\n     *     async.constant(filename, \"utf8\"),\n     *     fs.readFile,\n     *     function (fileData, next) {\n     *         //...\n     *     }\n     *     //...\n     * ], callback);\n     *\n     * async.auto({\n     *     hostname: async.constant(\"https://server.net/\"),\n     *     port: findFreePort,\n     *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n     *         startServer(options, cb);\n     *     }],\n     *     //...\n     * }, callback);\n     */\n    function constant(...args) {\n        return function (...ignoredArgs/*, callback*/) {\n            var callback = ignoredArgs.pop();\n            return callback(null, ...args);\n        };\n    }\n\n    function _createTester(check, getResult) {\n        return (eachfn, arr, _iteratee, cb) => {\n            var testPassed = false;\n            var testResult;\n            const iteratee = wrapAsync(_iteratee);\n            eachfn(arr, (value, _, callback) => {\n                iteratee(value, (err, result) => {\n                    if (err || err === false) return callback(err);\n\n                    if (check(result) && !testResult) {\n                        testPassed = true;\n                        testResult = getResult(true, value);\n                        return callback(null, breakLoop);\n                    }\n                    callback();\n                });\n            }, err => {\n                if (err) return cb(err);\n                cb(null, testPassed ? testResult : getResult(false));\n            });\n        };\n    }\n\n    /**\n     * Returns the first value in `coll` that passes an async truth test. The\n     * `iteratee` is applied in parallel, meaning the first iteratee to return\n     * `true` will fire the detect `callback` with that result. That means the\n     * result might not be the first item in the original `coll` (in terms of order)\n     * that passes the test.\n\n     * If order within the original `coll` is important, then look at\n     * [`detectSeries`]{@link module:Collections.detectSeries}.\n     *\n     * @name detect\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @alias find\n     * @category Collections\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n     * The iteratee must complete with a boolean value as its result.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called as soon as any\n     * iteratee returns `true`, or after all the `iteratee` functions have finished.\n     * Result will be the first item in the array that passes the truth test\n     * (iteratee) or the value `undefined` if none passed. Invoked with\n     * (err, result).\n     * @returns {Promise} a promise, if a callback is omitted\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     *\n     * // asynchronous function that checks if a file exists\n     * function fileExists(file, callback) {\n     *    fs.access(file, fs.constants.F_OK, (err) => {\n     *        callback(null, !err);\n     *    });\n     * }\n     *\n     * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists,\n     *    function(err, result) {\n     *        console.log(result);\n     *        // dir1/file1.txt\n     *        // result now equals the first file in the list that exists\n     *    }\n     *);\n     *\n     * // Using Promises\n     * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists)\n     * .then(result => {\n     *     console.log(result);\n     *     // dir1/file1.txt\n     *     // result now equals the first file in the list that exists\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists);\n     *         console.log(result);\n     *         // dir1/file1.txt\n     *         // result now equals the file in the list that exists\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function detect(coll, iteratee, callback) {\n        return _createTester(bool => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback)\n    }\n    var detect$1 = awaitify(detect, 3);\n\n    /**\n     * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n     * time.\n     *\n     * @name detectLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.detect]{@link module:Collections.detect}\n     * @alias findLimit\n     * @category Collections\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n     * The iteratee must complete with a boolean value as its result.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called as soon as any\n     * iteratee returns `true`, or after all the `iteratee` functions have finished.\n     * Result will be the first item in the array that passes the truth test\n     * (iteratee) or the value `undefined` if none passed. Invoked with\n     * (err, result).\n     * @returns {Promise} a promise, if a callback is omitted\n     */\n    function detectLimit(coll, limit, iteratee, callback) {\n        return _createTester(bool => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback)\n    }\n    var detectLimit$1 = awaitify(detectLimit, 4);\n\n    /**\n     * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n     *\n     * @name detectSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.detect]{@link module:Collections.detect}\n     * @alias findSeries\n     * @category Collections\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n     * The iteratee must complete with a boolean value as its result.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called as soon as any\n     * iteratee returns `true`, or after all the `iteratee` functions have finished.\n     * Result will be the first item in the array that passes the truth test\n     * (iteratee) or the value `undefined` if none passed. Invoked with\n     * (err, result).\n     * @returns {Promise} a promise, if a callback is omitted\n     */\n    function detectSeries(coll, iteratee, callback) {\n        return _createTester(bool => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback)\n    }\n\n    var detectSeries$1 = awaitify(detectSeries, 3);\n\n    function consoleFunc(name) {\n        return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {\n            /* istanbul ignore else */\n            if (typeof console === 'object') {\n                /* istanbul ignore else */\n                if (err) {\n                    /* istanbul ignore else */\n                    if (console.error) {\n                        console.error(err);\n                    }\n                } else if (console[name]) { /* istanbul ignore else */\n                    resultArgs.forEach(x => console[name](x));\n                }\n            }\n        })\n    }\n\n    /**\n     * Logs the result of an [`async` function]{@link AsyncFunction} to the\n     * `console` using `console.dir` to display the properties of the resulting object.\n     * Only works in Node.js or in browsers that support `console.dir` and\n     * `console.error` (such as FF and Chrome).\n     * If multiple arguments are returned from the async function,\n     * `console.dir` is called on each argument in order.\n     *\n     * @name dir\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {AsyncFunction} function - The function you want to eventually apply\n     * all arguments to.\n     * @param {...*} arguments... - Any number of arguments to apply to the function.\n     * @example\n     *\n     * // in a module\n     * var hello = function(name, callback) {\n     *     setTimeout(function() {\n     *         callback(null, {hello: name});\n     *     }, 1000);\n     * };\n     *\n     * // in the node repl\n     * node> async.dir(hello, 'world');\n     * {hello: 'world'}\n     */\n    var dir = consoleFunc('dir');\n\n    /**\n     * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n     * the order of operations, the arguments `test` and `iteratee` are switched.\n     *\n     * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n     *\n     * @name doWhilst\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.whilst]{@link module:ControlFlow.whilst}\n     * @category Control Flow\n     * @param {AsyncFunction} iteratee - A function which is called each time `test`\n     * passes. Invoked with (callback).\n     * @param {AsyncFunction} test - asynchronous truth test to perform after each\n     * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the\n     * non-error args from the previous callback of `iteratee`.\n     * @param {Function} [callback] - A callback which is called after the test\n     * function has failed and repeated execution of `iteratee` has stopped.\n     * `callback` will be passed an error and any arguments passed to the final\n     * `iteratee`'s callback. Invoked with (err, [results]);\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function doWhilst(iteratee, test, callback) {\n        callback = onlyOnce(callback);\n        var _fn = wrapAsync(iteratee);\n        var _test = wrapAsync(test);\n        var results;\n\n        function next(err, ...args) {\n            if (err) return callback(err);\n            if (err === false) return;\n            results = args;\n            _test(...args, check);\n        }\n\n        function check(err, truth) {\n            if (err) return callback(err);\n            if (err === false) return;\n            if (!truth) return callback(null, ...results);\n            _fn(next);\n        }\n\n        return check(null, true);\n    }\n\n    var doWhilst$1 = awaitify(doWhilst, 3);\n\n    /**\n     * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n     * argument ordering differs from `until`.\n     *\n     * @name doUntil\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n     * @category Control Flow\n     * @param {AsyncFunction} iteratee - An async function which is called each time\n     * `test` fails. Invoked with (callback).\n     * @param {AsyncFunction} test - asynchronous truth test to perform after each\n     * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the\n     * non-error args from the previous callback of `iteratee`\n     * @param {Function} [callback] - A callback which is called after the test\n     * function has passed and repeated execution of `iteratee` has stopped. `callback`\n     * will be passed an error and any arguments passed to the final `iteratee`'s\n     * callback. Invoked with (err, [results]);\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function doUntil(iteratee, test, callback) {\n        const _test = wrapAsync(test);\n        return doWhilst$1(iteratee, (...args) => {\n            const cb = args.pop();\n            _test(...args, (err, truth) => cb (err, !truth));\n        }, callback);\n    }\n\n    function _withoutIndex(iteratee) {\n        return (value, index, callback) => iteratee(value, callback);\n    }\n\n    /**\n     * Applies the function `iteratee` to each item in `coll`, in parallel.\n     * The `iteratee` is called with an item from the list, and a callback for when\n     * it has finished. If the `iteratee` passes an error to its `callback`, the\n     * main `callback` (for the `each` function) is immediately called with the\n     * error.\n     *\n     * Note, that since this function applies `iteratee` to each item in parallel,\n     * there is no guarantee that the iteratee functions will complete in order.\n     *\n     * @name each\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @alias forEach\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to\n     * each item in `coll`. Invoked with (item, callback).\n     * The array index is not passed to the iteratee.\n     * If you need the index, use `eachOf`.\n     * @param {Function} [callback] - A callback which is called when all\n     * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n     * @returns {Promise} a promise, if a callback is omitted\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     * // dir4 does not exist\n     *\n     * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];\n     * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];\n     *\n     * // asynchronous function that deletes a file\n     * const deleteFile = function(file, callback) {\n     *     fs.unlink(file, callback);\n     * };\n     *\n     * // Using callbacks\n     * async.each(fileList, deleteFile, function(err) {\n     *     if( err ) {\n     *         console.log(err);\n     *     } else {\n     *         console.log('All files have been deleted successfully');\n     *     }\n     * });\n     *\n     * // Error Handling\n     * async.each(withMissingFileList, deleteFile, function(err){\n     *     console.log(err);\n     *     // [ Error: ENOENT: no such file or directory ]\n     *     // since dir4/file2.txt does not exist\n     *     // dir1/file1.txt could have been deleted\n     * });\n     *\n     * // Using Promises\n     * async.each(fileList, deleteFile)\n     * .then( () => {\n     *     console.log('All files have been deleted successfully');\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Error Handling\n     * async.each(fileList, deleteFile)\n     * .then( () => {\n     *     console.log('All files have been deleted successfully');\n     * }).catch( err => {\n     *     console.log(err);\n     *     // [ Error: ENOENT: no such file or directory ]\n     *     // since dir4/file2.txt does not exist\n     *     // dir1/file1.txt could have been deleted\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         await async.each(files, deleteFile);\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * // Error Handling\n     * async () => {\n     *     try {\n     *         await async.each(withMissingFileList, deleteFile);\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *         // since dir4/file2.txt does not exist\n     *         // dir1/file1.txt could have been deleted\n     *     }\n     * }\n     *\n     */\n    function eachLimit(coll, iteratee, callback) {\n        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n    }\n\n    var each = awaitify(eachLimit, 3);\n\n    /**\n     * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n     *\n     * @name eachLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.each]{@link module:Collections.each}\n     * @alias forEachLimit\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The array index is not passed to the iteratee.\n     * If you need the index, use `eachOfLimit`.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called when all\n     * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n     * @returns {Promise} a promise, if a callback is omitted\n     */\n    function eachLimit$1(coll, limit, iteratee, callback) {\n        return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n    }\n    var eachLimit$2 = awaitify(eachLimit$1, 4);\n\n    /**\n     * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n     *\n     * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item\n     * in series and therefore the iteratee functions will complete in order.\n\n     * @name eachSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.each]{@link module:Collections.each}\n     * @alias forEachSeries\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to each\n     * item in `coll`.\n     * The array index is not passed to the iteratee.\n     * If you need the index, use `eachOfSeries`.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called when all\n     * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n     * @returns {Promise} a promise, if a callback is omitted\n     */\n    function eachSeries(coll, iteratee, callback) {\n        return eachLimit$2(coll, 1, iteratee, callback)\n    }\n    var eachSeries$1 = awaitify(eachSeries, 3);\n\n    /**\n     * Wrap an async function and ensure it calls its callback on a later tick of\n     * the event loop.  If the function already calls its callback on a next tick,\n     * no extra deferral is added. This is useful for preventing stack overflows\n     * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n     * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n     * contained. ES2017 `async` functions are returned as-is -- they are immune\n     * to Zalgo's corrupting influences, as they always resolve on a later tick.\n     *\n     * @name ensureAsync\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {AsyncFunction} fn - an async function, one that expects a node-style\n     * callback as its last argument.\n     * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n     * signature as the function passed in.\n     * @example\n     *\n     * function sometimesAsync(arg, callback) {\n     *     if (cache[arg]) {\n     *         return callback(null, cache[arg]); // this would be synchronous!!\n     *     } else {\n     *         doSomeIO(arg, callback); // this IO would be asynchronous\n     *     }\n     * }\n     *\n     * // this has a risk of stack overflows if many results are cached in a row\n     * async.mapSeries(args, sometimesAsync, done);\n     *\n     * // this will defer sometimesAsync's callback if necessary,\n     * // preventing stack overflows\n     * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n     */\n    function ensureAsync(fn) {\n        if (isAsync(fn)) return fn;\n        return function (...args/*, callback*/) {\n            var callback = args.pop();\n            var sync = true;\n            args.push((...innerArgs) => {\n                if (sync) {\n                    setImmediate$1(() => callback(...innerArgs));\n                } else {\n                    callback(...innerArgs);\n                }\n            });\n            fn.apply(this, args);\n            sync = false;\n        };\n    }\n\n    /**\n     * Returns `true` if every element in `coll` satisfies an async test. If any\n     * iteratee call returns `false`, the main `callback` is immediately called.\n     *\n     * @name every\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @alias all\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n     * in the collection in parallel.\n     * The iteratee must complete with a boolean result value.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Result will be either `true` or `false`\n     * depending on the values of the async tests. Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback provided\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     * // dir4 does not exist\n     *\n     * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file5.txt'];\n     * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];\n     *\n     * // asynchronous function that checks if a file exists\n     * function fileExists(file, callback) {\n     *    fs.access(file, fs.constants.F_OK, (err) => {\n     *        callback(null, !err);\n     *    });\n     * }\n     *\n     * // Using callbacks\n     * async.every(fileList, fileExists, function(err, result) {\n     *     console.log(result);\n     *     // true\n     *     // result is true since every file exists\n     * });\n     *\n     * async.every(withMissingFileList, fileExists, function(err, result) {\n     *     console.log(result);\n     *     // false\n     *     // result is false since NOT every file exists\n     * });\n     *\n     * // Using Promises\n     * async.every(fileList, fileExists)\n     * .then( result => {\n     *     console.log(result);\n     *     // true\n     *     // result is true since every file exists\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * async.every(withMissingFileList, fileExists)\n     * .then( result => {\n     *     console.log(result);\n     *     // false\n     *     // result is false since NOT every file exists\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.every(fileList, fileExists);\n     *         console.log(result);\n     *         // true\n     *         // result is true since every file exists\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * async () => {\n     *     try {\n     *         let result = await async.every(withMissingFileList, fileExists);\n     *         console.log(result);\n     *         // false\n     *         // result is false since NOT every file exists\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function every(coll, iteratee, callback) {\n        return _createTester(bool => !bool, res => !res)(eachOf$1, coll, iteratee, callback)\n    }\n    var every$1 = awaitify(every, 3);\n\n    /**\n     * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n     *\n     * @name everyLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.every]{@link module:Collections.every}\n     * @alias allLimit\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n     * in the collection in parallel.\n     * The iteratee must complete with a boolean result value.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Result will be either `true` or `false`\n     * depending on the values of the async tests. Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback provided\n     */\n    function everyLimit(coll, limit, iteratee, callback) {\n        return _createTester(bool => !bool, res => !res)(eachOfLimit(limit), coll, iteratee, callback)\n    }\n    var everyLimit$1 = awaitify(everyLimit, 4);\n\n    /**\n     * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n     *\n     * @name everySeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.every]{@link module:Collections.every}\n     * @alias allSeries\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n     * in the collection in series.\n     * The iteratee must complete with a boolean result value.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Result will be either `true` or `false`\n     * depending on the values of the async tests. Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback provided\n     */\n    function everySeries(coll, iteratee, callback) {\n        return _createTester(bool => !bool, res => !res)(eachOfSeries$1, coll, iteratee, callback)\n    }\n    var everySeries$1 = awaitify(everySeries, 3);\n\n    function filterArray(eachfn, arr, iteratee, callback) {\n        var truthValues = new Array(arr.length);\n        eachfn(arr, (x, index, iterCb) => {\n            iteratee(x, (err, v) => {\n                truthValues[index] = !!v;\n                iterCb(err);\n            });\n        }, err => {\n            if (err) return callback(err);\n            var results = [];\n            for (var i = 0; i < arr.length; i++) {\n                if (truthValues[i]) results.push(arr[i]);\n            }\n            callback(null, results);\n        });\n    }\n\n    function filterGeneric(eachfn, coll, iteratee, callback) {\n        var results = [];\n        eachfn(coll, (x, index, iterCb) => {\n            iteratee(x, (err, v) => {\n                if (err) return iterCb(err);\n                if (v) {\n                    results.push({index, value: x});\n                }\n                iterCb(err);\n            });\n        }, err => {\n            if (err) return callback(err);\n            callback(null, results\n                .sort((a, b) => a.index - b.index)\n                .map(v => v.value));\n        });\n    }\n\n    function _filter(eachfn, coll, iteratee, callback) {\n        var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n        return filter(eachfn, coll, wrapAsync(iteratee), callback);\n    }\n\n    /**\n     * Returns a new array of all the values in `coll` which pass an async truth\n     * test. This operation is performed in parallel, but the results array will be\n     * in the same order as the original.\n     *\n     * @name filter\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @alias select\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n     * with a boolean argument once it has completed. Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback provided\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     *\n     * const files = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];\n     *\n     * // asynchronous function that checks if a file exists\n     * function fileExists(file, callback) {\n     *    fs.access(file, fs.constants.F_OK, (err) => {\n     *        callback(null, !err);\n     *    });\n     * }\n     *\n     * // Using callbacks\n     * async.filter(files, fileExists, function(err, results) {\n     *    if(err) {\n     *        console.log(err);\n     *    } else {\n     *        console.log(results);\n     *        // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n     *        // results is now an array of the existing files\n     *    }\n     * });\n     *\n     * // Using Promises\n     * async.filter(files, fileExists)\n     * .then(results => {\n     *     console.log(results);\n     *     // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n     *     // results is now an array of the existing files\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let results = await async.filter(files, fileExists);\n     *         console.log(results);\n     *         // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n     *         // results is now an array of the existing files\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function filter (coll, iteratee, callback) {\n        return _filter(eachOf$1, coll, iteratee, callback)\n    }\n    var filter$1 = awaitify(filter, 3);\n\n    /**\n     * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n     * time.\n     *\n     * @name filterLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.filter]{@link module:Collections.filter}\n     * @alias selectLimit\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n     * with a boolean argument once it has completed. Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback provided\n     */\n    function filterLimit (coll, limit, iteratee, callback) {\n        return _filter(eachOfLimit(limit), coll, iteratee, callback)\n    }\n    var filterLimit$1 = awaitify(filterLimit, 4);\n\n    /**\n     * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n     *\n     * @name filterSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.filter]{@link module:Collections.filter}\n     * @alias selectSeries\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n     * with a boolean argument once it has completed. Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Invoked with (err, results)\n     * @returns {Promise} a promise, if no callback provided\n     */\n    function filterSeries (coll, iteratee, callback) {\n        return _filter(eachOfSeries$1, coll, iteratee, callback)\n    }\n    var filterSeries$1 = awaitify(filterSeries, 3);\n\n    /**\n     * Calls the asynchronous function `fn` with a callback parameter that allows it\n     * to call itself again, in series, indefinitely.\n\n     * If an error is passed to the callback then `errback` is called with the\n     * error, and execution stops, otherwise it will never be called.\n     *\n     * @name forever\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {AsyncFunction} fn - an async function to call repeatedly.\n     * Invoked with (next).\n     * @param {Function} [errback] - when `fn` passes an error to it's callback,\n     * this function will be called, and execution stops. Invoked with (err).\n     * @returns {Promise} a promise that rejects if an error occurs and an errback\n     * is not passed\n     * @example\n     *\n     * async.forever(\n     *     function(next) {\n     *         // next is suitable for passing to things that need a callback(err [, whatever]);\n     *         // it will result in this function being called again.\n     *     },\n     *     function(err) {\n     *         // if next is called with a value in its first parameter, it will appear\n     *         // in here as 'err', and execution will stop.\n     *     }\n     * );\n     */\n    function forever(fn, errback) {\n        var done = onlyOnce(errback);\n        var task = wrapAsync(ensureAsync(fn));\n\n        function next(err) {\n            if (err) return done(err);\n            if (err === false) return;\n            task(next);\n        }\n        return next();\n    }\n    var forever$1 = awaitify(forever, 2);\n\n    /**\n     * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n     *\n     * @name groupByLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.groupBy]{@link module:Collections.groupBy}\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The iteratee should complete with a `key` to group the value under.\n     * Invoked with (value, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. Result is an `Object` whoses\n     * properties are arrays of values which returned the corresponding key.\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function groupByLimit(coll, limit, iteratee, callback) {\n        var _iteratee = wrapAsync(iteratee);\n        return mapLimit$1(coll, limit, (val, iterCb) => {\n            _iteratee(val, (err, key) => {\n                if (err) return iterCb(err);\n                return iterCb(err, {key, val});\n            });\n        }, (err, mapResults) => {\n            var result = {};\n            // from MDN, handle object having an `hasOwnProperty` prop\n            var {hasOwnProperty} = Object.prototype;\n\n            for (var i = 0; i < mapResults.length; i++) {\n                if (mapResults[i]) {\n                    var {key} = mapResults[i];\n                    var {val} = mapResults[i];\n\n                    if (hasOwnProperty.call(result, key)) {\n                        result[key].push(val);\n                    } else {\n                        result[key] = [val];\n                    }\n                }\n            }\n\n            return callback(err, result);\n        });\n    }\n\n    var groupByLimit$1 = awaitify(groupByLimit, 4);\n\n    /**\n     * Returns a new object, where each value corresponds to an array of items, from\n     * `coll`, that returned the corresponding key. That is, the keys of the object\n     * correspond to the values passed to the `iteratee` callback.\n     *\n     * Note: Since this function applies the `iteratee` to each item in parallel,\n     * there is no guarantee that the `iteratee` functions will complete in order.\n     * However, the values for each key in the `result` will be in the same order as\n     * the original `coll`. For Objects, the values will roughly be in the order of\n     * the original Objects' keys (but this can vary across JavaScript engines).\n     *\n     * @name groupBy\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The iteratee should complete with a `key` to group the value under.\n     * Invoked with (value, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. Result is an `Object` whoses\n     * properties are arrays of values which returned the corresponding key.\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     * // dir4 does not exist\n     *\n     * const files = ['dir1/file1.txt','dir2','dir4']\n     *\n     * // asynchronous function that detects file type as none, file, or directory\n     * function detectFile(file, callback) {\n     *     fs.stat(file, function(err, stat) {\n     *         if (err) {\n     *             return callback(null, 'none');\n     *         }\n     *         callback(null, stat.isDirectory() ? 'directory' : 'file');\n     *     });\n     * }\n     *\n     * //Using callbacks\n     * async.groupBy(files, detectFile, function(err, result) {\n     *     if(err) {\n     *         console.log(err);\n     *     } else {\n     *\t       console.log(result);\n     *         // {\n     *         //     file: [ 'dir1/file1.txt' ],\n     *         //     none: [ 'dir4' ],\n     *         //     directory: [ 'dir2']\n     *         // }\n     *         // result is object containing the files grouped by type\n     *     }\n     * });\n     *\n     * // Using Promises\n     * async.groupBy(files, detectFile)\n     * .then( result => {\n     *     console.log(result);\n     *     // {\n     *     //     file: [ 'dir1/file1.txt' ],\n     *     //     none: [ 'dir4' ],\n     *     //     directory: [ 'dir2']\n     *     // }\n     *     // result is object containing the files grouped by type\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.groupBy(files, detectFile);\n     *         console.log(result);\n     *         // {\n     *         //     file: [ 'dir1/file1.txt' ],\n     *         //     none: [ 'dir4' ],\n     *         //     directory: [ 'dir2']\n     *         // }\n     *         // result is object containing the files grouped by type\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function groupBy (coll, iteratee, callback) {\n        return groupByLimit$1(coll, Infinity, iteratee, callback)\n    }\n\n    /**\n     * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n     *\n     * @name groupBySeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.groupBy]{@link module:Collections.groupBy}\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The iteratee should complete with a `key` to group the value under.\n     * Invoked with (value, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. Result is an `Object` whose\n     * properties are arrays of values which returned the corresponding key.\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function groupBySeries (coll, iteratee, callback) {\n        return groupByLimit$1(coll, 1, iteratee, callback)\n    }\n\n    /**\n     * Logs the result of an `async` function to the `console`. Only works in\n     * Node.js or in browsers that support `console.log` and `console.error` (such\n     * as FF and Chrome). If multiple arguments are returned from the async\n     * function, `console.log` is called on each argument in order.\n     *\n     * @name log\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {AsyncFunction} function - The function you want to eventually apply\n     * all arguments to.\n     * @param {...*} arguments... - Any number of arguments to apply to the function.\n     * @example\n     *\n     * // in a module\n     * var hello = function(name, callback) {\n     *     setTimeout(function() {\n     *         callback(null, 'hello ' + name);\n     *     }, 1000);\n     * };\n     *\n     * // in the node repl\n     * node> async.log(hello, 'world');\n     * 'hello world'\n     */\n    var log = consoleFunc('log');\n\n    /**\n     * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n     * time.\n     *\n     * @name mapValuesLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.mapValues]{@link module:Collections.mapValues}\n     * @category Collection\n     * @param {Object} obj - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - A function to apply to each value and key\n     * in `coll`.\n     * The iteratee should complete with the transformed value as its result.\n     * Invoked with (value, key, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. `result` is a new object consisting\n     * of each key from `obj`, with each transformed value on the right-hand side.\n     * Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function mapValuesLimit(obj, limit, iteratee, callback) {\n        callback = once(callback);\n        var newObj = {};\n        var _iteratee = wrapAsync(iteratee);\n        return eachOfLimit(limit)(obj, (val, key, next) => {\n            _iteratee(val, key, (err, result) => {\n                if (err) return next(err);\n                newObj[key] = result;\n                next(err);\n            });\n        }, err => callback(err, newObj));\n    }\n\n    var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);\n\n    /**\n     * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n     *\n     * Produces a new Object by mapping each value of `obj` through the `iteratee`\n     * function. The `iteratee` is called each `value` and `key` from `obj` and a\n     * callback for when it has finished processing. Each of these callbacks takes\n     * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n     * passes an error to its callback, the main `callback` (for the `mapValues`\n     * function) is immediately called with the error.\n     *\n     * Note, the order of the keys in the result is not guaranteed.  The keys will\n     * be roughly in the order they complete, (but this is very engine-specific)\n     *\n     * @name mapValues\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @category Collection\n     * @param {Object} obj - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - A function to apply to each value and key\n     * in `coll`.\n     * The iteratee should complete with the transformed value as its result.\n     * Invoked with (value, key, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. `result` is a new object consisting\n     * of each key from `obj`, with each transformed value on the right-hand side.\n     * Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * // file1.txt is a file that is 1000 bytes in size\n     * // file2.txt is a file that is 2000 bytes in size\n     * // file3.txt is a file that is 3000 bytes in size\n     * // file4.txt does not exist\n     *\n     * const fileMap = {\n     *     f1: 'file1.txt',\n     *     f2: 'file2.txt',\n     *     f3: 'file3.txt'\n     * };\n     *\n     * const withMissingFileMap = {\n     *     f1: 'file1.txt',\n     *     f2: 'file2.txt',\n     *     f3: 'file4.txt'\n     * };\n     *\n     * // asynchronous function that returns the file size in bytes\n     * function getFileSizeInBytes(file, key, callback) {\n     *     fs.stat(file, function(err, stat) {\n     *         if (err) {\n     *             return callback(err);\n     *         }\n     *         callback(null, stat.size);\n     *     });\n     * }\n     *\n     * // Using callbacks\n     * async.mapValues(fileMap, getFileSizeInBytes, function(err, result) {\n     *     if (err) {\n     *         console.log(err);\n     *     } else {\n     *         console.log(result);\n     *         // result is now a map of file size in bytes for each file, e.g.\n     *         // {\n     *         //     f1: 1000,\n     *         //     f2: 2000,\n     *         //     f3: 3000\n     *         // }\n     *     }\n     * });\n     *\n     * // Error handling\n     * async.mapValues(withMissingFileMap, getFileSizeInBytes, function(err, result) {\n     *     if (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *     } else {\n     *         console.log(result);\n     *     }\n     * });\n     *\n     * // Using Promises\n     * async.mapValues(fileMap, getFileSizeInBytes)\n     * .then( result => {\n     *     console.log(result);\n     *     // result is now a map of file size in bytes for each file, e.g.\n     *     // {\n     *     //     f1: 1000,\n     *     //     f2: 2000,\n     *     //     f3: 3000\n     *     // }\n     * }).catch (err => {\n     *     console.log(err);\n     * });\n     *\n     * // Error Handling\n     * async.mapValues(withMissingFileMap, getFileSizeInBytes)\n     * .then( result => {\n     *     console.log(result);\n     * }).catch (err => {\n     *     console.log(err);\n     *     // [ Error: ENOENT: no such file or directory ]\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.mapValues(fileMap, getFileSizeInBytes);\n     *         console.log(result);\n     *         // result is now a map of file size in bytes for each file, e.g.\n     *         // {\n     *         //     f1: 1000,\n     *         //     f2: 2000,\n     *         //     f3: 3000\n     *         // }\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * // Error Handling\n     * async () => {\n     *     try {\n     *         let result = await async.mapValues(withMissingFileMap, getFileSizeInBytes);\n     *         console.log(result);\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *     }\n     * }\n     *\n     */\n    function mapValues(obj, iteratee, callback) {\n        return mapValuesLimit$1(obj, Infinity, iteratee, callback)\n    }\n\n    /**\n     * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n     *\n     * @name mapValuesSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.mapValues]{@link module:Collections.mapValues}\n     * @category Collection\n     * @param {Object} obj - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - A function to apply to each value and key\n     * in `coll`.\n     * The iteratee should complete with the transformed value as its result.\n     * Invoked with (value, key, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. `result` is a new object consisting\n     * of each key from `obj`, with each transformed value on the right-hand side.\n     * Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function mapValuesSeries(obj, iteratee, callback) {\n        return mapValuesLimit$1(obj, 1, iteratee, callback)\n    }\n\n    /**\n     * Caches the results of an async function. When creating a hash to store\n     * function results against, the callback is omitted from the hash and an\n     * optional hash function can be used.\n     *\n     * **Note: if the async function errs, the result will not be cached and\n     * subsequent calls will call the wrapped function.**\n     *\n     * If no hash function is specified, the first argument is used as a hash key,\n     * which may work reasonably if it is a string or a data type that converts to a\n     * distinct string. Note that objects and arrays will not behave reasonably.\n     * Neither will cases where the other arguments are significant. In such cases,\n     * specify your own hash function.\n     *\n     * The cache of results is exposed as the `memo` property of the function\n     * returned by `memoize`.\n     *\n     * @name memoize\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n     * @param {Function} hasher - An optional function for generating a custom hash\n     * for storing results. It has all the arguments applied to it apart from the\n     * callback, and must be synchronous.\n     * @returns {AsyncFunction} a memoized version of `fn`\n     * @example\n     *\n     * var slow_fn = function(name, callback) {\n     *     // do something\n     *     callback(null, result);\n     * };\n     * var fn = async.memoize(slow_fn);\n     *\n     * // fn can now be used as if it were slow_fn\n     * fn('some name', function() {\n     *     // callback\n     * });\n     */\n    function memoize(fn, hasher = v => v) {\n        var memo = Object.create(null);\n        var queues = Object.create(null);\n        var _fn = wrapAsync(fn);\n        var memoized = initialParams((args, callback) => {\n            var key = hasher(...args);\n            if (key in memo) {\n                setImmediate$1(() => callback(null, ...memo[key]));\n            } else if (key in queues) {\n                queues[key].push(callback);\n            } else {\n                queues[key] = [callback];\n                _fn(...args, (err, ...resultArgs) => {\n                    // #1465 don't memoize if an error occurred\n                    if (!err) {\n                        memo[key] = resultArgs;\n                    }\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                        q[i](err, ...resultArgs);\n                    }\n                });\n            }\n        });\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    }\n\n    /* istanbul ignore file */\n\n    /**\n     * Calls `callback` on a later loop around the event loop. In Node.js this just\n     * calls `process.nextTick`.  In the browser it will use `setImmediate` if\n     * available, otherwise `setTimeout(callback, 0)`, which means other higher\n     * priority events may precede the execution of `callback`.\n     *\n     * This is used internally for browser-compatibility purposes.\n     *\n     * @name nextTick\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @see [async.setImmediate]{@link module:Utils.setImmediate}\n     * @category Util\n     * @param {Function} callback - The function to call on a later loop around\n     * the event loop. Invoked with (args...).\n     * @param {...*} args... - any number of additional arguments to pass to the\n     * callback on the next tick.\n     * @example\n     *\n     * var call_order = [];\n     * async.nextTick(function() {\n     *     call_order.push('two');\n     *     // call_order now equals ['one','two']\n     * });\n     * call_order.push('one');\n     *\n     * async.setImmediate(function (a, b, c) {\n     *     // a, b, and c equal 1, 2, and 3\n     * }, 1, 2, 3);\n     */\n    var _defer$1;\n\n    if (hasNextTick) {\n        _defer$1 = process.nextTick;\n    } else if (hasSetImmediate) {\n        _defer$1 = setImmediate;\n    } else {\n        _defer$1 = fallback;\n    }\n\n    var nextTick = wrap(_defer$1);\n\n    var parallel = awaitify((eachfn, tasks, callback) => {\n        var results = isArrayLike(tasks) ? [] : {};\n\n        eachfn(tasks, (task, key, taskCb) => {\n            wrapAsync(task)((err, ...result) => {\n                if (result.length < 2) {\n                    [result] = result;\n                }\n                results[key] = result;\n                taskCb(err);\n            });\n        }, err => callback(err, results));\n    }, 3);\n\n    /**\n     * Run the `tasks` collection of functions in parallel, without waiting until\n     * the previous function has completed. If any of the functions pass an error to\n     * its callback, the main `callback` is immediately called with the value of the\n     * error. Once the `tasks` have completed, the results are passed to the final\n     * `callback` as an array.\n     *\n     * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n     * parallel execution of code.  If your tasks do not use any timers or perform\n     * any I/O, they will actually be executed in series.  Any synchronous setup\n     * sections for each task will happen one after the other.  JavaScript remains\n     * single-threaded.\n     *\n     * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n     * execution of other tasks when a task fails.\n     *\n     * It is also possible to use an object instead of an array. Each property will\n     * be run as a function and the results will be passed to the final `callback`\n     * as an object instead of an array. This can be a more readable way of handling\n     * results from {@link async.parallel}.\n     *\n     * @name parallel\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of\n     * [async functions]{@link AsyncFunction} to run.\n     * Each async function can complete with any number of optional `result` values.\n     * @param {Function} [callback] - An optional callback to run once all the\n     * functions have completed successfully. This function gets a results array\n     * (or object) containing all the result arguments passed to the task callbacks.\n     * Invoked with (err, results).\n     * @returns {Promise} a promise, if a callback is not passed\n     *\n     * @example\n     *\n     * //Using Callbacks\n     * async.parallel([\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'one');\n     *         }, 200);\n     *     },\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'two');\n     *         }, 100);\n     *     }\n     * ], function(err, results) {\n     *     console.log(results);\n     *     // results is equal to ['one','two'] even though\n     *     // the second function had a shorter timeout.\n     * });\n     *\n     * // an example using an object instead of an array\n     * async.parallel({\n     *     one: function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 1);\n     *         }, 200);\n     *     },\n     *     two: function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 2);\n     *         }, 100);\n     *     }\n     * }, function(err, results) {\n     *     console.log(results);\n     *     // results is equal to: { one: 1, two: 2 }\n     * });\n     *\n     * //Using Promises\n     * async.parallel([\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'one');\n     *         }, 200);\n     *     },\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'two');\n     *         }, 100);\n     *     }\n     * ]).then(results => {\n     *     console.log(results);\n     *     // results is equal to ['one','two'] even though\n     *     // the second function had a shorter timeout.\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * // an example using an object instead of an array\n     * async.parallel({\n     *     one: function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 1);\n     *         }, 200);\n     *     },\n     *     two: function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 2);\n     *         }, 100);\n     *     }\n     * }).then(results => {\n     *     console.log(results);\n     *     // results is equal to: { one: 1, two: 2 }\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * //Using async/await\n     * async () => {\n     *     try {\n     *         let results = await async.parallel([\n     *             function(callback) {\n     *                 setTimeout(function() {\n     *                     callback(null, 'one');\n     *                 }, 200);\n     *             },\n     *             function(callback) {\n     *                 setTimeout(function() {\n     *                     callback(null, 'two');\n     *                 }, 100);\n     *             }\n     *         ]);\n     *         console.log(results);\n     *         // results is equal to ['one','two'] even though\n     *         // the second function had a shorter timeout.\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * // an example using an object instead of an array\n     * async () => {\n     *     try {\n     *         let results = await async.parallel({\n     *             one: function(callback) {\n     *                 setTimeout(function() {\n     *                     callback(null, 1);\n     *                 }, 200);\n     *             },\n     *            two: function(callback) {\n     *                 setTimeout(function() {\n     *                     callback(null, 2);\n     *                 }, 100);\n     *            }\n     *         });\n     *         console.log(results);\n     *         // results is equal to: { one: 1, two: 2 }\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function parallel$1(tasks, callback) {\n        return parallel(eachOf$1, tasks, callback);\n    }\n\n    /**\n     * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n     * time.\n     *\n     * @name parallelLimit\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.parallel]{@link module:ControlFlow.parallel}\n     * @category Control Flow\n     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of\n     * [async functions]{@link AsyncFunction} to run.\n     * Each async function can complete with any number of optional `result` values.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {Function} [callback] - An optional callback to run once all the\n     * functions have completed successfully. This function gets a results array\n     * (or object) containing all the result arguments passed to the task callbacks.\n     * Invoked with (err, results).\n     * @returns {Promise} a promise, if a callback is not passed\n     */\n    function parallelLimit(tasks, limit, callback) {\n        return parallel(eachOfLimit(limit), tasks, callback);\n    }\n\n    /**\n     * A queue of tasks for the worker function to complete.\n     * @typedef {Iterable} QueueObject\n     * @memberOf module:ControlFlow\n     * @property {Function} length - a function returning the number of items\n     * waiting to be processed. Invoke with `queue.length()`.\n     * @property {boolean} started - a boolean indicating whether or not any\n     * items have been pushed and processed by the queue.\n     * @property {Function} running - a function returning the number of items\n     * currently being processed. Invoke with `queue.running()`.\n     * @property {Function} workersList - a function returning the array of items\n     * currently being processed. Invoke with `queue.workersList()`.\n     * @property {Function} idle - a function returning false if there are items\n     * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n     * @property {number} concurrency - an integer for determining how many `worker`\n     * functions should be run in parallel. This property can be changed after a\n     * `queue` is created to alter the concurrency on-the-fly.\n     * @property {number} payload - an integer that specifies how many items are\n     * passed to the worker function at a time. only applies if this is a\n     * [cargo]{@link module:ControlFlow.cargo} object\n     * @property {AsyncFunction} push - add a new task to the `queue`. Calls `callback`\n     * once the `worker` has finished processing the task. Instead of a single task,\n     * a `tasks` array can be submitted. The respective callback is used for every\n     * task in the list. Invoke with `queue.push(task, [callback])`,\n     * @property {AsyncFunction} unshift - add a new task to the front of the `queue`.\n     * Invoke with `queue.unshift(task, [callback])`.\n     * @property {AsyncFunction} pushAsync - the same as `q.push`, except this returns\n     * a promise that rejects if an error occurs.\n     * @property {AsyncFunction} unshiftAsync - the same as `q.unshift`, except this returns\n     * a promise that rejects if an error occurs.\n     * @property {Function} remove - remove items from the queue that match a test\n     * function.  The test function will be passed an object with a `data` property,\n     * and a `priority` property, if this is a\n     * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.\n     * Invoked with `queue.remove(testFn)`, where `testFn` is of the form\n     * `function ({data, priority}) {}` and returns a Boolean.\n     * @property {Function} saturated - a function that sets a callback that is\n     * called when the number of running workers hits the `concurrency` limit, and\n     * further tasks will be queued.  If the callback is omitted, `q.saturated()`\n     * returns a promise for the next occurrence.\n     * @property {Function} unsaturated - a function that sets a callback that is\n     * called when the number of running workers is less than the `concurrency` &\n     * `buffer` limits, and further tasks will not be queued. If the callback is\n     * omitted, `q.unsaturated()` returns a promise for the next occurrence.\n     * @property {number} buffer - A minimum threshold buffer in order to say that\n     * the `queue` is `unsaturated`.\n     * @property {Function} empty - a function that sets a callback that is called\n     * when the last item from the `queue` is given to a `worker`. If the callback\n     * is omitted, `q.empty()` returns a promise for the next occurrence.\n     * @property {Function} drain - a function that sets a callback that is called\n     * when the last item from the `queue` has returned from the `worker`. If the\n     * callback is omitted, `q.drain()` returns a promise for the next occurrence.\n     * @property {Function} error - a function that sets a callback that is called\n     * when a task errors. Has the signature `function(error, task)`. If the\n     * callback is omitted, `error()` returns a promise that rejects on the next\n     * error.\n     * @property {boolean} paused - a boolean for determining whether the queue is\n     * in a paused state.\n     * @property {Function} pause - a function that pauses the processing of tasks\n     * until `resume()` is called. Invoke with `queue.pause()`.\n     * @property {Function} resume - a function that resumes the processing of\n     * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n     * @property {Function} kill - a function that removes the `drain` callback and\n     * empties remaining tasks from the queue forcing it to go idle. No more tasks\n     * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.\n     *\n     * @example\n     * const q = async.queue(worker, 2)\n     * q.push(item1)\n     * q.push(item2)\n     * q.push(item3)\n     * // queues are iterable, spread into an array to inspect\n     * const items = [...q] // [item1, item2, item3]\n     * // or use for of\n     * for (let item of q) {\n     *     console.log(item)\n     * }\n     *\n     * q.drain(() => {\n     *     console.log('all done')\n     * })\n     * // or\n     * await q.drain()\n     */\n\n    /**\n     * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n     * `queue` are processed in parallel (up to the `concurrency` limit). If all\n     * `worker`s are in progress, the task is queued until one becomes available.\n     * Once a `worker` completes a `task`, that `task`'s callback is called.\n     *\n     * @name queue\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {AsyncFunction} worker - An async function for processing a queued task.\n     * If you want to handle errors from an individual task, pass a callback to\n     * `q.push()`. Invoked with (task, callback).\n     * @param {number} [concurrency=1] - An `integer` for determining how many\n     * `worker` functions should be run in parallel.  If omitted, the concurrency\n     * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n     * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be\n     * attached as certain properties to listen for specific events during the\n     * lifecycle of the queue.\n     * @example\n     *\n     * // create a queue object with concurrency 2\n     * var q = async.queue(function(task, callback) {\n     *     console.log('hello ' + task.name);\n     *     callback();\n     * }, 2);\n     *\n     * // assign a callback\n     * q.drain(function() {\n     *     console.log('all items have been processed');\n     * });\n     * // or await the end\n     * await q.drain()\n     *\n     * // assign an error callback\n     * q.error(function(err, task) {\n     *     console.error('task experienced an error');\n     * });\n     *\n     * // add some items to the queue\n     * q.push({name: 'foo'}, function(err) {\n     *     console.log('finished processing foo');\n     * });\n     * // callback is optional\n     * q.push({name: 'bar'});\n     *\n     * // add some items to the queue (batch-wise)\n     * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n     *     console.log('finished processing item');\n     * });\n     *\n     * // add some items to the front of the queue\n     * q.unshift({name: 'bar'}, function (err) {\n     *     console.log('finished processing bar');\n     * });\n     */\n    function queue$1 (worker, concurrency) {\n        var _worker = wrapAsync(worker);\n        return queue((items, cb) => {\n            _worker(items[0], cb);\n        }, concurrency, 1);\n    }\n\n    // Binary min-heap implementation used for priority queue.\n    // Implementation is stable, i.e. push time is considered for equal priorities\n    class Heap {\n        constructor() {\n            this.heap = [];\n            this.pushCount = Number.MIN_SAFE_INTEGER;\n        }\n\n        get length() {\n            return this.heap.length;\n        }\n\n        empty () {\n            this.heap = [];\n            return this;\n        }\n\n        percUp(index) {\n            let p;\n\n            while (index > 0 && smaller(this.heap[index], this.heap[p=parent(index)])) {\n                let t = this.heap[index];\n                this.heap[index] = this.heap[p];\n                this.heap[p] = t;\n\n                index = p;\n            }\n        }\n\n        percDown(index) {\n            let l;\n\n            while ((l=leftChi(index)) < this.heap.length) {\n                if (l+1 < this.heap.length && smaller(this.heap[l+1], this.heap[l])) {\n                    l = l+1;\n                }\n\n                if (smaller(this.heap[index], this.heap[l])) {\n                    break;\n                }\n\n                let t = this.heap[index];\n                this.heap[index] = this.heap[l];\n                this.heap[l] = t;\n\n                index = l;\n            }\n        }\n\n        push(node) {\n            node.pushCount = ++this.pushCount;\n            this.heap.push(node);\n            this.percUp(this.heap.length-1);\n        }\n\n        unshift(node) {\n            return this.heap.push(node);\n        }\n\n        shift() {\n            let [top] = this.heap;\n\n            this.heap[0] = this.heap[this.heap.length-1];\n            this.heap.pop();\n            this.percDown(0);\n\n            return top;\n        }\n\n        toArray() {\n            return [...this];\n        }\n\n        *[Symbol.iterator] () {\n            for (let i = 0; i < this.heap.length; i++) {\n                yield this.heap[i].data;\n            }\n        }\n\n        remove (testFn) {\n            let j = 0;\n            for (let i = 0; i < this.heap.length; i++) {\n                if (!testFn(this.heap[i])) {\n                    this.heap[j] = this.heap[i];\n                    j++;\n                }\n            }\n\n            this.heap.splice(j);\n\n            for (let i = parent(this.heap.length-1); i >= 0; i--) {\n                this.percDown(i);\n            }\n\n            return this;\n        }\n    }\n\n    function leftChi(i) {\n        return (i<<1)+1;\n    }\n\n    function parent(i) {\n        return ((i+1)>>1)-1;\n    }\n\n    function smaller(x, y) {\n        if (x.priority !== y.priority) {\n            return x.priority < y.priority;\n        }\n        else {\n            return x.pushCount < y.pushCount;\n        }\n    }\n\n    /**\n     * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n     * completed in ascending priority order.\n     *\n     * @name priorityQueue\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.queue]{@link module:ControlFlow.queue}\n     * @category Control Flow\n     * @param {AsyncFunction} worker - An async function for processing a queued task.\n     * If you want to handle errors from an individual task, pass a callback to\n     * `q.push()`.\n     * Invoked with (task, callback).\n     * @param {number} concurrency - An `integer` for determining how many `worker`\n     * functions should be run in parallel.  If omitted, the concurrency defaults to\n     * `1`.  If the concurrency is `0`, an error is thrown.\n     * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are three\n     * differences between `queue` and `priorityQueue` objects:\n     * * `push(task, priority, [callback])` - `priority` should be a number. If an\n     *   array of `tasks` is given, all tasks will be assigned the same priority.\n     * * `pushAsync(task, priority, [callback])` - the same as `priorityQueue.push`,\n     *   except this returns a promise that rejects if an error occurs.\n     * * The `unshift` and `unshiftAsync` methods were removed.\n     */\n    function priorityQueue(worker, concurrency) {\n        // Start with a normal queue\n        var q = queue$1(worker, concurrency);\n\n        var {\n            push,\n            pushAsync\n        } = q;\n\n        q._tasks = new Heap();\n        q._createTaskItem = ({data, priority}, callback) => {\n            return {\n                data,\n                priority,\n                callback\n            };\n        };\n\n        function createDataItems(tasks, priority) {\n            if (!Array.isArray(tasks)) {\n                return {data: tasks, priority};\n            }\n            return tasks.map(data => { return {data, priority}; });\n        }\n\n        // Override push to accept second parameter representing priority\n        q.push = function(data, priority = 0, callback) {\n            return push(createDataItems(data, priority), callback);\n        };\n\n        q.pushAsync = function(data, priority = 0, callback) {\n            return pushAsync(createDataItems(data, priority), callback);\n        };\n\n        // Remove unshift functions\n        delete q.unshift;\n        delete q.unshiftAsync;\n\n        return q;\n    }\n\n    /**\n     * Runs the `tasks` array of functions in parallel, without waiting until the\n     * previous function has completed. Once any of the `tasks` complete or pass an\n     * error to its callback, the main `callback` is immediately called. It's\n     * equivalent to `Promise.race()`.\n     *\n     * @name race\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n     * to run. Each function can complete with an optional `result` value.\n     * @param {Function} callback - A callback to run once any of the functions have\n     * completed. This function gets an error or result from the first function that\n     * completed. Invoked with (err, result).\n     * @returns {Promise} a promise, if a callback is omitted\n     * @example\n     *\n     * async.race([\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'one');\n     *         }, 200);\n     *     },\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'two');\n     *         }, 100);\n     *     }\n     * ],\n     * // main callback\n     * function(err, result) {\n     *     // the result will be equal to 'two' as it finishes earlier\n     * });\n     */\n    function race(tasks, callback) {\n        callback = once(callback);\n        if (!Array.isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n        if (!tasks.length) return callback();\n        for (var i = 0, l = tasks.length; i < l; i++) {\n            wrapAsync(tasks[i])(callback);\n        }\n    }\n\n    var race$1 = awaitify(race, 2);\n\n    /**\n     * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n     *\n     * @name reduceRight\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.reduce]{@link module:Collections.reduce}\n     * @alias foldr\n     * @category Collection\n     * @param {Array} array - A collection to iterate over.\n     * @param {*} memo - The initial state of the reduction.\n     * @param {AsyncFunction} iteratee - A function applied to each item in the\n     * array to produce the next step in the reduction.\n     * The `iteratee` should complete with the next state of the reduction.\n     * If the iteratee completes with an error, the reduction is stopped and the\n     * main `callback` is immediately called with the error.\n     * Invoked with (memo, item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Result is the reduced value. Invoked with\n     * (err, result).\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function reduceRight (array, memo, iteratee, callback) {\n        var reversed = [...array].reverse();\n        return reduce$1(reversed, memo, iteratee, callback);\n    }\n\n    /**\n     * Wraps the async function in another function that always completes with a\n     * result object, even when it errors.\n     *\n     * The result object has either the property `error` or `value`.\n     *\n     * @name reflect\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {AsyncFunction} fn - The async function you want to wrap\n     * @returns {Function} - A function that always passes null to it's callback as\n     * the error. The second argument to the callback will be an `object` with\n     * either an `error` or a `value` property.\n     * @example\n     *\n     * async.parallel([\n     *     async.reflect(function(callback) {\n     *         // do some stuff ...\n     *         callback(null, 'one');\n     *     }),\n     *     async.reflect(function(callback) {\n     *         // do some more stuff but error ...\n     *         callback('bad stuff happened');\n     *     }),\n     *     async.reflect(function(callback) {\n     *         // do some more stuff ...\n     *         callback(null, 'two');\n     *     })\n     * ],\n     * // optional callback\n     * function(err, results) {\n     *     // values\n     *     // results[0].value = 'one'\n     *     // results[1].error = 'bad stuff happened'\n     *     // results[2].value = 'two'\n     * });\n     */\n    function reflect(fn) {\n        var _fn = wrapAsync(fn);\n        return initialParams(function reflectOn(args, reflectCallback) {\n            args.push((error, ...cbArgs) => {\n                let retVal = {};\n                if (error) {\n                    retVal.error = error;\n                }\n                if (cbArgs.length > 0){\n                    var value = cbArgs;\n                    if (cbArgs.length <= 1) {\n                        [value] = cbArgs;\n                    }\n                    retVal.value = value;\n                }\n                reflectCallback(null, retVal);\n            });\n\n            return _fn.apply(this, args);\n        });\n    }\n\n    /**\n     * A helper function that wraps an array or an object of functions with `reflect`.\n     *\n     * @name reflectAll\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @see [async.reflect]{@link module:Utils.reflect}\n     * @category Util\n     * @param {Array|Object|Iterable} tasks - The collection of\n     * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n     * @returns {Array} Returns an array of async functions, each wrapped in\n     * `async.reflect`\n     * @example\n     *\n     * let tasks = [\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'one');\n     *         }, 200);\n     *     },\n     *     function(callback) {\n     *         // do some more stuff but error ...\n     *         callback(new Error('bad stuff happened'));\n     *     },\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'two');\n     *         }, 100);\n     *     }\n     * ];\n     *\n     * async.parallel(async.reflectAll(tasks),\n     * // optional callback\n     * function(err, results) {\n     *     // values\n     *     // results[0].value = 'one'\n     *     // results[1].error = Error('bad stuff happened')\n     *     // results[2].value = 'two'\n     * });\n     *\n     * // an example using an object instead of an array\n     * let tasks = {\n     *     one: function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'one');\n     *         }, 200);\n     *     },\n     *     two: function(callback) {\n     *         callback('two');\n     *     },\n     *     three: function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'three');\n     *         }, 100);\n     *     }\n     * };\n     *\n     * async.parallel(async.reflectAll(tasks),\n     * // optional callback\n     * function(err, results) {\n     *     // values\n     *     // results.one.value = 'one'\n     *     // results.two.error = 'two'\n     *     // results.three.value = 'three'\n     * });\n     */\n    function reflectAll(tasks) {\n        var results;\n        if (Array.isArray(tasks)) {\n            results = tasks.map(reflect);\n        } else {\n            results = {};\n            Object.keys(tasks).forEach(key => {\n                results[key] = reflect.call(this, tasks[key]);\n            });\n        }\n        return results;\n    }\n\n    function reject(eachfn, arr, _iteratee, callback) {\n        const iteratee = wrapAsync(_iteratee);\n        return _filter(eachfn, arr, (value, cb) => {\n            iteratee(value, (err, v) => {\n                cb(err, !v);\n            });\n        }, callback);\n    }\n\n    /**\n     * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n     *\n     * @name reject\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.filter]{@link module:Collections.filter}\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {Function} iteratee - An async truth test to apply to each item in\n     * `coll`.\n     * The should complete with a boolean value as its `result`.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     *\n     * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];\n     *\n     * // asynchronous function that checks if a file exists\n     * function fileExists(file, callback) {\n     *    fs.access(file, fs.constants.F_OK, (err) => {\n     *        callback(null, !err);\n     *    });\n     * }\n     *\n     * // Using callbacks\n     * async.reject(fileList, fileExists, function(err, results) {\n     *    // [ 'dir3/file6.txt' ]\n     *    // results now equals an array of the non-existing files\n     * });\n     *\n     * // Using Promises\n     * async.reject(fileList, fileExists)\n     * .then( results => {\n     *     console.log(results);\n     *     // [ 'dir3/file6.txt' ]\n     *     // results now equals an array of the non-existing files\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let results = await async.reject(fileList, fileExists);\n     *         console.log(results);\n     *         // [ 'dir3/file6.txt' ]\n     *         // results now equals an array of the non-existing files\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function reject$1 (coll, iteratee, callback) {\n        return reject(eachOf$1, coll, iteratee, callback)\n    }\n    var reject$2 = awaitify(reject$1, 3);\n\n    /**\n     * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n     * time.\n     *\n     * @name rejectLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.reject]{@link module:Collections.reject}\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {Function} iteratee - An async truth test to apply to each item in\n     * `coll`.\n     * The should complete with a boolean value as its `result`.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function rejectLimit (coll, limit, iteratee, callback) {\n        return reject(eachOfLimit(limit), coll, iteratee, callback)\n    }\n    var rejectLimit$1 = awaitify(rejectLimit, 4);\n\n    /**\n     * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n     *\n     * @name rejectSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.reject]{@link module:Collections.reject}\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {Function} iteratee - An async truth test to apply to each item in\n     * `coll`.\n     * The should complete with a boolean value as its `result`.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function rejectSeries (coll, iteratee, callback) {\n        return reject(eachOfSeries$1, coll, iteratee, callback)\n    }\n    var rejectSeries$1 = awaitify(rejectSeries, 3);\n\n    function constant$1(value) {\n        return function () {\n            return value;\n        }\n    }\n\n    /**\n     * Attempts to get a successful response from `task` no more than `times` times\n     * before returning an error. If the task is successful, the `callback` will be\n     * passed the result of the successful task. If all attempts fail, the callback\n     * will be passed the error and result (if any) of the final attempt.\n     *\n     * @name retry\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @see [async.retryable]{@link module:ControlFlow.retryable}\n     * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n     * object with `times` and `interval` or a number.\n     * * `times` - The number of attempts to make before giving up.  The default\n     *   is `5`.\n     * * `interval` - The time to wait between retries, in milliseconds.  The\n     *   default is `0`. The interval may also be specified as a function of the\n     *   retry count (see example).\n     * * `errorFilter` - An optional synchronous function that is invoked on\n     *   erroneous result. If it returns `true` the retry attempts will continue;\n     *   if the function returns `false` the retry flow is aborted with the current\n     *   attempt's error and result being returned to the final callback.\n     *   Invoked with (err).\n     * * If `opts` is a number, the number specifies the number of times to retry,\n     *   with the default interval of `0`.\n     * @param {AsyncFunction} task - An async function to retry.\n     * Invoked with (callback).\n     * @param {Function} [callback] - An optional callback which is called when the\n     * task has succeeded, or after the final failed attempt. It receives the `err`\n     * and `result` arguments of the last attempt at completing the `task`. Invoked\n     * with (err, results).\n     * @returns {Promise} a promise if no callback provided\n     *\n     * @example\n     *\n     * // The `retry` function can be used as a stand-alone control flow by passing\n     * // a callback, as shown below:\n     *\n     * // try calling apiMethod 3 times\n     * async.retry(3, apiMethod, function(err, result) {\n     *     // do something with the result\n     * });\n     *\n     * // try calling apiMethod 3 times, waiting 200 ms between each retry\n     * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n     *     // do something with the result\n     * });\n     *\n     * // try calling apiMethod 10 times with exponential backoff\n     * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n     * async.retry({\n     *   times: 10,\n     *   interval: function(retryCount) {\n     *     return 50 * Math.pow(2, retryCount);\n     *   }\n     * }, apiMethod, function(err, result) {\n     *     // do something with the result\n     * });\n     *\n     * // try calling apiMethod the default 5 times no delay between each retry\n     * async.retry(apiMethod, function(err, result) {\n     *     // do something with the result\n     * });\n     *\n     * // try calling apiMethod only when error condition satisfies, all other\n     * // errors will abort the retry control flow and return to final callback\n     * async.retry({\n     *   errorFilter: function(err) {\n     *     return err.message === 'Temporary error'; // only retry on a specific error\n     *   }\n     * }, apiMethod, function(err, result) {\n     *     // do something with the result\n     * });\n     *\n     * // to retry individual methods that are not as reliable within other\n     * // control flow functions, use the `retryable` wrapper:\n     * async.auto({\n     *     users: api.getUsers.bind(api),\n     *     payments: async.retryable(3, api.getPayments.bind(api))\n     * }, function(err, results) {\n     *     // do something with the results\n     * });\n     *\n     */\n    const DEFAULT_TIMES = 5;\n    const DEFAULT_INTERVAL = 0;\n\n    function retry(opts, task, callback) {\n        var options = {\n            times: DEFAULT_TIMES,\n            intervalFunc: constant$1(DEFAULT_INTERVAL)\n        };\n\n        if (arguments.length < 3 && typeof opts === 'function') {\n            callback = task || promiseCallback();\n            task = opts;\n        } else {\n            parseTimes(options, opts);\n            callback = callback || promiseCallback();\n        }\n\n        if (typeof task !== 'function') {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n\n        var _task = wrapAsync(task);\n\n        var attempt = 1;\n        function retryAttempt() {\n            _task((err, ...args) => {\n                if (err === false) return\n                if (err && attempt++ < options.times &&\n                    (typeof options.errorFilter != 'function' ||\n                        options.errorFilter(err))) {\n                    setTimeout(retryAttempt, options.intervalFunc(attempt - 1));\n                } else {\n                    callback(err, ...args);\n                }\n            });\n        }\n\n        retryAttempt();\n        return callback[PROMISE_SYMBOL]\n    }\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ?\n                t.interval :\n                constant$1(+t.interval || DEFAULT_INTERVAL);\n\n            acc.errorFilter = t.errorFilter;\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n    /**\n     * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n     * wraps a task and makes it retryable, rather than immediately calling it\n     * with retries.\n     *\n     * @name retryable\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.retry]{@link module:ControlFlow.retry}\n     * @category Control Flow\n     * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n     * options, exactly the same as from `retry`, except for a `opts.arity` that\n     * is the arity of the `task` function, defaulting to `task.length`\n     * @param {AsyncFunction} task - the asynchronous function to wrap.\n     * This function will be passed any arguments passed to the returned wrapper.\n     * Invoked with (...args, callback).\n     * @returns {AsyncFunction} The wrapped function, which when invoked, will\n     * retry on an error, based on the parameters specified in `opts`.\n     * This function will accept the same parameters as `task`.\n     * @example\n     *\n     * async.auto({\n     *     dep1: async.retryable(3, getFromFlakyService),\n     *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n     *         maybeProcessData(results.dep1, cb);\n     *     })]\n     * }, callback);\n     */\n    function retryable (opts, task) {\n        if (!task) {\n            task = opts;\n            opts = null;\n        }\n        let arity = (opts && opts.arity) || task.length;\n        if (isAsync(task)) {\n            arity += 1;\n        }\n        var _task = wrapAsync(task);\n        return initialParams((args, callback) => {\n            if (args.length < arity - 1 || callback == null) {\n                args.push(callback);\n                callback = promiseCallback();\n            }\n            function taskFn(cb) {\n                _task(...args, cb);\n            }\n\n            if (opts) retry(opts, taskFn, callback);\n            else retry(taskFn, callback);\n\n            return callback[PROMISE_SYMBOL]\n        });\n    }\n\n    /**\n     * Run the functions in the `tasks` collection in series, each one running once\n     * the previous function has completed. If any functions in the series pass an\n     * error to its callback, no more functions are run, and `callback` is\n     * immediately called with the value of the error. Otherwise, `callback`\n     * receives an array of results when `tasks` have completed.\n     *\n     * It is also possible to use an object instead of an array. Each property will\n     * be run as a function, and the results will be passed to the final `callback`\n     * as an object instead of an array. This can be a more readable way of handling\n     *  results from {@link async.series}.\n     *\n     * **Note** that while many implementations preserve the order of object\n     * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n     * explicitly states that\n     *\n     * > The mechanics and order of enumerating the properties is not specified.\n     *\n     * So if you rely on the order in which your series of functions are executed,\n     * and want this to work on all platforms, consider using an array.\n     *\n     * @name series\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing\n     * [async functions]{@link AsyncFunction} to run in series.\n     * Each function can complete with any number of optional `result` values.\n     * @param {Function} [callback] - An optional callback to run once all the\n     * functions have completed. This function gets a results array (or object)\n     * containing all the result arguments passed to the `task` callbacks. Invoked\n     * with (err, result).\n     * @return {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * //Using Callbacks\n     * async.series([\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             // do some async task\n     *             callback(null, 'one');\n     *         }, 200);\n     *     },\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             // then do another async task\n     *             callback(null, 'two');\n     *         }, 100);\n     *     }\n     * ], function(err, results) {\n     *     console.log(results);\n     *     // results is equal to ['one','two']\n     * });\n     *\n     * // an example using objects instead of arrays\n     * async.series({\n     *     one: function(callback) {\n     *         setTimeout(function() {\n     *             // do some async task\n     *             callback(null, 1);\n     *         }, 200);\n     *     },\n     *     two: function(callback) {\n     *         setTimeout(function() {\n     *             // then do another async task\n     *             callback(null, 2);\n     *         }, 100);\n     *     }\n     * }, function(err, results) {\n     *     console.log(results);\n     *     // results is equal to: { one: 1, two: 2 }\n     * });\n     *\n     * //Using Promises\n     * async.series([\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'one');\n     *         }, 200);\n     *     },\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'two');\n     *         }, 100);\n     *     }\n     * ]).then(results => {\n     *     console.log(results);\n     *     // results is equal to ['one','two']\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * // an example using an object instead of an array\n     * async.series({\n     *     one: function(callback) {\n     *         setTimeout(function() {\n     *             // do some async task\n     *             callback(null, 1);\n     *         }, 200);\n     *     },\n     *     two: function(callback) {\n     *         setTimeout(function() {\n     *             // then do another async task\n     *             callback(null, 2);\n     *         }, 100);\n     *     }\n     * }).then(results => {\n     *     console.log(results);\n     *     // results is equal to: { one: 1, two: 2 }\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * //Using async/await\n     * async () => {\n     *     try {\n     *         let results = await async.series([\n     *             function(callback) {\n     *                 setTimeout(function() {\n     *                     // do some async task\n     *                     callback(null, 'one');\n     *                 }, 200);\n     *             },\n     *             function(callback) {\n     *                 setTimeout(function() {\n     *                     // then do another async task\n     *                     callback(null, 'two');\n     *                 }, 100);\n     *             }\n     *         ]);\n     *         console.log(results);\n     *         // results is equal to ['one','two']\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * // an example using an object instead of an array\n     * async () => {\n     *     try {\n     *         let results = await async.parallel({\n     *             one: function(callback) {\n     *                 setTimeout(function() {\n     *                     // do some async task\n     *                     callback(null, 1);\n     *                 }, 200);\n     *             },\n     *            two: function(callback) {\n     *                 setTimeout(function() {\n     *                     // then do another async task\n     *                     callback(null, 2);\n     *                 }, 100);\n     *            }\n     *         });\n     *         console.log(results);\n     *         // results is equal to: { one: 1, two: 2 }\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function series(tasks, callback) {\n        return parallel(eachOfSeries$1, tasks, callback);\n    }\n\n    /**\n     * Returns `true` if at least one element in the `coll` satisfies an async test.\n     * If any iteratee call returns `true`, the main `callback` is immediately\n     * called.\n     *\n     * @name some\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @alias any\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n     * in the collections in parallel.\n     * The iteratee should complete with a boolean `result` value.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called as soon as any\n     * iteratee returns `true`, or after all the iteratee functions have finished.\n     * Result will be either `true` or `false` depending on the values of the async\n     * tests. Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback provided\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     * // dir4 does not exist\n     *\n     * // asynchronous function that checks if a file exists\n     * function fileExists(file, callback) {\n     *    fs.access(file, fs.constants.F_OK, (err) => {\n     *        callback(null, !err);\n     *    });\n     * }\n     *\n     * // Using callbacks\n     * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists,\n     *    function(err, result) {\n     *        console.log(result);\n     *        // true\n     *        // result is true since some file in the list exists\n     *    }\n     *);\n     *\n     * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists,\n     *    function(err, result) {\n     *        console.log(result);\n     *        // false\n     *        // result is false since none of the files exists\n     *    }\n     *);\n     *\n     * // Using Promises\n     * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists)\n     * .then( result => {\n     *     console.log(result);\n     *     // true\n     *     // result is true since some file in the list exists\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists)\n     * .then( result => {\n     *     console.log(result);\n     *     // false\n     *     // result is false since none of the files exists\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists);\n     *         console.log(result);\n     *         // true\n     *         // result is true since some file in the list exists\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * async () => {\n     *     try {\n     *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists);\n     *         console.log(result);\n     *         // false\n     *         // result is false since none of the files exists\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function some(coll, iteratee, callback) {\n        return _createTester(Boolean, res => res)(eachOf$1, coll, iteratee, callback)\n    }\n    var some$1 = awaitify(some, 3);\n\n    /**\n     * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n     *\n     * @name someLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.some]{@link module:Collections.some}\n     * @alias anyLimit\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n     * in the collections in parallel.\n     * The iteratee should complete with a boolean `result` value.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called as soon as any\n     * iteratee returns `true`, or after all the iteratee functions have finished.\n     * Result will be either `true` or `false` depending on the values of the async\n     * tests. Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback provided\n     */\n    function someLimit(coll, limit, iteratee, callback) {\n        return _createTester(Boolean, res => res)(eachOfLimit(limit), coll, iteratee, callback)\n    }\n    var someLimit$1 = awaitify(someLimit, 4);\n\n    /**\n     * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n     *\n     * @name someSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.some]{@link module:Collections.some}\n     * @alias anySeries\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n     * in the collections in series.\n     * The iteratee should complete with a boolean `result` value.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called as soon as any\n     * iteratee returns `true`, or after all the iteratee functions have finished.\n     * Result will be either `true` or `false` depending on the values of the async\n     * tests. Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback provided\n     */\n    function someSeries(coll, iteratee, callback) {\n        return _createTester(Boolean, res => res)(eachOfSeries$1, coll, iteratee, callback)\n    }\n    var someSeries$1 = awaitify(someSeries, 3);\n\n    /**\n     * Sorts a list by the results of running each `coll` value through an async\n     * `iteratee`.\n     *\n     * @name sortBy\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The iteratee should complete with a value to use as the sort criteria as\n     * its `result`.\n     * Invoked with (item, callback).\n     * @param {Function} callback - A callback which is called after all the\n     * `iteratee` functions have finished, or an error occurs. Results is the items\n     * from the original `coll` sorted by the values returned by the `iteratee`\n     * calls. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback passed\n     * @example\n     *\n     * // bigfile.txt is a file that is 251100 bytes in size\n     * // mediumfile.txt is a file that is 11000 bytes in size\n     * // smallfile.txt is a file that is 121 bytes in size\n     *\n     * // asynchronous function that returns the file size in bytes\n     * function getFileSizeInBytes(file, callback) {\n     *     fs.stat(file, function(err, stat) {\n     *         if (err) {\n     *             return callback(err);\n     *         }\n     *         callback(null, stat.size);\n     *     });\n     * }\n     *\n     * // Using callbacks\n     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes,\n     *     function(err, results) {\n     *         if (err) {\n     *             console.log(err);\n     *         } else {\n     *             console.log(results);\n     *             // results is now the original array of files sorted by\n     *             // file size (ascending by default), e.g.\n     *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n     *         }\n     *     }\n     * );\n     *\n     * // By modifying the callback parameter the\n     * // sorting order can be influenced:\n     *\n     * // ascending order\n     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], function(file, callback) {\n     *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {\n     *         if (getFileSizeErr) return callback(getFileSizeErr);\n     *         callback(null, fileSize);\n     *     });\n     * }, function(err, results) {\n     *         if (err) {\n     *             console.log(err);\n     *         } else {\n     *             console.log(results);\n     *             // results is now the original array of files sorted by\n     *             // file size (ascending by default), e.g.\n     *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n     *         }\n     *     }\n     * );\n     *\n     * // descending order\n     * async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], function(file, callback) {\n     *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {\n     *         if (getFileSizeErr) {\n     *             return callback(getFileSizeErr);\n     *         }\n     *         callback(null, fileSize * -1);\n     *     });\n     * }, function(err, results) {\n     *         if (err) {\n     *             console.log(err);\n     *         } else {\n     *             console.log(results);\n     *             // results is now the original array of files sorted by\n     *             // file size (ascending by default), e.g.\n     *             // [ 'bigfile.txt', 'mediumfile.txt', 'smallfile.txt']\n     *         }\n     *     }\n     * );\n     *\n     * // Error handling\n     * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes,\n     *     function(err, results) {\n     *         if (err) {\n     *             console.log(err);\n     *             // [ Error: ENOENT: no such file or directory ]\n     *         } else {\n     *             console.log(results);\n     *         }\n     *     }\n     * );\n     *\n     * // Using Promises\n     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes)\n     * .then( results => {\n     *     console.log(results);\n     *     // results is now the original array of files sorted by\n     *     // file size (ascending by default), e.g.\n     *     // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Error handling\n     * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes)\n     * .then( results => {\n     *     console.log(results);\n     * }).catch( err => {\n     *     console.log(err);\n     *     // [ Error: ENOENT: no such file or directory ]\n     * });\n     *\n     * // Using async/await\n     * (async () => {\n     *     try {\n     *         let results = await async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);\n     *         console.log(results);\n     *         // results is now the original array of files sorted by\n     *         // file size (ascending by default), e.g.\n     *         // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * })();\n     *\n     * // Error handling\n     * async () => {\n     *     try {\n     *         let results = await async.sortBy(['missingfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);\n     *         console.log(results);\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *     }\n     * }\n     *\n     */\n    function sortBy (coll, iteratee, callback) {\n        var _iteratee = wrapAsync(iteratee);\n        return map$1(coll, (x, iterCb) => {\n            _iteratee(x, (err, criteria) => {\n                if (err) return iterCb(err);\n                iterCb(err, {value: x, criteria});\n            });\n        }, (err, results) => {\n            if (err) return callback(err);\n            callback(null, results.sort(comparator).map(v => v.value));\n        });\n\n        function comparator(left, right) {\n            var a = left.criteria, b = right.criteria;\n            return a < b ? -1 : a > b ? 1 : 0;\n        }\n    }\n    var sortBy$1 = awaitify(sortBy, 3);\n\n    /**\n     * Sets a time limit on an asynchronous function. If the function does not call\n     * its callback within the specified milliseconds, it will be called with a\n     * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n     *\n     * @name timeout\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {AsyncFunction} asyncFn - The async function to limit in time.\n     * @param {number} milliseconds - The specified time limit.\n     * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n     * to timeout Error for more information..\n     * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n     * of the control flow functions.\n     * Invoke this function with the same parameters as you would `asyncFunc`.\n     * @example\n     *\n     * function myFunction(foo, callback) {\n     *     doAsyncTask(foo, function(err, data) {\n     *         // handle errors\n     *         if (err) return callback(err);\n     *\n     *         // do some stuff ...\n     *\n     *         // return processed data\n     *         return callback(null, data);\n     *     });\n     * }\n     *\n     * var wrapped = async.timeout(myFunction, 1000);\n     *\n     * // call `wrapped` as you would `myFunction`\n     * wrapped({ bar: 'bar' }, function(err, data) {\n     *     // if `myFunction` takes < 1000 ms to execute, `err`\n     *     // and `data` will have their expected values\n     *\n     *     // else `err` will be an Error with the code 'ETIMEDOUT'\n     * });\n     */\n    function timeout(asyncFn, milliseconds, info) {\n        var fn = wrapAsync(asyncFn);\n\n        return initialParams((args, callback) => {\n            var timedOut = false;\n            var timer;\n\n            function timeoutCallback() {\n                var name = asyncFn.name || 'anonymous';\n                var error  = new Error('Callback function \"' + name + '\" timed out.');\n                error.code = 'ETIMEDOUT';\n                if (info) {\n                    error.info = info;\n                }\n                timedOut = true;\n                callback(error);\n            }\n\n            args.push((...cbArgs) => {\n                if (!timedOut) {\n                    callback(...cbArgs);\n                    clearTimeout(timer);\n                }\n            });\n\n            // setup timer and call original function\n            timer = setTimeout(timeoutCallback, milliseconds);\n            fn(...args);\n        });\n    }\n\n    function range(size) {\n        var result = Array(size);\n        while (size--) {\n            result[size] = size;\n        }\n        return result;\n    }\n\n    /**\n     * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n     * time.\n     *\n     * @name timesLimit\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.times]{@link module:ControlFlow.times}\n     * @category Control Flow\n     * @param {number} count - The number of times to run the function.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - The async function to call `n` times.\n     * Invoked with the iteration index and a callback: (n, next).\n     * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n     * @returns {Promise} a promise, if no callback is provided\n     */\n    function timesLimit(count, limit, iteratee, callback) {\n        var _iteratee = wrapAsync(iteratee);\n        return mapLimit$1(range(count), limit, _iteratee, callback);\n    }\n\n    /**\n     * Calls the `iteratee` function `n` times, and accumulates results in the same\n     * manner you would use with [map]{@link module:Collections.map}.\n     *\n     * @name times\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.map]{@link module:Collections.map}\n     * @category Control Flow\n     * @param {number} n - The number of times to run the function.\n     * @param {AsyncFunction} iteratee - The async function to call `n` times.\n     * Invoked with the iteration index and a callback: (n, next).\n     * @param {Function} callback - see {@link module:Collections.map}.\n     * @returns {Promise} a promise, if no callback is provided\n     * @example\n     *\n     * // Pretend this is some complicated async factory\n     * var createUser = function(id, callback) {\n     *     callback(null, {\n     *         id: 'user' + id\n     *     });\n     * };\n     *\n     * // generate 5 users\n     * async.times(5, function(n, next) {\n     *     createUser(n, function(err, user) {\n     *         next(err, user);\n     *     });\n     * }, function(err, users) {\n     *     // we should now have 5 users\n     * });\n     */\n    function times (n, iteratee, callback) {\n        return timesLimit(n, Infinity, iteratee, callback)\n    }\n\n    /**\n     * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n     *\n     * @name timesSeries\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.times]{@link module:ControlFlow.times}\n     * @category Control Flow\n     * @param {number} n - The number of times to run the function.\n     * @param {AsyncFunction} iteratee - The async function to call `n` times.\n     * Invoked with the iteration index and a callback: (n, next).\n     * @param {Function} callback - see {@link module:Collections.map}.\n     * @returns {Promise} a promise, if no callback is provided\n     */\n    function timesSeries (n, iteratee, callback) {\n        return timesLimit(n, 1, iteratee, callback)\n    }\n\n    /**\n     * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n     * element in parallel, each step potentially mutating an `accumulator` value.\n     * The type of the accumulator defaults to the type of collection passed in.\n     *\n     * @name transform\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n     * it will default to an empty Object or Array, depending on the type of `coll`\n     * @param {AsyncFunction} iteratee - A function applied to each item in the\n     * collection that potentially modifies the accumulator.\n     * Invoked with (accumulator, item, key, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Result is the transformed accumulator.\n     * Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback provided\n     * @example\n     *\n     * // file1.txt is a file that is 1000 bytes in size\n     * // file2.txt is a file that is 2000 bytes in size\n     * // file3.txt is a file that is 3000 bytes in size\n     *\n     * // helper function that returns human-readable size format from bytes\n     * function formatBytes(bytes, decimals = 2) {\n     *   // implementation not included for brevity\n     *   return humanReadbleFilesize;\n     * }\n     *\n     * const fileList = ['file1.txt','file2.txt','file3.txt'];\n     *\n     * // asynchronous function that returns the file size, transformed to human-readable format\n     * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.\n     * function transformFileSize(acc, value, key, callback) {\n     *     fs.stat(value, function(err, stat) {\n     *         if (err) {\n     *             return callback(err);\n     *         }\n     *         acc[key] = formatBytes(stat.size);\n     *         callback(null);\n     *     });\n     * }\n     *\n     * // Using callbacks\n     * async.transform(fileList, transformFileSize, function(err, result) {\n     *     if(err) {\n     *         console.log(err);\n     *     } else {\n     *         console.log(result);\n     *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n     *     }\n     * });\n     *\n     * // Using Promises\n     * async.transform(fileList, transformFileSize)\n     * .then(result => {\n     *     console.log(result);\n     *     // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * (async () => {\n     *     try {\n     *         let result = await async.transform(fileList, transformFileSize);\n     *         console.log(result);\n     *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * })();\n     *\n     * @example\n     *\n     * // file1.txt is a file that is 1000 bytes in size\n     * // file2.txt is a file that is 2000 bytes in size\n     * // file3.txt is a file that is 3000 bytes in size\n     *\n     * // helper function that returns human-readable size format from bytes\n     * function formatBytes(bytes, decimals = 2) {\n     *   // implementation not included for brevity\n     *   return humanReadbleFilesize;\n     * }\n     *\n     * const fileMap = { f1: 'file1.txt', f2: 'file2.txt', f3: 'file3.txt' };\n     *\n     * // asynchronous function that returns the file size, transformed to human-readable format\n     * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.\n     * function transformFileSize(acc, value, key, callback) {\n     *     fs.stat(value, function(err, stat) {\n     *         if (err) {\n     *             return callback(err);\n     *         }\n     *         acc[key] = formatBytes(stat.size);\n     *         callback(null);\n     *     });\n     * }\n     *\n     * // Using callbacks\n     * async.transform(fileMap, transformFileSize, function(err, result) {\n     *     if(err) {\n     *         console.log(err);\n     *     } else {\n     *         console.log(result);\n     *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n     *     }\n     * });\n     *\n     * // Using Promises\n     * async.transform(fileMap, transformFileSize)\n     * .then(result => {\n     *     console.log(result);\n     *     // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.transform(fileMap, transformFileSize);\n     *         console.log(result);\n     *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function transform (coll, accumulator, iteratee, callback) {\n        if (arguments.length <= 3 && typeof accumulator === 'function') {\n            callback = iteratee;\n            iteratee = accumulator;\n            accumulator = Array.isArray(coll) ? [] : {};\n        }\n        callback = once(callback || promiseCallback());\n        var _iteratee = wrapAsync(iteratee);\n\n        eachOf$1(coll, (v, k, cb) => {\n            _iteratee(accumulator, v, k, cb);\n        }, err => callback(err, accumulator));\n        return callback[PROMISE_SYMBOL]\n    }\n\n    /**\n     * It runs each task in series but stops whenever any of the functions were\n     * successful. If one of the tasks were successful, the `callback` will be\n     * passed the result of the successful task. If all tasks fail, the callback\n     * will be passed the error and result (if any) of the final attempt.\n     *\n     * @name tryEach\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing functions to\n     * run, each function is passed a `callback(err, result)` it must call on\n     * completion with an error `err` (which can be `null`) and an optional `result`\n     * value.\n     * @param {Function} [callback] - An optional callback which is called when one\n     * of the tasks has succeeded, or all have failed. It receives the `err` and\n     * `result` arguments of the last attempt at completing the `task`. Invoked with\n     * (err, results).\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     * async.tryEach([\n     *     function getDataFromFirstWebsite(callback) {\n     *         // Try getting the data from the first website\n     *         callback(err, data);\n     *     },\n     *     function getDataFromSecondWebsite(callback) {\n     *         // First website failed,\n     *         // Try getting the data from the backup website\n     *         callback(err, data);\n     *     }\n     * ],\n     * // optional callback\n     * function(err, results) {\n     *     Now do something with the data.\n     * });\n     *\n     */\n    function tryEach(tasks, callback) {\n        var error = null;\n        var result;\n        return eachSeries$1(tasks, (task, taskCb) => {\n            wrapAsync(task)((err, ...args) => {\n                if (err === false) return taskCb(err);\n\n                if (args.length < 2) {\n                    [result] = args;\n                } else {\n                    result = args;\n                }\n                error = err;\n                taskCb(err ? null : {});\n            });\n        }, () => callback(error, result));\n    }\n\n    var tryEach$1 = awaitify(tryEach);\n\n    /**\n     * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n     * unmemoized form. Handy for testing.\n     *\n     * @name unmemoize\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @see [async.memoize]{@link module:Utils.memoize}\n     * @category Util\n     * @param {AsyncFunction} fn - the memoized function\n     * @returns {AsyncFunction} a function that calls the original unmemoized function\n     */\n    function unmemoize(fn) {\n        return (...args) => {\n            return (fn.unmemoized || fn)(...args);\n        };\n    }\n\n    /**\n     * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n     * stopped, or an error occurs.\n     *\n     * @name whilst\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {AsyncFunction} test - asynchronous truth test to perform before each\n     * execution of `iteratee`. Invoked with ().\n     * @param {AsyncFunction} iteratee - An async function which is called each time\n     * `test` passes. Invoked with (callback).\n     * @param {Function} [callback] - A callback which is called after the test\n     * function has failed and repeated execution of `iteratee` has stopped. `callback`\n     * will be passed an error and any arguments passed to the final `iteratee`'s\n     * callback. Invoked with (err, [results]);\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * var count = 0;\n     * async.whilst(\n     *     function test(cb) { cb(null, count < 5); },\n     *     function iter(callback) {\n     *         count++;\n     *         setTimeout(function() {\n     *             callback(null, count);\n     *         }, 1000);\n     *     },\n     *     function (err, n) {\n     *         // 5 seconds have passed, n = 5\n     *     }\n     * );\n     */\n    function whilst(test, iteratee, callback) {\n        callback = onlyOnce(callback);\n        var _fn = wrapAsync(iteratee);\n        var _test = wrapAsync(test);\n        var results = [];\n\n        function next(err, ...rest) {\n            if (err) return callback(err);\n            results = rest;\n            if (err === false) return;\n            _test(check);\n        }\n\n        function check(err, truth) {\n            if (err) return callback(err);\n            if (err === false) return;\n            if (!truth) return callback(null, ...results);\n            _fn(next);\n        }\n\n        return _test(check);\n    }\n    var whilst$1 = awaitify(whilst, 3);\n\n    /**\n     * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n     * stopped, or an error occurs. `callback` will be passed an error and any\n     * arguments passed to the final `iteratee`'s callback.\n     *\n     * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n     *\n     * @name until\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.whilst]{@link module:ControlFlow.whilst}\n     * @category Control Flow\n     * @param {AsyncFunction} test - asynchronous truth test to perform before each\n     * execution of `iteratee`. Invoked with (callback).\n     * @param {AsyncFunction} iteratee - An async function which is called each time\n     * `test` fails. Invoked with (callback).\n     * @param {Function} [callback] - A callback which is called after the test\n     * function has passed and repeated execution of `iteratee` has stopped. `callback`\n     * will be passed an error and any arguments passed to the final `iteratee`'s\n     * callback. Invoked with (err, [results]);\n     * @returns {Promise} a promise, if a callback is not passed\n     *\n     * @example\n     * const results = []\n     * let finished = false\n     * async.until(function test(cb) {\n     *     cb(null, finished)\n     * }, function iter(next) {\n     *     fetchPage(url, (err, body) => {\n     *         if (err) return next(err)\n     *         results = results.concat(body.objects)\n     *         finished = !!body.next\n     *         next(err)\n     *     })\n     * }, function done (err) {\n     *     // all pages have been fetched\n     * })\n     */\n    function until(test, iteratee, callback) {\n        const _test = wrapAsync(test);\n        return whilst$1((cb) => _test((err, truth) => cb (err, !truth)), iteratee, callback);\n    }\n\n    /**\n     * Runs the `tasks` array of functions in series, each passing their results to\n     * the next in the array. However, if any of the `tasks` pass an error to their\n     * own callback, the next function is not executed, and the main `callback` is\n     * immediately called with the error.\n     *\n     * @name waterfall\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n     * to run.\n     * Each function should complete with any number of `result` values.\n     * The `result` values will be passed as arguments, in order, to the next task.\n     * @param {Function} [callback] - An optional callback to run once all the\n     * functions have completed. This will be passed the results of the last task's\n     * callback. Invoked with (err, [results]).\n     * @returns {Promise} a promise, if a callback is omitted\n     * @example\n     *\n     * async.waterfall([\n     *     function(callback) {\n     *         callback(null, 'one', 'two');\n     *     },\n     *     function(arg1, arg2, callback) {\n     *         // arg1 now equals 'one' and arg2 now equals 'two'\n     *         callback(null, 'three');\n     *     },\n     *     function(arg1, callback) {\n     *         // arg1 now equals 'three'\n     *         callback(null, 'done');\n     *     }\n     * ], function (err, result) {\n     *     // result now equals 'done'\n     * });\n     *\n     * // Or, with named functions:\n     * async.waterfall([\n     *     myFirstFunction,\n     *     mySecondFunction,\n     *     myLastFunction,\n     * ], function (err, result) {\n     *     // result now equals 'done'\n     * });\n     * function myFirstFunction(callback) {\n     *     callback(null, 'one', 'two');\n     * }\n     * function mySecondFunction(arg1, arg2, callback) {\n     *     // arg1 now equals 'one' and arg2 now equals 'two'\n     *     callback(null, 'three');\n     * }\n     * function myLastFunction(arg1, callback) {\n     *     // arg1 now equals 'three'\n     *     callback(null, 'done');\n     * }\n     */\n    function waterfall (tasks, callback) {\n        callback = once(callback);\n        if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n        if (!tasks.length) return callback();\n        var taskIndex = 0;\n\n        function nextTask(args) {\n            var task = wrapAsync(tasks[taskIndex++]);\n            task(...args, onlyOnce(next));\n        }\n\n        function next(err, ...args) {\n            if (err === false) return\n            if (err || taskIndex === tasks.length) {\n                return callback(err, ...args);\n            }\n            nextTask(args);\n        }\n\n        nextTask([]);\n    }\n\n    var waterfall$1 = awaitify(waterfall);\n\n    /**\n     * An \"async function\" in the context of Async is an asynchronous function with\n     * a variable number of parameters, with the final parameter being a callback.\n     * (`function (arg1, arg2, ..., callback) {}`)\n     * The final callback is of the form `callback(err, results...)`, which must be\n     * called once the function is completed.  The callback should be called with a\n     * Error as its first argument to signal that an error occurred.\n     * Otherwise, if no error occurred, it should be called with `null` as the first\n     * argument, and any additional `result` arguments that may apply, to signal\n     * successful completion.\n     * The callback must be called exactly once, ideally on a later tick of the\n     * JavaScript event loop.\n     *\n     * This type of function is also referred to as a \"Node-style async function\",\n     * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n     * library are themselves CPS/Node-style async functions, or functions that\n     * return CPS/Node-style async functions.\n     *\n     * Wherever we accept a Node-style async function, we also directly accept an\n     * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n     * In this case, the `async` function will not be passed a final callback\n     * argument, and any thrown error will be used as the `err` argument of the\n     * implicit callback, and the return value will be used as the `result` value.\n     * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n     * argument, and a `resolved` value becomes the `result`.)\n     *\n     * Note, due to JavaScript limitations, we can only detect native `async`\n     * functions and not transpilied implementations.\n     * Your environment must have `async`/`await` support for this to work.\n     * (e.g. Node > v7.6, or a recent version of a modern browser).\n     * If you are using `async` functions through a transpiler (e.g. Babel), you\n     * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n     * because the `async function` will be compiled to an ordinary function that\n     * returns a promise.\n     *\n     * @typedef {Function} AsyncFunction\n     * @static\n     */\n\n    var index = {\n        apply,\n        applyEach: applyEach$1,\n        applyEachSeries,\n        asyncify,\n        auto,\n        autoInject,\n        cargo,\n        cargoQueue: cargo$1,\n        compose,\n        concat: concat$1,\n        concatLimit: concatLimit$1,\n        concatSeries: concatSeries$1,\n        constant,\n        detect: detect$1,\n        detectLimit: detectLimit$1,\n        detectSeries: detectSeries$1,\n        dir,\n        doUntil,\n        doWhilst: doWhilst$1,\n        each,\n        eachLimit: eachLimit$2,\n        eachOf: eachOf$1,\n        eachOfLimit: eachOfLimit$2,\n        eachOfSeries: eachOfSeries$1,\n        eachSeries: eachSeries$1,\n        ensureAsync,\n        every: every$1,\n        everyLimit: everyLimit$1,\n        everySeries: everySeries$1,\n        filter: filter$1,\n        filterLimit: filterLimit$1,\n        filterSeries: filterSeries$1,\n        forever: forever$1,\n        groupBy,\n        groupByLimit: groupByLimit$1,\n        groupBySeries,\n        log,\n        map: map$1,\n        mapLimit: mapLimit$1,\n        mapSeries: mapSeries$1,\n        mapValues,\n        mapValuesLimit: mapValuesLimit$1,\n        mapValuesSeries,\n        memoize,\n        nextTick,\n        parallel: parallel$1,\n        parallelLimit,\n        priorityQueue,\n        queue: queue$1,\n        race: race$1,\n        reduce: reduce$1,\n        reduceRight,\n        reflect,\n        reflectAll,\n        reject: reject$2,\n        rejectLimit: rejectLimit$1,\n        rejectSeries: rejectSeries$1,\n        retry,\n        retryable,\n        seq,\n        series,\n        setImmediate: setImmediate$1,\n        some: some$1,\n        someLimit: someLimit$1,\n        someSeries: someSeries$1,\n        sortBy: sortBy$1,\n        timeout,\n        times,\n        timesLimit,\n        timesSeries,\n        transform,\n        tryEach: tryEach$1,\n        unmemoize,\n        until,\n        waterfall: waterfall$1,\n        whilst: whilst$1,\n\n        // aliases\n        all: every$1,\n        allLimit: everyLimit$1,\n        allSeries: everySeries$1,\n        any: some$1,\n        anyLimit: someLimit$1,\n        anySeries: someSeries$1,\n        find: detect$1,\n        findLimit: detectLimit$1,\n        findSeries: detectSeries$1,\n        flatMap: concat$1,\n        flatMapLimit: concatLimit$1,\n        flatMapSeries: concatSeries$1,\n        forEach: each,\n        forEachSeries: eachSeries$1,\n        forEachLimit: eachLimit$2,\n        forEachOf: eachOf$1,\n        forEachOfSeries: eachOfSeries$1,\n        forEachOfLimit: eachOfLimit$2,\n        inject: reduce$1,\n        foldl: reduce$1,\n        foldr: reduceRight,\n        select: filter$1,\n        selectLimit: filterLimit$1,\n        selectSeries: filterSeries$1,\n        wrapSync: asyncify,\n        during: whilst$1,\n        doDuring: doWhilst$1\n    };\n\n    exports.default = index;\n    exports.apply = apply;\n    exports.applyEach = applyEach$1;\n    exports.applyEachSeries = applyEachSeries;\n    exports.asyncify = asyncify;\n    exports.auto = auto;\n    exports.autoInject = autoInject;\n    exports.cargo = cargo;\n    exports.cargoQueue = cargo$1;\n    exports.compose = compose;\n    exports.concat = concat$1;\n    exports.concatLimit = concatLimit$1;\n    exports.concatSeries = concatSeries$1;\n    exports.constant = constant;\n    exports.detect = detect$1;\n    exports.detectLimit = detectLimit$1;\n    exports.detectSeries = detectSeries$1;\n    exports.dir = dir;\n    exports.doUntil = doUntil;\n    exports.doWhilst = doWhilst$1;\n    exports.each = each;\n    exports.eachLimit = eachLimit$2;\n    exports.eachOf = eachOf$1;\n    exports.eachOfLimit = eachOfLimit$2;\n    exports.eachOfSeries = eachOfSeries$1;\n    exports.eachSeries = eachSeries$1;\n    exports.ensureAsync = ensureAsync;\n    exports.every = every$1;\n    exports.everyLimit = everyLimit$1;\n    exports.everySeries = everySeries$1;\n    exports.filter = filter$1;\n    exports.filterLimit = filterLimit$1;\n    exports.filterSeries = filterSeries$1;\n    exports.forever = forever$1;\n    exports.groupBy = groupBy;\n    exports.groupByLimit = groupByLimit$1;\n    exports.groupBySeries = groupBySeries;\n    exports.log = log;\n    exports.map = map$1;\n    exports.mapLimit = mapLimit$1;\n    exports.mapSeries = mapSeries$1;\n    exports.mapValues = mapValues;\n    exports.mapValuesLimit = mapValuesLimit$1;\n    exports.mapValuesSeries = mapValuesSeries;\n    exports.memoize = memoize;\n    exports.nextTick = nextTick;\n    exports.parallel = parallel$1;\n    exports.parallelLimit = parallelLimit;\n    exports.priorityQueue = priorityQueue;\n    exports.queue = queue$1;\n    exports.race = race$1;\n    exports.reduce = reduce$1;\n    exports.reduceRight = reduceRight;\n    exports.reflect = reflect;\n    exports.reflectAll = reflectAll;\n    exports.reject = reject$2;\n    exports.rejectLimit = rejectLimit$1;\n    exports.rejectSeries = rejectSeries$1;\n    exports.retry = retry;\n    exports.retryable = retryable;\n    exports.seq = seq;\n    exports.series = series;\n    exports.setImmediate = setImmediate$1;\n    exports.some = some$1;\n    exports.someLimit = someLimit$1;\n    exports.someSeries = someSeries$1;\n    exports.sortBy = sortBy$1;\n    exports.timeout = timeout;\n    exports.times = times;\n    exports.timesLimit = timesLimit;\n    exports.timesSeries = timesSeries;\n    exports.transform = transform;\n    exports.tryEach = tryEach$1;\n    exports.unmemoize = unmemoize;\n    exports.until = until;\n    exports.waterfall = waterfall$1;\n    exports.whilst = whilst$1;\n    exports.all = every$1;\n    exports.allLimit = everyLimit$1;\n    exports.allSeries = everySeries$1;\n    exports.any = some$1;\n    exports.anyLimit = someLimit$1;\n    exports.anySeries = someSeries$1;\n    exports.find = detect$1;\n    exports.findLimit = detectLimit$1;\n    exports.findSeries = detectSeries$1;\n    exports.flatMap = concat$1;\n    exports.flatMapLimit = concatLimit$1;\n    exports.flatMapSeries = concatSeries$1;\n    exports.forEach = each;\n    exports.forEachSeries = eachSeries$1;\n    exports.forEachLimit = eachLimit$2;\n    exports.forEachOf = eachOf$1;\n    exports.forEachOfSeries = eachOfSeries$1;\n    exports.forEachOfLimit = eachOfLimit$2;\n    exports.inject = reduce$1;\n    exports.foldl = reduce$1;\n    exports.foldr = reduceRight;\n    exports.select = filter$1;\n    exports.selectLimit = filterLimit$1;\n    exports.selectSeries = filterSeries$1;\n    exports.wrapSync = asyncify;\n    exports.during = whilst$1;\n    exports.doDuring = doWhilst$1;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"mappings":"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AG,EAAEF,KAAK,EAAE;MAClC,IAAIE,GAAG,KAAK,KAAK,EAAE;QACf+D,QAAQ,GAAG,IAAI;MACnB;MACA,IAAIA,QAAQ,KAAK,IAAI,EAAE;MACvB,IAAI/D,GAAG,EAAE;QACL1B,QAAQ,CAAC0B,GAAG,CAAC;MACjB,CAAC,MAAM,IAAK,EAAEgF,SAAS,KAAKlE,MAAM,IAAKhB,KAAK,KAAKwC,SAAS,EAAE;QACxDhE,QAAQ,CAAC,IAAI,CAAC;MAClB;IACJ;IAEA,OAAO6D,KAAK,GAAGrB,MAAM,EAAEqB,KAAK,EAAE,EAAE;MAC5BN,QAAQ,CAACgB,IAAI,CAACV,KAAK,CAAC,EAAEA,KAAK,EAAEwB,QAAQ,CAACsB,gBAAgB,CAAC,CAAC;IAC5D;EACJ;;EAEA;EACA,SAASC,aAAaA,CAAErC,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,EAAE;IAC9C,OAAOwG,aAAa,CAACjC,IAAI,EAAEsC,QAAQ,EAAEtD,QAAQ,EAAEvD,QAAQ,CAAC;EAC5D;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAAS8G,MAAMA,CAACvC,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,EAAE;IACtC,IAAI+G,oBAAoB,GAAGhD,WAAW,CAACQ,IAAI,CAAC,GAAGkC,eAAe,GAAGG,aAAa;IAC9E,OAAOG,oBAAoB,CAACxC,IAAI,EAAEnC,SAAS,CAACmB,QAAQ,CAAC,EAAEvD,QAAQ,CAAC;EACpE;EAEA,IAAIgH,QAAQ,GAAG1E,QAAQ,CAACwE,MAAM,EAAE,CAAC,CAAC;;EAElC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASG,GAAGA,CAAE1C,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,EAAE;IACpC,OAAOqD,SAAS,CAAC2D,QAAQ,EAAEzC,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,CAAC;EACxD;EACA,IAAIkH,KAAK,GAAG5E,QAAQ,CAAC2E,GAAG,EAAE,CAAC,CAAC;;EAE5B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIE,WAAW,GAAGrE,SAAS,CAACoE,KAAK,CAAC;;EAElC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASE,YAAYA,CAAC7C,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,EAAE;IAC5C,OAAOwG,aAAa,CAACjC,IAAI,EAAE,CAAC,EAAEhB,QAAQ,EAAEvD,QAAQ,CAAC;EACrD;EACA,IAAIqH,cAAc,GAAG/E,QAAQ,CAAC8E,YAAY,EAAE,CAAC,CAAC;;EAE9C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASE,SAASA,CAAE/C,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,EAAE;IAC1C,OAAOqD,SAAS,CAACgE,cAAc,EAAE9C,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,CAAC;EAC9D;EACA,IAAIuH,WAAW,GAAGjF,QAAQ,CAACgF,SAAS,EAAE,CAAC,CAAC;;EAExC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIE,eAAe,GAAG1E,SAAS,CAACyE,WAAW,CAAC;EAE5C,MAAME,cAAc,GAAG3F,MAAM,CAAC,iBAAiB,CAAC;EAEhD,SAAS4F,eAAeA,CAAA,EAAI;IACxB,IAAI/E,OAAO,EAAEC,MAAM;IACnB,SAAS5C,QAAQA,CAAE0B,GAAG,EAAE,GAAG7B,IAAI,EAAE;MAC7B,IAAI6B,GAAG,EAAE,OAAOkB,MAAM,CAAClB,GAAG,CAAC;MAC3BiB,OAAO,CAAC9C,IAAI,CAAC2C,MAAM,GAAG,CAAC,GAAG3C,IAAI,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC;IAC7C;IAEAG,QAAQ,CAACyH,cAAc,CAAC,GAAG,IAAI/E,OAAO,CAAC,CAACiF,GAAG,EAAEC,GAAG,KAAK;MACjDjF,OAAO,GAAGgF,GAAG,EACb/E,MAAM,GAAGgF,GAAG;IAChB,CAAC,CAAC;IAEF,OAAO5H,QAAQ;EACnB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAAS6H,IAAIA,CAACC,KAAK,EAAEC,WAAW,EAAE/H,QAAQ,EAAE;IACxC,IAAI,OAAO+H,WAAW,KAAK,QAAQ,EAAE;MACjC;MACA/H,QAAQ,GAAG+H,WAAW;MACtBA,WAAW,GAAG,IAAI;IACtB;IACA/H,QAAQ,GAAGiE,IAAI,CAACjE,QAAQ,IAAI0H,eAAe,CAAC,CAAC,CAAC;IAC9C,IAAIM,QAAQ,GAAG5D,MAAM,CAACe,IAAI,CAAC2C,KAAK,CAAC,CAACtF,MAAM;IACxC,IAAI,CAACwF,QAAQ,EAAE;MACX,OAAOhI,QAAQ,CAAC,IAAI,CAAC;IACzB;IACA,IAAI,CAAC+H,WAAW,EAAE;MACdA,WAAW,GAAGC,QAAQ;IAC1B;IAEA,IAAIxE,OAAO,GAAG,CAAC,CAAC;IAChB,IAAIyE,YAAY,GAAG,CAAC;IACpB,IAAIxC,QAAQ,GAAG,KAA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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAAS4C,OAAOA,CAAC7C,MAAM,EAAEpF,WAAW,EAAEqF,OAAO,EAAE;IAC3C,OAAOF,KAAK,CAACC,MAAM,EAAEpF,WAAW,EAAEqF,OAAO,CAAC;EAC9C;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAAS6C,MAAMA,CAAC1L,IAAI,EAAE2L,IAAI,EAAE3M,QAAQ,EAAEvD,QAAQ,EAAE;IAC5CA,QAAQ,GAAGiE,IAAI,CAACjE,QAAQ,CAAC;IACzB,IAAI0D,SAAS,GAAGtB,SAAS,CAACmB,QAAQ,CAAC;IACnC,OAAO8D,cAAc,CAAC9C,IAAI,EAAE,CAAC4L,CAAC,EAAEzL,CAAC,EAAEd,MAAM,KAAK;MAC1CF,SAAS,CAACwM,IAAI,EAAEC,CAAC,EAAE,CAACzO,GAAG,EAAEoC,CAAC,KAAK;QAC3BoM,IAAI,GAAGpM,CAAC;QACRF,MAAM,CAAClC,GAAG,CAAC;MACf,CAAC,CAAC;IACN,CAAC,EAAEA,GAAG,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C;MACJ;MAEA,OAAO1E,QAAQ,CAAC0B,GAAG,EAAEL,MAAM,CAAC;IAChC,CAAC,CAAC;EACN;EACA,IAAI4P,aAAa,GAAG3O,QAAQ,CAACwO,WAAW,EAAE,CAAC,CAAC;;EAE5C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAAS1N,MAAMA,CAACmB,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,EAAE;IACtC,OAAOiR,aAAa,CAAC1M,IAAI,EAAEsC,QAAQ,EAAEtD,QAAQ,EAAEvD,QAAQ,CAAC;EAC5D;EACA,IAAIkR,QAAQ,GAAG5O,QAAQ,CAACc,MAAM,EAAE,CAAC,CAAC;;EAElC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAAS+N,YAAYA,CAAC5M,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,EAAE;IAC5C,OAAOiR,aAAa,CAAC1M,IAAI,EAAE,CAAC,EAAEhB,QAAQ,EAAEvD,QAAQ,CAAC;EACrD;EACA,IAAIoR,cAAc,GAAG9O,QAAQ,CAAC6O,YAAY,EAAE,CAAC,CAAC;;EAE9C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASE,WAAWA,CAACzT,EAAE,EAAE;IACrB,IAAIsB,OAAO,CAACtB,EAAE,CAAC,EAAE,OAAOA,EAAE;IAC1B,OAAO,UAAU,GAAGC,IAAI,iBAAgB;MACpC,IAAIG,QAAQ,GAAGH,IAAI,CAACI,GAAG,CAAC,CAAC;MACzB,IAAIqT,IAAI,GAAG,IAAI;MACfzT,IAAI,CAACgJ,IAAI,CAAC,CAAC,GAAG0K,SAAS,KAAK;QACxB,IAAID,IAAI,EAAE;UACNvS,cAAc,CAAC,MAAMf,QAAQ,CAAC,GAAGuT,SAAS,CAAC,CAAC;QAChD,CAAC,MAAM;UACHvT,QAAQ,CAAC,GAAGuT,SAAS,CAAC;QAC1B;MACJ,CAAC,CAAC;MACF3T,EAAE,CAACD,KAAK,CAAC,IAAI,EAAEE,IAAI,CAAC;MACpByT,IAAI,GAAG,KAAK;IAChB,CAAC;EACL;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASE,KAAKA,CAACjP,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,EAAE;IACrC,OAAOuR,aAAa,CAACM,IAAI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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASG,SAASA,CAACrT,GAAG,EAAEqB,QAAQ,EAAEvD,QAAQ,EAAE;IACxC,OAAOsV,gBAAgB,CAACpT,GAAG,EAAE2E,QAAQ,EAAEtD,QAAQ,EAAEvD,QAAQ,CAAC;EAC9D;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASwV,eAAeA,CAACtT,GAAG,EAAEqB,QAAQ,EAAEvD,QAAQ,EAAE;IAC9C,OAAOsV,gBAAgB,CAACpT,GAAG,EAAE,CAAC,EAAEqB,QAAQ,EAAEvD,QAAQ,CAAC;EACvD;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASwS,UAAUA,CAAClO,KAAK,EAAE9H,QAAQ,EAAE;IACjC,OAAO+V,QAAQ,CAAC/O,QAAQ,EAAEc,KAAK,EAAE9H,QAAQ,CAAC;EAC9C;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASiW,aAAaA,CAACnO,KAAK,EAAEtC,KAAK,EAAExF,QAAQ,EAAE;IAC3C,OAAO+V,QAAQ,CAAC7P,WAAW,CAACV,KAAK,CAAC,EAAEsC,KAAK,EAAE9H,QAAQ,CAAC;EACxD;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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ACvD;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAAS4X,OAAOA,CAAChY,EAAE,EAAE;IACjB,IAAI6S,GAAG,GAAGrQ,SAAS,CAACxC,EAAE,CAAC;IACvB,OAAOG,aAAa,CAAC,SAAS8X,SAASA,CAAChY,IAAI,EAAEiY,eAAe,EAAE;MAC3DjY,IAAI,CAACgJ,IAAI,CAAC,CAAChH,KAAK,EAAE,GAAGgB,MAAM,KAAK;QAC5B,IAAIkV,MAAM,GAAG,CAAC,CAAC;QACf,IAAIlW,KAAK,EAAE;UACPkW,MAAM,CAAClW,KAAK,GAAGA,KAAK;QACxB;QACA,IAAIgB,MAAM,CAACL,MAAM,GAAG,CAAC,EAAC;UAClB,IAAIhB,KAAK,GAAGqB,MAAM;UAClB,IAAIA,MAAM,CAACL,MAAM,IAAI,CAAC,EAAE;YACpB,CAAChB,KAAK,CAAC,GAAGqB,MAAM;UACpB;UACAkV,MAAM,CAACvW,KAAK,GAAGA,KAAK;QACxB;QACAsW,eAAe,CAAC,IAAI,EAAEC,MAAM,CAAC;MACjC,CAAC,CAAC;MAEF,OAAOtF,GAAG,CAAC9S,KAAK,CAAC,IAAI,EAAEE,IAAI,CAAC;IAChC,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASmY,UAAUA,CAAClQ,KAAK,EAAE;IACvB,IAAItE,OAAO;IACX,IAAIkF,KAAK,CAACC,OAAO,CAACb,KAAK,CAAC,EAAE;MACtBtE,OAAO,GAAGsE,KAAK,CAACb,GAAG,CAAC2Q,OAAO,CAAC;IAChC,CAAC,MAAM;MACHpU,OAAO,GAAG,CAAC,CAAC;MACZY,MAAM,CAACe,IAAI,CAAC2C,KAAK,CAAC,CAACU,OAAO,CAAC3D,GAAG,IAAI;QAC9BrB,OAAO,CAACqB,GAAG,CAAC,GAAG+S,OAAO,CAAC1X,IAAI,CAAC,IAAI,EAAE4H,KAAK,CAACjD,GAAG,CAAC,CAAC;MACjD,CAAC,CAAC;IACN;IACA,OAAOrB,OAAO;EAClB;EAEA,SAASZ,MAAMA,CAACG,MAAM,EAAEO,GAAG,EAAEI,SAAS,EAAE1D,QAAQ,EAAE;IAC9C,MAAMuD,QAAQ,GAAGnB,SAAS,CAACsB,SAAS,CAAC;IACrC,OAAO0Q,OAAO,CAACrR,MAAM,EAAEO,GAAG,EAAE,CAAC9B,KAAK,EAAE2B,EAAE,KAAK;MACvCI,QAAQ,CAAC/B,KAAK,EAAE,CAACE,GAAG,EAAEoC,CAAC,KAAK;QACxBX,EAAE,CAACzB,GAAG,EAAE,CAACoC,CAAC,CAAC;MACf,CAAC,CAAC;IACN,CAAC,EAAE9D,QAAQ,CAAC;EAChB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASiY,QAAQA,CAAE1T,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,EAAE;IACzC,OAAO4C,MAAM,CAACoE,QAAQ,EAAEzC,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,CAAC;EACrD;EACA,IAAIkY,QAAQ,GAAG5V,QAAQ,CAAC2V,QAAQ,EAAE,CAAC,CAAC;;EAEpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASE,WAAWA,CAAE5T,IAAI,EAAEiB,KAAK,EAAEjC,QAAQ,EAAEvD,QAAQ,EAAE;IACnD,OAAO4C,MAAM,CAACsD,WAAW,CAACV,KAAK,CAAC,EAAEjB,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,CAAC;EAC/D;EACA,IAAIoY,aAAa,GAAG9V,QAAQ,CAAC6V,WAAW,EAAE,CAAC,CAAC;;EAE5C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASE,YAAYA,CAAE9T,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,EAAE;IAC7C,OAAO4C,MAAM,CAACyE,cAAc,EAAE9C,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,CAAC;EAC3D;EACA,IAAIsY,cAAc,GAAGhW,QAAQ,CAAC+V,YAAY,EAAE,CAAC,CAAC;EAE9C,SAASE,UAAUA,CAAC/W,KAAK,EAAE;IACvB,OAAO,YAAY;MACf,OAAOA,KAAK;IAChB,CAAC;EACL;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMgX,aAAa,GAAG,CAAC;EACvB,MAAMC,gBAAgB,GAAG,CAAC;EAE1B,SAAS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,MAAM,EAAE/J,QAAQ,CAAC;MAE5B,OAAOA,QAAQ,CAACyH,cAAc,CAAC;IACnC,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAAS+R,MAAMA,CAAC1R,KAAK,EAAE9H,QAAQ,EAAE;IAC7B,OAAO+V,QAAQ,CAAC1O,cAAc,EAAES,KAAK,EAAE9H,QAAQ,CAAC;EACpD;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASyZ,IAAIA,CAAClV,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,EAAE;IACpC,OAAOuR,aAAa,CAACmI,OAAO,EAAE/R,GAAG,IAAIA,GAAG,CAAC,CAACX,QAAQ,EAAEzC,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,CAAC;EACjF;EACA,IAAI2Z,MAAM,GAAGrX,QAAQ,CAACmX,IAAI,EAAE,CAAC,CAAC;;EAE9B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASG,SAASA,CAACrV,IAAI,EAAEiB,KAAK,EAAEjC,QAAQ,EAAEvD,QAAQ,EAAE;IAChD,OAAOuR,aAAa,CAACmI,OAAO,EAAE/R,GAAG,IAAIA,GAAG,CAAC,CAACzB,WAAW,CAACV,KAAK,CAAC,EAAEjB,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,CAAC;EAC3F;EACA,IAAI6Z,WAAW,GAAGvX,QAAQ,CAACsX,SAAS,EAAE,CAAC,CAAC;;EAExC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASE,UAAUA,CAACvV,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,EAAE;IAC1C,OAAOuR,aAAa,CAACmI,OAAO,EAAE/R,GAAG,IAAIA,GAAG,CAAC,CAACN,cAAc,EAAE9C,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,CAAC;EACvF;EACA,IAAI+Z,YAAY,GAAGzX,QAAQ,CAACwX,UAAU,EAAE,CAAC,CAAC;;EAE1C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASE,MAAMA,CAAEzV,IAAI,EAAEhB,QAAQ,EAAEvD,QAAQ,EAAE;IACvC,IAAI0D,SAAS,GAAGtB,SAAS,CAACmB,QAAQ,CAAC;IACnC,OAAO2D,KAAK,CAAC3C,IAAI,EAAE,CAAC4L,CAAC,EAAEvM,MAAM,KAAK;MAC9BF,SAAS,CAACyM,CAAC,EAAE,CAACzO,GAAG,EAAEuY,QAAQ,KAAK;QAC5B,IAAIvY,GAAG,EAAE,OAAOkC,MAAM,CAAClC,GAAG,CAAC;QAC3BkC,MAAM,CAAClC,GAAG,EAAE;UAACF,KAAK,EAAE2O,CAAC;UAAE8J;QAAQ,CAAC,CAAC;MACrC,CAAC,CAAC;IACN,CAAC,EAAE,CAACvY,GAAG,EAAE8B,OAAO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,EAAE3X,QAAQ,EAAEvD,QAAQ,CAAC;EAC/C;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASob,SAASA,CAAE7W,IAAI,EAAE8W,WAAW,EAAE9X,QAAQ,EAAEvD,QAAQ,EAAE;IACvD,IAAI+Y,SAAS,CAACvW,MAAM,IAAI,CAAC,IAAI,OAAO6Y,WAAW,KAAK,UAAU,EAAE;MAC5Drb,QAAQ,GAAGuD,QAAQ;MACnBA,QAAQ,GAAG8X,WAAW;MACtBA,WAAW,GAAG3S,KAAK,CAACC,OAAO,CAACpE,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IAC/C;IACAvE,QAAQ,GAAGiE,IAAI,CAACjE,QAAQ,IAAI0H,eAAe,CAAC,CAAC,CAAC;IAC9C,IAAIhE,SAAS,GAAGtB,SAAS,CAACmB,QAAQ,CAAC;IAEnCyD,QAAQ,CAACzC,IAAI,EAAE,CAACT,CAAC,EAAEwX,CAAC,EAAEnY,EAAE,KAAK;MACzBO,SAAS,CAAC2X,WAAW,EAAEvX,CA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"}},"mtime":1674865257031},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf\\\\formats.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"\"use strict\";\n\n/*\n * formats.js: Default formats supported by nconf\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar ini = require('ini');\nvar formats = exports;\n\n//\n// ### @json\n// Standard JSON format which pretty prints `.stringify()`.\n//\nformats.json = {\n  stringify: function (obj, replacer, spacing) {\n    return JSON.stringify(obj, replacer || null, spacing || 2);\n  },\n  parse: JSON.parse\n};\n\n//\n// ### @ini\n// Standard INI format supplied from the `ini` module\n// http://en.wikipedia.org/wiki/INI_file\n//\nformats.ini = ini;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpbmkiLCJyZXF1aXJlIiwiZm9ybWF0cyIsImV4cG9ydHMiLCJqc29uIiwic3RyaW5naWZ5Iiwib2JqIiwicmVwbGFjZXIiLCJzcGFjaW5nIiwiSlNPTiIsInBhcnNlIl0sInNvdXJjZVJvb3QiOiJDOlxcY29kZVxcRmx1aWRGcmFtZXdvcms1XFxub2RlX21vZHVsZXNcXC5wbnBtXFxuY29uZkAwLjEyLjBcXG5vZGVfbW9kdWxlc1xcbmNvbmZcXGxpYlxcbmNvbmZcXCIsInNvdXJjZXMiOlsiZm9ybWF0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogZm9ybWF0cy5qczogRGVmYXVsdCBmb3JtYXRzIHN1cHBvcnRlZCBieSBuY29uZlxuICpcbiAqIChDKSAyMDExLCBDaGFybGllIFJvYmJpbnMgYW5kIHRoZSBDb250cmlidXRvcnMuXG4gKlxuICovXG5cbnZhciBpbmkgPSByZXF1aXJlKCdpbmknKTtcblxudmFyIGZvcm1hdHMgPSBleHBvcnRzO1xuXG4vL1xuLy8gIyMjIEBqc29uXG4vLyBTdGFuZGFyZCBKU09OIGZvcm1hdCB3aGljaCBwcmV0dHkgcHJpbnRzIGAuc3RyaW5naWZ5KClgLlxuLy9cbmZvcm1hdHMuanNvbiA9IHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiAob2JqLCByZXBsYWNlciwgc3BhY2luZykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyIHx8IG51bGwsIHNwYWNpbmcgfHwgMilcbiAgfSxcbiAgcGFyc2U6IEpTT04ucGFyc2Vcbn07XG5cbi8vXG4vLyAjIyMgQGluaVxuLy8gU3RhbmRhcmQgSU5JIGZvcm1hdCBzdXBwbGllZCBmcm9tIHRoZSBgaW5pYCBtb2R1bGVcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSU5JX2ZpbGVcbi8vXG5mb3JtYXRzLmluaSA9IGluaTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUEsR0FBRyxHQUFHQyxPQUFPLENBQUMsS0FBSyxDQUFDO0FBRXhCLElBQUlDLE9BQU8sR0FBR0MsT0FBTzs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQUQsT0FBTyxDQUFDRSxJQUFJLEdBQUc7RUFDYkMsU0FBUyxFQUFFLFNBQUFBLENBQVVDLEdBQUcsRUFBRUMsUUFBUSxFQUFFQyxPQUFPLEVBQUU7SUFDM0MsT0FBT0MsSUFBSSxDQUFDSixTQUFTLENBQUNDLEdBQUcsRUFBRUMsUUFBUSxJQUFJLElBQUksRUFBRUMsT0FBTyxJQUFJLENBQUMsQ0FBQztFQUM1RCxDQUFDO0VBQ0RFLEtBQUssRUFBRUQsSUFBSSxDQUFDQztBQUNkLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBUixPQUFPLENBQUNGLEdBQUcsR0FBR0EsR0FBRyJ9","map":{"version":3,"names":["ini","require","formats","exports","json","stringify","obj","replacer","spacing","JSON","parse"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\nconf@0.12.0\\node_modules\\nconf\\lib\\nconf\\","sources":["formats.js"],"sourcesContent":["/*\n * formats.js: Default formats supported by nconf\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar ini = require('ini');\n\nvar formats = exports;\n\n//\n// ### @json\n// Standard JSON format which pretty prints `.stringify()`.\n//\nformats.json = {\n  stringify: function (obj, replacer, spacing) {\n    return JSON.stringify(obj, replacer || null, spacing || 2)\n  },\n  parse: JSON.parse\n};\n\n//\n// ### @ini\n// Standard INI format supplied from the `ini` module\n// http://en.wikipedia.org/wiki/INI_file\n//\nformats.ini = ini;\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,KAAK,CAAC;AAExB,IAAIC,OAAO,GAAGC,OAAO;;AAErB;AACA;AACA;AACA;AACAD,OAAO,CAACE,IAAI,GAAG;EACbC,SAAS,EAAE,SAAAA,CAAUC,GAAG,EAAEC,QAAQ,EAAEC,OAAO,EAAE;IAC3C,OAAOC,IAAI,CAACJ,SAAS,CAACC,GAAG,EAAEC,QAAQ,IAAI,IAAI,EAAEC,OAAO,IAAI,CAAC,CAAC;EAC5D,CAAC;EACDE,KAAK,EAAED,IAAI,CAACC;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAR,OAAO,CAACF,GAAG,GAAGA,GAAG"}},"mtime":1674865250519},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\ini@2.0.0\\\\node_modules\\\\ini\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\ini@2.0.0\\\\node_modules\\\\ini\\\\ini.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"\"use strict\";\n\nconst {\n  hasOwnProperty\n} = Object.prototype;\nconst eol = typeof process !== 'undefined' && process.platform === 'win32' ? '\\r\\n' : '\\n';\nconst encode = (obj, opt) => {\n  const children = [];\n  let out = '';\n  if (typeof opt === 'string') {\n    opt = {\n      section: opt,\n      whitespace: false\n    };\n  } else {\n    opt = opt || Object.create(null);\n    opt.whitespace = opt.whitespace === true;\n  }\n  const separator = opt.whitespace ? ' = ' : '=';\n  for (const k of Object.keys(obj)) {\n    const val = obj[k];\n    if (val && Array.isArray(val)) {\n      for (const item of val) out += safe(k + '[]') + separator + safe(item) + '\\n';\n    } else if (val && typeof val === 'object') children.push(k);else out += safe(k) + separator + safe(val) + eol;\n  }\n  if (opt.section && out.length) out = '[' + safe(opt.section) + ']' + eol + out;\n  for (const k of children) {\n    const nk = dotSplit(k).join('\\\\.');\n    const section = (opt.section ? opt.section + '.' : '') + nk;\n    const {\n      whitespace\n    } = opt;\n    const child = encode(obj[k], {\n      section,\n      whitespace\n    });\n    if (out.length && child.length) out += eol;\n    out += child;\n  }\n  return out;\n};\nconst dotSplit = str => str.replace(/\\1/g, '\\u0002LITERAL\\\\1LITERAL\\u0002').replace(/\\\\\\./g, '\\u0001').split(/\\./).map(part => part.replace(/\\1/g, '\\\\.').replace(/\\2LITERAL\\\\1LITERAL\\2/g, '\\u0001'));\nconst decode = str => {\n  const out = Object.create(null);\n  let p = out;\n  let section = null;\n  //          section     |key      = value\n  const re = /^\\[([^\\]]*)\\]$|^([^=]+)(=(.*))?$/i;\n  const lines = str.split(/[\\r\\n]+/g);\n  for (const line of lines) {\n    if (!line || line.match(/^\\s*[;#]/)) continue;\n    const match = line.match(re);\n    if (!match) continue;\n    if (match[1] !== undefined) {\n      section = unsafe(match[1]);\n      if (section === '__proto__') {\n        // not allowed\n        // keep parsing the section, but don't attach it.\n        p = Object.create(null);\n        continue;\n      }\n      p = out[section] = out[section] || Object.create(null);\n      continue;\n    }\n    const keyRaw = unsafe(match[2]);\n    const isArray = keyRaw.length > 2 && keyRaw.slice(-2) === '[]';\n    const key = isArray ? keyRaw.slice(0, -2) : keyRaw;\n    if (key === '__proto__') continue;\n    const valueRaw = match[3] ? unsafe(match[4]) : true;\n    const value = valueRaw === 'true' || valueRaw === 'false' || valueRaw === 'null' ? JSON.parse(valueRaw) : valueRaw;\n\n    // Convert keys with '[]' suffix to an array\n    if (isArray) {\n      if (!hasOwnProperty.call(p, key)) p[key] = [];else if (!Array.isArray(p[key])) p[key] = [p[key]];\n    }\n\n    // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n    if (Array.isArray(p[key])) p[key].push(value);else p[key] = value;\n  }\n\n  // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n  const remove = [];\n  for (const k of Object.keys(out)) {\n    if (!hasOwnProperty.call(out, k) || typeof out[k] !== 'object' || Array.isArray(out[k])) continue;\n\n    // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n    const parts = dotSplit(k);\n    let p = out;\n    const l = parts.pop();\n    const nl = l.replace(/\\\\\\./g, '.');\n    for (const part of parts) {\n      if (part === '__proto__') continue;\n      if (!hasOwnProperty.call(p, part) || typeof p[part] !== 'object') p[part] = Object.create(null);\n      p = p[part];\n    }\n    if (p === out && nl === l) continue;\n    p[nl] = out[k];\n    remove.push(k);\n  }\n  for (const del of remove) delete out[del];\n  return out;\n};\nconst isQuoted = val => val.charAt(0) === '\"' && val.slice(-1) === '\"' || val.charAt(0) === \"'\" && val.slice(-1) === \"'\";\nconst safe = val => typeof val !== 'string' || val.match(/[=\\r\\n]/) || val.match(/^\\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, '\\\\;').replace(/#/g, '\\\\#');\nconst unsafe = (val, doUnesc) => {\n  val = (val || '').trim();\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\") val = val.substr(1, val.length - 2);\n    try {\n      val = JSON.parse(val);\n    } catch (_) {}\n  } else {\n    // walk the val to find the first not-escaped ; character\n    let esc = false;\n    let unesc = '';\n    for (let i = 0, l = val.length; i < l; i++) {\n      const c = val.charAt(i);\n      if (esc) {\n        if ('\\\\;#'.indexOf(c) !== -1) unesc += c;else unesc += '\\\\' + c;\n        esc = false;\n      } else if (';#'.indexOf(c) !== -1) break;else if (c === '\\\\') esc = true;else unesc += c;\n    }\n    if (esc) unesc += '\\\\';\n    return unesc.trim();\n  }\n  return val;\n};\nmodule.exports = {\n  parse: decode,\n  decode,\n  stringify: encode,\n  encode,\n  safe,\n  unsafe\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsInByb3RvdHlwZSIsImVvbCIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsImVuY29kZSIsIm9iaiIsIm9wdCIsImNoaWxkcmVuIiwib3V0Iiwic2VjdGlvbiIsIndoaXRlc3BhY2UiLCJjcmVhdGUiLCJzZXBhcmF0b3IiLCJrIiwia2V5cyIsInZhbCIsIkFycmF5IiwiaXNBcnJheSIsIml0ZW0iLCJzYWZlIiwicHVzaCIsImxlbmd0aCIsIm5rIiwiZG90U3BsaXQiLCJqb2luIiwiY2hpbGQiLCJzdHIiLCJyZXBsYWNlIiwic3BsaXQiLCJtYXAiLCJwYXJ0IiwiZGVjb2RlIiwicCIsInJlIiwibGluZXMiLCJsaW5lIiwibWF0Y2giLCJ1bmRlZmluZWQiLCJ1bnNhZmUiLCJrZXlSYXciLCJzbGljZSIsImtleSIsInZhbHVlUmF3IiwidmFsdWUiLCJKU09OIiwicGFyc2UiLCJjYWxsIiwicmVtb3ZlIiwicGFydHMiLCJsIiwicG9wIiwibmwiLCJkZWwiLCJpc1F1b3RlZCIsImNoYXJBdCIsInRyaW0iLCJzdHJpbmdpZnkiLCJkb1VuZXNjIiwic3Vic3RyIiwiXyIsImVzYyIsInVuZXNjIiwiaSIsImMiLCJpbmRleE9mIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiQzpcXGNvZGVcXEZsdWlkRnJhbWV3b3JrNVxcbm9kZV9tb2R1bGVzXFwucG5wbVxcaW5pQDIuMC4wXFxub2RlX21vZHVsZXNcXGluaVxcIiwic291cmNlcyI6WyJpbmkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSB9ID0gT2JqZWN0LnByb3RvdHlwZVxuXG5jb25zdCBlb2wgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICdcXHJcXG4nIDogJ1xcbidcblxuY29uc3QgZW5jb2RlID0gKG9iaiwgb3B0KSA9PiB7XG4gIGNvbnN0IGNoaWxkcmVuID0gW11cbiAgbGV0IG91dCA9ICcnXG5cbiAgaWYgKHR5cGVvZiBvcHQgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0ID0ge1xuICAgICAgc2VjdGlvbjogb3B0LFxuICAgICAgd2hpdGVzcGFjZTogZmFsc2UsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9wdCA9IG9wdCB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgb3B0LndoaXRlc3BhY2UgPSBvcHQud2hpdGVzcGFjZSA9PT0gdHJ1ZVxuICB9XG5cbiAgY29uc3Qgc2VwYXJhdG9yID0gb3B0LndoaXRlc3BhY2UgPyAnID0gJyA6ICc9J1xuXG4gIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgY29uc3QgdmFsID0gb2JqW2tdXG4gICAgaWYgKHZhbCAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWwpXG4gICAgICAgIG91dCArPSBzYWZlKGsgKyAnW10nKSArIHNlcGFyYXRvciArIHNhZmUoaXRlbSkgKyAnXFxuJ1xuICAgIH0gZWxzZSBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKVxuICAgICAgY2hpbGRyZW4ucHVzaChrKVxuICAgIGVsc2VcbiAgICAgIG91dCArPSBzYWZlKGspICsgc2VwYXJhdG9yICsgc2FmZSh2YWwpICsgZW9sXG4gIH1cblxuICBpZiAob3B0LnNlY3Rpb24gJiYgb3V0Lmxlbmd0aClcbiAgICBvdXQgPSAnWycgKyBzYWZlKG9wdC5zZWN0aW9uKSArICddJyArIGVvbCArIG91dFxuXG4gIGZvciAoY29uc3QgayBvZiBjaGlsZHJlbikge1xuICAgIGNvbnN0IG5rID0gZG90U3BsaXQoaykuam9pbignXFxcXC4nKVxuICAgIGNvbnN0IHNlY3Rpb24gPSAob3B0LnNlY3Rpb24gPyBvcHQuc2VjdGlvbiArICcuJyA6ICcnKSArIG5rXG4gICAgY29uc3QgeyB3aGl0ZXNwYWNlIH0gPSBvcHRcbiAgICBjb25zdCBjaGlsZCA9IGVuY29kZShvYmpba10sIHtcbiAgICAgIHNlY3Rpb24sXG4gICAgICB3aGl0ZXNwYWNlLFxuICAgIH0pXG4gICAgaWYgKG91dC5sZW5ndGggJiYgY2hpbGQubGVuZ3RoKVxuICAgICAgb3V0ICs9IGVvbFxuXG4gICAgb3V0ICs9IGNoaWxkXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbmNvbnN0IGRvdFNwbGl0ID0gc3RyID0+XG4gIHN0ci5yZXBsYWNlKC9cXDEvZywgJ1xcdTAwMDJMSVRFUkFMXFxcXDFMSVRFUkFMXFx1MDAwMicpXG4gICAgLnJlcGxhY2UoL1xcXFxcXC4vZywgJ1xcdTAwMDEnKVxuICAgIC5zcGxpdCgvXFwuLylcbiAgICAubWFwKHBhcnQgPT5cbiAgICAgIHBhcnQucmVwbGFjZSgvXFwxL2csICdcXFxcLicpXG4gICAgICAgIC5yZXBsYWNlKC9cXDJMSVRFUkFMXFxcXDFMSVRFUkFMXFwyL2csICdcXHUwMDAxJykpXG5cbmNvbnN0IGRlY29kZSA9IHN0ciA9PiB7XG4gIGNvbnN0IG91dCA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgbGV0IHAgPSBvdXRcbiAgbGV0IHNlY3Rpb24gPSBudWxsXG4gIC8vICAgICAgICAgIHNlY3Rpb24gICAgIHxrZXkgICAgICA9IHZhbHVlXG4gIGNvbnN0IHJlID0gL15cXFsoW15cXF1dKilcXF0kfF4oW149XSspKD0oLiopKT8kL2lcbiAgY29uc3QgbGluZXMgPSBzdHIuc3BsaXQoL1tcXHJcXG5dKy9nKVxuXG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGlmICghbGluZSB8fCBsaW5lLm1hdGNoKC9eXFxzKls7I10vKSlcbiAgICAgIGNvbnRpbnVlXG4gICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKHJlKVxuICAgIGlmICghbWF0Y2gpXG4gICAgICBjb250aW51ZVxuICAgIGlmIChtYXRjaFsxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZWN0aW9uID0gdW5zYWZlKG1hdGNoWzFdKVxuICAgICAgaWYgKHNlY3Rpb24gPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIC8vIG5vdCBhbGxvd2VkXG4gICAgICAgIC8vIGtlZXAgcGFyc2luZyB0aGUgc2VjdGlvbiwgYnV0IGRvbid0IGF0dGFjaCBpdC5cbiAgICAgICAgcCA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHAgPSBvdXRbc2VjdGlvbl0gPSBvdXRbc2VjdGlvbl0gfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgY29uc3Qga2V5UmF3ID0gdW5zYWZlKG1hdGNoWzJdKVxuICAgIGNvbnN0IGlzQXJyYXkgPSBrZXlSYXcubGVuZ3RoID4gMiAmJiBrZXlSYXcuc2xpY2UoLTIpID09PSAnW10nXG4gICAgY29uc3Qga2V5ID0gaXNBcnJheSA/IGtleVJhdy5zbGljZSgwLCAtMikgOiBrZXlSYXdcbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJylcbiAgICAgIGNvbnRpbnVlXG4gICAgY29uc3QgdmFsdWVSYXcgPSBtYXRjaFszXSA/IHVuc2FmZShtYXRjaFs0XSkgOiB0cnVlXG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZVJhdyA9PT0gJ3RydWUnIHx8XG4gICAgICB2YWx1ZVJhdyA9PT0gJ2ZhbHNlJyB8fFxuICAgICAgdmFsdWVSYXcgPT09ICdudWxsJyA/IEpTT04ucGFyc2UodmFsdWVSYXcpXG4gICAgICA6IHZhbHVlUmF3XG5cbiAgICAvLyBDb252ZXJ0IGtleXMgd2l0aCAnW10nIHN1ZmZpeCB0byBhbiBhcnJheVxuICAgIGlmIChpc0FycmF5KSB7XG4gICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwocCwga2V5KSlcbiAgICAgICAgcFtrZXldID0gW11cbiAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHBba2V5XSkpXG4gICAgICAgIHBba2V5XSA9IFtwW2tleV1dXG4gICAgfVxuXG4gICAgLy8gc2FmZWd1YXJkIGFnYWluc3QgcmVzZXR0aW5nIGEgcHJldmlvdXNseSBkZWZpbmVkXG4gICAgLy8gYXJyYXkgYnkgYWNjaWRlbnRhbGx5IGZvcmdldHRpbmcgdGhlIGJyYWNrZXRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocFtrZXldKSlcbiAgICAgIHBba2V5XS5wdXNoKHZhbHVlKVxuICAgIGVsc2VcbiAgICAgIHBba2V5XSA9IHZhbHVlXG4gIH1cblxuICAvLyB7YTp7eToxfSxcImEuYlwiOnt4OjJ9fSAtLT4ge2E6e3k6MSxiOnt4OjJ9fX1cbiAgLy8gdXNlIGEgZmlsdGVyIHRvIHJldHVybiB0aGUga2V5cyB0aGF0IGhhdmUgdG8gYmUgZGVsZXRlZC5cbiAgY29uc3QgcmVtb3ZlID0gW11cbiAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKG91dCkpIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob3V0LCBrKSB8fFxuICAgICAgICB0eXBlb2Ygb3V0W2tdICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBBcnJheS5pc0FycmF5KG91dFtrXSkpXG4gICAgICBjb250aW51ZVxuXG4gICAgLy8gc2VlIGlmIHRoZSBwYXJlbnQgc2VjdGlvbiBpcyBhbHNvIGFuIG9iamVjdC5cbiAgICAvLyBpZiBzbywgYWRkIGl0IHRvIHRoYXQsIGFuZCBtYXJrIHRoaXMgb25lIGZvciBkZWxldGlvblxuICAgIGNvbnN0IHBhcnRzID0gZG90U3BsaXQoaylcbiAgICBsZXQgcCA9IG91dFxuICAgIGNvbnN0IGwgPSBwYXJ0cy5wb3AoKVxuICAgIGNvbnN0IG5sID0gbC5yZXBsYWNlKC9cXFxcXFwuL2csICcuJylcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIGlmIChwYXJ0ID09PSAnX19wcm90b19fJylcbiAgICAgICAgY29udGludWVcbiAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChwLCBwYXJ0KSB8fCB0eXBlb2YgcFtwYXJ0XSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHBbcGFydF0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICBwID0gcFtwYXJ0XVxuICAgIH1cbiAgICBpZiAocCA9PT0gb3V0ICYmIG5sID09PSBsKVxuICAgICAgY29udGludWVcblxuICAgIHBbbmxdID0gb3V0W2tdXG4gICAgcmVtb3ZlLnB1c2goaylcbiAgfVxuICBmb3IgKGNvbnN0IGRlbCBvZiByZW1vdmUpXG4gICAgZGVsZXRlIG91dFtkZWxdXG5cbiAgcmV0dXJuIG91dFxufVxuXG5jb25zdCBpc1F1b3RlZCA9IHZhbCA9PlxuICAodmFsLmNoYXJBdCgwKSA9PT0gJ1wiJyAmJiB2YWwuc2xpY2UoLTEpID09PSAnXCInKSB8fFxuICAgICh2YWwuY2hhckF0KDApID09PSBcIidcIiAmJiB2YWwuc2xpY2UoLTEpID09PSBcIidcIilcblxuY29uc3Qgc2FmZSA9IHZhbCA9PlxuICAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycgfHxcbiAgICB2YWwubWF0Y2goL1s9XFxyXFxuXS8pIHx8XG4gICAgdmFsLm1hdGNoKC9eXFxbLykgfHxcbiAgICAodmFsLmxlbmd0aCA+IDEgJiZcbiAgICAgaXNRdW90ZWQodmFsKSkgfHxcbiAgICB2YWwgIT09IHZhbC50cmltKCkpXG4gICAgPyBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICAgOiB2YWwucmVwbGFjZSgvOy9nLCAnXFxcXDsnKS5yZXBsYWNlKC8jL2csICdcXFxcIycpXG5cbmNvbnN0IHVuc2FmZSA9ICh2YWwsIGRvVW5lc2MpID0+IHtcbiAgdmFsID0gKHZhbCB8fCAnJykudHJpbSgpXG4gIGlmIChpc1F1b3RlZCh2YWwpKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBzaW5nbGUgcXVvdGVzIGJlZm9yZSBjYWxsaW5nIEpTT04ucGFyc2VcbiAgICBpZiAodmFsLmNoYXJBdCgwKSA9PT0gXCInXCIpXG4gICAgICB2YWwgPSB2YWwuc3Vic3RyKDEsIHZhbC5sZW5ndGggLSAyKVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhbCA9IEpTT04ucGFyc2UodmFsKVxuICAgIH0gY2F0Y2ggKF8pIHt9XG4gIH0gZWxzZSB7XG4gICAgLy8gd2FsayB0aGUgdmFsIHRvIGZpbmQgdGhlIGZpcnN0IG5vdC1lc2NhcGVkIDsgY2hhcmFjdGVyXG4gICAgbGV0IGVzYyA9IGZhbHNlXG4gICAgbGV0IHVuZXNjID0gJydcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSB2YWwuY2hhckF0KGkpXG4gICAgICBpZiAoZXNjKSB7XG4gICAgICAgIGlmICgnXFxcXDsjJy5pbmRleE9mKGMpICE9PSAtMSlcbiAgICAgICAgICB1bmVzYyArPSBjXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB1bmVzYyArPSAnXFxcXCcgKyBjXG5cbiAgICAgICAgZXNjID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAoJzsjJy5pbmRleE9mKGMpICE9PSAtMSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGVsc2UgaWYgKGMgPT09ICdcXFxcJylcbiAgICAgICAgZXNjID0gdHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICB1bmVzYyArPSBjXG4gICAgfVxuICAgIGlmIChlc2MpXG4gICAgICB1bmVzYyArPSAnXFxcXCdcblxuICAgIHJldHVybiB1bmVzYy50cmltKClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZTogZGVjb2RlLFxuICBkZWNvZGUsXG4gIHN0cmluZ2lmeTogZW5jb2RlLFxuICBlbmNvZGUsXG4gIHNhZmUsXG4gIHVuc2FmZSxcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxNQUFNO0VBQUVBO0FBQWUsQ0FBQyxHQUFHQyxNQUFNLENBQUNDLFNBQVM7QUFFM0MsTUFBTUMsR0FBRyxHQUFHLE9BQU9DLE9BQU8sS0FBSyxXQUFXLElBQ3hDQSxPQUFPLENBQUNDLFFBQVEsS0FBSyxPQUFPLEdBQUcsTUFBTSxHQUFHLElBQUk7QUFFOUMsTUFBTUMsTUFBTSxHQUFHQSxDQUFDQyxHQUFHLEVBQUVDLEdBQUcsS0FBSztFQUMz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","map":{"version":3,"names":["hasOwnProperty","Object","prototype","eol","process","platform","encode","obj","opt","children","out","section","whitespace","create","separator","k","keys","val","Array","isArray","item","safe","push","length","nk","dotSplit","join","child","str","replace","split","map","part","decode","p","re","lines","line","match","undefined","unsafe","keyRaw","slice","key","valueRaw","value","JSON","parse","call","remove","parts","l","pop","nl","del","isQuoted","charAt","trim","stringify","doUnesc","substr","_","esc","unesc","i","c","indexOf","module","exports"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\ini@2.0.0\\node_modules\\ini\\","sources":["ini.js"],"sourcesContent":["const { hasOwnProperty } = Object.prototype\n\nconst eol = typeof process !== 'undefined' &&\n  process.platform === 'win32' ? '\\r\\n' : '\\n'\n\nconst encode = (obj, opt) => {\n  const children = []\n  let out = ''\n\n  if (typeof opt === 'string') {\n    opt = {\n      section: opt,\n      whitespace: false,\n    }\n  } else {\n    opt = opt || Object.create(null)\n    opt.whitespace = opt.whitespace === true\n  }\n\n  const separator = opt.whitespace ? ' = ' : '='\n\n  for (const k of Object.keys(obj)) {\n    const val = obj[k]\n    if (val && Array.isArray(val)) {\n      for (const item of val)\n        out += safe(k + '[]') + separator + safe(item) + '\\n'\n    } else if (val && typeof val === 'object')\n      children.push(k)\n    else\n      out += safe(k) + separator + safe(val) + eol\n  }\n\n  if (opt.section && out.length)\n    out = '[' + safe(opt.section) + ']' + eol + out\n\n  for (const k of children) {\n    const nk = dotSplit(k).join('\\\\.')\n    const section = (opt.section ? opt.section + '.' : '') + nk\n    const { whitespace } = opt\n    const child = encode(obj[k], {\n      section,\n      whitespace,\n    })\n    if (out.length && child.length)\n      out += eol\n\n    out += child\n  }\n\n  return out\n}\n\nconst dotSplit = str =>\n  str.replace(/\\1/g, '\\u0002LITERAL\\\\1LITERAL\\u0002')\n    .replace(/\\\\\\./g, '\\u0001')\n    .split(/\\./)\n    .map(part =>\n      part.replace(/\\1/g, '\\\\.')\n        .replace(/\\2LITERAL\\\\1LITERAL\\2/g, '\\u0001'))\n\nconst decode = str => {\n  const out = Object.create(null)\n  let p = out\n  let section = null\n  //          section     |key      = value\n  const re = /^\\[([^\\]]*)\\]$|^([^=]+)(=(.*))?$/i\n  const lines = str.split(/[\\r\\n]+/g)\n\n  for (const line of lines) {\n    if (!line || line.match(/^\\s*[;#]/))\n      continue\n    const match = line.match(re)\n    if (!match)\n      continue\n    if (match[1] !== undefined) {\n      section = unsafe(match[1])\n      if (section === '__proto__') {\n        // not allowed\n        // keep parsing the section, but don't attach it.\n        p = Object.create(null)\n        continue\n      }\n      p = out[section] = out[section] || Object.create(null)\n      continue\n    }\n    const keyRaw = unsafe(match[2])\n    const isArray = keyRaw.length > 2 && keyRaw.slice(-2) === '[]'\n    const key = isArray ? keyRaw.slice(0, -2) : keyRaw\n    if (key === '__proto__')\n      continue\n    const valueRaw = match[3] ? unsafe(match[4]) : true\n    const value = valueRaw === 'true' ||\n      valueRaw === 'false' ||\n      valueRaw === 'null' ? JSON.parse(valueRaw)\n      : valueRaw\n\n    // Convert keys with '[]' suffix to an array\n    if (isArray) {\n      if (!hasOwnProperty.call(p, key))\n        p[key] = []\n      else if (!Array.isArray(p[key]))\n        p[key] = [p[key]]\n    }\n\n    // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n    if (Array.isArray(p[key]))\n      p[key].push(value)\n    else\n      p[key] = value\n  }\n\n  // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n  const remove = []\n  for (const k of Object.keys(out)) {\n    if (!hasOwnProperty.call(out, k) ||\n        typeof out[k] !== 'object' ||\n        Array.isArray(out[k]))\n      continue\n\n    // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n    const parts = dotSplit(k)\n    let p = out\n    const l = parts.pop()\n    const nl = l.replace(/\\\\\\./g, '.')\n    for (const part of parts) {\n      if (part === '__proto__')\n        continue\n      if (!hasOwnProperty.call(p, part) || typeof p[part] !== 'object')\n        p[part] = Object.create(null)\n      p = p[part]\n    }\n    if (p === out && nl === l)\n      continue\n\n    p[nl] = out[k]\n    remove.push(k)\n  }\n  for (const del of remove)\n    delete out[del]\n\n  return out\n}\n\nconst isQuoted = val =>\n  (val.charAt(0) === '\"' && val.slice(-1) === '\"') ||\n    (val.charAt(0) === \"'\" && val.slice(-1) === \"'\")\n\nconst safe = val =>\n  (typeof val !== 'string' ||\n    val.match(/[=\\r\\n]/) ||\n    val.match(/^\\[/) ||\n    (val.length > 1 &&\n     isQuoted(val)) ||\n    val !== val.trim())\n    ? JSON.stringify(val)\n    : val.replace(/;/g, '\\\\;').replace(/#/g, '\\\\#')\n\nconst unsafe = (val, doUnesc) => {\n  val = (val || '').trim()\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\")\n      val = val.substr(1, val.length - 2)\n\n    try {\n      val = JSON.parse(val)\n    } catch (_) {}\n  } else {\n    // walk the val to find the first not-escaped ; character\n    let esc = false\n    let unesc = ''\n    for (let i = 0, l = val.length; i < l; i++) {\n      const c = val.charAt(i)\n      if (esc) {\n        if ('\\\\;#'.indexOf(c) !== -1)\n          unesc += c\n        else\n          unesc += '\\\\' + c\n\n        esc = false\n      } else if (';#'.indexOf(c) !== -1)\n        break\n      else if (c === '\\\\')\n        esc = true\n      else\n        unesc += c\n    }\n    if (esc)\n      unesc += '\\\\'\n\n    return unesc.trim()\n  }\n  return val\n}\n\nmodule.exports = {\n  parse: decode,\n  decode,\n  stringify: encode,\n  encode,\n  safe,\n  unsafe,\n}\n"],"mappings":"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"}},"mtime":1674865304234},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf\\\\stores\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf\\\\stores\\\\memory.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"\"use strict\";\n\n/*\n * memory.js: Simple memory storage engine for nconf configuration(s)\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar common = require('../common');\n\n//\n// ### function Memory (options)\n// #### @options {Object} Options for this instance\n// Constructor function for the Memory nconf store which maintains\n// a nested json structure based on key delimiters `:`.\n//\n// e.g. `my:nested:key` ==> `{ my: { nested: { key: } } }`\n//\nvar Memory = exports.Memory = function (options) {\n  options = options || {};\n  this.type = 'memory';\n  this.store = {};\n  this.mtimes = {};\n  this.readOnly = false;\n  this.loadFrom = options.loadFrom || null;\n  this.logicalSeparator = options.logicalSeparator || ':';\n  this.parseValues = options.parseValues || false;\n  if (this.loadFrom) {\n    this.store = common.loadFilesSync(this.loadFrom);\n  }\n};\n\n//\n// ### function get (key)\n// #### @key {string} Key to retrieve for this instance.\n// Retrieves the value for the specified key (if any).\n//\nMemory.prototype.get = function (key) {\n  var target = this.store,\n    path = common.path(key, this.logicalSeparator);\n\n  //\n  // Scope into the object to get the appropriate nested context\n  //\n  while (path.length > 0) {\n    key = path.shift();\n    if (target && typeof target !== 'string' && Object.hasOwnProperty.call(target, key)) {\n      target = target[key];\n      continue;\n    }\n    return undefined;\n  }\n  return target;\n};\n\n//\n// ### function set (key, value)\n// #### @key {string} Key to set in this instance\n// #### @value {literal|Object} Value for the specified key\n// Sets the `value` for the specified `key` in this instance.\n//\nMemory.prototype.set = function (key, value) {\n  if (this.readOnly) {\n    return false;\n  }\n  var target = this.store,\n    path = common.path(key, this.logicalSeparator);\n  if (path.length === 0) {\n    //\n    // Root must be an object\n    //\n    if (!value || typeof value !== 'object') {\n      return false;\n    } else {\n      this.reset();\n      this.store = value;\n      return true;\n    }\n  }\n\n  //\n  // Update the `mtime` (modified time) of the key\n  //\n  this.mtimes[key] = Date.now();\n\n  //\n  // Scope into the object to get the appropriate nested context\n  //\n  while (path.length > 1) {\n    key = path.shift();\n    if (!target[key] || typeof target[key] !== 'object' || !Object.hasOwnProperty.call(target, key)) {\n      target[key] = {};\n    }\n    target = target[key];\n  }\n\n  // Set the specified value in the nested JSON structure\n  key = path.shift();\n  if (this.parseValues) {\n    value = common.parseValues.call(common, value);\n  }\n  target[key] = value;\n  return true;\n};\n\n//\n// ### function clear (key)\n// #### @key {string} Key to remove from this instance\n// Removes the value for the specified `key` from this instance.\n//\nMemory.prototype.clear = function (key) {\n  if (this.readOnly) {\n    return false;\n  }\n  var target = this.store,\n    value = target,\n    path = common.path(key, this.logicalSeparator);\n\n  //\n  // Remove the key from the set of `mtimes` (modified times)\n  //\n  delete this.mtimes[key];\n\n  //\n  // Scope into the object to get the appropriate nested context\n  //\n  for (var i = 0; i < path.length - 1; i++) {\n    key = path[i];\n    value = target[key];\n    if (typeof value !== 'function' && typeof value !== 'object') {\n      return false;\n    }\n    target = value;\n  }\n\n  // Delete the key from the nested JSON structure\n  key = path[i];\n  delete target[key];\n  return true;\n};\n\n//\n// ### function merge (key, value)\n// #### @key {string} Key to merge the value into\n// #### @value {literal|Object} Value to merge into the key\n// Merges the properties in `value` into the existing object value\n// at `key`. If the existing value `key` is not an Object, it will be\n// completely overwritten.\n//\nMemory.prototype.merge = function (key, value) {\n  if (this.readOnly) {\n    return false;\n  }\n\n  //\n  // If the key is not an `Object` or is an `Array`,\n  // then simply set it. Merging is for Objects.\n  //\n  if (typeof value !== 'object' || Array.isArray(value) || value === null) {\n    return this.set(key, value);\n  }\n  var self = this,\n    target = this.store,\n    path = common.path(key, this.logicalSeparator),\n    fullKey = key;\n\n  //\n  // Update the `mtime` (modified time) of the key\n  //\n  this.mtimes[key] = Date.now();\n\n  //\n  // Scope into the object to get the appropriate nested context\n  //\n  while (path.length > 1) {\n    key = path.shift();\n    if (!target[key]) {\n      target[key] = {};\n    }\n    target = target[key];\n  }\n\n  // Set the specified value in the nested JSON structure\n  key = path.shift();\n\n  //\n  // If the current value at the key target is not an `Object`,\n  // or is an `Array` then simply override it because the new value\n  // is an Object.\n  //\n  if (typeof target[key] !== 'object' || Array.isArray(target[key])) {\n    target[key] = value;\n    return true;\n  }\n  return Object.keys(value).every(function (nested) {\n    return self.merge(common.keyed(self.logicalSeparator, fullKey, nested), value[nested]);\n  });\n};\n\n//\n// ### function reset (callback)\n// Clears all keys associated with this instance.\n//\nMemory.prototype.reset = function () {\n  if (this.readOnly) {\n    return false;\n  }\n  this.mtimes = {};\n  this.store = {};\n  return true;\n};\n\n//\n// ### function loadSync\n// Returns the store managed by this instance\n//\nMemory.prototype.loadSync = function () {\n  return this.store || {};\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjb21tb24iLCJyZXF1aXJlIiwiTWVtb3J5IiwiZXhwb3J0cyIsIm9wdGlvbnMiLCJ0eXBlIiwic3RvcmUiLCJtdGltZXMiLCJyZWFkT25seSIsImxvYWRGcm9tIiwibG9naWNhbFNlcGFyYXRvciIsInBhcnNlVmFsdWVzIiwibG9hZEZpbGVzU3luYyIsInByb3RvdHlwZSIsImdldCIsImtleSIsInRhcmdldCIsInBhdGgiLCJsZW5ndGgiLCJzaGlmdCIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInVuZGVmaW5lZCIsInNldCIsInZhbHVlIiwicmVzZXQiLCJEYXRlIiwibm93IiwiY2xlYXIiLCJpIiwibWVyZ2UiLCJBcnJheSIsImlzQXJyYXkiLCJzZWxmIiwiZnVsbEtleSIsImtleXMiLCJldmVyeSIsIm5lc3RlZCIsImtleWVkIiwibG9hZFN5bmMiXSwic291cmNlUm9vdCI6IkM6XFxjb2RlXFxGbHVpZEZyYW1ld29yazVcXG5vZGVfbW9kdWxlc1xcLnBucG1cXG5jb25mQDAuMTIuMFxcbm9kZV9tb2R1bGVzXFxuY29uZlxcbGliXFxuY29uZlxcc3RvcmVzXFwiLCJzb3VyY2VzIjpbIm1lbW9yeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogbWVtb3J5LmpzOiBTaW1wbGUgbWVtb3J5IHN0b3JhZ2UgZW5naW5lIGZvciBuY29uZiBjb25maWd1cmF0aW9uKHMpXG4gKlxuICogKEMpIDIwMTEsIENoYXJsaWUgUm9iYmlucyBhbmQgdGhlIENvbnRyaWJ1dG9ycy5cbiAqXG4gKi9cblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuXG4vL1xuLy8gIyMjIGZ1bmN0aW9uIE1lbW9yeSAob3B0aW9ucylcbi8vICMjIyMgQG9wdGlvbnMge09iamVjdH0gT3B0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZVxuLy8gQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBNZW1vcnkgbmNvbmYgc3RvcmUgd2hpY2ggbWFpbnRhaW5zXG4vLyBhIG5lc3RlZCBqc29uIHN0cnVjdHVyZSBiYXNlZCBvbiBrZXkgZGVsaW1pdGVycyBgOmAuXG4vL1xuLy8gZS5nLiBgbXk6bmVzdGVkOmtleWAgPT0+IGB7IG15OiB7IG5lc3RlZDogeyBrZXk6IH0gfSB9YFxuLy9cbnZhciBNZW1vcnkgPSBleHBvcnRzLk1lbW9yeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgICAgICAgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnR5cGUgICAgID0gJ21lbW9yeSc7XG4gIHRoaXMuc3RvcmUgICAgPSB7fTtcbiAgdGhpcy5tdGltZXMgICA9IHt9O1xuICB0aGlzLnJlYWRPbmx5ID0gZmFsc2U7XG4gIHRoaXMubG9hZEZyb20gPSBvcHRpb25zLmxvYWRGcm9tIHx8IG51bGw7XG4gIHRoaXMubG9naWNhbFNlcGFyYXRvciA9IG9wdGlvbnMubG9naWNhbFNlcGFyYXRvciB8fCAnOic7XG4gIHRoaXMucGFyc2VWYWx1ZXMgPSBvcHRpb25zLnBhcnNlVmFsdWVzIHx8IGZhbHNlO1xuXG4gIGlmICh0aGlzLmxvYWRGcm9tKSB7XG4gICAgdGhpcy5zdG9yZSA9IGNvbW1vbi5sb2FkRmlsZXNTeW5jKHRoaXMubG9hZEZyb20pO1xuICB9XG59O1xuXG4vL1xuLy8gIyMjIGZ1bmN0aW9uIGdldCAoa2V5KVxuLy8gIyMjIyBAa2V5IHtzdHJpbmd9IEtleSB0byByZXRyaWV2ZSBmb3IgdGhpcyBpbnN0YW5jZS5cbi8vIFJldHJpZXZlcyB0aGUgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQga2V5IChpZiBhbnkpLlxuLy9cbk1lbW9yeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICB2YXIgdGFyZ2V0ID0gdGhpcy5zdG9yZSxcbiAgICAgIHBhdGggICA9IGNvbW1vbi5wYXRoKGtleSwgdGhpcy5sb2dpY2FsU2VwYXJhdG9yKTtcblxuICAvL1xuICAvLyBTY29wZSBpbnRvIHRoZSBvYmplY3QgdG8gZ2V0IHRoZSBhcHByb3ByaWF0ZSBuZXN0ZWQgY29udGV4dFxuICAvL1xuICB3aGlsZSAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAga2V5ID0gcGF0aC5zaGlmdCgpO1xuICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXRba2V5XTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gc2V0IChrZXksIHZhbHVlKVxuLy8gIyMjIyBAa2V5IHtzdHJpbmd9IEtleSB0byBzZXQgaW4gdGhpcyBpbnN0YW5jZVxuLy8gIyMjIyBAdmFsdWUge2xpdGVyYWx8T2JqZWN0fSBWYWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBrZXlcbi8vIFNldHMgdGhlIGB2YWx1ZWAgZm9yIHRoZSBzcGVjaWZpZWQgYGtleWAgaW4gdGhpcyBpbnN0YW5jZS5cbi8vXG5NZW1vcnkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIGlmICh0aGlzLnJlYWRPbmx5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHRoaXMuc3RvcmUsXG4gICAgICBwYXRoICAgPSBjb21tb24ucGF0aChrZXksIHRoaXMubG9naWNhbFNlcGFyYXRvcik7XG5cbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgLy9cbiAgICAvLyBSb290IG11c3QgYmUgYW4gb2JqZWN0XG4gICAgLy9cbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB0aGlzLnN0b3JlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBVcGRhdGUgdGhlIGBtdGltZWAgKG1vZGlmaWVkIHRpbWUpIG9mIHRoZSBrZXlcbiAgLy9cbiAgdGhpcy5tdGltZXNba2V5XSA9IERhdGUubm93KCk7XG5cbiAgLy9cbiAgLy8gU2NvcGUgaW50byB0aGUgb2JqZWN0IHRvIGdldCB0aGUgYXBwcm9wcmlhdGUgbmVzdGVkIGNvbnRleHRcbiAgLy9cbiAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMSkge1xuICAgIGtleSA9IHBhdGguc2hpZnQoKTtcbiAgICBpZiAoIXRhcmdldFtrZXldIHx8IHR5cGVvZiB0YXJnZXRba2V5XSAhPT0gJ29iamVjdCcgfHwgIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSB7fTtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSB0YXJnZXRba2V5XTtcbiAgfVxuXG4gIC8vIFNldCB0aGUgc3BlY2lmaWVkIHZhbHVlIGluIHRoZSBuZXN0ZWQgSlNPTiBzdHJ1Y3R1cmVcbiAga2V5ID0gcGF0aC5zaGlmdCgpO1xuICBpZiAodGhpcy5wYXJzZVZhbHVlcykge1xuICAgIHZhbHVlID0gY29tbW9uLnBhcnNlVmFsdWVzLmNhbGwoY29tbW9uLCB2YWx1ZSk7XG4gIH1cbiAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vL1xuLy8gIyMjIGZ1bmN0aW9uIGNsZWFyIChrZXkpXG4vLyAjIyMjIEBrZXkge3N0cmluZ30gS2V5IHRvIHJlbW92ZSBmcm9tIHRoaXMgaW5zdGFuY2Vcbi8vIFJlbW92ZXMgdGhlIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIGBrZXlgIGZyb20gdGhpcyBpbnN0YW5jZS5cbi8vXG5NZW1vcnkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAodGhpcy5yZWFkT25seSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB0YXJnZXQgPSB0aGlzLnN0b3JlLFxuICAgICAgdmFsdWUgID0gdGFyZ2V0LFxuICAgICAgcGF0aCAgID0gY29tbW9uLnBhdGgoa2V5LCB0aGlzLmxvZ2ljYWxTZXBhcmF0b3IpO1xuXG4gIC8vXG4gIC8vIFJlbW92ZSB0aGUga2V5IGZyb20gdGhlIHNldCBvZiBgbXRpbWVzYCAobW9kaWZpZWQgdGltZXMpXG4gIC8vXG4gIGRlbGV0ZSB0aGlzLm10aW1lc1trZXldO1xuXG4gIC8vXG4gIC8vIFNjb3BlIGludG8gdGhlIG9iamVjdCB0byBnZXQgdGhlIGFwcHJvcHJpYXRlIG5lc3RlZCBjb250ZXh0XG4gIC8vXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBrZXkgPSBwYXRoW2ldO1xuICAgIHZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRhcmdldCA9IHZhbHVlO1xuICB9XG5cbiAgLy8gRGVsZXRlIHRoZSBrZXkgZnJvbSB0aGUgbmVzdGVkIEpTT04gc3RydWN0dXJlXG4gIGtleSA9IHBhdGhbaV07XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vL1xuLy8gIyMjIGZ1bmN0aW9uIG1lcmdlIChrZXksIHZhbHVlKVxuLy8gIyMjIyBAa2V5IHtzdHJpbmd9IEtleSB0byBtZXJnZSB0aGUgdmFsdWUgaW50b1xuLy8gIyMjIyBAdmFsdWUge2xpdGVyYWx8T2JqZWN0fSBWYWx1ZSB0byBtZXJnZSBpbnRvIHRoZSBrZXlcbi8vIE1lcmdlcyB0aGUgcHJvcGVydGllcyBpbiBgdmFsdWVgIGludG8gdGhlIGV4aXN0aW5nIG9iamVjdCB2YWx1ZVxuLy8gYXQgYGtleWAuIElmIHRoZSBleGlzdGluZyB2YWx1ZSBga2V5YCBpcyBub3QgYW4gT2JqZWN0LCBpdCB3aWxsIGJlXG4vLyBjb21wbGV0ZWx5IG92ZXJ3cml0dGVuLlxuLy9cbk1lbW9yeS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICBpZiAodGhpcy5yZWFkT25seSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vXG4gIC8vIElmIHRoZSBrZXkgaXMgbm90IGFuIGBPYmplY3RgIG9yIGlzIGFuIGBBcnJheWAsXG4gIC8vIHRoZW4gc2ltcGx5IHNldCBpdC4gTWVyZ2luZyBpcyBmb3IgT2JqZWN0cy5cbiAgLy9cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gIH1cblxuICB2YXIgc2VsZiAgICA9IHRoaXMsXG4gICAgICB0YXJnZXQgID0gdGhpcy5zdG9yZSxcbiAgICAgIHBhdGggICAgPSBjb21tb24ucGF0aChrZXksIHRoaXMubG9naWNhbFNlcGFyYXRvciksXG4gICAgICBmdWxsS2V5ID0ga2V5O1xuXG4gIC8vXG4gIC8vIFVwZGF0ZSB0aGUgYG10aW1lYCAobW9kaWZpZWQgdGltZSkgb2YgdGhlIGtleVxuICAvL1xuICB0aGlzLm10aW1lc1trZXldID0gRGF0ZS5ub3coKTtcblxuICAvL1xuICAvLyBTY29wZSBpbnRvIHRoZSBvYmplY3QgdG8gZ2V0IHRoZSBhcHByb3ByaWF0ZSBuZXN0ZWQgY29udGV4dFxuICAvL1xuICB3aGlsZSAocGF0aC5sZW5ndGggPiAxKSB7XG4gICAga2V5ID0gcGF0aC5zaGlmdCgpO1xuICAgIGlmICghdGFyZ2V0W2tleV0pIHtcbiAgICAgIHRhcmdldFtrZXldID0ge307XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0W2tleV07XG4gIH1cblxuICAvLyBTZXQgdGhlIHNwZWNpZmllZCB2YWx1ZSBpbiB0aGUgbmVzdGVkIEpTT04gc3RydWN0dXJlXG4gIGtleSA9IHBhdGguc2hpZnQoKTtcblxuICAvL1xuICAvLyBJZiB0aGUgY3VycmVudCB2YWx1ZSBhdCB0aGUga2V5IHRhcmdldCBpcyBub3QgYW4gYE9iamVjdGAsXG4gIC8vIG9yIGlzIGFuIGBBcnJheWAgdGhlbiBzaW1wbHkgb3ZlcnJpZGUgaXQgYmVjYXVzZSB0aGUgbmV3IHZhbHVlXG4gIC8vIGlzIGFuIE9iamVjdC5cbiAgLy9cbiAgaWYgKHR5cGVvZiB0YXJnZXRba2V5XSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheSh0YXJnZXRba2V5XSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5ldmVyeShmdW5jdGlvbiAobmVzdGVkKSB7XG4gICAgcmV0dXJuIHNlbGYubWVyZ2UoY29tbW9uLmtleWVkKHNlbGYubG9naWNhbFNlcGFyYXRvciwgZnVsbEtleSwgbmVzdGVkKSwgdmFsdWVbbmVzdGVkXSk7XG4gIH0pO1xufTtcblxuLy9cbi8vICMjIyBmdW5jdGlvbiByZXNldCAoY2FsbGJhY2spXG4vLyBDbGVhcnMgYWxsIGtleXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4vL1xuTWVtb3J5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucmVhZE9ubHkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aGlzLm10aW1lcyA9IHt9O1xuICB0aGlzLnN0b3JlICA9IHt9O1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gbG9hZFN5bmNcbi8vIFJldHVybnMgdGhlIHN0b3JlIG1hbmFnZWQgYnkgdGhpcyBpbnN0YW5jZVxuLy9cbk1lbW9yeS5wcm90b3R5cGUubG9hZFN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnN0b3JlIHx8IHt9O1xufTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7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","map":{"version":3,"names":["common","require","Memory","exports","options","type","store","mtimes","readOnly","loadFrom","logicalSeparator","parseValues","loadFilesSync","prototype","get","key","target","path","length","shift","Object","hasOwnProperty","call","undefined","set","value","reset","Date","now","clear","i","merge","Array","isArray","self","fullKey","keys","every","nested","keyed","loadSync"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\nconf@0.12.0\\node_modules\\nconf\\lib\\nconf\\stores\\","sources":["memory.js"],"sourcesContent":["/*\n * memory.js: Simple memory storage engine for nconf configuration(s)\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar common = require('../common');\n\n//\n// ### function Memory (options)\n// #### @options {Object} Options for this instance\n// Constructor function for the Memory nconf store which maintains\n// a nested json structure based on key delimiters `:`.\n//\n// e.g. `my:nested:key` ==> `{ my: { nested: { key: } } }`\n//\nvar Memory = exports.Memory = function (options) {\n  options       = options || {};\n  this.type     = 'memory';\n  this.store    = {};\n  this.mtimes   = {};\n  this.readOnly = false;\n  this.loadFrom = options.loadFrom || null;\n  this.logicalSeparator = options.logicalSeparator || ':';\n  this.parseValues = options.parseValues || false;\n\n  if (this.loadFrom) {\n    this.store = common.loadFilesSync(this.loadFrom);\n  }\n};\n\n//\n// ### function get (key)\n// #### @key {string} Key to retrieve for this instance.\n// Retrieves the value for the specified key (if any).\n//\nMemory.prototype.get = function (key) {\n  var target = this.store,\n      path   = common.path(key, this.logicalSeparator);\n\n  //\n  // Scope into the object to get the appropriate nested context\n  //\n  while (path.length > 0) {\n    key = path.shift();\n    if (target && typeof target !== 'string' && Object.hasOwnProperty.call(target, key)) {\n      target = target[key];\n      continue;\n    }\n    return undefined;\n  }\n\n  return target;\n};\n\n//\n// ### function set (key, value)\n// #### @key {string} Key to set in this instance\n// #### @value {literal|Object} Value for the specified key\n// Sets the `value` for the specified `key` in this instance.\n//\nMemory.prototype.set = function (key, value) {\n  if (this.readOnly) {\n    return false;\n  }\n\n  var target = this.store,\n      path   = common.path(key, this.logicalSeparator);\n\n  if (path.length === 0) {\n    //\n    // Root must be an object\n    //\n    if (!value || typeof value !== 'object') {\n      return false;\n    }\n    else {\n      this.reset();\n      this.store = value;\n      return true;\n    }\n  }\n\n  //\n  // Update the `mtime` (modified time) of the key\n  //\n  this.mtimes[key] = Date.now();\n\n  //\n  // Scope into the object to get the appropriate nested context\n  //\n  while (path.length > 1) {\n    key = path.shift();\n    if (!target[key] || typeof target[key] !== 'object' || !Object.hasOwnProperty.call(target, key)) {\n      target[key] = {};\n    }\n\n    target = target[key];\n  }\n\n  // Set the specified value in the nested JSON structure\n  key = path.shift();\n  if (this.parseValues) {\n    value = common.parseValues.call(common, value);\n  }\n  target[key] = value;\n  return true;\n};\n\n//\n// ### function clear (key)\n// #### @key {string} Key to remove from this instance\n// Removes the value for the specified `key` from this instance.\n//\nMemory.prototype.clear = function (key) {\n  if (this.readOnly) {\n    return false;\n  }\n\n  var target = this.store,\n      value  = target,\n      path   = common.path(key, this.logicalSeparator);\n\n  //\n  // Remove the key from the set of `mtimes` (modified times)\n  //\n  delete this.mtimes[key];\n\n  //\n  // Scope into the object to get the appropriate nested context\n  //\n  for (var i = 0; i < path.length - 1; i++) {\n    key = path[i];\n    value = target[key];\n    if (typeof value !== 'function' && typeof value !== 'object') {\n      return false;\n    }\n    target = value;\n  }\n\n  // Delete the key from the nested JSON structure\n  key = path[i];\n  delete target[key];\n  return true;\n};\n\n//\n// ### function merge (key, value)\n// #### @key {string} Key to merge the value into\n// #### @value {literal|Object} Value to merge into the key\n// Merges the properties in `value` into the existing object value\n// at `key`. If the existing value `key` is not an Object, it will be\n// completely overwritten.\n//\nMemory.prototype.merge = function (key, value) {\n  if (this.readOnly) {\n    return false;\n  }\n\n  //\n  // If the key is not an `Object` or is an `Array`,\n  // then simply set it. Merging is for Objects.\n  //\n  if (typeof value !== 'object' || Array.isArray(value) || value === null) {\n    return this.set(key, value);\n  }\n\n  var self    = this,\n      target  = this.store,\n      path    = common.path(key, this.logicalSeparator),\n      fullKey = key;\n\n  //\n  // Update the `mtime` (modified time) of the key\n  //\n  this.mtimes[key] = Date.now();\n\n  //\n  // Scope into the object to get the appropriate nested context\n  //\n  while (path.length > 1) {\n    key = path.shift();\n    if (!target[key]) {\n      target[key] = {};\n    }\n\n    target = target[key];\n  }\n\n  // Set the specified value in the nested JSON structure\n  key = path.shift();\n\n  //\n  // If the current value at the key target is not an `Object`,\n  // or is an `Array` then simply override it because the new value\n  // is an Object.\n  //\n  if (typeof target[key] !== 'object' || Array.isArray(target[key])) {\n    target[key] = value;\n    return true;\n  }\n\n  return Object.keys(value).every(function (nested) {\n    return self.merge(common.keyed(self.logicalSeparator, fullKey, nested), value[nested]);\n  });\n};\n\n//\n// ### function reset (callback)\n// Clears all keys associated with this instance.\n//\nMemory.prototype.reset = function () {\n  if (this.readOnly) {\n    return false;\n  }\n\n  this.mtimes = {};\n  this.store  = {};\n  return true;\n};\n\n//\n// ### function loadSync\n// Returns the store managed by this instance\n//\nMemory.prototype.loadSync = function () {\n  return this.store || {};\n};\n"],"mappings":"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"}},"mtime":1674865250537},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf\\\\provider.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"\"use strict\";\n\n/*\n * provider.js: Abstraction providing an interface into pluggable configuration storage.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar async = require('async'),\n  common = require('./common');\n\n//\n// ### function Provider (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Provider object responsible\n// for exposing the pluggable storage features of `nconf`.\n//\nvar Provider = exports.Provider = function (options) {\n  //\n  // Setup default options for working with `stores`,\n  // `overrides`, `process.env` and `process.argv`.\n  //\n  options = options || {};\n  this.stores = {};\n  this.sources = [];\n  this.init(options);\n};\n\n//\n// Define wrapper functions for using basic stores\n// in this instance\n//\n\n['argv', 'env'].forEach(function (type) {\n  Provider.prototype[type] = function () {\n    var args = [type].concat(Array.prototype.slice.call(arguments));\n    return this.add.apply(this, args);\n  };\n});\n\n//\n// ### function file (key, options)\n// #### @key {string|Object} Fully qualified options, name of file store, or path.\n// #### @path {string|Object} **Optional** Full qualified options, or path.\n// Adds a new `File` store to this instance. Accepts the following options\n//\n//    nconf.file({ file: '.jitsuconf', dir: process.env.HOME, search: true });\n//    nconf.file('path/to/config/file');\n//    nconf.file('userconfig', 'path/to/config/file');\n//    nconf.file('userconfig', { file: '.jitsuconf', search: true });\n//\nProvider.prototype.file = function (key, options) {\n  if (arguments.length == 1) {\n    options = typeof key === 'string' ? {\n      file: key\n    } : key;\n    key = 'file';\n  } else {\n    options = typeof options === 'string' ? {\n      file: options\n    } : options;\n  }\n  options.type = 'file';\n  return this.add(key, options);\n};\n\n//\n// Define wrapper functions for using\n// overrides and defaults\n//\n['defaults', 'overrides'].forEach(function (type) {\n  Provider.prototype[type] = function (options) {\n    options = options || {};\n    if (!options.type) {\n      options.type = 'literal';\n    }\n    return this.add(type, options);\n  };\n});\n\n//\n// ### function use (name, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Adds (or replaces) a new store with the specified `name`\n// and `options`. If `options.type` is not set, then `name`\n// will be used instead:\n//\n//    provider.use('file');\n//    provider.use('file', { type: 'file', filename: '/path/to/userconf' })\n//\nProvider.prototype.use = function (name, options) {\n  options = options || {};\n  function sameOptions(store) {\n    return Object.keys(options).every(function (key) {\n      return options[key] === store[key];\n    });\n  }\n  var store = this.stores[name],\n    update = store && !sameOptions(store);\n  if (!store || update) {\n    if (update) {\n      this.remove(name);\n    }\n    this.add(name, options);\n  }\n  return this;\n};\n\n//\n// ### function add (name, options)\n// #### @name {string} Name of the store to add to this instance\n// #### @options {Object} Options for the store to create\n// Adds a new store with the specified `name` and `options`. If `options.type`\n// is not set, then `name` will be used instead:\n//\n//    provider.add('memory');\n//    provider.add('userconf', { type: 'file', filename: '/path/to/userconf' })\n//\nProvider.prototype.add = function (name, options, usage) {\n  options = options || {};\n  var type = options.type || name;\n  if (!require('../nconf')[common.capitalize(type)]) {\n    throw new Error('Cannot add store with unknown type: ' + type);\n  }\n  this.stores[name] = this.create(type, options, usage);\n  if (this.stores[name].loadSync) {\n    this.stores[name].loadSync();\n  }\n  return this;\n};\n\n//\n// ### function remove (name)\n// #### @name {string} Name of the store to remove from this instance\n// Removes a store with the specified `name` from this instance. Users\n// are allowed to pass in a type argument (e.g. `memory`) as name if\n// this was used in the call to `.add()`.\n//\nProvider.prototype.remove = function (name) {\n  delete this.stores[name];\n  return this;\n};\n\n//\n// ### function create (type, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Creates a store of the specified `type` using the\n// specified `options`.\n//\nProvider.prototype.create = function (type, options, usage) {\n  return new (require('../nconf')[common.capitalize(type.toLowerCase())])(options, usage);\n};\n\n//\n// ### function init (options)\n// #### @options {Object} Options to initialize this instance with.\n// Initializes this instance with additional `stores` or `sources` in the\n// `options` supplied.\n//\nProvider.prototype.init = function (options) {\n  var self = this;\n\n  //\n  // Add any stores passed in through the options\n  // to this instance.\n  //\n  if (options.type) {\n    this.add(options.type, options);\n  } else if (options.store) {\n    this.add(options.store.name || options.store.type, options.store);\n  } else if (options.stores) {\n    Object.keys(options.stores).forEach(function (name) {\n      var store = options.stores[name];\n      self.add(store.name || name || store.type, store);\n    });\n  }\n\n  //\n  // Add any read-only sources to this instance\n  //\n  if (options.source) {\n    this.sources.push(this.create(options.source.type || options.source.name, options.source));\n  } else if (options.sources) {\n    Object.keys(options.sources).forEach(function (name) {\n      var source = options.sources[name];\n      self.sources.push(self.create(source.type || source.name || name, source));\n    });\n  }\n};\n\n//\n// ### function get (key, callback)\n// #### @key {string} Key to retrieve for this instance.\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the value for the specified key (if any).\n//\nProvider.prototype.get = function (key, callback) {\n  if (typeof key === 'function') {\n    // Allow a * key call to be made\n    callback = key;\n    key = null;\n  }\n\n  //\n  // If there is no callback we can short-circuit into the default\n  // logic for traversing stores.\n  //\n  if (!callback) {\n    return this._execute('get', 1, key, callback);\n  }\n\n  //\n  // Otherwise the asynchronous, hierarchical `get` is\n  // slightly more complicated because we do not need to traverse\n  // the entire set of stores, but up until there is a defined value.\n  //\n  var current = 0,\n    names = Object.keys(this.stores),\n    self = this,\n    response,\n    mergeObjs = [];\n  async.whilst(function (cb) {\n    cb(null, typeof response === 'undefined' && current < names.length);\n  }, function (next) {\n    var store = self.stores[names[current]];\n    current++;\n    if (store.get.length >= 2) {\n      return store.get(key, function (err, value) {\n        if (err) {\n          return next(err);\n        }\n        response = value;\n\n        // Merge objects if necessary\n        if (response && typeof response === 'object' && !Array.isArray(response)) {\n          mergeObjs.push(response);\n          response = undefined;\n        }\n        next();\n      });\n    }\n    response = store.get(key);\n\n    // Merge objects if necessary\n    if (response && typeof response === 'object' && !Array.isArray(response)) {\n      mergeObjs.push(response);\n      response = undefined;\n    }\n    next();\n  }, function (err) {\n    if (!err && mergeObjs.length) {\n      response = common.merge(mergeObjs.reverse());\n    }\n    return err ? callback(err) : callback(null, response);\n  });\n};\n\n//\n// ### function any (keys, callback)\n// #### @keys {array|string...} Array of keys to query, or a variable list of strings\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the first truthy value (if any) for the specified list of keys.\n//\nProvider.prototype.any = function (keys, callback) {\n  if (!Array.isArray(keys)) {\n    keys = Array.prototype.slice.call(arguments);\n    if (keys.length > 0 && typeof keys[keys.length - 1] === 'function') {\n      callback = keys.pop();\n    } else {\n      callback = null;\n    }\n  }\n\n  //\n  // If there is no callback, use the short-circuited \"get\"\n  // on each key in turn.\n  //\n  if (!callback) {\n    var val;\n    for (var i = 0; i < keys.length; ++i) {\n      val = this._execute('get', 1, keys[i], callback);\n      if (val) {\n        return val;\n      }\n    }\n    return null;\n  }\n  var keyIndex = 0,\n    result,\n    self = this;\n  async.whilst(function (cb) {\n    cb(null, !result && keyIndex < keys.length);\n  }, function (next) {\n    var key = keys[keyIndex];\n    keyIndex++;\n    self.get(key, function (err, v) {\n      if (err) {\n        next(err);\n      } else {\n        result = v;\n        next();\n      }\n    });\n  }, function (err) {\n    return err ? callback(err) : callback(null, result);\n  });\n};\n\n//\n// ### function set (key, value, callback)\n// #### @key {string} Key to set in this instance\n// #### @value {literal|Object} Value for the specified key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Sets the `value` for the specified `key` in this instance.\n//\nProvider.prototype.set = function (key, value, callback) {\n  return this._execute('set', 2, key, value, callback);\n};\n\n//\n// ### function required (keys)\n// #### @keys {array} List of keys\n// Throws an error if any of `keys` has no value, otherwise returns `true`\nProvider.prototype.required = function (keys) {\n  if (!Array.isArray(keys)) {\n    throw new Error('Incorrect parameter, array expected');\n  }\n  var missing = [];\n  keys.forEach(function (key) {\n    if (typeof this.get(key) === 'undefined') {\n      missing.push(key);\n    }\n  }, this);\n  if (missing.length) {\n    throw new Error('Missing required keys: ' + missing.join(', '));\n  } else {\n    return true;\n  }\n};\n\n//\n// ### function reset (callback)\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Clears all keys associated with this instance.\n//\nProvider.prototype.reset = function (callback) {\n  return this._execute('reset', 0, callback);\n};\n\n//\n// ### function clear (key, callback)\n// #### @key {string} Key to remove from this instance\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Removes the value for the specified `key` from this instance.\n//\nProvider.prototype.clear = function (key, callback) {\n  return this._execute('clear', 1, key, callback);\n};\n\n//\n// ### function merge ([key,] value [, callback])\n// #### @key {string} Key to merge the value into\n// #### @value {literal|Object} Value to merge into the key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Merges the properties in `value` into the existing object value at `key`.\n//\n// 1. If the existing value `key` is not an Object, it will be completely overwritten.\n// 2. If `key` is not supplied, then the `value` will be merged into the root.\n//\nProvider.prototype.merge = function () {\n  var self = this,\n    args = Array.prototype.slice.call(arguments),\n    callback = typeof args[args.length - 1] === 'function' && args.pop(),\n    value = args.pop(),\n    key = args.pop();\n  function mergeProperty(prop, next) {\n    return self._execute('merge', 2, prop, value[prop], next);\n  }\n  if (!key) {\n    if (Array.isArray(value) || typeof value !== 'object') {\n      return onError(new Error('Cannot merge non-Object into top-level.'), callback);\n    }\n    return async.forEach(Object.keys(value), mergeProperty, callback || function () {});\n  }\n  return this._execute('merge', 2, key, value, callback);\n};\n\n//\n// ### function load (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an Object representing all keys associated in this instance.\n//\nProvider.prototype.load = function (callback) {\n  var self = this;\n  function getStores() {\n    var stores = Object.keys(self.stores);\n    stores.reverse();\n    return stores.map(function (name) {\n      return self.stores[name];\n    });\n  }\n  function loadStoreSync(store) {\n    if (!store.loadSync) {\n      throw new Error('nconf store ' + store.type + ' has no loadSync() method');\n    }\n    return store.loadSync();\n  }\n  function loadStore(store, next) {\n    if (!store.load && !store.loadSync) {\n      return next(new Error('nconf store ' + store.type + ' has no load() method'));\n    }\n    return store.loadSync ? next(null, store.loadSync()) : store.load(next);\n  }\n  function loadBatch(targets, done) {\n    if (!done) {\n      return common.merge(targets.map(loadStoreSync));\n    }\n    async.map(targets, loadStore, function (err, objs) {\n      return err ? done(err) : done(null, common.merge(objs));\n    });\n  }\n  function mergeSources(data) {\n    //\n    // If `data` was returned then merge it into\n    // the system store.\n    //\n    if (data && typeof data === 'object') {\n      self.use('sources', {\n        type: 'literal',\n        store: data\n      });\n    }\n  }\n  function loadSources() {\n    var sourceHierarchy = self.sources.splice(0);\n    sourceHierarchy.reverse();\n\n    //\n    // If we don't have a callback and the current\n    // store is capable of loading synchronously\n    // then do so.\n    //\n    if (!callback) {\n      mergeSources(loadBatch(sourceHierarchy));\n      return loadBatch(getStores());\n    }\n    loadBatch(sourceHierarchy, function (err, data) {\n      if (err) {\n        return callback(err);\n      }\n      mergeSources(data);\n      return loadBatch(getStores(), callback);\n    });\n  }\n  return self.sources.length ? loadSources() : loadBatch(getStores(), callback);\n};\n\n//\n// ### function save (callback)\n// #### @callback {function} **optional**  Continuation to respond to when\n// complete.\n// Instructs each provider to save.  If a callback is provided, we will attempt\n// asynchronous saves on the providers, falling back to synchronous saves if\n// this isn't possible.  If a provider does not know how to save, it will be\n// ignored.  Returns an object consisting of all of the data which was\n// actually saved.\n//\nProvider.prototype.save = function (value, callback) {\n  if (!callback && typeof value === 'function') {\n    callback = value;\n    value = null;\n  }\n  var self = this,\n    names = Object.keys(this.stores);\n  function saveStoreSync(memo, name) {\n    var store = self.stores[name];\n\n    //\n    // If the `store` doesn't have a `saveSync` method,\n    // just ignore it and continue.\n    //\n    if (store.saveSync) {\n      var ret = store.saveSync();\n      if (typeof ret == 'object' && ret !== null) {\n        memo.push(ret);\n      }\n    }\n    return memo;\n  }\n  function saveStore(memo, name, next) {\n    var store = self.stores[name];\n\n    //\n    // If the `store` doesn't have a `save` or saveSync`\n    // method(s), just ignore it and continue.\n    //\n\n    if (store.save) {\n      return store.save(value, function (err, data) {\n        if (err) {\n          return next(err);\n        }\n        if (typeof data == 'object' && data !== null) {\n          memo.push(data);\n        }\n        next(null, memo);\n      });\n    } else if (store.saveSync) {\n      memo.push(store.saveSync());\n    }\n    next(null, memo);\n  }\n\n  //\n  // If we don't have a callback and the current\n  // store is capable of saving synchronously\n  // then do so.\n  //\n  if (!callback) {\n    return common.merge(names.reduce(saveStoreSync, []));\n  }\n  async.reduce(names, [], saveStore, function (err, objs) {\n    return err ? callback(err) : callback(null, common.merge(objs));\n  });\n};\n\n//\n// ### @private function _execute (action, syncLength, [arguments])\n// #### @action {string} Action to execute on `this.store`.\n// #### @syncLength {number} Function length of the sync version.\n// #### @arguments {Array} Arguments array to apply to the action\n// Executes the specified `action` on all stores for this instance, ensuring a callback supplied\n// to a synchronous store function is still invoked.\n//\nProvider.prototype._execute = function (action, syncLength /* [arguments] */) {\n  var args = Array.prototype.slice.call(arguments, 2),\n    callback = typeof args[args.length - 1] === 'function' && args.pop(),\n    destructive = ['set', 'clear', 'merge', 'reset'].indexOf(action) !== -1,\n    self = this,\n    response,\n    mergeObjs = [],\n    keys = Object.keys(this.stores);\n  function runAction(name, next) {\n    var store = self.stores[name];\n    if (destructive && store.readOnly) {\n      return next();\n    }\n    return store[action].length > syncLength ? store[action].apply(store, args.concat(next)) : next(null, store[action].apply(store, args));\n  }\n  if (callback) {\n    return async.forEach(keys, runAction, function (err) {\n      return err ? callback(err) : callback();\n    });\n  }\n  keys.forEach(function (name) {\n    if (typeof response === 'undefined') {\n      var store = self.stores[name];\n      if (destructive && store.readOnly) {\n        return;\n      }\n      response = store[action].apply(store, args);\n\n      // Merge objects if necessary\n      if (response && action === 'get' && typeof response === 'object' && !Array.isArray(response)) {\n        mergeObjs.push(response);\n        response = undefined;\n      }\n    }\n  });\n  if (mergeObjs.length) {\n    response = common.merge(mergeObjs.reverse());\n  }\n  return response;\n};\n\n//\n// Throw the `err` if a callback is not supplied\n//\nfunction onError(err, callback) {\n  if (callback) {\n    return callback(err);\n  }\n  throw err;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJhc3luYyIsInJlcXVpcmUiLCJjb21tb24iLCJQcm92aWRlciIsImV4cG9ydHMiLCJvcHRpb25zIiwic3RvcmVzIiwic291cmNlcyIsImluaXQiLCJmb3JFYWNoIiwidHlwZSIsInByb3RvdHlwZSIsImFyZ3MiLCJjb25jYXQiLCJBcnJheSIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsImFkZCIsImFwcGx5IiwiZmlsZSIsImtleSIsImxlbmd0aCIsInVzZSIsIm5hbWUiLCJzYW1lT3B0aW9ucyIsInN0b3JlIiwiT2JqZWN0Iiwia2V5cyIsImV2ZXJ5IiwidXBkYXRlIiwicmVtb3ZlIiwidXNhZ2UiLCJjYXBpdGFsaXplIiwiRXJyb3IiLCJjcmVhdGUiLCJsb2FkU3luYyIsInRvTG93ZXJDYXNlIiwic2VsZiIsInNvdXJjZSIsInB1c2giLCJnZXQiLCJjYWxsYmFjayIsIl9leGVjdXRlIiwiY3VycmVudCIsIm5hbWVzIiwicmVzcG9uc2UiLCJtZXJnZU9ianMiLCJ3aGlsc3QiLCJjYiIsIm5leHQiLCJlcnIiLCJ2YWx1ZSIsImlzQXJyYXkiLCJ1bmRlZmluZWQiLCJtZXJnZSIsInJldmVyc2UiLCJhbnkiLCJwb3AiLCJ2YWwiLCJpIiwia2V5SW5kZXgiLCJyZXN1bHQiLCJ2Iiwic2V0IiwicmVxdWlyZWQiLCJtaXNzaW5nIiwiam9pbiIsInJlc2V0IiwiY2xlYXIiLCJtZXJnZVByb3BlcnR5IiwicHJvcCIsIm9uRXJyb3IiLCJsb2FkIiwiZ2V0U3RvcmVzIiwibWFwIiwibG9hZFN0b3JlU3luYyIsImxvYWRTdG9yZSIsImxvYWRCYXRjaCIsInRhcmdldHMiLCJkb25lIiwib2JqcyIsIm1lcmdlU291cmNlcyIsImRhdGEiLCJsb2FkU291cmNlcyIsInNvdXJjZUhpZXJhcmNoeSIsInNwbGljZSIsInNhdmUiLCJzYXZlU3RvcmVTeW5jIiwibWVtbyIsInNhdmVTeW5jIiwicmV0Iiwic2F2ZVN0b3JlIiwicmVkdWNlIiwiYWN0aW9uIiwic3luY0xlbmd0aCIsImRlc3RydWN0aXZlIiwiaW5kZXhPZiIsInJ1bkFjdGlvbiIsInJlYWRPbmx5Il0sInNvdXJjZVJvb3QiOiJDOlxcY29kZVxcRmx1aWRGcmFtZXdvcms1XFxub2RlX21vZHVsZXNcXC5wbnBtXFxuY29uZkAwLjEyLjBcXG5vZGVfbW9kdWxlc1xcbmNvbmZcXGxpYlxcbmNvbmZcXCIsInNvdXJjZXMiOlsicHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIHByb3ZpZGVyLmpzOiBBYnN0cmFjdGlvbiBwcm92aWRpbmcgYW4gaW50ZXJmYWNlIGludG8gcGx1Z2dhYmxlIGNvbmZpZ3VyYXRpb24gc3RvcmFnZS5cbiAqXG4gKiAoQykgMjAxMSwgQ2hhcmxpZSBSb2JiaW5zIGFuZCB0aGUgQ29udHJpYnV0b3JzLlxuICpcbiAqL1xuXG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpLFxuICAgIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gUHJvdmlkZXIgKG9wdGlvbnMpXG4vLyAjIyMjIEBvcHRpb25zIHtPYmplY3R9IE9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4vLyBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIFByb3ZpZGVyIG9iamVjdCByZXNwb25zaWJsZVxuLy8gZm9yIGV4cG9zaW5nIHRoZSBwbHVnZ2FibGUgc3RvcmFnZSBmZWF0dXJlcyBvZiBgbmNvbmZgLlxuLy9cbnZhciBQcm92aWRlciA9IGV4cG9ydHMuUHJvdmlkZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAvL1xuICAvLyBTZXR1cCBkZWZhdWx0IG9wdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBgc3RvcmVzYCxcbiAgLy8gYG92ZXJyaWRlc2AsIGBwcm9jZXNzLmVudmAgYW5kIGBwcm9jZXNzLmFyZ3ZgLlxuICAvL1xuICBvcHRpb25zICAgICAgID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5zdG9yZXMgID0ge307XG4gIHRoaXMuc291cmNlcyA9IFtdO1xuICB0aGlzLmluaXQob3B0aW9ucyk7XG59O1xuXG4vL1xuLy8gRGVmaW5lIHdyYXBwZXIgZnVuY3Rpb25zIGZvciB1c2luZyBiYXNpYyBzdG9yZXNcbi8vIGluIHRoaXMgaW5zdGFuY2Vcbi8vXG5cblsnYXJndicsICdlbnYnXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIFByb3ZpZGVyLnByb3RvdHlwZVt0eXBlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFt0eXBlXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMuYWRkLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufSk7XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gZmlsZSAoa2V5LCBvcHRpb25zKVxuLy8gIyMjIyBAa2V5IHtzdHJpbmd8T2JqZWN0fSBGdWxseSBxdWFsaWZpZWQgb3B0aW9ucywgbmFtZSBvZiBmaWxlIHN0b3JlLCBvciBwYXRoLlxuLy8gIyMjIyBAcGF0aCB7c3RyaW5nfE9iamVjdH0gKipPcHRpb25hbCoqIEZ1bGwgcXVhbGlmaWVkIG9wdGlvbnMsIG9yIHBhdGguXG4vLyBBZGRzIGEgbmV3IGBGaWxlYCBzdG9yZSB0byB0aGlzIGluc3RhbmNlLiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgb3B0aW9uc1xuLy9cbi8vICAgIG5jb25mLmZpbGUoeyBmaWxlOiAnLmppdHN1Y29uZicsIGRpcjogcHJvY2Vzcy5lbnYuSE9NRSwgc2VhcmNoOiB0cnVlIH0pO1xuLy8gICAgbmNvbmYuZmlsZSgncGF0aC90by9jb25maWcvZmlsZScpO1xuLy8gICAgbmNvbmYuZmlsZSgndXNlcmNvbmZpZycsICdwYXRoL3RvL2NvbmZpZy9maWxlJyk7XG4vLyAgICBuY29uZi5maWxlKCd1c2VyY29uZmlnJywgeyBmaWxlOiAnLmppdHN1Y29uZicsIHNlYXJjaDogdHJ1ZSB9KTtcbi8vXG5Qcm92aWRlci5wcm90b3R5cGUuZmlsZSA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgIG9wdGlvbnMgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHsgZmlsZToga2V5IH0gOiBrZXk7XG4gICAga2V5ID0gJ2ZpbGUnO1xuICB9XG4gIGVsc2Uge1xuICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZydcbiAgICAgID8geyBmaWxlOiBvcHRpb25zIH1cbiAgICAgIDogb3B0aW9ucztcbiAgfVxuXG4gIG9wdGlvbnMudHlwZSA9ICdmaWxlJztcbiAgcmV0dXJuIHRoaXMuYWRkKGtleSwgb3B0aW9ucyk7XG59O1xuXG4vL1xuLy8gRGVmaW5lIHdyYXBwZXIgZnVuY3Rpb25zIGZvciB1c2luZ1xuLy8gb3ZlcnJpZGVzIGFuZCBkZWZhdWx0c1xuLy9cblsnZGVmYXVsdHMnLCAnb3ZlcnJpZGVzJ10uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBQcm92aWRlci5wcm90b3R5cGVbdHlwZV0gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICBvcHRpb25zLnR5cGUgPSAnbGl0ZXJhbCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYWRkKHR5cGUsIG9wdGlvbnMpO1xuICB9O1xufSk7XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gdXNlIChuYW1lLCBvcHRpb25zKVxuLy8gIyMjIyBAdHlwZSB7c3RyaW5nfSBUeXBlIG9mIHRoZSBuY29uZiBzdG9yZSB0byB1c2UuXG4vLyAjIyMjIEBvcHRpb25zIHtPYmplY3R9IE9wdGlvbnMgZm9yIHRoZSBzdG9yZSBpbnN0YW5jZS5cbi8vIEFkZHMgKG9yIHJlcGxhY2VzKSBhIG5ldyBzdG9yZSB3aXRoIHRoZSBzcGVjaWZpZWQgYG5hbWVgXG4vLyBhbmQgYG9wdGlvbnNgLiBJZiBgb3B0aW9ucy50eXBlYCBpcyBub3Qgc2V0LCB0aGVuIGBuYW1lYFxuLy8gd2lsbCBiZSB1c2VkIGluc3RlYWQ6XG4vL1xuLy8gICAgcHJvdmlkZXIudXNlKCdmaWxlJyk7XG4vLyAgICBwcm92aWRlci51c2UoJ2ZpbGUnLCB7IHR5cGU6ICdmaWxlJywgZmlsZW5hbWU6ICcvcGF0aC90by91c2VyY29uZicgfSlcbi8vXG5Qcm92aWRlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKG5hbWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyAgPSBvcHRpb25zICAgICAgfHwge307XG5cbiAgZnVuY3Rpb24gc2FtZU9wdGlvbnMgKHN0b3JlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9wdGlvbnMpLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBvcHRpb25zW2tleV0gPT09IHN0b3JlW2tleV07XG4gICAgfSk7XG4gIH1cblxuICB2YXIgc3RvcmUgPSB0aGlzLnN0b3Jlc1tuYW1lXSxcbiAgICAgIHVwZGF0ZSA9IHN0b3JlICYmICFzYW1lT3B0aW9ucyhzdG9yZSk7XG5cbiAgaWYgKCFzdG9yZSB8fCB1cGRhdGUpIHtcbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICB0aGlzLnJlbW92ZShuYW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZChuYW1lLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vICMjIyBmdW5jdGlvbiBhZGQgKG5hbWUsIG9wdGlvbnMpXG4vLyAjIyMjIEBuYW1lIHtzdHJpbmd9IE5hbWUgb2YgdGhlIHN0b3JlIHRvIGFkZCB0byB0aGlzIGluc3RhbmNlXG4vLyAjIyMjIEBvcHRpb25zIHtPYmplY3R9IE9wdGlvbnMgZm9yIHRoZSBzdG9yZSB0byBjcmVhdGVcbi8vIEFkZHMgYSBuZXcgc3RvcmUgd2l0aCB0aGUgc3BlY2lmaWVkIGBuYW1lYCBhbmQgYG9wdGlvbnNgLiBJZiBgb3B0aW9ucy50eXBlYFxuLy8gaXMgbm90IHNldCwgdGhlbiBgbmFtZWAgd2lsbCBiZSB1c2VkIGluc3RlYWQ6XG4vL1xuLy8gICAgcHJvdmlkZXIuYWRkKCdtZW1vcnknKTtcbi8vICAgIHByb3ZpZGVyLmFkZCgndXNlcmNvbmYnLCB7IHR5cGU6ICdmaWxlJywgZmlsZW5hbWU6ICcvcGF0aC90by91c2VyY29uZicgfSlcbi8vXG5Qcm92aWRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5hbWUsIG9wdGlvbnMsIHVzYWdlKSB7XG4gIG9wdGlvbnMgID0gb3B0aW9ucyAgICAgIHx8IHt9O1xuICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBuYW1lO1xuXG4gIGlmICghcmVxdWlyZSgnLi4vbmNvbmYnKVtjb21tb24uY2FwaXRhbGl6ZSh0eXBlKV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgc3RvcmUgd2l0aCB1bmtub3duIHR5cGU6ICcgKyB0eXBlKTtcbiAgfVxuXG4gIHRoaXMuc3RvcmVzW25hbWVdID0gdGhpcy5jcmVhdGUodHlwZSwgb3B0aW9ucywgdXNhZ2UpO1xuXG4gIGlmICh0aGlzLnN0b3Jlc1tuYW1lXS5sb2FkU3luYykge1xuICAgIHRoaXMuc3RvcmVzW25hbWVdLmxvYWRTeW5jKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gcmVtb3ZlIChuYW1lKVxuLy8gIyMjIyBAbmFtZSB7c3RyaW5nfSBOYW1lIG9mIHRoZSBzdG9yZSB0byByZW1vdmUgZnJvbSB0aGlzIGluc3RhbmNlXG4vLyBSZW1vdmVzIGEgc3RvcmUgd2l0aCB0aGUgc3BlY2lmaWVkIGBuYW1lYCBmcm9tIHRoaXMgaW5zdGFuY2UuIFVzZXJzXG4vLyBhcmUgYWxsb3dlZCB0byBwYXNzIGluIGEgdHlwZSBhcmd1bWVudCAoZS5nLiBgbWVtb3J5YCkgYXMgbmFtZSBpZlxuLy8gdGhpcyB3YXMgdXNlZCBpbiB0aGUgY2FsbCB0byBgLmFkZCgpYC5cbi8vXG5Qcm92aWRlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXMuc3RvcmVzW25hbWVdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gY3JlYXRlICh0eXBlLCBvcHRpb25zKVxuLy8gIyMjIyBAdHlwZSB7c3RyaW5nfSBUeXBlIG9mIHRoZSBuY29uZiBzdG9yZSB0byB1c2UuXG4vLyAjIyMjIEBvcHRpb25zIHtPYmplY3R9IE9wdGlvbnMgZm9yIHRoZSBzdG9yZSBpbnN0YW5jZS5cbi8vIENyZWF0ZXMgYSBzdG9yZSBvZiB0aGUgc3BlY2lmaWVkIGB0eXBlYCB1c2luZyB0aGVcbi8vIHNwZWNpZmllZCBgb3B0aW9uc2AuXG4vL1xuUHJvdmlkZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICh0eXBlLCBvcHRpb25zLCB1c2FnZSkge1xuICByZXR1cm4gbmV3IChyZXF1aXJlKCcuLi9uY29uZicpW2NvbW1vbi5jYXBpdGFsaXplKHR5cGUudG9Mb3dlckNhc2UoKSldKShvcHRpb25zLCB1c2FnZSk7XG59O1xuXG4vL1xuLy8gIyMjIGZ1bmN0aW9uIGluaXQgKG9wdGlvbnMpXG4vLyAjIyMjIEBvcHRpb25zIHtPYmplY3R9IE9wdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGlzIGluc3RhbmNlIHdpdGguXG4vLyBJbml0aWFsaXplcyB0aGlzIGluc3RhbmNlIHdpdGggYWRkaXRpb25hbCBgc3RvcmVzYCBvciBgc291cmNlc2AgaW4gdGhlXG4vLyBgb3B0aW9uc2Agc3VwcGxpZWQuXG4vL1xuUHJvdmlkZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy9cbiAgLy8gQWRkIGFueSBzdG9yZXMgcGFzc2VkIGluIHRocm91Z2ggdGhlIG9wdGlvbnNcbiAgLy8gdG8gdGhpcyBpbnN0YW5jZS5cbiAgLy9cbiAgaWYgKG9wdGlvbnMudHlwZSkge1xuICAgIHRoaXMuYWRkKG9wdGlvbnMudHlwZSwgb3B0aW9ucyk7XG4gIH1cbiAgZWxzZSBpZiAob3B0aW9ucy5zdG9yZSkge1xuICAgIHRoaXMuYWRkKG9wdGlvbnMuc3RvcmUubmFtZSB8fCBvcHRpb25zLnN0b3JlLnR5cGUsIG9wdGlvbnMuc3RvcmUpO1xuICB9XG4gIGVsc2UgaWYgKG9wdGlvbnMuc3RvcmVzKSB7XG4gICAgT2JqZWN0LmtleXMob3B0aW9ucy5zdG9yZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBzdG9yZSA9IG9wdGlvbnMuc3RvcmVzW25hbWVdO1xuICAgICAgc2VsZi5hZGQoc3RvcmUubmFtZSB8fCBuYW1lIHx8IHN0b3JlLnR5cGUsIHN0b3JlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFkZCBhbnkgcmVhZC1vbmx5IHNvdXJjZXMgdG8gdGhpcyBpbnN0YW5jZVxuICAvL1xuICBpZiAob3B0aW9ucy5zb3VyY2UpIHtcbiAgICB0aGlzLnNvdXJjZXMucHVzaCh0aGlzLmNyZWF0ZShvcHRpb25zLnNvdXJjZS50eXBlIHx8IG9wdGlvbnMuc291cmNlLm5hbWUsIG9wdGlvbnMuc291cmNlKSk7XG4gIH1cbiAgZWxzZSBpZiAob3B0aW9ucy5zb3VyY2VzKSB7XG4gICAgT2JqZWN0LmtleXMob3B0aW9ucy5zb3VyY2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgc291cmNlID0gb3B0aW9ucy5zb3VyY2VzW25hbWVdO1xuICAgICAgc2VsZi5zb3VyY2VzLnB1c2goc2VsZi5jcmVhdGUoc291cmNlLnR5cGUgfHwgc291cmNlLm5hbWUgfHwgbmFtZSwgc291cmNlKSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gZ2V0IChrZXksIGNhbGxiYWNrKVxuLy8gIyMjIyBAa2V5IHtzdHJpbmd9IEtleSB0byByZXRyaWV2ZSBmb3IgdGhpcyBpbnN0YW5jZS5cbi8vICMjIyMgQGNhbGxiYWNrIHtmdW5jdGlvbn0gKipPcHRpb25hbCoqIENvbnRpbnVhdGlvbiB0byByZXNwb25kIHRvIHdoZW4gY29tcGxldGUuXG4vLyBSZXRyaWV2ZXMgdGhlIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIGtleSAoaWYgYW55KS5cbi8vXG5Qcm92aWRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBBbGxvdyBhICoga2V5IGNhbGwgdG8gYmUgbWFkZVxuICAgIGNhbGxiYWNrID0ga2V5O1xuICAgIGtleSA9IG51bGw7XG4gIH1cblxuICAvL1xuICAvLyBJZiB0aGVyZSBpcyBubyBjYWxsYmFjayB3ZSBjYW4gc2hvcnQtY2lyY3VpdCBpbnRvIHRoZSBkZWZhdWx0XG4gIC8vIGxvZ2ljIGZvciB0cmF2ZXJzaW5nIHN0b3Jlcy5cbiAgLy9cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9leGVjdXRlKCdnZXQnLCAxLCBrZXksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vXG4gIC8vIE90aGVyd2lzZSB0aGUgYXN5bmNocm9ub3VzLCBoaWVyYXJjaGljYWwgYGdldGAgaXNcbiAgLy8gc2xpZ2h0bHkgbW9yZSBjb21wbGljYXRlZCBiZWNhdXNlIHdlIGRvIG5vdCBuZWVkIHRvIHRyYXZlcnNlXG4gIC8vIHRoZSBlbnRpcmUgc2V0IG9mIHN0b3JlcywgYnV0IHVwIHVudGlsIHRoZXJlIGlzIGEgZGVmaW5lZCB2YWx1ZS5cbiAgLy9cbiAgdmFyIGN1cnJlbnQgPSAwLFxuICAgICAgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLnN0b3JlcyksXG4gICAgICBzZWxmID0gdGhpcyxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgbWVyZ2VPYmpzID0gW107XG5cbiAgYXN5bmMud2hpbHN0KGZ1bmN0aW9uIChjYikge1xuICAgIGNiKG51bGwsIHR5cGVvZiByZXNwb25zZSA9PT0gJ3VuZGVmaW5lZCcgJiYgY3VycmVudCA8IG5hbWVzLmxlbmd0aCk7XG4gIH0sIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgdmFyIHN0b3JlID0gc2VsZi5zdG9yZXNbbmFtZXNbY3VycmVudF1dO1xuICAgIGN1cnJlbnQrKztcblxuICAgIGlmIChzdG9yZS5nZXQubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiBzdG9yZS5nZXQoa2V5LCBmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3BvbnNlID0gdmFsdWU7XG5cbiAgICAgICAgLy8gTWVyZ2Ugb2JqZWN0cyBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgbWVyZ2VPYmpzLnB1c2gocmVzcG9uc2UpO1xuICAgICAgICAgIHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzcG9uc2UgPSBzdG9yZS5nZXQoa2V5KTtcblxuICAgIC8vIE1lcmdlIG9iamVjdHMgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICBtZXJnZU9ianMucHVzaChyZXNwb25zZSk7XG4gICAgICByZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBuZXh0KCk7XG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWVyciAmJiBtZXJnZU9ianMubGVuZ3RoKSB7XG4gICAgICByZXNwb25zZSA9IGNvbW1vbi5tZXJnZShtZXJnZU9ianMucmV2ZXJzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVyciA/IGNhbGxiYWNrKGVycikgOiBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7XG4gIH0pO1xufTtcblxuXG4vL1xuLy8gIyMjIGZ1bmN0aW9uIGFueSAoa2V5cywgY2FsbGJhY2spXG4vLyAjIyMjIEBrZXlzIHthcnJheXxzdHJpbmcuLi59IEFycmF5IG9mIGtleXMgdG8gcXVlcnksIG9yIGEgdmFyaWFibGUgbGlzdCBvZiBzdHJpbmdzXG4vLyAjIyMjIEBjYWxsYmFjayB7ZnVuY3Rpb259ICoqT3B0aW9uYWwqKiBDb250aW51YXRpb24gdG8gcmVzcG9uZCB0byB3aGVuIGNvbXBsZXRlLlxuLy8gUmV0cmlldmVzIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgKGlmIGFueSkgZm9yIHRoZSBzcGVjaWZpZWQgbGlzdCBvZiBrZXlzLlxuLy9cblByb3ZpZGVyLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiAoa2V5cywgY2FsbGJhY2spIHtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICBrZXlzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPiAwICYmIHR5cGVvZiBrZXlzW2tleXMubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0ga2V5cy5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIElmIHRoZXJlIGlzIG5vIGNhbGxiYWNrLCB1c2UgdGhlIHNob3J0LWNpcmN1aXRlZCBcImdldFwiXG4gIC8vIG9uIGVhY2gga2V5IGluIHR1cm4uXG4gIC8vXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICB2YXIgdmFsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFsID0gdGhpcy5fZXhlY3V0ZSgnZ2V0JywgMSwga2V5c1tpXSwgY2FsbGJhY2spO1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBrZXlJbmRleCA9IDAsXG4gICAgICByZXN1bHQsXG4gICAgICBzZWxmID0gdGhpcztcbiAgXG4gIGFzeW5jLndoaWxzdChmdW5jdGlvbihjYikge1xuICAgIGNiKG51bGwsICFyZXN1bHQgJiYga2V5SW5kZXggPCBrZXlzLmxlbmd0aCk7XG4gIH0sIGZ1bmN0aW9uKG5leHQpIHtcbiAgICB2YXIga2V5ID0ga2V5c1trZXlJbmRleF07XG4gICAga2V5SW5kZXgrKztcblxuICAgIHNlbGYuZ2V0KGtleSwgZnVuY3Rpb24oZXJyLCB2KSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIG5leHQoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHY7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgcmV0dXJuIGVyciA/IGNhbGxiYWNrKGVycikgOiBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICB9KTtcbn07XG5cblxuLy9cbi8vICMjIyBmdW5jdGlvbiBzZXQgKGtleSwgdmFsdWUsIGNhbGxiYWNrKVxuLy8gIyMjIyBAa2V5IHtzdHJpbmd9IEtleSB0byBzZXQgaW4gdGhpcyBpbnN0YW5jZVxuLy8gIyMjIyBAdmFsdWUge2xpdGVyYWx8T2JqZWN0fSBWYWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBrZXlcbi8vICMjIyMgQGNhbGxiYWNrIHtmdW5jdGlvbn0gKipPcHRpb25hbCoqIENvbnRpbnVhdGlvbiB0byByZXNwb25kIHRvIHdoZW4gY29tcGxldGUuXG4vLyBTZXRzIHRoZSBgdmFsdWVgIGZvciB0aGUgc3BlY2lmaWVkIGBrZXlgIGluIHRoaXMgaW5zdGFuY2UuXG4vL1xuUHJvdmlkZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fZXhlY3V0ZSgnc2V0JywgMiwga2V5LCB2YWx1ZSwgY2FsbGJhY2spO1xufTtcblxuXG4vL1xuLy8gIyMjIGZ1bmN0aW9uIHJlcXVpcmVkIChrZXlzKVxuLy8gIyMjIyBAa2V5cyB7YXJyYXl9IExpc3Qgb2Yga2V5c1xuLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFueSBvZiBga2V5c2AgaGFzIG5vIHZhbHVlLCBvdGhlcndpc2UgcmV0dXJucyBgdHJ1ZWBcblByb3ZpZGVyLnByb3RvdHlwZS5yZXF1aXJlZCA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IHBhcmFtZXRlciwgYXJyYXkgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIHZhciBtaXNzaW5nID0gW107XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZ2V0KGtleSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBtaXNzaW5nLnB1c2goa2V5KTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuXG4gIGlmIChtaXNzaW5nLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBrZXlzOiAnICsgbWlzc2luZy5qb2luKCcsICcpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG59O1xuXG4vL1xuLy8gIyMjIGZ1bmN0aW9uIHJlc2V0IChjYWxsYmFjaylcbi8vICMjIyMgQGNhbGxiYWNrIHtmdW5jdGlvbn0gKipPcHRpb25hbCoqIENvbnRpbnVhdGlvbiB0byByZXNwb25kIHRvIHdoZW4gY29tcGxldGUuXG4vLyBDbGVhcnMgYWxsIGtleXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4vL1xuUHJvdmlkZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9leGVjdXRlKCdyZXNldCcsIDAsIGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gY2xlYXIgKGtleSwgY2FsbGJhY2spXG4vLyAjIyMjIEBrZXkge3N0cmluZ30gS2V5IHRvIHJlbW92ZSBmcm9tIHRoaXMgaW5zdGFuY2Vcbi8vICMjIyMgQGNhbGxiYWNrIHtmdW5jdGlvbn0gKipPcHRpb25hbCoqIENvbnRpbnVhdGlvbiB0byByZXNwb25kIHRvIHdoZW4gY29tcGxldGUuXG4vLyBSZW1vdmVzIHRoZSB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBga2V5YCBmcm9tIHRoaXMgaW5zdGFuY2UuXG4vL1xuUHJvdmlkZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKGtleSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2V4ZWN1dGUoJ2NsZWFyJywgMSwga2V5LCBjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gIyMjIGZ1bmN0aW9uIG1lcmdlIChba2V5LF0gdmFsdWUgWywgY2FsbGJhY2tdKVxuLy8gIyMjIyBAa2V5IHtzdHJpbmd9IEtleSB0byBtZXJnZSB0aGUgdmFsdWUgaW50b1xuLy8gIyMjIyBAdmFsdWUge2xpdGVyYWx8T2JqZWN0fSBWYWx1ZSB0byBtZXJnZSBpbnRvIHRoZSBrZXlcbi8vICMjIyMgQGNhbGxiYWNrIHtmdW5jdGlvbn0gKipPcHRpb25hbCoqIENvbnRpbnVhdGlvbiB0byByZXNwb25kIHRvIHdoZW4gY29tcGxldGUuXG4vLyBNZXJnZXMgdGhlIHByb3BlcnRpZXMgaW4gYHZhbHVlYCBpbnRvIHRoZSBleGlzdGluZyBvYmplY3QgdmFsdWUgYXQgYGtleWAuXG4vL1xuLy8gMS4gSWYgdGhlIGV4aXN0aW5nIHZhbHVlIGBrZXlgIGlzIG5vdCBhbiBPYmplY3QsIGl0IHdpbGwgYmUgY29tcGxldGVseSBvdmVyd3JpdHRlbi5cbi8vIDIuIElmIGBrZXlgIGlzIG5vdCBzdXBwbGllZCwgdGhlbiB0aGUgYHZhbHVlYCB3aWxsIGJlIG1lcmdlZCBpbnRvIHRoZSByb290LlxuLy9cblByb3ZpZGVyLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICBjYWxsYmFjayA9IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicgJiYgYXJncy5wb3AoKSxcbiAgICAgIHZhbHVlID0gYXJncy5wb3AoKSxcbiAgICAgIGtleSA9IGFyZ3MucG9wKCk7XG5cbiAgZnVuY3Rpb24gbWVyZ2VQcm9wZXJ0eSAocHJvcCwgbmV4dCkge1xuICAgIHJldHVybiBzZWxmLl9leGVjdXRlKCdtZXJnZScsIDIsIHByb3AsIHZhbHVlW3Byb3BdLCBuZXh0KTtcbiAgfVxuXG4gIGlmICgha2V5KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBvbkVycm9yKG5ldyBFcnJvcignQ2Fubm90IG1lcmdlIG5vbi1PYmplY3QgaW50byB0b3AtbGV2ZWwuJyksIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXN5bmMuZm9yRWFjaChPYmplY3Qua2V5cyh2YWx1ZSksIG1lcmdlUHJvcGVydHksIGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHsgfSlcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9leGVjdXRlKCdtZXJnZScsIDIsIGtleSwgdmFsdWUsIGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gbG9hZCAoY2FsbGJhY2spXG4vLyAjIyMjIEBjYWxsYmFjayB7ZnVuY3Rpb259IENvbnRpbnVhdGlvbiB0byByZXNwb25kIHRvIHdoZW4gY29tcGxldGUuXG4vLyBSZXNwb25kcyB3aXRoIGFuIE9iamVjdCByZXByZXNlbnRpbmcgYWxsIGtleXMgYXNzb2NpYXRlZCBpbiB0aGlzIGluc3RhbmNlLlxuLy9cblByb3ZpZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBnZXRTdG9yZXMgKCkge1xuICAgIHZhciBzdG9yZXMgPSBPYmplY3Qua2V5cyhzZWxmLnN0b3Jlcyk7XG4gICAgc3RvcmVzLnJldmVyc2UoKTtcbiAgICByZXR1cm4gc3RvcmVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIHNlbGYuc3RvcmVzW25hbWVdO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9hZFN0b3JlU3luYyhzdG9yZSkge1xuICAgIGlmICghc3RvcmUubG9hZFN5bmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbmNvbmYgc3RvcmUgJyArIHN0b3JlLnR5cGUgKyAnIGhhcyBubyBsb2FkU3luYygpIG1ldGhvZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBzdG9yZS5sb2FkU3luYygpO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9hZFN0b3JlKHN0b3JlLCBuZXh0KSB7XG4gICAgaWYgKCFzdG9yZS5sb2FkICYmICFzdG9yZS5sb2FkU3luYykge1xuICAgICAgcmV0dXJuIG5leHQobmV3IEVycm9yKCduY29uZiBzdG9yZSAnICsgc3RvcmUudHlwZSArICcgaGFzIG5vIGxvYWQoKSBtZXRob2QnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0b3JlLmxvYWRTeW5jXG4gICAgICA/IG5leHQobnVsbCwgc3RvcmUubG9hZFN5bmMoKSlcbiAgICAgIDogc3RvcmUubG9hZChuZXh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvYWRCYXRjaCAodGFyZ2V0cywgZG9uZSkge1xuICAgIGlmICghZG9uZSkge1xuICAgICAgcmV0dXJuIGNvbW1vbi5tZXJnZSh0YXJnZXRzLm1hcChsb2FkU3RvcmVTeW5jKSk7XG4gICAgfVxuXG4gICAgYXN5bmMubWFwKHRhcmdldHMsIGxvYWRTdG9yZSwgZnVuY3Rpb24gKGVyciwgb2Jqcykge1xuICAgICAgcmV0dXJuIGVyciA/IGRvbmUoZXJyKSA6IGRvbmUobnVsbCwgY29tbW9uLm1lcmdlKG9ianMpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlU291cmNlcyAoZGF0YSkge1xuICAgIC8vXG4gICAgLy8gSWYgYGRhdGFgIHdhcyByZXR1cm5lZCB0aGVuIG1lcmdlIGl0IGludG9cbiAgICAvLyB0aGUgc3lzdGVtIHN0b3JlLlxuICAgIC8vXG4gICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICBzZWxmLnVzZSgnc291cmNlcycsIHtcbiAgICAgICAgdHlwZTogJ2xpdGVyYWwnLFxuICAgICAgICBzdG9yZTogZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9hZFNvdXJjZXMgKCkge1xuICAgIHZhciBzb3VyY2VIaWVyYXJjaHkgPSBzZWxmLnNvdXJjZXMuc3BsaWNlKDApO1xuICAgIHNvdXJjZUhpZXJhcmNoeS5yZXZlcnNlKCk7XG5cbiAgICAvL1xuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjYWxsYmFjayBhbmQgdGhlIGN1cnJlbnRcbiAgICAvLyBzdG9yZSBpcyBjYXBhYmxlIG9mIGxvYWRpbmcgc3luY2hyb25vdXNseVxuICAgIC8vIHRoZW4gZG8gc28uXG4gICAgLy9cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBtZXJnZVNvdXJjZXMobG9hZEJhdGNoKHNvdXJjZUhpZXJhcmNoeSkpO1xuICAgICAgcmV0dXJuIGxvYWRCYXRjaChnZXRTdG9yZXMoKSk7XG4gICAgfVxuXG4gICAgbG9hZEJhdGNoKHNvdXJjZUhpZXJhcmNoeSwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgbWVyZ2VTb3VyY2VzKGRhdGEpO1xuICAgICAgcmV0dXJuIGxvYWRCYXRjaChnZXRTdG9yZXMoKSwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHNlbGYuc291cmNlcy5sZW5ndGhcbiAgICA/IGxvYWRTb3VyY2VzKClcbiAgICA6IGxvYWRCYXRjaChnZXRTdG9yZXMoKSwgY2FsbGJhY2spO1xufTtcblxuLy9cbi8vICMjIyBmdW5jdGlvbiBzYXZlIChjYWxsYmFjaylcbi8vICMjIyMgQGNhbGxiYWNrIHtmdW5jdGlvbn0gKipvcHRpb25hbCoqICBDb250aW51YXRpb24gdG8gcmVzcG9uZCB0byB3aGVuXG4vLyBjb21wbGV0ZS5cbi8vIEluc3RydWN0cyBlYWNoIHByb3ZpZGVyIHRvIHNhdmUuICBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkLCB3ZSB3aWxsIGF0dGVtcHRcbi8vIGFzeW5jaHJvbm91cyBzYXZlcyBvbiB0aGUgcHJvdmlkZXJzLCBmYWxsaW5nIGJhY2sgdG8gc3luY2hyb25vdXMgc2F2ZXMgaWZcbi8vIHRoaXMgaXNuJ3QgcG9zc2libGUuICBJZiBhIHByb3ZpZGVyIGRvZXMgbm90IGtub3cgaG93IHRvIHNhdmUsIGl0IHdpbGwgYmVcbi8vIGlnbm9yZWQuICBSZXR1cm5zIGFuIG9iamVjdCBjb25zaXN0aW5nIG9mIGFsbCBvZiB0aGUgZGF0YSB3aGljaCB3YXNcbi8vIGFjdHVhbGx5IHNhdmVkLlxuLy9cblByb3ZpZGVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKHZhbHVlLCBjYWxsYmFjaykge1xuICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gdmFsdWU7XG4gICAgdmFsdWUgPSBudWxsO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLnN0b3Jlcyk7XG5cbiAgZnVuY3Rpb24gc2F2ZVN0b3JlU3luYyhtZW1vLCBuYW1lKSB7XG4gICAgdmFyIHN0b3JlID0gc2VsZi5zdG9yZXNbbmFtZV07XG5cbiAgICAvL1xuICAgIC8vIElmIHRoZSBgc3RvcmVgIGRvZXNuJ3QgaGF2ZSBhIGBzYXZlU3luY2AgbWV0aG9kLFxuICAgIC8vIGp1c3QgaWdub3JlIGl0IGFuZCBjb250aW51ZS5cbiAgICAvL1xuICAgIGlmIChzdG9yZS5zYXZlU3luYykge1xuICAgICAgdmFyIHJldCA9IHN0b3JlLnNhdmVTeW5jKCk7XG4gICAgICBpZiAodHlwZW9mIHJldCA9PSAnb2JqZWN0JyAmJiByZXQgIT09IG51bGwpIHtcbiAgICAgICAgbWVtby5wdXNoKHJldCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9XG5cbiAgZnVuY3Rpb24gc2F2ZVN0b3JlKG1lbW8sIG5hbWUsIG5leHQpIHtcbiAgICB2YXIgc3RvcmUgPSBzZWxmLnN0b3Jlc1tuYW1lXTtcblxuICAgIC8vXG4gICAgLy8gSWYgdGhlIGBzdG9yZWAgZG9lc24ndCBoYXZlIGEgYHNhdmVgIG9yIHNhdmVTeW5jYFxuICAgIC8vIG1ldGhvZChzKSwganVzdCBpZ25vcmUgaXQgYW5kIGNvbnRpbnVlLlxuICAgIC8vXG5cbiAgICBpZiAoc3RvcmUuc2F2ZSkge1xuICAgICAgcmV0dXJuIHN0b3JlLnNhdmUodmFsdWUsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ29iamVjdCcgJiYgZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIG1lbW8ucHVzaChkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQobnVsbCwgbWVtbyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RvcmUuc2F2ZVN5bmMpIHtcbiAgICAgIG1lbW8ucHVzaChzdG9yZS5zYXZlU3luYygpKTtcbiAgICB9XG5cbiAgICBuZXh0KG51bGwsIG1lbW8pO1xuICB9XG5cbiAgLy9cbiAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNhbGxiYWNrIGFuZCB0aGUgY3VycmVudFxuICAvLyBzdG9yZSBpcyBjYXBhYmxlIG9mIHNhdmluZyBzeW5jaHJvbm91c2x5XG4gIC8vIHRoZW4gZG8gc28uXG4gIC8vXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm4gY29tbW9uLm1lcmdlKG5hbWVzLnJlZHVjZShzYXZlU3RvcmVTeW5jLCBbXSkpO1xuICB9XG5cbiAgYXN5bmMucmVkdWNlKG5hbWVzLCBbXSwgc2F2ZVN0b3JlLCBmdW5jdGlvbiAoZXJyLCBvYmpzKSB7XG4gICAgcmV0dXJuIGVyciA/IGNhbGxiYWNrKGVycikgOiBjYWxsYmFjayhudWxsLCBjb21tb24ubWVyZ2Uob2JqcykpO1xuICB9KTtcbn07XG5cbi8vXG4vLyAjIyMgQHByaXZhdGUgZnVuY3Rpb24gX2V4ZWN1dGUgKGFjdGlvbiwgc3luY0xlbmd0aCwgW2FyZ3VtZW50c10pXG4vLyAjIyMjIEBhY3Rpb24ge3N0cmluZ30gQWN0aW9uIHRvIGV4ZWN1dGUgb24gYHRoaXMuc3RvcmVgLlxuLy8gIyMjIyBAc3luY0xlbmd0aCB7bnVtYmVyfSBGdW5jdGlvbiBsZW5ndGggb2YgdGhlIHN5bmMgdmVyc2lvbi5cbi8vICMjIyMgQGFyZ3VtZW50cyB7QXJyYXl9IEFyZ3VtZW50cyBhcnJheSB0byBhcHBseSB0byB0aGUgYWN0aW9uXG4vLyBFeGVjdXRlcyB0aGUgc3BlY2lmaWVkIGBhY3Rpb25gIG9uIGFsbCBzdG9yZXMgZm9yIHRoaXMgaW5zdGFuY2UsIGVuc3VyaW5nIGEgY2FsbGJhY2sgc3VwcGxpZWRcbi8vIHRvIGEgc3luY2hyb25vdXMgc3RvcmUgZnVuY3Rpb24gaXMgc3RpbGwgaW52b2tlZC5cbi8vXG5Qcm92aWRlci5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoYWN0aW9uLCBzeW5jTGVuZ3RoIC8qIFthcmd1bWVudHNdICovKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgIGNhbGxiYWNrID0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmdzLnBvcCgpLFxuICAgICAgZGVzdHJ1Y3RpdmUgPSBbJ3NldCcsICdjbGVhcicsICdtZXJnZScsICdyZXNldCddLmluZGV4T2YoYWN0aW9uKSAhPT0gLTEsXG4gICAgICBzZWxmID0gdGhpcyxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgbWVyZ2VPYmpzID0gW10sXG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModGhpcy5zdG9yZXMpO1xuXG5cbiAgZnVuY3Rpb24gcnVuQWN0aW9uIChuYW1lLCBuZXh0KSB7XG4gICAgdmFyIHN0b3JlID0gc2VsZi5zdG9yZXNbbmFtZV07XG5cbiAgICBpZiAoZGVzdHJ1Y3RpdmUgJiYgc3RvcmUucmVhZE9ubHkpIHtcbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0b3JlW2FjdGlvbl0ubGVuZ3RoID4gc3luY0xlbmd0aFxuICAgICAgPyBzdG9yZVthY3Rpb25dLmFwcGx5KHN0b3JlLCBhcmdzLmNvbmNhdChuZXh0KSlcbiAgICAgIDogbmV4dChudWxsLCBzdG9yZVthY3Rpb25dLmFwcGx5KHN0b3JlLCBhcmdzKSk7XG4gIH1cblxuICBpZiAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gYXN5bmMuZm9yRWFjaChrZXlzLCBydW5BY3Rpb24sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJldHVybiBlcnIgPyBjYWxsYmFjayhlcnIpIDogY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfVxuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3RvcmUgPSBzZWxmLnN0b3Jlc1tuYW1lXTtcblxuICAgICAgaWYgKGRlc3RydWN0aXZlICYmIHN0b3JlLnJlYWRPbmx5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzcG9uc2UgPSBzdG9yZVthY3Rpb25dLmFwcGx5KHN0b3JlLCBhcmdzKTtcblxuICAgICAgLy8gTWVyZ2Ugb2JqZWN0cyBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChyZXNwb25zZSAmJiBhY3Rpb24gPT09ICdnZXQnICYmIHR5cGVvZiByZXNwb25zZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgIG1lcmdlT2Jqcy5wdXNoKHJlc3BvbnNlKTtcbiAgICAgICAgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAobWVyZ2VPYmpzLmxlbmd0aCkge1xuICAgIHJlc3BvbnNlID0gY29tbW9uLm1lcmdlKG1lcmdlT2Jqcy5yZXZlcnNlKCkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuXG4vL1xuLy8gVGhyb3cgdGhlIGBlcnJgIGlmIGEgY2FsbGJhY2sgaXMgbm90IHN1cHBsaWVkXG4vL1xuZnVuY3Rpb24gb25FcnJvcihlcnIsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgdGhyb3cgZXJyO1xufVxuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJQSxLQUFLLEdBQUdDLE9BQU8sQ0FBQyxPQUFPLENBQUM7RUFDeEJDLE1BQU0sR0FBR0QsT0FBTyxDQUFDLFVBQVUsQ0FBQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSUUsUUFBUSxHQUFHQyxPQUFPLENBQUNELFFBQVEsR0FBRyxVQUFVRSxPQUFPLEVBQUU7RUFDbkQ7RUFDQTtFQUNBO0VBQ0E7RUFDQUEsT0FBTyxHQUFTQSxPQUFPLElBQUksQ0FBQyxDQUFDO0VBQzdCLElBQUksQ0FBQ0MsTUFBTSxHQUFJLENBQUMsQ0FBQztFQUNqQixJQUFJLENBQUNDLE9BQU8sR0FBRyxFQUFFO0VBQ2pCLElBQUksQ0FBQ0MsSUFBSSxDQUFDSCxPQUFPLENBQUM7QUFDcEIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFD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","map":{"version":3,"names":["async","require","common","Provider","exports","options","stores","sources","init","forEach","type","prototype","args","concat","Array","slice","call","arguments","add","apply","file","key","length","use","name","sameOptions","store","Object","keys","every","update","remove","usage","capitalize","Error","create","loadSync","toLowerCase","self","source","push","get","callback","_execute","current","names","response","mergeObjs","whilst","cb","next","err","value","isArray","undefined","merge","reverse","any","pop","val","i","keyIndex","result","v","set","required","missing","join","reset","clear","mergeProperty","prop","onError","load","getStores","map","loadStoreSync","loadStore","loadBatch","targets","done","objs","mergeSources","data","loadSources","sourceHierarchy","splice","save","saveStoreSync","memo","saveSync","ret","saveStore","reduce","action","syncLength","destructive","indexOf","runAction","readOnly"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\nconf@0.12.0\\node_modules\\nconf\\lib\\nconf\\","sources":["provider.js"],"sourcesContent":["/*\n * provider.js: Abstraction providing an interface into pluggable configuration storage.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar async = require('async'),\n    common = require('./common');\n\n//\n// ### function Provider (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Provider object responsible\n// for exposing the pluggable storage features of `nconf`.\n//\nvar Provider = exports.Provider = function (options) {\n  //\n  // Setup default options for working with `stores`,\n  // `overrides`, `process.env` and `process.argv`.\n  //\n  options       = options || {};\n  this.stores  = {};\n  this.sources = [];\n  this.init(options);\n};\n\n//\n// Define wrapper functions for using basic stores\n// in this instance\n//\n\n['argv', 'env'].forEach(function (type) {\n  Provider.prototype[type] = function () {\n    var args = [type].concat(Array.prototype.slice.call(arguments));\n    return this.add.apply(this, args);\n  };\n});\n\n//\n// ### function file (key, options)\n// #### @key {string|Object} Fully qualified options, name of file store, or path.\n// #### @path {string|Object} **Optional** Full qualified options, or path.\n// Adds a new `File` store to this instance. Accepts the following options\n//\n//    nconf.file({ file: '.jitsuconf', dir: process.env.HOME, search: true });\n//    nconf.file('path/to/config/file');\n//    nconf.file('userconfig', 'path/to/config/file');\n//    nconf.file('userconfig', { file: '.jitsuconf', search: true });\n//\nProvider.prototype.file = function (key, options) {\n  if (arguments.length == 1) {\n    options = typeof key === 'string' ? { file: key } : key;\n    key = 'file';\n  }\n  else {\n    options = typeof options === 'string'\n      ? { file: options }\n      : options;\n  }\n\n  options.type = 'file';\n  return this.add(key, options);\n};\n\n//\n// Define wrapper functions for using\n// overrides and defaults\n//\n['defaults', 'overrides'].forEach(function (type) {\n  Provider.prototype[type] = function (options) {\n    options = options || {};\n    if (!options.type) {\n      options.type = 'literal';\n    }\n\n    return this.add(type, options);\n  };\n});\n\n//\n// ### function use (name, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Adds (or replaces) a new store with the specified `name`\n// and `options`. If `options.type` is not set, then `name`\n// will be used instead:\n//\n//    provider.use('file');\n//    provider.use('file', { type: 'file', filename: '/path/to/userconf' })\n//\nProvider.prototype.use = function (name, options) {\n  options  = options      || {};\n\n  function sameOptions (store) {\n    return Object.keys(options).every(function (key) {\n      return options[key] === store[key];\n    });\n  }\n\n  var store = this.stores[name],\n      update = store && !sameOptions(store);\n\n  if (!store || update) {\n    if (update) {\n      this.remove(name);\n    }\n\n    this.add(name, options);\n  }\n\n  return this;\n};\n\n//\n// ### function add (name, options)\n// #### @name {string} Name of the store to add to this instance\n// #### @options {Object} Options for the store to create\n// Adds a new store with the specified `name` and `options`. If `options.type`\n// is not set, then `name` will be used instead:\n//\n//    provider.add('memory');\n//    provider.add('userconf', { type: 'file', filename: '/path/to/userconf' })\n//\nProvider.prototype.add = function (name, options, usage) {\n  options  = options      || {};\n  var type = options.type || name;\n\n  if (!require('../nconf')[common.capitalize(type)]) {\n    throw new Error('Cannot add store with unknown type: ' + type);\n  }\n\n  this.stores[name] = this.create(type, options, usage);\n\n  if (this.stores[name].loadSync) {\n    this.stores[name].loadSync();\n  }\n\n  return this;\n};\n\n//\n// ### function remove (name)\n// #### @name {string} Name of the store to remove from this instance\n// Removes a store with the specified `name` from this instance. Users\n// are allowed to pass in a type argument (e.g. `memory`) as name if\n// this was used in the call to `.add()`.\n//\nProvider.prototype.remove = function (name) {\n  delete this.stores[name];\n  return this;\n};\n\n//\n// ### function create (type, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Creates a store of the specified `type` using the\n// specified `options`.\n//\nProvider.prototype.create = function (type, options, usage) {\n  return new (require('../nconf')[common.capitalize(type.toLowerCase())])(options, usage);\n};\n\n//\n// ### function init (options)\n// #### @options {Object} Options to initialize this instance with.\n// Initializes this instance with additional `stores` or `sources` in the\n// `options` supplied.\n//\nProvider.prototype.init = function (options) {\n  var self = this;\n\n  //\n  // Add any stores passed in through the options\n  // to this instance.\n  //\n  if (options.type) {\n    this.add(options.type, options);\n  }\n  else if (options.store) {\n    this.add(options.store.name || options.store.type, options.store);\n  }\n  else if (options.stores) {\n    Object.keys(options.stores).forEach(function (name) {\n      var store = options.stores[name];\n      self.add(store.name || name || store.type, store);\n    });\n  }\n\n  //\n  // Add any read-only sources to this instance\n  //\n  if (options.source) {\n    this.sources.push(this.create(options.source.type || options.source.name, options.source));\n  }\n  else if (options.sources) {\n    Object.keys(options.sources).forEach(function (name) {\n      var source = options.sources[name];\n      self.sources.push(self.create(source.type || source.name || name, source));\n    });\n  }\n};\n\n//\n// ### function get (key, callback)\n// #### @key {string} Key to retrieve for this instance.\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the value for the specified key (if any).\n//\nProvider.prototype.get = function (key, callback) {\n  if (typeof key === 'function') {\n    // Allow a * key call to be made\n    callback = key;\n    key = null;\n  }\n\n  //\n  // If there is no callback we can short-circuit into the default\n  // logic for traversing stores.\n  //\n  if (!callback) {\n    return this._execute('get', 1, key, callback);\n  }\n\n  //\n  // Otherwise the asynchronous, hierarchical `get` is\n  // slightly more complicated because we do not need to traverse\n  // the entire set of stores, but up until there is a defined value.\n  //\n  var current = 0,\n      names = Object.keys(this.stores),\n      self = this,\n      response,\n      mergeObjs = [];\n\n  async.whilst(function (cb) {\n    cb(null, typeof response === 'undefined' && current < names.length);\n  }, function (next) {\n    var store = self.stores[names[current]];\n    current++;\n\n    if (store.get.length >= 2) {\n      return store.get(key, function (err, value) {\n        if (err) {\n          return next(err);\n        }\n\n        response = value;\n\n        // Merge objects if necessary\n        if (response && typeof response === 'object' && !Array.isArray(response)) {\n          mergeObjs.push(response);\n          response = undefined;\n        }\n\n        next();\n      });\n    }\n\n    response = store.get(key);\n\n    // Merge objects if necessary\n    if (response && typeof response === 'object' && !Array.isArray(response)) {\n      mergeObjs.push(response);\n      response = undefined;\n    }\n\n    next();\n  }, function (err) {\n    if (!err && mergeObjs.length) {\n      response = common.merge(mergeObjs.reverse());\n    }\n    return err ? callback(err) : callback(null, response);\n  });\n};\n\n\n//\n// ### function any (keys, callback)\n// #### @keys {array|string...} Array of keys to query, or a variable list of strings\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the first truthy value (if any) for the specified list of keys.\n//\nProvider.prototype.any = function (keys, callback) {\n\n  if (!Array.isArray(keys)) {\n    keys = Array.prototype.slice.call(arguments);\n    if (keys.length > 0 && typeof keys[keys.length - 1] === 'function') {\n      callback = keys.pop();\n    } else {\n      callback = null;\n    }\n  }\n\n  //\n  // If there is no callback, use the short-circuited \"get\"\n  // on each key in turn.\n  //\n  if (!callback) {\n    var val;\n    for (var i = 0; i < keys.length; ++i) {\n      val = this._execute('get', 1, keys[i], callback);\n      if (val) {\n        return val;\n      }\n    }\n    return null;\n  }\n\n  var keyIndex = 0,\n      result,\n      self = this;\n  \n  async.whilst(function(cb) {\n    cb(null, !result && keyIndex < keys.length);\n  }, function(next) {\n    var key = keys[keyIndex];\n    keyIndex++;\n\n    self.get(key, function(err, v) {\n      if (err) {\n        next(err);\n      } else {\n        result = v;\n        next();\n      }\n    });\n  }, function(err) {\n    return err ? callback(err) : callback(null, result);\n  });\n};\n\n\n//\n// ### function set (key, value, callback)\n// #### @key {string} Key to set in this instance\n// #### @value {literal|Object} Value for the specified key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Sets the `value` for the specified `key` in this instance.\n//\nProvider.prototype.set = function (key, value, callback) {\n  return this._execute('set', 2, key, value, callback);\n};\n\n\n//\n// ### function required (keys)\n// #### @keys {array} List of keys\n// Throws an error if any of `keys` has no value, otherwise returns `true`\nProvider.prototype.required = function (keys) {\n  if (!Array.isArray(keys)) {\n    throw new Error('Incorrect parameter, array expected');\n  }\n\n  var missing = [];\n  keys.forEach(function(key) {\n    if (typeof this.get(key) === 'undefined') {\n      missing.push(key);\n    }\n  }, this);\n\n  if (missing.length) {\n    throw new Error('Missing required keys: ' + missing.join(', '));\n  } else {\n    return true;\n  }\n\n};\n\n//\n// ### function reset (callback)\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Clears all keys associated with this instance.\n//\nProvider.prototype.reset = function (callback) {\n  return this._execute('reset', 0, callback);\n};\n\n//\n// ### function clear (key, callback)\n// #### @key {string} Key to remove from this instance\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Removes the value for the specified `key` from this instance.\n//\nProvider.prototype.clear = function (key, callback) {\n  return this._execute('clear', 1, key, callback);\n};\n\n//\n// ### function merge ([key,] value [, callback])\n// #### @key {string} Key to merge the value into\n// #### @value {literal|Object} Value to merge into the key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Merges the properties in `value` into the existing object value at `key`.\n//\n// 1. If the existing value `key` is not an Object, it will be completely overwritten.\n// 2. If `key` is not supplied, then the `value` will be merged into the root.\n//\nProvider.prototype.merge = function () {\n  var self = this,\n      args = Array.prototype.slice.call(arguments),\n      callback = typeof args[args.length - 1] === 'function' && args.pop(),\n      value = args.pop(),\n      key = args.pop();\n\n  function mergeProperty (prop, next) {\n    return self._execute('merge', 2, prop, value[prop], next);\n  }\n\n  if (!key) {\n    if (Array.isArray(value) || typeof value !== 'object') {\n      return onError(new Error('Cannot merge non-Object into top-level.'), callback);\n    }\n\n    return async.forEach(Object.keys(value), mergeProperty, callback || function () { })\n  }\n\n  return this._execute('merge', 2, key, value, callback);\n};\n\n//\n// ### function load (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an Object representing all keys associated in this instance.\n//\nProvider.prototype.load = function (callback) {\n  var self = this;\n\n  function getStores () {\n    var stores = Object.keys(self.stores);\n    stores.reverse();\n    return stores.map(function (name) {\n      return self.stores[name];\n    });\n  }\n\n  function loadStoreSync(store) {\n    if (!store.loadSync) {\n      throw new Error('nconf store ' + store.type + ' has no loadSync() method');\n    }\n\n    return store.loadSync();\n  }\n\n  function loadStore(store, next) {\n    if (!store.load && !store.loadSync) {\n      return next(new Error('nconf store ' + store.type + ' has no load() method'));\n    }\n\n    return store.loadSync\n      ? next(null, store.loadSync())\n      : store.load(next);\n  }\n\n  function loadBatch (targets, done) {\n    if (!done) {\n      return common.merge(targets.map(loadStoreSync));\n    }\n\n    async.map(targets, loadStore, function (err, objs) {\n      return err ? done(err) : done(null, common.merge(objs));\n    });\n  }\n\n  function mergeSources (data) {\n    //\n    // If `data` was returned then merge it into\n    // the system store.\n    //\n    if (data && typeof data === 'object') {\n      self.use('sources', {\n        type: 'literal',\n        store: data\n      });\n    }\n  }\n\n  function loadSources () {\n    var sourceHierarchy = self.sources.splice(0);\n    sourceHierarchy.reverse();\n\n    //\n    // If we don't have a callback and the current\n    // store is capable of loading synchronously\n    // then do so.\n    //\n    if (!callback) {\n      mergeSources(loadBatch(sourceHierarchy));\n      return loadBatch(getStores());\n    }\n\n    loadBatch(sourceHierarchy, function (err, data) {\n      if (err) {\n        return callback(err);\n      }\n\n      mergeSources(data);\n      return loadBatch(getStores(), callback);\n    });\n  }\n\n  return self.sources.length\n    ? loadSources()\n    : loadBatch(getStores(), callback);\n};\n\n//\n// ### function save (callback)\n// #### @callback {function} **optional**  Continuation to respond to when\n// complete.\n// Instructs each provider to save.  If a callback is provided, we will attempt\n// asynchronous saves on the providers, falling back to synchronous saves if\n// this isn't possible.  If a provider does not know how to save, it will be\n// ignored.  Returns an object consisting of all of the data which was\n// actually saved.\n//\nProvider.prototype.save = function (value, callback) {\n  if (!callback && typeof value === 'function') {\n    callback = value;\n    value = null;\n  }\n\n  var self = this,\n      names = Object.keys(this.stores);\n\n  function saveStoreSync(memo, name) {\n    var store = self.stores[name];\n\n    //\n    // If the `store` doesn't have a `saveSync` method,\n    // just ignore it and continue.\n    //\n    if (store.saveSync) {\n      var ret = store.saveSync();\n      if (typeof ret == 'object' && ret !== null) {\n        memo.push(ret);\n      }\n    }\n    return memo;\n  }\n\n  function saveStore(memo, name, next) {\n    var store = self.stores[name];\n\n    //\n    // If the `store` doesn't have a `save` or saveSync`\n    // method(s), just ignore it and continue.\n    //\n\n    if (store.save) {\n      return store.save(value, function (err, data) {\n        if (err) {\n          return next(err);\n        }\n\n        if (typeof data == 'object' && data !== null) {\n          memo.push(data);\n        }\n\n        next(null, memo);\n      });\n    }\n    else if (store.saveSync) {\n      memo.push(store.saveSync());\n    }\n\n    next(null, memo);\n  }\n\n  //\n  // If we don't have a callback and the current\n  // store is capable of saving synchronously\n  // then do so.\n  //\n  if (!callback) {\n    return common.merge(names.reduce(saveStoreSync, []));\n  }\n\n  async.reduce(names, [], saveStore, function (err, objs) {\n    return err ? callback(err) : callback(null, common.merge(objs));\n  });\n};\n\n//\n// ### @private function _execute (action, syncLength, [arguments])\n// #### @action {string} Action to execute on `this.store`.\n// #### @syncLength {number} Function length of the sync version.\n// #### @arguments {Array} Arguments array to apply to the action\n// Executes the specified `action` on all stores for this instance, ensuring a callback supplied\n// to a synchronous store function is still invoked.\n//\nProvider.prototype._execute = function (action, syncLength /* [arguments] */) {\n  var args = Array.prototype.slice.call(arguments, 2),\n      callback = typeof args[args.length - 1] === 'function' && args.pop(),\n      destructive = ['set', 'clear', 'merge', 'reset'].indexOf(action) !== -1,\n      self = this,\n      response,\n      mergeObjs = [],\n      keys = Object.keys(this.stores);\n\n\n  function runAction (name, next) {\n    var store = self.stores[name];\n\n    if (destructive && store.readOnly) {\n      return next();\n    }\n\n    return store[action].length > syncLength\n      ? store[action].apply(store, args.concat(next))\n      : next(null, store[action].apply(store, args));\n  }\n\n  if (callback) {\n    return async.forEach(keys, runAction, function (err) {\n      return err ? callback(err) : callback();\n    });\n  }\n\n  keys.forEach(function (name) {\n    if (typeof response === 'undefined') {\n      var store = self.stores[name];\n\n      if (destructive && store.readOnly) {\n        return;\n      }\n\n      response = store[action].apply(store, args);\n\n      // Merge objects if necessary\n      if (response && action === 'get' && typeof response === 'object' && !Array.isArray(response)) {\n        mergeObjs.push(response);\n        response = undefined;\n      }\n    }\n  });\n\n  if (mergeObjs.length) {\n    response = common.merge(mergeObjs.reverse());\n  }\n\n  return response;\n}\n\n//\n// Throw the `err` if a callback is not supplied\n//\nfunction onError(err, callback) {\n  if (callback) {\n    return callback(err);\n  }\n\n  throw err;\n}\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC;EACxBC,MAAM,GAAGD,OAAO,CAAC,UAAU,CAAC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA,IAAIE,QAAQ,GAAGC,OAAO,CAACD,QAAQ,GAAG,UAAUE,OAAO,EAAE;EACnD;EACA;EACA;EACA;EACAA,OAAO,GAASA,OAAO,IAAI,CAAC,CAAC;EAC7B,IAAI,CAACC,MAAM,GAAI,CAAC,CAAC;EACjB,IAAI,CAACC,OAAO,GAAG,EAAE;EACjB,IAAI,CAACC,IAAI,CAACH,OAAO,CAAC;AACpB,CAAC;;AAED;AACA;AACA;AACA;;AAEA,CAAC,MAAM,EAAE,KAAK,CAAC,CAACI,OAAO,CAAC,UAAUC,IAAI,EAAE;EACtCP,QAAQ,CAACQ,SAAS,CAACD,IAAI,CAAC,GAAG,YAAY;IACrC,IAAIE,IAAI,GAAG,CAACF,IAAI,CAAC,CAACG,MAAM,CAACC,KAAK,CAACH,SAAS,CAACI,KAAK,CAACC,IAAI,CAACC,SAAS,CAAC,CAAC;IAC/D,OAAO,IAAI,CAACC,GAAG,CAACC,KAAK,CAAC,IAAI,EAAEP,IAAI,CAAC;EACnC,CAAC;AACH,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAT,QAAQ,CAACQ,SAAS,CAACS,IAAI,GAAG,UAAUC,GAAG,EAAEhB,OAAO,EAAE;EAChD,IAAIY,SAAS,CAACK,MAAM,IAAI,CAAC,EAAE;IACzBjB,OAAO,GAAG,OAAOgB,GAAG,KAAK,QAAQ,GAAG;MAAED,IAAI,EAAEC;IAAI,CAAC,GAAGA,GAAG;IACvDA,GAAG,GAAG,MAAM;EACd,CAAC,MACI;IACHhB,OAAO,GAAG,OAAOA,OAAO,KAAK,QAAQ,GACjC;MAAEe,IAAI,EAAEf;IAAQ,CAAC,GACjBA,OAAO;EACb;EAEAA,OAAO,CAACK,IAAI,GAAG,MAAM;EACrB,OAAO,IAAI,CAACQ,GAAG,CAACG,GAAG,EAAEhB,OAAO,CAAC;AAC/B,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC,UAAU,EAAE,WAAW,CAAC,CAACI,OAAO,CAAC,UAAUC,IAAI,EAAE;EAChDP,QAAQ,CAACQ,SAAS,CAACD,IAAI,CAAC,GAAG,UAAUL,OAAO,EAAE;IAC5CA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;IACvB,IAAI,CAACA,OAAO,CAACK,IAAI,EAAE;MACjBL,OAAO,CAACK,IAAI,GAAG,SAAS;IAC1B;IAEA,OAAO,IAAI,CAACQ,GAAG,CAACR,IAAI,EAAEL,OAAO,CAAC;EAChC,CAAC;AACH,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAF,QAAQ,CAACQ,SAAS,CAACY,GAAG,GAAG,UAAUC,IAAI,EAAEnB,OAAO,EAAE;EAChDA,OAAO,GAAIA,OAAO,IAAS,CAAC,CAAC;EAE7B,SAASoB,WAAWA,CAAEC,KAAK,EAAE;IAC3B,OAAOC,MAAM,CAACC,IAAI,CAACvB,OAAO,CAAC,CAACwB,KAAK,CAAC,UAAUR,GAAG,EAAE;MAC/C,OAAOhB,OAAO,CAACgB,GAAG,CAAC,KAAKK,KAAK,CAACL,GAAG,CAAC;IACpC,CAAC,CAAC;EACJ;EAEA,IAAIK,KAAK,GAAG,IAAI,CAACpB,MAAM,CAACkB,IAAI,CAAC;IACzBM,MAAM,GAAGJ,KAAK,IAAI,CAACD,WAAW,CAACC,KAAK,CAAC;EAEzC,IAAI,CAACA,KAAK,IAAII,MAAM,EAAE;IACpB,IAAIA,MAAM,EAAE;MACV,IAAI,CAACC,MAAM,CAACP,IAAI,CAAC;IACnB;IAEA,IAAI,CAACN,GAAG,CAACM,IAAI,EAAEnB,OAAO,CAAC;EACzB;EAEA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAF,QAAQ,CAACQ,SAAS,CAACO,GAAG,GAAG,UAAUM,IAAI,EAAEnB,OAAO,EAAE2B,KAAK,EAAE;EACvD3B,OAAO,GAAIA,OAAO,IAAS,CAAC,CAAC;EAC7B,IAAIK,IAAI,GAAGL,OAAO,CAACK,IAAI,IAAIc,IAAI;EAE/B,IAAI,CAACvB,OAAO,CAAC,UAAU,CAAC,CAACC,MAAM,CAAC+B,UAAU,CAACvB,IAAI,CAAC,CAAC,EAAE;IACjD,MAAM,IAAIwB,KAAK,CAAC,sCAAsC,GAAGxB,IAAI,CAAC;EAChE;EAEA,IAAI,CAACJ,MAAM,CAACkB,IAAI,CAAC,GAAG,IAAI,CAACW,MAAM,CAACzB,IAAI,EAAEL,OAAO,EAAE2B,KAAK,CAAC;EAErD,IAAI,IAAI,CAAC1B,MAAM,CAACkB,IAAI,CAAC,CAACY,QAAQ,EAAE;IAC9B,IAAI,CAAC9B,MAAM,CAACkB,IAAI,CAAC,CAACY,QAAQ,CAAC,CAAC;EAC9B;EAEA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAjC,QAAQ,CAACQ,SAAS,CAACoB,MAAM,GAAG,UAAUP,IAAI,EAAE;EAC1C,OAAO,IAAI,CAAClB,MAAM,CAACkB,IAAI,CAAC;EACxB,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACArB,QAAQ,CAACQ,SAAS,CAACwB,MAAM,GAAG,UAAUzB,IAAI,EAAEL,OAAO,EAAE2B,KAAK,EAAE;EAC1D,OAAO,KAAK/B,OAAO,CAAC,UAAU,CAAC,CAACC,MAAM,CAAC+B,UAAU,CAACvB,IAAI,CAAC2B,WAAW,CAAC,CAAC,CAAC,CAAC,EAAEhC,OAAO,EAAE2B,KAAK,CAAC;AACzF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA7B,QAAQ,CAACQ,SAAS,CAACH,IAAI,GAAG,UAAUH,OAAO,EAAE;EAC3C,IAAIiC,IAAI,GAAG,IAAI;;EAEf;EACA;EACA;EACA;EACA,IAAIjC,OAAO,CAACK,IAAI,EAAE;IAChB,IAAI,CAACQ,GAAG,CAACb,OAAO,CAACK,IAAI,EAAEL,OAAO,CAAC;EACjC,CAAC,MACI,IAAIA,OAAO,CAACqB,KAAK,EAAE;IACtB,IAAI,CAACR,GAAG,CAACb,OAAO,CAACqB,KAAK,CAACF,IAAI,IAAInB,OAAO,CAACqB,KAAK,CAAChB,IAAI,EAAEL,OAAO,CAACqB,KAAK,CAAC;EACnE,CAAC,MACI,IAAIrB,OAAO,CAACC,MAAM,EAAE;IACvBqB,MAAM,CAACC,IAAI,CAACvB,OAAO,CAACC,MAAM,CAAC,CAACG,OAAO,CAAC,UAAUe,IAAI,EAAE;MAClD,IAAIE,KAAK,GAAGrB,OAAO,CAACC,MAAM,CAACkB,IAAI,CAAC;MAChCc,IAAI,CAACpB,GAAG,CAACQ,KAAK,CAACF,IAAI,IAAIA,IAAI,IAAIE,KAAK,CAAChB,IAAI,EAAEgB,KAAK,CAAC;IACnD,CAAC,CAAC;EACJ;;EAEA;EACA;EACA;EACA,IAAIrB,OAAO,CAACkC,MAAM,EAAE;IAClB,IAAI,CAAChC,OAAO,CAACiC,IAAI,CAAC,IAAI,CAACL,MAAM,CAAC9B,OAAO,CAACkC,MAAM,CAAC7B,IAAI,IAAIL,OAAO,CAACkC,MAAM,CAACf,IAAI,EAAEnB,OAAO,CAACkC,MAAM,CAAC,CAAC;EAC5F,CAAC,MACI,IAAIlC,OAAO,CAACE,OAAO,EAAE;IACxBoB,MAAM,CAACC,IAAI,CAACvB,OAAO,CAACE,OAAO,CAAC,CAACE,OAAO,CAAC,UAAUe,IAAI,EAAE;MACnD,IAAIe,MAAM,GAAGlC,OAAO,CAACE,OAAO,CAACiB,IAAI,CAAC;MAClCc,IAAI,CAAC/B,OAAO,CAACiC,IAAI,CAACF,IAAI,CAACH,MAAM,CAACI,MAAM,CAAC7B,IAAI,IAAI6B,MAAM,CAACf,IAAI,IAAIA,IAAI,EAAEe,MAAM,CAAC,CAAC;IAC5E,CAAC,CAAC;EACJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACApC,QAAQ,CAACQ,SAAS,CAAC8B,GAAG,GAAG,UAAUpB,GAAG,EAAEqB,QAAQ,EAAE;EAChD,IAAI,OAAOrB,GAAG,KAAK,UAAU,EAAE;IAC7B;IACAqB,QAAQ,GAAGrB,GAAG;IACdA,GAAG,GAAG,IAAI;EACZ;;EAEA;EACA;EACA;EACA;EACA,IAAI,CAACqB,QAAQ,EAAE;IACb,OAAO,IAAI,CAACC,QAAQ,CAAC,KAAK,EAAE,CAAC,EAAEtB,GAAG,EAAEqB,QAAQ,CAAC;EAC/C;;EAEA;EACA;EACA;EACA;EACA;EACA,IAAIE,OAAO,GAAG,CAAC;IACXC,KAAK,GAAGlB,MAAM,CAACC,IAAI,CAAC,IAAI,CAACtB,MAAM,CAAC;IAChCgC,IAAI,GAAG,IAAI;IACXQ,QAAQ;IACRC,SAAS,GAAG,EAAE;EAElB/C,KAAK,CAACgD,MAAM,CAAC,UAAUC,EAAE,EAAE;IACzBA,EAAE,CAAC,IAAI,EAAE,OAAOH,QAAQ,KAAK,WAAW,IAAIF,OAAO,GAAGC,KAAK,CAACvB,MAAM,CAAC;EACrE,CAAC,EAAE,UAAU4B,IAAI,EAAE;IACjB,IAAIxB,KAAK,GAAGY,IAAI,CAAChC,MAAM,CAACuC,KAAK,CAACD,OAAO,CAAC,CAAC;IACvCA,OAAO,EAAE;IAET,IAAIlB,KAAK,CAACe,GAAG,CAACnB,MAAM,IAAI,CAAC,EAAE;MACzB,OAAOI,KAAK,CAACe,GAAG,CAACpB,GAAG,EAAE,UAAU8B,GAAG,EAAEC,KAAK,EAAE;QAC1C,IAAID,GAAG,EAAE;UACP,OAAOD,IAAI,CAACC,GAAG,CAAC;QAClB;QAEAL,QAAQ,GAAGM,KAAK;;QAEhB;QACA,IAAIN,QAAQ,IAAI,OAAOA,QAAQ,KAAK,QAAQ,IAAI,CAAChC,KAAK,CAACuC,OAAO,CAACP,QAAQ,CAAC,EAAE;UACxEC,SAAS,CAACP,IAAI,CAACM,QAAQ,CAAC;UACxBA,QAAQ,GAAGQ,SAAS;QACtB;QAEAJ,IAAI,CAAC,CAAC;MACR,CAAC,CAAC;IACJ;IAEAJ,QAAQ,GAAGpB,KAAK,CAACe,GAAG,CAACpB,GAAG,CAAC;;IAEzB;IACA,IAAIyB,QAAQ,IAAI,OAAOA,QAAQ,KAAK,QAAQ,IAAI,CAAChC,KAAK,CAACuC,OAAO,CAACP,QAAQ,CAAC,EAAE;MACxEC,SAAS,CAACP,IAAI,CAACM,QAAQ,CAAC;MACxBA,QAAQ,GAAGQ,SAAS;IACtB;IAEAJ,IAAI,CAAC,CAAC;EACR,CAAC,EAAE,UAAUC,GAAG,EAAE;IAChB,IAAI,CAACA,GAAG,IAAIJ,SAAS,CAACzB,MAAM,EAAE;MAC5BwB,QAAQ,GAAG5C,MAAM,CAACqD,KAAK,CAACR,SAAS,CAACS,OAAO,CAAC,CAAC,CAAC;IAC9C;IACA,OAAOL,GAAG,GAAGT,QAAQ,CAACS,GAAG,CAAC,GAAGT,QAAQ,CAAC,IAAI,EAAEI,QAAQ,CAAC;EACvD,CAAC,CAAC;AACJ,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA3C,QAAQ,CAACQ,SAAS,CAAC8C,GAAG,GAAG,UAAU7B,IAAI,EAAEc,QAAQ,EAAE;EAEjD,IAAI,CAAC5B,KAAK,CAACuC,OAAO,CAACzB,IAAI,CAAC,EAAE;IACxBA,IAAI,GAAGd,KAAK,CAACH,SAAS,CAACI,KAAK,CAACC,IAAI,CAACC,SAAS,CAAC;IAC5C,IAAIW,IAAI,CAACN,MAAM,GAAG,CAAC,IAAI,OAAOM,IAAI,CAACA,IAAI,CAACN,MAAM,GAAG,CAAC,CAAC,KAAK,UAAU,EAAE;MAClEoB,QAAQ,GAAGd,IAAI,CAAC8B,GAAG,CAAC,CAAC;IACvB,CAAC,MAAM;MACLhB,QAAQ,GAAG,IAAI;IACjB;EACF;;EAEA;EACA;EACA;EACA;EACA,IAAI,CAACA,QAAQ,EAAE;IACb,IAAIiB,GAAG;IACP,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhC,IAAI,CAACN,MAAM,EAAE,EAAEsC,CAAC,EAAE;MACpCD,GAAG,GAAG,IAAI,CAAChB,QAAQ,CAAC,KAAK,EAAE,CAAC,EAAEf,IAAI,CAACgC,CAAC,CAAC,EAAElB,QAAQ,CAAC;MAChD,IAAIiB,GAAG,EAAE;QACP,OAAOA,GAAG;MACZ;IACF;IACA,OAAO,IAAI;EACb;EAEA,IAAIE,QAAQ,GAAG,CAAC;IACZC,MAAM;IACNxB,IAAI,GAAG,IAAI;EAEftC,KAAK,CAACgD,MAAM,CAAC,UAASC,EAAE,EAAE;IACxBA,EAAE,CAAC,IAAI,EAAE,CAACa,MAAM,IAAID,QAAQ,GAAGjC,IAAI,CAACN,MAAM,CAAC;EAC7C,CAAC,EAAE,UAAS4B,IAAI,EAAE;IAChB,IAAI7B,GAAG,GAAGO,IAAI,CAACiC,QAAQ,CAAC;IACxBA,QAAQ,EAAE;IAEVvB,IAAI,CAACG,GAAG,CAACpB,GAAG,EAAE,UAAS8B,GAAG,EAAEY,CAAC,EAAE;MAC7B,IAAIZ,GAAG,EAAE;QACPD,IAAI,CAACC,GAAG,CAAC;MACX,CAAC,MAAM;QACLW,MAAM,GAAGC,CAAC;QACVb,IAAI,CAAC,CAAC;MACR;IACF,CAAC,CAAC;EACJ,CAAC,EAAE,UAASC,GAAG,EAAE;IACf,OAAOA,GAAG,GAAGT,QAAQ,CAACS,GAAG,CAAC,GAAGT,QAAQ,CAAC,IAAI,EAAEoB,MAAM,CAAC;EACrD,CAAC,CAAC;AACJ,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA3D,QAAQ,CAACQ,SAAS,CAACqD,GAAG,GAAG,UAAU3C,GAAG,EAAE+B,KAAK,EAAEV,QAAQ,EAAE;EACvD,OAAO,IAAI,CAACC,QAAQ,CAAC,KAAK,EAAE,CAAC,EAAEtB,GAAG,EAAE+B,KAAK,EAAEV,QAAQ,CAAC;AACtD,CAAC;;AAGD;AACA;AACA;AACA;AACAvC,QAAQ,CAACQ,SAAS,CAACsD,QAAQ,GAAG,UAAUrC,IAAI,EAAE;EAC5C,IAAI,CAACd,KAAK,CAACuC,OAAO,CAACzB,IAAI,CAAC,EAAE;IACxB,MAAM,IAAIM,KAAK,CAAC,qCAAqC,CAAC;EACxD;EAEA,IAAIgC,OAAO,GAAG,EAAE;EAChBtC,IAAI,CAACnB,OAAO,CAAC,UAASY,GAAG,EAAE;IACzB,IAAI,OAAO,IAAI,CAACoB,GAAG,CAACpB,GAAG,CAAC,KAAK,WAAW,EAAE;MACxC6C,OAAO,CAAC1B,IAAI,CAACnB,GAAG,CAAC;IACnB;EACF,CAAC,EAAE,IAAI,CAAC;EAER,IAAI6C,OAAO,CAAC5C,MAAM,EAAE;IAClB,MAAM,IAAIY,KAAK,CAAC,yBAAyB,GAAGgC,OAAO,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;EACjE,CAAC,MAAM;IACL,OAAO,IAAI;EACb;AAEF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAhE,QAAQ,CAACQ,SAAS,CAACyD,KAAK,GAAG,UAAU1B,QAAQ,EAAE;EAC7C,OAAO,IAAI,CAACC,QAAQ,CAAC,OAAO,EAAE,CAAC,EAAED,QAAQ,CAAC;AAC5C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAvC,QAAQ,CAACQ,SAAS,CAAC0D,KAAK,GAAG,UAAUhD,GAAG,EAAEqB,QAAQ,EAAE;EAClD,OAAO,IAAI,CAACC,QAAQ,CAAC,OAAO,EAAE,CAAC,EAAEtB,GAAG,EAAEqB,QAAQ,CAAC;AACjD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAvC,QAAQ,CAACQ,SAAS,CAAC4C,KAAK,GAAG,YAAY;EACrC,IAAIjB,IAAI,GAAG,IAAI;IACX1B,IAAI,GAAGE,KAAK,CAACH,SAAS,CAACI,KAAK,CAACC,IAAI,CAACC,SAAS,CAAC;IAC5CyB,QAAQ,GAAG,OAAO9B,IAAI,CAACA,IAAI,CAACU,MAAM,GAAG,CAAC,CAAC,KAAK,UAAU,IAAIV,IAAI,CAAC8C,GAAG,CAAC,CAAC;IACpEN,KAAK,GAAGxC,IAAI,CAAC8C,GAAG,CAAC,CAAC;IAClBrC,GAAG,GAAGT,IAAI,CAAC8C,GAAG,CAAC,CAAC;EAEpB,SAASY,aAAaA,CAAEC,IAAI,EAAErB,IAAI,EAAE;IAClC,OAAOZ,IAAI,CAACK,QAAQ,CAAC,OAAO,EAAE,CAAC,EAAE4B,IAAI,EAAEnB,KAAK,CAACmB,IAAI,CAAC,EAAErB,IAAI,CAAC;EAC3D;EAEA,IAAI,CAAC7B,GAAG,EAAE;IACR,IAAIP,KAAK,CAACuC,OAAO,CAACD,KAAK,CAAC,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MACrD,OAAOoB,OAAO,CAAC,IAAItC,KAAK,CAAC,yCAAyC,CAAC,EAAEQ,QAAQ,CAAC;IAChF;IAEA,OAAO1C,KAAK,CAACS,OAAO,CAACkB,MAAM,CAACC,IAAI,CAACwB,KAAK,CAAC,EAAEkB,aAAa,EAAE5B,QAAQ,IAAI,YAAY,CAAE,CAAC,CAAC;EACtF;EAEA,OAAO,IAAI,CAACC,QAAQ,CAAC,OAAO,EAAE,CAAC,EAAEtB,GAAG,EAAE+B,KAAK,EAAEV,QAAQ,CAAC;AACxD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAvC,QAAQ,CAACQ,SAAS,CAAC8D,IAAI,GAAG,UAAU/B,QAAQ,EAAE;EAC5C,IAAIJ,IAAI,GAAG,IAAI;EAEf,SAASoC,SAASA,CAAA,EAAI;IACpB,IAAIpE,MAAM,GAAGqB,MAAM,CAACC,IAAI,CAACU,IAAI,CAAChC,MAAM,CAAC;IACrCA,MAAM,CAACkD,OAAO,CAAC,CAAC;IAChB,OAAOlD,MAAM,CAACqE,GAAG,CAAC,UAAUnD,IAAI,EAAE;MAChC,OAAOc,IAAI,CAAChC,MAAM,CAACkB,IAAI,CAAC;IAC1B,CAAC,CAAC;EACJ;EAEA,SAASoD,aAAaA,CAAClD,KAAK,EAAE;IAC5B,IAAI,CAACA,KAAK,CAACU,QAAQ,EAAE;MACnB,MAAM,IAAIF,KAAK,CAAC,cAAc,GAAGR,KAAK,CAAChB,IAAI,GAAG,2BAA2B,CAAC;IAC5E;IAEA,OAAOgB,KAAK,CAACU,QAAQ,CAAC,CAAC;EACzB;EAEA,SAASyC,SAASA,CAACnD,KAAK,EAAEwB,IAAI,EAAE;IAC9B,IAAI,CAACxB,KAAK,CAAC+C,IAAI,IAAI,CAAC/C,KAAK,CAACU,QAAQ,EAAE;MAClC,OAAOc,IAAI,CAAC,IAAIhB,KAAK,CAAC,cAAc,GAAGR,KAAK,CAAChB,IAAI,GAAG,uBAAuB,CAAC,CAAC;IAC/E;IAEA,OAAOgB,KAAK,CAACU,QAAQ,GACjBc,IAAI,CAAC,IAAI,EAAExB,KAAK,CAACU,QAAQ,CAAC,CAAC,CAAC,GAC5BV,KAAK,CAAC+C,IAAI,CAACvB,IAAI,CAAC;EACtB;EAEA,SAAS4B,SAASA,CAAEC,OAAO,EAAEC,IAAI,EAAE;IACjC,IAAI,CAACA,IAAI,EAAE;MACT,OAAO9E,MAAM,CAACqD,KAAK,CAACwB,OAAO,CAACJ,GAAG,CAACC,aAAa,CAAC,CAAC;IACjD;IAEA5E,KAAK,CAAC2E,GAAG,CAACI,OAAO,EAAEF,SAAS,EAAE,UAAU1B,GAAG,EAAE8B,IAAI,EAAE;MACjD,OAAO9B,GAAG,GAAG6B,IAAI,CAAC7B,GAAG,CAAC,GAAG6B,IAAI,CAAC,IAAI,EAAE9E,MAAM,CAACqD,KAAK,CAAC0B,IAAI,CAAC,CAAC;IACzD,CAAC,CAAC;EACJ;EAEA,SAASC,YAAYA,CAAEC,IAAI,EAAE;IAC3B;IACA;IACA;IACA;IACA,IAAIA,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MACpC7C,IAAI,CAACf,GAAG,CAAC,SAAS,EAAE;QAClBb,IAAI,EAAE,SAAS;QACfgB,KAAK,EAAEyD;MACT,CAAC,CAAC;IACJ;EACF;EAEA,SAASC,WAAWA,CAAA,EAAI;IACtB,IAAIC,eAAe,GAAG/C,IAAI,CAAC/B,OAAO,CAAC+E,MAAM,CAAC,CAAC,CAAC;IAC5CD,eAAe,CAAC7B,OAAO,CAAC,CAAC;;IAEzB;IACA;IACA;IACA;IACA;IACA,IAAI,CAACd,QAAQ,EAAE;MACbwC,YAAY,CAACJ,SAAS,CAACO,eAAe,CAAC,CAAC;MACxC,OAAOP,SAAS,CAACJ,SAAS,CAAC,CAAC,CAAC;IAC/B;IAEAI,SAAS,CAACO,eAAe,EAAE,UAAUlC,GAAG,EAAEgC,IAAI,EAAE;MAC9C,IAAIhC,GAAG,EAAE;QACP,OAAOT,QAAQ,CAACS,GAAG,CAAC;MACtB;MAEA+B,YAAY,CAACC,IAAI,CAAC;MAClB,OAAOL,SAAS,CAACJ,SAAS,CAAC,CAAC,EAAEhC,QAAQ,CAAC;IACzC,CAAC,CAAC;EACJ;EAEA,OAAOJ,IAAI,CAAC/B,OAAO,CAACe,MAAM,GACtB8D,WAAW,CAAC,CAAC,GACbN,SAAS,CAACJ,SAAS,CAAC,CAAC,EAAEhC,QAAQ,CAAC;AACtC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAvC,QAAQ,CAACQ,SAAS,CAAC4E,IAAI,GAAG,UAAUnC,KAAK,EAAEV,QAAQ,EAAE;EACnD,IAAI,CAACA,QAAQ,IAAI,OAAOU,KAAK,KAAK,UAAU,EAAE;IAC5CV,QAAQ,GAAGU,KAAK;IAChBA,KAAK,GAAG,IAAI;EACd;EAEA,IAAId,IAAI,GAAG,IAAI;IACXO,KAAK,GAAGlB,MAAM,CAACC,IAAI,CAAC,IAAI,CAACtB,MAAM,CAAC;EAEpC,SAASkF,aAAaA,CAACC,IAAI,EAAEjE,IAAI,EAAE;IACjC,IAAIE,KAAK,GAAGY,IAAI,CAAChC,MAAM,CAACkB,IAAI,CAAC;;IAE7B;IACA;IACA;IACA;IACA,IAAIE,KAAK,CAACgE,QAAQ,EAAE;MAClB,IAAIC,GAAG,GAAGjE,KAAK,CAACgE,QAAQ,CAAC,CAAC;MAC1B,IAAI,OAAOC,GAAG,IAAI,QAAQ,IAAIA,GAAG,KAAK,IAAI,EAAE;QAC1CF,IAAI,CAACjD,IAAI,CAACmD,GAAG,CAAC;MAChB;IACF;IACA,OAAOF,IAAI;EACb;EAEA,SAASG,SAASA,CAACH,IAAI,EAAEjE,IAAI,EAAE0B,IAAI,EAAE;IACnC,IAAIxB,KAAK,GAAGY,IAAI,CAAChC,MAAM,CAACkB,IAAI,CAAC;;IAE7B;IACA;IACA;IACA;;IAEA,IAAIE,KAAK,CAAC6D,IAAI,EAAE;MACd,OAAO7D,KAAK,CAAC6D,IAAI,CAACnC,KAAK,EAAE,UAAUD,GAAG,EAAEgC,IAAI,EAAE;QAC5C,IAAIhC,GAAG,EAAE;UACP,OAAOD,IAAI,CAACC,GAAG,CAAC;QAClB;QAEA,IAAI,OAAOgC,IAAI,IAAI,QAAQ,IAAIA,IAAI,KAAK,IAAI,EAAE;UAC5CM,IAAI,CAACjD,IAAI,CAAC2C,IAAI,CAAC;QACjB;QAEAjC,IAAI,CAAC,IAAI,EAAEuC,IAAI,CAAC;MAClB,CAAC,CAAC;IACJ,CAAC,MACI,IAAI/D,KAAK,CAACgE,QAAQ,EAAE;MACvBD,IAAI,CAACjD,IAAI,CAACd,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC;IAC7B;IAEAxC,IAAI,CAAC,IAAI,EAAEuC,IAAI,CAAC;EAClB;;EAEA;EACA;EACA;EACA;EACA;EACA,IAAI,CAAC/C,QAAQ,EAAE;IACb,OAAOxC,MAAM,CAACqD,KAAK,CAACV,KAAK,CAACgD,MAAM,CAACL,aAAa,EAAE,EAAE,CAAC,CAAC;EACtD;EAEAxF,KAAK,CAAC6F,MAAM,CAAChD,KAAK,EAAE,EAAE,EAAE+C,SAAS,EAAE,UAAUzC,GAAG,EAAE8B,IAAI,EAAE;IACtD,OAAO9B,GAAG,GAAGT,QAAQ,CAACS,GAAG,CAAC,GAAGT,QAAQ,CAAC,IAAI,EAAExC,MAAM,CAACqD,KAAK,CAAC0B,IAAI,CAAC,CAAC;EACjE,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA9E,QAAQ,CAACQ,SAAS,CAACgC,QAAQ,GAAG,UAAUmD,MAAM,EAAEC,UAAU,CAAC,mBAAmB;EAC5E,IAAInF,IAAI,GAAGE,KAAK,CAACH,SAAS,CAACI,KAAK,CAACC,IAAI,CAACC,SAAS,EAAE,CAAC,CAAC;IAC/CyB,QAAQ,GAAG,OAAO9B,IAAI,CAACA,IAAI,CAACU,MAAM,GAAG,CAAC,CAAC,KAAK,UAAU,IAAIV,IAAI,CAAC8C,GAAG,CAAC,CAAC;IACpEsC,WAAW,GAAG,CAAC,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,CAAC,CAACC,OAAO,CAACH,MAAM,CAAC,KAAK,CAAC,CAAC;IACvExD,IAAI,GAAG,IAAI;IACXQ,QAAQ;IACRC,SAAS,GAAG,EAAE;IACdnB,IAAI,GAAGD,MAAM,CAACC,IAAI,CAAC,IAAI,CAACtB,MAAM,CAAC;EAGnC,SAAS4F,SAASA,CAAE1E,IAAI,EAAE0B,IAAI,EAAE;IAC9B,IAAIxB,KAAK,GAAGY,IAAI,CAAChC,MAAM,CAACkB,IAAI,CAAC;IAE7B,IAAIwE,WAAW,IAAItE,KAAK,CAACyE,QAAQ,EAAE;MACjC,OAAOjD,IAAI,CAAC,CAAC;IACf;IAEA,OAAOxB,KAAK,CAACoE,MAAM,CAAC,CAACxE,MAAM,GAAGyE,UAAU,GACpCrE,KAAK,CAACoE,MAAM,CAAC,CAAC3E,KAAK,CAACO,KAAK,EAAEd,IAAI,CAACC,MAAM,CAACqC,IAAI,CAAC,CAAC,GAC7CA,IAAI,CAAC,IAAI,EAAExB,KAAK,CAACoE,MAAM,CAAC,CAAC3E,KAAK,CAACO,KAAK,EAAEd,IAAI,CAAC,CAAC;EAClD;EAEA,IAAI8B,QAAQ,EAAE;IACZ,OAAO1C,KAAK,CAACS,OAAO,CAACmB,IAAI,EAAEsE,SAAS,EAAE,UAAU/C,GAAG,EAAE;MACnD,OAAOA,GAAG,GAAGT,QAAQ,CAACS,GAAG,CAAC,GAAGT,QAAQ,CAAC,CAAC;IACzC,CAAC,CAAC;EACJ;EAEAd,IAAI,CAACnB,OAAO,CAAC,UAAUe,IAAI,EAAE;IAC3B,IAAI,OAAOsB,QAAQ,KAAK,WAAW,EAAE;MACnC,IAAIpB,KAAK,GAAGY,IAAI,CAAChC,MAAM,CAACkB,IAAI,CAAC;MAE7B,IAAIwE,WAAW,IAAItE,KAAK,CAACyE,QAAQ,EAAE;QACjC;MACF;MAEArD,QAAQ,GAAGpB,KAAK,CAACoE,MAAM,CAAC,CAAC3E,KAAK,CAACO,KAAK,EAAEd,IAAI,CAAC;;MAE3C;MACA,IAAIkC,QAAQ,IAAIgD,MAAM,KAAK,KAAK,IAAI,OAAOhD,QAAQ,KAAK,QAAQ,IAAI,CAAChC,KAAK,CAACuC,OAAO,CAACP,QAAQ,CAAC,EAAE;QAC5FC,SAAS,CAACP,IAAI,CAACM,QAAQ,CAAC;QACxBA,QAAQ,GAAGQ,SAAS;MACtB;IACF;EACF,CAAC,CAAC;EAEF,IAAIP,SAAS,CAACzB,MAAM,EAAE;IACpBwB,QAAQ,GAAG5C,MAAM,CAACqD,KAAK,CAACR,SAAS,CAACS,OAAO,CAAC,CAAC,CAAC;EAC9C;EAEA,OAAOV,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA,SAAS0B,OAAOA,CAACrB,GAAG,EAAET,QAAQ,EAAE;EAC9B,IAAIA,QAAQ,EAAE;IACZ,OAAOA,QAAQ,CAACS,GAAG,CAAC;EACtB;EAEA,MAAMA,GAAG;AACX"}},"mtime":1674865250653},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf\\\\stores\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf\\\\stores\\\\argv.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"\"use strict\";\n\n/*\n * argv.js: Simple memory-based store for command-line arguments.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar util = require('util'),\n  common = require('../common'),\n  Memory = require('./memory').Memory;\n\n//\n// ### function Argv (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Argv nconf store, a simple abstraction\n// around the Memory store that can read command-line arguments.\n//\nvar Argv = exports.Argv = function (options, usage) {\n  Memory.call(this, options);\n  options = options || {};\n  this.type = 'argv';\n  this.readOnly = true;\n  this.options = options;\n  this.usage = usage;\n  if (typeof options.parseValues === 'boolean') {\n    this.parseValues = options.parseValues;\n    delete options.parseValues;\n  } else {\n    this.parseValues = false;\n  }\n  if (typeof options.transform === 'function') {\n    this.transform = options.transform;\n    delete options.transform;\n  } else {\n    this.transform = false;\n  }\n  if (typeof options.separator === 'string' || options.separator instanceof RegExp) {\n    this.separator = options.separator;\n    delete options.separator;\n  } else {\n    this.separator = '';\n  }\n};\n\n// Inherit from the Memory store\nutil.inherits(Argv, Memory);\n\n//\n// ### function loadSync ()\n// Loads the data passed in from `process.argv` into this instance.\n//\nArgv.prototype.loadSync = function () {\n  this.loadArgv();\n  return this.store;\n};\n\n//\n// ### function loadArgv ()\n// Loads the data passed in from the command-line arguments\n// into this instance.\n//\nArgv.prototype.loadArgv = function () {\n  var self = this,\n    yargs,\n    argv;\n  yargs = isYargs(this.options) ? this.options : typeof this.options === 'object' ? require('yargs')(process.argv.slice(2)).options(this.options) : require('yargs')(process.argv.slice(2));\n  if (typeof this.usage === 'string') {\n    yargs.usage(this.usage);\n  }\n  argv = yargs.argv;\n  if (!argv) {\n    return;\n  }\n  if (this.transform) {\n    argv = common.transform(argv, this.transform);\n  }\n  this.readOnly = false;\n  Object.keys(argv).forEach(function (key) {\n    var val = argv[key];\n    if (typeof val !== 'undefined') {\n      if (self.parseValues) {\n        val = common.parseValues(val);\n      }\n      if (self.separator) {\n        self.set(common.key.apply(common, key.split(self.separator)), val);\n      } else {\n        self.set(key, val);\n      }\n    }\n  });\n  this.showHelp = yargs.showHelp;\n  this.help = yargs.help;\n  this.readOnly = true;\n  return this.store;\n};\nfunction isYargs(obj) {\n  return (typeof obj === 'function' || typeof obj === 'object') && 'argv' in obj;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsImNvbW1vbiIsIk1lbW9yeSIsIkFyZ3YiLCJleHBvcnRzIiwib3B0aW9ucyIsInVzYWdlIiwiY2FsbCIsInR5cGUiLCJyZWFkT25seSIsInBhcnNlVmFsdWVzIiwidHJhbnNmb3JtIiwic2VwYXJhdG9yIiwiUmVnRXhwIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJsb2FkU3luYyIsImxvYWRBcmd2Iiwic3RvcmUiLCJzZWxmIiwieWFyZ3MiLCJhcmd2IiwiaXNZYXJncyIsInByb2Nlc3MiLCJzbGljZSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwidmFsIiwic2V0IiwiYXBwbHkiLCJzcGxpdCIsInNob3dIZWxwIiwiaGVscCIsIm9iaiJdLCJzb3VyY2VSb290IjoiQzpcXGNvZGVcXEZsdWlkRnJhbWV3b3JrNVxcbm9kZV9tb2R1bGVzXFwucG5wbVxcbmNvbmZAMC4xMi4wXFxub2RlX21vZHVsZXNcXG5jb25mXFxsaWJcXG5jb25mXFxzdG9yZXNcXCIsInNvdXJjZXMiOlsiYXJndi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogYXJndi5qczogU2ltcGxlIG1lbW9yeS1iYXNlZCBzdG9yZSBmb3IgY29tbWFuZC1saW5lIGFyZ3VtZW50cy5cbiAqXG4gKiAoQykgMjAxMSwgQ2hhcmxpZSBSb2JiaW5zIGFuZCB0aGUgQ29udHJpYnV0b3JzLlxuICpcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKSxcbiAgICBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKSxcbiAgICBNZW1vcnkgPSByZXF1aXJlKCcuL21lbW9yeScpLk1lbW9yeTtcblxuLy9cbi8vICMjIyBmdW5jdGlvbiBBcmd2IChvcHRpb25zKVxuLy8gIyMjIyBAb3B0aW9ucyB7T2JqZWN0fSBPcHRpb25zIGZvciB0aGlzIGluc3RhbmNlLlxuLy8gQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBBcmd2IG5jb25mIHN0b3JlLCBhIHNpbXBsZSBhYnN0cmFjdGlvblxuLy8gYXJvdW5kIHRoZSBNZW1vcnkgc3RvcmUgdGhhdCBjYW4gcmVhZCBjb21tYW5kLWxpbmUgYXJndW1lbnRzLlxuLy9cbnZhciBBcmd2ID0gZXhwb3J0cy5Bcmd2ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHVzYWdlKSB7XG4gIE1lbW9yeS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIG9wdGlvbnMgICAgICAgID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy50eXBlICAgICA9ICdhcmd2JztcbiAgdGhpcy5yZWFkT25seSA9IHRydWU7XG4gIHRoaXMub3B0aW9ucyAgPSBvcHRpb25zO1xuICB0aGlzLnVzYWdlICAgID0gdXNhZ2U7XG4gIGlmKHR5cGVvZiBvcHRpb25zLnBhcnNlVmFsdWVzID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMucGFyc2VWYWx1ZXMgPSBvcHRpb25zLnBhcnNlVmFsdWVzO1xuICAgICAgZGVsZXRlIG9wdGlvbnMucGFyc2VWYWx1ZXM7XG4gIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcnNlVmFsdWVzID0gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJynCoHtcbiAgICAgIHRoaXMudHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG4gICAgICBkZWxldGUgb3B0aW9ucy50cmFuc2Zvcm07XG4gIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5zZXBhcmF0b3IgPT09ICdzdHJpbmcnIHx8IG9wdGlvbnMuc2VwYXJhdG9yIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgdGhpcy5zZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvcjtcbiAgICBkZWxldGUgb3B0aW9ucy5zZXBhcmF0b3I7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZXBhcmF0b3IgPSAnJztcbiAgfVxufTtcblxuLy8gSW5oZXJpdCBmcm9tIHRoZSBNZW1vcnkgc3RvcmVcbnV0aWwuaW5oZXJpdHMoQXJndiwgTWVtb3J5KTtcblxuLy9cbi8vICMjIyBmdW5jdGlvbiBsb2FkU3luYyAoKVxuLy8gTG9hZHMgdGhlIGRhdGEgcGFzc2VkIGluIGZyb20gYHByb2Nlc3MuYXJndmAgaW50byB0aGlzIGluc3RhbmNlLlxuLy9cbkFyZ3YucHJvdG90eXBlLmxvYWRTeW5jID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxvYWRBcmd2KCk7XG4gIHJldHVybiB0aGlzLnN0b3JlO1xufTtcblxuLy9cbi8vICMjIyBmdW5jdGlvbiBsb2FkQXJndiAoKVxuLy8gTG9hZHMgdGhlIGRhdGEgcGFzc2VkIGluIGZyb20gdGhlIGNvbW1hbmQtbGluZSBhcmd1bWVudHNcbi8vIGludG8gdGhpcyBpbnN0YW5jZS5cbi8vXG5Bcmd2LnByb3RvdHlwZS5sb2FkQXJndiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgeWFyZ3MsIGFyZ3Y7XG5cbiAgeWFyZ3MgPSBpc1lhcmdzKHRoaXMub3B0aW9ucykgP1xuICAgIHRoaXMub3B0aW9ucyA6XG4gICAgdHlwZW9mIHRoaXMub3B0aW9ucyA9PT0gJ29iamVjdCcgP1xuICAgICAgcmVxdWlyZSgneWFyZ3MnKShwcm9jZXNzLmFyZ3Yuc2xpY2UoMikpLm9wdGlvbnModGhpcy5vcHRpb25zKSA6XG4gICAgICByZXF1aXJlKCd5YXJncycpKHByb2Nlc3MuYXJndi5zbGljZSgyKSk7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLnVzYWdlID09PSAnc3RyaW5nJykgeyB5YXJncy51c2FnZSh0aGlzLnVzYWdlKSB9XG5cbiAgYXJndiA9IHlhcmdzLmFyZ3ZcblxuICBpZiAoIWFyZ3YpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy50cmFuc2Zvcm0pIHtcbiAgICBhcmd2ID0gY29tbW9uLnRyYW5zZm9ybShhcmd2LCB0aGlzLnRyYW5zZm9ybSk7XG4gIH1cblxuICB0aGlzLnJlYWRPbmx5ID0gZmFsc2U7XG4gIE9iamVjdC5rZXlzKGFyZ3YpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSBhcmd2W2tleV07XG5cbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChzZWxmLnBhcnNlVmFsdWVzKSB7XG4gICAgICAgIHZhbCA9IGNvbW1vbi5wYXJzZVZhbHVlcyh2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5zZXBhcmF0b3IpIHtcbiAgICAgICAgc2VsZi5zZXQoY29tbW9uLmtleS5hcHBseShjb21tb24sIGtleS5zcGxpdChzZWxmLnNlcGFyYXRvcikpLCB2YWwpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYuc2V0KGtleSwgdmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuc2hvd0hlbHAgPSB5YXJncy5zaG93SGVscFxuICB0aGlzLmhlbHAgICAgID0geWFyZ3MuaGVscFxuXG4gIHRoaXMucmVhZE9ubHkgPSB0cnVlO1xuICByZXR1cm4gdGhpcy5zdG9yZTtcbn07XG5cbmZ1bmN0aW9uIGlzWWFyZ3Mob2JqKSB7XG4gIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JykgJiYgKCdhcmd2JyBpbiBvYmopO1xufVxuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJQSxJQUFJLEdBQUdDLE9BQU8sQ0FBQyxNQUFNLENBQUM7RUFDdEJDLE1BQU0sR0FBR0QsT0FBTyxDQUFDLFdBQVcsQ0FBQztFQUM3QkUsTUFBTSxHQUFHRixPQUFPLENBQUMsVUFBVSxDQUFDLENBQUNFLE1BQU07O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUlDLElBQUksR0FBR0MsT0FBTyxDQUFDRCxJQUFJLEdBQUcsVUFBVUUsT0FBTyxFQUFFQyxLQUFLLEVBQUU7RUFDbERK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","map":{"version":3,"names":["util","require","common","Memory","Argv","exports","options","usage","call","type","readOnly","parseValues","transform","separator","RegExp","inherits","prototype","loadSync","loadArgv","store","self","yargs","argv","isYargs","process","slice","Object","keys","forEach","key","val","set","apply","split","showHelp","help","obj"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\nconf@0.12.0\\node_modules\\nconf\\lib\\nconf\\stores\\","sources":["argv.js"],"sourcesContent":["/*\n * argv.js: Simple memory-based store for command-line arguments.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar util = require('util'),\n    common = require('../common'),\n    Memory = require('./memory').Memory;\n\n//\n// ### function Argv (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Argv nconf store, a simple abstraction\n// around the Memory store that can read command-line arguments.\n//\nvar Argv = exports.Argv = function (options, usage) {\n  Memory.call(this, options);\n\n  options        = options || {};\n  this.type     = 'argv';\n  this.readOnly = true;\n  this.options  = options;\n  this.usage    = usage;\n  if(typeof options.parseValues === 'boolean') {\n      this.parseValues = options.parseValues;\n      delete options.parseValues;\n  } else {\n      this.parseValues = false;\n  }\n  if (typeof options.transform === 'function') {\n      this.transform = options.transform;\n      delete options.transform;\n  } else {\n      this.transform = false;\n  }\n  if (typeof options.separator === 'string' || options.separator instanceof RegExp) {\n    this.separator = options.separator;\n    delete options.separator;\n  } else {\n    this.separator = '';\n  }\n};\n\n// Inherit from the Memory store\nutil.inherits(Argv, Memory);\n\n//\n// ### function loadSync ()\n// Loads the data passed in from `process.argv` into this instance.\n//\nArgv.prototype.loadSync = function () {\n  this.loadArgv();\n  return this.store;\n};\n\n//\n// ### function loadArgv ()\n// Loads the data passed in from the command-line arguments\n// into this instance.\n//\nArgv.prototype.loadArgv = function () {\n  var self = this,\n      yargs, argv;\n\n  yargs = isYargs(this.options) ?\n    this.options :\n    typeof this.options === 'object' ?\n      require('yargs')(process.argv.slice(2)).options(this.options) :\n      require('yargs')(process.argv.slice(2));\n\n  if (typeof this.usage === 'string') { yargs.usage(this.usage) }\n\n  argv = yargs.argv\n\n  if (!argv) {\n    return;\n  }\n\n  if (this.transform) {\n    argv = common.transform(argv, this.transform);\n  }\n\n  this.readOnly = false;\n  Object.keys(argv).forEach(function (key) {\n    var val = argv[key];\n\n    if (typeof val !== 'undefined') {\n      if (self.parseValues) {\n        val = common.parseValues(val);\n      }\n\n      if (self.separator) {\n        self.set(common.key.apply(common, key.split(self.separator)), val);\n      }\n      else {\n        self.set(key, val);\n      }\n    }\n  });\n\n  this.showHelp = yargs.showHelp\n  this.help     = yargs.help\n\n  this.readOnly = true;\n  return this.store;\n};\n\nfunction isYargs(obj) {\n  return (typeof obj === 'function' || typeof obj === 'object') && ('argv' in obj);\n}\n"],"mappings":"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"}},"mtime":1674865250449},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\yargs@16.2.0\\\\node_modules\\\\yargs\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\yargs@16.2.0\\\\node_modules\\\\yargs\\\\index.cjs\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"'use strict';\n\n// classic singleton yargs API, to use yargs\n// without running as a singleton do:\n// require('yargs/yargs')(process.argv.slice(2))\nconst {\n  Yargs,\n  processArgv\n} = require('./build/index.cjs');\nArgv(processArgv.hideBin(process.argv));\nmodule.exports = Argv;\nfunction Argv(processArgs, cwd) {\n  const argv = Yargs(processArgs, cwd, require);\n  singletonify(argv);\n  return argv;\n}\n\n/*  Hack an instance of Argv with process.argv into Argv\n    so people can do\n    require('yargs')(['--beeble=1','-z','zizzle']).argv\n    to parse a list of args and\n    require('yargs').argv\n    to get a parsed version of process.argv.\n*/\nfunction singletonify(inst) {\n  Object.keys(inst).forEach(key => {\n    if (key === 'argv') {\n      Argv.__defineGetter__(key, inst.__lookupGetter__(key));\n    } else if (typeof inst[key] === 'function') {\n      Argv[key] = inst[key].bind(inst);\n    } else {\n      Argv.__defineGetter__('$0', () => {\n        return inst.$0;\n      });\n      Argv.__defineGetter__('parsed', () => {\n        return inst.parsed;\n      });\n    }\n  });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJZYXJncyIsInByb2Nlc3NBcmd2IiwicmVxdWlyZSIsIkFyZ3YiLCJoaWRlQmluIiwicHJvY2VzcyIsImFyZ3YiLCJtb2R1bGUiLCJleHBvcnRzIiwicHJvY2Vzc0FyZ3MiLCJjd2QiLCJzaW5nbGV0b25pZnkiLCJpbnN0IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJfX2RlZmluZUdldHRlcl9fIiwiX19sb29rdXBHZXR0ZXJfXyIsImJpbmQiLCIkMCIsInBhcnNlZCJdLCJzb3VyY2VSb290IjoiQzpcXGNvZGVcXEZsdWlkRnJhbWV3b3JrNVxcbm9kZV9tb2R1bGVzXFwucG5wbVxceWFyZ3NAMTYuMi4wXFxub2RlX21vZHVsZXNcXHlhcmdzXFwiLCJzb3VyY2VzIjpbImluZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBjbGFzc2ljIHNpbmdsZXRvbiB5YXJncyBBUEksIHRvIHVzZSB5YXJnc1xuLy8gd2l0aG91dCBydW5uaW5nIGFzIGEgc2luZ2xldG9uIGRvOlxuLy8gcmVxdWlyZSgneWFyZ3MveWFyZ3MnKShwcm9jZXNzLmFyZ3Yuc2xpY2UoMikpXG5jb25zdCB7WWFyZ3MsIHByb2Nlc3NBcmd2fSA9IHJlcXVpcmUoJy4vYnVpbGQvaW5kZXguY2pzJyk7XG5cbkFyZ3YocHJvY2Vzc0FyZ3YuaGlkZUJpbihwcm9jZXNzLmFyZ3YpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcmd2O1xuXG5mdW5jdGlvbiBBcmd2KHByb2Nlc3NBcmdzLCBjd2QpIHtcbiAgY29uc3QgYXJndiA9IFlhcmdzKHByb2Nlc3NBcmdzLCBjd2QsIHJlcXVpcmUpO1xuICBzaW5nbGV0b25pZnkoYXJndik7XG4gIHJldHVybiBhcmd2O1xufVxuXG4vKiAgSGFjayBhbiBpbnN0YW5jZSBvZiBBcmd2IHdpdGggcHJvY2Vzcy5hcmd2IGludG8gQXJndlxuICAgIHNvIHBlb3BsZSBjYW4gZG9cbiAgICByZXF1aXJlKCd5YXJncycpKFsnLS1iZWVibGU9MScsJy16Jywneml6emxlJ10pLmFyZ3ZcbiAgICB0byBwYXJzZSBhIGxpc3Qgb2YgYXJncyBhbmRcbiAgICByZXF1aXJlKCd5YXJncycpLmFyZ3ZcbiAgICB0byBnZXQgYSBwYXJzZWQgdmVyc2lvbiBvZiBwcm9jZXNzLmFyZ3YuXG4qL1xuZnVuY3Rpb24gc2luZ2xldG9uaWZ5KGluc3QpIHtcbiAgT2JqZWN0LmtleXMoaW5zdCkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmIChrZXkgPT09ICdhcmd2Jykge1xuICAgICAgQXJndi5fX2RlZmluZUdldHRlcl9fKGtleSwgaW5zdC5fX2xvb2t1cEdldHRlcl9fKGtleSkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgQXJndltrZXldID0gaW5zdFtrZXldLmJpbmQoaW5zdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEFyZ3YuX19kZWZpbmVHZXR0ZXJfXygnJDAnLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiBpbnN0LiQwO1xuICAgICAgfSk7XG4gICAgICBBcmd2Ll9fZGVmaW5lR2V0dGVyX18oJ3BhcnNlZCcsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGluc3QucGFyc2VkO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFDWjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0VBQUNBLEtBQUs7RUFBRUM7QUFBVyxDQUFDLEdBQUdDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQztBQUV6REMsSUFBSSxDQUFDRixXQUFXLENBQUNHLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDQyxJQUFJLENBQUMsQ0FBQztBQUV2Q0MsTUFBTSxDQUFDQyxPQUFPLEdBQUdMLElBQUk7QUFFckIsU0FBU0EsSUFBSUEsQ0FBQ00sV0FBVyxFQUFFQyxHQUFHLEVBQUU7RUFDOUIsTUFBTUosSUFBSSxHQUFHTixLQUFLLENBQUNTLFdBQVcsRUFBRUMsR0FBRyxFQUFFUixPQUFPLENBQUM7RUFDN0NTLFlBQVksQ0FBQ0wsSUFBSSxDQUFDO0VBQ2xCLE9BQU9BLElBQUk7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNLLFlBQVlBLENBQUNDLElBQUksRUFBRTtFQUMxQkMsTUFBTSxDQUFDQyxJQUFJLENBQUNGLElBQUksQ0FBQyxDQUFDRyxPQUFPLENBQUNDLEdBQUcsSUFBSTtJQUMvQixJQUFJQSxHQUFHLEtBQUssTUFBTSxFQUFFO01BQ2xCYixJQUFJLENBQUNjLGdCQUFnQixDQUFDRCxHQUFHLEVBQUVKLElBQUksQ0FBQ00sZ0JBQWdCLENBQUNGLEdBQUcsQ0FBQyxDQUFDO0lBQ3hELENBQUMsTUFBTSxJQUFJLE9BQU9KLElBQUksQ0FBQ0ksR0FBRyxDQUFDLEtBQUssVUFBVSxFQUFFO01BQzFDYixJQUFJLENBQUNhLEdBQUcsQ0FBQyxHQUFHSixJQUFJLENBQUNJLEdBQUcsQ0FBQyxDQUFDRyxJQUFJLENBQUNQLElBQUksQ0FBQztJQUNsQyxDQUFDLE1BQU07TUFDTFQsSUFBSSxDQUFDYyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsTUFBTTtRQUNoQyxPQUFPTCxJQUFJLENBQUNRLEVBQUU7TUFDaEIsQ0FBQyxDQUFDO01BQ0ZqQixJQUFJLENBQUNjLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxNQUFNO1FBQ3BDLE9BQU9MLElBQUksQ0FBQ1MsTUFBTTtNQUNwQixDQUFDLENBQUM7SUFDSjtFQUNGLENBQUMsQ0FBQztBQUNKIn0=","map":{"version":3,"names":["Yargs","processArgv","require","Argv","hideBin","process","argv","module","exports","processArgs","cwd","singletonify","inst","Object","keys","forEach","key","__defineGetter__","__lookupGetter__","bind","$0","parsed"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\yargs@16.2.0\\node_modules\\yargs\\","sources":["index.cjs"],"sourcesContent":["'use strict';\n// classic singleton yargs API, to use yargs\n// without running as a singleton do:\n// require('yargs/yargs')(process.argv.slice(2))\nconst {Yargs, processArgv} = require('./build/index.cjs');\n\nArgv(processArgv.hideBin(process.argv));\n\nmodule.exports = Argv;\n\nfunction Argv(processArgs, cwd) {\n  const argv = Yargs(processArgs, cwd, require);\n  singletonify(argv);\n  return argv;\n}\n\n/*  Hack an instance of Argv with process.argv into Argv\n    so people can do\n    require('yargs')(['--beeble=1','-z','zizzle']).argv\n    to parse a list of args and\n    require('yargs').argv\n    to get a parsed version of process.argv.\n*/\nfunction singletonify(inst) {\n  Object.keys(inst).forEach(key => {\n    if (key === 'argv') {\n      Argv.__defineGetter__(key, inst.__lookupGetter__(key));\n    } else if (typeof inst[key] === 'function') {\n      Argv[key] = inst[key].bind(inst);\n    } else {\n      Argv.__defineGetter__('$0', () => {\n        return inst.$0;\n      });\n      Argv.__defineGetter__('parsed', () => {\n        return inst.parsed;\n      });\n    }\n  });\n}\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA,MAAM;EAACA,KAAK;EAAEC;AAAW,CAAC,GAAGC,OAAO,CAAC,mBAAmB,CAAC;AAEzDC,IAAI,CAACF,WAAW,CAACG,OAAO,CAACC,OAAO,CAACC,IAAI,CAAC,CAAC;AAEvCC,MAAM,CAACC,OAAO,GAAGL,IAAI;AAErB,SAASA,IAAIA,CAACM,WAAW,EAAEC,GAAG,EAAE;EAC9B,MAAMJ,IAAI,GAAGN,KAAK,CAACS,WAAW,EAAEC,GAAG,EAAER,OAAO,CAAC;EAC7CS,YAAY,CAACL,IAAI,CAAC;EAClB,OAAOA,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,YAAYA,CAACC,IAAI,EAAE;EAC1BC,MAAM,CAACC,IAAI,CAACF,IAAI,CAAC,CAACG,OAAO,CAACC,GAAG,IAAI;IAC/B,IAAIA,GAAG,KAAK,MAAM,EAAE;MAClBb,IAAI,CAACc,gBAAgB,CAACD,GAAG,EAAEJ,IAAI,CAACM,gBAAgB,CAACF,GAAG,CAAC,CAAC;IACxD,CAAC,MAAM,IAAI,OAAOJ,IAAI,CAACI,GAAG,CAAC,KAAK,UAAU,EAAE;MAC1Cb,IAAI,CAACa,GAAG,CAAC,GAAGJ,IAAI,CAACI,GAAG,CAAC,CAACG,IAAI,CAACP,IAAI,CAAC;IAClC,CAAC,MAAM;MACLT,IAAI,CAACc,gBAAgB,CAAC,IAAI,EAAE,MAAM;QAChC,OAAOL,IAAI,CAACQ,EAAE;MAChB,CAAC,CAAC;MACFjB,IAAI,CAACc,gBAAgB,CAAC,QAAQ,EAAE,MAAM;QACpC,OAAOL,IAAI,CAACS,MAAM;MACpB,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;AACJ"}},"mtime":1674865296659},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\yargs@16.2.0\\\\node_modules\\\\yargs\\\\build\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\yargs@16.2.0\\\\node_modules\\\\yargs\\\\build\\\\index.cjs\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"'use strict';\n\nvar assert = require('assert');\nclass YError extends Error {\n  constructor(msg) {\n    super(msg || 'yargs error');\n    this.name = 'YError';\n    Error.captureStackTrace(this, YError);\n  }\n}\nlet previouslyVisitedConfigs = [];\nlet shim;\nfunction applyExtends(config, cwd, mergeExtends, _shim) {\n  shim = _shim;\n  let defaultConfig = {};\n  if (Object.prototype.hasOwnProperty.call(config, 'extends')) {\n    if (typeof config.extends !== 'string') return defaultConfig;\n    const isPath = /\\.json|\\..*rc$/.test(config.extends);\n    let pathToDefault = null;\n    if (!isPath) {\n      try {\n        pathToDefault = require.resolve(config.extends);\n      } catch (_err) {\n        return config;\n      }\n    } else {\n      pathToDefault = getPathToDefaultConfig(cwd, config.extends);\n    }\n    checkForCircularExtends(pathToDefault);\n    previouslyVisitedConfigs.push(pathToDefault);\n    defaultConfig = isPath ? JSON.parse(shim.readFileSync(pathToDefault, 'utf8')) : require(config.extends);\n    delete config.extends;\n    defaultConfig = applyExtends(defaultConfig, shim.path.dirname(pathToDefault), mergeExtends, shim);\n  }\n  previouslyVisitedConfigs = [];\n  return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);\n}\nfunction checkForCircularExtends(cfgPath) {\n  if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {\n    throw new YError(`Circular extended configurations: '${cfgPath}'.`);\n  }\n}\nfunction getPathToDefaultConfig(cwd, pathToExtend) {\n  return shim.path.resolve(cwd, pathToExtend);\n}\nfunction mergeDeep(config1, config2) {\n  const target = {};\n  function isObject(obj) {\n    return obj && typeof obj === 'object' && !Array.isArray(obj);\n  }\n  Object.assign(target, config1);\n  for (const key of Object.keys(config2)) {\n    if (isObject(config2[key]) && isObject(target[key])) {\n      target[key] = mergeDeep(config1[key], config2[key]);\n    } else {\n      target[key] = config2[key];\n    }\n  }\n  return target;\n}\nfunction parseCommand(cmd) {\n  const extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ');\n  const splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/);\n  const bregex = /\\.*[\\][<>]/g;\n  const firstCommand = splitCommand.shift();\n  if (!firstCommand) throw new Error(`No command found in: ${cmd}`);\n  const parsedCommand = {\n    cmd: firstCommand.replace(bregex, ''),\n    demanded: [],\n    optional: []\n  };\n  splitCommand.forEach((cmd, i) => {\n    let variadic = false;\n    cmd = cmd.replace(/\\s/g, '');\n    if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true;\n    if (/^\\[/.test(cmd)) {\n      parsedCommand.optional.push({\n        cmd: cmd.replace(bregex, '').split('|'),\n        variadic\n      });\n    } else {\n      parsedCommand.demanded.push({\n        cmd: cmd.replace(bregex, '').split('|'),\n        variadic\n      });\n    }\n  });\n  return parsedCommand;\n}\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];\nfunction argsert(arg1, arg2, arg3) {\n  function parseArgs() {\n    return typeof arg1 === 'object' ? [{\n      demanded: [],\n      optional: []\n    }, arg1, arg2] : [parseCommand(`cmd ${arg1}`), arg2, arg3];\n  }\n  try {\n    let position = 0;\n    const [parsed, callerArguments, _length] = parseArgs();\n    const args = [].slice.call(callerArguments);\n    while (args.length && args[args.length - 1] === undefined) args.pop();\n    const length = _length || args.length;\n    if (length < parsed.demanded.length) {\n      throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);\n    }\n    const totalCommands = parsed.demanded.length + parsed.optional.length;\n    if (length > totalCommands) {\n      throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);\n    }\n    parsed.demanded.forEach(demanded => {\n      const arg = args.shift();\n      const observedType = guessType(arg);\n      const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*');\n      if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position);\n      position += 1;\n    });\n    parsed.optional.forEach(optional => {\n      if (args.length === 0) return;\n      const arg = args.shift();\n      const observedType = guessType(arg);\n      const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*');\n      if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position);\n      position += 1;\n    });\n  } catch (err) {\n    console.warn(err.stack);\n  }\n}\nfunction guessType(arg) {\n  if (Array.isArray(arg)) {\n    return 'array';\n  } else if (arg === null) {\n    return 'null';\n  }\n  return typeof arg;\n}\nfunction argumentTypeError(observedType, allowedTypes, position) {\n  throw new YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`);\n}\nfunction isPromise(maybePromise) {\n  return !!maybePromise && !!maybePromise.then && typeof maybePromise.then === 'function';\n}\nfunction assertNotStrictEqual(actual, expected, shim, message) {\n  shim.assert.notStrictEqual(actual, expected, message);\n}\nfunction assertSingleKey(actual, shim) {\n  shim.assert.strictEqual(typeof actual, 'string');\n}\nfunction objectKeys(object) {\n  return Object.keys(object);\n}\nfunction objFilter(original = {}, filter = () => true) {\n  const obj = {};\n  objectKeys(original).forEach(key => {\n    if (filter(key, original[key])) {\n      obj[key] = original[key];\n    }\n  });\n  return obj;\n}\nfunction globalMiddlewareFactory(globalMiddleware, context) {\n  return function (callback, applyBeforeValidation = false) {\n    argsert('<array|function> [boolean]', [callback, applyBeforeValidation], arguments.length);\n    if (Array.isArray(callback)) {\n      for (let i = 0; i < callback.length; i++) {\n        if (typeof callback[i] !== 'function') {\n          throw Error('middleware must be a function');\n        }\n        callback[i].applyBeforeValidation = applyBeforeValidation;\n      }\n      Array.prototype.push.apply(globalMiddleware, callback);\n    } else if (typeof callback === 'function') {\n      callback.applyBeforeValidation = applyBeforeValidation;\n      globalMiddleware.push(callback);\n    }\n    return context;\n  };\n}\nfunction commandMiddlewareFactory(commandMiddleware) {\n  if (!commandMiddleware) return [];\n  return commandMiddleware.map(middleware => {\n    middleware.applyBeforeValidation = false;\n    return middleware;\n  });\n}\nfunction applyMiddleware(argv, yargs, middlewares, beforeValidation) {\n  const beforeValidationError = new Error('middleware cannot return a promise when applyBeforeValidation is true');\n  return middlewares.reduce((acc, middleware) => {\n    if (middleware.applyBeforeValidation !== beforeValidation) {\n      return acc;\n    }\n    if (isPromise(acc)) {\n      return acc.then(initialObj => Promise.all([initialObj, middleware(initialObj, yargs)])).then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));\n    } else {\n      const result = middleware(acc, yargs);\n      if (beforeValidation && isPromise(result)) throw beforeValidationError;\n      return isPromise(result) ? result.then(middlewareObj => Object.assign(acc, middlewareObj)) : Object.assign(acc, result);\n    }\n  }, argv);\n}\nfunction getProcessArgvBinIndex() {\n  if (isBundledElectronApp()) return 0;\n  return 1;\n}\nfunction isBundledElectronApp() {\n  return isElectronApp() && !process.defaultApp;\n}\nfunction isElectronApp() {\n  return !!process.versions.electron;\n}\nfunction hideBin(argv) {\n  return argv.slice(getProcessArgvBinIndex() + 1);\n}\nfunction getProcessArgvBin() {\n  return process.argv[getProcessArgvBinIndex()];\n}\nvar processArgv = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  hideBin: hideBin,\n  getProcessArgvBin: getProcessArgvBin\n});\nfunction whichModule(exported) {\n  if (typeof require === 'undefined') return null;\n  for (let i = 0, files = Object.keys(require.cache), mod; i < files.length; i++) {\n    mod = require.cache[files[i]];\n    if (mod.exports === exported) return mod;\n  }\n  return null;\n}\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/;\nfunction command(yargs, usage, validation, globalMiddleware = [], shim) {\n  const self = {};\n  let handlers = {};\n  let aliasMap = {};\n  let defaultCommand;\n  self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {\n    let aliases = [];\n    const middlewares = commandMiddlewareFactory(commandMiddleware);\n    handler = handler || (() => {});\n    if (Array.isArray(cmd)) {\n      if (isCommandAndAliases(cmd)) {\n        [cmd, ...aliases] = cmd;\n      } else {\n        for (const command of cmd) {\n          self.addHandler(command);\n        }\n      }\n    } else if (isCommandHandlerDefinition(cmd)) {\n      let command = Array.isArray(cmd.command) || typeof cmd.command === 'string' ? cmd.command : moduleName(cmd);\n      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases);\n      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);\n      return;\n    } else if (isCommandBuilderDefinition(builder)) {\n      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);\n      return;\n    }\n    if (typeof cmd === 'string') {\n      const parsedCommand = parseCommand(cmd);\n      aliases = aliases.map(alias => parseCommand(alias).cmd);\n      let isDefault = false;\n      const parsedAliases = [parsedCommand.cmd].concat(aliases).filter(c => {\n        if (DEFAULT_MARKER.test(c)) {\n          isDefault = true;\n          return false;\n        }\n        return true;\n      });\n      if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0');\n      if (isDefault) {\n        parsedCommand.cmd = parsedAliases[0];\n        aliases = parsedAliases.slice(1);\n        cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);\n      }\n      aliases.forEach(alias => {\n        aliasMap[alias] = parsedCommand.cmd;\n      });\n      if (description !== false) {\n        usage.command(cmd, description, isDefault, aliases, deprecated);\n      }\n      handlers[parsedCommand.cmd] = {\n        original: cmd,\n        description,\n        handler,\n        builder: builder || {},\n        middlewares,\n        deprecated,\n        demanded: parsedCommand.demanded,\n        optional: parsedCommand.optional\n      };\n      if (isDefault) defaultCommand = handlers[parsedCommand.cmd];\n    }\n  };\n  self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {\n    opts = opts || {};\n    if (typeof opts.recurse !== 'boolean') opts.recurse = false;\n    if (!Array.isArray(opts.extensions)) opts.extensions = ['js'];\n    const parentVisit = typeof opts.visit === 'function' ? opts.visit : o => o;\n    opts.visit = function visit(obj, joined, filename) {\n      const visited = parentVisit(obj, joined, filename);\n      if (visited) {\n        if (~context.files.indexOf(joined)) return visited;\n        context.files.push(joined);\n        self.addHandler(visited);\n      }\n      return visited;\n    };\n    shim.requireDirectory({\n      require: req,\n      filename: callerFile\n    }, dir, opts);\n  };\n  function moduleName(obj) {\n    const mod = whichModule(obj);\n    if (!mod) throw new Error(`No command name given for module: ${shim.inspect(obj)}`);\n    return commandFromFilename(mod.filename);\n  }\n  function commandFromFilename(filename) {\n    return shim.path.basename(filename, shim.path.extname(filename));\n  }\n  function extractDesc({\n    describe,\n    description,\n    desc\n  }) {\n    for (const test of [describe, description, desc]) {\n      if (typeof test === 'string' || test === false) return test;\n      assertNotStrictEqual(test, true, shim);\n    }\n    return false;\n  }\n  self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));\n  self.getCommandHandlers = () => handlers;\n  self.hasDefaultCommand = () => !!defaultCommand;\n  self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {\n    let aliases = parsed.aliases;\n    const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;\n    const currentContext = yargs.getContext();\n    let numFiles = currentContext.files.length;\n    const parentCommands = currentContext.commands.slice();\n    let innerArgv = parsed.argv;\n    let positionalMap = {};\n    if (command) {\n      currentContext.commands.push(command);\n      currentContext.fullCommands.push(commandHandler.original);\n    }\n    const builder = commandHandler.builder;\n    if (isCommandBuilderCallback(builder)) {\n      const builderOutput = builder(yargs.reset(parsed.aliases));\n      const innerYargs = isYargsInstance(builderOutput) ? builderOutput : yargs;\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n      }\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n      aliases = innerYargs.parsed.aliases;\n    } else if (isCommandBuilderOptionDefinitions(builder)) {\n      const innerYargs = yargs.reset(parsed.aliases);\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n      }\n      Object.keys(commandHandler.builder).forEach(key => {\n        innerYargs.option(key, builder[key]);\n      });\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n      aliases = innerYargs.parsed.aliases;\n    }\n    if (!yargs._hasOutput()) {\n      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);\n    }\n    const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares);\n    applyMiddleware(innerArgv, yargs, middlewares, true);\n    if (!yargs._hasOutput()) {\n      yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error, !command);\n    }\n    if (commandHandler.handler && !yargs._hasOutput()) {\n      yargs._setHasOutput();\n      const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];\n      yargs._postProcess(innerArgv, populateDoubleDash);\n      innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);\n      let handlerResult;\n      if (isPromise(innerArgv)) {\n        handlerResult = innerArgv.then(argv => commandHandler.handler(argv));\n      } else {\n        handlerResult = commandHandler.handler(innerArgv);\n      }\n      const handlerFinishCommand = yargs.getHandlerFinishCommand();\n      if (isPromise(handlerResult)) {\n        yargs.getUsageInstance().cacheHelpMessage();\n        handlerResult.then(value => {\n          if (handlerFinishCommand) {\n            handlerFinishCommand(value);\n          }\n        }).catch(error => {\n          try {\n            yargs.getUsageInstance().fail(null, error);\n          } catch (err) {}\n        }).then(() => {\n          yargs.getUsageInstance().clearCachedHelpMessage();\n        });\n      } else {\n        if (handlerFinishCommand) {\n          handlerFinishCommand(handlerResult);\n        }\n      }\n    }\n    if (command) {\n      currentContext.commands.pop();\n      currentContext.fullCommands.pop();\n    }\n    numFiles = currentContext.files.length - numFiles;\n    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles);\n    return innerArgv;\n  };\n  function shouldUpdateUsage(yargs) {\n    return !yargs.getUsageInstance().getUsageDisabled() && yargs.getUsageInstance().getUsage().length === 0;\n  }\n  function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {\n    const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;\n    const pc = parentCommands.filter(c => {\n      return !DEFAULT_MARKER.test(c);\n    });\n    pc.push(c);\n    return `$0 ${pc.join(' ')}`;\n  }\n  self.runDefaultBuilderOn = function (yargs) {\n    assertNotStrictEqual(defaultCommand, undefined, shim);\n    if (shouldUpdateUsage(yargs)) {\n      const commandString = DEFAULT_MARKER.test(defaultCommand.original) ? defaultCommand.original : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ');\n      yargs.getUsageInstance().usage(commandString, defaultCommand.description);\n    }\n    const builder = defaultCommand.builder;\n    if (isCommandBuilderCallback(builder)) {\n      builder(yargs);\n    } else if (!isCommandBuilderDefinition(builder)) {\n      Object.keys(builder).forEach(key => {\n        yargs.option(key, builder[key]);\n      });\n    }\n  };\n  function populatePositionals(commandHandler, argv, context) {\n    argv._ = argv._.slice(context.commands.length);\n    const demanded = commandHandler.demanded.slice(0);\n    const optional = commandHandler.optional.slice(0);\n    const positionalMap = {};\n    validation.positionalCount(demanded.length, argv._.length);\n    while (demanded.length) {\n      const demand = demanded.shift();\n      populatePositional(demand, argv, positionalMap);\n    }\n    while (optional.length) {\n      const maybe = optional.shift();\n      populatePositional(maybe, argv, positionalMap);\n    }\n    argv._ = context.commands.concat(argv._.map(a => '' + a));\n    postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));\n    return positionalMap;\n  }\n  function populatePositional(positional, argv, positionalMap) {\n    const cmd = positional.cmd[0];\n    if (positional.variadic) {\n      positionalMap[cmd] = argv._.splice(0).map(String);\n    } else {\n      if (argv._.length) positionalMap[cmd] = [String(argv._.shift())];\n    }\n  }\n  function postProcessPositionals(argv, positionalMap, parseOptions) {\n    const options = Object.assign({}, yargs.getOptions());\n    options.default = Object.assign(parseOptions.default, options.default);\n    for (const key of Object.keys(parseOptions.alias)) {\n      options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);\n    }\n    options.array = options.array.concat(parseOptions.array);\n    options.config = {};\n    const unparsed = [];\n    Object.keys(positionalMap).forEach(key => {\n      positionalMap[key].map(value => {\n        if (options.configuration['unknown-options-as-args']) options.key[key] = true;\n        unparsed.push(`--${key}`);\n        unparsed.push(value);\n      });\n    });\n    if (!unparsed.length) return;\n    const config = Object.assign({}, options.configuration, {\n      'populate--': true\n    });\n    const parsed = shim.Parser.detailed(unparsed, Object.assign({}, options, {\n      configuration: config\n    }));\n    if (parsed.error) {\n      yargs.getUsageInstance().fail(parsed.error.message, parsed.error);\n    } else {\n      const positionalKeys = Object.keys(positionalMap);\n      Object.keys(positionalMap).forEach(key => {\n        positionalKeys.push(...parsed.aliases[key]);\n      });\n      Object.keys(parsed.argv).forEach(key => {\n        if (positionalKeys.indexOf(key) !== -1) {\n          if (!positionalMap[key]) positionalMap[key] = parsed.argv[key];\n          argv[key] = parsed.argv[key];\n        }\n      });\n    }\n  }\n  self.cmdToParseOptions = function (cmdString) {\n    const parseOptions = {\n      array: [],\n      default: {},\n      alias: {},\n      demand: {}\n    };\n    const parsed = parseCommand(cmdString);\n    parsed.demanded.forEach(d => {\n      const [cmd, ...aliases] = d.cmd;\n      if (d.variadic) {\n        parseOptions.array.push(cmd);\n        parseOptions.default[cmd] = [];\n      }\n      parseOptions.alias[cmd] = aliases;\n      parseOptions.demand[cmd] = true;\n    });\n    parsed.optional.forEach(o => {\n      const [cmd, ...aliases] = o.cmd;\n      if (o.variadic) {\n        parseOptions.array.push(cmd);\n        parseOptions.default[cmd] = [];\n      }\n      parseOptions.alias[cmd] = aliases;\n    });\n    return parseOptions;\n  };\n  self.reset = () => {\n    handlers = {};\n    aliasMap = {};\n    defaultCommand = undefined;\n    return self;\n  };\n  const frozens = [];\n  self.freeze = () => {\n    frozens.push({\n      handlers,\n      aliasMap,\n      defaultCommand\n    });\n  };\n  self.unfreeze = () => {\n    const frozen = frozens.pop();\n    assertNotStrictEqual(frozen, undefined, shim);\n    ({\n      handlers,\n      aliasMap,\n      defaultCommand\n    } = frozen);\n  };\n  return self;\n}\nfunction isCommandBuilderDefinition(builder) {\n  return typeof builder === 'object' && !!builder.builder && typeof builder.handler === 'function';\n}\nfunction isCommandAndAliases(cmd) {\n  if (cmd.every(c => typeof c === 'string')) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isCommandBuilderCallback(builder) {\n  return typeof builder === 'function';\n}\nfunction isCommandBuilderOptionDefinitions(builder) {\n  return typeof builder === 'object';\n}\nfunction isCommandHandlerDefinition(cmd) {\n  return typeof cmd === 'object' && !Array.isArray(cmd);\n}\nfunction setBlocking(blocking) {\n  if (typeof process === 'undefined') return;\n  [process.stdout, process.stderr].forEach(_stream => {\n    const stream = _stream;\n    if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === 'function') {\n      stream._handle.setBlocking(blocking);\n    }\n  });\n}\nfunction usage(yargs, y18n, shim) {\n  const __ = y18n.__;\n  const self = {};\n  const fails = [];\n  self.failFn = function failFn(f) {\n    fails.push(f);\n  };\n  let failMessage = null;\n  let showHelpOnFail = true;\n  self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {\n    function parseFunctionArgs() {\n      return typeof arg1 === 'string' ? [true, arg1] : [arg1, arg2];\n    }\n    const [enabled, message] = parseFunctionArgs();\n    failMessage = message;\n    showHelpOnFail = enabled;\n    return self;\n  };\n  let failureOutput = false;\n  self.fail = function fail(msg, err) {\n    const logger = yargs._getLoggerInstance();\n    if (fails.length) {\n      for (let i = fails.length - 1; i >= 0; --i) {\n        fails[i](msg, err, self);\n      }\n    } else {\n      if (yargs.getExitProcess()) setBlocking(true);\n      if (!failureOutput) {\n        failureOutput = true;\n        if (showHelpOnFail) {\n          yargs.showHelp('error');\n          logger.error();\n        }\n        if (msg || err) logger.error(msg || err);\n        if (failMessage) {\n          if (msg || err) logger.error('');\n          logger.error(failMessage);\n        }\n      }\n      err = err || new YError(msg);\n      if (yargs.getExitProcess()) {\n        return yargs.exit(1);\n      } else if (yargs._hasParseCallback()) {\n        return yargs.exit(1, err);\n      } else {\n        throw err;\n      }\n    }\n  };\n  let usages = [];\n  let usageDisabled = false;\n  self.usage = (msg, description) => {\n    if (msg === null) {\n      usageDisabled = true;\n      usages = [];\n      return self;\n    }\n    usageDisabled = false;\n    usages.push([msg, description || '']);\n    return self;\n  };\n  self.getUsage = () => {\n    return usages;\n  };\n  self.getUsageDisabled = () => {\n    return usageDisabled;\n  };\n  self.getPositionalGroupName = () => {\n    return __('Positionals:');\n  };\n  let examples = [];\n  self.example = (cmd, description) => {\n    examples.push([cmd, description || '']);\n  };\n  let commands = [];\n  self.command = function command(cmd, description, isDefault, aliases, deprecated = false) {\n    if (isDefault) {\n      commands = commands.map(cmdArray => {\n        cmdArray[2] = false;\n        return cmdArray;\n      });\n    }\n    commands.push([cmd, description || '', isDefault, aliases, deprecated]);\n  };\n  self.getCommands = () => commands;\n  let descriptions = {};\n  self.describe = function describe(keyOrKeys, desc) {\n    if (Array.isArray(keyOrKeys)) {\n      keyOrKeys.forEach(k => {\n        self.describe(k, desc);\n      });\n    } else if (typeof keyOrKeys === 'object') {\n      Object.keys(keyOrKeys).forEach(k => {\n        self.describe(k, keyOrKeys[k]);\n      });\n    } else {\n      descriptions[keyOrKeys] = desc;\n    }\n  };\n  self.getDescriptions = () => descriptions;\n  let epilogs = [];\n  self.epilog = msg => {\n    epilogs.push(msg);\n  };\n  let wrapSet = false;\n  let wrap;\n  self.wrap = cols => {\n    wrapSet = true;\n    wrap = cols;\n  };\n  function getWrap() {\n    if (!wrapSet) {\n      wrap = windowWidth();\n      wrapSet = true;\n    }\n    return wrap;\n  }\n  const deferY18nLookupPrefix = '__yargsString__:';\n  self.deferY18nLookup = str => deferY18nLookupPrefix + str;\n  self.help = function help() {\n    if (cachedHelpMessage) return cachedHelpMessage;\n    normalizeAliases();\n    const base$0 = yargs.customScriptName ? yargs.$0 : shim.path.basename(yargs.$0);\n    const demandedOptions = yargs.getDemandedOptions();\n    const demandedCommands = yargs.getDemandedCommands();\n    const deprecatedOptions = yargs.getDeprecatedOptions();\n    const groups = yargs.getGroups();\n    const options = yargs.getOptions();\n    let keys = [];\n    keys = keys.concat(Object.keys(descriptions));\n    keys = keys.concat(Object.keys(demandedOptions));\n    keys = keys.concat(Object.keys(demandedCommands));\n    keys = keys.concat(Object.keys(options.default));\n    keys = keys.filter(filterHiddenOptions);\n    keys = Object.keys(keys.reduce((acc, key) => {\n      if (key !== '_') acc[key] = true;\n      return acc;\n    }, {}));\n    const theWrap = getWrap();\n    const ui = shim.cliui({\n      width: theWrap,\n      wrap: !!theWrap\n    });\n    if (!usageDisabled) {\n      if (usages.length) {\n        usages.forEach(usage => {\n          ui.div(`${usage[0].replace(/\\$0/g, base$0)}`);\n          if (usage[1]) {\n            ui.div({\n              text: `${usage[1]}`,\n              padding: [1, 0, 0, 0]\n            });\n          }\n        });\n        ui.div();\n      } else if (commands.length) {\n        let u = null;\n        if (demandedCommands._) {\n          u = `${base$0} <${__('command')}>\\n`;\n        } else {\n          u = `${base$0} [${__('command')}]\\n`;\n        }\n        ui.div(`${u}`);\n      }\n    }\n    if (commands.length) {\n      ui.div(__('Commands:'));\n      const context = yargs.getContext();\n      const parentCommands = context.commands.length ? `${context.commands.join(' ')} ` : '';\n      if (yargs.getParserConfiguration()['sort-commands'] === true) {\n        commands = commands.sort((a, b) => a[0].localeCompare(b[0]));\n      }\n      commands.forEach(command => {\n        const commandString = `${base$0} ${parentCommands}${command[0].replace(/^\\$0 ?/, '')}`;\n        ui.span({\n          text: commandString,\n          padding: [0, 2, 0, 2],\n          width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4\n        }, {\n          text: command[1]\n        });\n        const hints = [];\n        if (command[2]) hints.push(`[${__('default')}]`);\n        if (command[3] && command[3].length) {\n          hints.push(`[${__('aliases:')} ${command[3].join(', ')}]`);\n        }\n        if (command[4]) {\n          if (typeof command[4] === 'string') {\n            hints.push(`[${__('deprecated: %s', command[4])}]`);\n          } else {\n            hints.push(`[${__('deprecated')}]`);\n          }\n        }\n        if (hints.length) {\n          ui.div({\n            text: hints.join(' '),\n            padding: [0, 0, 0, 2],\n            align: 'right'\n          });\n        } else {\n          ui.div();\n        }\n      });\n      ui.div();\n    }\n    const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);\n    keys = keys.filter(key => !yargs.parsed.newAliases[key] && aliasKeys.every(alias => (options.alias[alias] || []).indexOf(key) === -1));\n    const defaultGroup = __('Options:');\n    if (!groups[defaultGroup]) groups[defaultGroup] = [];\n    addUngroupedKeys(keys, options.alias, groups, defaultGroup);\n    const isLongSwitch = sw => /^--/.test(getText(sw));\n    const displayedGroups = Object.keys(groups).filter(groupName => groups[groupName].length > 0).map(groupName => {\n      const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map(key => {\n        if (~aliasKeys.indexOf(key)) return key;\n        for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {\n          if (~(options.alias[aliasKey] || []).indexOf(key)) return aliasKey;\n        }\n        return key;\n      });\n      return {\n        groupName,\n        normalizedKeys\n      };\n    }).filter(({\n      normalizedKeys\n    }) => normalizedKeys.length > 0).map(({\n      groupName,\n      normalizedKeys\n    }) => {\n      const switches = normalizedKeys.reduce((acc, key) => {\n        acc[key] = [key].concat(options.alias[key] || []).map(sw => {\n          if (groupName === self.getPositionalGroupName()) return sw;else {\n            return (/^[0-9]$/.test(sw) ? ~options.boolean.indexOf(key) ? '-' : '--' : sw.length > 1 ? '--' : '-') + sw;\n          }\n        }).sort((sw1, sw2) => isLongSwitch(sw1) === isLongSwitch(sw2) ? 0 : isLongSwitch(sw1) ? 1 : -1).join(', ');\n        return acc;\n      }, {});\n      return {\n        groupName,\n        normalizedKeys,\n        switches\n      };\n    });\n    const shortSwitchesUsed = displayedGroups.filter(({\n      groupName\n    }) => groupName !== self.getPositionalGroupName()).some(({\n      normalizedKeys,\n      switches\n    }) => !normalizedKeys.every(key => isLongSwitch(switches[key])));\n    if (shortSwitchesUsed) {\n      displayedGroups.filter(({\n        groupName\n      }) => groupName !== self.getPositionalGroupName()).forEach(({\n        normalizedKeys,\n        switches\n      }) => {\n        normalizedKeys.forEach(key => {\n          if (isLongSwitch(switches[key])) {\n            switches[key] = addIndentation(switches[key], '-x, '.length);\n          }\n        });\n      });\n    }\n    displayedGroups.forEach(({\n      groupName,\n      normalizedKeys,\n      switches\n    }) => {\n      ui.div(groupName);\n      normalizedKeys.forEach(key => {\n        const kswitch = switches[key];\n        let desc = descriptions[key] || '';\n        let type = null;\n        if (~desc.lastIndexOf(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length));\n        if (~options.boolean.indexOf(key)) type = `[${__('boolean')}]`;\n        if (~options.count.indexOf(key)) type = `[${__('count')}]`;\n        if (~options.string.indexOf(key)) type = `[${__('string')}]`;\n        if (~options.normalize.indexOf(key)) type = `[${__('string')}]`;\n        if (~options.array.indexOf(key)) type = `[${__('array')}]`;\n        if (~options.number.indexOf(key)) type = `[${__('number')}]`;\n        const deprecatedExtra = deprecated => typeof deprecated === 'string' ? `[${__('deprecated: %s', deprecated)}]` : `[${__('deprecated')}]`;\n        const extra = [key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null, type, key in demandedOptions ? `[${__('required')}]` : null, options.choices && options.choices[key] ? `[${__('choices:')} ${self.stringifiedValues(options.choices[key])}]` : null, defaultString(options.default[key], options.defaultDescription[key])].filter(Boolean).join(' ');\n        ui.span({\n          text: getText(kswitch),\n          padding: [0, 2, 0, 2 + getIndentation(kswitch)],\n          width: maxWidth(switches, theWrap) + 4\n        }, desc);\n        if (extra) ui.div({\n          text: extra,\n          padding: [0, 0, 0, 2],\n          align: 'right'\n        });else ui.div();\n      });\n      ui.div();\n    });\n    if (examples.length) {\n      ui.div(__('Examples:'));\n      examples.forEach(example => {\n        example[0] = example[0].replace(/\\$0/g, base$0);\n      });\n      examples.forEach(example => {\n        if (example[1] === '') {\n          ui.div({\n            text: example[0],\n            padding: [0, 2, 0, 2]\n          });\n        } else {\n          ui.div({\n            text: example[0],\n            padding: [0, 2, 0, 2],\n            width: maxWidth(examples, theWrap) + 4\n          }, {\n            text: example[1]\n          });\n        }\n      });\n      ui.div();\n    }\n    if (epilogs.length > 0) {\n      const e = epilogs.map(epilog => epilog.replace(/\\$0/g, base$0)).join('\\n');\n      ui.div(`${e}\\n`);\n    }\n    return ui.toString().replace(/\\s*$/, '');\n  };\n  function maxWidth(table, theWrap, modifier) {\n    let width = 0;\n    if (!Array.isArray(table)) {\n      table = Object.values(table).map(v => [v]);\n    }\n    table.forEach(v => {\n      width = Math.max(shim.stringWidth(modifier ? `${modifier} ${getText(v[0])}` : getText(v[0])) + getIndentation(v[0]), width);\n    });\n    if (theWrap) width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));\n    return width;\n  }\n  function normalizeAliases() {\n    const demandedOptions = yargs.getDemandedOptions();\n    const options = yargs.getOptions();\n    (Object.keys(options.alias) || []).forEach(key => {\n      options.alias[key].forEach(alias => {\n        if (descriptions[alias]) self.describe(key, descriptions[alias]);\n        if (alias in demandedOptions) yargs.demandOption(key, demandedOptions[alias]);\n        if (~options.boolean.indexOf(alias)) yargs.boolean(key);\n        if (~options.count.indexOf(alias)) yargs.count(key);\n        if (~options.string.indexOf(alias)) yargs.string(key);\n        if (~options.normalize.indexOf(alias)) yargs.normalize(key);\n        if (~options.array.indexOf(alias)) yargs.array(key);\n        if (~options.number.indexOf(alias)) yargs.number(key);\n      });\n    });\n  }\n  let cachedHelpMessage;\n  self.cacheHelpMessage = function () {\n    cachedHelpMessage = this.help();\n  };\n  self.clearCachedHelpMessage = function () {\n    cachedHelpMessage = undefined;\n  };\n  function addUngroupedKeys(keys, aliases, groups, defaultGroup) {\n    let groupedKeys = [];\n    let toCheck = null;\n    Object.keys(groups).forEach(group => {\n      groupedKeys = groupedKeys.concat(groups[group]);\n    });\n    keys.forEach(key => {\n      toCheck = [key].concat(aliases[key]);\n      if (!toCheck.some(k => groupedKeys.indexOf(k) !== -1)) {\n        groups[defaultGroup].push(key);\n      }\n    });\n    return groupedKeys;\n  }\n  function filterHiddenOptions(key) {\n    return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];\n  }\n  self.showHelp = level => {\n    const logger = yargs._getLoggerInstance();\n    if (!level) level = 'error';\n    const emit = typeof level === 'function' ? level : logger[level];\n    emit(self.help());\n  };\n  self.functionDescription = fn => {\n    const description = fn.name ? shim.Parser.decamelize(fn.name, '-') : __('generated-value');\n    return ['(', description, ')'].join('');\n  };\n  self.stringifiedValues = function stringifiedValues(values, separator) {\n    let string = '';\n    const sep = separator || ', ';\n    const array = [].concat(values);\n    if (!values || !array.length) return string;\n    array.forEach(value => {\n      if (string.length) string += sep;\n      string += JSON.stringify(value);\n    });\n    return string;\n  };\n  function defaultString(value, defaultDescription) {\n    let string = `[${__('default:')} `;\n    if (value === undefined && !defaultDescription) return null;\n    if (defaultDescription) {\n      string += defaultDescription;\n    } else {\n      switch (typeof value) {\n        case 'string':\n          string += `\"${value}\"`;\n          break;\n        case 'object':\n          string += JSON.stringify(value);\n          break;\n        default:\n          string += value;\n      }\n    }\n    return `${string}]`;\n  }\n  function windowWidth() {\n    const maxWidth = 80;\n    if (shim.process.stdColumns) {\n      return Math.min(maxWidth, shim.process.stdColumns);\n    } else {\n      return maxWidth;\n    }\n  }\n  let version = null;\n  self.version = ver => {\n    version = ver;\n  };\n  self.showVersion = () => {\n    const logger = yargs._getLoggerInstance();\n    logger.log(version);\n  };\n  self.reset = function reset(localLookup) {\n    failMessage = null;\n    failureOutput = false;\n    usages = [];\n    usageDisabled = false;\n    epilogs = [];\n    examples = [];\n    commands = [];\n    descriptions = objFilter(descriptions, k => !localLookup[k]);\n    return self;\n  };\n  const frozens = [];\n  self.freeze = function freeze() {\n    frozens.push({\n      failMessage,\n      failureOutput,\n      usages,\n      usageDisabled,\n      epilogs,\n      examples,\n      commands,\n      descriptions\n    });\n  };\n  self.unfreeze = function unfreeze() {\n    const frozen = frozens.pop();\n    assertNotStrictEqual(frozen, undefined, shim);\n    ({\n      failMessage,\n      failureOutput,\n      usages,\n      usageDisabled,\n      epilogs,\n      examples,\n      commands,\n      descriptions\n    } = frozen);\n  };\n  return self;\n}\nfunction isIndentedText(text) {\n  return typeof text === 'object';\n}\nfunction addIndentation(text, indent) {\n  return isIndentedText(text) ? {\n    text: text.text,\n    indentation: text.indentation + indent\n  } : {\n    text,\n    indentation: indent\n  };\n}\nfunction getIndentation(text) {\n  return isIndentedText(text) ? text.indentation : 0;\n}\nfunction getText(text) {\n  return isIndentedText(text) ? text.text : text;\n}\nconst completionShTemplate = `###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc\n#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.\n#\n_yargs_completions()\n{\n    local cur_word args type_list\n\n    cur_word=\"\\${COMP_WORDS[COMP_CWORD]}\"\n    args=(\"\\${COMP_WORDS[@]}\")\n\n    # ask yargs to generate completions.\n    type_list=$({{app_path}} --get-yargs-completions \"\\${args[@]}\")\n\n    COMPREPLY=( $(compgen -W \"\\${type_list}\" -- \\${cur_word}) )\n\n    # if no match was found, fall back to filename completion\n    if [ \\${#COMPREPLY[@]} -eq 0 ]; then\n      COMPREPLY=()\n    fi\n\n    return 0\n}\ncomplete -o default -F _yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n`;\nconst completionZshTemplate = `###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc\n#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.\n#\n_{{app_name}}_yargs_completions()\n{\n  local reply\n  local si=$IFS\n  IFS=$'\\n' reply=($(COMP_CWORD=\"$((CURRENT-1))\" COMP_LINE=\"$BUFFER\" COMP_POINT=\"$CURSOR\" {{app_path}} --get-yargs-completions \"\\${words[@]}\"))\n  IFS=$si\n  _describe 'values' reply\n}\ncompdef _{{app_name}}_yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n`;\nfunction completion(yargs, usage, command, shim) {\n  const self = {\n    completionKey: 'get-yargs-completions'\n  };\n  let aliases;\n  self.setParsed = function setParsed(parsed) {\n    aliases = parsed.aliases;\n  };\n  const zshShell = shim.getEnv('SHELL') && shim.getEnv('SHELL').indexOf('zsh') !== -1 || shim.getEnv('ZSH_NAME') && shim.getEnv('ZSH_NAME').indexOf('zsh') !== -1;\n  self.getCompletion = function getCompletion(args, done) {\n    const completions = [];\n    const current = args.length ? args[args.length - 1] : '';\n    const argv = yargs.parse(args, true);\n    const parentCommands = yargs.getContext().commands;\n    function runCompletionFunction(argv) {\n      assertNotStrictEqual(completionFunction, null, shim);\n      if (isSyncCompletionFunction(completionFunction)) {\n        const result = completionFunction(current, argv);\n        if (isPromise(result)) {\n          return result.then(list => {\n            shim.process.nextTick(() => {\n              done(list);\n            });\n          }).catch(err => {\n            shim.process.nextTick(() => {\n              throw err;\n            });\n          });\n        }\n        return done(result);\n      } else {\n        return completionFunction(current, argv, completions => {\n          done(completions);\n        });\n      }\n    }\n    if (completionFunction) {\n      return isPromise(argv) ? argv.then(runCompletionFunction) : runCompletionFunction(argv);\n    }\n    const handlers = command.getCommandHandlers();\n    for (let i = 0, ii = args.length; i < ii; ++i) {\n      if (handlers[args[i]] && handlers[args[i]].builder) {\n        const builder = handlers[args[i]].builder;\n        if (isCommandBuilderCallback(builder)) {\n          const y = yargs.reset();\n          builder(y);\n          return y.argv;\n        }\n      }\n    }\n    if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current) {\n      usage.getCommands().forEach(usageCommand => {\n        const commandName = parseCommand(usageCommand[0]).cmd;\n        if (args.indexOf(commandName) === -1) {\n          if (!zshShell) {\n            completions.push(commandName);\n          } else {\n            const desc = usageCommand[1] || '';\n            completions.push(commandName.replace(/:/g, '\\\\:') + ':' + desc);\n          }\n        }\n      });\n    }\n    if (current.match(/^-/) || current === '' && completions.length === 0) {\n      const descs = usage.getDescriptions();\n      const options = yargs.getOptions();\n      Object.keys(options.key).forEach(key => {\n        const negable = !!options.configuration['boolean-negation'] && options.boolean.includes(key);\n        let keyAndAliases = [key].concat(aliases[key] || []);\n        if (negable) keyAndAliases = keyAndAliases.concat(keyAndAliases.map(key => `no-${key}`));\n        function completeOptionKey(key) {\n          const notInArgs = keyAndAliases.every(val => args.indexOf(`--${val}`) === -1);\n          if (notInArgs) {\n            const startsByTwoDashes = s => /^--/.test(s);\n            const isShortOption = s => /^[^0-9]$/.test(s);\n            const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';\n            if (!zshShell) {\n              completions.push(dashes + key);\n            } else {\n              const desc = descs[key] || '';\n              completions.push(dashes + `${key.replace(/:/g, '\\\\:')}:${desc.replace('__yargsString__:', '')}`);\n            }\n          }\n        }\n        completeOptionKey(key);\n        if (negable && !!options.default[key]) completeOptionKey(`no-${key}`);\n      });\n    }\n    done(completions);\n  };\n  self.generateCompletionScript = function generateCompletionScript($0, cmd) {\n    let script = zshShell ? completionZshTemplate : completionShTemplate;\n    const name = shim.path.basename($0);\n    if ($0.match(/\\.js$/)) $0 = `./${$0}`;\n    script = script.replace(/{{app_name}}/g, name);\n    script = script.replace(/{{completion_command}}/g, cmd);\n    return script.replace(/{{app_path}}/g, $0);\n  };\n  let completionFunction = null;\n  self.registerFunction = fn => {\n    completionFunction = fn;\n  };\n  return self;\n}\nfunction isSyncCompletionFunction(completionFunction) {\n  return completionFunction.length < 3;\n}\nfunction levenshtein(a, b) {\n  if (a.length === 0) return b.length;\n  if (b.length === 0) return a.length;\n  const matrix = [];\n  let i;\n  for (i = 0; i <= b.length; i++) {\n    matrix[i] = [i];\n  }\n  let j;\n  for (j = 0; j <= a.length; j++) {\n    matrix[0][j] = j;\n  }\n  for (i = 1; i <= b.length; i++) {\n    for (j = 1; j <= a.length; j++) {\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\n        matrix[i][j] = matrix[i - 1][j - 1];\n      } else {\n        matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));\n      }\n    }\n  }\n  return matrix[b.length][a.length];\n}\nconst specialKeys = ['$0', '--', '_'];\nfunction validation(yargs, usage, y18n, shim) {\n  const __ = y18n.__;\n  const __n = y18n.__n;\n  const self = {};\n  self.nonOptionCount = function nonOptionCount(argv) {\n    const demandedCommands = yargs.getDemandedCommands();\n    const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);\n    const _s = positionalCount - yargs.getContext().commands.length;\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.min.toString()) : null);\n        } else {\n          usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.max.toString()) : null);\n        } else {\n          usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));\n        }\n      }\n    }\n  };\n  self.positionalCount = function positionalCount(required, observed) {\n    if (observed < required) {\n      usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));\n    }\n  };\n  self.requiredArguments = function requiredArguments(argv) {\n    const demandedOptions = yargs.getDemandedOptions();\n    let missing = null;\n    for (const key of Object.keys(demandedOptions)) {\n      if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {\n        missing = missing || {};\n        missing[key] = demandedOptions[key];\n      }\n    }\n    if (missing) {\n      const customMsgs = [];\n      for (const key of Object.keys(missing)) {\n        const msg = missing[key];\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg);\n        }\n      }\n      const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n      usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n    }\n  };\n  self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {\n    const commandKeys = yargs.getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getContext();\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n        unknown.push(key);\n      }\n    });\n    if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (commandKeys.indexOf('' + key) === -1) {\n          unknown.push('' + key);\n        }\n      });\n    }\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n    }\n  };\n  self.unknownCommands = function unknownCommands(argv) {\n    const commandKeys = yargs.getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getContext();\n    if (currentContext.commands.length > 0 || commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (commandKeys.indexOf('' + key) === -1) {\n          unknown.push('' + key);\n        }\n      });\n    }\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n      return true;\n    } else {\n      return false;\n    }\n  };\n  self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n      return false;\n    }\n    const newAliases = yargs.parsed.newAliases;\n    for (const a of [key, ...aliases[key]]) {\n      if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {\n        return true;\n      }\n    }\n    return false;\n  };\n  self.limitedChoices = function limitedChoices(argv) {\n    const options = yargs.getOptions();\n    const invalid = {};\n    if (!Object.keys(options.choices).length) return;\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {\n        [].concat(argv[key]).forEach(value => {\n          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {\n            invalid[key] = (invalid[key] || []).concat(value);\n          }\n        });\n      }\n    });\n    const invalidKeys = Object.keys(invalid);\n    if (!invalidKeys.length) return;\n    let msg = __('Invalid values:');\n    invalidKeys.forEach(key => {\n      msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n    });\n    usage.fail(msg);\n  };\n  let checks = [];\n  self.check = function check(f, global) {\n    checks.push({\n      func: f,\n      global\n    });\n  };\n  self.customChecks = function customChecks(argv, aliases) {\n    for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n      const func = f.func;\n      let result = null;\n      try {\n        result = func(argv, aliases);\n      } catch (err) {\n        usage.fail(err.message ? err.message : err, err);\n        continue;\n      }\n      if (!result) {\n        usage.fail(__('Argument check failed: %s', func.toString()));\n      } else if (typeof result === 'string' || result instanceof Error) {\n        usage.fail(result.toString(), result);\n      }\n    }\n  };\n  let implied = {};\n  self.implies = function implies(key, value) {\n    argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.implies(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n      if (!implied[key]) {\n        implied[key] = [];\n      }\n      if (Array.isArray(value)) {\n        value.forEach(i => self.implies(key, i));\n      } else {\n        assertNotStrictEqual(value, undefined, shim);\n        implied[key].push(value);\n      }\n    }\n  };\n  self.getImplied = function getImplied() {\n    return implied;\n  };\n  function keyExists(argv, val) {\n    const num = Number(val);\n    val = isNaN(num) ? val : num;\n    if (typeof val === 'number') {\n      val = argv._.length >= val;\n    } else if (val.match(/^--no-.+/)) {\n      val = val.match(/^--no-(.+)/)[1];\n      val = !argv[val];\n    } else {\n      val = argv[val];\n    }\n    return val;\n  }\n  self.implications = function implications(argv) {\n    const implyFail = [];\n    Object.keys(implied).forEach(key => {\n      const origKey = key;\n      (implied[key] || []).forEach(value => {\n        let key = origKey;\n        const origValue = value;\n        key = keyExists(argv, key);\n        value = keyExists(argv, value);\n        if (key && !value) {\n          implyFail.push(` ${origKey} -> ${origValue}`);\n        }\n      });\n    });\n    if (implyFail.length) {\n      let msg = `${__('Implications failed:')}\\n`;\n      implyFail.forEach(value => {\n        msg += value;\n      });\n      usage.fail(msg);\n    }\n  };\n  let conflicting = {};\n  self.conflicts = function conflicts(key, value) {\n    argsert('<string|object> [array|string]', [key, value], arguments.length);\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.conflicts(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n      if (!conflicting[key]) {\n        conflicting[key] = [];\n      }\n      if (Array.isArray(value)) {\n        value.forEach(i => self.conflicts(key, i));\n      } else {\n        conflicting[key].push(value);\n      }\n    }\n  };\n  self.getConflicting = () => conflicting;\n  self.conflicting = function conflictingFn(argv) {\n    Object.keys(argv).forEach(key => {\n      if (conflicting[key]) {\n        conflicting[key].forEach(value => {\n          if (value && argv[key] !== undefined && argv[value] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n          }\n        });\n      }\n    });\n  };\n  self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n    const threshold = 3;\n    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n    let recommended = null;\n    let bestDistance = Infinity;\n    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      const d = levenshtein(cmd, candidate);\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d;\n        recommended = candidate;\n      }\n    }\n    if (recommended) usage.fail(__('Did you mean %s?', recommended));\n  };\n  self.reset = function reset(localLookup) {\n    implied = objFilter(implied, k => !localLookup[k]);\n    conflicting = objFilter(conflicting, k => !localLookup[k]);\n    checks = checks.filter(c => c.global);\n    return self;\n  };\n  const frozens = [];\n  self.freeze = function freeze() {\n    frozens.push({\n      implied,\n      checks,\n      conflicting\n    });\n  };\n  self.unfreeze = function unfreeze() {\n    const frozen = frozens.pop();\n    assertNotStrictEqual(frozen, undefined, shim);\n    ({\n      implied,\n      checks,\n      conflicting\n    } = frozen);\n  };\n  return self;\n}\nlet shim$1;\nfunction YargsWithShim(_shim) {\n  shim$1 = _shim;\n  return Yargs;\n}\nfunction Yargs(processArgs = [], cwd = shim$1.process.cwd(), parentRequire) {\n  const self = {};\n  let command$1;\n  let completion$1 = null;\n  let groups = {};\n  const globalMiddleware = [];\n  let output = '';\n  const preservedGroups = {};\n  let usage$1;\n  let validation$1;\n  let handlerFinishCommand = null;\n  const y18n = shim$1.y18n;\n  self.middleware = globalMiddlewareFactory(globalMiddleware, self);\n  self.scriptName = function (scriptName) {\n    self.customScriptName = true;\n    self.$0 = scriptName;\n    return self;\n  };\n  let default$0;\n  if (/\\b(node|iojs|electron)(\\.exe)?$/.test(shim$1.process.argv()[0])) {\n    default$0 = shim$1.process.argv().slice(1, 2);\n  } else {\n    default$0 = shim$1.process.argv().slice(0, 1);\n  }\n  self.$0 = default$0.map(x => {\n    const b = rebase(cwd, x);\n    return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x;\n  }).join(' ').trim();\n  if (shim$1.getEnv('_') && shim$1.getProcessArgvBin() === shim$1.getEnv('_')) {\n    self.$0 = shim$1.getEnv('_').replace(`${shim$1.path.dirname(shim$1.process.execPath())}/`, '');\n  }\n  const context = {\n    resets: -1,\n    commands: [],\n    fullCommands: [],\n    files: []\n  };\n  self.getContext = () => context;\n  let hasOutput = false;\n  let exitError = null;\n  self.exit = (code, err) => {\n    hasOutput = true;\n    exitError = err;\n    if (exitProcess) shim$1.process.exit(code);\n  };\n  let completionCommand = null;\n  self.completion = function (cmd, desc, fn) {\n    argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length);\n    if (typeof desc === 'function') {\n      fn = desc;\n      desc = undefined;\n    }\n    completionCommand = cmd || completionCommand || 'completion';\n    if (!desc && desc !== false) {\n      desc = 'generate completion script';\n    }\n    self.command(completionCommand, desc);\n    if (fn) completion$1.registerFunction(fn);\n    return self;\n  };\n  let options;\n  self.resetOptions = self.reset = function resetOptions(aliases = {}) {\n    context.resets++;\n    options = options || {};\n    const tmpOptions = {};\n    tmpOptions.local = options.local ? options.local : [];\n    tmpOptions.configObjects = options.configObjects ? options.configObjects : [];\n    const localLookup = {};\n    tmpOptions.local.forEach(l => {\n      localLookup[l] = true;\n      (aliases[l] || []).forEach(a => {\n        localLookup[a] = true;\n      });\n    });\n    Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => {\n      const keys = groups[groupName].filter(key => !(key in localLookup));\n      if (keys.length > 0) {\n        acc[groupName] = keys;\n      }\n      return acc;\n    }, {}));\n    groups = {};\n    const arrayOptions = ['array', 'boolean', 'string', 'skipValidation', 'count', 'normalize', 'number', 'hiddenOptions'];\n    const objectOptions = ['narg', 'key', 'alias', 'default', 'defaultDescription', 'config', 'choices', 'demandedOptions', 'demandedCommands', 'coerce', 'deprecatedOptions'];\n    arrayOptions.forEach(k => {\n      tmpOptions[k] = (options[k] || []).filter(k => !localLookup[k]);\n    });\n    objectOptions.forEach(k => {\n      tmpOptions[k] = objFilter(options[k], k => !localLookup[k]);\n    });\n    tmpOptions.envPrefix = options.envPrefix;\n    options = tmpOptions;\n    usage$1 = usage$1 ? usage$1.reset(localLookup) : usage(self, y18n, shim$1);\n    validation$1 = validation$1 ? validation$1.reset(localLookup) : validation(self, usage$1, y18n, shim$1);\n    command$1 = command$1 ? command$1.reset() : command(self, usage$1, validation$1, globalMiddleware, shim$1);\n    if (!completion$1) completion$1 = completion(self, usage$1, command$1, shim$1);\n    completionCommand = null;\n    output = '';\n    exitError = null;\n    hasOutput = false;\n    self.parsed = false;\n    return self;\n  };\n  self.resetOptions();\n  const frozens = [];\n  function freeze() {\n    frozens.push({\n      options,\n      configObjects: options.configObjects.slice(0),\n      exitProcess,\n      groups,\n      strict,\n      strictCommands,\n      strictOptions,\n      completionCommand,\n      output,\n      exitError,\n      hasOutput,\n      parsed: self.parsed,\n      parseFn,\n      parseContext,\n      handlerFinishCommand\n    });\n    usage$1.freeze();\n    validation$1.freeze();\n    command$1.freeze();\n  }\n  function unfreeze() {\n    const frozen = frozens.pop();\n    assertNotStrictEqual(frozen, undefined, shim$1);\n    let configObjects;\n    ({\n      options,\n      configObjects,\n      exitProcess,\n      groups,\n      output,\n      exitError,\n      hasOutput,\n      parsed: self.parsed,\n      strict,\n      strictCommands,\n      strictOptions,\n      completionCommand,\n      parseFn,\n      parseContext,\n      handlerFinishCommand\n    } = frozen);\n    options.configObjects = configObjects;\n    usage$1.unfreeze();\n    validation$1.unfreeze();\n    command$1.unfreeze();\n  }\n  self.boolean = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('boolean', keys);\n    return self;\n  };\n  self.array = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('array', keys);\n    return self;\n  };\n  self.number = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('number', keys);\n    return self;\n  };\n  self.normalize = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('normalize', keys);\n    return self;\n  };\n  self.count = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('count', keys);\n    return self;\n  };\n  self.string = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('string', keys);\n    return self;\n  };\n  self.requiresArg = function (keys) {\n    argsert('<array|string|object> [number]', [keys], arguments.length);\n    if (typeof keys === 'string' && options.narg[keys]) {\n      return self;\n    } else {\n      populateParserHintSingleValueDictionary(self.requiresArg, 'narg', keys, NaN);\n    }\n    return self;\n  };\n  self.skipValidation = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('skipValidation', keys);\n    return self;\n  };\n  function populateParserHintArray(type, keys) {\n    keys = [].concat(keys);\n    keys.forEach(key => {\n      key = sanitizeKey(key);\n      options[type].push(key);\n    });\n  }\n  self.nargs = function (key, value) {\n    argsert('<string|object|array> [number]', [key, value], arguments.length);\n    populateParserHintSingleValueDictionary(self.nargs, 'narg', key, value);\n    return self;\n  };\n  self.choices = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n    populateParserHintArrayDictionary(self.choices, 'choices', key, value);\n    return self;\n  };\n  self.alias = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n    populateParserHintArrayDictionary(self.alias, 'alias', key, value);\n    return self;\n  };\n  self.default = self.defaults = function (key, value, defaultDescription) {\n    argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);\n    if (defaultDescription) {\n      assertSingleKey(key, shim$1);\n      options.defaultDescription[key] = defaultDescription;\n    }\n    if (typeof value === 'function') {\n      assertSingleKey(key, shim$1);\n      if (!options.defaultDescription[key]) options.defaultDescription[key] = usage$1.functionDescription(value);\n      value = value.call();\n    }\n    populateParserHintSingleValueDictionary(self.default, 'default', key, value);\n    return self;\n  };\n  self.describe = function (key, desc) {\n    argsert('<object|string|array> [string]', [key, desc], arguments.length);\n    setKey(key, true);\n    usage$1.describe(key, desc);\n    return self;\n  };\n  function setKey(key, set) {\n    populateParserHintSingleValueDictionary(setKey, 'key', key, set);\n    return self;\n  }\n  function demandOption(keys, msg) {\n    argsert('<object|string|array> [string]', [keys, msg], arguments.length);\n    populateParserHintSingleValueDictionary(self.demandOption, 'demandedOptions', keys, msg);\n    return self;\n  }\n  self.demandOption = demandOption;\n  self.coerce = function (keys, value) {\n    argsert('<object|string|array> [function]', [keys, value], arguments.length);\n    populateParserHintSingleValueDictionary(self.coerce, 'coerce', keys, value);\n    return self;\n  };\n  function populateParserHintSingleValueDictionary(builder, type, key, value) {\n    populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n      options[type][key] = value;\n    });\n  }\n  function populateParserHintArrayDictionary(builder, type, key, value) {\n    populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n      options[type][key] = (options[type][key] || []).concat(value);\n    });\n  }\n  function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {\n    if (Array.isArray(key)) {\n      key.forEach(k => {\n        builder(k, value);\n      });\n    } else if ((key => typeof key === 'object')(key)) {\n      for (const k of objectKeys(key)) {\n        builder(k, key[k]);\n      }\n    } else {\n      singleKeyHandler(type, sanitizeKey(key), value);\n    }\n  }\n  function sanitizeKey(key) {\n    if (key === '__proto__') return '___proto___';\n    return key;\n  }\n  function deleteFromParserHintObject(optionKey) {\n    objectKeys(options).forEach(hintKey => {\n      if ((key => key === 'configObjects')(hintKey)) return;\n      const hint = options[hintKey];\n      if (Array.isArray(hint)) {\n        if (~hint.indexOf(optionKey)) hint.splice(hint.indexOf(optionKey), 1);\n      } else if (typeof hint === 'object') {\n        delete hint[optionKey];\n      }\n    });\n    delete usage$1.getDescriptions()[optionKey];\n  }\n  self.config = function config(key = 'config', msg, parseFn) {\n    argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length);\n    if (typeof key === 'object' && !Array.isArray(key)) {\n      key = applyExtends(key, cwd, self.getParserConfiguration()['deep-merge-config'] || false, shim$1);\n      options.configObjects = (options.configObjects || []).concat(key);\n      return self;\n    }\n    if (typeof msg === 'function') {\n      parseFn = msg;\n      msg = undefined;\n    }\n    self.describe(key, msg || usage$1.deferY18nLookup('Path to JSON config file'));\n    (Array.isArray(key) ? key : [key]).forEach(k => {\n      options.config[k] = parseFn || true;\n    });\n    return self;\n  };\n  self.example = function (cmd, description) {\n    argsert('<string|array> [string]', [cmd, description], arguments.length);\n    if (Array.isArray(cmd)) {\n      cmd.forEach(exampleParams => self.example(...exampleParams));\n    } else {\n      usage$1.example(cmd, description);\n    }\n    return self;\n  };\n  self.command = function (cmd, description, builder, handler, middlewares, deprecated) {\n    argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [cmd, description, builder, handler, middlewares, deprecated], arguments.length);\n    command$1.addHandler(cmd, description, builder, handler, middlewares, deprecated);\n    return self;\n  };\n  self.commandDir = function (dir, opts) {\n    argsert('<string> [object]', [dir, opts], arguments.length);\n    const req = parentRequire || shim$1.require;\n    command$1.addDirectory(dir, self.getContext(), req, shim$1.getCallerFile(), opts);\n    return self;\n  };\n  self.demand = self.required = self.require = function demand(keys, max, msg) {\n    if (Array.isArray(max)) {\n      max.forEach(key => {\n        assertNotStrictEqual(msg, true, shim$1);\n        demandOption(key, msg);\n      });\n      max = Infinity;\n    } else if (typeof max !== 'number') {\n      msg = max;\n      max = Infinity;\n    }\n    if (typeof keys === 'number') {\n      assertNotStrictEqual(msg, true, shim$1);\n      self.demandCommand(keys, max, msg, msg);\n    } else if (Array.isArray(keys)) {\n      keys.forEach(key => {\n        assertNotStrictEqual(msg, true, shim$1);\n        demandOption(key, msg);\n      });\n    } else {\n      if (typeof msg === 'string') {\n        demandOption(keys, msg);\n      } else if (msg === true || typeof msg === 'undefined') {\n        demandOption(keys);\n      }\n    }\n    return self;\n  };\n  self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) {\n    argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length);\n    if (typeof max !== 'number') {\n      minMsg = max;\n      max = Infinity;\n    }\n    self.global('_', false);\n    options.demandedCommands._ = {\n      min,\n      max,\n      minMsg,\n      maxMsg\n    };\n    return self;\n  };\n  self.getDemandedOptions = () => {\n    argsert([], 0);\n    return options.demandedOptions;\n  };\n  self.getDemandedCommands = () => {\n    argsert([], 0);\n    return options.demandedCommands;\n  };\n  self.deprecateOption = function deprecateOption(option, message) {\n    argsert('<string> [string|boolean]', [option, message], arguments.length);\n    options.deprecatedOptions[option] = message;\n    return self;\n  };\n  self.getDeprecatedOptions = () => {\n    argsert([], 0);\n    return options.deprecatedOptions;\n  };\n  self.implies = function (key, value) {\n    argsert('<string|object> [number|string|array]', [key, value], arguments.length);\n    validation$1.implies(key, value);\n    return self;\n  };\n  self.conflicts = function (key1, key2) {\n    argsert('<string|object> [string|array]', [key1, key2], arguments.length);\n    validation$1.conflicts(key1, key2);\n    return self;\n  };\n  self.usage = function (msg, description, builder, handler) {\n    argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length);\n    if (description !== undefined) {\n      assertNotStrictEqual(msg, null, shim$1);\n      if ((msg || '').match(/^\\$0( |$)/)) {\n        return self.command(msg, description, builder, handler);\n      } else {\n        throw new YError('.usage() description must start with $0 if being used as alias for .command()');\n      }\n    } else {\n      usage$1.usage(msg);\n      return self;\n    }\n  };\n  self.epilogue = self.epilog = function (msg) {\n    argsert('<string>', [msg], arguments.length);\n    usage$1.epilog(msg);\n    return self;\n  };\n  self.fail = function (f) {\n    argsert('<function>', [f], arguments.length);\n    usage$1.failFn(f);\n    return self;\n  };\n  self.onFinishCommand = function (f) {\n    argsert('<function>', [f], arguments.length);\n    handlerFinishCommand = f;\n    return self;\n  };\n  self.getHandlerFinishCommand = () => handlerFinishCommand;\n  self.check = function (f, _global) {\n    argsert('<function> [boolean]', [f, _global], arguments.length);\n    validation$1.check(f, _global !== false);\n    return self;\n  };\n  self.global = function global(globals, global) {\n    argsert('<string|array> [boolean]', [globals, global], arguments.length);\n    globals = [].concat(globals);\n    if (global !== false) {\n      options.local = options.local.filter(l => globals.indexOf(l) === -1);\n    } else {\n      globals.forEach(g => {\n        if (options.local.indexOf(g) === -1) options.local.push(g);\n      });\n    }\n    return self;\n  };\n  self.pkgConf = function pkgConf(key, rootPath) {\n    argsert('<string> [string]', [key, rootPath], arguments.length);\n    let conf = null;\n    const obj = pkgUp(rootPath || cwd);\n    if (obj[key] && typeof obj[key] === 'object') {\n      conf = applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()['deep-merge-config'] || false, shim$1);\n      options.configObjects = (options.configObjects || []).concat(conf);\n    }\n    return self;\n  };\n  const pkgs = {};\n  function pkgUp(rootPath) {\n    const npath = rootPath || '*';\n    if (pkgs[npath]) return pkgs[npath];\n    let obj = {};\n    try {\n      let startDir = rootPath || shim$1.mainFilename;\n      if (!rootPath && shim$1.path.extname(startDir)) {\n        startDir = shim$1.path.dirname(startDir);\n      }\n      const pkgJsonPath = shim$1.findUp(startDir, (dir, names) => {\n        if (names.includes('package.json')) {\n          return 'package.json';\n        } else {\n          return undefined;\n        }\n      });\n      assertNotStrictEqual(pkgJsonPath, undefined, shim$1);\n      obj = JSON.parse(shim$1.readFileSync(pkgJsonPath, 'utf8'));\n    } catch (_noop) {}\n    pkgs[npath] = obj || {};\n    return pkgs[npath];\n  }\n  let parseFn = null;\n  let parseContext = null;\n  self.parse = function parse(args, shortCircuit, _parseFn) {\n    argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length);\n    freeze();\n    if (typeof args === 'undefined') {\n      const argv = self._parseArgs(processArgs);\n      const tmpParsed = self.parsed;\n      unfreeze();\n      self.parsed = tmpParsed;\n      return argv;\n    }\n    if (typeof shortCircuit === 'object') {\n      parseContext = shortCircuit;\n      shortCircuit = _parseFn;\n    }\n    if (typeof shortCircuit === 'function') {\n      parseFn = shortCircuit;\n      shortCircuit = false;\n    }\n    if (!shortCircuit) processArgs = args;\n    if (parseFn) exitProcess = false;\n    const parsed = self._parseArgs(args, !!shortCircuit);\n    completion$1.setParsed(self.parsed);\n    if (parseFn) parseFn(exitError, parsed, output);\n    unfreeze();\n    return parsed;\n  };\n  self._getParseContext = () => parseContext || {};\n  self._hasParseCallback = () => !!parseFn;\n  self.option = self.options = function option(key, opt) {\n    argsert('<string|object> [object]', [key, opt], arguments.length);\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.options(k, key[k]);\n      });\n    } else {\n      if (typeof opt !== 'object') {\n        opt = {};\n      }\n      options.key[key] = true;\n      if (opt.alias) self.alias(key, opt.alias);\n      const deprecate = opt.deprecate || opt.deprecated;\n      if (deprecate) {\n        self.deprecateOption(key, deprecate);\n      }\n      const demand = opt.demand || opt.required || opt.require;\n      if (demand) {\n        self.demand(key, demand);\n      }\n      if (opt.demandOption) {\n        self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);\n      }\n      if (opt.conflicts) {\n        self.conflicts(key, opt.conflicts);\n      }\n      if ('default' in opt) {\n        self.default(key, opt.default);\n      }\n      if (opt.implies !== undefined) {\n        self.implies(key, opt.implies);\n      }\n      if (opt.nargs !== undefined) {\n        self.nargs(key, opt.nargs);\n      }\n      if (opt.config) {\n        self.config(key, opt.configParser);\n      }\n      if (opt.normalize) {\n        self.normalize(key);\n      }\n      if (opt.choices) {\n        self.choices(key, opt.choices);\n      }\n      if (opt.coerce) {\n        self.coerce(key, opt.coerce);\n      }\n      if (opt.group) {\n        self.group(key, opt.group);\n      }\n      if (opt.boolean || opt.type === 'boolean') {\n        self.boolean(key);\n        if (opt.alias) self.boolean(opt.alias);\n      }\n      if (opt.array || opt.type === 'array') {\n        self.array(key);\n        if (opt.alias) self.array(opt.alias);\n      }\n      if (opt.number || opt.type === 'number') {\n        self.number(key);\n        if (opt.alias) self.number(opt.alias);\n      }\n      if (opt.string || opt.type === 'string') {\n        self.string(key);\n        if (opt.alias) self.string(opt.alias);\n      }\n      if (opt.count || opt.type === 'count') {\n        self.count(key);\n      }\n      if (typeof opt.global === 'boolean') {\n        self.global(key, opt.global);\n      }\n      if (opt.defaultDescription) {\n        options.defaultDescription[key] = opt.defaultDescription;\n      }\n      if (opt.skipValidation) {\n        self.skipValidation(key);\n      }\n      const desc = opt.describe || opt.description || opt.desc;\n      self.describe(key, desc);\n      if (opt.hidden) {\n        self.hide(key);\n      }\n      if (opt.requiresArg) {\n        self.requiresArg(key);\n      }\n    }\n    return self;\n  };\n  self.getOptions = () => options;\n  self.positional = function (key, opts) {\n    argsert('<string> <object>', [key, opts], arguments.length);\n    if (context.resets === 0) {\n      throw new YError(\".positional() can only be called in a command's builder function\");\n    }\n    const supportedOpts = ['default', 'defaultDescription', 'implies', 'normalize', 'choices', 'conflicts', 'coerce', 'type', 'describe', 'desc', 'description', 'alias'];\n    opts = objFilter(opts, (k, v) => {\n      let accept = supportedOpts.indexOf(k) !== -1;\n      if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1) accept = false;\n      return accept;\n    });\n    const fullCommand = context.fullCommands[context.fullCommands.length - 1];\n    const parseOptions = fullCommand ? command$1.cmdToParseOptions(fullCommand) : {\n      array: [],\n      alias: {},\n      default: {},\n      demand: {}\n    };\n    objectKeys(parseOptions).forEach(pk => {\n      const parseOption = parseOptions[pk];\n      if (Array.isArray(parseOption)) {\n        if (parseOption.indexOf(key) !== -1) opts[pk] = true;\n      } else {\n        if (parseOption[key] && !(pk in opts)) opts[pk] = parseOption[key];\n      }\n    });\n    self.group(key, usage$1.getPositionalGroupName());\n    return self.option(key, opts);\n  };\n  self.group = function group(opts, groupName) {\n    argsert('<string|array> <string>', [opts, groupName], arguments.length);\n    const existing = preservedGroups[groupName] || groups[groupName];\n    if (preservedGroups[groupName]) {\n      delete preservedGroups[groupName];\n    }\n    const seen = {};\n    groups[groupName] = (existing || []).concat(opts).filter(key => {\n      if (seen[key]) return false;\n      return seen[key] = true;\n    });\n    return self;\n  };\n  self.getGroups = () => Object.assign({}, groups, preservedGroups);\n  self.env = function (prefix) {\n    argsert('[string|boolean]', [prefix], arguments.length);\n    if (prefix === false) delete options.envPrefix;else options.envPrefix = prefix || '';\n    return self;\n  };\n  self.wrap = function (cols) {\n    argsert('<number|null|undefined>', [cols], arguments.length);\n    usage$1.wrap(cols);\n    return self;\n  };\n  let strict = false;\n  self.strict = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length);\n    strict = enabled !== false;\n    return self;\n  };\n  self.getStrict = () => strict;\n  let strictCommands = false;\n  self.strictCommands = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length);\n    strictCommands = enabled !== false;\n    return self;\n  };\n  self.getStrictCommands = () => strictCommands;\n  let strictOptions = false;\n  self.strictOptions = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length);\n    strictOptions = enabled !== false;\n    return self;\n  };\n  self.getStrictOptions = () => strictOptions;\n  let parserConfig = {};\n  self.parserConfiguration = function parserConfiguration(config) {\n    argsert('<object>', [config], arguments.length);\n    parserConfig = config;\n    return self;\n  };\n  self.getParserConfiguration = () => parserConfig;\n  self.showHelp = function (level) {\n    argsert('[string|function]', [level], arguments.length);\n    if (!self.parsed) self._parseArgs(processArgs);\n    if (command$1.hasDefaultCommand()) {\n      context.resets++;\n      command$1.runDefaultBuilderOn(self);\n    }\n    usage$1.showHelp(level);\n    return self;\n  };\n  let versionOpt = null;\n  self.version = function version(opt, msg, ver) {\n    const defaultVersionOpt = 'version';\n    argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length);\n    if (versionOpt) {\n      deleteFromParserHintObject(versionOpt);\n      usage$1.version(undefined);\n      versionOpt = null;\n    }\n    if (arguments.length === 0) {\n      ver = guessVersion();\n      opt = defaultVersionOpt;\n    } else if (arguments.length === 1) {\n      if (opt === false) {\n        return self;\n      }\n      ver = opt;\n      opt = defaultVersionOpt;\n    } else if (arguments.length === 2) {\n      ver = msg;\n      msg = undefined;\n    }\n    versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt;\n    msg = msg || usage$1.deferY18nLookup('Show version number');\n    usage$1.version(ver || undefined);\n    self.boolean(versionOpt);\n    self.describe(versionOpt, msg);\n    return self;\n  };\n  function guessVersion() {\n    const obj = pkgUp();\n    return obj.version || 'unknown';\n  }\n  let helpOpt = null;\n  self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {\n    const defaultHelpOpt = 'help';\n    argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n    if (helpOpt) {\n      deleteFromParserHintObject(helpOpt);\n      helpOpt = null;\n    }\n    if (arguments.length === 1) {\n      if (opt === false) return self;\n    }\n    helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt;\n    self.boolean(helpOpt);\n    self.describe(helpOpt, msg || usage$1.deferY18nLookup('Show help'));\n    return self;\n  };\n  const defaultShowHiddenOpt = 'show-hidden';\n  options.showHiddenOpt = defaultShowHiddenOpt;\n  self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {\n    argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n    if (arguments.length === 1) {\n      if (opt === false) return self;\n    }\n    const showHiddenOpt = typeof opt === 'string' ? opt : defaultShowHiddenOpt;\n    self.boolean(showHiddenOpt);\n    self.describe(showHiddenOpt, msg || usage$1.deferY18nLookup('Show hidden options'));\n    options.showHiddenOpt = showHiddenOpt;\n    return self;\n  };\n  self.hide = function hide(key) {\n    argsert('<string>', [key], arguments.length);\n    options.hiddenOptions.push(key);\n    return self;\n  };\n  self.showHelpOnFail = function showHelpOnFail(enabled, message) {\n    argsert('[boolean|string] [string]', [enabled, message], arguments.length);\n    usage$1.showHelpOnFail(enabled, message);\n    return self;\n  };\n  let exitProcess = true;\n  self.exitProcess = function (enabled = true) {\n    argsert('[boolean]', [enabled], arguments.length);\n    exitProcess = enabled;\n    return self;\n  };\n  self.getExitProcess = () => exitProcess;\n  self.showCompletionScript = function ($0, cmd) {\n    argsert('[string] [string]', [$0, cmd], arguments.length);\n    $0 = $0 || self.$0;\n    _logger.log(completion$1.generateCompletionScript($0, cmd || completionCommand || 'completion'));\n    return self;\n  };\n  self.getCompletion = function (args, done) {\n    argsert('<array> <function>', [args, done], arguments.length);\n    completion$1.getCompletion(args, done);\n  };\n  self.locale = function (locale) {\n    argsert('[string]', [locale], arguments.length);\n    if (!locale) {\n      guessLocale();\n      return y18n.getLocale();\n    }\n    detectLocale = false;\n    y18n.setLocale(locale);\n    return self;\n  };\n  self.updateStrings = self.updateLocale = function (obj) {\n    argsert('<object>', [obj], arguments.length);\n    detectLocale = false;\n    y18n.updateLocale(obj);\n    return self;\n  };\n  let detectLocale = true;\n  self.detectLocale = function (detect) {\n    argsert('<boolean>', [detect], arguments.length);\n    detectLocale = detect;\n    return self;\n  };\n  self.getDetectLocale = () => detectLocale;\n  const _logger = {\n    log(...args) {\n      if (!self._hasParseCallback()) console.log(...args);\n      hasOutput = true;\n      if (output.length) output += '\\n';\n      output += args.join(' ');\n    },\n    error(...args) {\n      if (!self._hasParseCallback()) console.error(...args);\n      hasOutput = true;\n      if (output.length) output += '\\n';\n      output += args.join(' ');\n    }\n  };\n  self._getLoggerInstance = () => _logger;\n  self._hasOutput = () => hasOutput;\n  self._setHasOutput = () => {\n    hasOutput = true;\n  };\n  let recommendCommands;\n  self.recommendCommands = function (recommend = true) {\n    argsert('[boolean]', [recommend], arguments.length);\n    recommendCommands = recommend;\n    return self;\n  };\n  self.getUsageInstance = () => usage$1;\n  self.getValidationInstance = () => validation$1;\n  self.getCommandInstance = () => command$1;\n  self.terminalWidth = () => {\n    argsert([], 0);\n    return shim$1.process.stdColumns;\n  };\n  Object.defineProperty(self, 'argv', {\n    get: () => self._parseArgs(processArgs),\n    enumerable: true\n  });\n  self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {\n    let skipValidation = !!_calledFromCommand;\n    args = args || processArgs;\n    options.__ = y18n.__;\n    options.configuration = self.getParserConfiguration();\n    const populateDoubleDash = !!options.configuration['populate--'];\n    const config = Object.assign({}, options.configuration, {\n      'populate--': true\n    });\n    const parsed = shim$1.Parser.detailed(args, Object.assign({}, options, {\n      configuration: Object.assign({\n        'parse-positional-numbers': false\n      }, config)\n    }));\n    let argv = parsed.argv;\n    if (parseContext) argv = Object.assign({}, argv, parseContext);\n    const aliases = parsed.aliases;\n    argv.$0 = self.$0;\n    self.parsed = parsed;\n    try {\n      guessLocale();\n      if (shortCircuit) {\n        return self._postProcess(argv, populateDoubleDash, _calledFromCommand);\n      }\n      if (helpOpt) {\n        const helpCmds = [helpOpt].concat(aliases[helpOpt] || []).filter(k => k.length > 1);\n        if (~helpCmds.indexOf('' + argv._[argv._.length - 1])) {\n          argv._.pop();\n          argv[helpOpt] = true;\n        }\n      }\n      const handlerKeys = command$1.getCommands();\n      const requestCompletions = (completion$1.completionKey in argv);\n      const skipRecommendation = argv[helpOpt] || requestCompletions;\n      const skipDefaultCommand = skipRecommendation && (handlerKeys.length > 1 || handlerKeys[0] !== '$0');\n      if (argv._.length) {\n        if (handlerKeys.length) {\n          let firstUnknownCommand;\n          for (let i = commandIndex || 0, cmd; argv._[i] !== undefined; i++) {\n            cmd = String(argv._[i]);\n            if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n              const innerArgv = command$1.runCommand(cmd, self, parsed, i + 1);\n              return self._postProcess(innerArgv, populateDoubleDash);\n            } else if (!firstUnknownCommand && cmd !== completionCommand) {\n              firstUnknownCommand = cmd;\n              break;\n            }\n          }\n          if (command$1.hasDefaultCommand() && !skipDefaultCommand) {\n            const innerArgv = command$1.runCommand(null, self, parsed);\n            return self._postProcess(innerArgv, populateDoubleDash);\n          }\n          if (recommendCommands && firstUnknownCommand && !skipRecommendation) {\n            validation$1.recommendCommands(firstUnknownCommand, handlerKeys);\n          }\n        }\n        if (completionCommand && ~argv._.indexOf(completionCommand) && !requestCompletions) {\n          if (exitProcess) setBlocking(true);\n          self.showCompletionScript();\n          self.exit(0);\n        }\n      } else if (command$1.hasDefaultCommand() && !skipDefaultCommand) {\n        const innerArgv = command$1.runCommand(null, self, parsed);\n        return self._postProcess(innerArgv, populateDoubleDash);\n      }\n      if (requestCompletions) {\n        if (exitProcess) setBlocking(true);\n        args = [].concat(args);\n        const completionArgs = args.slice(args.indexOf(`--${completion$1.completionKey}`) + 1);\n        completion$1.getCompletion(completionArgs, completions => {\n          (completions || []).forEach(completion => {\n            _logger.log(completion);\n          });\n          self.exit(0);\n        });\n        return self._postProcess(argv, !populateDoubleDash, _calledFromCommand);\n      }\n      if (!hasOutput) {\n        Object.keys(argv).forEach(key => {\n          if (key === helpOpt && argv[key]) {\n            if (exitProcess) setBlocking(true);\n            skipValidation = true;\n            self.showHelp('log');\n            self.exit(0);\n          } else if (key === versionOpt && argv[key]) {\n            if (exitProcess) setBlocking(true);\n            skipValidation = true;\n            usage$1.showVersion();\n            self.exit(0);\n          }\n        });\n      }\n      if (!skipValidation && options.skipValidation.length > 0) {\n        skipValidation = Object.keys(argv).some(key => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);\n      }\n      if (!skipValidation) {\n        if (parsed.error) throw new YError(parsed.error.message);\n        if (!requestCompletions) {\n          self._runValidation(argv, aliases, {}, parsed.error);\n        }\n      }\n    } catch (err) {\n      if (err instanceof YError) usage$1.fail(err.message, err);else throw err;\n    }\n    return self._postProcess(argv, populateDoubleDash, _calledFromCommand);\n  };\n  self._postProcess = function (argv, populateDoubleDash, calledFromCommand = false) {\n    if (isPromise(argv)) return argv;\n    if (calledFromCommand) return argv;\n    if (!populateDoubleDash) {\n      argv = self._copyDoubleDash(argv);\n    }\n    const parsePositionalNumbers = self.getParserConfiguration()['parse-positional-numbers'] || self.getParserConfiguration()['parse-positional-numbers'] === undefined;\n    if (parsePositionalNumbers) {\n      argv = self._parsePositionalNumbers(argv);\n    }\n    return argv;\n  };\n  self._copyDoubleDash = function (argv) {\n    if (!argv._ || !argv['--']) return argv;\n    argv._.push.apply(argv._, argv['--']);\n    try {\n      delete argv['--'];\n    } catch (_err) {}\n    return argv;\n  };\n  self._parsePositionalNumbers = function (argv) {\n    const args = argv['--'] ? argv['--'] : argv._;\n    for (let i = 0, arg; (arg = args[i]) !== undefined; i++) {\n      if (shim$1.Parser.looksLikeNumber(arg) && Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {\n        args[i] = Number(arg);\n      }\n    }\n    return argv;\n  };\n  self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) {\n    if (parseErrors) throw new YError(parseErrors.message);\n    validation$1.nonOptionCount(argv);\n    validation$1.requiredArguments(argv);\n    let failedStrictCommands = false;\n    if (strictCommands) {\n      failedStrictCommands = validation$1.unknownCommands(argv);\n    }\n    if (strict && !failedStrictCommands) {\n      validation$1.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);\n    } else if (strictOptions) {\n      validation$1.unknownArguments(argv, aliases, {}, false, false);\n    }\n    validation$1.customChecks(argv, aliases);\n    validation$1.limitedChoices(argv);\n    validation$1.implications(argv);\n    validation$1.conflicting(argv);\n  };\n  function guessLocale() {\n    if (!detectLocale) return;\n    const locale = shim$1.getEnv('LC_ALL') || shim$1.getEnv('LC_MESSAGES') || shim$1.getEnv('LANG') || shim$1.getEnv('LANGUAGE') || 'en_US';\n    self.locale(locale.replace(/[.:].*/, ''));\n  }\n  self.help();\n  self.version();\n  return self;\n}\nconst rebase = (base, dir) => shim$1.path.relative(base, dir);\nfunction isYargsInstance(y) {\n  return !!y && typeof y._parseArgs === 'function';\n}\nvar _a, _b;\nconst {\n  readFileSync\n} = require('fs');\nconst {\n  inspect\n} = require('util');\nconst {\n  resolve\n} = require('path');\nconst y18n = require('y18n');\nconst Parser = require('yargs-parser');\nvar cjsPlatformShim = {\n  assert: {\n    notStrictEqual: assert.notStrictEqual,\n    strictEqual: assert.strictEqual\n  },\n  cliui: require('cliui'),\n  findUp: require('escalade/sync'),\n  getEnv: key => {\n    return process.env[key];\n  },\n  getCallerFile: require('get-caller-file'),\n  getProcessArgvBin: getProcessArgvBin,\n  inspect,\n  mainFilename: (_b = (_a = require === null || require === void 0 ? void 0 : require.main) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : process.cwd(),\n  Parser,\n  path: require('path'),\n  process: {\n    argv: () => process.argv,\n    cwd: process.cwd,\n    execPath: () => process.execPath,\n    exit: code => {\n      process.exit(code);\n    },\n    nextTick: process.nextTick,\n    stdColumns: typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null\n  },\n  readFileSync,\n  require: require,\n  requireDirectory: require('require-directory'),\n  stringWidth: require('string-width'),\n  y18n: y18n({\n    directory: resolve(__dirname, '../locales'),\n    updateFiles: false\n  })\n};\nconst minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 10;\nif (process && process.version) {\n  const major = Number(process.version.match(/v([^.]+)/)[1]);\n  if (major < minNodeVersion) {\n    throw Error(`yargs supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs#supported-nodejs-versions`);\n  }\n}\nconst Parser$1 = require('yargs-parser');\nconst Yargs$1 = YargsWithShim(cjsPlatformShim);\nvar cjs = {\n  applyExtends,\n  cjsPlatformShim,\n  Yargs: Yargs$1,\n  argsert,\n  globalMiddlewareFactory,\n  isPromise,\n  objFilter,\n  parseCommand,\n  Parser: Parser$1,\n  processArgv,\n  rebase,\n  YError\n};\nmodule.exports = cjs;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwiWUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1zZyIsIm5hbWUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsInByZXZpb3VzbHlWaXNpdGVkQ29uZmlncyIsInNoaW0iLCJhcHBseUV4dGVuZHMiLCJjb25maWciLCJjd2QiLCJtZXJnZUV4dGVuZHMiLCJfc2hpbSIsImRlZmF1bHRDb25maWciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJleHRlbmRzIiwiaXNQYXRoIiwidGVzdCIsInBhdGhUb0RlZmF1bHQiLCJyZXNvbHZlIiwiX2VyciIsImdldFBhdGhUb0RlZmF1bHRDb25maWciLCJjaGVja0ZvckNpcmN1bGFyRXh0ZW5kcyIsInB1c2giLCJKU09OIiwicGFyc2UiLCJyZWFkRmlsZVN5bmMiLCJwYXRoIiwiZGlybmFtZSIsIm1lcmdlRGVlcCIsImFzc2lnbiIsImNmZ1BhdGgiLCJpbmRleE9mIiwicGF0aFRvRXh0ZW5kIiwiY29uZmlnMSIsImNvbmZpZzIiLCJ0YXJnZXQiLCJpc09iamVjdCIsIm9iaiIsIkFycmF5IiwiaXNBcnJheSIsImtleSIsImtleXMiLCJwYXJzZUNvbW1hbmQiLCJjbWQiLCJleHRyYVNwYWNlc1N0cmlwcGVkQ29tbWFuZCIsInJlcGxhY2UiLCJzcGxpdENvbW1hbmQiLCJzcGxpdCIsImJyZWdleCIsImZpcnN0Q29tbWFuZCIsInNoaWZ0IiwicGFyc2VkQ29tbWFuZCIsImRlbWFuZGVkIiwib3B0aW9uYWwiLCJmb3JFYWNoIiwiaSIsInZhcmlhZGljIiwibGVuZ3RoIiwicG9zaXRpb25OYW1lIiwiYXJnc2VydCIsImFyZzEiLCJhcmcyIiwiYXJnMyIsInBhcnNlQXJncyIsInBvc2l0aW9uIiwicGFyc2VkIiwiY2FsbGVyQXJndW1lbnRzIiwiX2xlbmd0aCIsImFyZ3MiLCJzbGljZSIsInVuZGVmaW5lZCIsInBvcCIsInRvdGFsQ29tbWFuZHMiLCJhcmciLCJvYnNlcnZlZFR5cGUiLCJndWVzc1R5cGUiLCJtYXRjaGluZ1R5cGVzIiwiZmlsdGVyIiwidHlwZSIsImFyZ3VtZW50VHlwZUVycm9yIiwiZXJyIiwiY29uc29sZSIsIndhcm4iLCJzdGFjayIsImFsbG93ZWRUeXBlcyIsImpvaW4iLCJpc1Byb21pc2UiLCJtYXliZVByb21pc2UiLCJ0aGVuIiwiYXNzZXJ0Tm90U3RyaWN0RXF1YWwiLCJhY3R1YWwiLCJleHBlY3RlZCIsIm1lc3NhZ2UiLCJub3RTdHJpY3RFcXVhbCIsImFzc2VydFNpbmdsZUtleSIsInN0cmljdEVxdWFsIiwib2JqZWN0S2V5cyIsIm9iamVjdCIsIm9iakZpbHRlciIsIm9yaWdpbmFsIiwiZ2xvYmFsTWlkZGxld2FyZUZhY3RvcnkiLCJnbG9iYWxNaWRkbGV3YXJlIiwiY29udGV4dCIsImNhbGxiYWNrIiwiYXBwbHlCZWZvcmVWYWxpZGF0aW9uIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJjb21tYW5kTWlkZGxld2FyZUZhY3RvcnkiLCJjb21tYW5kTWlkZGxld2FyZSIsIm1hcCIsIm1pZGRsZXdhcmUiLCJhcHBseU1pZGRsZXdhcmUiLCJhcmd2IiwieWFyZ3MiLCJtaWRkbGV3YXJlcyIsImJlZm9yZVZhbGlkYXRpb24iLCJiZWZvcmVWYWxpZGF0aW9uRXJyb3IiLCJyZWR1Y2UiLCJhY2MiLCJpbml0aWFsT2JqIiwiUHJvbWlzZSIsImFsbCIsIm1pZGRsZXdhcmVPYmoiLCJyZXN1bHQiLCJnZXRQcm9jZXNzQXJndkJpbkluZGV4IiwiaXNCdW5kbGVkRWxlY3Ryb25BcHAiLCJpc0VsZWN0cm9uQXBwIiwicHJvY2VzcyIsImRlZmF1bHRBcHAiLCJ2ZXJzaW9ucyIsImVsZWN0cm9uIiwiaGlkZUJpbiIsImdldFByb2Nlc3NBcmd2QmluIiwicHJvY2Vzc0FyZ3YiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJ3aGljaE1vZHVsZSIsImV4cG9ydGVkIiwiZmlsZXMiLCJjYWNoZSIsIm1vZCIsImV4cG9ydHMiLCJERUZBVUxUX01BUktFUiIsImNvbW1hbmQiLCJ1c2FnZSIsInZhbGlkYXRpb24iLCJzZWxmIiwiaGFuZGxlcnMiLCJhbGlhc01hcCIsImRlZmF1bHRDb21tYW5kIiwiYWRkSGFuZGxlciIsImRlc2NyaXB0aW9uIiwiYnVpbGRlciIsImhhbmRsZXIiLCJkZXByZWNhdGVkIiwiYWxpYXNlcyIsImlzQ29tbWFuZEFuZEFsaWFzZXMiLCJpc0NvbW1hbmRIYW5kbGVyRGVmaW5pdGlvbiIsIm1vZHVsZU5hbWUiLCJjb25jYXQiLCJleHRyYWN0RGVzYyIsImlzQ29tbWFuZEJ1aWxkZXJEZWZpbml0aW9uIiwiYWxpYXMiLCJpc0RlZmF1bHQiLCJwYXJzZWRBbGlhc2VzIiwiYyIsImFkZERpcmVjdG9yeSIsImRpciIsInJlcSIsImNhbGxlckZpbGUiLCJvcHRzIiwicmVjdXJzZSIsImV4dGVuc2lvbnMiLCJwYXJlbnRWaXNpdCIsInZpc2l0IiwibyIsImpvaW5lZCIsImZpbGVuYW1lIiwidmlzaXRlZCIsInJlcXVpcmVEaXJlY3RvcnkiLCJpbnNwZWN0IiwiY29tbWFuZEZyb21GaWxlbmFtZSIsImJhc2VuYW1lIiwiZXh0bmFtZSIsImRlc2NyaWJlIiwiZGVzYyIsImdldENvbW1hbmRzIiwiZ2V0Q29tbWFuZEhhbmRsZXJzIiwiaGFzRGVmYXVsdENvbW1hbmQiLCJydW5Db21tYW5kIiwiY29tbWFuZEluZGV4IiwiY29tbWFuZEhhbmRsZXIiLCJjdXJyZW50Q29udGV4dCIsImdldENvbnRleHQiLCJudW1GaWxlcyIsInBhcmVudENvbW1hbmRzIiwiY29tbWFuZHMiLCJpbm5lckFyZ3YiLCJwb3NpdGlvbmFsTWFwIiwiZnVsbENvbW1hbmRzIiwiaXNDb21tYW5kQnVpbGRlckNhbGxiYWNrIiwiYnVpbGRlck91dHB1dCIsInJlc2V0IiwiaW5uZXJZYXJncyIsImlzWWFyZ3NJbnN0YW5jZSIsInNob3VsZFVwZGF0ZVVzYWdlIiwiZ2V0VXNhZ2VJbnN0YW5jZSIsInVzYWdlRnJvbVBhcmVudENvbW1hbmRzQ29tbWFuZEhhbmRsZXIiLCJfcGFyc2VBcmdzIiwiaXNDb21tYW5kQnVpbGRlck9wdGlvbkRlZmluaXRpb25zIiwib3B0aW9uIiwiX2hhc091dHB1dCIsInBvcHVsYXRlUG9zaXRpb25hbHMiLCJfcnVuVmFsaWRhdGlvbiIsImVycm9yIiwiX3NldEhhc091dHB1dCIsInBvcHVsYXRlRG91YmxlRGFzaCIsImdldE9wdGlvbnMiLCJjb25maWd1cmF0aW9uIiwiX3Bvc3RQcm9jZXNzIiwiaGFuZGxlclJlc3VsdCIsImhhbmRsZXJGaW5pc2hDb21tYW5kIiwiZ2V0SGFuZGxlckZpbmlzaENvbW1hbmQiLCJjYWNoZUhlbHBNZXNzYWdlIiwidmFsdWUiLCJjYXRjaCIsImZhaWwiLCJjbGVhckNhY2hlZEhlbHBNZXNzYWdlIiwic3BsaWNlIiwiZ2V0VXNhZ2VEaXNhYmxlZCIsImdldFVzYWdlIiwidHJpbSIsInBjIiwicnVuRGVmYXVsdEJ1aWxkZXJPbiIsImNvbW1hbmRTdHJpbmciLCJfIiwicG9zaXRpb25hbENvdW50IiwiZGVtYW5kIiwicG9wdWxhdGVQb3NpdGlvbmFsIiwibWF5YmUiLCJhIiwicG9zdFByb2Nlc3NQb3NpdGlvbmFscyIsImNtZFRvUGFyc2VPcHRpb25zIiwicG9zaXRpb25hbCIsIlN0cmluZyIsInBhcnNlT3B0aW9ucyIsIm9wdGlvbnMiLCJkZWZhdWx0IiwiYXJyYXkiLCJ1bnBhcnNlZCIsIlBhcnNlciIsImRldGFpbGVkIiwicG9zaXRpb25hbEtleXMiLCJjbWRTdHJpbmciLCJkIiwiZnJvemVucyIsInVuZnJlZXplIiwiZnJvemVuIiwiZXZlcnkiLCJzZXRCbG9ja2luZyIsImJsb2NraW5nIiwic3Rkb3V0Iiwic3RkZXJyIiwiX3N0cmVhbSIsInN0cmVhbSIsIl9oYW5kbGUiLCJpc1RUWSIsInkxOG4iLCJfXyIsImZhaWxzIiwiZmFpbEZuIiwiZiIsImZhaWxNZXNzYWdlIiwic2hvd0hlbHBPbkZhaWwiLCJzaG93SGVscE9uRmFpbEZuIiwicGFyc2VGdW5jdGlvbkFyZ3MiLCJlbmFibGVkIiwiZmFpbHVyZU91dHB1dCIsImxvZ2dlciIsIl9nZXRMb2dnZXJJbnN0YW5jZSIsImdldEV4aXRQcm9jZXNzIiwic2hvd0hlbHAiLCJleGl0IiwiX2hhc1BhcnNlQ2FsbGJhY2siLCJ1c2FnZXMiLCJ1c2FnZURpc2FibGVkIiwiZ2V0UG9zaXRpb25hbEdyb3VwTmFtZSIsImV4YW1wbGVzIiwiZXhhbXBsZSIsImNtZEFycmF5IiwiZGVzY3JpcHRpb25zIiwia2V5T3JLZXlzIiwiayIsImdldERlc2NyaXB0aW9ucyIsImVwaWxvZ3MiLCJlcGlsb2ciLCJ3cmFwU2V0Iiwid3JhcCIsImNvbHMiLCJnZXRXcmFwIiwid2luZG93V2lkdGgiLCJkZWZlclkxOG5Mb29rdXBQcmVmaXgiLCJkZWZlclkxOG5Mb29rdXAiLCJzdHIiLCJoZWxwIiwiY2FjaGVkSGVscE1lc3NhZ2UiLCJub3JtYWxpemVBbGlhc2VzIiwiYmFzZSQwIiwiY3VzdG9tU2NyaXB0TmFtZSIsIiQwIiwiZGVtYW5kZWRPcHRpb25zIiwiZ2V0RGVtYW5kZWRPcHRpb25zIiwiZGVtYW5kZWRDb21tYW5kcyIsImdldERlbWFuZGVkQ29tbWFuZHMiLCJkZXByZWNhdGVkT3B0aW9ucyIsImdldERlcHJlY2F0ZWRPcHRpb25zIiwiZ3JvdXBzIiwiZ2V0R3JvdXBzIiwiZmlsdGVySGlkZGVuT3B0aW9ucyIsInRoZVdyYXAiLCJ1aSIsImNsaXVpIiwid2lkdGgiLCJkaXYiLCJ0ZXh0IiwicGFkZGluZyIsInUiLCJnZXRQYXJzZXJDb25maWd1cmF0aW9uIiwic29ydCIsImIiLCJsb2NhbGVDb21wYXJlIiwic3BhbiIsIm1heFdpZHRoIiwiaGludHMiLCJhbGlnbiIsImFsaWFzS2V5cyIsIm5ld0FsaWFzZXMiLCJkZWZhdWx0R3JvdXAiLCJhZGRVbmdyb3VwZWRLZXlzIiwiaXNMb25nU3dpdGNoIiwic3ciLCJnZXRUZXh0IiwiZGlzcGxheWVkR3JvdXBzIiwiZ3JvdXBOYW1lIiwibm9ybWFsaXplZEtleXMiLCJhbGlhc0tleSIsInN3aXRjaGVzIiwiYm9vbGVhbiIsInN3MSIsInN3MiIsInNob3J0U3dpdGNoZXNVc2VkIiwic29tZSIsImFkZEluZGVudGF0aW9uIiwia3N3aXRjaCIsImxhc3RJbmRleE9mIiwic3Vic3RyaW5nIiwiY291bnQiLCJzdHJpbmciLCJub3JtYWxpemUiLCJudW1iZXIiLCJkZXByZWNhdGVkRXh0cmEiLCJleHRyYSIsImNob2ljZXMiLCJzdHJpbmdpZmllZFZhbHVlcyIsImRlZmF1bHRTdHJpbmciLCJkZWZhdWx0RGVzY3JpcHRpb24iLCJCb29sZWFuIiwiZ2V0SW5kZW50YXRpb24iLCJlIiwidG9TdHJpbmciLCJ0YWJsZSIsIm1vZGlmaWVyIiwidmFsdWVzIiwidiIsIk1hdGgiLCJtYXgiLCJzdHJpbmdXaWR0aCIsIm1pbiIsInBhcnNlSW50IiwiZGVtYW5kT3B0aW9uIiwiZ3JvdXBlZEtleXMiLCJ0b0NoZWNrIiwiZ3JvdXAiLCJoaWRkZW5PcHRpb25zIiwic2hvd0hpZGRlbk9wdCIsImxldmVsIiwiZW1pdCIsImZ1bmN0aW9uRGVzY3JpcHRpb24iLCJmbiIsImRlY2FtZWxpemUiLCJzZXBhcmF0b3IiLCJzZXAiLCJzdHJpbmdpZnkiLCJzdGRDb2x1bW5zIiwidmVyc2lvbiIsInZlciIsInNob3dWZXJzaW9uIiwibG9nIiwibG9jYWxMb29rdXAiLCJpc0luZGVudGVkVGV4dCIsImluZGVudCIsImluZGVudGF0aW9uIiwiY29tcGxldGlvblNoVGVtcGxhdGUiLCJjb21wbGV0aW9uWnNoVGVtcGxhdGUiLCJjb21wbGV0aW9uIiwiY29tcGxldGlvbktleSIsInNldFBhcnNlZCIsInpzaFNoZWxsIiwiZ2V0RW52IiwiZ2V0Q29tcGxldGlvbiIsImRvbmUiLCJjb21wbGV0aW9ucyIsImN1cnJlbnQiLCJydW5Db21wbGV0aW9uRnVuY3Rpb24iLCJjb21wbGV0aW9uRnVuY3Rpb24iLCJpc1N5bmNDb21wbGV0aW9uRnVuY3Rpb24iLCJsaXN0IiwibmV4dFRpY2siLCJpaSIsInkiLCJtYXRjaCIsInVzYWdlQ29tbWFuZCIsImNvbW1hbmROYW1lIiwiZGVzY3MiLCJuZWdhYmxlIiwiaW5jbHVkZXMiLCJrZXlBbmRBbGlhc2VzIiwiY29tcGxldGVPcHRpb25LZXkiLCJub3RJbkFyZ3MiLCJ2YWwiLCJzdGFydHNCeVR3b0Rhc2hlcyIsInMiLCJpc1Nob3J0T3B0aW9uIiwiZGFzaGVzIiwiZ2VuZXJhdGVDb21wbGV0aW9uU2NyaXB0Iiwic2NyaXB0IiwicmVnaXN0ZXJGdW5jdGlvbiIsImxldmVuc2h0ZWluIiwibWF0cml4IiwiaiIsImNoYXJBdCIsInNwZWNpYWxLZXlzIiwiX19uIiwibm9uT3B0aW9uQ291bnQiLCJfcyIsIm1pbk1zZyIsIm1heE1zZyIsInJlcXVpcmVkIiwib2JzZXJ2ZWQiLCJyZXF1aXJlZEFyZ3VtZW50cyIsIm1pc3NpbmciLCJjdXN0b21Nc2dzIiwiY3VzdG9tTXNnIiwidW5rbm93bkFyZ3VtZW50cyIsImlzRGVmYXVsdENvbW1hbmQiLCJjaGVja1Bvc2l0aW9uYWxzIiwiY29tbWFuZEtleXMiLCJnZXRDb21tYW5kSW5zdGFuY2UiLCJ1bmtub3duIiwiX2dldFBhcnNlQ29udGV4dCIsImlzVmFsaWRBbmRTb21lQWxpYXNJc05vdE5ldyIsInVua25vd25Db21tYW5kcyIsImxpbWl0ZWRDaG9pY2VzIiwiaW52YWxpZCIsImludmFsaWRLZXlzIiwiY2hlY2tzIiwiY2hlY2siLCJnbG9iYWwiLCJmdW5jIiwiY3VzdG9tQ2hlY2tzIiwiaW1wbGllZCIsImltcGxpZXMiLCJnZXRJbXBsaWVkIiwia2V5RXhpc3RzIiwibnVtIiwiTnVtYmVyIiwiaXNOYU4iLCJpbXBsaWNhdGlvbnMiLCJpbXBseUZhaWwiLCJvcmlnS2V5Iiwib3JpZ1ZhbHVlIiwiY29uZmxpY3RpbmciLCJjb25mbGljdHMiLCJnZXRDb25mbGljdGluZyIsImNvbmZsaWN0aW5nRm4iLCJyZWNvbW1lbmRDb21tYW5kcyIsInBvdGVudGlhbENvbW1hbmRzIiwidGhyZXNob2xkIiwicmVjb21tZW5kZWQiLCJiZXN0RGlzdGFuY2UiLCJJbmZpbml0eSIsImNhbmRpZGF0ZSIsInNoaW0kMSIsIllhcmdzV2l0aFNoaW0iLCJZYXJncyIsInByb2Nlc3NBcmdzIiwicGFyZW50UmVxdWlyZSIsImNvbW1hbmQkMSIsImNvbXBsZXRpb24kMSIsIm91dHB1dCIsInByZXNlcnZlZEdyb3VwcyIsInVzYWdlJDEiLCJ2YWxpZGF0aW9uJDEiLCJzY3JpcHROYW1lIiwiZGVmYXVsdCQwIiwieCIsInJlYmFzZSIsImV4ZWNQYXRoIiwicmVzZXRzIiwiaGFzT3V0cHV0IiwiZXhpdEVycm9yIiwiY29kZSIsImV4aXRQcm9jZXNzIiwiY29tcGxldGlvbkNvbW1hbmQiLCJyZXNldE9wdGlvbnMiLCJ0bXBPcHRpb25zIiwibG9jYWwiLCJjb25maWdPYmplY3RzIiwibCIsImFycmF5T3B0aW9ucyIsIm9iamVjdE9wdGlvbnMiLCJlbnZQcmVmaXgiLCJzdHJpY3QiLCJzdHJpY3RDb21tYW5kcyIsInN0cmljdE9wdGlvbnMiLCJwYXJzZUZuIiwicGFyc2VDb250ZXh0IiwicG9wdWxhdGVQYXJzZXJIaW50QXJyYXkiLCJyZXF1aXJlc0FyZyIsIm5hcmciLCJwb3B1bGF0ZVBhcnNlckhpbnRTaW5nbGVWYWx1ZURpY3Rpb25hcnkiLCJOYU4iLCJza2lwVmFsaWRhdGlvbiIsInNhbml0aXplS2V5IiwibmFyZ3MiLCJwb3B1bGF0ZVBhcnNlckhpbnRBcnJheURpY3Rpb25hcnkiLCJkZWZhdWx0cyIsInNldEtleSIsInNldCIsImNvZXJjZSIsInBvcHVsYXRlUGFyc2VySGludERpY3Rpb25hcnkiLCJzaW5nbGVLZXlIYW5kbGVyIiwiZGVsZXRlRnJvbVBhcnNlckhpbnRPYmplY3QiLCJvcHRpb25LZXkiLCJoaW50S2V5IiwiaGludCIsImV4YW1wbGVQYXJhbXMiLCJjb21tYW5kRGlyIiwiZ2V0Q2FsbGVyRmlsZSIsImRlbWFuZENvbW1hbmQiLCJkZXByZWNhdGVPcHRpb24iLCJrZXkxIiwia2V5MiIsImVwaWxvZ3VlIiwib25GaW5pc2hDb21tYW5kIiwiX2dsb2JhbCIsImdsb2JhbHMiLCJnIiwicGtnQ29uZiIsInJvb3RQYXRoIiwiY29uZiIsInBrZ1VwIiwicGtncyIsIm5wYXRoIiwic3RhcnREaXIiLCJtYWluRmlsZW5hbWUiLCJwa2dKc29uUGF0aCIsImZpbmRVcCIsIm5hbWVzIiwiX25vb3AiLCJzaG9ydENpcmN1aXQiLCJfcGFyc2VGbiIsInRtcFBhcnNlZCIsIm9wdCIsImRlcHJlY2F0ZSIsImNvbmZpZ1BhcnNlciIsImhpZGRlbiIsImhpZGUiLCJzdXBwb3J0ZWRPcHRzIiwiYWNjZXB0IiwiZnVsbENvbW1hbmQiLCJwayIsInBhcnNlT3B0aW9uIiwiZXhpc3RpbmciLCJzZWVuIiwiZW52IiwicHJlZml4IiwiZ2V0U3RyaWN0IiwiZ2V0U3RyaWN0Q29tbWFuZHMiLCJnZXRTdHJpY3RPcHRpb25zIiwicGFyc2VyQ29uZmlnIiwicGFyc2VyQ29uZmlndXJhdGlvbiIsInZlcnNpb25PcHQiLCJkZWZhdWx0VmVyc2lvbk9wdCIsImd1ZXNzVmVyc2lvbiIsImhlbHBPcHQiLCJhZGRIZWxwT3B0IiwiZGVmYXVsdEhlbHBPcHQiLCJkZWZhdWx0U2hvd0hpZGRlbk9wdCIsImFkZFNob3dIaWRkZW5PcHQiLCJzaG93SGlkZGVuIiwic2hvd0NvbXBsZXRpb25TY3JpcHQiLCJfbG9nZ2VyIiwibG9jYWxlIiwiZ3Vlc3NMb2NhbGUiLCJnZXRMb2NhbGUiLCJkZXRlY3RMb2NhbGUiLCJzZXRMb2NhbGUiLCJ1cGRhdGVTdHJpbmdzIiwidXBkYXRlTG9jYWxlIiwiZGV0ZWN0IiwiZ2V0RGV0ZWN0TG9jYWxlIiwicmVjb21tZW5kIiwiZ2V0VmFsaWRhdGlvbkluc3RhbmNlIiwidGVybWluYWxXaWR0aCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZW51bWVyYWJsZSIsIl9jYWxsZWRGcm9tQ29tbWFuZCIsImhlbHBDbWRzIiwiaGFuZGxlcktleXMiLCJyZXF1ZXN0Q29tcGxldGlvbnMiLCJza2lwUmVjb21tZW5kYXRpb24iLCJza2lwRGVmYXVsdENvbW1hbmQiLCJmaXJzdFVua25vd25Db21tYW5kIiwiY29tcGxldGlvbkFyZ3MiLCJjYWxsZWRGcm9tQ29tbWFuZCIsIl9jb3B5RG91YmxlRGFzaCIsInBhcnNlUG9zaXRpb25hbE51bWJlcnMiLCJfcGFyc2VQb3NpdGlvbmFsTnVtYmVycyIsImxvb2tzTGlrZU51bWJlciIsImlzU2FmZUludGVnZXIiLCJmbG9vciIsInBhcnNlRmxvYXQiLCJydW5WYWxpZGF0aW9uIiwicGFyc2VFcnJvcnMiLCJmYWlsZWRTdHJpY3RDb21tYW5kcyIsImJhc2UiLCJyZWxhdGl2ZSIsIl9hIiwiX2IiLCJjanNQbGF0Zm9ybVNoaW0iLCJtYWluIiwiY29sdW1ucyIsImRpcmVjdG9yeSIsIl9fZGlybmFtZSIsInVwZGF0ZUZpbGVzIiwibWluTm9kZVZlcnNpb24iLCJZQVJHU19NSU5fTk9ERV9WRVJTSU9OIiwibWFqb3IiLCJQYXJzZXIkMSIsIllhcmdzJDEiLCJjanMiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IkM6XFxjb2RlXFxGbHVpZEZyYW1ld29yazVcXG5vZGVfbW9kdWxlc1xcLnBucG1cXHlhcmdzQDE2LjIuMFxcbm9kZV9tb2R1bGVzXFx5YXJnc1xcYnVpbGRcXCIsInNvdXJjZXMiOlsiaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5jbGFzcyBZRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyB8fCAneWFyZ3MgZXJyb3InKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1lFcnJvcic7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFlFcnJvcik7XG4gICAgfVxufVxuXG5sZXQgcHJldmlvdXNseVZpc2l0ZWRDb25maWdzID0gW107XG5sZXQgc2hpbTtcbmZ1bmN0aW9uIGFwcGx5RXh0ZW5kcyhjb25maWcsIGN3ZCwgbWVyZ2VFeHRlbmRzLCBfc2hpbSkge1xuICAgIHNoaW0gPSBfc2hpbTtcbiAgICBsZXQgZGVmYXVsdENvbmZpZyA9IHt9O1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAnZXh0ZW5kcycpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnLmV4dGVuZHMgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRDb25maWc7XG4gICAgICAgIGNvbnN0IGlzUGF0aCA9IC9cXC5qc29ufFxcLi4qcmMkLy50ZXN0KGNvbmZpZy5leHRlbmRzKTtcbiAgICAgICAgbGV0IHBhdGhUb0RlZmF1bHQgPSBudWxsO1xuICAgICAgICBpZiAoIWlzUGF0aCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXRoVG9EZWZhdWx0ID0gcmVxdWlyZS5yZXNvbHZlKGNvbmZpZy5leHRlbmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGhUb0RlZmF1bHQgPSBnZXRQYXRoVG9EZWZhdWx0Q29uZmlnKGN3ZCwgY29uZmlnLmV4dGVuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRm9yQ2lyY3VsYXJFeHRlbmRzKHBhdGhUb0RlZmF1bHQpO1xuICAgICAgICBwcmV2aW91c2x5VmlzaXRlZENvbmZpZ3MucHVzaChwYXRoVG9EZWZhdWx0KTtcbiAgICAgICAgZGVmYXVsdENvbmZpZyA9IGlzUGF0aFxuICAgICAgICAgICAgPyBKU09OLnBhcnNlKHNoaW0ucmVhZEZpbGVTeW5jKHBhdGhUb0RlZmF1bHQsICd1dGY4JykpXG4gICAgICAgICAgICA6IHJlcXVpcmUoY29uZmlnLmV4dGVuZHMpO1xuICAgICAgICBkZWxldGUgY29uZmlnLmV4dGVuZHM7XG4gICAgICAgIGRlZmF1bHRDb25maWcgPSBhcHBseUV4dGVuZHMoZGVmYXVsdENvbmZpZywgc2hpbS5wYXRoLmRpcm5hbWUocGF0aFRvRGVmYXVsdCksIG1lcmdlRXh0ZW5kcywgc2hpbSk7XG4gICAgfVxuICAgIHByZXZpb3VzbHlWaXNpdGVkQ29uZmlncyA9IFtdO1xuICAgIHJldHVybiBtZXJnZUV4dGVuZHNcbiAgICAgICAgPyBtZXJnZURlZXAoZGVmYXVsdENvbmZpZywgY29uZmlnKVxuICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25maWcsIGNvbmZpZyk7XG59XG5mdW5jdGlvbiBjaGVja0ZvckNpcmN1bGFyRXh0ZW5kcyhjZmdQYXRoKSB7XG4gICAgaWYgKHByZXZpb3VzbHlWaXNpdGVkQ29uZmlncy5pbmRleE9mKGNmZ1BhdGgpID4gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFlFcnJvcihgQ2lyY3VsYXIgZXh0ZW5kZWQgY29uZmlndXJhdGlvbnM6ICcke2NmZ1BhdGh9Jy5gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQYXRoVG9EZWZhdWx0Q29uZmlnKGN3ZCwgcGF0aFRvRXh0ZW5kKSB7XG4gICAgcmV0dXJuIHNoaW0ucGF0aC5yZXNvbHZlKGN3ZCwgcGF0aFRvRXh0ZW5kKTtcbn1cbmZ1bmN0aW9uIG1lcmdlRGVlcChjb25maWcxLCBjb25maWcyKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0ge307XG4gICAgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIGNvbmZpZzEpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvbmZpZzIpKSB7XG4gICAgICAgIGlmIChpc09iamVjdChjb25maWcyW2tleV0pICYmIGlzT2JqZWN0KHRhcmdldFtrZXldKSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZURlZXAoY29uZmlnMVtrZXldLCBjb25maWcyW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBjb25maWcyW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcGFyc2VDb21tYW5kKGNtZCkge1xuICAgIGNvbnN0IGV4dHJhU3BhY2VzU3RyaXBwZWRDb21tYW5kID0gY21kLnJlcGxhY2UoL1xcc3syLH0vZywgJyAnKTtcbiAgICBjb25zdCBzcGxpdENvbW1hbmQgPSBleHRyYVNwYWNlc1N0cmlwcGVkQ29tbWFuZC5zcGxpdCgvXFxzKyg/IVteW10qXXxbXjxdKj4pLyk7XG4gICAgY29uc3QgYnJlZ2V4ID0gL1xcLipbXFxdWzw+XS9nO1xuICAgIGNvbnN0IGZpcnN0Q29tbWFuZCA9IHNwbGl0Q29tbWFuZC5zaGlmdCgpO1xuICAgIGlmICghZmlyc3RDb21tYW5kKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvbW1hbmQgZm91bmQgaW46ICR7Y21kfWApO1xuICAgIGNvbnN0IHBhcnNlZENvbW1hbmQgPSB7XG4gICAgICAgIGNtZDogZmlyc3RDb21tYW5kLnJlcGxhY2UoYnJlZ2V4LCAnJyksXG4gICAgICAgIGRlbWFuZGVkOiBbXSxcbiAgICAgICAgb3B0aW9uYWw6IFtdLFxuICAgIH07XG4gICAgc3BsaXRDb21tYW5kLmZvckVhY2goKGNtZCwgaSkgPT4ge1xuICAgICAgICBsZXQgdmFyaWFkaWMgPSBmYWxzZTtcbiAgICAgICAgY21kID0gY21kLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICAgIGlmICgvXFwuK1tcXF0+XS8udGVzdChjbWQpICYmIGkgPT09IHNwbGl0Q29tbWFuZC5sZW5ndGggLSAxKVxuICAgICAgICAgICAgdmFyaWFkaWMgPSB0cnVlO1xuICAgICAgICBpZiAoL15cXFsvLnRlc3QoY21kKSkge1xuICAgICAgICAgICAgcGFyc2VkQ29tbWFuZC5vcHRpb25hbC5wdXNoKHtcbiAgICAgICAgICAgICAgICBjbWQ6IGNtZC5yZXBsYWNlKGJyZWdleCwgJycpLnNwbGl0KCd8JyksXG4gICAgICAgICAgICAgICAgdmFyaWFkaWMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZENvbW1hbmQuZGVtYW5kZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgY21kOiBjbWQucmVwbGFjZShicmVnZXgsICcnKS5zcGxpdCgnfCcpLFxuICAgICAgICAgICAgICAgIHZhcmlhZGljLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGFyc2VkQ29tbWFuZDtcbn1cblxuY29uc3QgcG9zaXRpb25OYW1lID0gWydmaXJzdCcsICdzZWNvbmQnLCAndGhpcmQnLCAnZm91cnRoJywgJ2ZpZnRoJywgJ3NpeHRoJ107XG5mdW5jdGlvbiBhcmdzZXJ0KGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBmdW5jdGlvbiBwYXJzZUFyZ3MoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gW3sgZGVtYW5kZWQ6IFtdLCBvcHRpb25hbDogW10gfSwgYXJnMSwgYXJnMl1cbiAgICAgICAgICAgIDogW1xuICAgICAgICAgICAgICAgIHBhcnNlQ29tbWFuZChgY21kICR7YXJnMX1gKSxcbiAgICAgICAgICAgICAgICBhcmcyLFxuICAgICAgICAgICAgICAgIGFyZzMsXG4gICAgICAgICAgICBdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgICAgICBjb25zdCBbcGFyc2VkLCBjYWxsZXJBcmd1bWVudHMsIF9sZW5ndGhdID0gcGFyc2VBcmdzKCk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGNhbGxlckFyZ3VtZW50cyk7XG4gICAgICAgIHdoaWxlIChhcmdzLmxlbmd0aCAmJiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IF9sZW5ndGggfHwgYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCBwYXJzZWQuZGVtYW5kZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgWUVycm9yKGBOb3QgZW5vdWdoIGFyZ3VtZW50cyBwcm92aWRlZC4gRXhwZWN0ZWQgJHtwYXJzZWQuZGVtYW5kZWQubGVuZ3RofSBidXQgcmVjZWl2ZWQgJHthcmdzLmxlbmd0aH0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxDb21tYW5kcyA9IHBhcnNlZC5kZW1hbmRlZC5sZW5ndGggKyBwYXJzZWQub3B0aW9uYWwubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoID4gdG90YWxDb21tYW5kcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFlFcnJvcihgVG9vIG1hbnkgYXJndW1lbnRzIHByb3ZpZGVkLiBFeHBlY3RlZCBtYXggJHt0b3RhbENvbW1hbmRzfSBidXQgcmVjZWl2ZWQgJHtsZW5ndGh9LmApO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5kZW1hbmRlZC5mb3JFYWNoKGRlbWFuZGVkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVkVHlwZSA9IGd1ZXNzVHlwZShhcmcpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdUeXBlcyA9IGRlbWFuZGVkLmNtZC5maWx0ZXIodHlwZSA9PiB0eXBlID09PSBvYnNlcnZlZFR5cGUgfHwgdHlwZSA9PT0gJyonKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGluZ1R5cGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICBhcmd1bWVudFR5cGVFcnJvcihvYnNlcnZlZFR5cGUsIGRlbWFuZGVkLmNtZCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgcG9zaXRpb24gKz0gMTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcnNlZC5vcHRpb25hbC5mb3JFYWNoKG9wdGlvbmFsID0+IHtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlZFR5cGUgPSBndWVzc1R5cGUoYXJnKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nVHlwZXMgPSBvcHRpb25hbC5jbWQuZmlsdGVyKHR5cGUgPT4gdHlwZSA9PT0gb2JzZXJ2ZWRUeXBlIHx8IHR5cGUgPT09ICcqJyk7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdUeXBlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgYXJndW1lbnRUeXBlRXJyb3Iob2JzZXJ2ZWRUeXBlLCBvcHRpb25hbC5jbWQsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IDE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnIuc3RhY2spO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGd1ZXNzVHlwZShhcmcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmcgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBhcmc7XG59XG5mdW5jdGlvbiBhcmd1bWVudFR5cGVFcnJvcihvYnNlcnZlZFR5cGUsIGFsbG93ZWRUeXBlcywgcG9zaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgWUVycm9yKGBJbnZhbGlkICR7cG9zaXRpb25OYW1lW3Bvc2l0aW9uXSB8fCAnbWFueWl0aCd9IGFyZ3VtZW50LiBFeHBlY3RlZCAke2FsbG93ZWRUeXBlcy5qb2luKCcgb3IgJyl9IGJ1dCByZWNlaXZlZCAke29ic2VydmVkVHlwZX0uYCk7XG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZShtYXliZVByb21pc2UpIHtcbiAgICByZXR1cm4gKCEhbWF5YmVQcm9taXNlICYmXG4gICAgICAgICEhbWF5YmVQcm9taXNlLnRoZW4gJiZcbiAgICAgICAgdHlwZW9mIG1heWJlUHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Tm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc2hpbSwgbWVzc2FnZSkge1xuICAgIHNoaW0uYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U2luZ2xlS2V5KGFjdHVhbCwgc2hpbSkge1xuICAgIHNoaW0uYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBhY3R1YWwsICdzdHJpbmcnKTtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIG9iakZpbHRlcihvcmlnaW5hbCA9IHt9LCBmaWx0ZXIgPSAoKSA9PiB0cnVlKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgb2JqZWN0S2V5cyhvcmlnaW5hbCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoZmlsdGVyKGtleSwgb3JpZ2luYWxba2V5XSkpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gb3JpZ2luYWxba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGdsb2JhbE1pZGRsZXdhcmVGYWN0b3J5KGdsb2JhbE1pZGRsZXdhcmUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcHBseUJlZm9yZVZhbGlkYXRpb24gPSBmYWxzZSkge1xuICAgICAgICBhcmdzZXJ0KCc8YXJyYXl8ZnVuY3Rpb24+IFtib29sZWFuXScsIFtjYWxsYmFjaywgYXBwbHlCZWZvcmVWYWxpZGF0aW9uXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2tbaV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ21pZGRsZXdhcmUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrW2ldLmFwcGx5QmVmb3JlVmFsaWRhdGlvbiA9IGFwcGx5QmVmb3JlVmFsaWRhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGdsb2JhbE1pZGRsZXdhcmUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5QmVmb3JlVmFsaWRhdGlvbiA9IGFwcGx5QmVmb3JlVmFsaWRhdGlvbjtcbiAgICAgICAgICAgIGdsb2JhbE1pZGRsZXdhcmUucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbW1hbmRNaWRkbGV3YXJlRmFjdG9yeShjb21tYW5kTWlkZGxld2FyZSkge1xuICAgIGlmICghY29tbWFuZE1pZGRsZXdhcmUpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICByZXR1cm4gY29tbWFuZE1pZGRsZXdhcmUubWFwKG1pZGRsZXdhcmUgPT4ge1xuICAgICAgICBtaWRkbGV3YXJlLmFwcGx5QmVmb3JlVmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbWlkZGxld2FyZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZShhcmd2LCB5YXJncywgbWlkZGxld2FyZXMsIGJlZm9yZVZhbGlkYXRpb24pIHtcbiAgICBjb25zdCBiZWZvcmVWYWxpZGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoJ21pZGRsZXdhcmUgY2Fubm90IHJldHVybiBhIHByb21pc2Ugd2hlbiBhcHBseUJlZm9yZVZhbGlkYXRpb24gaXMgdHJ1ZScpO1xuICAgIHJldHVybiBtaWRkbGV3YXJlcy5yZWR1Y2UoKGFjYywgbWlkZGxld2FyZSkgPT4ge1xuICAgICAgICBpZiAobWlkZGxld2FyZS5hcHBseUJlZm9yZVZhbGlkYXRpb24gIT09IGJlZm9yZVZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvbWlzZShhY2MpKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjXG4gICAgICAgICAgICAgICAgLnRoZW4oaW5pdGlhbE9iaiA9PiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgaW5pdGlhbE9iaixcbiAgICAgICAgICAgICAgICBtaWRkbGV3YXJlKGluaXRpYWxPYmosIHlhcmdzKSxcbiAgICAgICAgICAgIF0pKVxuICAgICAgICAgICAgICAgIC50aGVuKChbaW5pdGlhbE9iaiwgbWlkZGxld2FyZU9ial0pID0+IE9iamVjdC5hc3NpZ24oaW5pdGlhbE9iaiwgbWlkZGxld2FyZU9iaikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWlkZGxld2FyZShhY2MsIHlhcmdzKTtcbiAgICAgICAgICAgIGlmIChiZWZvcmVWYWxpZGF0aW9uICYmIGlzUHJvbWlzZShyZXN1bHQpKVxuICAgICAgICAgICAgICAgIHRocm93IGJlZm9yZVZhbGlkYXRpb25FcnJvcjtcbiAgICAgICAgICAgIHJldHVybiBpc1Byb21pc2UocmVzdWx0KVxuICAgICAgICAgICAgICAgID8gcmVzdWx0LnRoZW4obWlkZGxld2FyZU9iaiA9PiBPYmplY3QuYXNzaWduKGFjYywgbWlkZGxld2FyZU9iaikpXG4gICAgICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKGFjYywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0sIGFyZ3YpO1xufVxuXG5mdW5jdGlvbiBnZXRQcm9jZXNzQXJndkJpbkluZGV4KCkge1xuICAgIGlmIChpc0J1bmRsZWRFbGVjdHJvbkFwcCgpKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gMTtcbn1cbmZ1bmN0aW9uIGlzQnVuZGxlZEVsZWN0cm9uQXBwKCkge1xuICAgIHJldHVybiBpc0VsZWN0cm9uQXBwKCkgJiYgIXByb2Nlc3MuZGVmYXVsdEFwcDtcbn1cbmZ1bmN0aW9uIGlzRWxlY3Ryb25BcHAoKSB7XG4gICAgcmV0dXJuICEhcHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbjtcbn1cbmZ1bmN0aW9uIGhpZGVCaW4oYXJndikge1xuICAgIHJldHVybiBhcmd2LnNsaWNlKGdldFByb2Nlc3NBcmd2QmluSW5kZXgoKSArIDEpO1xufVxuZnVuY3Rpb24gZ2V0UHJvY2Vzc0FyZ3ZCaW4oKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuYXJndltnZXRQcm9jZXNzQXJndkJpbkluZGV4KCldO1xufVxuXG52YXIgcHJvY2Vzc0FyZ3YgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgaGlkZUJpbjogaGlkZUJpbixcbiAgZ2V0UHJvY2Vzc0FyZ3ZCaW46IGdldFByb2Nlc3NBcmd2QmluXG59KTtcblxuZnVuY3Rpb24gd2hpY2hNb2R1bGUoZXhwb3J0ZWQpIHtcbiAgICBpZiAodHlwZW9mIHJlcXVpcmUgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMCwgZmlsZXMgPSBPYmplY3Qua2V5cyhyZXF1aXJlLmNhY2hlKSwgbW9kOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW9kID0gcmVxdWlyZS5jYWNoZVtmaWxlc1tpXV07XG4gICAgICAgIGlmIChtb2QuZXhwb3J0cyA9PT0gZXhwb3J0ZWQpXG4gICAgICAgICAgICByZXR1cm4gbW9kO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgREVGQVVMVF9NQVJLRVIgPSAvKF5cXCopfCheXFwkMCkvO1xuZnVuY3Rpb24gY29tbWFuZCh5YXJncywgdXNhZ2UsIHZhbGlkYXRpb24sIGdsb2JhbE1pZGRsZXdhcmUgPSBbXSwgc2hpbSkge1xuICAgIGNvbnN0IHNlbGYgPSB7fTtcbiAgICBsZXQgaGFuZGxlcnMgPSB7fTtcbiAgICBsZXQgYWxpYXNNYXAgPSB7fTtcbiAgICBsZXQgZGVmYXVsdENvbW1hbmQ7XG4gICAgc2VsZi5hZGRIYW5kbGVyID0gZnVuY3Rpb24gYWRkSGFuZGxlcihjbWQsIGRlc2NyaXB0aW9uLCBidWlsZGVyLCBoYW5kbGVyLCBjb21tYW5kTWlkZGxld2FyZSwgZGVwcmVjYXRlZCkge1xuICAgICAgICBsZXQgYWxpYXNlcyA9IFtdO1xuICAgICAgICBjb25zdCBtaWRkbGV3YXJlcyA9IGNvbW1hbmRNaWRkbGV3YXJlRmFjdG9yeShjb21tYW5kTWlkZGxld2FyZSk7XG4gICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyIHx8ICgoKSA9PiB7IH0pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjbWQpKSB7XG4gICAgICAgICAgICBpZiAoaXNDb21tYW5kQW5kQWxpYXNlcyhjbWQpKSB7XG4gICAgICAgICAgICAgICAgW2NtZCwgLi4uYWxpYXNlc10gPSBjbWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgY21kKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkSGFuZGxlcihjb21tYW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDb21tYW5kSGFuZGxlckRlZmluaXRpb24oY21kKSkge1xuICAgICAgICAgICAgbGV0IGNvbW1hbmQgPSBBcnJheS5pc0FycmF5KGNtZC5jb21tYW5kKSB8fCB0eXBlb2YgY21kLmNvbW1hbmQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBjbWQuY29tbWFuZFxuICAgICAgICAgICAgICAgIDogbW9kdWxlTmFtZShjbWQpO1xuICAgICAgICAgICAgaWYgKGNtZC5hbGlhc2VzKVxuICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBbXS5jb25jYXQoY29tbWFuZCkuY29uY2F0KGNtZC5hbGlhc2VzKTtcbiAgICAgICAgICAgIHNlbGYuYWRkSGFuZGxlcihjb21tYW5kLCBleHRyYWN0RGVzYyhjbWQpLCBjbWQuYnVpbGRlciwgY21kLmhhbmRsZXIsIGNtZC5taWRkbGV3YXJlcywgY21kLmRlcHJlY2F0ZWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ29tbWFuZEJ1aWxkZXJEZWZpbml0aW9uKGJ1aWxkZXIpKSB7XG4gICAgICAgICAgICBzZWxmLmFkZEhhbmRsZXIoW2NtZF0uY29uY2F0KGFsaWFzZXMpLCBkZXNjcmlwdGlvbiwgYnVpbGRlci5idWlsZGVyLCBidWlsZGVyLmhhbmRsZXIsIGJ1aWxkZXIubWlkZGxld2FyZXMsIGJ1aWxkZXIuZGVwcmVjYXRlZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjbWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRDb21tYW5kID0gcGFyc2VDb21tYW5kKGNtZCk7XG4gICAgICAgICAgICBhbGlhc2VzID0gYWxpYXNlcy5tYXAoYWxpYXMgPT4gcGFyc2VDb21tYW5kKGFsaWFzKS5jbWQpO1xuICAgICAgICAgICAgbGV0IGlzRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQWxpYXNlcyA9IFtwYXJzZWRDb21tYW5kLmNtZF0uY29uY2F0KGFsaWFzZXMpLmZpbHRlcihjID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoREVGQVVMVF9NQVJLRVIudGVzdChjKSkge1xuICAgICAgICAgICAgICAgICAgICBpc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkQWxpYXNlcy5sZW5ndGggPT09IDAgJiYgaXNEZWZhdWx0KVxuICAgICAgICAgICAgICAgIHBhcnNlZEFsaWFzZXMucHVzaCgnJDAnKTtcbiAgICAgICAgICAgIGlmIChpc0RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRDb21tYW5kLmNtZCA9IHBhcnNlZEFsaWFzZXNbMF07XG4gICAgICAgICAgICAgICAgYWxpYXNlcyA9IHBhcnNlZEFsaWFzZXMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgY21kID0gY21kLnJlcGxhY2UoREVGQVVMVF9NQVJLRVIsIHBhcnNlZENvbW1hbmQuY21kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsaWFzZXMuZm9yRWFjaChhbGlhcyA9PiB7XG4gICAgICAgICAgICAgICAgYWxpYXNNYXBbYWxpYXNdID0gcGFyc2VkQ29tbWFuZC5jbWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB1c2FnZS5jb21tYW5kKGNtZCwgZGVzY3JpcHRpb24sIGlzRGVmYXVsdCwgYWxpYXNlcywgZGVwcmVjYXRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVyc1twYXJzZWRDb21tYW5kLmNtZF0gPSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWw6IGNtZCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIGJ1aWxkZXI6IGJ1aWxkZXIgfHwge30sXG4gICAgICAgICAgICAgICAgbWlkZGxld2FyZXMsXG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlZCxcbiAgICAgICAgICAgICAgICBkZW1hbmRlZDogcGFyc2VkQ29tbWFuZC5kZW1hbmRlZCxcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogcGFyc2VkQ29tbWFuZC5vcHRpb25hbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaXNEZWZhdWx0KVxuICAgICAgICAgICAgICAgIGRlZmF1bHRDb21tYW5kID0gaGFuZGxlcnNbcGFyc2VkQ29tbWFuZC5jbWRdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzZWxmLmFkZERpcmVjdG9yeSA9IGZ1bmN0aW9uIGFkZERpcmVjdG9yeShkaXIsIGNvbnRleHQsIHJlcSwgY2FsbGVyRmlsZSwgb3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLnJlY3Vyc2UgIT09ICdib29sZWFuJylcbiAgICAgICAgICAgIG9wdHMucmVjdXJzZSA9IGZhbHNlO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0cy5leHRlbnNpb25zKSlcbiAgICAgICAgICAgIG9wdHMuZXh0ZW5zaW9ucyA9IFsnanMnXTtcbiAgICAgICAgY29uc3QgcGFyZW50VmlzaXQgPSB0eXBlb2Ygb3B0cy52aXNpdCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMudmlzaXQgOiAobykgPT4gbztcbiAgICAgICAgb3B0cy52aXNpdCA9IGZ1bmN0aW9uIHZpc2l0KG9iaiwgam9pbmVkLCBmaWxlbmFtZSkge1xuICAgICAgICAgICAgY29uc3QgdmlzaXRlZCA9IHBhcmVudFZpc2l0KG9iaiwgam9pbmVkLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICBpZiAodmlzaXRlZCkge1xuICAgICAgICAgICAgICAgIGlmICh+Y29udGV4dC5maWxlcy5pbmRleE9mKGpvaW5lZCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdGVkO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsZXMucHVzaChqb2luZWQpO1xuICAgICAgICAgICAgICAgIHNlbGYuYWRkSGFuZGxlcih2aXNpdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2aXNpdGVkO1xuICAgICAgICB9O1xuICAgICAgICBzaGltLnJlcXVpcmVEaXJlY3RvcnkoeyByZXF1aXJlOiByZXEsIGZpbGVuYW1lOiBjYWxsZXJGaWxlIH0sIGRpciwgb3B0cyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBtb2R1bGVOYW1lKG9iaikge1xuICAgICAgICBjb25zdCBtb2QgPSB3aGljaE1vZHVsZShvYmopO1xuICAgICAgICBpZiAoIW1vZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY29tbWFuZCBuYW1lIGdpdmVuIGZvciBtb2R1bGU6ICR7c2hpbS5pbnNwZWN0KG9iail9YCk7XG4gICAgICAgIHJldHVybiBjb21tYW5kRnJvbUZpbGVuYW1lKG1vZC5maWxlbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1hbmRGcm9tRmlsZW5hbWUoZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHNoaW0ucGF0aC5iYXNlbmFtZShmaWxlbmFtZSwgc2hpbS5wYXRoLmV4dG5hbWUoZmlsZW5hbWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0cmFjdERlc2MoeyBkZXNjcmliZSwgZGVzY3JpcHRpb24sIGRlc2MsIH0pIHtcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIFtkZXNjcmliZSwgZGVzY3JpcHRpb24sIGRlc2NdKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRlc3QgPT09ICdzdHJpbmcnIHx8IHRlc3QgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0O1xuICAgICAgICAgICAgYXNzZXJ0Tm90U3RyaWN0RXF1YWwodGVzdCwgdHJ1ZSwgc2hpbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxmLmdldENvbW1hbmRzID0gKCkgPT4gT2JqZWN0LmtleXMoaGFuZGxlcnMpLmNvbmNhdChPYmplY3Qua2V5cyhhbGlhc01hcCkpO1xuICAgIHNlbGYuZ2V0Q29tbWFuZEhhbmRsZXJzID0gKCkgPT4gaGFuZGxlcnM7XG4gICAgc2VsZi5oYXNEZWZhdWx0Q29tbWFuZCA9ICgpID0+ICEhZGVmYXVsdENvbW1hbmQ7XG4gICAgc2VsZi5ydW5Db21tYW5kID0gZnVuY3Rpb24gcnVuQ29tbWFuZChjb21tYW5kLCB5YXJncywgcGFyc2VkLCBjb21tYW5kSW5kZXgpIHtcbiAgICAgICAgbGV0IGFsaWFzZXMgPSBwYXJzZWQuYWxpYXNlcztcbiAgICAgICAgY29uc3QgY29tbWFuZEhhbmRsZXIgPSBoYW5kbGVyc1tjb21tYW5kXSB8fCBoYW5kbGVyc1thbGlhc01hcFtjb21tYW5kXV0gfHwgZGVmYXVsdENvbW1hbmQ7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb250ZXh0ID0geWFyZ3MuZ2V0Q29udGV4dCgpO1xuICAgICAgICBsZXQgbnVtRmlsZXMgPSBjdXJyZW50Q29udGV4dC5maWxlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHBhcmVudENvbW1hbmRzID0gY3VycmVudENvbnRleHQuY29tbWFuZHMuc2xpY2UoKTtcbiAgICAgICAgbGV0IGlubmVyQXJndiA9IHBhcnNlZC5hcmd2O1xuICAgICAgICBsZXQgcG9zaXRpb25hbE1hcCA9IHt9O1xuICAgICAgICBpZiAoY29tbWFuZCkge1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQuY29tbWFuZHMucHVzaChjb21tYW5kKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0LmZ1bGxDb21tYW5kcy5wdXNoKGNvbW1hbmRIYW5kbGVyLm9yaWdpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWlsZGVyID0gY29tbWFuZEhhbmRsZXIuYnVpbGRlcjtcbiAgICAgICAgaWYgKGlzQ29tbWFuZEJ1aWxkZXJDYWxsYmFjayhidWlsZGVyKSkge1xuICAgICAgICAgICAgY29uc3QgYnVpbGRlck91dHB1dCA9IGJ1aWxkZXIoeWFyZ3MucmVzZXQocGFyc2VkLmFsaWFzZXMpKTtcbiAgICAgICAgICAgIGNvbnN0IGlubmVyWWFyZ3MgPSBpc1lhcmdzSW5zdGFuY2UoYnVpbGRlck91dHB1dCkgPyBidWlsZGVyT3V0cHV0IDogeWFyZ3M7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlVXNhZ2UoaW5uZXJZYXJncykpIHtcbiAgICAgICAgICAgICAgICBpbm5lcllhcmdzXG4gICAgICAgICAgICAgICAgICAgIC5nZXRVc2FnZUluc3RhbmNlKClcbiAgICAgICAgICAgICAgICAgICAgLnVzYWdlKHVzYWdlRnJvbVBhcmVudENvbW1hbmRzQ29tbWFuZEhhbmRsZXIocGFyZW50Q29tbWFuZHMsIGNvbW1hbmRIYW5kbGVyKSwgY29tbWFuZEhhbmRsZXIuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5uZXJBcmd2ID0gaW5uZXJZYXJncy5fcGFyc2VBcmdzKG51bGwsIG51bGwsIHRydWUsIGNvbW1hbmRJbmRleCk7XG4gICAgICAgICAgICBhbGlhc2VzID0gaW5uZXJZYXJncy5wYXJzZWQuYWxpYXNlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NvbW1hbmRCdWlsZGVyT3B0aW9uRGVmaW5pdGlvbnMoYnVpbGRlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IGlubmVyWWFyZ3MgPSB5YXJncy5yZXNldChwYXJzZWQuYWxpYXNlcyk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlVXNhZ2UoaW5uZXJZYXJncykpIHtcbiAgICAgICAgICAgICAgICBpbm5lcllhcmdzXG4gICAgICAgICAgICAgICAgICAgIC5nZXRVc2FnZUluc3RhbmNlKClcbiAgICAgICAgICAgICAgICAgICAgLnVzYWdlKHVzYWdlRnJvbVBhcmVudENvbW1hbmRzQ29tbWFuZEhhbmRsZXIocGFyZW50Q29tbWFuZHMsIGNvbW1hbmRIYW5kbGVyKSwgY29tbWFuZEhhbmRsZXIuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29tbWFuZEhhbmRsZXIuYnVpbGRlcikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGlubmVyWWFyZ3Mub3B0aW9uKGtleSwgYnVpbGRlcltrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5uZXJBcmd2ID0gaW5uZXJZYXJncy5fcGFyc2VBcmdzKG51bGwsIG51bGwsIHRydWUsIGNvbW1hbmRJbmRleCk7XG4gICAgICAgICAgICBhbGlhc2VzID0gaW5uZXJZYXJncy5wYXJzZWQuYWxpYXNlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXlhcmdzLl9oYXNPdXRwdXQoKSkge1xuICAgICAgICAgICAgcG9zaXRpb25hbE1hcCA9IHBvcHVsYXRlUG9zaXRpb25hbHMoY29tbWFuZEhhbmRsZXIsIGlubmVyQXJndiwgY3VycmVudENvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pZGRsZXdhcmVzID0gZ2xvYmFsTWlkZGxld2FyZVxuICAgICAgICAgICAgLnNsaWNlKDApXG4gICAgICAgICAgICAuY29uY2F0KGNvbW1hbmRIYW5kbGVyLm1pZGRsZXdhcmVzKTtcbiAgICAgICAgYXBwbHlNaWRkbGV3YXJlKGlubmVyQXJndiwgeWFyZ3MsIG1pZGRsZXdhcmVzLCB0cnVlKTtcbiAgICAgICAgaWYgKCF5YXJncy5faGFzT3V0cHV0KCkpIHtcbiAgICAgICAgICAgIHlhcmdzLl9ydW5WYWxpZGF0aW9uKGlubmVyQXJndiwgYWxpYXNlcywgcG9zaXRpb25hbE1hcCwgeWFyZ3MucGFyc2VkLmVycm9yLCAhY29tbWFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmRIYW5kbGVyLmhhbmRsZXIgJiYgIXlhcmdzLl9oYXNPdXRwdXQoKSkge1xuICAgICAgICAgICAgeWFyZ3MuX3NldEhhc091dHB1dCgpO1xuICAgICAgICAgICAgY29uc3QgcG9wdWxhdGVEb3VibGVEYXNoID0gISF5YXJncy5nZXRPcHRpb25zKCkuY29uZmlndXJhdGlvblsncG9wdWxhdGUtLSddO1xuICAgICAgICAgICAgeWFyZ3MuX3Bvc3RQcm9jZXNzKGlubmVyQXJndiwgcG9wdWxhdGVEb3VibGVEYXNoKTtcbiAgICAgICAgICAgIGlubmVyQXJndiA9IGFwcGx5TWlkZGxld2FyZShpbm5lckFyZ3YsIHlhcmdzLCBtaWRkbGV3YXJlcywgZmFsc2UpO1xuICAgICAgICAgICAgbGV0IGhhbmRsZXJSZXN1bHQ7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKGlubmVyQXJndikpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gaW5uZXJBcmd2LnRoZW4oYXJndiA9PiBjb21tYW5kSGFuZGxlci5oYW5kbGVyKGFyZ3YpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSBjb21tYW5kSGFuZGxlci5oYW5kbGVyKGlubmVyQXJndik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyRmluaXNoQ29tbWFuZCA9IHlhcmdzLmdldEhhbmRsZXJGaW5pc2hDb21tYW5kKCk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKGhhbmRsZXJSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgeWFyZ3MuZ2V0VXNhZ2VJbnN0YW5jZSgpLmNhY2hlSGVscE1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJGaW5pc2hDb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyRmluaXNoQ29tbWFuZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWFyZ3MuZ2V0VXNhZ2VJbnN0YW5jZSgpLmZhaWwobnVsbCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgeWFyZ3MuZ2V0VXNhZ2VJbnN0YW5jZSgpLmNsZWFyQ2FjaGVkSGVscE1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyRmluaXNoQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyRmluaXNoQ29tbWFuZChoYW5kbGVyUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0LmNvbW1hbmRzLnBvcCgpO1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQuZnVsbENvbW1hbmRzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIG51bUZpbGVzID0gY3VycmVudENvbnRleHQuZmlsZXMubGVuZ3RoIC0gbnVtRmlsZXM7XG4gICAgICAgIGlmIChudW1GaWxlcyA+IDApXG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dC5maWxlcy5zcGxpY2UobnVtRmlsZXMgKiAtMSwgbnVtRmlsZXMpO1xuICAgICAgICByZXR1cm4gaW5uZXJBcmd2O1xuICAgIH07XG4gICAgZnVuY3Rpb24gc2hvdWxkVXBkYXRlVXNhZ2UoeWFyZ3MpIHtcbiAgICAgICAgcmV0dXJuICgheWFyZ3MuZ2V0VXNhZ2VJbnN0YW5jZSgpLmdldFVzYWdlRGlzYWJsZWQoKSAmJlxuICAgICAgICAgICAgeWFyZ3MuZ2V0VXNhZ2VJbnN0YW5jZSgpLmdldFVzYWdlKCkubGVuZ3RoID09PSAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNhZ2VGcm9tUGFyZW50Q29tbWFuZHNDb21tYW5kSGFuZGxlcihwYXJlbnRDb21tYW5kcywgY29tbWFuZEhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgYyA9IERFRkFVTFRfTUFSS0VSLnRlc3QoY29tbWFuZEhhbmRsZXIub3JpZ2luYWwpXG4gICAgICAgICAgICA/IGNvbW1hbmRIYW5kbGVyLm9yaWdpbmFsLnJlcGxhY2UoREVGQVVMVF9NQVJLRVIsICcnKS50cmltKClcbiAgICAgICAgICAgIDogY29tbWFuZEhhbmRsZXIub3JpZ2luYWw7XG4gICAgICAgIGNvbnN0IHBjID0gcGFyZW50Q29tbWFuZHMuZmlsdGVyKGMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICFERUZBVUxUX01BUktFUi50ZXN0KGMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGMucHVzaChjKTtcbiAgICAgICAgcmV0dXJuIGAkMCAke3BjLmpvaW4oJyAnKX1gO1xuICAgIH1cbiAgICBzZWxmLnJ1bkRlZmF1bHRCdWlsZGVyT24gPSBmdW5jdGlvbiAoeWFyZ3MpIHtcbiAgICAgICAgYXNzZXJ0Tm90U3RyaWN0RXF1YWwoZGVmYXVsdENvbW1hbmQsIHVuZGVmaW5lZCwgc2hpbSk7XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVVc2FnZSh5YXJncykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1hbmRTdHJpbmcgPSBERUZBVUxUX01BUktFUi50ZXN0KGRlZmF1bHRDb21tYW5kLm9yaWdpbmFsKVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdENvbW1hbmQub3JpZ2luYWxcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRDb21tYW5kLm9yaWdpbmFsLnJlcGxhY2UoL15bXltcXF08Pl0qLywgJyQwICcpO1xuICAgICAgICAgICAgeWFyZ3MuZ2V0VXNhZ2VJbnN0YW5jZSgpLnVzYWdlKGNvbW1hbmRTdHJpbmcsIGRlZmF1bHRDb21tYW5kLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWlsZGVyID0gZGVmYXVsdENvbW1hbmQuYnVpbGRlcjtcbiAgICAgICAgaWYgKGlzQ29tbWFuZEJ1aWxkZXJDYWxsYmFjayhidWlsZGVyKSkge1xuICAgICAgICAgICAgYnVpbGRlcih5YXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzQ29tbWFuZEJ1aWxkZXJEZWZpbml0aW9uKGJ1aWxkZXIpKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhidWlsZGVyKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgeWFyZ3Mub3B0aW9uKGtleSwgYnVpbGRlcltrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwb3B1bGF0ZVBvc2l0aW9uYWxzKGNvbW1hbmRIYW5kbGVyLCBhcmd2LCBjb250ZXh0KSB7XG4gICAgICAgIGFyZ3YuXyA9IGFyZ3YuXy5zbGljZShjb250ZXh0LmNvbW1hbmRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGRlbWFuZGVkID0gY29tbWFuZEhhbmRsZXIuZGVtYW5kZWQuc2xpY2UoMCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0gY29tbWFuZEhhbmRsZXIub3B0aW9uYWwuc2xpY2UoMCk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uYWxNYXAgPSB7fTtcbiAgICAgICAgdmFsaWRhdGlvbi5wb3NpdGlvbmFsQ291bnQoZGVtYW5kZWQubGVuZ3RoLCBhcmd2Ll8ubGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGRlbWFuZGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZGVtYW5kID0gZGVtYW5kZWQuc2hpZnQoKTtcbiAgICAgICAgICAgIHBvcHVsYXRlUG9zaXRpb25hbChkZW1hbmQsIGFyZ3YsIHBvc2l0aW9uYWxNYXApO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChvcHRpb25hbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1heWJlID0gb3B0aW9uYWwuc2hpZnQoKTtcbiAgICAgICAgICAgIHBvcHVsYXRlUG9zaXRpb25hbChtYXliZSwgYXJndiwgcG9zaXRpb25hbE1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgYXJndi5fID0gY29udGV4dC5jb21tYW5kcy5jb25jYXQoYXJndi5fLm1hcChhID0+ICcnICsgYSkpO1xuICAgICAgICBwb3N0UHJvY2Vzc1Bvc2l0aW9uYWxzKGFyZ3YsIHBvc2l0aW9uYWxNYXAsIHNlbGYuY21kVG9QYXJzZU9wdGlvbnMoY29tbWFuZEhhbmRsZXIub3JpZ2luYWwpKTtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uYWxNYXA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcHVsYXRlUG9zaXRpb25hbChwb3NpdGlvbmFsLCBhcmd2LCBwb3NpdGlvbmFsTWFwKSB7XG4gICAgICAgIGNvbnN0IGNtZCA9IHBvc2l0aW9uYWwuY21kWzBdO1xuICAgICAgICBpZiAocG9zaXRpb25hbC52YXJpYWRpYykge1xuICAgICAgICAgICAgcG9zaXRpb25hbE1hcFtjbWRdID0gYXJndi5fLnNwbGljZSgwKS5tYXAoU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhcmd2Ll8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uYWxNYXBbY21kXSA9IFtTdHJpbmcoYXJndi5fLnNoaWZ0KCkpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwb3N0UHJvY2Vzc1Bvc2l0aW9uYWxzKGFyZ3YsIHBvc2l0aW9uYWxNYXAsIHBhcnNlT3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgeWFyZ3MuZ2V0T3B0aW9ucygpKTtcbiAgICAgICAgb3B0aW9ucy5kZWZhdWx0ID0gT2JqZWN0LmFzc2lnbihwYXJzZU9wdGlvbnMuZGVmYXVsdCwgb3B0aW9ucy5kZWZhdWx0KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGFyc2VPcHRpb25zLmFsaWFzKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5hbGlhc1trZXldID0gKG9wdGlvbnMuYWxpYXNba2V5XSB8fCBbXSkuY29uY2F0KHBhcnNlT3B0aW9ucy5hbGlhc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmFycmF5ID0gb3B0aW9ucy5hcnJheS5jb25jYXQocGFyc2VPcHRpb25zLmFycmF5KTtcbiAgICAgICAgb3B0aW9ucy5jb25maWcgPSB7fTtcbiAgICAgICAgY29uc3QgdW5wYXJzZWQgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXMocG9zaXRpb25hbE1hcCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgcG9zaXRpb25hbE1hcFtrZXldLm1hcCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29uZmlndXJhdGlvblsndW5rbm93bi1vcHRpb25zLWFzLWFyZ3MnXSlcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5rZXlba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdW5wYXJzZWQucHVzaChgLS0ke2tleX1gKTtcbiAgICAgICAgICAgICAgICB1bnBhcnNlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF1bnBhcnNlZC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuY29uZmlndXJhdGlvbiwge1xuICAgICAgICAgICAgJ3BvcHVsYXRlLS0nOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gc2hpbS5QYXJzZXIuZGV0YWlsZWQodW5wYXJzZWQsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZyxcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAocGFyc2VkLmVycm9yKSB7XG4gICAgICAgICAgICB5YXJncy5nZXRVc2FnZUluc3RhbmNlKCkuZmFpbChwYXJzZWQuZXJyb3IubWVzc2FnZSwgcGFyc2VkLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uYWxLZXlzID0gT2JqZWN0LmtleXMocG9zaXRpb25hbE1hcCk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwb3NpdGlvbmFsTWFwKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25hbEtleXMucHVzaCguLi5wYXJzZWQuYWxpYXNlc1trZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyc2VkLmFyZ3YpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25hbEtleXMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBvc2l0aW9uYWxNYXBba2V5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uYWxNYXBba2V5XSA9IHBhcnNlZC5hcmd2W2tleV07XG4gICAgICAgICAgICAgICAgICAgIGFyZ3Zba2V5XSA9IHBhcnNlZC5hcmd2W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5jbWRUb1BhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uIChjbWRTdHJpbmcpIHtcbiAgICAgICAgY29uc3QgcGFyc2VPcHRpb25zID0ge1xuICAgICAgICAgICAgYXJyYXk6IFtdLFxuICAgICAgICAgICAgZGVmYXVsdDoge30sXG4gICAgICAgICAgICBhbGlhczoge30sXG4gICAgICAgICAgICBkZW1hbmQ6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNvbW1hbmQoY21kU3RyaW5nKTtcbiAgICAgICAgcGFyc2VkLmRlbWFuZGVkLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBbY21kLCAuLi5hbGlhc2VzXSA9IGQuY21kO1xuICAgICAgICAgICAgaWYgKGQudmFyaWFkaWMpIHtcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbnMuYXJyYXkucHVzaChjbWQpO1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9ucy5kZWZhdWx0W2NtZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlT3B0aW9ucy5hbGlhc1tjbWRdID0gYWxpYXNlcztcbiAgICAgICAgICAgIHBhcnNlT3B0aW9ucy5kZW1hbmRbY21kXSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJzZWQub3B0aW9uYWwuZm9yRWFjaChvID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtjbWQsIC4uLmFsaWFzZXNdID0gby5jbWQ7XG4gICAgICAgICAgICBpZiAoby52YXJpYWRpYykge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9ucy5hcnJheS5wdXNoKGNtZCk7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb25zLmRlZmF1bHRbY21kXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VPcHRpb25zLmFsaWFzW2NtZF0gPSBhbGlhc2VzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlT3B0aW9ucztcbiAgICB9O1xuICAgIHNlbGYucmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIGhhbmRsZXJzID0ge307XG4gICAgICAgIGFsaWFzTWFwID0ge307XG4gICAgICAgIGRlZmF1bHRDb21tYW5kID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIGNvbnN0IGZyb3plbnMgPSBbXTtcbiAgICBzZWxmLmZyZWV6ZSA9ICgpID0+IHtcbiAgICAgICAgZnJvemVucy5wdXNoKHtcbiAgICAgICAgICAgIGhhbmRsZXJzLFxuICAgICAgICAgICAgYWxpYXNNYXAsXG4gICAgICAgICAgICBkZWZhdWx0Q29tbWFuZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBzZWxmLnVuZnJlZXplID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBmcm96ZW4gPSBmcm96ZW5zLnBvcCgpO1xuICAgICAgICBhc3NlcnROb3RTdHJpY3RFcXVhbChmcm96ZW4sIHVuZGVmaW5lZCwgc2hpbSk7XG4gICAgICAgICh7IGhhbmRsZXJzLCBhbGlhc01hcCwgZGVmYXVsdENvbW1hbmQgfSA9IGZyb3plbik7XG4gICAgfTtcbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWFuZEJ1aWxkZXJEZWZpbml0aW9uKGJ1aWxkZXIpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBidWlsZGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAhIWJ1aWxkZXIuYnVpbGRlciAmJlxuICAgICAgICB0eXBlb2YgYnVpbGRlci5oYW5kbGVyID09PSAnZnVuY3Rpb24nKTtcbn1cbmZ1bmN0aW9uIGlzQ29tbWFuZEFuZEFsaWFzZXMoY21kKSB7XG4gICAgaWYgKGNtZC5ldmVyeShjID0+IHR5cGVvZiBjID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNDb21tYW5kQnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIGJ1aWxkZXIgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc0NvbW1hbmRCdWlsZGVyT3B0aW9uRGVmaW5pdGlvbnMoYnVpbGRlcikge1xuICAgIHJldHVybiB0eXBlb2YgYnVpbGRlciA9PT0gJ29iamVjdCc7XG59XG5mdW5jdGlvbiBpc0NvbW1hbmRIYW5kbGVyRGVmaW5pdGlvbihjbWQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNtZCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoY21kKTtcbn1cblxuZnVuY3Rpb24gc2V0QmxvY2tpbmcoYmxvY2tpbmcpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm47XG4gICAgW3Byb2Nlc3Muc3Rkb3V0LCBwcm9jZXNzLnN0ZGVycl0uZm9yRWFjaChfc3RyZWFtID0+IHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gX3N0cmVhbTtcbiAgICAgICAgaWYgKHN0cmVhbS5faGFuZGxlICYmXG4gICAgICAgICAgICBzdHJlYW0uaXNUVFkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzdHJlYW0uX2hhbmRsZS5zZXRCbG9ja2luZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RyZWFtLl9oYW5kbGUuc2V0QmxvY2tpbmcoYmxvY2tpbmcpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzYWdlKHlhcmdzLCB5MThuLCBzaGltKSB7XG4gICAgY29uc3QgX18gPSB5MThuLl9fO1xuICAgIGNvbnN0IHNlbGYgPSB7fTtcbiAgICBjb25zdCBmYWlscyA9IFtdO1xuICAgIHNlbGYuZmFpbEZuID0gZnVuY3Rpb24gZmFpbEZuKGYpIHtcbiAgICAgICAgZmFpbHMucHVzaChmKTtcbiAgICB9O1xuICAgIGxldCBmYWlsTWVzc2FnZSA9IG51bGw7XG4gICAgbGV0IHNob3dIZWxwT25GYWlsID0gdHJ1ZTtcbiAgICBzZWxmLnNob3dIZWxwT25GYWlsID0gZnVuY3Rpb24gc2hvd0hlbHBPbkZhaWxGbihhcmcxID0gdHJ1ZSwgYXJnMikge1xuICAgICAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uQXJncygpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnMSA9PT0gJ3N0cmluZycgPyBbdHJ1ZSwgYXJnMV0gOiBbYXJnMSwgYXJnMl07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2VuYWJsZWQsIG1lc3NhZ2VdID0gcGFyc2VGdW5jdGlvbkFyZ3MoKTtcbiAgICAgICAgZmFpbE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBzaG93SGVscE9uRmFpbCA9IGVuYWJsZWQ7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgbGV0IGZhaWx1cmVPdXRwdXQgPSBmYWxzZTtcbiAgICBzZWxmLmZhaWwgPSBmdW5jdGlvbiBmYWlsKG1zZywgZXJyKSB7XG4gICAgICAgIGNvbnN0IGxvZ2dlciA9IHlhcmdzLl9nZXRMb2dnZXJJbnN0YW5jZSgpO1xuICAgICAgICBpZiAoZmFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZmFpbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICBmYWlsc1tpXShtc2csIGVyciwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoeWFyZ3MuZ2V0RXhpdFByb2Nlc3MoKSlcbiAgICAgICAgICAgICAgICBzZXRCbG9ja2luZyh0cnVlKTtcbiAgICAgICAgICAgIGlmICghZmFpbHVyZU91dHB1dCkge1xuICAgICAgICAgICAgICAgIGZhaWx1cmVPdXRwdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzaG93SGVscE9uRmFpbCkge1xuICAgICAgICAgICAgICAgICAgICB5YXJncy5zaG93SGVscCgnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtc2cgfHwgZXJyKVxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IobXNnIHx8IGVycik7XG4gICAgICAgICAgICAgICAgaWYgKGZhaWxNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtc2cgfHwgZXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGZhaWxNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnIgPSBlcnIgfHwgbmV3IFlFcnJvcihtc2cpO1xuICAgICAgICAgICAgaWYgKHlhcmdzLmdldEV4aXRQcm9jZXNzKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWFyZ3MuZXhpdCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHlhcmdzLl9oYXNQYXJzZUNhbGxiYWNrKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWFyZ3MuZXhpdCgxLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgdXNhZ2VzID0gW107XG4gICAgbGV0IHVzYWdlRGlzYWJsZWQgPSBmYWxzZTtcbiAgICBzZWxmLnVzYWdlID0gKG1zZywgZGVzY3JpcHRpb24pID0+IHtcbiAgICAgICAgaWYgKG1zZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdXNhZ2VEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB1c2FnZXMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIHVzYWdlRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdXNhZ2VzLnB1c2goW21zZywgZGVzY3JpcHRpb24gfHwgJyddKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmdldFVzYWdlID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gdXNhZ2VzO1xuICAgIH07XG4gICAgc2VsZi5nZXRVc2FnZURpc2FibGVkID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gdXNhZ2VEaXNhYmxlZDtcbiAgICB9O1xuICAgIHNlbGYuZ2V0UG9zaXRpb25hbEdyb3VwTmFtZSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIF9fKCdQb3NpdGlvbmFsczonKTtcbiAgICB9O1xuICAgIGxldCBleGFtcGxlcyA9IFtdO1xuICAgIHNlbGYuZXhhbXBsZSA9IChjbWQsIGRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAgIGV4YW1wbGVzLnB1c2goW2NtZCwgZGVzY3JpcHRpb24gfHwgJyddKTtcbiAgICB9O1xuICAgIGxldCBjb21tYW5kcyA9IFtdO1xuICAgIHNlbGYuY29tbWFuZCA9IGZ1bmN0aW9uIGNvbW1hbmQoY21kLCBkZXNjcmlwdGlvbiwgaXNEZWZhdWx0LCBhbGlhc2VzLCBkZXByZWNhdGVkID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGlzRGVmYXVsdCkge1xuICAgICAgICAgICAgY29tbWFuZHMgPSBjb21tYW5kcy5tYXAoY21kQXJyYXkgPT4ge1xuICAgICAgICAgICAgICAgIGNtZEFycmF5WzJdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtZEFycmF5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbWFuZHMucHVzaChbY21kLCBkZXNjcmlwdGlvbiB8fCAnJywgaXNEZWZhdWx0LCBhbGlhc2VzLCBkZXByZWNhdGVkXSk7XG4gICAgfTtcbiAgICBzZWxmLmdldENvbW1hbmRzID0gKCkgPT4gY29tbWFuZHM7XG4gICAgbGV0IGRlc2NyaXB0aW9ucyA9IHt9O1xuICAgIHNlbGYuZGVzY3JpYmUgPSBmdW5jdGlvbiBkZXNjcmliZShrZXlPcktleXMsIGRlc2MpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5T3JLZXlzKSkge1xuICAgICAgICAgICAga2V5T3JLZXlzLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5kZXNjcmliZShrLCBkZXNjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBrZXlPcktleXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhrZXlPcktleXMpLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5kZXNjcmliZShrLCBrZXlPcktleXNba10pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbnNba2V5T3JLZXlzXSA9IGRlc2M7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNlbGYuZ2V0RGVzY3JpcHRpb25zID0gKCkgPT4gZGVzY3JpcHRpb25zO1xuICAgIGxldCBlcGlsb2dzID0gW107XG4gICAgc2VsZi5lcGlsb2cgPSBtc2cgPT4ge1xuICAgICAgICBlcGlsb2dzLnB1c2gobXNnKTtcbiAgICB9O1xuICAgIGxldCB3cmFwU2V0ID0gZmFsc2U7XG4gICAgbGV0IHdyYXA7XG4gICAgc2VsZi53cmFwID0gY29scyA9PiB7XG4gICAgICAgIHdyYXBTZXQgPSB0cnVlO1xuICAgICAgICB3cmFwID0gY29scztcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdldFdyYXAoKSB7XG4gICAgICAgIGlmICghd3JhcFNldCkge1xuICAgICAgICAgICAgd3JhcCA9IHdpbmRvd1dpZHRoKCk7XG4gICAgICAgICAgICB3cmFwU2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JhcDtcbiAgICB9XG4gICAgY29uc3QgZGVmZXJZMThuTG9va3VwUHJlZml4ID0gJ19feWFyZ3NTdHJpbmdfXzonO1xuICAgIHNlbGYuZGVmZXJZMThuTG9va3VwID0gc3RyID0+IGRlZmVyWTE4bkxvb2t1cFByZWZpeCArIHN0cjtcbiAgICBzZWxmLmhlbHAgPSBmdW5jdGlvbiBoZWxwKCkge1xuICAgICAgICBpZiAoY2FjaGVkSGVscE1lc3NhZ2UpXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkSGVscE1lc3NhZ2U7XG4gICAgICAgIG5vcm1hbGl6ZUFsaWFzZXMoKTtcbiAgICAgICAgY29uc3QgYmFzZSQwID0geWFyZ3MuY3VzdG9tU2NyaXB0TmFtZVxuICAgICAgICAgICAgPyB5YXJncy4kMFxuICAgICAgICAgICAgOiBzaGltLnBhdGguYmFzZW5hbWUoeWFyZ3MuJDApO1xuICAgICAgICBjb25zdCBkZW1hbmRlZE9wdGlvbnMgPSB5YXJncy5nZXREZW1hbmRlZE9wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgZGVtYW5kZWRDb21tYW5kcyA9IHlhcmdzLmdldERlbWFuZGVkQ29tbWFuZHMoKTtcbiAgICAgICAgY29uc3QgZGVwcmVjYXRlZE9wdGlvbnMgPSB5YXJncy5nZXREZXByZWNhdGVkT3B0aW9ucygpO1xuICAgICAgICBjb25zdCBncm91cHMgPSB5YXJncy5nZXRHcm91cHMoKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHlhcmdzLmdldE9wdGlvbnMoKTtcbiAgICAgICAgbGV0IGtleXMgPSBbXTtcbiAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KE9iamVjdC5rZXlzKGRlc2NyaXB0aW9ucykpO1xuICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoT2JqZWN0LmtleXMoZGVtYW5kZWRPcHRpb25zKSk7XG4gICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChPYmplY3Qua2V5cyhkZW1hbmRlZENvbW1hbmRzKSk7XG4gICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChPYmplY3Qua2V5cyhvcHRpb25zLmRlZmF1bHQpKTtcbiAgICAgICAga2V5cyA9IGtleXMuZmlsdGVyKGZpbHRlckhpZGRlbk9wdGlvbnMpO1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoa2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnXycpXG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pKTtcbiAgICAgICAgY29uc3QgdGhlV3JhcCA9IGdldFdyYXAoKTtcbiAgICAgICAgY29uc3QgdWkgPSBzaGltLmNsaXVpKHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGVXcmFwLFxuICAgICAgICAgICAgd3JhcDogISF0aGVXcmFwLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF1c2FnZURpc2FibGVkKSB7XG4gICAgICAgICAgICBpZiAodXNhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHVzYWdlcy5mb3JFYWNoKHVzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdWkuZGl2KGAke3VzYWdlWzBdLnJlcGxhY2UoL1xcJDAvZywgYmFzZSQwKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzYWdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aS5kaXYoeyB0ZXh0OiBgJHt1c2FnZVsxXX1gLCBwYWRkaW5nOiBbMSwgMCwgMCwgMF0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1aS5kaXYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCB1ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZGVtYW5kZWRDb21tYW5kcy5fKSB7XG4gICAgICAgICAgICAgICAgICAgIHUgPSBgJHtiYXNlJDB9IDwke19fKCdjb21tYW5kJyl9PlxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1ID0gYCR7YmFzZSQwfSBbJHtfXygnY29tbWFuZCcpfV1cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1aS5kaXYoYCR7dX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB1aS5kaXYoX18oJ0NvbW1hbmRzOicpKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB5YXJncy5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRDb21tYW5kcyA9IGNvbnRleHQuY29tbWFuZHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBgJHtjb250ZXh0LmNvbW1hbmRzLmpvaW4oJyAnKX0gYFxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICBpZiAoeWFyZ3MuZ2V0UGFyc2VyQ29uZmlndXJhdGlvbigpWydzb3J0LWNvbW1hbmRzJ10gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kcyA9IGNvbW1hbmRzLnNvcnQoKGEsIGIpID0+IGFbMF0ubG9jYWxlQ29tcGFyZShiWzBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21tYW5kcy5mb3JFYWNoKGNvbW1hbmQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1hbmRTdHJpbmcgPSBgJHtiYXNlJDB9ICR7cGFyZW50Q29tbWFuZHN9JHtjb21tYW5kWzBdLnJlcGxhY2UoL15cXCQwID8vLCAnJyl9YDtcbiAgICAgICAgICAgICAgICB1aS5zcGFuKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY29tbWFuZFN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogWzAsIDIsIDAsIDJdLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbWF4V2lkdGgoY29tbWFuZHMsIHRoZVdyYXAsIGAke2Jhc2UkMH0ke3BhcmVudENvbW1hbmRzfWApICsgNCxcbiAgICAgICAgICAgICAgICB9LCB7IHRleHQ6IGNvbW1hbmRbMV0gfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGludHMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZFsyXSlcbiAgICAgICAgICAgICAgICAgICAgaGludHMucHVzaChgWyR7X18oJ2RlZmF1bHQnKX1dYCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1hbmRbM10gJiYgY29tbWFuZFszXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaGludHMucHVzaChgWyR7X18oJ2FsaWFzZXM6Jyl9ICR7Y29tbWFuZFszXS5qb2luKCcsICcpfV1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1hbmRbNF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kWzRdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGludHMucHVzaChgWyR7X18oJ2RlcHJlY2F0ZWQ6ICVzJywgY29tbWFuZFs0XSl9XWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGludHMucHVzaChgWyR7X18oJ2RlcHJlY2F0ZWQnKX1dYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhpbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB1aS5kaXYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogaGludHMuam9pbignICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogWzAsIDAsIDAsIDJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ246ICdyaWdodCcsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdWkuZGl2KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1aS5kaXYoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGlhc0tleXMgPSAoT2JqZWN0LmtleXMob3B0aW9ucy5hbGlhcykgfHwgW10pLmNvbmNhdChPYmplY3Qua2V5cyh5YXJncy5wYXJzZWQubmV3QWxpYXNlcykgfHwgW10pO1xuICAgICAgICBrZXlzID0ga2V5cy5maWx0ZXIoa2V5ID0+ICF5YXJncy5wYXJzZWQubmV3QWxpYXNlc1trZXldICYmXG4gICAgICAgICAgICBhbGlhc0tleXMuZXZlcnkoYWxpYXMgPT4gKG9wdGlvbnMuYWxpYXNbYWxpYXNdIHx8IFtdKS5pbmRleE9mKGtleSkgPT09IC0xKSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRHcm91cCA9IF9fKCdPcHRpb25zOicpO1xuICAgICAgICBpZiAoIWdyb3Vwc1tkZWZhdWx0R3JvdXBdKVxuICAgICAgICAgICAgZ3JvdXBzW2RlZmF1bHRHcm91cF0gPSBbXTtcbiAgICAgICAgYWRkVW5ncm91cGVkS2V5cyhrZXlzLCBvcHRpb25zLmFsaWFzLCBncm91cHMsIGRlZmF1bHRHcm91cCk7XG4gICAgICAgIGNvbnN0IGlzTG9uZ1N3aXRjaCA9IChzdykgPT4gL14tLS8udGVzdChnZXRUZXh0KHN3KSk7XG4gICAgICAgIGNvbnN0IGRpc3BsYXllZEdyb3VwcyA9IE9iamVjdC5rZXlzKGdyb3VwcylcbiAgICAgICAgICAgIC5maWx0ZXIoZ3JvdXBOYW1lID0+IGdyb3Vwc1tncm91cE5hbWVdLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAubWFwKGdyb3VwTmFtZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5cyA9IGdyb3Vwc1tncm91cE5hbWVdXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmaWx0ZXJIaWRkZW5PcHRpb25zKVxuICAgICAgICAgICAgICAgIC5tYXAoa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAofmFsaWFzS2V5cy5pbmRleE9mKGtleSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGFsaWFzS2V5OyAoYWxpYXNLZXkgPSBhbGlhc0tleXNbaV0pICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAofihvcHRpb25zLmFsaWFzW2FsaWFzS2V5XSB8fCBbXSkuaW5kZXhPZihrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsaWFzS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBncm91cE5hbWUsIG5vcm1hbGl6ZWRLZXlzIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKCh7IG5vcm1hbGl6ZWRLZXlzIH0pID0+IG5vcm1hbGl6ZWRLZXlzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAubWFwKCh7IGdyb3VwTmFtZSwgbm9ybWFsaXplZEtleXMgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3dpdGNoZXMgPSBub3JtYWxpemVkS2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBba2V5XVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG9wdGlvbnMuYWxpYXNba2V5XSB8fCBbXSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChzdyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cE5hbWUgPT09IHNlbGYuZ2V0UG9zaXRpb25hbEdyb3VwTmFtZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN3O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKC9eWzAtOV0kLy50ZXN0KHN3KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gfm9wdGlvbnMuYm9vbGVhbi5pbmRleE9mKGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnLSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnLS0nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJy0tJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICctJykgKyBzdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuc29ydCgoc3cxLCBzdzIpID0+IGlzTG9uZ1N3aXRjaChzdzEpID09PSBpc0xvbmdTd2l0Y2goc3cyKVxuICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgOiBpc0xvbmdTd2l0Y2goc3cxKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IC0xKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgcmV0dXJuIHsgZ3JvdXBOYW1lLCBub3JtYWxpemVkS2V5cywgc3dpdGNoZXMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNob3J0U3dpdGNoZXNVc2VkID0gZGlzcGxheWVkR3JvdXBzXG4gICAgICAgICAgICAuZmlsdGVyKCh7IGdyb3VwTmFtZSB9KSA9PiBncm91cE5hbWUgIT09IHNlbGYuZ2V0UG9zaXRpb25hbEdyb3VwTmFtZSgpKVxuICAgICAgICAgICAgLnNvbWUoKHsgbm9ybWFsaXplZEtleXMsIHN3aXRjaGVzIH0pID0+ICFub3JtYWxpemVkS2V5cy5ldmVyeShrZXkgPT4gaXNMb25nU3dpdGNoKHN3aXRjaGVzW2tleV0pKSk7XG4gICAgICAgIGlmIChzaG9ydFN3aXRjaGVzVXNlZCkge1xuICAgICAgICAgICAgZGlzcGxheWVkR3JvdXBzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoeyBncm91cE5hbWUgfSkgPT4gZ3JvdXBOYW1lICE9PSBzZWxmLmdldFBvc2l0aW9uYWxHcm91cE5hbWUoKSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoeyBub3JtYWxpemVkS2V5cywgc3dpdGNoZXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTG9uZ1N3aXRjaChzd2l0Y2hlc1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoZXNba2V5XSA9IGFkZEluZGVudGF0aW9uKHN3aXRjaGVzW2tleV0sICcteCwgJy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwbGF5ZWRHcm91cHMuZm9yRWFjaCgoeyBncm91cE5hbWUsIG5vcm1hbGl6ZWRLZXlzLCBzd2l0Y2hlcyB9KSA9PiB7XG4gICAgICAgICAgICB1aS5kaXYoZ3JvdXBOYW1lKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrc3dpdGNoID0gc3dpdGNoZXNba2V5XTtcbiAgICAgICAgICAgICAgICBsZXQgZGVzYyA9IGRlc2NyaXB0aW9uc1trZXldIHx8ICcnO1xuICAgICAgICAgICAgICAgIGxldCB0eXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAofmRlc2MubGFzdEluZGV4T2YoZGVmZXJZMThuTG9va3VwUHJlZml4KSlcbiAgICAgICAgICAgICAgICAgICAgZGVzYyA9IF9fKGRlc2Muc3Vic3RyaW5nKGRlZmVyWTE4bkxvb2t1cFByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBpZiAofm9wdGlvbnMuYm9vbGVhbi5pbmRleE9mKGtleSkpXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBgWyR7X18oJ2Jvb2xlYW4nKX1dYDtcbiAgICAgICAgICAgICAgICBpZiAofm9wdGlvbnMuY291bnQuaW5kZXhPZihrZXkpKVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gYFske19fKCdjb3VudCcpfV1gO1xuICAgICAgICAgICAgICAgIGlmICh+b3B0aW9ucy5zdHJpbmcuaW5kZXhPZihrZXkpKVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gYFske19fKCdzdHJpbmcnKX1dYDtcbiAgICAgICAgICAgICAgICBpZiAofm9wdGlvbnMubm9ybWFsaXplLmluZGV4T2Yoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGBbJHtfXygnc3RyaW5nJyl9XWA7XG4gICAgICAgICAgICAgICAgaWYgKH5vcHRpb25zLmFycmF5LmluZGV4T2Yoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGBbJHtfXygnYXJyYXknKX1dYDtcbiAgICAgICAgICAgICAgICBpZiAofm9wdGlvbnMubnVtYmVyLmluZGV4T2Yoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGBbJHtfXygnbnVtYmVyJyl9XWA7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVwcmVjYXRlZEV4dHJhID0gKGRlcHJlY2F0ZWQpID0+IHR5cGVvZiBkZXByZWNhdGVkID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IGBbJHtfXygnZGVwcmVjYXRlZDogJXMnLCBkZXByZWNhdGVkKX1dYFxuICAgICAgICAgICAgICAgICAgICA6IGBbJHtfXygnZGVwcmVjYXRlZCcpfV1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhID0gW1xuICAgICAgICAgICAgICAgICAgICBrZXkgaW4gZGVwcmVjYXRlZE9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZGVwcmVjYXRlZEV4dHJhKGRlcHJlY2F0ZWRPcHRpb25zW2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGtleSBpbiBkZW1hbmRlZE9wdGlvbnMgPyBgWyR7X18oJ3JlcXVpcmVkJyl9XWAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNob2ljZXMgJiYgb3B0aW9ucy5jaG9pY2VzW2tleV1cbiAgICAgICAgICAgICAgICAgICAgICAgID8gYFske19fKCdjaG9pY2VzOicpfSAke3NlbGYuc3RyaW5naWZpZWRWYWx1ZXMob3B0aW9ucy5jaG9pY2VzW2tleV0pfV1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdHJpbmcob3B0aW9ucy5kZWZhdWx0W2tleV0sIG9wdGlvbnMuZGVmYXVsdERlc2NyaXB0aW9uW2tleV0pLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICAgICAgICAgIHVpLnNwYW4oe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXRUZXh0KGtzd2l0Y2gpLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBbMCwgMiwgMCwgMiArIGdldEluZGVudGF0aW9uKGtzd2l0Y2gpXSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG1heFdpZHRoKHN3aXRjaGVzLCB0aGVXcmFwKSArIDQsXG4gICAgICAgICAgICAgICAgfSwgZGVzYyk7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhKVxuICAgICAgICAgICAgICAgICAgICB1aS5kaXYoeyB0ZXh0OiBleHRyYSwgcGFkZGluZzogWzAsIDAsIDAsIDJdLCBhbGlnbjogJ3JpZ2h0JyB9KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHVpLmRpdigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1aS5kaXYoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChleGFtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHVpLmRpdihfXygnRXhhbXBsZXM6JykpO1xuICAgICAgICAgICAgZXhhbXBsZXMuZm9yRWFjaChleGFtcGxlID0+IHtcbiAgICAgICAgICAgICAgICBleGFtcGxlWzBdID0gZXhhbXBsZVswXS5yZXBsYWNlKC9cXCQwL2csIGJhc2UkMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4YW1wbGVzLmZvckVhY2goZXhhbXBsZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV4YW1wbGVbMV0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpLmRpdih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBleGFtcGxlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogWzAsIDIsIDAsIDJdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVpLmRpdih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBleGFtcGxlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogWzAsIDIsIDAsIDJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG1heFdpZHRoKGV4YW1wbGVzLCB0aGVXcmFwKSArIDQsXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGV4YW1wbGVbMV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdWkuZGl2KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVwaWxvZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZSA9IGVwaWxvZ3NcbiAgICAgICAgICAgICAgICAubWFwKGVwaWxvZyA9PiBlcGlsb2cucmVwbGFjZSgvXFwkMC9nLCBiYXNlJDApKVxuICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIHVpLmRpdihgJHtlfVxcbmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1aS50b1N0cmluZygpLnJlcGxhY2UoL1xccyokLywgJycpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbWF4V2lkdGgodGFibGUsIHRoZVdyYXAsIG1vZGlmaWVyKSB7XG4gICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWJsZSkpIHtcbiAgICAgICAgICAgIHRhYmxlID0gT2JqZWN0LnZhbHVlcyh0YWJsZSkubWFwKHYgPT4gW3ZdKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZS5mb3JFYWNoKHYgPT4ge1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1heChzaGltLnN0cmluZ1dpZHRoKG1vZGlmaWVyID8gYCR7bW9kaWZpZXJ9ICR7Z2V0VGV4dCh2WzBdKX1gIDogZ2V0VGV4dCh2WzBdKSkgKyBnZXRJbmRlbnRhdGlvbih2WzBdKSwgd2lkdGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoZVdyYXApXG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWluKHdpZHRoLCBwYXJzZUludCgodGhlV3JhcCAqIDAuNSkudG9TdHJpbmcoKSwgMTApKTtcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVBbGlhc2VzKCkge1xuICAgICAgICBjb25zdCBkZW1hbmRlZE9wdGlvbnMgPSB5YXJncy5nZXREZW1hbmRlZE9wdGlvbnMoKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHlhcmdzLmdldE9wdGlvbnMoKTtcbiAgICAgICAgKE9iamVjdC5rZXlzKG9wdGlvbnMuYWxpYXMpIHx8IFtdKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBvcHRpb25zLmFsaWFzW2tleV0uZm9yRWFjaChhbGlhcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uc1thbGlhc10pXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVzY3JpYmUoa2V5LCBkZXNjcmlwdGlvbnNbYWxpYXNdKTtcbiAgICAgICAgICAgICAgICBpZiAoYWxpYXMgaW4gZGVtYW5kZWRPcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICB5YXJncy5kZW1hbmRPcHRpb24oa2V5LCBkZW1hbmRlZE9wdGlvbnNbYWxpYXNdKTtcbiAgICAgICAgICAgICAgICBpZiAofm9wdGlvbnMuYm9vbGVhbi5pbmRleE9mKGFsaWFzKSlcbiAgICAgICAgICAgICAgICAgICAgeWFyZ3MuYm9vbGVhbihrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh+b3B0aW9ucy5jb3VudC5pbmRleE9mKGFsaWFzKSlcbiAgICAgICAgICAgICAgICAgICAgeWFyZ3MuY291bnQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAofm9wdGlvbnMuc3RyaW5nLmluZGV4T2YoYWxpYXMpKVxuICAgICAgICAgICAgICAgICAgICB5YXJncy5zdHJpbmcoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAofm9wdGlvbnMubm9ybWFsaXplLmluZGV4T2YoYWxpYXMpKVxuICAgICAgICAgICAgICAgICAgICB5YXJncy5ub3JtYWxpemUoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAofm9wdGlvbnMuYXJyYXkuaW5kZXhPZihhbGlhcykpXG4gICAgICAgICAgICAgICAgICAgIHlhcmdzLmFycmF5KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKH5vcHRpb25zLm51bWJlci5pbmRleE9mKGFsaWFzKSlcbiAgICAgICAgICAgICAgICAgICAgeWFyZ3MubnVtYmVyKGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBjYWNoZWRIZWxwTWVzc2FnZTtcbiAgICBzZWxmLmNhY2hlSGVscE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhY2hlZEhlbHBNZXNzYWdlID0gdGhpcy5oZWxwKCk7XG4gICAgfTtcbiAgICBzZWxmLmNsZWFyQ2FjaGVkSGVscE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhY2hlZEhlbHBNZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgZnVuY3Rpb24gYWRkVW5ncm91cGVkS2V5cyhrZXlzLCBhbGlhc2VzLCBncm91cHMsIGRlZmF1bHRHcm91cCkge1xuICAgICAgICBsZXQgZ3JvdXBlZEtleXMgPSBbXTtcbiAgICAgICAgbGV0IHRvQ2hlY2sgPSBudWxsO1xuICAgICAgICBPYmplY3Qua2V5cyhncm91cHMpLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgICAgICAgICAgZ3JvdXBlZEtleXMgPSBncm91cGVkS2V5cy5jb25jYXQoZ3JvdXBzW2dyb3VwXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHRvQ2hlY2sgPSBba2V5XS5jb25jYXQoYWxpYXNlc1trZXldKTtcbiAgICAgICAgICAgIGlmICghdG9DaGVjay5zb21lKGsgPT4gZ3JvdXBlZEtleXMuaW5kZXhPZihrKSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW2RlZmF1bHRHcm91cF0ucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdyb3VwZWRLZXlzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaWx0ZXJIaWRkZW5PcHRpb25zKGtleSkge1xuICAgICAgICByZXR1cm4gKHlhcmdzLmdldE9wdGlvbnMoKS5oaWRkZW5PcHRpb25zLmluZGV4T2Yoa2V5KSA8IDAgfHxcbiAgICAgICAgICAgIHlhcmdzLnBhcnNlZC5hcmd2W3lhcmdzLmdldE9wdGlvbnMoKS5zaG93SGlkZGVuT3B0XSk7XG4gICAgfVxuICAgIHNlbGYuc2hvd0hlbHAgPSAobGV2ZWwpID0+IHtcbiAgICAgICAgY29uc3QgbG9nZ2VyID0geWFyZ3MuX2dldExvZ2dlckluc3RhbmNlKCk7XG4gICAgICAgIGlmICghbGV2ZWwpXG4gICAgICAgICAgICBsZXZlbCA9ICdlcnJvcic7XG4gICAgICAgIGNvbnN0IGVtaXQgPSB0eXBlb2YgbGV2ZWwgPT09ICdmdW5jdGlvbicgPyBsZXZlbCA6IGxvZ2dlcltsZXZlbF07XG4gICAgICAgIGVtaXQoc2VsZi5oZWxwKCkpO1xuICAgIH07XG4gICAgc2VsZi5mdW5jdGlvbkRlc2NyaXB0aW9uID0gZm4gPT4ge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGZuLm5hbWVcbiAgICAgICAgICAgID8gc2hpbS5QYXJzZXIuZGVjYW1lbGl6ZShmbi5uYW1lLCAnLScpXG4gICAgICAgICAgICA6IF9fKCdnZW5lcmF0ZWQtdmFsdWUnKTtcbiAgICAgICAgcmV0dXJuIFsnKCcsIGRlc2NyaXB0aW9uLCAnKSddLmpvaW4oJycpO1xuICAgIH07XG4gICAgc2VsZi5zdHJpbmdpZmllZFZhbHVlcyA9IGZ1bmN0aW9uIHN0cmluZ2lmaWVkVmFsdWVzKHZhbHVlcywgc2VwYXJhdG9yKSB7XG4gICAgICAgIGxldCBzdHJpbmcgPSAnJztcbiAgICAgICAgY29uc3Qgc2VwID0gc2VwYXJhdG9yIHx8ICcsICc7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gW10uY29uY2F0KHZhbHVlcyk7XG4gICAgICAgIGlmICghdmFsdWVzIHx8ICFhcnJheS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICBhcnJheS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgIGlmIChzdHJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHN0cmluZyArPSBzZXA7XG4gICAgICAgICAgICBzdHJpbmcgKz0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRTdHJpbmcodmFsdWUsIGRlZmF1bHREZXNjcmlwdGlvbikge1xuICAgICAgICBsZXQgc3RyaW5nID0gYFske19fKCdkZWZhdWx0OicpfSBgO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhZGVmYXVsdERlc2NyaXB0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChkZWZhdWx0RGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBkZWZhdWx0RGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBgXCIke3ZhbHVlfVwiYDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtzdHJpbmd9XWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdpbmRvd1dpZHRoKCkge1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IDgwO1xuICAgICAgICBpZiAoc2hpbS5wcm9jZXNzLnN0ZENvbHVtbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihtYXhXaWR0aCwgc2hpbS5wcm9jZXNzLnN0ZENvbHVtbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1heFdpZHRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB2ZXJzaW9uID0gbnVsbDtcbiAgICBzZWxmLnZlcnNpb24gPSB2ZXIgPT4ge1xuICAgICAgICB2ZXJzaW9uID0gdmVyO1xuICAgIH07XG4gICAgc2VsZi5zaG93VmVyc2lvbiA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgbG9nZ2VyID0geWFyZ3MuX2dldExvZ2dlckluc3RhbmNlKCk7XG4gICAgICAgIGxvZ2dlci5sb2codmVyc2lvbik7XG4gICAgfTtcbiAgICBzZWxmLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQobG9jYWxMb29rdXApIHtcbiAgICAgICAgZmFpbE1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBmYWlsdXJlT3V0cHV0ID0gZmFsc2U7XG4gICAgICAgIHVzYWdlcyA9IFtdO1xuICAgICAgICB1c2FnZURpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIGVwaWxvZ3MgPSBbXTtcbiAgICAgICAgZXhhbXBsZXMgPSBbXTtcbiAgICAgICAgY29tbWFuZHMgPSBbXTtcbiAgICAgICAgZGVzY3JpcHRpb25zID0gb2JqRmlsdGVyKGRlc2NyaXB0aW9ucywgayA9PiAhbG9jYWxMb29rdXBba10pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIGNvbnN0IGZyb3plbnMgPSBbXTtcbiAgICBzZWxmLmZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZSgpIHtcbiAgICAgICAgZnJvemVucy5wdXNoKHtcbiAgICAgICAgICAgIGZhaWxNZXNzYWdlLFxuICAgICAgICAgICAgZmFpbHVyZU91dHB1dCxcbiAgICAgICAgICAgIHVzYWdlcyxcbiAgICAgICAgICAgIHVzYWdlRGlzYWJsZWQsXG4gICAgICAgICAgICBlcGlsb2dzLFxuICAgICAgICAgICAgZXhhbXBsZXMsXG4gICAgICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBzZWxmLnVuZnJlZXplID0gZnVuY3Rpb24gdW5mcmVlemUoKSB7XG4gICAgICAgIGNvbnN0IGZyb3plbiA9IGZyb3plbnMucG9wKCk7XG4gICAgICAgIGFzc2VydE5vdFN0cmljdEVxdWFsKGZyb3plbiwgdW5kZWZpbmVkLCBzaGltKTtcbiAgICAgICAgKHtcbiAgICAgICAgICAgIGZhaWxNZXNzYWdlLFxuICAgICAgICAgICAgZmFpbHVyZU91dHB1dCxcbiAgICAgICAgICAgIHVzYWdlcyxcbiAgICAgICAgICAgIHVzYWdlRGlzYWJsZWQsXG4gICAgICAgICAgICBlcGlsb2dzLFxuICAgICAgICAgICAgZXhhbXBsZXMsXG4gICAgICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9ucyxcbiAgICAgICAgfSA9IGZyb3plbik7XG4gICAgfTtcbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIGlzSW5kZW50ZWRUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRleHQgPT09ICdvYmplY3QnO1xufVxuZnVuY3Rpb24gYWRkSW5kZW50YXRpb24odGV4dCwgaW5kZW50KSB7XG4gICAgcmV0dXJuIGlzSW5kZW50ZWRUZXh0KHRleHQpXG4gICAgICAgID8geyB0ZXh0OiB0ZXh0LnRleHQsIGluZGVudGF0aW9uOiB0ZXh0LmluZGVudGF0aW9uICsgaW5kZW50IH1cbiAgICAgICAgOiB7IHRleHQsIGluZGVudGF0aW9uOiBpbmRlbnQgfTtcbn1cbmZ1bmN0aW9uIGdldEluZGVudGF0aW9uKHRleHQpIHtcbiAgICByZXR1cm4gaXNJbmRlbnRlZFRleHQodGV4dCkgPyB0ZXh0LmluZGVudGF0aW9uIDogMDtcbn1cbmZ1bmN0aW9uIGdldFRleHQodGV4dCkge1xuICAgIHJldHVybiBpc0luZGVudGVkVGV4dCh0ZXh0KSA/IHRleHQudGV4dCA6IHRleHQ7XG59XG5cbmNvbnN0IGNvbXBsZXRpb25TaFRlbXBsYXRlID0gYCMjIy1iZWdpbi17e2FwcF9uYW1lfX0tY29tcGxldGlvbnMtIyMjXG4jXG4jIHlhcmdzIGNvbW1hbmQgY29tcGxldGlvbiBzY3JpcHRcbiNcbiMgSW5zdGFsbGF0aW9uOiB7e2FwcF9wYXRofX0ge3tjb21wbGV0aW9uX2NvbW1hbmR9fSA+PiB+Ly5iYXNocmNcbiMgICAgb3Ige3thcHBfcGF0aH19IHt7Y29tcGxldGlvbl9jb21tYW5kfX0gPj4gfi8uYmFzaF9wcm9maWxlIG9uIE9TWC5cbiNcbl95YXJnc19jb21wbGV0aW9ucygpXG57XG4gICAgbG9jYWwgY3VyX3dvcmQgYXJncyB0eXBlX2xpc3RcblxuICAgIGN1cl93b3JkPVwiXFwke0NPTVBfV09SRFNbQ09NUF9DV09SRF19XCJcbiAgICBhcmdzPShcIlxcJHtDT01QX1dPUkRTW0BdfVwiKVxuXG4gICAgIyBhc2sgeWFyZ3MgdG8gZ2VuZXJhdGUgY29tcGxldGlvbnMuXG4gICAgdHlwZV9saXN0PSQoe3thcHBfcGF0aH19IC0tZ2V0LXlhcmdzLWNvbXBsZXRpb25zIFwiXFwke2FyZ3NbQF19XCIpXG5cbiAgICBDT01QUkVQTFk9KCAkKGNvbXBnZW4gLVcgXCJcXCR7dHlwZV9saXN0fVwiIC0tIFxcJHtjdXJfd29yZH0pIClcblxuICAgICMgaWYgbm8gbWF0Y2ggd2FzIGZvdW5kLCBmYWxsIGJhY2sgdG8gZmlsZW5hbWUgY29tcGxldGlvblxuICAgIGlmIFsgXFwkeyNDT01QUkVQTFlbQF19IC1lcSAwIF07IHRoZW5cbiAgICAgIENPTVBSRVBMWT0oKVxuICAgIGZpXG5cbiAgICByZXR1cm4gMFxufVxuY29tcGxldGUgLW8gZGVmYXVsdCAtRiBfeWFyZ3NfY29tcGxldGlvbnMge3thcHBfbmFtZX19XG4jIyMtZW5kLXt7YXBwX25hbWV9fS1jb21wbGV0aW9ucy0jIyNcbmA7XG5jb25zdCBjb21wbGV0aW9uWnNoVGVtcGxhdGUgPSBgIyMjLWJlZ2luLXt7YXBwX25hbWV9fS1jb21wbGV0aW9ucy0jIyNcbiNcbiMgeWFyZ3MgY29tbWFuZCBjb21wbGV0aW9uIHNjcmlwdFxuI1xuIyBJbnN0YWxsYXRpb246IHt7YXBwX3BhdGh9fSB7e2NvbXBsZXRpb25fY29tbWFuZH19ID4+IH4vLnpzaHJjXG4jICAgIG9yIHt7YXBwX3BhdGh9fSB7e2NvbXBsZXRpb25fY29tbWFuZH19ID4+IH4vLnpzaF9wcm9maWxlIG9uIE9TWC5cbiNcbl97e2FwcF9uYW1lfX1feWFyZ3NfY29tcGxldGlvbnMoKVxue1xuICBsb2NhbCByZXBseVxuICBsb2NhbCBzaT0kSUZTXG4gIElGUz0kJ1xcbicgcmVwbHk9KCQoQ09NUF9DV09SRD1cIiQoKENVUlJFTlQtMSkpXCIgQ09NUF9MSU5FPVwiJEJVRkZFUlwiIENPTVBfUE9JTlQ9XCIkQ1VSU09SXCIge3thcHBfcGF0aH19IC0tZ2V0LXlhcmdzLWNvbXBsZXRpb25zIFwiXFwke3dvcmRzW0BdfVwiKSlcbiAgSUZTPSRzaVxuICBfZGVzY3JpYmUgJ3ZhbHVlcycgcmVwbHlcbn1cbmNvbXBkZWYgX3t7YXBwX25hbWV9fV95YXJnc19jb21wbGV0aW9ucyB7e2FwcF9uYW1lfX1cbiMjIy1lbmQte3thcHBfbmFtZX19LWNvbXBsZXRpb25zLSMjI1xuYDtcblxuZnVuY3Rpb24gY29tcGxldGlvbih5YXJncywgdXNhZ2UsIGNvbW1hbmQsIHNoaW0pIHtcbiAgICBjb25zdCBzZWxmID0ge1xuICAgICAgICBjb21wbGV0aW9uS2V5OiAnZ2V0LXlhcmdzLWNvbXBsZXRpb25zJyxcbiAgICB9O1xuICAgIGxldCBhbGlhc2VzO1xuICAgIHNlbGYuc2V0UGFyc2VkID0gZnVuY3Rpb24gc2V0UGFyc2VkKHBhcnNlZCkge1xuICAgICAgICBhbGlhc2VzID0gcGFyc2VkLmFsaWFzZXM7XG4gICAgfTtcbiAgICBjb25zdCB6c2hTaGVsbCA9IChzaGltLmdldEVudignU0hFTEwnKSAmJiBzaGltLmdldEVudignU0hFTEwnKS5pbmRleE9mKCd6c2gnKSAhPT0gLTEpIHx8XG4gICAgICAgIChzaGltLmdldEVudignWlNIX05BTUUnKSAmJiBzaGltLmdldEVudignWlNIX05BTUUnKS5pbmRleE9mKCd6c2gnKSAhPT0gLTEpO1xuICAgIHNlbGYuZ2V0Q29tcGxldGlvbiA9IGZ1bmN0aW9uIGdldENvbXBsZXRpb24oYXJncywgZG9uZSkge1xuICAgICAgICBjb25zdCBjb21wbGV0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gYXJncy5sZW5ndGggPyBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gOiAnJztcbiAgICAgICAgY29uc3QgYXJndiA9IHlhcmdzLnBhcnNlKGFyZ3MsIHRydWUpO1xuICAgICAgICBjb25zdCBwYXJlbnRDb21tYW5kcyA9IHlhcmdzLmdldENvbnRleHQoKS5jb21tYW5kcztcbiAgICAgICAgZnVuY3Rpb24gcnVuQ29tcGxldGlvbkZ1bmN0aW9uKGFyZ3YpIHtcbiAgICAgICAgICAgIGFzc2VydE5vdFN0cmljdEVxdWFsKGNvbXBsZXRpb25GdW5jdGlvbiwgbnVsbCwgc2hpbSk7XG4gICAgICAgICAgICBpZiAoaXNTeW5jQ29tcGxldGlvbkZ1bmN0aW9uKGNvbXBsZXRpb25GdW5jdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wbGV0aW9uRnVuY3Rpb24oY3VycmVudCwgYXJndik7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGxpc3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hpbS5wcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGxpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaW0ucHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRpb25GdW5jdGlvbihjdXJyZW50LCBhcmd2LCBjb21wbGV0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoY29tcGxldGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wbGV0aW9uRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBpc1Byb21pc2UoYXJndilcbiAgICAgICAgICAgICAgICA/IGFyZ3YudGhlbihydW5Db21wbGV0aW9uRnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgOiBydW5Db21wbGV0aW9uRnVuY3Rpb24oYXJndik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBjb21tYW5kLmdldENvbW1hbmRIYW5kbGVycygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyc1thcmdzW2ldXSAmJiBoYW5kbGVyc1thcmdzW2ldXS5idWlsZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVpbGRlciA9IGhhbmRsZXJzW2FyZ3NbaV1dLmJ1aWxkZXI7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tbWFuZEJ1aWxkZXJDYWxsYmFjayhidWlsZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5ID0geWFyZ3MucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRlcih5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkuYXJndjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJyZW50Lm1hdGNoKC9eLS8pICYmXG4gICAgICAgICAgICBwYXJlbnRDb21tYW5kc1twYXJlbnRDb21tYW5kcy5sZW5ndGggLSAxXSAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgdXNhZ2UuZ2V0Q29tbWFuZHMoKS5mb3JFYWNoKHVzYWdlQ29tbWFuZCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFuZE5hbWUgPSBwYXJzZUNvbW1hbmQodXNhZ2VDb21tYW5kWzBdKS5jbWQ7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MuaW5kZXhPZihjb21tYW5kTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghenNoU2hlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25zLnB1c2goY29tbWFuZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzYyA9IHVzYWdlQ29tbWFuZFsxXSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25zLnB1c2goY29tbWFuZE5hbWUucmVwbGFjZSgvOi9nLCAnXFxcXDonKSArICc6JyArIGRlc2MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQubWF0Y2goL14tLykgfHwgKGN1cnJlbnQgPT09ICcnICYmIGNvbXBsZXRpb25zLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NzID0gdXNhZ2UuZ2V0RGVzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0geWFyZ3MuZ2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5rZXkpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZWdhYmxlID0gISFvcHRpb25zLmNvbmZpZ3VyYXRpb25bJ2Jvb2xlYW4tbmVnYXRpb24nXSAmJlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmJvb2xlYW4uaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgICAgICBsZXQga2V5QW5kQWxpYXNlcyA9IFtrZXldLmNvbmNhdChhbGlhc2VzW2tleV0gfHwgW10pO1xuICAgICAgICAgICAgICAgIGlmIChuZWdhYmxlKVxuICAgICAgICAgICAgICAgICAgICBrZXlBbmRBbGlhc2VzID0ga2V5QW5kQWxpYXNlcy5jb25jYXQoa2V5QW5kQWxpYXNlcy5tYXAoa2V5ID0+IGBuby0ke2tleX1gKSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY29tcGxldGVPcHRpb25LZXkoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdEluQXJncyA9IGtleUFuZEFsaWFzZXMuZXZlcnkodmFsID0+IGFyZ3MuaW5kZXhPZihgLS0ke3ZhbH1gKSA9PT0gLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm90SW5BcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydHNCeVR3b0Rhc2hlcyA9IChzKSA9PiAvXi0tLy50ZXN0KHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNTaG9ydE9wdGlvbiA9IChzKSA9PiAvXlteMC05XSQvLnRlc3Qocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXNoZXMgPSAhc3RhcnRzQnlUd29EYXNoZXMoY3VycmVudCkgJiYgaXNTaG9ydE9wdGlvbihrZXkpID8gJy0nIDogJy0tJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghenNoU2hlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9ucy5wdXNoKGRhc2hlcyArIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXNjID0gZGVzY3Nba2V5XSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9ucy5wdXNoKGRhc2hlcyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2tleS5yZXBsYWNlKC86L2csICdcXFxcOicpfToke2Rlc2MucmVwbGFjZSgnX195YXJnc1N0cmluZ19fOicsICcnKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wbGV0ZU9wdGlvbktleShrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChuZWdhYmxlICYmICEhb3B0aW9ucy5kZWZhdWx0W2tleV0pXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlT3B0aW9uS2V5KGBuby0ke2tleX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUoY29tcGxldGlvbnMpO1xuICAgIH07XG4gICAgc2VsZi5nZW5lcmF0ZUNvbXBsZXRpb25TY3JpcHQgPSBmdW5jdGlvbiBnZW5lcmF0ZUNvbXBsZXRpb25TY3JpcHQoJDAsIGNtZCkge1xuICAgICAgICBsZXQgc2NyaXB0ID0genNoU2hlbGxcbiAgICAgICAgICAgID8gY29tcGxldGlvblpzaFRlbXBsYXRlXG4gICAgICAgICAgICA6IGNvbXBsZXRpb25TaFRlbXBsYXRlO1xuICAgICAgICBjb25zdCBuYW1lID0gc2hpbS5wYXRoLmJhc2VuYW1lKCQwKTtcbiAgICAgICAgaWYgKCQwLm1hdGNoKC9cXC5qcyQvKSlcbiAgICAgICAgICAgICQwID0gYC4vJHskMH1gO1xuICAgICAgICBzY3JpcHQgPSBzY3JpcHQucmVwbGFjZSgve3thcHBfbmFtZX19L2csIG5hbWUpO1xuICAgICAgICBzY3JpcHQgPSBzY3JpcHQucmVwbGFjZSgve3tjb21wbGV0aW9uX2NvbW1hbmR9fS9nLCBjbWQpO1xuICAgICAgICByZXR1cm4gc2NyaXB0LnJlcGxhY2UoL3t7YXBwX3BhdGh9fS9nLCAkMCk7XG4gICAgfTtcbiAgICBsZXQgY29tcGxldGlvbkZ1bmN0aW9uID0gbnVsbDtcbiAgICBzZWxmLnJlZ2lzdGVyRnVuY3Rpb24gPSBmbiA9PiB7XG4gICAgICAgIGNvbXBsZXRpb25GdW5jdGlvbiA9IGZuO1xuICAgIH07XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBpc1N5bmNDb21wbGV0aW9uRnVuY3Rpb24oY29tcGxldGlvbkZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGNvbXBsZXRpb25GdW5jdGlvbi5sZW5ndGggPCAzO1xufVxuXG5mdW5jdGlvbiBsZXZlbnNodGVpbihhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gYi5sZW5ndGg7XG4gICAgaWYgKGIubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gYS5sZW5ndGg7XG4gICAgY29uc3QgbWF0cml4ID0gW107XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8PSBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hdHJpeFtpXSA9IFtpXTtcbiAgICB9XG4gICAgbGV0IGo7XG4gICAgZm9yIChqID0gMDsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG1hdHJpeFswXVtqXSA9IGo7XG4gICAgfVxuICAgIGZvciAoaSA9IDE7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAxOyBqIDw9IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChiLmNoYXJBdChpIC0gMSkgPT09IGEuY2hhckF0KGogLSAxKSkge1xuICAgICAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IG1hdHJpeFtpIC0gMV1baiAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0cml4W2ldW2pdID0gTWF0aC5taW4obWF0cml4W2kgLSAxXVtqIC0gMV0gKyAxLCBNYXRoLm1pbihtYXRyaXhbaV1baiAtIDFdICsgMSwgbWF0cml4W2kgLSAxXVtqXSArIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0cml4W2IubGVuZ3RoXVthLmxlbmd0aF07XG59XG5cbmNvbnN0IHNwZWNpYWxLZXlzID0gWyckMCcsICctLScsICdfJ107XG5mdW5jdGlvbiB2YWxpZGF0aW9uKHlhcmdzLCB1c2FnZSwgeTE4biwgc2hpbSkge1xuICAgIGNvbnN0IF9fID0geTE4bi5fXztcbiAgICBjb25zdCBfX24gPSB5MThuLl9fbjtcbiAgICBjb25zdCBzZWxmID0ge307XG4gICAgc2VsZi5ub25PcHRpb25Db3VudCA9IGZ1bmN0aW9uIG5vbk9wdGlvbkNvdW50KGFyZ3YpIHtcbiAgICAgICAgY29uc3QgZGVtYW5kZWRDb21tYW5kcyA9IHlhcmdzLmdldERlbWFuZGVkQ29tbWFuZHMoKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25hbENvdW50ID0gYXJndi5fLmxlbmd0aCArIChhcmd2WyctLSddID8gYXJndlsnLS0nXS5sZW5ndGggOiAwKTtcbiAgICAgICAgY29uc3QgX3MgPSBwb3NpdGlvbmFsQ291bnQgLSB5YXJncy5nZXRDb250ZXh0KCkuY29tbWFuZHMubGVuZ3RoO1xuICAgICAgICBpZiAoZGVtYW5kZWRDb21tYW5kcy5fICYmXG4gICAgICAgICAgICAoX3MgPCBkZW1hbmRlZENvbW1hbmRzLl8ubWluIHx8IF9zID4gZGVtYW5kZWRDb21tYW5kcy5fLm1heCkpIHtcbiAgICAgICAgICAgIGlmIChfcyA8IGRlbWFuZGVkQ29tbWFuZHMuXy5taW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVtYW5kZWRDb21tYW5kcy5fLm1pbk1zZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzYWdlLmZhaWwoZGVtYW5kZWRDb21tYW5kcy5fLm1pbk1zZ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBkZW1hbmRlZENvbW1hbmRzLl8ubWluTXNnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcJDAvZywgX3MudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwkMS8sIGRlbWFuZGVkQ29tbWFuZHMuXy5taW4udG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1c2FnZS5mYWlsKF9fbignTm90IGVub3VnaCBub24tb3B0aW9uIGFyZ3VtZW50czogZ290ICVzLCBuZWVkIGF0IGxlYXN0ICVzJywgJ05vdCBlbm91Z2ggbm9uLW9wdGlvbiBhcmd1bWVudHM6IGdvdCAlcywgbmVlZCBhdCBsZWFzdCAlcycsIF9zLCBfcy50b1N0cmluZygpLCBkZW1hbmRlZENvbW1hbmRzLl8ubWluLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfcyA+IGRlbWFuZGVkQ29tbWFuZHMuXy5tYXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVtYW5kZWRDb21tYW5kcy5fLm1heE1zZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzYWdlLmZhaWwoZGVtYW5kZWRDb21tYW5kcy5fLm1heE1zZ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBkZW1hbmRlZENvbW1hbmRzLl8ubWF4TXNnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcJDAvZywgX3MudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwkMS8sIGRlbWFuZGVkQ29tbWFuZHMuXy5tYXgudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1c2FnZS5mYWlsKF9fbignVG9vIG1hbnkgbm9uLW9wdGlvbiBhcmd1bWVudHM6IGdvdCAlcywgbWF4aW11bSBvZiAlcycsICdUb28gbWFueSBub24tb3B0aW9uIGFyZ3VtZW50czogZ290ICVzLCBtYXhpbXVtIG9mICVzJywgX3MsIF9zLnRvU3RyaW5nKCksIGRlbWFuZGVkQ29tbWFuZHMuXy5tYXgudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgc2VsZi5wb3NpdGlvbmFsQ291bnQgPSBmdW5jdGlvbiBwb3NpdGlvbmFsQ291bnQocmVxdWlyZWQsIG9ic2VydmVkKSB7XG4gICAgICAgIGlmIChvYnNlcnZlZCA8IHJlcXVpcmVkKSB7XG4gICAgICAgICAgICB1c2FnZS5mYWlsKF9fbignTm90IGVub3VnaCBub24tb3B0aW9uIGFyZ3VtZW50czogZ290ICVzLCBuZWVkIGF0IGxlYXN0ICVzJywgJ05vdCBlbm91Z2ggbm9uLW9wdGlvbiBhcmd1bWVudHM6IGdvdCAlcywgbmVlZCBhdCBsZWFzdCAlcycsIG9ic2VydmVkLCBvYnNlcnZlZCArICcnLCByZXF1aXJlZCArICcnKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNlbGYucmVxdWlyZWRBcmd1bWVudHMgPSBmdW5jdGlvbiByZXF1aXJlZEFyZ3VtZW50cyhhcmd2KSB7XG4gICAgICAgIGNvbnN0IGRlbWFuZGVkT3B0aW9ucyA9IHlhcmdzLmdldERlbWFuZGVkT3B0aW9ucygpO1xuICAgICAgICBsZXQgbWlzc2luZyA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGRlbWFuZGVkT3B0aW9ucykpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3YsIGtleSkgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgYXJndltrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG1pc3NpbmcgPSBtaXNzaW5nIHx8IHt9O1xuICAgICAgICAgICAgICAgIG1pc3Npbmdba2V5XSA9IGRlbWFuZGVkT3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaXNzaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjdXN0b21Nc2dzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtaXNzaW5nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IG1pc3Npbmdba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAobXNnICYmIGN1c3RvbU1zZ3MuaW5kZXhPZihtc2cpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21Nc2dzLnB1c2gobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjdXN0b21Nc2cgPSBjdXN0b21Nc2dzLmxlbmd0aCA/IGBcXG4ke2N1c3RvbU1zZ3Muam9pbignXFxuJyl9YCA6ICcnO1xuICAgICAgICAgICAgdXNhZ2UuZmFpbChfX24oJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQ6ICVzJywgJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnRzOiAlcycsIE9iamVjdC5rZXlzKG1pc3NpbmcpLmxlbmd0aCwgT2JqZWN0LmtleXMobWlzc2luZykuam9pbignLCAnKSArIGN1c3RvbU1zZykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzZWxmLnVua25vd25Bcmd1bWVudHMgPSBmdW5jdGlvbiB1bmtub3duQXJndW1lbnRzKGFyZ3YsIGFsaWFzZXMsIHBvc2l0aW9uYWxNYXAsIGlzRGVmYXVsdENvbW1hbmQsIGNoZWNrUG9zaXRpb25hbHMgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmRLZXlzID0geWFyZ3MuZ2V0Q29tbWFuZEluc3RhbmNlKCkuZ2V0Q29tbWFuZHMoKTtcbiAgICAgICAgY29uc3QgdW5rbm93biA9IFtdO1xuICAgICAgICBjb25zdCBjdXJyZW50Q29udGV4dCA9IHlhcmdzLmdldENvbnRleHQoKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXJndikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKHNwZWNpYWxLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBvc2l0aW9uYWxNYXAsIGtleSkgJiZcbiAgICAgICAgICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHlhcmdzLl9nZXRQYXJzZUNvbnRleHQoKSwga2V5KSAmJlxuICAgICAgICAgICAgICAgICFzZWxmLmlzVmFsaWRBbmRTb21lQWxpYXNJc05vdE5ldyhrZXksIGFsaWFzZXMpKSB7XG4gICAgICAgICAgICAgICAgdW5rbm93bi5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2hlY2tQb3NpdGlvbmFscyAmJlxuICAgICAgICAgICAgKGN1cnJlbnRDb250ZXh0LmNvbW1hbmRzLmxlbmd0aCA+IDAgfHxcbiAgICAgICAgICAgICAgICBjb21tYW5kS2V5cy5sZW5ndGggPiAwIHx8XG4gICAgICAgICAgICAgICAgaXNEZWZhdWx0Q29tbWFuZCkpIHtcbiAgICAgICAgICAgIGFyZ3YuXy5zbGljZShjdXJyZW50Q29udGV4dC5jb21tYW5kcy5sZW5ndGgpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZEtleXMuaW5kZXhPZignJyArIGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHVua25vd24ucHVzaCgnJyArIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVua25vd24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdXNhZ2UuZmFpbChfX24oJ1Vua25vd24gYXJndW1lbnQ6ICVzJywgJ1Vua25vd24gYXJndW1lbnRzOiAlcycsIHVua25vd24ubGVuZ3RoLCB1bmtub3duLmpvaW4oJywgJykpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc2VsZi51bmtub3duQ29tbWFuZHMgPSBmdW5jdGlvbiB1bmtub3duQ29tbWFuZHMoYXJndikge1xuICAgICAgICBjb25zdCBjb21tYW5kS2V5cyA9IHlhcmdzLmdldENvbW1hbmRJbnN0YW5jZSgpLmdldENvbW1hbmRzKCk7XG4gICAgICAgIGNvbnN0IHVua25vd24gPSBbXTtcbiAgICAgICAgY29uc3QgY3VycmVudENvbnRleHQgPSB5YXJncy5nZXRDb250ZXh0KCk7XG4gICAgICAgIGlmIChjdXJyZW50Q29udGV4dC5jb21tYW5kcy5sZW5ndGggPiAwIHx8IGNvbW1hbmRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGFyZ3YuXy5zbGljZShjdXJyZW50Q29udGV4dC5jb21tYW5kcy5sZW5ndGgpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZEtleXMuaW5kZXhPZignJyArIGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHVua25vd24ucHVzaCgnJyArIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVua25vd24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdXNhZ2UuZmFpbChfX24oJ1Vua25vd24gY29tbWFuZDogJXMnLCAnVW5rbm93biBjb21tYW5kczogJXMnLCB1bmtub3duLmxlbmd0aCwgdW5rbm93bi5qb2luKCcsICcpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc2VsZi5pc1ZhbGlkQW5kU29tZUFsaWFzSXNOb3ROZXcgPSBmdW5jdGlvbiBpc1ZhbGlkQW5kU29tZUFsaWFzSXNOb3ROZXcoa2V5LCBhbGlhc2VzKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFsaWFzZXMsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdBbGlhc2VzID0geWFyZ3MucGFyc2VkLm5ld0FsaWFzZXM7XG4gICAgICAgIGZvciAoY29uc3QgYSBvZiBba2V5LCAuLi5hbGlhc2VzW2tleV1dKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXdBbGlhc2VzLCBhKSB8fFxuICAgICAgICAgICAgICAgICFuZXdBbGlhc2VzW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBzZWxmLmxpbWl0ZWRDaG9pY2VzID0gZnVuY3Rpb24gbGltaXRlZENob2ljZXMoYXJndikge1xuICAgICAgICBjb25zdCBvcHRpb25zID0geWFyZ3MuZ2V0T3B0aW9ucygpO1xuICAgICAgICBjb25zdCBpbnZhbGlkID0ge307XG4gICAgICAgIGlmICghT2JqZWN0LmtleXMob3B0aW9ucy5jaG9pY2VzKS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIE9iamVjdC5rZXlzKGFyZ3YpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChzcGVjaWFsS2V5cy5pbmRleE9mKGtleSkgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMuY2hvaWNlcywga2V5KSkge1xuICAgICAgICAgICAgICAgIFtdLmNvbmNhdChhcmd2W2tleV0pLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaG9pY2VzW2tleV0uaW5kZXhPZih2YWx1ZSkgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkW2tleV0gPSAoaW52YWxpZFtrZXldIHx8IFtdKS5jb25jYXQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbnZhbGlkS2V5cyA9IE9iamVjdC5rZXlzKGludmFsaWQpO1xuICAgICAgICBpZiAoIWludmFsaWRLZXlzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1zZyA9IF9fKCdJbnZhbGlkIHZhbHVlczonKTtcbiAgICAgICAgaW52YWxpZEtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbXNnICs9IGBcXG4gICR7X18oJ0FyZ3VtZW50OiAlcywgR2l2ZW46ICVzLCBDaG9pY2VzOiAlcycsIGtleSwgdXNhZ2Uuc3RyaW5naWZpZWRWYWx1ZXMoaW52YWxpZFtrZXldKSwgdXNhZ2Uuc3RyaW5naWZpZWRWYWx1ZXMob3B0aW9ucy5jaG9pY2VzW2tleV0pKX1gO1xuICAgICAgICB9KTtcbiAgICAgICAgdXNhZ2UuZmFpbChtc2cpO1xuICAgIH07XG4gICAgbGV0IGNoZWNrcyA9IFtdO1xuICAgIHNlbGYuY2hlY2sgPSBmdW5jdGlvbiBjaGVjayhmLCBnbG9iYWwpIHtcbiAgICAgICAgY2hlY2tzLnB1c2goe1xuICAgICAgICAgICAgZnVuYzogZixcbiAgICAgICAgICAgIGdsb2JhbCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBzZWxmLmN1c3RvbUNoZWNrcyA9IGZ1bmN0aW9uIGN1c3RvbUNoZWNrcyhhcmd2LCBhbGlhc2VzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBmOyAoZiA9IGNoZWNrc1tpXSkgIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gZi5mdW5jO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoYXJndiwgYWxpYXNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdXNhZ2UuZmFpbChlcnIubWVzc2FnZSA/IGVyci5tZXNzYWdlIDogZXJyLCBlcnIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB1c2FnZS5mYWlsKF9fKCdBcmd1bWVudCBjaGVjayBmYWlsZWQ6ICVzJywgZnVuYy50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJyB8fCByZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHVzYWdlLmZhaWwocmVzdWx0LnRvU3RyaW5nKCksIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBpbXBsaWVkID0ge307XG4gICAgc2VsZi5pbXBsaWVzID0gZnVuY3Rpb24gaW1wbGllcyhrZXksIHZhbHVlKSB7XG4gICAgICAgIGFyZ3NlcnQoJzxzdHJpbmd8b2JqZWN0PiBbYXJyYXl8bnVtYmVyfHN0cmluZ10nLCBba2V5LCB2YWx1ZV0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGtleSkuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmltcGxpZXMoaywga2V5W2tdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWFyZ3MuZ2xvYmFsKGtleSk7XG4gICAgICAgICAgICBpZiAoIWltcGxpZWRba2V5XSkge1xuICAgICAgICAgICAgICAgIGltcGxpZWRba2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChpID0+IHNlbGYuaW1wbGllcyhrZXksIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydE5vdFN0cmljdEVxdWFsKHZhbHVlLCB1bmRlZmluZWQsIHNoaW0pO1xuICAgICAgICAgICAgICAgIGltcGxpZWRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgc2VsZi5nZXRJbXBsaWVkID0gZnVuY3Rpb24gZ2V0SW1wbGllZCgpIHtcbiAgICAgICAgcmV0dXJuIGltcGxpZWQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBrZXlFeGlzdHMoYXJndiwgdmFsKSB7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlcih2YWwpO1xuICAgICAgICB2YWwgPSBpc05hTihudW0pID8gdmFsIDogbnVtO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbCA9IGFyZ3YuXy5sZW5ndGggPj0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbC5tYXRjaCgvXi0tbm8tLisvKSkge1xuICAgICAgICAgICAgdmFsID0gdmFsLm1hdGNoKC9eLS1uby0oLispLylbMV07XG4gICAgICAgICAgICB2YWwgPSAhYXJndlt2YWxdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gYXJndlt2YWxdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIHNlbGYuaW1wbGljYXRpb25zID0gZnVuY3Rpb24gaW1wbGljYXRpb25zKGFyZ3YpIHtcbiAgICAgICAgY29uc3QgaW1wbHlGYWlsID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKGltcGxpZWQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdLZXkgPSBrZXk7XG4gICAgICAgICAgICAoaW1wbGllZFtrZXldIHx8IFtdKS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gb3JpZ0tleTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlFeGlzdHMoYXJndiwga2V5KTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGtleUV4aXN0cyhhcmd2LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wbHlGYWlsLnB1c2goYCAke29yaWdLZXl9IC0+ICR7b3JpZ1ZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGltcGx5RmFpbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBtc2cgPSBgJHtfXygnSW1wbGljYXRpb25zIGZhaWxlZDonKX1cXG5gO1xuICAgICAgICAgICAgaW1wbHlGYWlsLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIG1zZyArPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXNhZ2UuZmFpbChtc2cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgY29uZmxpY3RpbmcgPSB7fTtcbiAgICBzZWxmLmNvbmZsaWN0cyA9IGZ1bmN0aW9uIGNvbmZsaWN0cyhrZXksIHZhbHVlKSB7XG4gICAgICAgIGFyZ3NlcnQoJzxzdHJpbmd8b2JqZWN0PiBbYXJyYXl8c3RyaW5nXScsIFtrZXksIHZhbHVlXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoa2V5KS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmxpY3RzKGssIGtleVtrXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlhcmdzLmdsb2JhbChrZXkpO1xuICAgICAgICAgICAgaWYgKCFjb25mbGljdGluZ1trZXldKSB7XG4gICAgICAgICAgICAgICAgY29uZmxpY3Rpbmdba2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChpID0+IHNlbGYuY29uZmxpY3RzKGtleSwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmxpY3Rpbmdba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgc2VsZi5nZXRDb25mbGljdGluZyA9ICgpID0+IGNvbmZsaWN0aW5nO1xuICAgIHNlbGYuY29uZmxpY3RpbmcgPSBmdW5jdGlvbiBjb25mbGljdGluZ0ZuKGFyZ3YpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoYXJndikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbmZsaWN0aW5nW2tleV0pIHtcbiAgICAgICAgICAgICAgICBjb25mbGljdGluZ1trZXldLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgYXJndltrZXldICE9PSB1bmRlZmluZWQgJiYgYXJndlt2YWx1ZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNhZ2UuZmFpbChfXygnQXJndW1lbnRzICVzIGFuZCAlcyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlJywga2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgc2VsZi5yZWNvbW1lbmRDb21tYW5kcyA9IGZ1bmN0aW9uIHJlY29tbWVuZENvbW1hbmRzKGNtZCwgcG90ZW50aWFsQ29tbWFuZHMpIHtcbiAgICAgICAgY29uc3QgdGhyZXNob2xkID0gMztcbiAgICAgICAgcG90ZW50aWFsQ29tbWFuZHMgPSBwb3RlbnRpYWxDb21tYW5kcy5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTtcbiAgICAgICAgbGV0IHJlY29tbWVuZGVkID0gbnVsbDtcbiAgICAgICAgbGV0IGJlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgY2FuZGlkYXRlOyAoY2FuZGlkYXRlID0gcG90ZW50aWFsQ29tbWFuZHNbaV0pICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZCA9IGxldmVuc2h0ZWluKGNtZCwgY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIGlmIChkIDw9IHRocmVzaG9sZCAmJiBkIDwgYmVzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgYmVzdERpc3RhbmNlID0gZDtcbiAgICAgICAgICAgICAgICByZWNvbW1lbmRlZCA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjb21tZW5kZWQpXG4gICAgICAgICAgICB1c2FnZS5mYWlsKF9fKCdEaWQgeW91IG1lYW4gJXM/JywgcmVjb21tZW5kZWQpKTtcbiAgICB9O1xuICAgIHNlbGYucmVzZXQgPSBmdW5jdGlvbiByZXNldChsb2NhbExvb2t1cCkge1xuICAgICAgICBpbXBsaWVkID0gb2JqRmlsdGVyKGltcGxpZWQsIGsgPT4gIWxvY2FsTG9va3VwW2tdKTtcbiAgICAgICAgY29uZmxpY3RpbmcgPSBvYmpGaWx0ZXIoY29uZmxpY3RpbmcsIGsgPT4gIWxvY2FsTG9va3VwW2tdKTtcbiAgICAgICAgY2hlY2tzID0gY2hlY2tzLmZpbHRlcihjID0+IGMuZ2xvYmFsKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBjb25zdCBmcm96ZW5zID0gW107XG4gICAgc2VsZi5mcmVlemUgPSBmdW5jdGlvbiBmcmVlemUoKSB7XG4gICAgICAgIGZyb3plbnMucHVzaCh7XG4gICAgICAgICAgICBpbXBsaWVkLFxuICAgICAgICAgICAgY2hlY2tzLFxuICAgICAgICAgICAgY29uZmxpY3RpbmcsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgc2VsZi51bmZyZWV6ZSA9IGZ1bmN0aW9uIHVuZnJlZXplKCkge1xuICAgICAgICBjb25zdCBmcm96ZW4gPSBmcm96ZW5zLnBvcCgpO1xuICAgICAgICBhc3NlcnROb3RTdHJpY3RFcXVhbChmcm96ZW4sIHVuZGVmaW5lZCwgc2hpbSk7XG4gICAgICAgICh7IGltcGxpZWQsIGNoZWNrcywgY29uZmxpY3RpbmcgfSA9IGZyb3plbik7XG4gICAgfTtcbiAgICByZXR1cm4gc2VsZjtcbn1cblxubGV0IHNoaW0kMTtcbmZ1bmN0aW9uIFlhcmdzV2l0aFNoaW0oX3NoaW0pIHtcbiAgICBzaGltJDEgPSBfc2hpbTtcbiAgICByZXR1cm4gWWFyZ3M7XG59XG5mdW5jdGlvbiBZYXJncyhwcm9jZXNzQXJncyA9IFtdLCBjd2QgPSBzaGltJDEucHJvY2Vzcy5jd2QoKSwgcGFyZW50UmVxdWlyZSkge1xuICAgIGNvbnN0IHNlbGYgPSB7fTtcbiAgICBsZXQgY29tbWFuZCQxO1xuICAgIGxldCBjb21wbGV0aW9uJDEgPSBudWxsO1xuICAgIGxldCBncm91cHMgPSB7fTtcbiAgICBjb25zdCBnbG9iYWxNaWRkbGV3YXJlID0gW107XG4gICAgbGV0IG91dHB1dCA9ICcnO1xuICAgIGNvbnN0IHByZXNlcnZlZEdyb3VwcyA9IHt9O1xuICAgIGxldCB1c2FnZSQxO1xuICAgIGxldCB2YWxpZGF0aW9uJDE7XG4gICAgbGV0IGhhbmRsZXJGaW5pc2hDb21tYW5kID0gbnVsbDtcbiAgICBjb25zdCB5MThuID0gc2hpbSQxLnkxOG47XG4gICAgc2VsZi5taWRkbGV3YXJlID0gZ2xvYmFsTWlkZGxld2FyZUZhY3RvcnkoZ2xvYmFsTWlkZGxld2FyZSwgc2VsZik7XG4gICAgc2VsZi5zY3JpcHROYW1lID0gZnVuY3Rpb24gKHNjcmlwdE5hbWUpIHtcbiAgICAgICAgc2VsZi5jdXN0b21TY3JpcHROYW1lID0gdHJ1ZTtcbiAgICAgICAgc2VsZi4kMCA9IHNjcmlwdE5hbWU7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgbGV0IGRlZmF1bHQkMDtcbiAgICBpZiAoL1xcYihub2RlfGlvanN8ZWxlY3Ryb24pKFxcLmV4ZSk/JC8udGVzdChzaGltJDEucHJvY2Vzcy5hcmd2KClbMF0pKSB7XG4gICAgICAgIGRlZmF1bHQkMCA9IHNoaW0kMS5wcm9jZXNzLmFyZ3YoKS5zbGljZSgxLCAyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlZmF1bHQkMCA9IHNoaW0kMS5wcm9jZXNzLmFyZ3YoKS5zbGljZSgwLCAxKTtcbiAgICB9XG4gICAgc2VsZi4kMCA9IGRlZmF1bHQkMFxuICAgICAgICAubWFwKHggPT4ge1xuICAgICAgICBjb25zdCBiID0gcmViYXNlKGN3ZCwgeCk7XG4gICAgICAgIHJldHVybiB4Lm1hdGNoKC9eKFxcL3woW2EtekEtWl06KT9cXFxcKS8pICYmIGIubGVuZ3RoIDwgeC5sZW5ndGggPyBiIDogeDtcbiAgICB9KVxuICAgICAgICAuam9pbignICcpXG4gICAgICAgIC50cmltKCk7XG4gICAgaWYgKHNoaW0kMS5nZXRFbnYoJ18nKSAmJiBzaGltJDEuZ2V0UHJvY2Vzc0FyZ3ZCaW4oKSA9PT0gc2hpbSQxLmdldEVudignXycpKSB7XG4gICAgICAgIHNlbGYuJDAgPSBzaGltJDFcbiAgICAgICAgICAgIC5nZXRFbnYoJ18nKVxuICAgICAgICAgICAgLnJlcGxhY2UoYCR7c2hpbSQxLnBhdGguZGlybmFtZShzaGltJDEucHJvY2Vzcy5leGVjUGF0aCgpKX0vYCwgJycpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0geyByZXNldHM6IC0xLCBjb21tYW5kczogW10sIGZ1bGxDb21tYW5kczogW10sIGZpbGVzOiBbXSB9O1xuICAgIHNlbGYuZ2V0Q29udGV4dCA9ICgpID0+IGNvbnRleHQ7XG4gICAgbGV0IGhhc091dHB1dCA9IGZhbHNlO1xuICAgIGxldCBleGl0RXJyb3IgPSBudWxsO1xuICAgIHNlbGYuZXhpdCA9IChjb2RlLCBlcnIpID0+IHtcbiAgICAgICAgaGFzT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgZXhpdEVycm9yID0gZXJyO1xuICAgICAgICBpZiAoZXhpdFByb2Nlc3MpXG4gICAgICAgICAgICBzaGltJDEucHJvY2Vzcy5leGl0KGNvZGUpO1xuICAgIH07XG4gICAgbGV0IGNvbXBsZXRpb25Db21tYW5kID0gbnVsbDtcbiAgICBzZWxmLmNvbXBsZXRpb24gPSBmdW5jdGlvbiAoY21kLCBkZXNjLCBmbikge1xuICAgICAgICBhcmdzZXJ0KCdbc3RyaW5nXSBbc3RyaW5nfGJvb2xlYW58ZnVuY3Rpb25dIFtmdW5jdGlvbl0nLCBbY21kLCBkZXNjLCBmbl0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAodHlwZW9mIGRlc2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGZuID0gZGVzYztcbiAgICAgICAgICAgIGRlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29tcGxldGlvbkNvbW1hbmQgPSBjbWQgfHwgY29tcGxldGlvbkNvbW1hbmQgfHwgJ2NvbXBsZXRpb24nO1xuICAgICAgICBpZiAoIWRlc2MgJiYgZGVzYyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlc2MgPSAnZ2VuZXJhdGUgY29tcGxldGlvbiBzY3JpcHQnO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuY29tbWFuZChjb21wbGV0aW9uQ29tbWFuZCwgZGVzYyk7XG4gICAgICAgIGlmIChmbilcbiAgICAgICAgICAgIGNvbXBsZXRpb24kMS5yZWdpc3RlckZ1bmN0aW9uKGZuKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBzZWxmLnJlc2V0T3B0aW9ucyA9IHNlbGYucmVzZXQgPSBmdW5jdGlvbiByZXNldE9wdGlvbnMoYWxpYXNlcyA9IHt9KSB7XG4gICAgICAgIGNvbnRleHQucmVzZXRzKys7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBjb25zdCB0bXBPcHRpb25zID0ge307XG4gICAgICAgIHRtcE9wdGlvbnMubG9jYWwgPSBvcHRpb25zLmxvY2FsID8gb3B0aW9ucy5sb2NhbCA6IFtdO1xuICAgICAgICB0bXBPcHRpb25zLmNvbmZpZ09iamVjdHMgPSBvcHRpb25zLmNvbmZpZ09iamVjdHNcbiAgICAgICAgICAgID8gb3B0aW9ucy5jb25maWdPYmplY3RzXG4gICAgICAgICAgICA6IFtdO1xuICAgICAgICBjb25zdCBsb2NhbExvb2t1cCA9IHt9O1xuICAgICAgICB0bXBPcHRpb25zLmxvY2FsLmZvckVhY2gobCA9PiB7XG4gICAgICAgICAgICBsb2NhbExvb2t1cFtsXSA9IHRydWU7XG4gICAgICAgICAgICAoYWxpYXNlc1tsXSB8fCBbXSkuZm9yRWFjaChhID0+IHtcbiAgICAgICAgICAgICAgICBsb2NhbExvb2t1cFthXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocHJlc2VydmVkR3JvdXBzLCBPYmplY3Qua2V5cyhncm91cHMpLnJlZHVjZSgoYWNjLCBncm91cE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBncm91cHNbZ3JvdXBOYW1lXS5maWx0ZXIoa2V5ID0+ICEoa2V5IGluIGxvY2FsTG9va3VwKSk7XG4gICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYWNjW2dyb3VwTmFtZV0gPSBrZXlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pKTtcbiAgICAgICAgZ3JvdXBzID0ge307XG4gICAgICAgIGNvbnN0IGFycmF5T3B0aW9ucyA9IFtcbiAgICAgICAgICAgICdhcnJheScsXG4gICAgICAgICAgICAnYm9vbGVhbicsXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdza2lwVmFsaWRhdGlvbicsXG4gICAgICAgICAgICAnY291bnQnLFxuICAgICAgICAgICAgJ25vcm1hbGl6ZScsXG4gICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgICdoaWRkZW5PcHRpb25zJyxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3Qgb2JqZWN0T3B0aW9ucyA9IFtcbiAgICAgICAgICAgICduYXJnJyxcbiAgICAgICAgICAgICdrZXknLFxuICAgICAgICAgICAgJ2FsaWFzJyxcbiAgICAgICAgICAgICdkZWZhdWx0JyxcbiAgICAgICAgICAgICdkZWZhdWx0RGVzY3JpcHRpb24nLFxuICAgICAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICAgICAnY2hvaWNlcycsXG4gICAgICAgICAgICAnZGVtYW5kZWRPcHRpb25zJyxcbiAgICAgICAgICAgICdkZW1hbmRlZENvbW1hbmRzJyxcbiAgICAgICAgICAgICdjb2VyY2UnLFxuICAgICAgICAgICAgJ2RlcHJlY2F0ZWRPcHRpb25zJyxcbiAgICAgICAgXTtcbiAgICAgICAgYXJyYXlPcHRpb25zLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICB0bXBPcHRpb25zW2tdID0gKG9wdGlvbnNba10gfHwgW10pLmZpbHRlcigoaykgPT4gIWxvY2FsTG9va3VwW2tdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9iamVjdE9wdGlvbnMuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgdG1wT3B0aW9uc1trXSA9IG9iakZpbHRlcihvcHRpb25zW2tdLCBrID0+ICFsb2NhbExvb2t1cFtrXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0bXBPcHRpb25zLmVudlByZWZpeCA9IG9wdGlvbnMuZW52UHJlZml4O1xuICAgICAgICBvcHRpb25zID0gdG1wT3B0aW9ucztcbiAgICAgICAgdXNhZ2UkMSA9IHVzYWdlJDEgPyB1c2FnZSQxLnJlc2V0KGxvY2FsTG9va3VwKSA6IHVzYWdlKHNlbGYsIHkxOG4sIHNoaW0kMSk7XG4gICAgICAgIHZhbGlkYXRpb24kMSA9IHZhbGlkYXRpb24kMVxuICAgICAgICAgICAgPyB2YWxpZGF0aW9uJDEucmVzZXQobG9jYWxMb29rdXApXG4gICAgICAgICAgICA6IHZhbGlkYXRpb24oc2VsZiwgdXNhZ2UkMSwgeTE4biwgc2hpbSQxKTtcbiAgICAgICAgY29tbWFuZCQxID0gY29tbWFuZCQxXG4gICAgICAgICAgICA/IGNvbW1hbmQkMS5yZXNldCgpXG4gICAgICAgICAgICA6IGNvbW1hbmQoc2VsZiwgdXNhZ2UkMSwgdmFsaWRhdGlvbiQxLCBnbG9iYWxNaWRkbGV3YXJlLCBzaGltJDEpO1xuICAgICAgICBpZiAoIWNvbXBsZXRpb24kMSlcbiAgICAgICAgICAgIGNvbXBsZXRpb24kMSA9IGNvbXBsZXRpb24oc2VsZiwgdXNhZ2UkMSwgY29tbWFuZCQxLCBzaGltJDEpO1xuICAgICAgICBjb21wbGV0aW9uQ29tbWFuZCA9IG51bGw7XG4gICAgICAgIG91dHB1dCA9ICcnO1xuICAgICAgICBleGl0RXJyb3IgPSBudWxsO1xuICAgICAgICBoYXNPdXRwdXQgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5wYXJzZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLnJlc2V0T3B0aW9ucygpO1xuICAgIGNvbnN0IGZyb3plbnMgPSBbXTtcbiAgICBmdW5jdGlvbiBmcmVlemUoKSB7XG4gICAgICAgIGZyb3plbnMucHVzaCh7XG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgY29uZmlnT2JqZWN0czogb3B0aW9ucy5jb25maWdPYmplY3RzLnNsaWNlKDApLFxuICAgICAgICAgICAgZXhpdFByb2Nlc3MsXG4gICAgICAgICAgICBncm91cHMsXG4gICAgICAgICAgICBzdHJpY3QsXG4gICAgICAgICAgICBzdHJpY3RDb21tYW5kcyxcbiAgICAgICAgICAgIHN0cmljdE9wdGlvbnMsXG4gICAgICAgICAgICBjb21wbGV0aW9uQ29tbWFuZCxcbiAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgIGV4aXRFcnJvcixcbiAgICAgICAgICAgIGhhc091dHB1dCxcbiAgICAgICAgICAgIHBhcnNlZDogc2VsZi5wYXJzZWQsXG4gICAgICAgICAgICBwYXJzZUZuLFxuICAgICAgICAgICAgcGFyc2VDb250ZXh0LFxuICAgICAgICAgICAgaGFuZGxlckZpbmlzaENvbW1hbmQsXG4gICAgICAgIH0pO1xuICAgICAgICB1c2FnZSQxLmZyZWV6ZSgpO1xuICAgICAgICB2YWxpZGF0aW9uJDEuZnJlZXplKCk7XG4gICAgICAgIGNvbW1hbmQkMS5mcmVlemUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5mcmVlemUoKSB7XG4gICAgICAgIGNvbnN0IGZyb3plbiA9IGZyb3plbnMucG9wKCk7XG4gICAgICAgIGFzc2VydE5vdFN0cmljdEVxdWFsKGZyb3plbiwgdW5kZWZpbmVkLCBzaGltJDEpO1xuICAgICAgICBsZXQgY29uZmlnT2JqZWN0cztcbiAgICAgICAgKHtcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBjb25maWdPYmplY3RzLFxuICAgICAgICAgICAgZXhpdFByb2Nlc3MsXG4gICAgICAgICAgICBncm91cHMsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICBleGl0RXJyb3IsXG4gICAgICAgICAgICBoYXNPdXRwdXQsXG4gICAgICAgICAgICBwYXJzZWQ6IHNlbGYucGFyc2VkLFxuICAgICAgICAgICAgc3RyaWN0LFxuICAgICAgICAgICAgc3RyaWN0Q29tbWFuZHMsXG4gICAgICAgICAgICBzdHJpY3RPcHRpb25zLFxuICAgICAgICAgICAgY29tcGxldGlvbkNvbW1hbmQsXG4gICAgICAgICAgICBwYXJzZUZuLFxuICAgICAgICAgICAgcGFyc2VDb250ZXh0LFxuICAgICAgICAgICAgaGFuZGxlckZpbmlzaENvbW1hbmQsXG4gICAgICAgIH0gPSBmcm96ZW4pO1xuICAgICAgICBvcHRpb25zLmNvbmZpZ09iamVjdHMgPSBjb25maWdPYmplY3RzO1xuICAgICAgICB1c2FnZSQxLnVuZnJlZXplKCk7XG4gICAgICAgIHZhbGlkYXRpb24kMS51bmZyZWV6ZSgpO1xuICAgICAgICBjb21tYW5kJDEudW5mcmVlemUoKTtcbiAgICB9XG4gICAgc2VsZi5ib29sZWFuID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgYXJnc2VydCgnPGFycmF5fHN0cmluZz4nLCBba2V5c10sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBwb3B1bGF0ZVBhcnNlckhpbnRBcnJheSgnYm9vbGVhbicsIGtleXMpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYuYXJyYXkgPSBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICBhcmdzZXJ0KCc8YXJyYXl8c3RyaW5nPicsIFtrZXlzXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHBvcHVsYXRlUGFyc2VySGludEFycmF5KCdhcnJheScsIGtleXMpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYubnVtYmVyID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgYXJnc2VydCgnPGFycmF5fHN0cmluZz4nLCBba2V5c10sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBwb3B1bGF0ZVBhcnNlckhpbnRBcnJheSgnbnVtYmVyJywga2V5cyk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5ub3JtYWxpemUgPSBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICBhcmdzZXJ0KCc8YXJyYXl8c3RyaW5nPicsIFtrZXlzXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHBvcHVsYXRlUGFyc2VySGludEFycmF5KCdub3JtYWxpemUnLCBrZXlzKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmNvdW50ID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgYXJnc2VydCgnPGFycmF5fHN0cmluZz4nLCBba2V5c10sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBwb3B1bGF0ZVBhcnNlckhpbnRBcnJheSgnY291bnQnLCBrZXlzKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLnN0cmluZyA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIGFyZ3NlcnQoJzxhcnJheXxzdHJpbmc+JywgW2tleXNdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcG9wdWxhdGVQYXJzZXJIaW50QXJyYXkoJ3N0cmluZycsIGtleXMpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYucmVxdWlyZXNBcmcgPSBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICBhcmdzZXJ0KCc8YXJyYXl8c3RyaW5nfG9iamVjdD4gW251bWJlcl0nLCBba2V5c10sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAodHlwZW9mIGtleXMgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMubmFyZ1trZXlzXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3B1bGF0ZVBhcnNlckhpbnRTaW5nbGVWYWx1ZURpY3Rpb25hcnkoc2VsZi5yZXF1aXJlc0FyZywgJ25hcmcnLCBrZXlzLCBOYU4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5za2lwVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIGFyZ3NlcnQoJzxhcnJheXxzdHJpbmc+JywgW2tleXNdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcG9wdWxhdGVQYXJzZXJIaW50QXJyYXkoJ3NraXBWYWxpZGF0aW9uJywga2V5cyk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcG9wdWxhdGVQYXJzZXJIaW50QXJyYXkodHlwZSwga2V5cykge1xuICAgICAgICBrZXlzID0gW10uY29uY2F0KGtleXMpO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGtleSA9IHNhbml0aXplS2V5KGtleSk7XG4gICAgICAgICAgICBvcHRpb25zW3R5cGVdLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbGYubmFyZ3MgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBhcmdzZXJ0KCc8c3RyaW5nfG9iamVjdHxhcnJheT4gW251bWJlcl0nLCBba2V5LCB2YWx1ZV0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBwb3B1bGF0ZVBhcnNlckhpbnRTaW5nbGVWYWx1ZURpY3Rpb25hcnkoc2VsZi5uYXJncywgJ25hcmcnLCBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmNob2ljZXMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBhcmdzZXJ0KCc8b2JqZWN0fHN0cmluZ3xhcnJheT4gW3N0cmluZ3xhcnJheV0nLCBba2V5LCB2YWx1ZV0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBwb3B1bGF0ZVBhcnNlckhpbnRBcnJheURpY3Rpb25hcnkoc2VsZi5jaG9pY2VzLCAnY2hvaWNlcycsIGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYuYWxpYXMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBhcmdzZXJ0KCc8b2JqZWN0fHN0cmluZ3xhcnJheT4gW3N0cmluZ3xhcnJheV0nLCBba2V5LCB2YWx1ZV0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBwb3B1bGF0ZVBhcnNlckhpbnRBcnJheURpY3Rpb25hcnkoc2VsZi5hbGlhcywgJ2FsaWFzJywga2V5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5kZWZhdWx0ID0gc2VsZi5kZWZhdWx0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBkZWZhdWx0RGVzY3JpcHRpb24pIHtcbiAgICAgICAgYXJnc2VydCgnPG9iamVjdHxzdHJpbmd8YXJyYXk+IFsqXSBbc3RyaW5nXScsIFtrZXksIHZhbHVlLCBkZWZhdWx0RGVzY3JpcHRpb25dLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGRlZmF1bHREZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgYXNzZXJ0U2luZ2xlS2V5KGtleSwgc2hpbSQxKTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdERlc2NyaXB0aW9uW2tleV0gPSBkZWZhdWx0RGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0U2luZ2xlS2V5KGtleSwgc2hpbSQxKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kZWZhdWx0RGVzY3JpcHRpb25ba2V5XSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRlZmF1bHREZXNjcmlwdGlvbltrZXldID0gdXNhZ2UkMS5mdW5jdGlvbkRlc2NyaXB0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2FsbCgpO1xuICAgICAgICB9XG4gICAgICAgIHBvcHVsYXRlUGFyc2VySGludFNpbmdsZVZhbHVlRGljdGlvbmFyeShzZWxmLmRlZmF1bHQsICdkZWZhdWx0Jywga2V5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5kZXNjcmliZSA9IGZ1bmN0aW9uIChrZXksIGRlc2MpIHtcbiAgICAgICAgYXJnc2VydCgnPG9iamVjdHxzdHJpbmd8YXJyYXk+IFtzdHJpbmddJywgW2tleSwgZGVzY10sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBzZXRLZXkoa2V5LCB0cnVlKTtcbiAgICAgICAgdXNhZ2UkMS5kZXNjcmliZShrZXksIGRlc2MpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHNldEtleShrZXksIHNldCkge1xuICAgICAgICBwb3B1bGF0ZVBhcnNlckhpbnRTaW5nbGVWYWx1ZURpY3Rpb25hcnkoc2V0S2V5LCAna2V5Jywga2V5LCBzZXQpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVtYW5kT3B0aW9uKGtleXMsIG1zZykge1xuICAgICAgICBhcmdzZXJ0KCc8b2JqZWN0fHN0cmluZ3xhcnJheT4gW3N0cmluZ10nLCBba2V5cywgbXNnXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHBvcHVsYXRlUGFyc2VySGludFNpbmdsZVZhbHVlRGljdGlvbmFyeShzZWxmLmRlbWFuZE9wdGlvbiwgJ2RlbWFuZGVkT3B0aW9ucycsIGtleXMsIG1zZyk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBzZWxmLmRlbWFuZE9wdGlvbiA9IGRlbWFuZE9wdGlvbjtcbiAgICBzZWxmLmNvZXJjZSA9IGZ1bmN0aW9uIChrZXlzLCB2YWx1ZSkge1xuICAgICAgICBhcmdzZXJ0KCc8b2JqZWN0fHN0cmluZ3xhcnJheT4gW2Z1bmN0aW9uXScsIFtrZXlzLCB2YWx1ZV0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBwb3B1bGF0ZVBhcnNlckhpbnRTaW5nbGVWYWx1ZURpY3Rpb25hcnkoc2VsZi5jb2VyY2UsICdjb2VyY2UnLCBrZXlzLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcG9wdWxhdGVQYXJzZXJIaW50U2luZ2xlVmFsdWVEaWN0aW9uYXJ5KGJ1aWxkZXIsIHR5cGUsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgcG9wdWxhdGVQYXJzZXJIaW50RGljdGlvbmFyeShidWlsZGVyLCB0eXBlLCBrZXksIHZhbHVlLCAodHlwZSwga2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgb3B0aW9uc1t0eXBlXVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3B1bGF0ZVBhcnNlckhpbnRBcnJheURpY3Rpb25hcnkoYnVpbGRlciwgdHlwZSwga2V5LCB2YWx1ZSkge1xuICAgICAgICBwb3B1bGF0ZVBhcnNlckhpbnREaWN0aW9uYXJ5KGJ1aWxkZXIsIHR5cGUsIGtleSwgdmFsdWUsICh0eXBlLCBrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBvcHRpb25zW3R5cGVdW2tleV0gPSAob3B0aW9uc1t0eXBlXVtrZXldIHx8IFtdKS5jb25jYXQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wdWxhdGVQYXJzZXJIaW50RGljdGlvbmFyeShidWlsZGVyLCB0eXBlLCBrZXksIHZhbHVlLCBzaW5nbGVLZXlIYW5kbGVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIGtleS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIoaywgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKChrZXkpID0+IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKShrZXkpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2Ygb2JqZWN0S2V5cyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRlcihrLCBrZXlba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2luZ2xlS2V5SGFuZGxlcih0eXBlLCBzYW5pdGl6ZUtleShrZXkpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2FuaXRpemVLZXkoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuICAgICAgICAgICAgcmV0dXJuICdfX19wcm90b19fXyc7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlbGV0ZUZyb21QYXJzZXJIaW50T2JqZWN0KG9wdGlvbktleSkge1xuICAgICAgICBvYmplY3RLZXlzKG9wdGlvbnMpLmZvckVhY2goKGhpbnRLZXkpID0+IHtcbiAgICAgICAgICAgIGlmICgoKGtleSkgPT4ga2V5ID09PSAnY29uZmlnT2JqZWN0cycpKGhpbnRLZXkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGhpbnQgPSBvcHRpb25zW2hpbnRLZXldO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGludCkpIHtcbiAgICAgICAgICAgICAgICBpZiAofmhpbnQuaW5kZXhPZihvcHRpb25LZXkpKVxuICAgICAgICAgICAgICAgICAgICBoaW50LnNwbGljZShoaW50LmluZGV4T2Yob3B0aW9uS2V5KSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaGludCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGludFtvcHRpb25LZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIHVzYWdlJDEuZ2V0RGVzY3JpcHRpb25zKClbb3B0aW9uS2V5XTtcbiAgICB9XG4gICAgc2VsZi5jb25maWcgPSBmdW5jdGlvbiBjb25maWcoa2V5ID0gJ2NvbmZpZycsIG1zZywgcGFyc2VGbikge1xuICAgICAgICBhcmdzZXJ0KCdbb2JqZWN0fHN0cmluZ10gW3N0cmluZ3xmdW5jdGlvbl0gW2Z1bmN0aW9uXScsIFtrZXksIG1zZywgcGFyc2VGbl0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAga2V5ID0gYXBwbHlFeHRlbmRzKGtleSwgY3dkLCBzZWxmLmdldFBhcnNlckNvbmZpZ3VyYXRpb24oKVsnZGVlcC1tZXJnZS1jb25maWcnXSB8fCBmYWxzZSwgc2hpbSQxKTtcbiAgICAgICAgICAgIG9wdGlvbnMuY29uZmlnT2JqZWN0cyA9IChvcHRpb25zLmNvbmZpZ09iamVjdHMgfHwgW10pLmNvbmNhdChrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtc2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBhcnNlRm4gPSBtc2c7XG4gICAgICAgICAgICBtc2cgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5kZXNjcmliZShrZXksIG1zZyB8fCB1c2FnZSQxLmRlZmVyWTE4bkxvb2t1cCgnUGF0aCB0byBKU09OIGNvbmZpZyBmaWxlJykpO1xuICAgICAgICAoQXJyYXkuaXNBcnJheShrZXkpID8ga2V5IDogW2tleV0pLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICBvcHRpb25zLmNvbmZpZ1trXSA9IHBhcnNlRm4gfHwgdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5leGFtcGxlID0gZnVuY3Rpb24gKGNtZCwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgYXJnc2VydCgnPHN0cmluZ3xhcnJheT4gW3N0cmluZ10nLCBbY21kLCBkZXNjcmlwdGlvbl0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjbWQpKSB7XG4gICAgICAgICAgICBjbWQuZm9yRWFjaChleGFtcGxlUGFyYW1zID0+IHNlbGYuZXhhbXBsZSguLi5leGFtcGxlUGFyYW1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1c2FnZSQxLmV4YW1wbGUoY21kLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmNvbW1hbmQgPSBmdW5jdGlvbiAoY21kLCBkZXNjcmlwdGlvbiwgYnVpbGRlciwgaGFuZGxlciwgbWlkZGxld2FyZXMsIGRlcHJlY2F0ZWQpIHtcbiAgICAgICAgYXJnc2VydCgnPHN0cmluZ3xhcnJheXxvYmplY3Q+IFtzdHJpbmd8Ym9vbGVhbl0gW2Z1bmN0aW9ufG9iamVjdF0gW2Z1bmN0aW9uXSBbYXJyYXldIFtib29sZWFufHN0cmluZ10nLCBbY21kLCBkZXNjcmlwdGlvbiwgYnVpbGRlciwgaGFuZGxlciwgbWlkZGxld2FyZXMsIGRlcHJlY2F0ZWRdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgY29tbWFuZCQxLmFkZEhhbmRsZXIoY21kLCBkZXNjcmlwdGlvbiwgYnVpbGRlciwgaGFuZGxlciwgbWlkZGxld2FyZXMsIGRlcHJlY2F0ZWQpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYuY29tbWFuZERpciA9IGZ1bmN0aW9uIChkaXIsIG9wdHMpIHtcbiAgICAgICAgYXJnc2VydCgnPHN0cmluZz4gW29iamVjdF0nLCBbZGlyLCBvcHRzXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlcSA9IHBhcmVudFJlcXVpcmUgfHwgc2hpbSQxLnJlcXVpcmU7XG4gICAgICAgIGNvbW1hbmQkMS5hZGREaXJlY3RvcnkoZGlyLCBzZWxmLmdldENvbnRleHQoKSwgcmVxLCBzaGltJDEuZ2V0Q2FsbGVyRmlsZSgpLCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmRlbWFuZCA9IHNlbGYucmVxdWlyZWQgPSBzZWxmLnJlcXVpcmUgPSBmdW5jdGlvbiBkZW1hbmQoa2V5cywgbWF4LCBtc2cpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF4KSkge1xuICAgICAgICAgICAgbWF4LmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnROb3RTdHJpY3RFcXVhbChtc2csIHRydWUsIHNoaW0kMSk7XG4gICAgICAgICAgICAgICAgZGVtYW5kT3B0aW9uKGtleSwgbXNnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWF4ID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1heCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG1zZyA9IG1heDtcbiAgICAgICAgICAgIG1heCA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGFzc2VydE5vdFN0cmljdEVxdWFsKG1zZywgdHJ1ZSwgc2hpbSQxKTtcbiAgICAgICAgICAgIHNlbGYuZGVtYW5kQ29tbWFuZChrZXlzLCBtYXgsIG1zZywgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnROb3RTdHJpY3RFcXVhbChtc2csIHRydWUsIHNoaW0kMSk7XG4gICAgICAgICAgICAgICAgZGVtYW5kT3B0aW9uKGtleSwgbXNnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGVtYW5kT3B0aW9uKGtleXMsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtc2cgPT09IHRydWUgfHwgdHlwZW9mIG1zZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkZW1hbmRPcHRpb24oa2V5cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmRlbWFuZENvbW1hbmQgPSBmdW5jdGlvbiBkZW1hbmRDb21tYW5kKG1pbiA9IDEsIG1heCwgbWluTXNnLCBtYXhNc2cpIHtcbiAgICAgICAgYXJnc2VydCgnW251bWJlcl0gW251bWJlcnxzdHJpbmddIFtzdHJpbmd8bnVsbHx1bmRlZmluZWRdIFtzdHJpbmd8bnVsbHx1bmRlZmluZWRdJywgW21pbiwgbWF4LCBtaW5Nc2csIG1heE1zZ10sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAodHlwZW9mIG1heCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG1pbk1zZyA9IG1heDtcbiAgICAgICAgICAgIG1heCA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZ2xvYmFsKCdfJywgZmFsc2UpO1xuICAgICAgICBvcHRpb25zLmRlbWFuZGVkQ29tbWFuZHMuXyA9IHtcbiAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgIG1heCxcbiAgICAgICAgICAgIG1pbk1zZyxcbiAgICAgICAgICAgIG1heE1zZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmdldERlbWFuZGVkT3B0aW9ucyA9ICgpID0+IHtcbiAgICAgICAgYXJnc2VydChbXSwgMCk7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmRlbWFuZGVkT3B0aW9ucztcbiAgICB9O1xuICAgIHNlbGYuZ2V0RGVtYW5kZWRDb21tYW5kcyA9ICgpID0+IHtcbiAgICAgICAgYXJnc2VydChbXSwgMCk7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmRlbWFuZGVkQ29tbWFuZHM7XG4gICAgfTtcbiAgICBzZWxmLmRlcHJlY2F0ZU9wdGlvbiA9IGZ1bmN0aW9uIGRlcHJlY2F0ZU9wdGlvbihvcHRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgYXJnc2VydCgnPHN0cmluZz4gW3N0cmluZ3xib29sZWFuXScsIFtvcHRpb24sIG1lc3NhZ2VdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgb3B0aW9ucy5kZXByZWNhdGVkT3B0aW9uc1tvcHRpb25dID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmdldERlcHJlY2F0ZWRPcHRpb25zID0gKCkgPT4ge1xuICAgICAgICBhcmdzZXJ0KFtdLCAwKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGVwcmVjYXRlZE9wdGlvbnM7XG4gICAgfTtcbiAgICBzZWxmLmltcGxpZXMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBhcmdzZXJ0KCc8c3RyaW5nfG9iamVjdD4gW251bWJlcnxzdHJpbmd8YXJyYXldJywgW2tleSwgdmFsdWVdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGlvbiQxLmltcGxpZXMoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5jb25mbGljdHMgPSBmdW5jdGlvbiAoa2V5MSwga2V5Mikge1xuICAgICAgICBhcmdzZXJ0KCc8c3RyaW5nfG9iamVjdD4gW3N0cmluZ3xhcnJheV0nLCBba2V5MSwga2V5Ml0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uJDEuY29uZmxpY3RzKGtleTEsIGtleTIpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYudXNhZ2UgPSBmdW5jdGlvbiAobXNnLCBkZXNjcmlwdGlvbiwgYnVpbGRlciwgaGFuZGxlcikge1xuICAgICAgICBhcmdzZXJ0KCc8c3RyaW5nfG51bGx8dW5kZWZpbmVkPiBbc3RyaW5nfGJvb2xlYW5dIFtmdW5jdGlvbnxvYmplY3RdIFtmdW5jdGlvbl0nLCBbbXNnLCBkZXNjcmlwdGlvbiwgYnVpbGRlciwgaGFuZGxlcl0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0Tm90U3RyaWN0RXF1YWwobXNnLCBudWxsLCBzaGltJDEpO1xuICAgICAgICAgICAgaWYgKChtc2cgfHwgJycpLm1hdGNoKC9eXFwkMCggfCQpLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jb21tYW5kKG1zZywgZGVzY3JpcHRpb24sIGJ1aWxkZXIsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFlFcnJvcignLnVzYWdlKCkgZGVzY3JpcHRpb24gbXVzdCBzdGFydCB3aXRoICQwIGlmIGJlaW5nIHVzZWQgYXMgYWxpYXMgZm9yIC5jb21tYW5kKCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzYWdlJDEudXNhZ2UobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzZWxmLmVwaWxvZ3VlID0gc2VsZi5lcGlsb2cgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGFyZ3NlcnQoJzxzdHJpbmc+JywgW21zZ10sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB1c2FnZSQxLmVwaWxvZyhtc2cpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYuZmFpbCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGFyZ3NlcnQoJzxmdW5jdGlvbj4nLCBbZl0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB1c2FnZSQxLmZhaWxGbihmKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLm9uRmluaXNoQ29tbWFuZCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGFyZ3NlcnQoJzxmdW5jdGlvbj4nLCBbZl0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBoYW5kbGVyRmluaXNoQ29tbWFuZCA9IGY7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5nZXRIYW5kbGVyRmluaXNoQ29tbWFuZCA9ICgpID0+IGhhbmRsZXJGaW5pc2hDb21tYW5kO1xuICAgIHNlbGYuY2hlY2sgPSBmdW5jdGlvbiAoZiwgX2dsb2JhbCkge1xuICAgICAgICBhcmdzZXJ0KCc8ZnVuY3Rpb24+IFtib29sZWFuXScsIFtmLCBfZ2xvYmFsXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRpb24kMS5jaGVjayhmLCBfZ2xvYmFsICE9PSBmYWxzZSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5nbG9iYWwgPSBmdW5jdGlvbiBnbG9iYWwoZ2xvYmFscywgZ2xvYmFsKSB7XG4gICAgICAgIGFyZ3NlcnQoJzxzdHJpbmd8YXJyYXk+IFtib29sZWFuXScsIFtnbG9iYWxzLCBnbG9iYWxdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZ2xvYmFscyA9IFtdLmNvbmNhdChnbG9iYWxzKTtcbiAgICAgICAgaWYgKGdsb2JhbCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubG9jYWwgPSBvcHRpb25zLmxvY2FsLmZpbHRlcihsID0+IGdsb2JhbHMuaW5kZXhPZihsKSA9PT0gLTEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFscy5mb3JFYWNoKGcgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxvY2FsLmluZGV4T2YoZykgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsLnB1c2goZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYucGtnQ29uZiA9IGZ1bmN0aW9uIHBrZ0NvbmYoa2V5LCByb290UGF0aCkge1xuICAgICAgICBhcmdzZXJ0KCc8c3RyaW5nPiBbc3RyaW5nXScsIFtrZXksIHJvb3RQYXRoXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGxldCBjb25mID0gbnVsbDtcbiAgICAgICAgY29uc3Qgb2JqID0gcGtnVXAocm9vdFBhdGggfHwgY3dkKTtcbiAgICAgICAgaWYgKG9ialtrZXldICYmIHR5cGVvZiBvYmpba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbmYgPSBhcHBseUV4dGVuZHMob2JqW2tleV0sIHJvb3RQYXRoIHx8IGN3ZCwgc2VsZi5nZXRQYXJzZXJDb25maWd1cmF0aW9uKClbJ2RlZXAtbWVyZ2UtY29uZmlnJ10gfHwgZmFsc2UsIHNoaW0kMSk7XG4gICAgICAgICAgICBvcHRpb25zLmNvbmZpZ09iamVjdHMgPSAob3B0aW9ucy5jb25maWdPYmplY3RzIHx8IFtdKS5jb25jYXQoY29uZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBjb25zdCBwa2dzID0ge307XG4gICAgZnVuY3Rpb24gcGtnVXAocm9vdFBhdGgpIHtcbiAgICAgICAgY29uc3QgbnBhdGggPSByb290UGF0aCB8fCAnKic7XG4gICAgICAgIGlmIChwa2dzW25wYXRoXSlcbiAgICAgICAgICAgIHJldHVybiBwa2dzW25wYXRoXTtcbiAgICAgICAgbGV0IG9iaiA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0RGlyID0gcm9vdFBhdGggfHwgc2hpbSQxLm1haW5GaWxlbmFtZTtcbiAgICAgICAgICAgIGlmICghcm9vdFBhdGggJiYgc2hpbSQxLnBhdGguZXh0bmFtZShzdGFydERpcikpIHtcbiAgICAgICAgICAgICAgICBzdGFydERpciA9IHNoaW0kMS5wYXRoLmRpcm5hbWUoc3RhcnREaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGtnSnNvblBhdGggPSBzaGltJDEuZmluZFVwKHN0YXJ0RGlyLCAoZGlyLCBuYW1lcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lcy5pbmNsdWRlcygncGFja2FnZS5qc29uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdwYWNrYWdlLmpzb24nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzc2VydE5vdFN0cmljdEVxdWFsKHBrZ0pzb25QYXRoLCB1bmRlZmluZWQsIHNoaW0kMSk7XG4gICAgICAgICAgICBvYmogPSBKU09OLnBhcnNlKHNoaW0kMS5yZWFkRmlsZVN5bmMocGtnSnNvblBhdGgsICd1dGY4JykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfbm9vcCkgeyB9XG4gICAgICAgIHBrZ3NbbnBhdGhdID0gb2JqIHx8IHt9O1xuICAgICAgICByZXR1cm4gcGtnc1tucGF0aF07XG4gICAgfVxuICAgIGxldCBwYXJzZUZuID0gbnVsbDtcbiAgICBsZXQgcGFyc2VDb250ZXh0ID0gbnVsbDtcbiAgICBzZWxmLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgc2hvcnRDaXJjdWl0LCBfcGFyc2VGbikge1xuICAgICAgICBhcmdzZXJ0KCdbc3RyaW5nfGFycmF5XSBbZnVuY3Rpb258Ym9vbGVhbnxvYmplY3RdIFtmdW5jdGlvbl0nLCBbYXJncywgc2hvcnRDaXJjdWl0LCBfcGFyc2VGbl0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmcmVlemUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgYXJndiA9IHNlbGYuX3BhcnNlQXJncyhwcm9jZXNzQXJncyk7XG4gICAgICAgICAgICBjb25zdCB0bXBQYXJzZWQgPSBzZWxmLnBhcnNlZDtcbiAgICAgICAgICAgIHVuZnJlZXplKCk7XG4gICAgICAgICAgICBzZWxmLnBhcnNlZCA9IHRtcFBhcnNlZDtcbiAgICAgICAgICAgIHJldHVybiBhcmd2O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2hvcnRDaXJjdWl0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcGFyc2VDb250ZXh0ID0gc2hvcnRDaXJjdWl0O1xuICAgICAgICAgICAgc2hvcnRDaXJjdWl0ID0gX3BhcnNlRm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzaG9ydENpcmN1aXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBhcnNlRm4gPSBzaG9ydENpcmN1aXQ7XG4gICAgICAgICAgICBzaG9ydENpcmN1aXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNob3J0Q2lyY3VpdClcbiAgICAgICAgICAgIHByb2Nlc3NBcmdzID0gYXJncztcbiAgICAgICAgaWYgKHBhcnNlRm4pXG4gICAgICAgICAgICBleGl0UHJvY2VzcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBzZWxmLl9wYXJzZUFyZ3MoYXJncywgISFzaG9ydENpcmN1aXQpO1xuICAgICAgICBjb21wbGV0aW9uJDEuc2V0UGFyc2VkKHNlbGYucGFyc2VkKTtcbiAgICAgICAgaWYgKHBhcnNlRm4pXG4gICAgICAgICAgICBwYXJzZUZuKGV4aXRFcnJvciwgcGFyc2VkLCBvdXRwdXQpO1xuICAgICAgICB1bmZyZWV6ZSgpO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH07XG4gICAgc2VsZi5fZ2V0UGFyc2VDb250ZXh0ID0gKCkgPT4gcGFyc2VDb250ZXh0IHx8IHt9O1xuICAgIHNlbGYuX2hhc1BhcnNlQ2FsbGJhY2sgPSAoKSA9PiAhIXBhcnNlRm47XG4gICAgc2VsZi5vcHRpb24gPSBzZWxmLm9wdGlvbnMgPSBmdW5jdGlvbiBvcHRpb24oa2V5LCBvcHQpIHtcbiAgICAgICAgYXJnc2VydCgnPHN0cmluZ3xvYmplY3Q+IFtvYmplY3RdJywgW2tleSwgb3B0XSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoa2V5KS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucyhrLCBrZXlba10pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBvcHQgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMua2V5W2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG9wdC5hbGlhcylcbiAgICAgICAgICAgICAgICBzZWxmLmFsaWFzKGtleSwgb3B0LmFsaWFzKTtcbiAgICAgICAgICAgIGNvbnN0IGRlcHJlY2F0ZSA9IG9wdC5kZXByZWNhdGUgfHwgb3B0LmRlcHJlY2F0ZWQ7XG4gICAgICAgICAgICBpZiAoZGVwcmVjYXRlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kZXByZWNhdGVPcHRpb24oa2V5LCBkZXByZWNhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVtYW5kID0gb3B0LmRlbWFuZCB8fCBvcHQucmVxdWlyZWQgfHwgb3B0LnJlcXVpcmU7XG4gICAgICAgICAgICBpZiAoZGVtYW5kKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kZW1hbmQoa2V5LCBkZW1hbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5kZW1hbmRPcHRpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRlbWFuZE9wdGlvbihrZXksIHR5cGVvZiBvcHQuZGVtYW5kT3B0aW9uID09PSAnc3RyaW5nJyA/IG9wdC5kZW1hbmRPcHRpb24gOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5jb25mbGljdHMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZsaWN0cyhrZXksIG9wdC5jb25mbGljdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBvcHQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRlZmF1bHQoa2V5LCBvcHQuZGVmYXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0LmltcGxpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaW1wbGllcyhrZXksIG9wdC5pbXBsaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHQubmFyZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYubmFyZ3Moa2V5LCBvcHQubmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5jb25maWcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZyhrZXksIG9wdC5jb25maWdQYXJzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm5vcm1hbGl6ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5jaG9pY2VzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jaG9pY2VzKGtleSwgb3B0LmNob2ljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5jb2VyY2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvZXJjZShrZXksIG9wdC5jb2VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5ncm91cCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZ3JvdXAoa2V5LCBvcHQuZ3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5ib29sZWFuIHx8IG9wdC50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmJvb2xlYW4oa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0LmFsaWFzKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmJvb2xlYW4ob3B0LmFsaWFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHQuYXJyYXkgfHwgb3B0LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFycmF5KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5hbGlhcylcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcnJheShvcHQuYWxpYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5udW1iZXIgfHwgb3B0LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5udW1iZXIoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0LmFsaWFzKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLm51bWJlcihvcHQuYWxpYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5zdHJpbmcgfHwgb3B0LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zdHJpbmcoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0LmFsaWFzKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnN0cmluZyhvcHQuYWxpYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5jb3VudCB8fCBvcHQudHlwZSA9PT0gJ2NvdW50Jykge1xuICAgICAgICAgICAgICAgIHNlbGYuY291bnQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0Lmdsb2JhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5nbG9iYWwoa2V5LCBvcHQuZ2xvYmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHQuZGVmYXVsdERlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0RGVzY3JpcHRpb25ba2V5XSA9IG9wdC5kZWZhdWx0RGVzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0LnNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5za2lwVmFsaWRhdGlvbihrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVzYyA9IG9wdC5kZXNjcmliZSB8fCBvcHQuZGVzY3JpcHRpb24gfHwgb3B0LmRlc2M7XG4gICAgICAgICAgICBzZWxmLmRlc2NyaWJlKGtleSwgZGVzYyk7XG4gICAgICAgICAgICBpZiAob3B0LmhpZGRlbikge1xuICAgICAgICAgICAgICAgIHNlbGYuaGlkZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5yZXF1aXJlc0FyZykge1xuICAgICAgICAgICAgICAgIHNlbGYucmVxdWlyZXNBcmcoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYuZ2V0T3B0aW9ucyA9ICgpID0+IG9wdGlvbnM7XG4gICAgc2VsZi5wb3NpdGlvbmFsID0gZnVuY3Rpb24gKGtleSwgb3B0cykge1xuICAgICAgICBhcmdzZXJ0KCc8c3RyaW5nPiA8b2JqZWN0PicsIFtrZXksIG9wdHNdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGNvbnRleHQucmVzZXRzID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgWUVycm9yKFwiLnBvc2l0aW9uYWwoKSBjYW4gb25seSBiZSBjYWxsZWQgaW4gYSBjb21tYW5kJ3MgYnVpbGRlciBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdXBwb3J0ZWRPcHRzID0gW1xuICAgICAgICAgICAgJ2RlZmF1bHQnLFxuICAgICAgICAgICAgJ2RlZmF1bHREZXNjcmlwdGlvbicsXG4gICAgICAgICAgICAnaW1wbGllcycsXG4gICAgICAgICAgICAnbm9ybWFsaXplJyxcbiAgICAgICAgICAgICdjaG9pY2VzJyxcbiAgICAgICAgICAgICdjb25mbGljdHMnLFxuICAgICAgICAgICAgJ2NvZXJjZScsXG4gICAgICAgICAgICAndHlwZScsXG4gICAgICAgICAgICAnZGVzY3JpYmUnLFxuICAgICAgICAgICAgJ2Rlc2MnLFxuICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgICdhbGlhcycsXG4gICAgICAgIF07XG4gICAgICAgIG9wdHMgPSBvYmpGaWx0ZXIob3B0cywgKGssIHYpID0+IHtcbiAgICAgICAgICAgIGxldCBhY2NlcHQgPSBzdXBwb3J0ZWRPcHRzLmluZGV4T2YoaykgIT09IC0xO1xuICAgICAgICAgICAgaWYgKGsgPT09ICd0eXBlJyAmJiBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddLmluZGV4T2YodikgPT09IC0xKVxuICAgICAgICAgICAgICAgIGFjY2VwdCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGFjY2VwdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZ1bGxDb21tYW5kID0gY29udGV4dC5mdWxsQ29tbWFuZHNbY29udGV4dC5mdWxsQ29tbWFuZHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHBhcnNlT3B0aW9ucyA9IGZ1bGxDb21tYW5kXG4gICAgICAgICAgICA/IGNvbW1hbmQkMS5jbWRUb1BhcnNlT3B0aW9ucyhmdWxsQ29tbWFuZClcbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGFycmF5OiBbXSxcbiAgICAgICAgICAgICAgICBhbGlhczoge30sXG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge30sXG4gICAgICAgICAgICAgICAgZGVtYW5kOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIG9iamVjdEtleXMocGFyc2VPcHRpb25zKS5mb3JFYWNoKHBrID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlT3B0aW9uID0gcGFyc2VPcHRpb25zW3BrXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlT3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZU9wdGlvbi5pbmRleE9mKGtleSkgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBvcHRzW3BrXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VPcHRpb25ba2V5XSAmJiAhKHBrIGluIG9wdHMpKVxuICAgICAgICAgICAgICAgICAgICBvcHRzW3BrXSA9IHBhcnNlT3B0aW9uW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLmdyb3VwKGtleSwgdXNhZ2UkMS5nZXRQb3NpdGlvbmFsR3JvdXBOYW1lKCkpO1xuICAgICAgICByZXR1cm4gc2VsZi5vcHRpb24oa2V5LCBvcHRzKTtcbiAgICB9O1xuICAgIHNlbGYuZ3JvdXAgPSBmdW5jdGlvbiBncm91cChvcHRzLCBncm91cE5hbWUpIHtcbiAgICAgICAgYXJnc2VydCgnPHN0cmluZ3xhcnJheT4gPHN0cmluZz4nLCBbb3B0cywgZ3JvdXBOYW1lXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcHJlc2VydmVkR3JvdXBzW2dyb3VwTmFtZV0gfHwgZ3JvdXBzW2dyb3VwTmFtZV07XG4gICAgICAgIGlmIChwcmVzZXJ2ZWRHcm91cHNbZ3JvdXBOYW1lXSkge1xuICAgICAgICAgICAgZGVsZXRlIHByZXNlcnZlZEdyb3Vwc1tncm91cE5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZW4gPSB7fTtcbiAgICAgICAgZ3JvdXBzW2dyb3VwTmFtZV0gPSAoZXhpc3RpbmcgfHwgW10pLmNvbmNhdChvcHRzKS5maWx0ZXIoa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChzZWVuW2tleV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIChzZWVuW2tleV0gPSB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5nZXRHcm91cHMgPSAoKSA9PiBPYmplY3QuYXNzaWduKHt9LCBncm91cHMsIHByZXNlcnZlZEdyb3Vwcyk7XG4gICAgc2VsZi5lbnYgPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICAgIGFyZ3NlcnQoJ1tzdHJpbmd8Ym9vbGVhbl0nLCBbcHJlZml4XSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmIChwcmVmaXggPT09IGZhbHNlKVxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZW52UHJlZml4O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvcHRpb25zLmVudlByZWZpeCA9IHByZWZpeCB8fCAnJztcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLndyYXAgPSBmdW5jdGlvbiAoY29scykge1xuICAgICAgICBhcmdzZXJ0KCc8bnVtYmVyfG51bGx8dW5kZWZpbmVkPicsIFtjb2xzXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHVzYWdlJDEud3JhcChjb2xzKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBsZXQgc3RyaWN0ID0gZmFsc2U7XG4gICAgc2VsZi5zdHJpY3QgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICBhcmdzZXJ0KCdbYm9vbGVhbl0nLCBbZW5hYmxlZF0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBzdHJpY3QgPSBlbmFibGVkICE9PSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmdldFN0cmljdCA9ICgpID0+IHN0cmljdDtcbiAgICBsZXQgc3RyaWN0Q29tbWFuZHMgPSBmYWxzZTtcbiAgICBzZWxmLnN0cmljdENvbW1hbmRzID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgYXJnc2VydCgnW2Jvb2xlYW5dJywgW2VuYWJsZWRdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgc3RyaWN0Q29tbWFuZHMgPSBlbmFibGVkICE9PSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmdldFN0cmljdENvbW1hbmRzID0gKCkgPT4gc3RyaWN0Q29tbWFuZHM7XG4gICAgbGV0IHN0cmljdE9wdGlvbnMgPSBmYWxzZTtcbiAgICBzZWxmLnN0cmljdE9wdGlvbnMgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICBhcmdzZXJ0KCdbYm9vbGVhbl0nLCBbZW5hYmxlZF0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBzdHJpY3RPcHRpb25zID0gZW5hYmxlZCAhPT0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5nZXRTdHJpY3RPcHRpb25zID0gKCkgPT4gc3RyaWN0T3B0aW9ucztcbiAgICBsZXQgcGFyc2VyQ29uZmlnID0ge307XG4gICAgc2VsZi5wYXJzZXJDb25maWd1cmF0aW9uID0gZnVuY3Rpb24gcGFyc2VyQ29uZmlndXJhdGlvbihjb25maWcpIHtcbiAgICAgICAgYXJnc2VydCgnPG9iamVjdD4nLCBbY29uZmlnXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHBhcnNlckNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmdldFBhcnNlckNvbmZpZ3VyYXRpb24gPSAoKSA9PiBwYXJzZXJDb25maWc7XG4gICAgc2VsZi5zaG93SGVscCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICBhcmdzZXJ0KCdbc3RyaW5nfGZ1bmN0aW9uXScsIFtsZXZlbF0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAoIXNlbGYucGFyc2VkKVxuICAgICAgICAgICAgc2VsZi5fcGFyc2VBcmdzKHByb2Nlc3NBcmdzKTtcbiAgICAgICAgaWYgKGNvbW1hbmQkMS5oYXNEZWZhdWx0Q29tbWFuZCgpKSB7XG4gICAgICAgICAgICBjb250ZXh0LnJlc2V0cysrO1xuICAgICAgICAgICAgY29tbWFuZCQxLnJ1bkRlZmF1bHRCdWlsZGVyT24oc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgdXNhZ2UkMS5zaG93SGVscChsZXZlbCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgbGV0IHZlcnNpb25PcHQgPSBudWxsO1xuICAgIHNlbGYudmVyc2lvbiA9IGZ1bmN0aW9uIHZlcnNpb24ob3B0LCBtc2csIHZlcikge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmVyc2lvbk9wdCA9ICd2ZXJzaW9uJztcbiAgICAgICAgYXJnc2VydCgnW2Jvb2xlYW58c3RyaW5nXSBbc3RyaW5nXSBbc3RyaW5nXScsIFtvcHQsIG1zZywgdmVyXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmICh2ZXJzaW9uT3B0KSB7XG4gICAgICAgICAgICBkZWxldGVGcm9tUGFyc2VySGludE9iamVjdCh2ZXJzaW9uT3B0KTtcbiAgICAgICAgICAgIHVzYWdlJDEudmVyc2lvbih1bmRlZmluZWQpO1xuICAgICAgICAgICAgdmVyc2lvbk9wdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZlciA9IGd1ZXNzVmVyc2lvbigpO1xuICAgICAgICAgICAgb3B0ID0gZGVmYXVsdFZlcnNpb25PcHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKG9wdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlciA9IG9wdDtcbiAgICAgICAgICAgIG9wdCA9IGRlZmF1bHRWZXJzaW9uT3B0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHZlciA9IG1zZztcbiAgICAgICAgICAgIG1zZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2ZXJzaW9uT3B0ID0gdHlwZW9mIG9wdCA9PT0gJ3N0cmluZycgPyBvcHQgOiBkZWZhdWx0VmVyc2lvbk9wdDtcbiAgICAgICAgbXNnID0gbXNnIHx8IHVzYWdlJDEuZGVmZXJZMThuTG9va3VwKCdTaG93IHZlcnNpb24gbnVtYmVyJyk7XG4gICAgICAgIHVzYWdlJDEudmVyc2lvbih2ZXIgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgc2VsZi5ib29sZWFuKHZlcnNpb25PcHQpO1xuICAgICAgICBzZWxmLmRlc2NyaWJlKHZlcnNpb25PcHQsIG1zZyk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ3Vlc3NWZXJzaW9uKCkge1xuICAgICAgICBjb25zdCBvYmogPSBwa2dVcCgpO1xuICAgICAgICByZXR1cm4gb2JqLnZlcnNpb24gfHwgJ3Vua25vd24nO1xuICAgIH1cbiAgICBsZXQgaGVscE9wdCA9IG51bGw7XG4gICAgc2VsZi5hZGRIZWxwT3B0ID0gc2VsZi5oZWxwID0gZnVuY3Rpb24gYWRkSGVscE9wdChvcHQsIG1zZykge1xuICAgICAgICBjb25zdCBkZWZhdWx0SGVscE9wdCA9ICdoZWxwJztcbiAgICAgICAgYXJnc2VydCgnW3N0cmluZ3xib29sZWFuXSBbc3RyaW5nXScsIFtvcHQsIG1zZ10sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAoaGVscE9wdCkge1xuICAgICAgICAgICAgZGVsZXRlRnJvbVBhcnNlckhpbnRPYmplY3QoaGVscE9wdCk7XG4gICAgICAgICAgICBoZWxwT3B0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKG9wdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgaGVscE9wdCA9IHR5cGVvZiBvcHQgPT09ICdzdHJpbmcnID8gb3B0IDogZGVmYXVsdEhlbHBPcHQ7XG4gICAgICAgIHNlbGYuYm9vbGVhbihoZWxwT3B0KTtcbiAgICAgICAgc2VsZi5kZXNjcmliZShoZWxwT3B0LCBtc2cgfHwgdXNhZ2UkMS5kZWZlclkxOG5Mb29rdXAoJ1Nob3cgaGVscCcpKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBjb25zdCBkZWZhdWx0U2hvd0hpZGRlbk9wdCA9ICdzaG93LWhpZGRlbic7XG4gICAgb3B0aW9ucy5zaG93SGlkZGVuT3B0ID0gZGVmYXVsdFNob3dIaWRkZW5PcHQ7XG4gICAgc2VsZi5hZGRTaG93SGlkZGVuT3B0ID0gc2VsZi5zaG93SGlkZGVuID0gZnVuY3Rpb24gYWRkU2hvd0hpZGRlbk9wdChvcHQsIG1zZykge1xuICAgICAgICBhcmdzZXJ0KCdbc3RyaW5nfGJvb2xlYW5dIFtzdHJpbmddJywgW29wdCwgbXNnXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAob3B0ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaG93SGlkZGVuT3B0ID0gdHlwZW9mIG9wdCA9PT0gJ3N0cmluZycgPyBvcHQgOiBkZWZhdWx0U2hvd0hpZGRlbk9wdDtcbiAgICAgICAgc2VsZi5ib29sZWFuKHNob3dIaWRkZW5PcHQpO1xuICAgICAgICBzZWxmLmRlc2NyaWJlKHNob3dIaWRkZW5PcHQsIG1zZyB8fCB1c2FnZSQxLmRlZmVyWTE4bkxvb2t1cCgnU2hvdyBoaWRkZW4gb3B0aW9ucycpKTtcbiAgICAgICAgb3B0aW9ucy5zaG93SGlkZGVuT3B0ID0gc2hvd0hpZGRlbk9wdDtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiBoaWRlKGtleSkge1xuICAgICAgICBhcmdzZXJ0KCc8c3RyaW5nPicsIFtrZXldLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgb3B0aW9ucy5oaWRkZW5PcHRpb25zLnB1c2goa2V5KTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLnNob3dIZWxwT25GYWlsID0gZnVuY3Rpb24gc2hvd0hlbHBPbkZhaWwoZW5hYmxlZCwgbWVzc2FnZSkge1xuICAgICAgICBhcmdzZXJ0KCdbYm9vbGVhbnxzdHJpbmddIFtzdHJpbmddJywgW2VuYWJsZWQsIG1lc3NhZ2VdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdXNhZ2UkMS5zaG93SGVscE9uRmFpbChlbmFibGVkLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBsZXQgZXhpdFByb2Nlc3MgPSB0cnVlO1xuICAgIHNlbGYuZXhpdFByb2Nlc3MgPSBmdW5jdGlvbiAoZW5hYmxlZCA9IHRydWUpIHtcbiAgICAgICAgYXJnc2VydCgnW2Jvb2xlYW5dJywgW2VuYWJsZWRdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZXhpdFByb2Nlc3MgPSBlbmFibGVkO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYuZ2V0RXhpdFByb2Nlc3MgPSAoKSA9PiBleGl0UHJvY2VzcztcbiAgICBzZWxmLnNob3dDb21wbGV0aW9uU2NyaXB0ID0gZnVuY3Rpb24gKCQwLCBjbWQpIHtcbiAgICAgICAgYXJnc2VydCgnW3N0cmluZ10gW3N0cmluZ10nLCBbJDAsIGNtZF0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICAkMCA9ICQwIHx8IHNlbGYuJDA7XG4gICAgICAgIF9sb2dnZXIubG9nKGNvbXBsZXRpb24kMS5nZW5lcmF0ZUNvbXBsZXRpb25TY3JpcHQoJDAsIGNtZCB8fCBjb21wbGV0aW9uQ29tbWFuZCB8fCAnY29tcGxldGlvbicpKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmdldENvbXBsZXRpb24gPSBmdW5jdGlvbiAoYXJncywgZG9uZSkge1xuICAgICAgICBhcmdzZXJ0KCc8YXJyYXk+IDxmdW5jdGlvbj4nLCBbYXJncywgZG9uZV0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBjb21wbGV0aW9uJDEuZ2V0Q29tcGxldGlvbihhcmdzLCBkb25lKTtcbiAgICB9O1xuICAgIHNlbGYubG9jYWxlID0gZnVuY3Rpb24gKGxvY2FsZSkge1xuICAgICAgICBhcmdzZXJ0KCdbc3RyaW5nXScsIFtsb2NhbGVdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFsb2NhbGUpIHtcbiAgICAgICAgICAgIGd1ZXNzTG9jYWxlKCk7XG4gICAgICAgICAgICByZXR1cm4geTE4bi5nZXRMb2NhbGUoKTtcbiAgICAgICAgfVxuICAgICAgICBkZXRlY3RMb2NhbGUgPSBmYWxzZTtcbiAgICAgICAgeTE4bi5zZXRMb2NhbGUobG9jYWxlKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLnVwZGF0ZVN0cmluZ3MgPSBzZWxmLnVwZGF0ZUxvY2FsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgYXJnc2VydCgnPG9iamVjdD4nLCBbb2JqXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGRldGVjdExvY2FsZSA9IGZhbHNlO1xuICAgICAgICB5MThuLnVwZGF0ZUxvY2FsZShvYmopO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIGxldCBkZXRlY3RMb2NhbGUgPSB0cnVlO1xuICAgIHNlbGYuZGV0ZWN0TG9jYWxlID0gZnVuY3Rpb24gKGRldGVjdCkge1xuICAgICAgICBhcmdzZXJ0KCc8Ym9vbGVhbj4nLCBbZGV0ZWN0XSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGRldGVjdExvY2FsZSA9IGRldGVjdDtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmdldERldGVjdExvY2FsZSA9ICgpID0+IGRldGVjdExvY2FsZTtcbiAgICBjb25zdCBfbG9nZ2VyID0ge1xuICAgICAgICBsb2coLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKCFzZWxmLl9oYXNQYXJzZUNhbGxiYWNrKCkpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coLi4uYXJncyk7XG4gICAgICAgICAgICBoYXNPdXRwdXQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICdcXG4nO1xuICAgICAgICAgICAgb3V0cHV0ICs9IGFyZ3Muam9pbignICcpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvciguLi5hcmdzKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYuX2hhc1BhcnNlQ2FsbGJhY2soKSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKC4uLmFyZ3MpO1xuICAgICAgICAgICAgaGFzT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG91dHB1dCArPSAnXFxuJztcbiAgICAgICAgICAgIG91dHB1dCArPSBhcmdzLmpvaW4oJyAnKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHNlbGYuX2dldExvZ2dlckluc3RhbmNlID0gKCkgPT4gX2xvZ2dlcjtcbiAgICBzZWxmLl9oYXNPdXRwdXQgPSAoKSA9PiBoYXNPdXRwdXQ7XG4gICAgc2VsZi5fc2V0SGFzT3V0cHV0ID0gKCkgPT4ge1xuICAgICAgICBoYXNPdXRwdXQgPSB0cnVlO1xuICAgIH07XG4gICAgbGV0IHJlY29tbWVuZENvbW1hbmRzO1xuICAgIHNlbGYucmVjb21tZW5kQ29tbWFuZHMgPSBmdW5jdGlvbiAocmVjb21tZW5kID0gdHJ1ZSkge1xuICAgICAgICBhcmdzZXJ0KCdbYm9vbGVhbl0nLCBbcmVjb21tZW5kXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHJlY29tbWVuZENvbW1hbmRzID0gcmVjb21tZW5kO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYuZ2V0VXNhZ2VJbnN0YW5jZSA9ICgpID0+IHVzYWdlJDE7XG4gICAgc2VsZi5nZXRWYWxpZGF0aW9uSW5zdGFuY2UgPSAoKSA9PiB2YWxpZGF0aW9uJDE7XG4gICAgc2VsZi5nZXRDb21tYW5kSW5zdGFuY2UgPSAoKSA9PiBjb21tYW5kJDE7XG4gICAgc2VsZi50ZXJtaW5hbFdpZHRoID0gKCkgPT4ge1xuICAgICAgICBhcmdzZXJ0KFtdLCAwKTtcbiAgICAgICAgcmV0dXJuIHNoaW0kMS5wcm9jZXNzLnN0ZENvbHVtbnM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgJ2FyZ3YnLCB7XG4gICAgICAgIGdldDogKCkgPT4gc2VsZi5fcGFyc2VBcmdzKHByb2Nlc3NBcmdzKSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgICBzZWxmLl9wYXJzZUFyZ3MgPSBmdW5jdGlvbiBwYXJzZUFyZ3MoYXJncywgc2hvcnRDaXJjdWl0LCBfY2FsbGVkRnJvbUNvbW1hbmQsIGNvbW1hbmRJbmRleCkge1xuICAgICAgICBsZXQgc2tpcFZhbGlkYXRpb24gPSAhIV9jYWxsZWRGcm9tQ29tbWFuZDtcbiAgICAgICAgYXJncyA9IGFyZ3MgfHwgcHJvY2Vzc0FyZ3M7XG4gICAgICAgIG9wdGlvbnMuX18gPSB5MThuLl9fO1xuICAgICAgICBvcHRpb25zLmNvbmZpZ3VyYXRpb24gPSBzZWxmLmdldFBhcnNlckNvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uc3QgcG9wdWxhdGVEb3VibGVEYXNoID0gISFvcHRpb25zLmNvbmZpZ3VyYXRpb25bJ3BvcHVsYXRlLS0nXTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5jb25maWd1cmF0aW9uLCB7XG4gICAgICAgICAgICAncG9wdWxhdGUtLSc6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBzaGltJDEuUGFyc2VyLmRldGFpbGVkKGFyZ3MsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb246IE9iamVjdC5hc3NpZ24oeyAncGFyc2UtcG9zaXRpb25hbC1udW1iZXJzJzogZmFsc2UgfSwgY29uZmlnKSxcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgYXJndiA9IHBhcnNlZC5hcmd2O1xuICAgICAgICBpZiAocGFyc2VDb250ZXh0KVxuICAgICAgICAgICAgYXJndiA9IE9iamVjdC5hc3NpZ24oe30sIGFyZ3YsIHBhcnNlQ29udGV4dCk7XG4gICAgICAgIGNvbnN0IGFsaWFzZXMgPSBwYXJzZWQuYWxpYXNlcztcbiAgICAgICAgYXJndi4kMCA9IHNlbGYuJDA7XG4gICAgICAgIHNlbGYucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ3Vlc3NMb2NhbGUoKTtcbiAgICAgICAgICAgIGlmIChzaG9ydENpcmN1aXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcG9zdFByb2Nlc3MoYXJndiwgcG9wdWxhdGVEb3VibGVEYXNoLCBfY2FsbGVkRnJvbUNvbW1hbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlbHBPcHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWxwQ21kcyA9IFtoZWxwT3B0XVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGFsaWFzZXNbaGVscE9wdF0gfHwgW10pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoayA9PiBrLmxlbmd0aCA+IDEpO1xuICAgICAgICAgICAgICAgIGlmICh+aGVscENtZHMuaW5kZXhPZignJyArIGFyZ3YuX1thcmd2Ll8ubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3YuXy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgYXJndltoZWxwT3B0XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFuZGxlcktleXMgPSBjb21tYW5kJDEuZ2V0Q29tbWFuZHMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RDb21wbGV0aW9ucyA9IGNvbXBsZXRpb24kMS5jb21wbGV0aW9uS2V5IGluIGFyZ3Y7XG4gICAgICAgICAgICBjb25zdCBza2lwUmVjb21tZW5kYXRpb24gPSBhcmd2W2hlbHBPcHRdIHx8IHJlcXVlc3RDb21wbGV0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHNraXBEZWZhdWx0Q29tbWFuZCA9IHNraXBSZWNvbW1lbmRhdGlvbiAmJlxuICAgICAgICAgICAgICAgIChoYW5kbGVyS2V5cy5sZW5ndGggPiAxIHx8IGhhbmRsZXJLZXlzWzBdICE9PSAnJDAnKTtcbiAgICAgICAgICAgIGlmIChhcmd2Ll8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3RVbmtub3duQ29tbWFuZDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbW1hbmRJbmRleCB8fCAwLCBjbWQ7IGFyZ3YuX1tpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IFN0cmluZyhhcmd2Ll9baV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKH5oYW5kbGVyS2V5cy5pbmRleE9mKGNtZCkgJiYgY21kICE9PSBjb21wbGV0aW9uQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyQXJndiA9IGNvbW1hbmQkMS5ydW5Db21tYW5kKGNtZCwgc2VsZiwgcGFyc2VkLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3Bvc3RQcm9jZXNzKGlubmVyQXJndiwgcG9wdWxhdGVEb3VibGVEYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFmaXJzdFVua25vd25Db21tYW5kICYmIGNtZCAhPT0gY29tcGxldGlvbkNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFVua25vd25Db21tYW5kID0gY21kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tYW5kJDEuaGFzRGVmYXVsdENvbW1hbmQoKSAmJiAhc2tpcERlZmF1bHRDb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbm5lckFyZ3YgPSBjb21tYW5kJDEucnVuQ29tbWFuZChudWxsLCBzZWxmLCBwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3Bvc3RQcm9jZXNzKGlubmVyQXJndiwgcG9wdWxhdGVEb3VibGVEYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb21tZW5kQ29tbWFuZHMgJiYgZmlyc3RVbmtub3duQ29tbWFuZCAmJiAhc2tpcFJlY29tbWVuZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uJDEucmVjb21tZW5kQ29tbWFuZHMoZmlyc3RVbmtub3duQ29tbWFuZCwgaGFuZGxlcktleXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0aW9uQ29tbWFuZCAmJlxuICAgICAgICAgICAgICAgICAgICB+YXJndi5fLmluZGV4T2YoY29tcGxldGlvbkNvbW1hbmQpICYmXG4gICAgICAgICAgICAgICAgICAgICFyZXF1ZXN0Q29tcGxldGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXRQcm9jZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QmxvY2tpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2hvd0NvbXBsZXRpb25TY3JpcHQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5leGl0KDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmQkMS5oYXNEZWZhdWx0Q29tbWFuZCgpICYmICFza2lwRGVmYXVsdENvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lckFyZ3YgPSBjb21tYW5kJDEucnVuQ29tbWFuZChudWxsLCBzZWxmLCBwYXJzZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wb3N0UHJvY2Vzcyhpbm5lckFyZ3YsIHBvcHVsYXRlRG91YmxlRGFzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdENvbXBsZXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXRQcm9jZXNzKVxuICAgICAgICAgICAgICAgICAgICBzZXRCbG9ja2luZyh0cnVlKTtcbiAgICAgICAgICAgICAgICBhcmdzID0gW10uY29uY2F0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRpb25BcmdzID0gYXJncy5zbGljZShhcmdzLmluZGV4T2YoYC0tJHtjb21wbGV0aW9uJDEuY29tcGxldGlvbktleX1gKSArIDEpO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRpb24kMS5nZXRDb21wbGV0aW9uKGNvbXBsZXRpb25BcmdzLCBjb21wbGV0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIChjb21wbGV0aW9ucyB8fCBbXSkuZm9yRWFjaChjb21wbGV0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nKGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5leGl0KDApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wb3N0UHJvY2Vzcyhhcmd2LCAhcG9wdWxhdGVEb3VibGVEYXNoLCBfY2FsbGVkRnJvbUNvbW1hbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhcmd2KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IGhlbHBPcHQgJiYgYXJndltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpdFByb2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QmxvY2tpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwVmFsaWRhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNob3dIZWxwKCdsb2cnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXhpdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IHZlcnNpb25PcHQgJiYgYXJndltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpdFByb2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QmxvY2tpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwVmFsaWRhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2FnZSQxLnNob3dWZXJzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmV4aXQoMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2tpcFZhbGlkYXRpb24gJiYgb3B0aW9ucy5za2lwVmFsaWRhdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2tpcFZhbGlkYXRpb24gPSBPYmplY3Qua2V5cyhhcmd2KS5zb21lKGtleSA9PiBvcHRpb25zLnNraXBWYWxpZGF0aW9uLmluZGV4T2Yoa2V5KSA+PSAwICYmIGFyZ3Zba2V5XSA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFlFcnJvcihwYXJzZWQuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0Q29tcGxldGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcnVuVmFsaWRhdGlvbihhcmd2LCBhbGlhc2VzLCB7fSwgcGFyc2VkLmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFlFcnJvcilcbiAgICAgICAgICAgICAgICB1c2FnZSQxLmZhaWwoZXJyLm1lc3NhZ2UsIGVycik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLl9wb3N0UHJvY2Vzcyhhcmd2LCBwb3B1bGF0ZURvdWJsZURhc2gsIF9jYWxsZWRGcm9tQ29tbWFuZCk7XG4gICAgfTtcbiAgICBzZWxmLl9wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIChhcmd2LCBwb3B1bGF0ZURvdWJsZURhc2gsIGNhbGxlZEZyb21Db21tYW5kID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShhcmd2KSlcbiAgICAgICAgICAgIHJldHVybiBhcmd2O1xuICAgICAgICBpZiAoY2FsbGVkRnJvbUNvbW1hbmQpXG4gICAgICAgICAgICByZXR1cm4gYXJndjtcbiAgICAgICAgaWYgKCFwb3B1bGF0ZURvdWJsZURhc2gpIHtcbiAgICAgICAgICAgIGFyZ3YgPSBzZWxmLl9jb3B5RG91YmxlRGFzaChhcmd2KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZVBvc2l0aW9uYWxOdW1iZXJzID0gc2VsZi5nZXRQYXJzZXJDb25maWd1cmF0aW9uKClbJ3BhcnNlLXBvc2l0aW9uYWwtbnVtYmVycyddIHx8XG4gICAgICAgICAgICBzZWxmLmdldFBhcnNlckNvbmZpZ3VyYXRpb24oKVsncGFyc2UtcG9zaXRpb25hbC1udW1iZXJzJ10gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBhcnNlUG9zaXRpb25hbE51bWJlcnMpIHtcbiAgICAgICAgICAgIGFyZ3YgPSBzZWxmLl9wYXJzZVBvc2l0aW9uYWxOdW1iZXJzKGFyZ3YpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmd2O1xuICAgIH07XG4gICAgc2VsZi5fY29weURvdWJsZURhc2ggPSBmdW5jdGlvbiAoYXJndikge1xuICAgICAgICBpZiAoIWFyZ3YuXyB8fCAhYXJndlsnLS0nXSlcbiAgICAgICAgICAgIHJldHVybiBhcmd2O1xuICAgICAgICBhcmd2Ll8ucHVzaC5hcHBseShhcmd2Ll8sIGFyZ3ZbJy0tJ10pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVsZXRlIGFyZ3ZbJy0tJ107XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9lcnIpIHsgfVxuICAgICAgICByZXR1cm4gYXJndjtcbiAgICB9O1xuICAgIHNlbGYuX3BhcnNlUG9zaXRpb25hbE51bWJlcnMgPSBmdW5jdGlvbiAoYXJndikge1xuICAgICAgICBjb25zdCBhcmdzID0gYXJndlsnLS0nXSA/IGFyZ3ZbJy0tJ10gOiBhcmd2Ll87XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBhcmc7IChhcmcgPSBhcmdzW2ldKSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzaGltJDEuUGFyc2VyLmxvb2tzTGlrZU51bWJlcihhcmcpICYmXG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzU2FmZUludGVnZXIoTWF0aC5mbG9vcihwYXJzZUZsb2F0KGAke2FyZ31gKSkpKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tpXSA9IE51bWJlcihhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmd2O1xuICAgIH07XG4gICAgc2VsZi5fcnVuVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIHJ1blZhbGlkYXRpb24oYXJndiwgYWxpYXNlcywgcG9zaXRpb25hbE1hcCwgcGFyc2VFcnJvcnMsIGlzRGVmYXVsdENvbW1hbmQgPSBmYWxzZSkge1xuICAgICAgICBpZiAocGFyc2VFcnJvcnMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgWUVycm9yKHBhcnNlRXJyb3JzLm1lc3NhZ2UpO1xuICAgICAgICB2YWxpZGF0aW9uJDEubm9uT3B0aW9uQ291bnQoYXJndik7XG4gICAgICAgIHZhbGlkYXRpb24kMS5yZXF1aXJlZEFyZ3VtZW50cyhhcmd2KTtcbiAgICAgICAgbGV0IGZhaWxlZFN0cmljdENvbW1hbmRzID0gZmFsc2U7XG4gICAgICAgIGlmIChzdHJpY3RDb21tYW5kcykge1xuICAgICAgICAgICAgZmFpbGVkU3RyaWN0Q29tbWFuZHMgPSB2YWxpZGF0aW9uJDEudW5rbm93bkNvbW1hbmRzKGFyZ3YpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpY3QgJiYgIWZhaWxlZFN0cmljdENvbW1hbmRzKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uJDEudW5rbm93bkFyZ3VtZW50cyhhcmd2LCBhbGlhc2VzLCBwb3NpdGlvbmFsTWFwLCBpc0RlZmF1bHRDb21tYW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHJpY3RPcHRpb25zKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uJDEudW5rbm93bkFyZ3VtZW50cyhhcmd2LCBhbGlhc2VzLCB7fSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0aW9uJDEuY3VzdG9tQ2hlY2tzKGFyZ3YsIGFsaWFzZXMpO1xuICAgICAgICB2YWxpZGF0aW9uJDEubGltaXRlZENob2ljZXMoYXJndik7XG4gICAgICAgIHZhbGlkYXRpb24kMS5pbXBsaWNhdGlvbnMoYXJndik7XG4gICAgICAgIHZhbGlkYXRpb24kMS5jb25mbGljdGluZyhhcmd2KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGd1ZXNzTG9jYWxlKCkge1xuICAgICAgICBpZiAoIWRldGVjdExvY2FsZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gc2hpbSQxLmdldEVudignTENfQUxMJykgfHxcbiAgICAgICAgICAgIHNoaW0kMS5nZXRFbnYoJ0xDX01FU1NBR0VTJykgfHxcbiAgICAgICAgICAgIHNoaW0kMS5nZXRFbnYoJ0xBTkcnKSB8fFxuICAgICAgICAgICAgc2hpbSQxLmdldEVudignTEFOR1VBR0UnKSB8fFxuICAgICAgICAgICAgJ2VuX1VTJztcbiAgICAgICAgc2VsZi5sb2NhbGUobG9jYWxlLnJlcGxhY2UoL1suOl0uKi8sICcnKSk7XG4gICAgfVxuICAgIHNlbGYuaGVscCgpO1xuICAgIHNlbGYudmVyc2lvbigpO1xuICAgIHJldHVybiBzZWxmO1xufVxuY29uc3QgcmViYXNlID0gKGJhc2UsIGRpcikgPT4gc2hpbSQxLnBhdGgucmVsYXRpdmUoYmFzZSwgZGlyKTtcbmZ1bmN0aW9uIGlzWWFyZ3NJbnN0YW5jZSh5KSB7XG4gICAgcmV0dXJuICEheSAmJiB0eXBlb2YgeS5fcGFyc2VBcmdzID09PSAnZnVuY3Rpb24nO1xufVxuXG52YXIgX2EsIF9iO1xuY29uc3QgeyByZWFkRmlsZVN5bmMgfSA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IGluc3BlY3QgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHsgcmVzb2x2ZSB9ID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgeTE4biA9IHJlcXVpcmUoJ3kxOG4nKTtcbmNvbnN0IFBhcnNlciA9IHJlcXVpcmUoJ3lhcmdzLXBhcnNlcicpO1xudmFyIGNqc1BsYXRmb3JtU2hpbSA9IHtcbiAgICBhc3NlcnQ6IHtcbiAgICAgICAgbm90U3RyaWN0RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgICAgICAgc3RyaWN0RXF1YWw6IGFzc2VydC5zdHJpY3RFcXVhbCxcbiAgICB9LFxuICAgIGNsaXVpOiByZXF1aXJlKCdjbGl1aScpLFxuICAgIGZpbmRVcDogcmVxdWlyZSgnZXNjYWxhZGUvc3luYycpLFxuICAgIGdldEVudjogKGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnZba2V5XTtcbiAgICB9LFxuICAgIGdldENhbGxlckZpbGU6IHJlcXVpcmUoJ2dldC1jYWxsZXItZmlsZScpLFxuICAgIGdldFByb2Nlc3NBcmd2QmluOiBnZXRQcm9jZXNzQXJndkJpbixcbiAgICBpbnNwZWN0LFxuICAgIG1haW5GaWxlbmFtZTogKF9iID0gKF9hID0gcmVxdWlyZSA9PT0gbnVsbCB8fCByZXF1aXJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXF1aXJlLm1haW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWxlbmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcHJvY2Vzcy5jd2QoKSxcbiAgICBQYXJzZXIsXG4gICAgcGF0aDogcmVxdWlyZSgncGF0aCcpLFxuICAgIHByb2Nlc3M6IHtcbiAgICAgICAgYXJndjogKCkgPT4gcHJvY2Vzcy5hcmd2LFxuICAgICAgICBjd2Q6IHByb2Nlc3MuY3dkLFxuICAgICAgICBleGVjUGF0aDogKCkgPT4gcHJvY2Vzcy5leGVjUGF0aCxcbiAgICAgICAgZXhpdDogKGNvZGUpID0+IHtcbiAgICAgICAgICAgIHByb2Nlc3MuZXhpdChjb2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dFRpY2s6IHByb2Nlc3MubmV4dFRpY2ssXG4gICAgICAgIHN0ZENvbHVtbnM6IHR5cGVvZiBwcm9jZXNzLnN0ZG91dC5jb2x1bW5zICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBwcm9jZXNzLnN0ZG91dC5jb2x1bW5zXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgfSxcbiAgICByZWFkRmlsZVN5bmMsXG4gICAgcmVxdWlyZTogcmVxdWlyZSxcbiAgICByZXF1aXJlRGlyZWN0b3J5OiByZXF1aXJlKCdyZXF1aXJlLWRpcmVjdG9yeScpLFxuICAgIHN0cmluZ1dpZHRoOiByZXF1aXJlKCdzdHJpbmctd2lkdGgnKSxcbiAgICB5MThuOiB5MThuKHtcbiAgICAgICAgZGlyZWN0b3J5OiByZXNvbHZlKF9fZGlybmFtZSwgJy4uL2xvY2FsZXMnKSxcbiAgICAgICAgdXBkYXRlRmlsZXM6IGZhbHNlLFxuICAgIH0pLFxufTtcblxuY29uc3QgbWluTm9kZVZlcnNpb24gPSBwcm9jZXNzICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52LllBUkdTX01JTl9OT0RFX1ZFUlNJT05cbiAgICA/IE51bWJlcihwcm9jZXNzLmVudi5ZQVJHU19NSU5fTk9ERV9WRVJTSU9OKVxuICAgIDogMTA7XG5pZiAocHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb24pIHtcbiAgICBjb25zdCBtYWpvciA9IE51bWJlcihwcm9jZXNzLnZlcnNpb24ubWF0Y2goL3YoW14uXSspLylbMV0pO1xuICAgIGlmIChtYWpvciA8IG1pbk5vZGVWZXJzaW9uKSB7XG4gICAgICAgIHRocm93IEVycm9yKGB5YXJncyBzdXBwb3J0cyBhIG1pbmltdW0gTm9kZS5qcyB2ZXJzaW9uIG9mICR7bWluTm9kZVZlcnNpb259LiBSZWFkIG91ciB2ZXJzaW9uIHN1cHBvcnQgcG9saWN5OiBodHRwczovL2dpdGh1Yi5jb20veWFyZ3MveWFyZ3Mjc3VwcG9ydGVkLW5vZGVqcy12ZXJzaW9uc2ApO1xuICAgIH1cbn1cbmNvbnN0IFBhcnNlciQxID0gcmVxdWlyZSgneWFyZ3MtcGFyc2VyJyk7XG5jb25zdCBZYXJncyQxID0gWWFyZ3NXaXRoU2hpbShjanNQbGF0Zm9ybVNoaW0pO1xudmFyIGNqcyA9IHtcbiAgICBhcHBseUV4dGVuZHMsXG4gICAgY2pzUGxhdGZvcm1TaGltLFxuICAgIFlhcmdzOiBZYXJncyQxLFxuICAgIGFyZ3NlcnQsXG4gICAgZ2xvYmFsTWlkZGxld2FyZUZhY3RvcnksXG4gICAgaXNQcm9taXNlLFxuICAgIG9iakZpbHRlcixcbiAgICBwYXJzZUNvbW1hbmQsXG4gICAgUGFyc2VyOiBQYXJzZXIkMSxcbiAgICBwcm9jZXNzQXJndixcbiAgICByZWJhc2UsXG4gICAgWUVycm9yLFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjanM7XG4iXSwibWFwcGluZ3MiOiJBQUFBLFlBQVk7O0FBRVosSUFBSUEsTUFBTSxHQUFHQyxPQUFPLENBQUMsUUFBUSxDQUFDO0FBRTlCLE1BQU1DLE1BQU0sU0FBU0MsS0FBSyxDQUFDO0VBQ3ZCQyxXQUFXQSxDQUFDQyxHQUFHLEVBQUU7SUFDYixLQUFLLENBQUNBLEdBQUcsSUFBSSxhQUFhLENBQUM7SUFDM0IsSUFBSSxDQUFDQyxJQUFJLEdBQUcsUUFBUTtJQUNwQkgsS0FBSyxDQUFDSSxpQkFBaUIsQ0FBQyxJQUFJLEVBQUVMLE1BQU0sQ0FBQztFQUN6QztBQUNKO0FBRUEsSUFBSU0sd0JBQXdCLEdBQUcsRUFBRTtBQUNqQyxJQUFJQyxJQUFJO0FBQ1IsU0FBU0MsWUFBWUEsQ0FBQ0MsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLFlBQVksRUFBRUMsS0FBSyxFQUFFO0VBQ3BETCxJQUFJLEdBQUdLLEtBQUs7RUFDWixJQUFJQyxhQUFhLEdBQUcsQ0FBQyxDQUFDO0VBQ3RCLElBQUlDLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsTUFBTSxFQUFFLFNBQVMsQ0FB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","map":{"version":3,"names":["assert","require","YError","Error","constructor","msg","name","captureStackTrace","previouslyVisitedConfigs","shim","applyExtends","config","cwd","mergeExtends","_shim","defaultConfig","Object","prototype","hasOwnProperty","call","extends","isPath","test","pathToDefault","resolve","_err","getPathToDefaultConfig","checkForCircularExtends","push","JSON","parse","readFileSync","path","dirname","mergeDeep","assign","cfgPath","indexOf","pathToExtend","config1","config2","target","isObject","obj","Array","isArray","key","keys","parseCommand","cmd","extraSpacesStrippedCommand","replace","splitCommand","split","bregex","firstCommand","shift","parsedCommand","demanded","optional","forEach","i","variadic","length","positionName","argsert","arg1","arg2","arg3","parseArgs","position","parsed","callerArguments","_length","args","slice","undefined","pop","totalCommands","arg","observedType","guessType","matchingTypes","filter","type","argumentTypeError","err","console","warn","stack","allowedTypes","join","isPromise","maybePromise","then","assertNotStrictEqual","actual","expected","message","notStrictEqual","assertSingleKey","strictEqual","objectKeys","object","objFilter","original","globalMiddlewareFactory","globalMiddleware","context","callback","applyBeforeValidation","arguments","apply","commandMiddlewareFactory","commandMiddleware","map","middleware","applyMiddleware","argv","yargs","middlewares","beforeValidation","beforeValidationError","reduce","acc","initialObj","Promise","all","middlewareObj","result","getProcessArgvBinIndex","isBundledElectronApp","isElectronApp","process","defaultApp","versions","electron","hideBin","getProcessArgvBin","processArgv","freeze","__proto__","whichModule","exported","files","cache","mod","exports","DEFAULT_MARKER","command","usage","validation","self","handlers","aliasMap","defaultCommand","addHandler","description","builder","handler","deprecated","aliases","isCommandAndAliases","isCommandHandlerDefinition","moduleName","concat","extractDesc","isCommandBuilderDefinition","alias","isDefault","parsedAliases","c","addDirectory","dir","req","callerFile","opts","recurse","extensions","parentVisit","visit","o","joined","filename","visited","requireDirectory","inspect","commandFromFilename","basename","extname","describe","desc","getCommands","getCommandHandlers","hasDefaultCommand","runCommand","commandIndex","commandHandler","currentContext","getContext","numFiles","parentCommands","commands","innerArgv","positionalMap","fullCommands","isCommandBuilderCallback","builderOutput","reset","innerYargs","isYargsInstance","shouldUpdateUsage","getUsageInstance","usageFromParentCommandsCommandHandler","_parseArgs","isCommandBuilderOptionDefinitions","option","_hasOutput","populatePositionals","_runValidation","error","_setHasOutput","populateDoubleDash","getOptions","configuration","_postProcess","handlerResult","handlerFinishCommand","getHandlerFinishCommand","cacheHelpMessage","value","catch","fail","clearCachedHelpMessage","splice","getUsageDisabled","getUsage","trim","pc","runDefaultBuilderOn","commandString","_","positionalCount","demand","populatePositional","maybe","a","postProcessPositionals","cmdToParseOptions","positional","String","parseOptions","options","default","array","unparsed","Parser","detailed","positionalKeys","cmdString","d","frozens","unfreeze","frozen","every","setBlocking","blocking","stdout","stderr","_stream","stream","_handle","isTTY","y18n","__","fails","failFn","f","failMessage","showHelpOnFail","showHelpOnFailFn","parseFunctionArgs","enabled","failureOutput","logger","_getLoggerInstance","getExitProcess","showHelp","exit","_hasParseCallback","usages","usageDisabled","getPositionalGroupName","examples","example","cmdArray","descriptions","keyOrKeys","k","getDescriptions","epilogs","epilog","wrapSet","wrap","cols","getWrap","windowWidth","deferY18nLookupPrefix","deferY18nLookup","str","help","cachedHelpMessage","normalizeAliases","base$0","customScriptName","$0","demandedOptions","getDemandedOptions","demandedCommands","getDemandedCommands","deprecatedOptions","getDeprecatedOptions","groups","getGroups","filterHiddenOptions","theWrap","ui","cliui","width","div","text","padding","u","getParserConfiguration","sort","b","localeCompare","span","maxWidth","hints","align","aliasKeys","newAliases","defaultGroup","addUngroupedKeys","isLongSwitch","sw","getText","displayedGroups","groupName","normalizedKeys","aliasKey","switches","boolean","sw1","sw2","shortSwitchesUsed","some","addIndentation","kswitch","lastIndexOf","substring","count","string","normalize","number","deprecatedExtra","extra","choices","stringifiedValues","defaultString","defaultDescription","Boolean","getIndentation","e","toString","table","modifier","values","v","Math","max","stringWidth","min","parseInt","demandOption","groupedKeys","toCheck","group","hiddenOptions","showHiddenOpt","level","emit","functionDescription","fn","decamelize","separator","sep","stringify","stdColumns","version","ver","showVersion","log","localLookup","isIndentedText","indent","indentation","completionShTemplate","completionZshTemplate","completion","completionKey","setParsed","zshShell","getEnv","getCompletion","done","completions","current","runCompletionFunction","completionFunction","isSyncCompletionFunction","list","nextTick","ii","y","match","usageCommand","commandName","descs","negable","includes","keyAndAliases","completeOptionKey","notInArgs","val","startsByTwoDashes","s","isShortOption","dashes","generateCompletionScript","script","registerFunction","levenshtein","matrix","j","charAt","specialKeys","__n","nonOptionCount","_s","minMsg","maxMsg","required","observed","requiredArguments","missing","customMsgs","customMsg","unknownArguments","isDefaultCommand","checkPositionals","commandKeys","getCommandInstance","unknown","_getParseContext","isValidAndSomeAliasIsNotNew","unknownCommands","limitedChoices","invalid","invalidKeys","checks","check","global","func","customChecks","implied","implies","getImplied","keyExists","num","Number","isNaN","implications","implyFail","origKey","origValue","conflicting","conflicts","getConflicting","conflictingFn","recommendCommands","potentialCommands","threshold","recommended","bestDistance","Infinity","candidate","shim$1","YargsWithShim","Yargs","processArgs","parentRequire","command$1","completion$1","output","preservedGroups","usage$1","validation$1","scriptName","default$0","x","rebase","execPath","resets","hasOutput","exitError","code","exitProcess","completionCommand","resetOptions","tmpOptions","local","configObjects","l","arrayOptions","objectOptions","envPrefix","strict","strictCommands","strictOptions","parseFn","parseContext","populateParserHintArray","requiresArg","narg","populateParserHintSingleValueDictionary","NaN","skipValidation","sanitizeKey","nargs","populateParserHintArrayDictionary","defaults","setKey","set","coerce","populateParserHintDictionary","singleKeyHandler","deleteFromParserHintObject","optionKey","hintKey","hint","exampleParams","commandDir","getCallerFile","demandCommand","deprecateOption","key1","key2","epilogue","onFinishCommand","_global","globals","g","pkgConf","rootPath","conf","pkgUp","pkgs","npath","startDir","mainFilename","pkgJsonPath","findUp","names","_noop","shortCircuit","_parseFn","tmpParsed","opt","deprecate","configParser","hidden","hide","supportedOpts","accept","fullCommand","pk","parseOption","existing","seen","env","prefix","getStrict","getStrictCommands","getStrictOptions","parserConfig","parserConfiguration","versionOpt","defaultVersionOpt","guessVersion","helpOpt","addHelpOpt","defaultHelpOpt","defaultShowHiddenOpt","addShowHiddenOpt","showHidden","showCompletionScript","_logger","locale","guessLocale","getLocale","detectLocale","setLocale","updateStrings","updateLocale","detect","getDetectLocale","recommend","getValidationInstance","terminalWidth","defineProperty","get","enumerable","_calledFromCommand","helpCmds","handlerKeys","requestCompletions","skipRecommendation","skipDefaultCommand","firstUnknownCommand","completionArgs","calledFromCommand","_copyDoubleDash","parsePositionalNumbers","_parsePositionalNumbers","looksLikeNumber","isSafeInteger","floor","parseFloat","runValidation","parseErrors","failedStrictCommands","base","relative","_a","_b","cjsPlatformShim","main","columns","directory","__dirname","updateFiles","minNodeVersion","YARGS_MIN_NODE_VERSION","major","Parser$1","Yargs$1","cjs","module"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\yargs@16.2.0\\node_modules\\yargs\\build\\","sources":["index.cjs"],"sourcesContent":["'use strict';\n\nvar assert = require('assert');\n\nclass YError extends Error {\n    constructor(msg) {\n        super(msg || 'yargs error');\n        this.name = 'YError';\n        Error.captureStackTrace(this, YError);\n    }\n}\n\nlet previouslyVisitedConfigs = [];\nlet shim;\nfunction applyExtends(config, cwd, mergeExtends, _shim) {\n    shim = _shim;\n    let defaultConfig = {};\n    if (Object.prototype.hasOwnProperty.call(config, 'extends')) {\n        if (typeof config.extends !== 'string')\n            return defaultConfig;\n        const isPath = /\\.json|\\..*rc$/.test(config.extends);\n        let pathToDefault = null;\n        if (!isPath) {\n            try {\n                pathToDefault = require.resolve(config.extends);\n            }\n            catch (_err) {\n                return config;\n            }\n        }\n        else {\n            pathToDefault = getPathToDefaultConfig(cwd, config.extends);\n        }\n        checkForCircularExtends(pathToDefault);\n        previouslyVisitedConfigs.push(pathToDefault);\n        defaultConfig = isPath\n            ? JSON.parse(shim.readFileSync(pathToDefault, 'utf8'))\n            : require(config.extends);\n        delete config.extends;\n        defaultConfig = applyExtends(defaultConfig, shim.path.dirname(pathToDefault), mergeExtends, shim);\n    }\n    previouslyVisitedConfigs = [];\n    return mergeExtends\n        ? mergeDeep(defaultConfig, config)\n        : Object.assign({}, defaultConfig, config);\n}\nfunction checkForCircularExtends(cfgPath) {\n    if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {\n        throw new YError(`Circular extended configurations: '${cfgPath}'.`);\n    }\n}\nfunction getPathToDefaultConfig(cwd, pathToExtend) {\n    return shim.path.resolve(cwd, pathToExtend);\n}\nfunction mergeDeep(config1, config2) {\n    const target = {};\n    function isObject(obj) {\n        return obj && typeof obj === 'object' && !Array.isArray(obj);\n    }\n    Object.assign(target, config1);\n    for (const key of Object.keys(config2)) {\n        if (isObject(config2[key]) && isObject(target[key])) {\n            target[key] = mergeDeep(config1[key], config2[key]);\n        }\n        else {\n            target[key] = config2[key];\n        }\n    }\n    return target;\n}\n\nfunction parseCommand(cmd) {\n    const extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ');\n    const splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/);\n    const bregex = /\\.*[\\][<>]/g;\n    const firstCommand = splitCommand.shift();\n    if (!firstCommand)\n        throw new Error(`No command found in: ${cmd}`);\n    const parsedCommand = {\n        cmd: firstCommand.replace(bregex, ''),\n        demanded: [],\n        optional: [],\n    };\n    splitCommand.forEach((cmd, i) => {\n        let variadic = false;\n        cmd = cmd.replace(/\\s/g, '');\n        if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1)\n            variadic = true;\n        if (/^\\[/.test(cmd)) {\n            parsedCommand.optional.push({\n                cmd: cmd.replace(bregex, '').split('|'),\n                variadic,\n            });\n        }\n        else {\n            parsedCommand.demanded.push({\n                cmd: cmd.replace(bregex, '').split('|'),\n                variadic,\n            });\n        }\n    });\n    return parsedCommand;\n}\n\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];\nfunction argsert(arg1, arg2, arg3) {\n    function parseArgs() {\n        return typeof arg1 === 'object'\n            ? [{ demanded: [], optional: [] }, arg1, arg2]\n            : [\n                parseCommand(`cmd ${arg1}`),\n                arg2,\n                arg3,\n            ];\n    }\n    try {\n        let position = 0;\n        const [parsed, callerArguments, _length] = parseArgs();\n        const args = [].slice.call(callerArguments);\n        while (args.length && args[args.length - 1] === undefined)\n            args.pop();\n        const length = _length || args.length;\n        if (length < parsed.demanded.length) {\n            throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);\n        }\n        const totalCommands = parsed.demanded.length + parsed.optional.length;\n        if (length > totalCommands) {\n            throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);\n        }\n        parsed.demanded.forEach(demanded => {\n            const arg = args.shift();\n            const observedType = guessType(arg);\n            const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*');\n            if (matchingTypes.length === 0)\n                argumentTypeError(observedType, demanded.cmd, position);\n            position += 1;\n        });\n        parsed.optional.forEach(optional => {\n            if (args.length === 0)\n                return;\n            const arg = args.shift();\n            const observedType = guessType(arg);\n            const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*');\n            if (matchingTypes.length === 0)\n                argumentTypeError(observedType, optional.cmd, position);\n            position += 1;\n        });\n    }\n    catch (err) {\n        console.warn(err.stack);\n    }\n}\nfunction guessType(arg) {\n    if (Array.isArray(arg)) {\n        return 'array';\n    }\n    else if (arg === null) {\n        return 'null';\n    }\n    return typeof arg;\n}\nfunction argumentTypeError(observedType, allowedTypes, position) {\n    throw new YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`);\n}\n\nfunction isPromise(maybePromise) {\n    return (!!maybePromise &&\n        !!maybePromise.then &&\n        typeof maybePromise.then === 'function');\n}\n\nfunction assertNotStrictEqual(actual, expected, shim, message) {\n    shim.assert.notStrictEqual(actual, expected, message);\n}\nfunction assertSingleKey(actual, shim) {\n    shim.assert.strictEqual(typeof actual, 'string');\n}\nfunction objectKeys(object) {\n    return Object.keys(object);\n}\n\nfunction objFilter(original = {}, filter = () => true) {\n    const obj = {};\n    objectKeys(original).forEach(key => {\n        if (filter(key, original[key])) {\n            obj[key] = original[key];\n        }\n    });\n    return obj;\n}\n\nfunction globalMiddlewareFactory(globalMiddleware, context) {\n    return function (callback, applyBeforeValidation = false) {\n        argsert('<array|function> [boolean]', [callback, applyBeforeValidation], arguments.length);\n        if (Array.isArray(callback)) {\n            for (let i = 0; i < callback.length; i++) {\n                if (typeof callback[i] !== 'function') {\n                    throw Error('middleware must be a function');\n                }\n                callback[i].applyBeforeValidation = applyBeforeValidation;\n            }\n            Array.prototype.push.apply(globalMiddleware, callback);\n        }\n        else if (typeof callback === 'function') {\n            callback.applyBeforeValidation = applyBeforeValidation;\n            globalMiddleware.push(callback);\n        }\n        return context;\n    };\n}\nfunction commandMiddlewareFactory(commandMiddleware) {\n    if (!commandMiddleware)\n        return [];\n    return commandMiddleware.map(middleware => {\n        middleware.applyBeforeValidation = false;\n        return middleware;\n    });\n}\nfunction applyMiddleware(argv, yargs, middlewares, beforeValidation) {\n    const beforeValidationError = new Error('middleware cannot return a promise when applyBeforeValidation is true');\n    return middlewares.reduce((acc, middleware) => {\n        if (middleware.applyBeforeValidation !== beforeValidation) {\n            return acc;\n        }\n        if (isPromise(acc)) {\n            return acc\n                .then(initialObj => Promise.all([\n                initialObj,\n                middleware(initialObj, yargs),\n            ]))\n                .then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));\n        }\n        else {\n            const result = middleware(acc, yargs);\n            if (beforeValidation && isPromise(result))\n                throw beforeValidationError;\n            return isPromise(result)\n                ? result.then(middlewareObj => Object.assign(acc, middlewareObj))\n                : Object.assign(acc, result);\n        }\n    }, argv);\n}\n\nfunction getProcessArgvBinIndex() {\n    if (isBundledElectronApp())\n        return 0;\n    return 1;\n}\nfunction isBundledElectronApp() {\n    return isElectronApp() && !process.defaultApp;\n}\nfunction isElectronApp() {\n    return !!process.versions.electron;\n}\nfunction hideBin(argv) {\n    return argv.slice(getProcessArgvBinIndex() + 1);\n}\nfunction getProcessArgvBin() {\n    return process.argv[getProcessArgvBinIndex()];\n}\n\nvar processArgv = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  hideBin: hideBin,\n  getProcessArgvBin: getProcessArgvBin\n});\n\nfunction whichModule(exported) {\n    if (typeof require === 'undefined')\n        return null;\n    for (let i = 0, files = Object.keys(require.cache), mod; i < files.length; i++) {\n        mod = require.cache[files[i]];\n        if (mod.exports === exported)\n            return mod;\n    }\n    return null;\n}\n\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/;\nfunction command(yargs, usage, validation, globalMiddleware = [], shim) {\n    const self = {};\n    let handlers = {};\n    let aliasMap = {};\n    let defaultCommand;\n    self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {\n        let aliases = [];\n        const middlewares = commandMiddlewareFactory(commandMiddleware);\n        handler = handler || (() => { });\n        if (Array.isArray(cmd)) {\n            if (isCommandAndAliases(cmd)) {\n                [cmd, ...aliases] = cmd;\n            }\n            else {\n                for (const command of cmd) {\n                    self.addHandler(command);\n                }\n            }\n        }\n        else if (isCommandHandlerDefinition(cmd)) {\n            let command = Array.isArray(cmd.command) || typeof cmd.command === 'string'\n                ? cmd.command\n                : moduleName(cmd);\n            if (cmd.aliases)\n                command = [].concat(command).concat(cmd.aliases);\n            self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);\n            return;\n        }\n        else if (isCommandBuilderDefinition(builder)) {\n            self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);\n            return;\n        }\n        if (typeof cmd === 'string') {\n            const parsedCommand = parseCommand(cmd);\n            aliases = aliases.map(alias => parseCommand(alias).cmd);\n            let isDefault = false;\n            const parsedAliases = [parsedCommand.cmd].concat(aliases).filter(c => {\n                if (DEFAULT_MARKER.test(c)) {\n                    isDefault = true;\n                    return false;\n                }\n                return true;\n            });\n            if (parsedAliases.length === 0 && isDefault)\n                parsedAliases.push('$0');\n            if (isDefault) {\n                parsedCommand.cmd = parsedAliases[0];\n                aliases = parsedAliases.slice(1);\n                cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);\n            }\n            aliases.forEach(alias => {\n                aliasMap[alias] = parsedCommand.cmd;\n            });\n            if (description !== false) {\n                usage.command(cmd, description, isDefault, aliases, deprecated);\n            }\n            handlers[parsedCommand.cmd] = {\n                original: cmd,\n                description,\n                handler,\n                builder: builder || {},\n                middlewares,\n                deprecated,\n                demanded: parsedCommand.demanded,\n                optional: parsedCommand.optional,\n            };\n            if (isDefault)\n                defaultCommand = handlers[parsedCommand.cmd];\n        }\n    };\n    self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {\n        opts = opts || {};\n        if (typeof opts.recurse !== 'boolean')\n            opts.recurse = false;\n        if (!Array.isArray(opts.extensions))\n            opts.extensions = ['js'];\n        const parentVisit = typeof opts.visit === 'function' ? opts.visit : (o) => o;\n        opts.visit = function visit(obj, joined, filename) {\n            const visited = parentVisit(obj, joined, filename);\n            if (visited) {\n                if (~context.files.indexOf(joined))\n                    return visited;\n                context.files.push(joined);\n                self.addHandler(visited);\n            }\n            return visited;\n        };\n        shim.requireDirectory({ require: req, filename: callerFile }, dir, opts);\n    };\n    function moduleName(obj) {\n        const mod = whichModule(obj);\n        if (!mod)\n            throw new Error(`No command name given for module: ${shim.inspect(obj)}`);\n        return commandFromFilename(mod.filename);\n    }\n    function commandFromFilename(filename) {\n        return shim.path.basename(filename, shim.path.extname(filename));\n    }\n    function extractDesc({ describe, description, desc, }) {\n        for (const test of [describe, description, desc]) {\n            if (typeof test === 'string' || test === false)\n                return test;\n            assertNotStrictEqual(test, true, shim);\n        }\n        return false;\n    }\n    self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));\n    self.getCommandHandlers = () => handlers;\n    self.hasDefaultCommand = () => !!defaultCommand;\n    self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {\n        let aliases = parsed.aliases;\n        const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;\n        const currentContext = yargs.getContext();\n        let numFiles = currentContext.files.length;\n        const parentCommands = currentContext.commands.slice();\n        let innerArgv = parsed.argv;\n        let positionalMap = {};\n        if (command) {\n            currentContext.commands.push(command);\n            currentContext.fullCommands.push(commandHandler.original);\n        }\n        const builder = commandHandler.builder;\n        if (isCommandBuilderCallback(builder)) {\n            const builderOutput = builder(yargs.reset(parsed.aliases));\n            const innerYargs = isYargsInstance(builderOutput) ? builderOutput : yargs;\n            if (shouldUpdateUsage(innerYargs)) {\n                innerYargs\n                    .getUsageInstance()\n                    .usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n            }\n            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n            aliases = innerYargs.parsed.aliases;\n        }\n        else if (isCommandBuilderOptionDefinitions(builder)) {\n            const innerYargs = yargs.reset(parsed.aliases);\n            if (shouldUpdateUsage(innerYargs)) {\n                innerYargs\n                    .getUsageInstance()\n                    .usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n            }\n            Object.keys(commandHandler.builder).forEach(key => {\n                innerYargs.option(key, builder[key]);\n            });\n            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n            aliases = innerYargs.parsed.aliases;\n        }\n        if (!yargs._hasOutput()) {\n            positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);\n        }\n        const middlewares = globalMiddleware\n            .slice(0)\n            .concat(commandHandler.middlewares);\n        applyMiddleware(innerArgv, yargs, middlewares, true);\n        if (!yargs._hasOutput()) {\n            yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error, !command);\n        }\n        if (commandHandler.handler && !yargs._hasOutput()) {\n            yargs._setHasOutput();\n            const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];\n            yargs._postProcess(innerArgv, populateDoubleDash);\n            innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);\n            let handlerResult;\n            if (isPromise(innerArgv)) {\n                handlerResult = innerArgv.then(argv => commandHandler.handler(argv));\n            }\n            else {\n                handlerResult = commandHandler.handler(innerArgv);\n            }\n            const handlerFinishCommand = yargs.getHandlerFinishCommand();\n            if (isPromise(handlerResult)) {\n                yargs.getUsageInstance().cacheHelpMessage();\n                handlerResult\n                    .then(value => {\n                    if (handlerFinishCommand) {\n                        handlerFinishCommand(value);\n                    }\n                })\n                    .catch(error => {\n                    try {\n                        yargs.getUsageInstance().fail(null, error);\n                    }\n                    catch (err) {\n                    }\n                })\n                    .then(() => {\n                    yargs.getUsageInstance().clearCachedHelpMessage();\n                });\n            }\n            else {\n                if (handlerFinishCommand) {\n                    handlerFinishCommand(handlerResult);\n                }\n            }\n        }\n        if (command) {\n            currentContext.commands.pop();\n            currentContext.fullCommands.pop();\n        }\n        numFiles = currentContext.files.length - numFiles;\n        if (numFiles > 0)\n            currentContext.files.splice(numFiles * -1, numFiles);\n        return innerArgv;\n    };\n    function shouldUpdateUsage(yargs) {\n        return (!yargs.getUsageInstance().getUsageDisabled() &&\n            yargs.getUsageInstance().getUsage().length === 0);\n    }\n    function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {\n        const c = DEFAULT_MARKER.test(commandHandler.original)\n            ? commandHandler.original.replace(DEFAULT_MARKER, '').trim()\n            : commandHandler.original;\n        const pc = parentCommands.filter(c => {\n            return !DEFAULT_MARKER.test(c);\n        });\n        pc.push(c);\n        return `$0 ${pc.join(' ')}`;\n    }\n    self.runDefaultBuilderOn = function (yargs) {\n        assertNotStrictEqual(defaultCommand, undefined, shim);\n        if (shouldUpdateUsage(yargs)) {\n            const commandString = DEFAULT_MARKER.test(defaultCommand.original)\n                ? defaultCommand.original\n                : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ');\n            yargs.getUsageInstance().usage(commandString, defaultCommand.description);\n        }\n        const builder = defaultCommand.builder;\n        if (isCommandBuilderCallback(builder)) {\n            builder(yargs);\n        }\n        else if (!isCommandBuilderDefinition(builder)) {\n            Object.keys(builder).forEach(key => {\n                yargs.option(key, builder[key]);\n            });\n        }\n    };\n    function populatePositionals(commandHandler, argv, context) {\n        argv._ = argv._.slice(context.commands.length);\n        const demanded = commandHandler.demanded.slice(0);\n        const optional = commandHandler.optional.slice(0);\n        const positionalMap = {};\n        validation.positionalCount(demanded.length, argv._.length);\n        while (demanded.length) {\n            const demand = demanded.shift();\n            populatePositional(demand, argv, positionalMap);\n        }\n        while (optional.length) {\n            const maybe = optional.shift();\n            populatePositional(maybe, argv, positionalMap);\n        }\n        argv._ = context.commands.concat(argv._.map(a => '' + a));\n        postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));\n        return positionalMap;\n    }\n    function populatePositional(positional, argv, positionalMap) {\n        const cmd = positional.cmd[0];\n        if (positional.variadic) {\n            positionalMap[cmd] = argv._.splice(0).map(String);\n        }\n        else {\n            if (argv._.length)\n                positionalMap[cmd] = [String(argv._.shift())];\n        }\n    }\n    function postProcessPositionals(argv, positionalMap, parseOptions) {\n        const options = Object.assign({}, yargs.getOptions());\n        options.default = Object.assign(parseOptions.default, options.default);\n        for (const key of Object.keys(parseOptions.alias)) {\n            options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);\n        }\n        options.array = options.array.concat(parseOptions.array);\n        options.config = {};\n        const unparsed = [];\n        Object.keys(positionalMap).forEach(key => {\n            positionalMap[key].map(value => {\n                if (options.configuration['unknown-options-as-args'])\n                    options.key[key] = true;\n                unparsed.push(`--${key}`);\n                unparsed.push(value);\n            });\n        });\n        if (!unparsed.length)\n            return;\n        const config = Object.assign({}, options.configuration, {\n            'populate--': true,\n        });\n        const parsed = shim.Parser.detailed(unparsed, Object.assign({}, options, {\n            configuration: config,\n        }));\n        if (parsed.error) {\n            yargs.getUsageInstance().fail(parsed.error.message, parsed.error);\n        }\n        else {\n            const positionalKeys = Object.keys(positionalMap);\n            Object.keys(positionalMap).forEach(key => {\n                positionalKeys.push(...parsed.aliases[key]);\n            });\n            Object.keys(parsed.argv).forEach(key => {\n                if (positionalKeys.indexOf(key) !== -1) {\n                    if (!positionalMap[key])\n                        positionalMap[key] = parsed.argv[key];\n                    argv[key] = parsed.argv[key];\n                }\n            });\n        }\n    }\n    self.cmdToParseOptions = function (cmdString) {\n        const parseOptions = {\n            array: [],\n            default: {},\n            alias: {},\n            demand: {},\n        };\n        const parsed = parseCommand(cmdString);\n        parsed.demanded.forEach(d => {\n            const [cmd, ...aliases] = d.cmd;\n            if (d.variadic) {\n                parseOptions.array.push(cmd);\n                parseOptions.default[cmd] = [];\n            }\n            parseOptions.alias[cmd] = aliases;\n            parseOptions.demand[cmd] = true;\n        });\n        parsed.optional.forEach(o => {\n            const [cmd, ...aliases] = o.cmd;\n            if (o.variadic) {\n                parseOptions.array.push(cmd);\n                parseOptions.default[cmd] = [];\n            }\n            parseOptions.alias[cmd] = aliases;\n        });\n        return parseOptions;\n    };\n    self.reset = () => {\n        handlers = {};\n        aliasMap = {};\n        defaultCommand = undefined;\n        return self;\n    };\n    const frozens = [];\n    self.freeze = () => {\n        frozens.push({\n            handlers,\n            aliasMap,\n            defaultCommand,\n        });\n    };\n    self.unfreeze = () => {\n        const frozen = frozens.pop();\n        assertNotStrictEqual(frozen, undefined, shim);\n        ({ handlers, aliasMap, defaultCommand } = frozen);\n    };\n    return self;\n}\nfunction isCommandBuilderDefinition(builder) {\n    return (typeof builder === 'object' &&\n        !!builder.builder &&\n        typeof builder.handler === 'function');\n}\nfunction isCommandAndAliases(cmd) {\n    if (cmd.every(c => typeof c === 'string')) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction isCommandBuilderCallback(builder) {\n    return typeof builder === 'function';\n}\nfunction isCommandBuilderOptionDefinitions(builder) {\n    return typeof builder === 'object';\n}\nfunction isCommandHandlerDefinition(cmd) {\n    return typeof cmd === 'object' && !Array.isArray(cmd);\n}\n\nfunction setBlocking(blocking) {\n    if (typeof process === 'undefined')\n        return;\n    [process.stdout, process.stderr].forEach(_stream => {\n        const stream = _stream;\n        if (stream._handle &&\n            stream.isTTY &&\n            typeof stream._handle.setBlocking === 'function') {\n            stream._handle.setBlocking(blocking);\n        }\n    });\n}\n\nfunction usage(yargs, y18n, shim) {\n    const __ = y18n.__;\n    const self = {};\n    const fails = [];\n    self.failFn = function failFn(f) {\n        fails.push(f);\n    };\n    let failMessage = null;\n    let showHelpOnFail = true;\n    self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {\n        function parseFunctionArgs() {\n            return typeof arg1 === 'string' ? [true, arg1] : [arg1, arg2];\n        }\n        const [enabled, message] = parseFunctionArgs();\n        failMessage = message;\n        showHelpOnFail = enabled;\n        return self;\n    };\n    let failureOutput = false;\n    self.fail = function fail(msg, err) {\n        const logger = yargs._getLoggerInstance();\n        if (fails.length) {\n            for (let i = fails.length - 1; i >= 0; --i) {\n                fails[i](msg, err, self);\n            }\n        }\n        else {\n            if (yargs.getExitProcess())\n                setBlocking(true);\n            if (!failureOutput) {\n                failureOutput = true;\n                if (showHelpOnFail) {\n                    yargs.showHelp('error');\n                    logger.error();\n                }\n                if (msg || err)\n                    logger.error(msg || err);\n                if (failMessage) {\n                    if (msg || err)\n                        logger.error('');\n                    logger.error(failMessage);\n                }\n            }\n            err = err || new YError(msg);\n            if (yargs.getExitProcess()) {\n                return yargs.exit(1);\n            }\n            else if (yargs._hasParseCallback()) {\n                return yargs.exit(1, err);\n            }\n            else {\n                throw err;\n            }\n        }\n    };\n    let usages = [];\n    let usageDisabled = false;\n    self.usage = (msg, description) => {\n        if (msg === null) {\n            usageDisabled = true;\n            usages = [];\n            return self;\n        }\n        usageDisabled = false;\n        usages.push([msg, description || '']);\n        return self;\n    };\n    self.getUsage = () => {\n        return usages;\n    };\n    self.getUsageDisabled = () => {\n        return usageDisabled;\n    };\n    self.getPositionalGroupName = () => {\n        return __('Positionals:');\n    };\n    let examples = [];\n    self.example = (cmd, description) => {\n        examples.push([cmd, description || '']);\n    };\n    let commands = [];\n    self.command = function command(cmd, description, isDefault, aliases, deprecated = false) {\n        if (isDefault) {\n            commands = commands.map(cmdArray => {\n                cmdArray[2] = false;\n                return cmdArray;\n            });\n        }\n        commands.push([cmd, description || '', isDefault, aliases, deprecated]);\n    };\n    self.getCommands = () => commands;\n    let descriptions = {};\n    self.describe = function describe(keyOrKeys, desc) {\n        if (Array.isArray(keyOrKeys)) {\n            keyOrKeys.forEach(k => {\n                self.describe(k, desc);\n            });\n        }\n        else if (typeof keyOrKeys === 'object') {\n            Object.keys(keyOrKeys).forEach(k => {\n                self.describe(k, keyOrKeys[k]);\n            });\n        }\n        else {\n            descriptions[keyOrKeys] = desc;\n        }\n    };\n    self.getDescriptions = () => descriptions;\n    let epilogs = [];\n    self.epilog = msg => {\n        epilogs.push(msg);\n    };\n    let wrapSet = false;\n    let wrap;\n    self.wrap = cols => {\n        wrapSet = true;\n        wrap = cols;\n    };\n    function getWrap() {\n        if (!wrapSet) {\n            wrap = windowWidth();\n            wrapSet = true;\n        }\n        return wrap;\n    }\n    const deferY18nLookupPrefix = '__yargsString__:';\n    self.deferY18nLookup = str => deferY18nLookupPrefix + str;\n    self.help = function help() {\n        if (cachedHelpMessage)\n            return cachedHelpMessage;\n        normalizeAliases();\n        const base$0 = yargs.customScriptName\n            ? yargs.$0\n            : shim.path.basename(yargs.$0);\n        const demandedOptions = yargs.getDemandedOptions();\n        const demandedCommands = yargs.getDemandedCommands();\n        const deprecatedOptions = yargs.getDeprecatedOptions();\n        const groups = yargs.getGroups();\n        const options = yargs.getOptions();\n        let keys = [];\n        keys = keys.concat(Object.keys(descriptions));\n        keys = keys.concat(Object.keys(demandedOptions));\n        keys = keys.concat(Object.keys(demandedCommands));\n        keys = keys.concat(Object.keys(options.default));\n        keys = keys.filter(filterHiddenOptions);\n        keys = Object.keys(keys.reduce((acc, key) => {\n            if (key !== '_')\n                acc[key] = true;\n            return acc;\n        }, {}));\n        const theWrap = getWrap();\n        const ui = shim.cliui({\n            width: theWrap,\n            wrap: !!theWrap,\n        });\n        if (!usageDisabled) {\n            if (usages.length) {\n                usages.forEach(usage => {\n                    ui.div(`${usage[0].replace(/\\$0/g, base$0)}`);\n                    if (usage[1]) {\n                        ui.div({ text: `${usage[1]}`, padding: [1, 0, 0, 0] });\n                    }\n                });\n                ui.div();\n            }\n            else if (commands.length) {\n                let u = null;\n                if (demandedCommands._) {\n                    u = `${base$0} <${__('command')}>\\n`;\n                }\n                else {\n                    u = `${base$0} [${__('command')}]\\n`;\n                }\n                ui.div(`${u}`);\n            }\n        }\n        if (commands.length) {\n            ui.div(__('Commands:'));\n            const context = yargs.getContext();\n            const parentCommands = context.commands.length\n                ? `${context.commands.join(' ')} `\n                : '';\n            if (yargs.getParserConfiguration()['sort-commands'] === true) {\n                commands = commands.sort((a, b) => a[0].localeCompare(b[0]));\n            }\n            commands.forEach(command => {\n                const commandString = `${base$0} ${parentCommands}${command[0].replace(/^\\$0 ?/, '')}`;\n                ui.span({\n                    text: commandString,\n                    padding: [0, 2, 0, 2],\n                    width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4,\n                }, { text: command[1] });\n                const hints = [];\n                if (command[2])\n                    hints.push(`[${__('default')}]`);\n                if (command[3] && command[3].length) {\n                    hints.push(`[${__('aliases:')} ${command[3].join(', ')}]`);\n                }\n                if (command[4]) {\n                    if (typeof command[4] === 'string') {\n                        hints.push(`[${__('deprecated: %s', command[4])}]`);\n                    }\n                    else {\n                        hints.push(`[${__('deprecated')}]`);\n                    }\n                }\n                if (hints.length) {\n                    ui.div({\n                        text: hints.join(' '),\n                        padding: [0, 0, 0, 2],\n                        align: 'right',\n                    });\n                }\n                else {\n                    ui.div();\n                }\n            });\n            ui.div();\n        }\n        const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);\n        keys = keys.filter(key => !yargs.parsed.newAliases[key] &&\n            aliasKeys.every(alias => (options.alias[alias] || []).indexOf(key) === -1));\n        const defaultGroup = __('Options:');\n        if (!groups[defaultGroup])\n            groups[defaultGroup] = [];\n        addUngroupedKeys(keys, options.alias, groups, defaultGroup);\n        const isLongSwitch = (sw) => /^--/.test(getText(sw));\n        const displayedGroups = Object.keys(groups)\n            .filter(groupName => groups[groupName].length > 0)\n            .map(groupName => {\n            const normalizedKeys = groups[groupName]\n                .filter(filterHiddenOptions)\n                .map(key => {\n                if (~aliasKeys.indexOf(key))\n                    return key;\n                for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {\n                    if (~(options.alias[aliasKey] || []).indexOf(key))\n                        return aliasKey;\n                }\n                return key;\n            });\n            return { groupName, normalizedKeys };\n        })\n            .filter(({ normalizedKeys }) => normalizedKeys.length > 0)\n            .map(({ groupName, normalizedKeys }) => {\n            const switches = normalizedKeys.reduce((acc, key) => {\n                acc[key] = [key]\n                    .concat(options.alias[key] || [])\n                    .map(sw => {\n                    if (groupName === self.getPositionalGroupName())\n                        return sw;\n                    else {\n                        return ((/^[0-9]$/.test(sw)\n                            ? ~options.boolean.indexOf(key)\n                                ? '-'\n                                : '--'\n                            : sw.length > 1\n                                ? '--'\n                                : '-') + sw);\n                    }\n                })\n                    .sort((sw1, sw2) => isLongSwitch(sw1) === isLongSwitch(sw2)\n                    ? 0\n                    : isLongSwitch(sw1)\n                        ? 1\n                        : -1)\n                    .join(', ');\n                return acc;\n            }, {});\n            return { groupName, normalizedKeys, switches };\n        });\n        const shortSwitchesUsed = displayedGroups\n            .filter(({ groupName }) => groupName !== self.getPositionalGroupName())\n            .some(({ normalizedKeys, switches }) => !normalizedKeys.every(key => isLongSwitch(switches[key])));\n        if (shortSwitchesUsed) {\n            displayedGroups\n                .filter(({ groupName }) => groupName !== self.getPositionalGroupName())\n                .forEach(({ normalizedKeys, switches }) => {\n                normalizedKeys.forEach(key => {\n                    if (isLongSwitch(switches[key])) {\n                        switches[key] = addIndentation(switches[key], '-x, '.length);\n                    }\n                });\n            });\n        }\n        displayedGroups.forEach(({ groupName, normalizedKeys, switches }) => {\n            ui.div(groupName);\n            normalizedKeys.forEach(key => {\n                const kswitch = switches[key];\n                let desc = descriptions[key] || '';\n                let type = null;\n                if (~desc.lastIndexOf(deferY18nLookupPrefix))\n                    desc = __(desc.substring(deferY18nLookupPrefix.length));\n                if (~options.boolean.indexOf(key))\n                    type = `[${__('boolean')}]`;\n                if (~options.count.indexOf(key))\n                    type = `[${__('count')}]`;\n                if (~options.string.indexOf(key))\n                    type = `[${__('string')}]`;\n                if (~options.normalize.indexOf(key))\n                    type = `[${__('string')}]`;\n                if (~options.array.indexOf(key))\n                    type = `[${__('array')}]`;\n                if (~options.number.indexOf(key))\n                    type = `[${__('number')}]`;\n                const deprecatedExtra = (deprecated) => typeof deprecated === 'string'\n                    ? `[${__('deprecated: %s', deprecated)}]`\n                    : `[${__('deprecated')}]`;\n                const extra = [\n                    key in deprecatedOptions\n                        ? deprecatedExtra(deprecatedOptions[key])\n                        : null,\n                    type,\n                    key in demandedOptions ? `[${__('required')}]` : null,\n                    options.choices && options.choices[key]\n                        ? `[${__('choices:')} ${self.stringifiedValues(options.choices[key])}]`\n                        : null,\n                    defaultString(options.default[key], options.defaultDescription[key]),\n                ]\n                    .filter(Boolean)\n                    .join(' ');\n                ui.span({\n                    text: getText(kswitch),\n                    padding: [0, 2, 0, 2 + getIndentation(kswitch)],\n                    width: maxWidth(switches, theWrap) + 4,\n                }, desc);\n                if (extra)\n                    ui.div({ text: extra, padding: [0, 0, 0, 2], align: 'right' });\n                else\n                    ui.div();\n            });\n            ui.div();\n        });\n        if (examples.length) {\n            ui.div(__('Examples:'));\n            examples.forEach(example => {\n                example[0] = example[0].replace(/\\$0/g, base$0);\n            });\n            examples.forEach(example => {\n                if (example[1] === '') {\n                    ui.div({\n                        text: example[0],\n                        padding: [0, 2, 0, 2],\n                    });\n                }\n                else {\n                    ui.div({\n                        text: example[0],\n                        padding: [0, 2, 0, 2],\n                        width: maxWidth(examples, theWrap) + 4,\n                    }, {\n                        text: example[1],\n                    });\n                }\n            });\n            ui.div();\n        }\n        if (epilogs.length > 0) {\n            const e = epilogs\n                .map(epilog => epilog.replace(/\\$0/g, base$0))\n                .join('\\n');\n            ui.div(`${e}\\n`);\n        }\n        return ui.toString().replace(/\\s*$/, '');\n    };\n    function maxWidth(table, theWrap, modifier) {\n        let width = 0;\n        if (!Array.isArray(table)) {\n            table = Object.values(table).map(v => [v]);\n        }\n        table.forEach(v => {\n            width = Math.max(shim.stringWidth(modifier ? `${modifier} ${getText(v[0])}` : getText(v[0])) + getIndentation(v[0]), width);\n        });\n        if (theWrap)\n            width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));\n        return width;\n    }\n    function normalizeAliases() {\n        const demandedOptions = yargs.getDemandedOptions();\n        const options = yargs.getOptions();\n        (Object.keys(options.alias) || []).forEach(key => {\n            options.alias[key].forEach(alias => {\n                if (descriptions[alias])\n                    self.describe(key, descriptions[alias]);\n                if (alias in demandedOptions)\n                    yargs.demandOption(key, demandedOptions[alias]);\n                if (~options.boolean.indexOf(alias))\n                    yargs.boolean(key);\n                if (~options.count.indexOf(alias))\n                    yargs.count(key);\n                if (~options.string.indexOf(alias))\n                    yargs.string(key);\n                if (~options.normalize.indexOf(alias))\n                    yargs.normalize(key);\n                if (~options.array.indexOf(alias))\n                    yargs.array(key);\n                if (~options.number.indexOf(alias))\n                    yargs.number(key);\n            });\n        });\n    }\n    let cachedHelpMessage;\n    self.cacheHelpMessage = function () {\n        cachedHelpMessage = this.help();\n    };\n    self.clearCachedHelpMessage = function () {\n        cachedHelpMessage = undefined;\n    };\n    function addUngroupedKeys(keys, aliases, groups, defaultGroup) {\n        let groupedKeys = [];\n        let toCheck = null;\n        Object.keys(groups).forEach(group => {\n            groupedKeys = groupedKeys.concat(groups[group]);\n        });\n        keys.forEach(key => {\n            toCheck = [key].concat(aliases[key]);\n            if (!toCheck.some(k => groupedKeys.indexOf(k) !== -1)) {\n                groups[defaultGroup].push(key);\n            }\n        });\n        return groupedKeys;\n    }\n    function filterHiddenOptions(key) {\n        return (yargs.getOptions().hiddenOptions.indexOf(key) < 0 ||\n            yargs.parsed.argv[yargs.getOptions().showHiddenOpt]);\n    }\n    self.showHelp = (level) => {\n        const logger = yargs._getLoggerInstance();\n        if (!level)\n            level = 'error';\n        const emit = typeof level === 'function' ? level : logger[level];\n        emit(self.help());\n    };\n    self.functionDescription = fn => {\n        const description = fn.name\n            ? shim.Parser.decamelize(fn.name, '-')\n            : __('generated-value');\n        return ['(', description, ')'].join('');\n    };\n    self.stringifiedValues = function stringifiedValues(values, separator) {\n        let string = '';\n        const sep = separator || ', ';\n        const array = [].concat(values);\n        if (!values || !array.length)\n            return string;\n        array.forEach(value => {\n            if (string.length)\n                string += sep;\n            string += JSON.stringify(value);\n        });\n        return string;\n    };\n    function defaultString(value, defaultDescription) {\n        let string = `[${__('default:')} `;\n        if (value === undefined && !defaultDescription)\n            return null;\n        if (defaultDescription) {\n            string += defaultDescription;\n        }\n        else {\n            switch (typeof value) {\n                case 'string':\n                    string += `\"${value}\"`;\n                    break;\n                case 'object':\n                    string += JSON.stringify(value);\n                    break;\n                default:\n                    string += value;\n            }\n        }\n        return `${string}]`;\n    }\n    function windowWidth() {\n        const maxWidth = 80;\n        if (shim.process.stdColumns) {\n            return Math.min(maxWidth, shim.process.stdColumns);\n        }\n        else {\n            return maxWidth;\n        }\n    }\n    let version = null;\n    self.version = ver => {\n        version = ver;\n    };\n    self.showVersion = () => {\n        const logger = yargs._getLoggerInstance();\n        logger.log(version);\n    };\n    self.reset = function reset(localLookup) {\n        failMessage = null;\n        failureOutput = false;\n        usages = [];\n        usageDisabled = false;\n        epilogs = [];\n        examples = [];\n        commands = [];\n        descriptions = objFilter(descriptions, k => !localLookup[k]);\n        return self;\n    };\n    const frozens = [];\n    self.freeze = function freeze() {\n        frozens.push({\n            failMessage,\n            failureOutput,\n            usages,\n            usageDisabled,\n            epilogs,\n            examples,\n            commands,\n            descriptions,\n        });\n    };\n    self.unfreeze = function unfreeze() {\n        const frozen = frozens.pop();\n        assertNotStrictEqual(frozen, undefined, shim);\n        ({\n            failMessage,\n            failureOutput,\n            usages,\n            usageDisabled,\n            epilogs,\n            examples,\n            commands,\n            descriptions,\n        } = frozen);\n    };\n    return self;\n}\nfunction isIndentedText(text) {\n    return typeof text === 'object';\n}\nfunction addIndentation(text, indent) {\n    return isIndentedText(text)\n        ? { text: text.text, indentation: text.indentation + indent }\n        : { text, indentation: indent };\n}\nfunction getIndentation(text) {\n    return isIndentedText(text) ? text.indentation : 0;\n}\nfunction getText(text) {\n    return isIndentedText(text) ? text.text : text;\n}\n\nconst completionShTemplate = `###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc\n#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.\n#\n_yargs_completions()\n{\n    local cur_word args type_list\n\n    cur_word=\"\\${COMP_WORDS[COMP_CWORD]}\"\n    args=(\"\\${COMP_WORDS[@]}\")\n\n    # ask yargs to generate completions.\n    type_list=$({{app_path}} --get-yargs-completions \"\\${args[@]}\")\n\n    COMPREPLY=( $(compgen -W \"\\${type_list}\" -- \\${cur_word}) )\n\n    # if no match was found, fall back to filename completion\n    if [ \\${#COMPREPLY[@]} -eq 0 ]; then\n      COMPREPLY=()\n    fi\n\n    return 0\n}\ncomplete -o default -F _yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n`;\nconst completionZshTemplate = `###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc\n#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.\n#\n_{{app_name}}_yargs_completions()\n{\n  local reply\n  local si=$IFS\n  IFS=$'\\n' reply=($(COMP_CWORD=\"$((CURRENT-1))\" COMP_LINE=\"$BUFFER\" COMP_POINT=\"$CURSOR\" {{app_path}} --get-yargs-completions \"\\${words[@]}\"))\n  IFS=$si\n  _describe 'values' reply\n}\ncompdef _{{app_name}}_yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n`;\n\nfunction completion(yargs, usage, command, shim) {\n    const self = {\n        completionKey: 'get-yargs-completions',\n    };\n    let aliases;\n    self.setParsed = function setParsed(parsed) {\n        aliases = parsed.aliases;\n    };\n    const zshShell = (shim.getEnv('SHELL') && shim.getEnv('SHELL').indexOf('zsh') !== -1) ||\n        (shim.getEnv('ZSH_NAME') && shim.getEnv('ZSH_NAME').indexOf('zsh') !== -1);\n    self.getCompletion = function getCompletion(args, done) {\n        const completions = [];\n        const current = args.length ? args[args.length - 1] : '';\n        const argv = yargs.parse(args, true);\n        const parentCommands = yargs.getContext().commands;\n        function runCompletionFunction(argv) {\n            assertNotStrictEqual(completionFunction, null, shim);\n            if (isSyncCompletionFunction(completionFunction)) {\n                const result = completionFunction(current, argv);\n                if (isPromise(result)) {\n                    return result\n                        .then(list => {\n                        shim.process.nextTick(() => {\n                            done(list);\n                        });\n                    })\n                        .catch(err => {\n                        shim.process.nextTick(() => {\n                            throw err;\n                        });\n                    });\n                }\n                return done(result);\n            }\n            else {\n                return completionFunction(current, argv, completions => {\n                    done(completions);\n                });\n            }\n        }\n        if (completionFunction) {\n            return isPromise(argv)\n                ? argv.then(runCompletionFunction)\n                : runCompletionFunction(argv);\n        }\n        const handlers = command.getCommandHandlers();\n        for (let i = 0, ii = args.length; i < ii; ++i) {\n            if (handlers[args[i]] && handlers[args[i]].builder) {\n                const builder = handlers[args[i]].builder;\n                if (isCommandBuilderCallback(builder)) {\n                    const y = yargs.reset();\n                    builder(y);\n                    return y.argv;\n                }\n            }\n        }\n        if (!current.match(/^-/) &&\n            parentCommands[parentCommands.length - 1] !== current) {\n            usage.getCommands().forEach(usageCommand => {\n                const commandName = parseCommand(usageCommand[0]).cmd;\n                if (args.indexOf(commandName) === -1) {\n                    if (!zshShell) {\n                        completions.push(commandName);\n                    }\n                    else {\n                        const desc = usageCommand[1] || '';\n                        completions.push(commandName.replace(/:/g, '\\\\:') + ':' + desc);\n                    }\n                }\n            });\n        }\n        if (current.match(/^-/) || (current === '' && completions.length === 0)) {\n            const descs = usage.getDescriptions();\n            const options = yargs.getOptions();\n            Object.keys(options.key).forEach(key => {\n                const negable = !!options.configuration['boolean-negation'] &&\n                    options.boolean.includes(key);\n                let keyAndAliases = [key].concat(aliases[key] || []);\n                if (negable)\n                    keyAndAliases = keyAndAliases.concat(keyAndAliases.map(key => `no-${key}`));\n                function completeOptionKey(key) {\n                    const notInArgs = keyAndAliases.every(val => args.indexOf(`--${val}`) === -1);\n                    if (notInArgs) {\n                        const startsByTwoDashes = (s) => /^--/.test(s);\n                        const isShortOption = (s) => /^[^0-9]$/.test(s);\n                        const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';\n                        if (!zshShell) {\n                            completions.push(dashes + key);\n                        }\n                        else {\n                            const desc = descs[key] || '';\n                            completions.push(dashes +\n                                `${key.replace(/:/g, '\\\\:')}:${desc.replace('__yargsString__:', '')}`);\n                        }\n                    }\n                }\n                completeOptionKey(key);\n                if (negable && !!options.default[key])\n                    completeOptionKey(`no-${key}`);\n            });\n        }\n        done(completions);\n    };\n    self.generateCompletionScript = function generateCompletionScript($0, cmd) {\n        let script = zshShell\n            ? completionZshTemplate\n            : completionShTemplate;\n        const name = shim.path.basename($0);\n        if ($0.match(/\\.js$/))\n            $0 = `./${$0}`;\n        script = script.replace(/{{app_name}}/g, name);\n        script = script.replace(/{{completion_command}}/g, cmd);\n        return script.replace(/{{app_path}}/g, $0);\n    };\n    let completionFunction = null;\n    self.registerFunction = fn => {\n        completionFunction = fn;\n    };\n    return self;\n}\nfunction isSyncCompletionFunction(completionFunction) {\n    return completionFunction.length < 3;\n}\n\nfunction levenshtein(a, b) {\n    if (a.length === 0)\n        return b.length;\n    if (b.length === 0)\n        return a.length;\n    const matrix = [];\n    let i;\n    for (i = 0; i <= b.length; i++) {\n        matrix[i] = [i];\n    }\n    let j;\n    for (j = 0; j <= a.length; j++) {\n        matrix[0][j] = j;\n    }\n    for (i = 1; i <= b.length; i++) {\n        for (j = 1; j <= a.length; j++) {\n            if (b.charAt(i - 1) === a.charAt(j - 1)) {\n                matrix[i][j] = matrix[i - 1][j - 1];\n            }\n            else {\n                matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));\n            }\n        }\n    }\n    return matrix[b.length][a.length];\n}\n\nconst specialKeys = ['$0', '--', '_'];\nfunction validation(yargs, usage, y18n, shim) {\n    const __ = y18n.__;\n    const __n = y18n.__n;\n    const self = {};\n    self.nonOptionCount = function nonOptionCount(argv) {\n        const demandedCommands = yargs.getDemandedCommands();\n        const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);\n        const _s = positionalCount - yargs.getContext().commands.length;\n        if (demandedCommands._ &&\n            (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n            if (_s < demandedCommands._.min) {\n                if (demandedCommands._.minMsg !== undefined) {\n                    usage.fail(demandedCommands._.minMsg\n                        ? demandedCommands._.minMsg\n                            .replace(/\\$0/g, _s.toString())\n                            .replace(/\\$1/, demandedCommands._.min.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));\n                }\n            }\n            else if (_s > demandedCommands._.max) {\n                if (demandedCommands._.maxMsg !== undefined) {\n                    usage.fail(demandedCommands._.maxMsg\n                        ? demandedCommands._.maxMsg\n                            .replace(/\\$0/g, _s.toString())\n                            .replace(/\\$1/, demandedCommands._.max.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));\n                }\n            }\n        }\n    };\n    self.positionalCount = function positionalCount(required, observed) {\n        if (observed < required) {\n            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));\n        }\n    };\n    self.requiredArguments = function requiredArguments(argv) {\n        const demandedOptions = yargs.getDemandedOptions();\n        let missing = null;\n        for (const key of Object.keys(demandedOptions)) {\n            if (!Object.prototype.hasOwnProperty.call(argv, key) ||\n                typeof argv[key] === 'undefined') {\n                missing = missing || {};\n                missing[key] = demandedOptions[key];\n            }\n        }\n        if (missing) {\n            const customMsgs = [];\n            for (const key of Object.keys(missing)) {\n                const msg = missing[key];\n                if (msg && customMsgs.indexOf(msg) < 0) {\n                    customMsgs.push(msg);\n                }\n            }\n            const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n        }\n    };\n    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        Object.keys(argv).forEach(key => {\n            if (specialKeys.indexOf(key) === -1 &&\n                !Object.prototype.hasOwnProperty.call(positionalMap, key) &&\n                !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) &&\n                !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n                unknown.push(key);\n            }\n        });\n        if (checkPositionals &&\n            (currentContext.commands.length > 0 ||\n                commandKeys.length > 0 ||\n                isDefaultCommand)) {\n            argv._.slice(currentContext.commands.length).forEach(key => {\n                if (commandKeys.indexOf('' + key) === -1) {\n                    unknown.push('' + key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n        }\n    };\n    self.unknownCommands = function unknownCommands(argv) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        if (currentContext.commands.length > 0 || commandKeys.length > 0) {\n            argv._.slice(currentContext.commands.length).forEach(key => {\n                if (commandKeys.indexOf('' + key) === -1) {\n                    unknown.push('' + key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n            return false;\n        }\n        const newAliases = yargs.parsed.newAliases;\n        for (const a of [key, ...aliases[key]]) {\n            if (!Object.prototype.hasOwnProperty.call(newAliases, a) ||\n                !newAliases[key]) {\n                return true;\n            }\n        }\n        return false;\n    };\n    self.limitedChoices = function limitedChoices(argv) {\n        const options = yargs.getOptions();\n        const invalid = {};\n        if (!Object.keys(options.choices).length)\n            return;\n        Object.keys(argv).forEach(key => {\n            if (specialKeys.indexOf(key) === -1 &&\n                Object.prototype.hasOwnProperty.call(options.choices, key)) {\n                [].concat(argv[key]).forEach(value => {\n                    if (options.choices[key].indexOf(value) === -1 &&\n                        value !== undefined) {\n                        invalid[key] = (invalid[key] || []).concat(value);\n                    }\n                });\n            }\n        });\n        const invalidKeys = Object.keys(invalid);\n        if (!invalidKeys.length)\n            return;\n        let msg = __('Invalid values:');\n        invalidKeys.forEach(key => {\n            msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n        });\n        usage.fail(msg);\n    };\n    let checks = [];\n    self.check = function check(f, global) {\n        checks.push({\n            func: f,\n            global,\n        });\n    };\n    self.customChecks = function customChecks(argv, aliases) {\n        for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n            const func = f.func;\n            let result = null;\n            try {\n                result = func(argv, aliases);\n            }\n            catch (err) {\n                usage.fail(err.message ? err.message : err, err);\n                continue;\n            }\n            if (!result) {\n                usage.fail(__('Argument check failed: %s', func.toString()));\n            }\n            else if (typeof result === 'string' || result instanceof Error) {\n                usage.fail(result.toString(), result);\n            }\n        }\n    };\n    let implied = {};\n    self.implies = function implies(key, value) {\n        argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(k => {\n                self.implies(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!implied[key]) {\n                implied[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach(i => self.implies(key, i));\n            }\n            else {\n                assertNotStrictEqual(value, undefined, shim);\n                implied[key].push(value);\n            }\n        }\n    };\n    self.getImplied = function getImplied() {\n        return implied;\n    };\n    function keyExists(argv, val) {\n        const num = Number(val);\n        val = isNaN(num) ? val : num;\n        if (typeof val === 'number') {\n            val = argv._.length >= val;\n        }\n        else if (val.match(/^--no-.+/)) {\n            val = val.match(/^--no-(.+)/)[1];\n            val = !argv[val];\n        }\n        else {\n            val = argv[val];\n        }\n        return val;\n    }\n    self.implications = function implications(argv) {\n        const implyFail = [];\n        Object.keys(implied).forEach(key => {\n            const origKey = key;\n            (implied[key] || []).forEach(value => {\n                let key = origKey;\n                const origValue = value;\n                key = keyExists(argv, key);\n                value = keyExists(argv, value);\n                if (key && !value) {\n                    implyFail.push(` ${origKey} -> ${origValue}`);\n                }\n            });\n        });\n        if (implyFail.length) {\n            let msg = `${__('Implications failed:')}\\n`;\n            implyFail.forEach(value => {\n                msg += value;\n            });\n            usage.fail(msg);\n        }\n    };\n    let conflicting = {};\n    self.conflicts = function conflicts(key, value) {\n        argsert('<string|object> [array|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(k => {\n                self.conflicts(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!conflicting[key]) {\n                conflicting[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach(i => self.conflicts(key, i));\n            }\n            else {\n                conflicting[key].push(value);\n            }\n        }\n    };\n    self.getConflicting = () => conflicting;\n    self.conflicting = function conflictingFn(argv) {\n        Object.keys(argv).forEach(key => {\n            if (conflicting[key]) {\n                conflicting[key].forEach(value => {\n                    if (value && argv[key] !== undefined && argv[value] !== undefined) {\n                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n                    }\n                });\n            }\n        });\n    };\n    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n        const threshold = 3;\n        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n        let recommended = null;\n        let bestDistance = Infinity;\n        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n            const d = levenshtein(cmd, candidate);\n            if (d <= threshold && d < bestDistance) {\n                bestDistance = d;\n                recommended = candidate;\n            }\n        }\n        if (recommended)\n            usage.fail(__('Did you mean %s?', recommended));\n    };\n    self.reset = function reset(localLookup) {\n        implied = objFilter(implied, k => !localLookup[k]);\n        conflicting = objFilter(conflicting, k => !localLookup[k]);\n        checks = checks.filter(c => c.global);\n        return self;\n    };\n    const frozens = [];\n    self.freeze = function freeze() {\n        frozens.push({\n            implied,\n            checks,\n            conflicting,\n        });\n    };\n    self.unfreeze = function unfreeze() {\n        const frozen = frozens.pop();\n        assertNotStrictEqual(frozen, undefined, shim);\n        ({ implied, checks, conflicting } = frozen);\n    };\n    return self;\n}\n\nlet shim$1;\nfunction YargsWithShim(_shim) {\n    shim$1 = _shim;\n    return Yargs;\n}\nfunction Yargs(processArgs = [], cwd = shim$1.process.cwd(), parentRequire) {\n    const self = {};\n    let command$1;\n    let completion$1 = null;\n    let groups = {};\n    const globalMiddleware = [];\n    let output = '';\n    const preservedGroups = {};\n    let usage$1;\n    let validation$1;\n    let handlerFinishCommand = null;\n    const y18n = shim$1.y18n;\n    self.middleware = globalMiddlewareFactory(globalMiddleware, self);\n    self.scriptName = function (scriptName) {\n        self.customScriptName = true;\n        self.$0 = scriptName;\n        return self;\n    };\n    let default$0;\n    if (/\\b(node|iojs|electron)(\\.exe)?$/.test(shim$1.process.argv()[0])) {\n        default$0 = shim$1.process.argv().slice(1, 2);\n    }\n    else {\n        default$0 = shim$1.process.argv().slice(0, 1);\n    }\n    self.$0 = default$0\n        .map(x => {\n        const b = rebase(cwd, x);\n        return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x;\n    })\n        .join(' ')\n        .trim();\n    if (shim$1.getEnv('_') && shim$1.getProcessArgvBin() === shim$1.getEnv('_')) {\n        self.$0 = shim$1\n            .getEnv('_')\n            .replace(`${shim$1.path.dirname(shim$1.process.execPath())}/`, '');\n    }\n    const context = { resets: -1, commands: [], fullCommands: [], files: [] };\n    self.getContext = () => context;\n    let hasOutput = false;\n    let exitError = null;\n    self.exit = (code, err) => {\n        hasOutput = true;\n        exitError = err;\n        if (exitProcess)\n            shim$1.process.exit(code);\n    };\n    let completionCommand = null;\n    self.completion = function (cmd, desc, fn) {\n        argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length);\n        if (typeof desc === 'function') {\n            fn = desc;\n            desc = undefined;\n        }\n        completionCommand = cmd || completionCommand || 'completion';\n        if (!desc && desc !== false) {\n            desc = 'generate completion script';\n        }\n        self.command(completionCommand, desc);\n        if (fn)\n            completion$1.registerFunction(fn);\n        return self;\n    };\n    let options;\n    self.resetOptions = self.reset = function resetOptions(aliases = {}) {\n        context.resets++;\n        options = options || {};\n        const tmpOptions = {};\n        tmpOptions.local = options.local ? options.local : [];\n        tmpOptions.configObjects = options.configObjects\n            ? options.configObjects\n            : [];\n        const localLookup = {};\n        tmpOptions.local.forEach(l => {\n            localLookup[l] = true;\n            (aliases[l] || []).forEach(a => {\n                localLookup[a] = true;\n            });\n        });\n        Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => {\n            const keys = groups[groupName].filter(key => !(key in localLookup));\n            if (keys.length > 0) {\n                acc[groupName] = keys;\n            }\n            return acc;\n        }, {}));\n        groups = {};\n        const arrayOptions = [\n            'array',\n            'boolean',\n            'string',\n            'skipValidation',\n            'count',\n            'normalize',\n            'number',\n            'hiddenOptions',\n        ];\n        const objectOptions = [\n            'narg',\n            'key',\n            'alias',\n            'default',\n            'defaultDescription',\n            'config',\n            'choices',\n            'demandedOptions',\n            'demandedCommands',\n            'coerce',\n            'deprecatedOptions',\n        ];\n        arrayOptions.forEach(k => {\n            tmpOptions[k] = (options[k] || []).filter((k) => !localLookup[k]);\n        });\n        objectOptions.forEach((k) => {\n            tmpOptions[k] = objFilter(options[k], k => !localLookup[k]);\n        });\n        tmpOptions.envPrefix = options.envPrefix;\n        options = tmpOptions;\n        usage$1 = usage$1 ? usage$1.reset(localLookup) : usage(self, y18n, shim$1);\n        validation$1 = validation$1\n            ? validation$1.reset(localLookup)\n            : validation(self, usage$1, y18n, shim$1);\n        command$1 = command$1\n            ? command$1.reset()\n            : command(self, usage$1, validation$1, globalMiddleware, shim$1);\n        if (!completion$1)\n            completion$1 = completion(self, usage$1, command$1, shim$1);\n        completionCommand = null;\n        output = '';\n        exitError = null;\n        hasOutput = false;\n        self.parsed = false;\n        return self;\n    };\n    self.resetOptions();\n    const frozens = [];\n    function freeze() {\n        frozens.push({\n            options,\n            configObjects: options.configObjects.slice(0),\n            exitProcess,\n            groups,\n            strict,\n            strictCommands,\n            strictOptions,\n            completionCommand,\n            output,\n            exitError,\n            hasOutput,\n            parsed: self.parsed,\n            parseFn,\n            parseContext,\n            handlerFinishCommand,\n        });\n        usage$1.freeze();\n        validation$1.freeze();\n        command$1.freeze();\n    }\n    function unfreeze() {\n        const frozen = frozens.pop();\n        assertNotStrictEqual(frozen, undefined, shim$1);\n        let configObjects;\n        ({\n            options,\n            configObjects,\n            exitProcess,\n            groups,\n            output,\n            exitError,\n            hasOutput,\n            parsed: self.parsed,\n            strict,\n            strictCommands,\n            strictOptions,\n            completionCommand,\n            parseFn,\n            parseContext,\n            handlerFinishCommand,\n        } = frozen);\n        options.configObjects = configObjects;\n        usage$1.unfreeze();\n        validation$1.unfreeze();\n        command$1.unfreeze();\n    }\n    self.boolean = function (keys) {\n        argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('boolean', keys);\n        return self;\n    };\n    self.array = function (keys) {\n        argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('array', keys);\n        return self;\n    };\n    self.number = function (keys) {\n        argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('number', keys);\n        return self;\n    };\n    self.normalize = function (keys) {\n        argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('normalize', keys);\n        return self;\n    };\n    self.count = function (keys) {\n        argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('count', keys);\n        return self;\n    };\n    self.string = function (keys) {\n        argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('string', keys);\n        return self;\n    };\n    self.requiresArg = function (keys) {\n        argsert('<array|string|object> [number]', [keys], arguments.length);\n        if (typeof keys === 'string' && options.narg[keys]) {\n            return self;\n        }\n        else {\n            populateParserHintSingleValueDictionary(self.requiresArg, 'narg', keys, NaN);\n        }\n        return self;\n    };\n    self.skipValidation = function (keys) {\n        argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('skipValidation', keys);\n        return self;\n    };\n    function populateParserHintArray(type, keys) {\n        keys = [].concat(keys);\n        keys.forEach(key => {\n            key = sanitizeKey(key);\n            options[type].push(key);\n        });\n    }\n    self.nargs = function (key, value) {\n        argsert('<string|object|array> [number]', [key, value], arguments.length);\n        populateParserHintSingleValueDictionary(self.nargs, 'narg', key, value);\n        return self;\n    };\n    self.choices = function (key, value) {\n        argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n        populateParserHintArrayDictionary(self.choices, 'choices', key, value);\n        return self;\n    };\n    self.alias = function (key, value) {\n        argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n        populateParserHintArrayDictionary(self.alias, 'alias', key, value);\n        return self;\n    };\n    self.default = self.defaults = function (key, value, defaultDescription) {\n        argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);\n        if (defaultDescription) {\n            assertSingleKey(key, shim$1);\n            options.defaultDescription[key] = defaultDescription;\n        }\n        if (typeof value === 'function') {\n            assertSingleKey(key, shim$1);\n            if (!options.defaultDescription[key])\n                options.defaultDescription[key] = usage$1.functionDescription(value);\n            value = value.call();\n        }\n        populateParserHintSingleValueDictionary(self.default, 'default', key, value);\n        return self;\n    };\n    self.describe = function (key, desc) {\n        argsert('<object|string|array> [string]', [key, desc], arguments.length);\n        setKey(key, true);\n        usage$1.describe(key, desc);\n        return self;\n    };\n    function setKey(key, set) {\n        populateParserHintSingleValueDictionary(setKey, 'key', key, set);\n        return self;\n    }\n    function demandOption(keys, msg) {\n        argsert('<object|string|array> [string]', [keys, msg], arguments.length);\n        populateParserHintSingleValueDictionary(self.demandOption, 'demandedOptions', keys, msg);\n        return self;\n    }\n    self.demandOption = demandOption;\n    self.coerce = function (keys, value) {\n        argsert('<object|string|array> [function]', [keys, value], arguments.length);\n        populateParserHintSingleValueDictionary(self.coerce, 'coerce', keys, value);\n        return self;\n    };\n    function populateParserHintSingleValueDictionary(builder, type, key, value) {\n        populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n            options[type][key] = value;\n        });\n    }\n    function populateParserHintArrayDictionary(builder, type, key, value) {\n        populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n            options[type][key] = (options[type][key] || []).concat(value);\n        });\n    }\n    function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {\n        if (Array.isArray(key)) {\n            key.forEach(k => {\n                builder(k, value);\n            });\n        }\n        else if (((key) => typeof key === 'object')(key)) {\n            for (const k of objectKeys(key)) {\n                builder(k, key[k]);\n            }\n        }\n        else {\n            singleKeyHandler(type, sanitizeKey(key), value);\n        }\n    }\n    function sanitizeKey(key) {\n        if (key === '__proto__')\n            return '___proto___';\n        return key;\n    }\n    function deleteFromParserHintObject(optionKey) {\n        objectKeys(options).forEach((hintKey) => {\n            if (((key) => key === 'configObjects')(hintKey))\n                return;\n            const hint = options[hintKey];\n            if (Array.isArray(hint)) {\n                if (~hint.indexOf(optionKey))\n                    hint.splice(hint.indexOf(optionKey), 1);\n            }\n            else if (typeof hint === 'object') {\n                delete hint[optionKey];\n            }\n        });\n        delete usage$1.getDescriptions()[optionKey];\n    }\n    self.config = function config(key = 'config', msg, parseFn) {\n        argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length);\n        if (typeof key === 'object' && !Array.isArray(key)) {\n            key = applyExtends(key, cwd, self.getParserConfiguration()['deep-merge-config'] || false, shim$1);\n            options.configObjects = (options.configObjects || []).concat(key);\n            return self;\n        }\n        if (typeof msg === 'function') {\n            parseFn = msg;\n            msg = undefined;\n        }\n        self.describe(key, msg || usage$1.deferY18nLookup('Path to JSON config file'));\n        (Array.isArray(key) ? key : [key]).forEach(k => {\n            options.config[k] = parseFn || true;\n        });\n        return self;\n    };\n    self.example = function (cmd, description) {\n        argsert('<string|array> [string]', [cmd, description], arguments.length);\n        if (Array.isArray(cmd)) {\n            cmd.forEach(exampleParams => self.example(...exampleParams));\n        }\n        else {\n            usage$1.example(cmd, description);\n        }\n        return self;\n    };\n    self.command = function (cmd, description, builder, handler, middlewares, deprecated) {\n        argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [cmd, description, builder, handler, middlewares, deprecated], arguments.length);\n        command$1.addHandler(cmd, description, builder, handler, middlewares, deprecated);\n        return self;\n    };\n    self.commandDir = function (dir, opts) {\n        argsert('<string> [object]', [dir, opts], arguments.length);\n        const req = parentRequire || shim$1.require;\n        command$1.addDirectory(dir, self.getContext(), req, shim$1.getCallerFile(), opts);\n        return self;\n    };\n    self.demand = self.required = self.require = function demand(keys, max, msg) {\n        if (Array.isArray(max)) {\n            max.forEach(key => {\n                assertNotStrictEqual(msg, true, shim$1);\n                demandOption(key, msg);\n            });\n            max = Infinity;\n        }\n        else if (typeof max !== 'number') {\n            msg = max;\n            max = Infinity;\n        }\n        if (typeof keys === 'number') {\n            assertNotStrictEqual(msg, true, shim$1);\n            self.demandCommand(keys, max, msg, msg);\n        }\n        else if (Array.isArray(keys)) {\n            keys.forEach(key => {\n                assertNotStrictEqual(msg, true, shim$1);\n                demandOption(key, msg);\n            });\n        }\n        else {\n            if (typeof msg === 'string') {\n                demandOption(keys, msg);\n            }\n            else if (msg === true || typeof msg === 'undefined') {\n                demandOption(keys);\n            }\n        }\n        return self;\n    };\n    self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) {\n        argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length);\n        if (typeof max !== 'number') {\n            minMsg = max;\n            max = Infinity;\n        }\n        self.global('_', false);\n        options.demandedCommands._ = {\n            min,\n            max,\n            minMsg,\n            maxMsg,\n        };\n        return self;\n    };\n    self.getDemandedOptions = () => {\n        argsert([], 0);\n        return options.demandedOptions;\n    };\n    self.getDemandedCommands = () => {\n        argsert([], 0);\n        return options.demandedCommands;\n    };\n    self.deprecateOption = function deprecateOption(option, message) {\n        argsert('<string> [string|boolean]', [option, message], arguments.length);\n        options.deprecatedOptions[option] = message;\n        return self;\n    };\n    self.getDeprecatedOptions = () => {\n        argsert([], 0);\n        return options.deprecatedOptions;\n    };\n    self.implies = function (key, value) {\n        argsert('<string|object> [number|string|array]', [key, value], arguments.length);\n        validation$1.implies(key, value);\n        return self;\n    };\n    self.conflicts = function (key1, key2) {\n        argsert('<string|object> [string|array]', [key1, key2], arguments.length);\n        validation$1.conflicts(key1, key2);\n        return self;\n    };\n    self.usage = function (msg, description, builder, handler) {\n        argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length);\n        if (description !== undefined) {\n            assertNotStrictEqual(msg, null, shim$1);\n            if ((msg || '').match(/^\\$0( |$)/)) {\n                return self.command(msg, description, builder, handler);\n            }\n            else {\n                throw new YError('.usage() description must start with $0 if being used as alias for .command()');\n            }\n        }\n        else {\n            usage$1.usage(msg);\n            return self;\n        }\n    };\n    self.epilogue = self.epilog = function (msg) {\n        argsert('<string>', [msg], arguments.length);\n        usage$1.epilog(msg);\n        return self;\n    };\n    self.fail = function (f) {\n        argsert('<function>', [f], arguments.length);\n        usage$1.failFn(f);\n        return self;\n    };\n    self.onFinishCommand = function (f) {\n        argsert('<function>', [f], arguments.length);\n        handlerFinishCommand = f;\n        return self;\n    };\n    self.getHandlerFinishCommand = () => handlerFinishCommand;\n    self.check = function (f, _global) {\n        argsert('<function> [boolean]', [f, _global], arguments.length);\n        validation$1.check(f, _global !== false);\n        return self;\n    };\n    self.global = function global(globals, global) {\n        argsert('<string|array> [boolean]', [globals, global], arguments.length);\n        globals = [].concat(globals);\n        if (global !== false) {\n            options.local = options.local.filter(l => globals.indexOf(l) === -1);\n        }\n        else {\n            globals.forEach(g => {\n                if (options.local.indexOf(g) === -1)\n                    options.local.push(g);\n            });\n        }\n        return self;\n    };\n    self.pkgConf = function pkgConf(key, rootPath) {\n        argsert('<string> [string]', [key, rootPath], arguments.length);\n        let conf = null;\n        const obj = pkgUp(rootPath || cwd);\n        if (obj[key] && typeof obj[key] === 'object') {\n            conf = applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()['deep-merge-config'] || false, shim$1);\n            options.configObjects = (options.configObjects || []).concat(conf);\n        }\n        return self;\n    };\n    const pkgs = {};\n    function pkgUp(rootPath) {\n        const npath = rootPath || '*';\n        if (pkgs[npath])\n            return pkgs[npath];\n        let obj = {};\n        try {\n            let startDir = rootPath || shim$1.mainFilename;\n            if (!rootPath && shim$1.path.extname(startDir)) {\n                startDir = shim$1.path.dirname(startDir);\n            }\n            const pkgJsonPath = shim$1.findUp(startDir, (dir, names) => {\n                if (names.includes('package.json')) {\n                    return 'package.json';\n                }\n                else {\n                    return undefined;\n                }\n            });\n            assertNotStrictEqual(pkgJsonPath, undefined, shim$1);\n            obj = JSON.parse(shim$1.readFileSync(pkgJsonPath, 'utf8'));\n        }\n        catch (_noop) { }\n        pkgs[npath] = obj || {};\n        return pkgs[npath];\n    }\n    let parseFn = null;\n    let parseContext = null;\n    self.parse = function parse(args, shortCircuit, _parseFn) {\n        argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length);\n        freeze();\n        if (typeof args === 'undefined') {\n            const argv = self._parseArgs(processArgs);\n            const tmpParsed = self.parsed;\n            unfreeze();\n            self.parsed = tmpParsed;\n            return argv;\n        }\n        if (typeof shortCircuit === 'object') {\n            parseContext = shortCircuit;\n            shortCircuit = _parseFn;\n        }\n        if (typeof shortCircuit === 'function') {\n            parseFn = shortCircuit;\n            shortCircuit = false;\n        }\n        if (!shortCircuit)\n            processArgs = args;\n        if (parseFn)\n            exitProcess = false;\n        const parsed = self._parseArgs(args, !!shortCircuit);\n        completion$1.setParsed(self.parsed);\n        if (parseFn)\n            parseFn(exitError, parsed, output);\n        unfreeze();\n        return parsed;\n    };\n    self._getParseContext = () => parseContext || {};\n    self._hasParseCallback = () => !!parseFn;\n    self.option = self.options = function option(key, opt) {\n        argsert('<string|object> [object]', [key, opt], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(k => {\n                self.options(k, key[k]);\n            });\n        }\n        else {\n            if (typeof opt !== 'object') {\n                opt = {};\n            }\n            options.key[key] = true;\n            if (opt.alias)\n                self.alias(key, opt.alias);\n            const deprecate = opt.deprecate || opt.deprecated;\n            if (deprecate) {\n                self.deprecateOption(key, deprecate);\n            }\n            const demand = opt.demand || opt.required || opt.require;\n            if (demand) {\n                self.demand(key, demand);\n            }\n            if (opt.demandOption) {\n                self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);\n            }\n            if (opt.conflicts) {\n                self.conflicts(key, opt.conflicts);\n            }\n            if ('default' in opt) {\n                self.default(key, opt.default);\n            }\n            if (opt.implies !== undefined) {\n                self.implies(key, opt.implies);\n            }\n            if (opt.nargs !== undefined) {\n                self.nargs(key, opt.nargs);\n            }\n            if (opt.config) {\n                self.config(key, opt.configParser);\n            }\n            if (opt.normalize) {\n                self.normalize(key);\n            }\n            if (opt.choices) {\n                self.choices(key, opt.choices);\n            }\n            if (opt.coerce) {\n                self.coerce(key, opt.coerce);\n            }\n            if (opt.group) {\n                self.group(key, opt.group);\n            }\n            if (opt.boolean || opt.type === 'boolean') {\n                self.boolean(key);\n                if (opt.alias)\n                    self.boolean(opt.alias);\n            }\n            if (opt.array || opt.type === 'array') {\n                self.array(key);\n                if (opt.alias)\n                    self.array(opt.alias);\n            }\n            if (opt.number || opt.type === 'number') {\n                self.number(key);\n                if (opt.alias)\n                    self.number(opt.alias);\n            }\n            if (opt.string || opt.type === 'string') {\n                self.string(key);\n                if (opt.alias)\n                    self.string(opt.alias);\n            }\n            if (opt.count || opt.type === 'count') {\n                self.count(key);\n            }\n            if (typeof opt.global === 'boolean') {\n                self.global(key, opt.global);\n            }\n            if (opt.defaultDescription) {\n                options.defaultDescription[key] = opt.defaultDescription;\n            }\n            if (opt.skipValidation) {\n                self.skipValidation(key);\n            }\n            const desc = opt.describe || opt.description || opt.desc;\n            self.describe(key, desc);\n            if (opt.hidden) {\n                self.hide(key);\n            }\n            if (opt.requiresArg) {\n                self.requiresArg(key);\n            }\n        }\n        return self;\n    };\n    self.getOptions = () => options;\n    self.positional = function (key, opts) {\n        argsert('<string> <object>', [key, opts], arguments.length);\n        if (context.resets === 0) {\n            throw new YError(\".positional() can only be called in a command's builder function\");\n        }\n        const supportedOpts = [\n            'default',\n            'defaultDescription',\n            'implies',\n            'normalize',\n            'choices',\n            'conflicts',\n            'coerce',\n            'type',\n            'describe',\n            'desc',\n            'description',\n            'alias',\n        ];\n        opts = objFilter(opts, (k, v) => {\n            let accept = supportedOpts.indexOf(k) !== -1;\n            if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1)\n                accept = false;\n            return accept;\n        });\n        const fullCommand = context.fullCommands[context.fullCommands.length - 1];\n        const parseOptions = fullCommand\n            ? command$1.cmdToParseOptions(fullCommand)\n            : {\n                array: [],\n                alias: {},\n                default: {},\n                demand: {},\n            };\n        objectKeys(parseOptions).forEach(pk => {\n            const parseOption = parseOptions[pk];\n            if (Array.isArray(parseOption)) {\n                if (parseOption.indexOf(key) !== -1)\n                    opts[pk] = true;\n            }\n            else {\n                if (parseOption[key] && !(pk in opts))\n                    opts[pk] = parseOption[key];\n            }\n        });\n        self.group(key, usage$1.getPositionalGroupName());\n        return self.option(key, opts);\n    };\n    self.group = function group(opts, groupName) {\n        argsert('<string|array> <string>', [opts, groupName], arguments.length);\n        const existing = preservedGroups[groupName] || groups[groupName];\n        if (preservedGroups[groupName]) {\n            delete preservedGroups[groupName];\n        }\n        const seen = {};\n        groups[groupName] = (existing || []).concat(opts).filter(key => {\n            if (seen[key])\n                return false;\n            return (seen[key] = true);\n        });\n        return self;\n    };\n    self.getGroups = () => Object.assign({}, groups, preservedGroups);\n    self.env = function (prefix) {\n        argsert('[string|boolean]', [prefix], arguments.length);\n        if (prefix === false)\n            delete options.envPrefix;\n        else\n            options.envPrefix = prefix || '';\n        return self;\n    };\n    self.wrap = function (cols) {\n        argsert('<number|null|undefined>', [cols], arguments.length);\n        usage$1.wrap(cols);\n        return self;\n    };\n    let strict = false;\n    self.strict = function (enabled) {\n        argsert('[boolean]', [enabled], arguments.length);\n        strict = enabled !== false;\n        return self;\n    };\n    self.getStrict = () => strict;\n    let strictCommands = false;\n    self.strictCommands = function (enabled) {\n        argsert('[boolean]', [enabled], arguments.length);\n        strictCommands = enabled !== false;\n        return self;\n    };\n    self.getStrictCommands = () => strictCommands;\n    let strictOptions = false;\n    self.strictOptions = function (enabled) {\n        argsert('[boolean]', [enabled], arguments.length);\n        strictOptions = enabled !== false;\n        return self;\n    };\n    self.getStrictOptions = () => strictOptions;\n    let parserConfig = {};\n    self.parserConfiguration = function parserConfiguration(config) {\n        argsert('<object>', [config], arguments.length);\n        parserConfig = config;\n        return self;\n    };\n    self.getParserConfiguration = () => parserConfig;\n    self.showHelp = function (level) {\n        argsert('[string|function]', [level], arguments.length);\n        if (!self.parsed)\n            self._parseArgs(processArgs);\n        if (command$1.hasDefaultCommand()) {\n            context.resets++;\n            command$1.runDefaultBuilderOn(self);\n        }\n        usage$1.showHelp(level);\n        return self;\n    };\n    let versionOpt = null;\n    self.version = function version(opt, msg, ver) {\n        const defaultVersionOpt = 'version';\n        argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length);\n        if (versionOpt) {\n            deleteFromParserHintObject(versionOpt);\n            usage$1.version(undefined);\n            versionOpt = null;\n        }\n        if (arguments.length === 0) {\n            ver = guessVersion();\n            opt = defaultVersionOpt;\n        }\n        else if (arguments.length === 1) {\n            if (opt === false) {\n                return self;\n            }\n            ver = opt;\n            opt = defaultVersionOpt;\n        }\n        else if (arguments.length === 2) {\n            ver = msg;\n            msg = undefined;\n        }\n        versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt;\n        msg = msg || usage$1.deferY18nLookup('Show version number');\n        usage$1.version(ver || undefined);\n        self.boolean(versionOpt);\n        self.describe(versionOpt, msg);\n        return self;\n    };\n    function guessVersion() {\n        const obj = pkgUp();\n        return obj.version || 'unknown';\n    }\n    let helpOpt = null;\n    self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {\n        const defaultHelpOpt = 'help';\n        argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n        if (helpOpt) {\n            deleteFromParserHintObject(helpOpt);\n            helpOpt = null;\n        }\n        if (arguments.length === 1) {\n            if (opt === false)\n                return self;\n        }\n        helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt;\n        self.boolean(helpOpt);\n        self.describe(helpOpt, msg || usage$1.deferY18nLookup('Show help'));\n        return self;\n    };\n    const defaultShowHiddenOpt = 'show-hidden';\n    options.showHiddenOpt = defaultShowHiddenOpt;\n    self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {\n        argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n        if (arguments.length === 1) {\n            if (opt === false)\n                return self;\n        }\n        const showHiddenOpt = typeof opt === 'string' ? opt : defaultShowHiddenOpt;\n        self.boolean(showHiddenOpt);\n        self.describe(showHiddenOpt, msg || usage$1.deferY18nLookup('Show hidden options'));\n        options.showHiddenOpt = showHiddenOpt;\n        return self;\n    };\n    self.hide = function hide(key) {\n        argsert('<string>', [key], arguments.length);\n        options.hiddenOptions.push(key);\n        return self;\n    };\n    self.showHelpOnFail = function showHelpOnFail(enabled, message) {\n        argsert('[boolean|string] [string]', [enabled, message], arguments.length);\n        usage$1.showHelpOnFail(enabled, message);\n        return self;\n    };\n    let exitProcess = true;\n    self.exitProcess = function (enabled = true) {\n        argsert('[boolean]', [enabled], arguments.length);\n        exitProcess = enabled;\n        return self;\n    };\n    self.getExitProcess = () => exitProcess;\n    self.showCompletionScript = function ($0, cmd) {\n        argsert('[string] [string]', [$0, cmd], arguments.length);\n        $0 = $0 || self.$0;\n        _logger.log(completion$1.generateCompletionScript($0, cmd || completionCommand || 'completion'));\n        return self;\n    };\n    self.getCompletion = function (args, done) {\n        argsert('<array> <function>', [args, done], arguments.length);\n        completion$1.getCompletion(args, done);\n    };\n    self.locale = function (locale) {\n        argsert('[string]', [locale], arguments.length);\n        if (!locale) {\n            guessLocale();\n            return y18n.getLocale();\n        }\n        detectLocale = false;\n        y18n.setLocale(locale);\n        return self;\n    };\n    self.updateStrings = self.updateLocale = function (obj) {\n        argsert('<object>', [obj], arguments.length);\n        detectLocale = false;\n        y18n.updateLocale(obj);\n        return self;\n    };\n    let detectLocale = true;\n    self.detectLocale = function (detect) {\n        argsert('<boolean>', [detect], arguments.length);\n        detectLocale = detect;\n        return self;\n    };\n    self.getDetectLocale = () => detectLocale;\n    const _logger = {\n        log(...args) {\n            if (!self._hasParseCallback())\n                console.log(...args);\n            hasOutput = true;\n            if (output.length)\n                output += '\\n';\n            output += args.join(' ');\n        },\n        error(...args) {\n            if (!self._hasParseCallback())\n                console.error(...args);\n            hasOutput = true;\n            if (output.length)\n                output += '\\n';\n            output += args.join(' ');\n        },\n    };\n    self._getLoggerInstance = () => _logger;\n    self._hasOutput = () => hasOutput;\n    self._setHasOutput = () => {\n        hasOutput = true;\n    };\n    let recommendCommands;\n    self.recommendCommands = function (recommend = true) {\n        argsert('[boolean]', [recommend], arguments.length);\n        recommendCommands = recommend;\n        return self;\n    };\n    self.getUsageInstance = () => usage$1;\n    self.getValidationInstance = () => validation$1;\n    self.getCommandInstance = () => command$1;\n    self.terminalWidth = () => {\n        argsert([], 0);\n        return shim$1.process.stdColumns;\n    };\n    Object.defineProperty(self, 'argv', {\n        get: () => self._parseArgs(processArgs),\n        enumerable: true,\n    });\n    self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {\n        let skipValidation = !!_calledFromCommand;\n        args = args || processArgs;\n        options.__ = y18n.__;\n        options.configuration = self.getParserConfiguration();\n        const populateDoubleDash = !!options.configuration['populate--'];\n        const config = Object.assign({}, options.configuration, {\n            'populate--': true,\n        });\n        const parsed = shim$1.Parser.detailed(args, Object.assign({}, options, {\n            configuration: Object.assign({ 'parse-positional-numbers': false }, config),\n        }));\n        let argv = parsed.argv;\n        if (parseContext)\n            argv = Object.assign({}, argv, parseContext);\n        const aliases = parsed.aliases;\n        argv.$0 = self.$0;\n        self.parsed = parsed;\n        try {\n            guessLocale();\n            if (shortCircuit) {\n                return self._postProcess(argv, populateDoubleDash, _calledFromCommand);\n            }\n            if (helpOpt) {\n                const helpCmds = [helpOpt]\n                    .concat(aliases[helpOpt] || [])\n                    .filter(k => k.length > 1);\n                if (~helpCmds.indexOf('' + argv._[argv._.length - 1])) {\n                    argv._.pop();\n                    argv[helpOpt] = true;\n                }\n            }\n            const handlerKeys = command$1.getCommands();\n            const requestCompletions = completion$1.completionKey in argv;\n            const skipRecommendation = argv[helpOpt] || requestCompletions;\n            const skipDefaultCommand = skipRecommendation &&\n                (handlerKeys.length > 1 || handlerKeys[0] !== '$0');\n            if (argv._.length) {\n                if (handlerKeys.length) {\n                    let firstUnknownCommand;\n                    for (let i = commandIndex || 0, cmd; argv._[i] !== undefined; i++) {\n                        cmd = String(argv._[i]);\n                        if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n                            const innerArgv = command$1.runCommand(cmd, self, parsed, i + 1);\n                            return self._postProcess(innerArgv, populateDoubleDash);\n                        }\n                        else if (!firstUnknownCommand && cmd !== completionCommand) {\n                            firstUnknownCommand = cmd;\n                            break;\n                        }\n                    }\n                    if (command$1.hasDefaultCommand() && !skipDefaultCommand) {\n                        const innerArgv = command$1.runCommand(null, self, parsed);\n                        return self._postProcess(innerArgv, populateDoubleDash);\n                    }\n                    if (recommendCommands && firstUnknownCommand && !skipRecommendation) {\n                        validation$1.recommendCommands(firstUnknownCommand, handlerKeys);\n                    }\n                }\n                if (completionCommand &&\n                    ~argv._.indexOf(completionCommand) &&\n                    !requestCompletions) {\n                    if (exitProcess)\n                        setBlocking(true);\n                    self.showCompletionScript();\n                    self.exit(0);\n                }\n            }\n            else if (command$1.hasDefaultCommand() && !skipDefaultCommand) {\n                const innerArgv = command$1.runCommand(null, self, parsed);\n                return self._postProcess(innerArgv, populateDoubleDash);\n            }\n            if (requestCompletions) {\n                if (exitProcess)\n                    setBlocking(true);\n                args = [].concat(args);\n                const completionArgs = args.slice(args.indexOf(`--${completion$1.completionKey}`) + 1);\n                completion$1.getCompletion(completionArgs, completions => {\n                    (completions || []).forEach(completion => {\n                        _logger.log(completion);\n                    });\n                    self.exit(0);\n                });\n                return self._postProcess(argv, !populateDoubleDash, _calledFromCommand);\n            }\n            if (!hasOutput) {\n                Object.keys(argv).forEach(key => {\n                    if (key === helpOpt && argv[key]) {\n                        if (exitProcess)\n                            setBlocking(true);\n                        skipValidation = true;\n                        self.showHelp('log');\n                        self.exit(0);\n                    }\n                    else if (key === versionOpt && argv[key]) {\n                        if (exitProcess)\n                            setBlocking(true);\n                        skipValidation = true;\n                        usage$1.showVersion();\n                        self.exit(0);\n                    }\n                });\n            }\n            if (!skipValidation && options.skipValidation.length > 0) {\n                skipValidation = Object.keys(argv).some(key => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);\n            }\n            if (!skipValidation) {\n                if (parsed.error)\n                    throw new YError(parsed.error.message);\n                if (!requestCompletions) {\n                    self._runValidation(argv, aliases, {}, parsed.error);\n                }\n            }\n        }\n        catch (err) {\n            if (err instanceof YError)\n                usage$1.fail(err.message, err);\n            else\n                throw err;\n        }\n        return self._postProcess(argv, populateDoubleDash, _calledFromCommand);\n    };\n    self._postProcess = function (argv, populateDoubleDash, calledFromCommand = false) {\n        if (isPromise(argv))\n            return argv;\n        if (calledFromCommand)\n            return argv;\n        if (!populateDoubleDash) {\n            argv = self._copyDoubleDash(argv);\n        }\n        const parsePositionalNumbers = self.getParserConfiguration()['parse-positional-numbers'] ||\n            self.getParserConfiguration()['parse-positional-numbers'] === undefined;\n        if (parsePositionalNumbers) {\n            argv = self._parsePositionalNumbers(argv);\n        }\n        return argv;\n    };\n    self._copyDoubleDash = function (argv) {\n        if (!argv._ || !argv['--'])\n            return argv;\n        argv._.push.apply(argv._, argv['--']);\n        try {\n            delete argv['--'];\n        }\n        catch (_err) { }\n        return argv;\n    };\n    self._parsePositionalNumbers = function (argv) {\n        const args = argv['--'] ? argv['--'] : argv._;\n        for (let i = 0, arg; (arg = args[i]) !== undefined; i++) {\n            if (shim$1.Parser.looksLikeNumber(arg) &&\n                Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {\n                args[i] = Number(arg);\n            }\n        }\n        return argv;\n    };\n    self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) {\n        if (parseErrors)\n            throw new YError(parseErrors.message);\n        validation$1.nonOptionCount(argv);\n        validation$1.requiredArguments(argv);\n        let failedStrictCommands = false;\n        if (strictCommands) {\n            failedStrictCommands = validation$1.unknownCommands(argv);\n        }\n        if (strict && !failedStrictCommands) {\n            validation$1.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);\n        }\n        else if (strictOptions) {\n            validation$1.unknownArguments(argv, aliases, {}, false, false);\n        }\n        validation$1.customChecks(argv, aliases);\n        validation$1.limitedChoices(argv);\n        validation$1.implications(argv);\n        validation$1.conflicting(argv);\n    };\n    function guessLocale() {\n        if (!detectLocale)\n            return;\n        const locale = shim$1.getEnv('LC_ALL') ||\n            shim$1.getEnv('LC_MESSAGES') ||\n            shim$1.getEnv('LANG') ||\n            shim$1.getEnv('LANGUAGE') ||\n            'en_US';\n        self.locale(locale.replace(/[.:].*/, ''));\n    }\n    self.help();\n    self.version();\n    return self;\n}\nconst rebase = (base, dir) => shim$1.path.relative(base, dir);\nfunction isYargsInstance(y) {\n    return !!y && typeof y._parseArgs === 'function';\n}\n\nvar _a, _b;\nconst { readFileSync } = require('fs');\nconst { inspect } = require('util');\nconst { resolve } = require('path');\nconst y18n = require('y18n');\nconst Parser = require('yargs-parser');\nvar cjsPlatformShim = {\n    assert: {\n        notStrictEqual: assert.notStrictEqual,\n        strictEqual: assert.strictEqual,\n    },\n    cliui: require('cliui'),\n    findUp: require('escalade/sync'),\n    getEnv: (key) => {\n        return process.env[key];\n    },\n    getCallerFile: require('get-caller-file'),\n    getProcessArgvBin: getProcessArgvBin,\n    inspect,\n    mainFilename: (_b = (_a = require === null || require === void 0 ? void 0 : require.main) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : process.cwd(),\n    Parser,\n    path: require('path'),\n    process: {\n        argv: () => process.argv,\n        cwd: process.cwd,\n        execPath: () => process.execPath,\n        exit: (code) => {\n            process.exit(code);\n        },\n        nextTick: process.nextTick,\n        stdColumns: typeof process.stdout.columns !== 'undefined'\n            ? process.stdout.columns\n            : null,\n    },\n    readFileSync,\n    require: require,\n    requireDirectory: require('require-directory'),\n    stringWidth: require('string-width'),\n    y18n: y18n({\n        directory: resolve(__dirname, '../locales'),\n        updateFiles: false,\n    }),\n};\n\nconst minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION\n    ? Number(process.env.YARGS_MIN_NODE_VERSION)\n    : 10;\nif (process && process.version) {\n    const major = Number(process.version.match(/v([^.]+)/)[1]);\n    if (major < minNodeVersion) {\n        throw Error(`yargs supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs#supported-nodejs-versions`);\n    }\n}\nconst Parser$1 = require('yargs-parser');\nconst Yargs$1 = YargsWithShim(cjsPlatformShim);\nvar cjs = {\n    applyExtends,\n    cjsPlatformShim,\n    Yargs: Yargs$1,\n    argsert,\n    globalMiddlewareFactory,\n    isPromise,\n    objFilter,\n    parseCommand,\n    Parser: Parser$1,\n    processArgv,\n    rebase,\n    YError,\n};\n\nmodule.exports = cjs;\n"],"mappings":"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"}},"mtime":1674865296659},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\y18n@5.0.8\\\\node_modules\\\\y18n\\\\build\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\y18n@5.0.8\\\\node_modules\\\\y18n\\\\build\\\\index.cjs\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"'use strict';\n\nvar fs = require('fs');\nvar util = require('util');\nvar path = require('path');\nlet shim;\nclass Y18N {\n  constructor(opts) {\n    // configurable options.\n    opts = opts || {};\n    this.directory = opts.directory || './locales';\n    this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true;\n    this.locale = opts.locale || 'en';\n    this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true;\n    // internal stuff.\n    this.cache = Object.create(null);\n    this.writeQueue = [];\n  }\n  __(...args) {\n    if (typeof arguments[0] !== 'string') {\n      return this._taggedLiteral(arguments[0], ...arguments);\n    }\n    const str = args.shift();\n    let cb = function () {}; // start with noop.\n    if (typeof args[args.length - 1] === 'function') cb = args.pop();\n    cb = cb || function () {}; // noop.\n    if (!this.cache[this.locale]) this._readLocaleFile();\n    // we've observed a new string, update the language file.\n    if (!this.cache[this.locale][str] && this.updateFiles) {\n      this.cache[this.locale][str] = str;\n      // include the current directory and locale,\n      // since these values could change before the\n      // write is performed.\n      this._enqueueWrite({\n        directory: this.directory,\n        locale: this.locale,\n        cb\n      });\n    } else {\n      cb();\n    }\n    return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));\n  }\n  __n() {\n    const args = Array.prototype.slice.call(arguments);\n    const singular = args.shift();\n    const plural = args.shift();\n    const quantity = args.shift();\n    let cb = function () {}; // start with noop.\n    if (typeof args[args.length - 1] === 'function') cb = args.pop();\n    if (!this.cache[this.locale]) this._readLocaleFile();\n    let str = quantity === 1 ? singular : plural;\n    if (this.cache[this.locale][singular]) {\n      const entry = this.cache[this.locale][singular];\n      str = entry[quantity === 1 ? 'one' : 'other'];\n    }\n    // we've observed a new string, update the language file.\n    if (!this.cache[this.locale][singular] && this.updateFiles) {\n      this.cache[this.locale][singular] = {\n        one: singular,\n        other: plural\n      };\n      // include the current directory and locale,\n      // since these values could change before the\n      // write is performed.\n      this._enqueueWrite({\n        directory: this.directory,\n        locale: this.locale,\n        cb\n      });\n    } else {\n      cb();\n    }\n    // if a %d placeholder is provided, add quantity\n    // to the arguments expanded by util.format.\n    const values = [str];\n    if (~str.indexOf('%d')) values.push(quantity);\n    return shim.format.apply(shim.format, values.concat(args));\n  }\n  setLocale(locale) {\n    this.locale = locale;\n  }\n  getLocale() {\n    return this.locale;\n  }\n  updateLocale(obj) {\n    if (!this.cache[this.locale]) this._readLocaleFile();\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        this.cache[this.locale][key] = obj[key];\n      }\n    }\n  }\n  _taggedLiteral(parts, ...args) {\n    let str = '';\n    parts.forEach(function (part, i) {\n      const arg = args[i + 1];\n      str += part;\n      if (typeof arg !== 'undefined') {\n        str += '%s';\n      }\n    });\n    return this.__.apply(this, [str].concat([].slice.call(args, 1)));\n  }\n  _enqueueWrite(work) {\n    this.writeQueue.push(work);\n    if (this.writeQueue.length === 1) this._processWriteQueue();\n  }\n  _processWriteQueue() {\n    const _this = this;\n    const work = this.writeQueue[0];\n    // destructure the enqueued work.\n    const directory = work.directory;\n    const locale = work.locale;\n    const cb = work.cb;\n    const languageFile = this._resolveLocaleFile(directory, locale);\n    const serializedLocale = JSON.stringify(this.cache[locale], null, 2);\n    shim.fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {\n      _this.writeQueue.shift();\n      if (_this.writeQueue.length > 0) _this._processWriteQueue();\n      cb(err);\n    });\n  }\n  _readLocaleFile() {\n    let localeLookup = {};\n    const languageFile = this._resolveLocaleFile(this.directory, this.locale);\n    try {\n      // When using a bundler such as webpack, readFileSync may not be defined:\n      if (shim.fs.readFileSync) {\n        localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, 'utf-8'));\n      }\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        err.message = 'syntax error in ' + languageFile;\n      }\n      if (err.code === 'ENOENT') localeLookup = {};else throw err;\n    }\n    this.cache[this.locale] = localeLookup;\n  }\n  _resolveLocaleFile(directory, locale) {\n    let file = shim.resolve(directory, './', locale + '.json');\n    if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {\n      // attempt fallback to language only\n      const languageFile = shim.resolve(directory, './', locale.split('_')[0] + '.json');\n      if (this._fileExistsSync(languageFile)) file = languageFile;\n    }\n    return file;\n  }\n  _fileExistsSync(file) {\n    return shim.exists(file);\n  }\n}\nfunction y18n$1(opts, _shim) {\n  shim = _shim;\n  const y18n = new Y18N(opts);\n  return {\n    __: y18n.__.bind(y18n),\n    __n: y18n.__n.bind(y18n),\n    setLocale: y18n.setLocale.bind(y18n),\n    getLocale: y18n.getLocale.bind(y18n),\n    updateLocale: y18n.updateLocale.bind(y18n),\n    locale: y18n.locale\n  };\n}\nvar nodePlatformShim = {\n  fs: {\n    readFileSync: fs.readFileSync,\n    writeFile: fs.writeFile\n  },\n  format: util.format,\n  resolve: path.resolve,\n  exists: file => {\n    try {\n      return fs.statSync(file).isFile();\n    } catch (err) {\n      return false;\n    }\n  }\n};\nconst y18n = opts => {\n  return y18n$1(opts, nodePlatformShim);\n};\nmodule.exports = y18n;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJ1dGlsIiwicGF0aCIsInNoaW0iLCJZMThOIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiZGlyZWN0b3J5IiwidXBkYXRlRmlsZXMiLCJsb2NhbGUiLCJmYWxsYmFja1RvTGFuZ3VhZ2UiLCJjYWNoZSIsIk9iamVjdCIsImNyZWF0ZSIsIndyaXRlUXVldWUiLCJfXyIsImFyZ3MiLCJhcmd1bWVudHMiLCJfdGFnZ2VkTGl0ZXJhbCIsInN0ciIsInNoaWZ0IiwiY2IiLCJsZW5ndGgiLCJwb3AiLCJfcmVhZExvY2FsZUZpbGUiLCJfZW5xdWV1ZVdyaXRlIiwiZm9ybWF0IiwiYXBwbHkiLCJjb25jYXQiLCJfX24iLCJBcnJheSIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsInNpbmd1bGFyIiwicGx1cmFsIiwicXVhbnRpdHkiLCJlbnRyeSIsIm9uZSIsIm90aGVyIiwidmFsdWVzIiwiaW5kZXhPZiIsInB1c2giLCJzZXRMb2NhbGUiLCJnZXRMb2NhbGUiLCJ1cGRhdGVMb2NhbGUiLCJvYmoiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsInBhcnRzIiwiZm9yRWFjaCIsInBhcnQiLCJpIiwiYXJnIiwid29yayIsIl9wcm9jZXNzV3JpdGVRdWV1ZSIsIl90aGlzIiwibGFuZ3VhZ2VGaWxlIiwiX3Jlc29sdmVMb2NhbGVGaWxlIiwic2VyaWFsaXplZExvY2FsZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ3cml0ZUZpbGUiLCJlcnIiLCJsb2NhbGVMb29rdXAiLCJyZWFkRmlsZVN5bmMiLCJwYXJzZSIsIlN5bnRheEVycm9yIiwibWVzc2FnZSIsImNvZGUiLCJmaWxlIiwicmVzb2x2ZSIsIl9maWxlRXhpc3RzU3luYyIsImxhc3RJbmRleE9mIiwic3BsaXQiLCJleGlzdHMiLCJ5MThuJDEiLCJfc2hpbSIsInkxOG4iLCJiaW5kIiwibm9kZVBsYXRmb3JtU2hpbSIsInN0YXRTeW5jIiwiaXNGaWxlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiQzpcXGNvZGVcXEZsdWlkRnJhbWV3b3JrNVxcbm9kZV9tb2R1bGVzXFwucG5wbVxceTE4bkA1LjAuOFxcbm9kZV9tb2R1bGVzXFx5MThuXFxidWlsZFxcIiwic291cmNlcyI6WyJpbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxubGV0IHNoaW07XG5jbGFzcyBZMThOIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIC8vIGNvbmZpZ3VyYWJsZSBvcHRpb25zLlxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5kaXJlY3RvcnkgPSBvcHRzLmRpcmVjdG9yeSB8fCAnLi9sb2NhbGVzJztcbiAgICAgICAgdGhpcy51cGRhdGVGaWxlcyA9IHR5cGVvZiBvcHRzLnVwZGF0ZUZpbGVzID09PSAnYm9vbGVhbicgPyBvcHRzLnVwZGF0ZUZpbGVzIDogdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBvcHRzLmxvY2FsZSB8fCAnZW4nO1xuICAgICAgICB0aGlzLmZhbGxiYWNrVG9MYW5ndWFnZSA9IHR5cGVvZiBvcHRzLmZhbGxiYWNrVG9MYW5ndWFnZSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5mYWxsYmFja1RvTGFuZ3VhZ2UgOiB0cnVlO1xuICAgICAgICAvLyBpbnRlcm5hbCBzdHVmZi5cbiAgICAgICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMud3JpdGVRdWV1ZSA9IFtdO1xuICAgIH1cbiAgICBfXyguLi5hcmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhZ2dlZExpdGVyYWwoYXJndW1lbnRzWzBdLCAuLi5hcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0ciA9IGFyZ3Muc2hpZnQoKTtcbiAgICAgICAgbGV0IGNiID0gZnVuY3Rpb24gKCkgeyB9OyAvLyBzdGFydCB3aXRoIG5vb3AuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IgPSBhcmdzLnBvcCgpO1xuICAgICAgICBjYiA9IGNiIHx8IGZ1bmN0aW9uICgpIHsgfTsgLy8gbm9vcC5cbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlW3RoaXMubG9jYWxlXSlcbiAgICAgICAgICAgIHRoaXMuX3JlYWRMb2NhbGVGaWxlKCk7XG4gICAgICAgIC8vIHdlJ3ZlIG9ic2VydmVkIGEgbmV3IHN0cmluZywgdXBkYXRlIHRoZSBsYW5ndWFnZSBmaWxlLlxuICAgICAgICBpZiAoIXRoaXMuY2FjaGVbdGhpcy5sb2NhbGVdW3N0cl0gJiYgdGhpcy51cGRhdGVGaWxlcykge1xuICAgICAgICAgICAgdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1bc3RyXSA9IHN0cjtcbiAgICAgICAgICAgIC8vIGluY2x1ZGUgdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGFuZCBsb2NhbGUsXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGVzZSB2YWx1ZXMgY291bGQgY2hhbmdlIGJlZm9yZSB0aGVcbiAgICAgICAgICAgIC8vIHdyaXRlIGlzIHBlcmZvcm1lZC5cbiAgICAgICAgICAgIHRoaXMuX2VucXVldWVXcml0ZSh7XG4gICAgICAgICAgICAgICAgZGlyZWN0b3J5OiB0aGlzLmRpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgICAgICAgICAgIGNiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNoaW0uZm9ybWF0LmFwcGx5KHNoaW0uZm9ybWF0LCBbdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1bc3RyXSB8fCBzdHJdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICAgIF9fbigpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnN0IHNpbmd1bGFyID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBjb25zdCBwbHVyYWwgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IHF1YW50aXR5ID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBsZXQgY2IgPSBmdW5jdGlvbiAoKSB7IH07IC8vIHN0YXJ0IHdpdGggbm9vcC5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYiA9IGFyZ3MucG9wKCk7XG4gICAgICAgIGlmICghdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV0pXG4gICAgICAgICAgICB0aGlzLl9yZWFkTG9jYWxlRmlsZSgpO1xuICAgICAgICBsZXQgc3RyID0gcXVhbnRpdHkgPT09IDEgPyBzaW5ndWxhciA6IHBsdXJhbDtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVbdGhpcy5sb2NhbGVdW3Npbmd1bGFyXSkge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmNhY2hlW3RoaXMubG9jYWxlXVtzaW5ndWxhcl07XG4gICAgICAgICAgICBzdHIgPSBlbnRyeVtxdWFudGl0eSA9PT0gMSA/ICdvbmUnIDogJ290aGVyJ107XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UndmUgb2JzZXJ2ZWQgYSBuZXcgc3RyaW5nLCB1cGRhdGUgdGhlIGxhbmd1YWdlIGZpbGUuXG4gICAgICAgIGlmICghdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1bc2luZ3VsYXJdICYmIHRoaXMudXBkYXRlRmlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVbdGhpcy5sb2NhbGVdW3Npbmd1bGFyXSA9IHtcbiAgICAgICAgICAgICAgICBvbmU6IHNpbmd1bGFyLFxuICAgICAgICAgICAgICAgIG90aGVyOiBwbHVyYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBpbmNsdWRlIHRoZSBjdXJyZW50IGRpcmVjdG9yeSBhbmQgbG9jYWxlLFxuICAgICAgICAgICAgLy8gc2luY2UgdGhlc2UgdmFsdWVzIGNvdWxkIGNoYW5nZSBiZWZvcmUgdGhlXG4gICAgICAgICAgICAvLyB3cml0ZSBpcyBwZXJmb3JtZWQuXG4gICAgICAgICAgICB0aGlzLl9lbnF1ZXVlV3JpdGUoe1xuICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogdGhpcy5kaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgICAgICAgICAgICBjYlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGEgJWQgcGxhY2Vob2xkZXIgaXMgcHJvdmlkZWQsIGFkZCBxdWFudGl0eVxuICAgICAgICAvLyB0byB0aGUgYXJndW1lbnRzIGV4cGFuZGVkIGJ5IHV0aWwuZm9ybWF0LlxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbc3RyXTtcbiAgICAgICAgaWYgKH5zdHIuaW5kZXhPZignJWQnKSlcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHF1YW50aXR5KTtcbiAgICAgICAgcmV0dXJuIHNoaW0uZm9ybWF0LmFwcGx5KHNoaW0uZm9ybWF0LCB2YWx1ZXMuY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gICAgc2V0TG9jYWxlKGxvY2FsZSkge1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB9XG4gICAgZ2V0TG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGU7XG4gICAgfVxuICAgIHVwZGF0ZUxvY2FsZShvYmopIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlW3RoaXMubG9jYWxlXSlcbiAgICAgICAgICAgIHRoaXMuX3JlYWRMb2NhbGVGaWxlKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlW3RoaXMubG9jYWxlXVtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3RhZ2dlZExpdGVyYWwocGFydHMsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0LCBpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgICAgIHN0ciArPSBwYXJ0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICclcyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fXy5hcHBseSh0aGlzLCBbc3RyXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmdzLCAxKSkpO1xuICAgIH1cbiAgICBfZW5xdWV1ZVdyaXRlKHdvcmspIHtcbiAgICAgICAgdGhpcy53cml0ZVF1ZXVlLnB1c2god29yayk7XG4gICAgICAgIGlmICh0aGlzLndyaXRlUXVldWUubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1dyaXRlUXVldWUoKTtcbiAgICB9XG4gICAgX3Byb2Nlc3NXcml0ZVF1ZXVlKCkge1xuICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHdvcmsgPSB0aGlzLndyaXRlUXVldWVbMF07XG4gICAgICAgIC8vIGRlc3RydWN0dXJlIHRoZSBlbnF1ZXVlZCB3b3JrLlxuICAgICAgICBjb25zdCBkaXJlY3RvcnkgPSB3b3JrLmRpcmVjdG9yeTtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gd29yay5sb2NhbGU7XG4gICAgICAgIGNvbnN0IGNiID0gd29yay5jYjtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VGaWxlID0gdGhpcy5fcmVzb2x2ZUxvY2FsZUZpbGUoZGlyZWN0b3J5LCBsb2NhbGUpO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkTG9jYWxlID0gSlNPTi5zdHJpbmdpZnkodGhpcy5jYWNoZVtsb2NhbGVdLCBudWxsLCAyKTtcbiAgICAgICAgc2hpbS5mcy53cml0ZUZpbGUobGFuZ3VhZ2VGaWxlLCBzZXJpYWxpemVkTG9jYWxlLCAndXRmLTgnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBfdGhpcy53cml0ZVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMud3JpdGVRdWV1ZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIF90aGlzLl9wcm9jZXNzV3JpdGVRdWV1ZSgpO1xuICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9yZWFkTG9jYWxlRmlsZSgpIHtcbiAgICAgICAgbGV0IGxvY2FsZUxvb2t1cCA9IHt9O1xuICAgICAgICBjb25zdCBsYW5ndWFnZUZpbGUgPSB0aGlzLl9yZXNvbHZlTG9jYWxlRmlsZSh0aGlzLmRpcmVjdG9yeSwgdGhpcy5sb2NhbGUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB1c2luZyBhIGJ1bmRsZXIgc3VjaCBhcyB3ZWJwYWNrLCByZWFkRmlsZVN5bmMgbWF5IG5vdCBiZSBkZWZpbmVkOlxuICAgICAgICAgICAgaWYgKHNoaW0uZnMucmVhZEZpbGVTeW5jKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlTG9va3VwID0gSlNPTi5wYXJzZShzaGltLmZzLnJlYWRGaWxlU3luYyhsYW5ndWFnZUZpbGUsICd1dGYtOCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9ICdzeW50YXggZXJyb3IgaW4gJyArIGxhbmd1YWdlRmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpXG4gICAgICAgICAgICAgICAgbG9jYWxlTG9va3VwID0ge307XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVbdGhpcy5sb2NhbGVdID0gbG9jYWxlTG9va3VwO1xuICAgIH1cbiAgICBfcmVzb2x2ZUxvY2FsZUZpbGUoZGlyZWN0b3J5LCBsb2NhbGUpIHtcbiAgICAgICAgbGV0IGZpbGUgPSBzaGltLnJlc29sdmUoZGlyZWN0b3J5LCAnLi8nLCBsb2NhbGUgKyAnLmpzb24nKTtcbiAgICAgICAgaWYgKHRoaXMuZmFsbGJhY2tUb0xhbmd1YWdlICYmICF0aGlzLl9maWxlRXhpc3RzU3luYyhmaWxlKSAmJiB+bG9jYWxlLmxhc3RJbmRleE9mKCdfJykpIHtcbiAgICAgICAgICAgIC8vIGF0dGVtcHQgZmFsbGJhY2sgdG8gbGFuZ3VhZ2Ugb25seVxuICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2VGaWxlID0gc2hpbS5yZXNvbHZlKGRpcmVjdG9yeSwgJy4vJywgbG9jYWxlLnNwbGl0KCdfJylbMF0gKyAnLmpzb24nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9maWxlRXhpc3RzU3luYyhsYW5ndWFnZUZpbGUpKVxuICAgICAgICAgICAgICAgIGZpbGUgPSBsYW5ndWFnZUZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfVxuICAgIF9maWxlRXhpc3RzU3luYyhmaWxlKSB7XG4gICAgICAgIHJldHVybiBzaGltLmV4aXN0cyhmaWxlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB5MThuJDEob3B0cywgX3NoaW0pIHtcbiAgICBzaGltID0gX3NoaW07XG4gICAgY29uc3QgeTE4biA9IG5ldyBZMThOKG9wdHMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIF9fOiB5MThuLl9fLmJpbmQoeTE4biksXG4gICAgICAgIF9fbjogeTE4bi5fX24uYmluZCh5MThuKSxcbiAgICAgICAgc2V0TG9jYWxlOiB5MThuLnNldExvY2FsZS5iaW5kKHkxOG4pLFxuICAgICAgICBnZXRMb2NhbGU6IHkxOG4uZ2V0TG9jYWxlLmJpbmQoeTE4biksXG4gICAgICAgIHVwZGF0ZUxvY2FsZTogeTE4bi51cGRhdGVMb2NhbGUuYmluZCh5MThuKSxcbiAgICAgICAgbG9jYWxlOiB5MThuLmxvY2FsZVxuICAgIH07XG59XG5cbnZhciBub2RlUGxhdGZvcm1TaGltID0ge1xuICAgIGZzOiB7XG4gICAgICAgIHJlYWRGaWxlU3luYzogZnMucmVhZEZpbGVTeW5jLFxuICAgICAgICB3cml0ZUZpbGU6IGZzLndyaXRlRmlsZVxuICAgIH0sXG4gICAgZm9ybWF0OiB1dGlsLmZvcm1hdCxcbiAgICByZXNvbHZlOiBwYXRoLnJlc29sdmUsXG4gICAgZXhpc3RzOiAoZmlsZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZzLnN0YXRTeW5jKGZpbGUpLmlzRmlsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbnN0IHkxOG4gPSAob3B0cykgPT4ge1xuICAgIHJldHVybiB5MThuJDEob3B0cywgbm9kZVBsYXRmb3JtU2hpbSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHkxOG47XG4iXSwibWFwcGluZ3MiOiJBQUFBLFlBQVk7O0FBRVosSUFBSUEsRUFBRSxHQUFHQyxPQUFPLENBQUMsSUFBSSxDQUFDO0FBQ3RCLElB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","map":{"version":3,"names":["fs","require","util","path","shim","Y18N","constructor","opts","directory","updateFiles","locale","fallbackToLanguage","cache","Object","create","writeQueue","__","args","arguments","_taggedLiteral","str","shift","cb","length","pop","_readLocaleFile","_enqueueWrite","format","apply","concat","__n","Array","prototype","slice","call","singular","plural","quantity","entry","one","other","values","indexOf","push","setLocale","getLocale","updateLocale","obj","key","hasOwnProperty","parts","forEach","part","i","arg","work","_processWriteQueue","_this","languageFile","_resolveLocaleFile","serializedLocale","JSON","stringify","writeFile","err","localeLookup","readFileSync","parse","SyntaxError","message","code","file","resolve","_fileExistsSync","lastIndexOf","split","exists","y18n$1","_shim","y18n","bind","nodePlatformShim","statSync","isFile","module","exports"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\y18n@5.0.8\\node_modules\\y18n\\build\\","sources":["index.cjs"],"sourcesContent":["'use strict';\n\nvar fs = require('fs');\nvar util = require('util');\nvar path = require('path');\n\nlet shim;\nclass Y18N {\n    constructor(opts) {\n        // configurable options.\n        opts = opts || {};\n        this.directory = opts.directory || './locales';\n        this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true;\n        this.locale = opts.locale || 'en';\n        this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true;\n        // internal stuff.\n        this.cache = Object.create(null);\n        this.writeQueue = [];\n    }\n    __(...args) {\n        if (typeof arguments[0] !== 'string') {\n            return this._taggedLiteral(arguments[0], ...arguments);\n        }\n        const str = args.shift();\n        let cb = function () { }; // start with noop.\n        if (typeof args[args.length - 1] === 'function')\n            cb = args.pop();\n        cb = cb || function () { }; // noop.\n        if (!this.cache[this.locale])\n            this._readLocaleFile();\n        // we've observed a new string, update the language file.\n        if (!this.cache[this.locale][str] && this.updateFiles) {\n            this.cache[this.locale][str] = str;\n            // include the current directory and locale,\n            // since these values could change before the\n            // write is performed.\n            this._enqueueWrite({\n                directory: this.directory,\n                locale: this.locale,\n                cb\n            });\n        }\n        else {\n            cb();\n        }\n        return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));\n    }\n    __n() {\n        const args = Array.prototype.slice.call(arguments);\n        const singular = args.shift();\n        const plural = args.shift();\n        const quantity = args.shift();\n        let cb = function () { }; // start with noop.\n        if (typeof args[args.length - 1] === 'function')\n            cb = args.pop();\n        if (!this.cache[this.locale])\n            this._readLocaleFile();\n        let str = quantity === 1 ? singular : plural;\n        if (this.cache[this.locale][singular]) {\n            const entry = this.cache[this.locale][singular];\n            str = entry[quantity === 1 ? 'one' : 'other'];\n        }\n        // we've observed a new string, update the language file.\n        if (!this.cache[this.locale][singular] && this.updateFiles) {\n            this.cache[this.locale][singular] = {\n                one: singular,\n                other: plural\n            };\n            // include the current directory and locale,\n            // since these values could change before the\n            // write is performed.\n            this._enqueueWrite({\n                directory: this.directory,\n                locale: this.locale,\n                cb\n            });\n        }\n        else {\n            cb();\n        }\n        // if a %d placeholder is provided, add quantity\n        // to the arguments expanded by util.format.\n        const values = [str];\n        if (~str.indexOf('%d'))\n            values.push(quantity);\n        return shim.format.apply(shim.format, values.concat(args));\n    }\n    setLocale(locale) {\n        this.locale = locale;\n    }\n    getLocale() {\n        return this.locale;\n    }\n    updateLocale(obj) {\n        if (!this.cache[this.locale])\n            this._readLocaleFile();\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                this.cache[this.locale][key] = obj[key];\n            }\n        }\n    }\n    _taggedLiteral(parts, ...args) {\n        let str = '';\n        parts.forEach(function (part, i) {\n            const arg = args[i + 1];\n            str += part;\n            if (typeof arg !== 'undefined') {\n                str += '%s';\n            }\n        });\n        return this.__.apply(this, [str].concat([].slice.call(args, 1)));\n    }\n    _enqueueWrite(work) {\n        this.writeQueue.push(work);\n        if (this.writeQueue.length === 1)\n            this._processWriteQueue();\n    }\n    _processWriteQueue() {\n        const _this = this;\n        const work = this.writeQueue[0];\n        // destructure the enqueued work.\n        const directory = work.directory;\n        const locale = work.locale;\n        const cb = work.cb;\n        const languageFile = this._resolveLocaleFile(directory, locale);\n        const serializedLocale = JSON.stringify(this.cache[locale], null, 2);\n        shim.fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {\n            _this.writeQueue.shift();\n            if (_this.writeQueue.length > 0)\n                _this._processWriteQueue();\n            cb(err);\n        });\n    }\n    _readLocaleFile() {\n        let localeLookup = {};\n        const languageFile = this._resolveLocaleFile(this.directory, this.locale);\n        try {\n            // When using a bundler such as webpack, readFileSync may not be defined:\n            if (shim.fs.readFileSync) {\n                localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, 'utf-8'));\n            }\n        }\n        catch (err) {\n            if (err instanceof SyntaxError) {\n                err.message = 'syntax error in ' + languageFile;\n            }\n            if (err.code === 'ENOENT')\n                localeLookup = {};\n            else\n                throw err;\n        }\n        this.cache[this.locale] = localeLookup;\n    }\n    _resolveLocaleFile(directory, locale) {\n        let file = shim.resolve(directory, './', locale + '.json');\n        if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {\n            // attempt fallback to language only\n            const languageFile = shim.resolve(directory, './', locale.split('_')[0] + '.json');\n            if (this._fileExistsSync(languageFile))\n                file = languageFile;\n        }\n        return file;\n    }\n    _fileExistsSync(file) {\n        return shim.exists(file);\n    }\n}\nfunction y18n$1(opts, _shim) {\n    shim = _shim;\n    const y18n = new Y18N(opts);\n    return {\n        __: y18n.__.bind(y18n),\n        __n: y18n.__n.bind(y18n),\n        setLocale: y18n.setLocale.bind(y18n),\n        getLocale: y18n.getLocale.bind(y18n),\n        updateLocale: y18n.updateLocale.bind(y18n),\n        locale: y18n.locale\n    };\n}\n\nvar nodePlatformShim = {\n    fs: {\n        readFileSync: fs.readFileSync,\n        writeFile: fs.writeFile\n    },\n    format: util.format,\n    resolve: path.resolve,\n    exists: (file) => {\n        try {\n            return fs.statSync(file).isFile();\n        }\n        catch (err) {\n            return false;\n        }\n    }\n};\n\nconst y18n = (opts) => {\n    return y18n$1(opts, nodePlatformShim);\n};\n\nmodule.exports = y18n;\n"],"mappings":"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"}},"mtime":1674865335277},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\yargs-parser@20.2.9\\\\node_modules\\\\yargs-parser\\\\build\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\yargs-parser@20.2.9\\\\node_modules\\\\yargs-parser\\\\build\\\\index.cjs\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"'use strict';\n\nvar util = require('util');\nvar fs = require('fs');\nvar path = require('path');\nfunction camelCase(str) {\n  const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();\n  if (!isCamelCase) {\n    str = str.toLowerCase();\n  }\n  if (str.indexOf('-') === -1 && str.indexOf('_') === -1) {\n    return str;\n  } else {\n    let camelcase = '';\n    let nextChrUpper = false;\n    const leadingHyphens = str.match(/^-+/);\n    for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {\n      let chr = str.charAt(i);\n      if (nextChrUpper) {\n        nextChrUpper = false;\n        chr = chr.toUpperCase();\n      }\n      if (i !== 0 && (chr === '-' || chr === '_')) {\n        nextChrUpper = true;\n      } else if (chr !== '-' && chr !== '_') {\n        camelcase += chr;\n      }\n    }\n    return camelcase;\n  }\n}\nfunction decamelize(str, joinString) {\n  const lowercase = str.toLowerCase();\n  joinString = joinString || '-';\n  let notCamelcase = '';\n  for (let i = 0; i < str.length; i++) {\n    const chrLower = lowercase.charAt(i);\n    const chrString = str.charAt(i);\n    if (chrLower !== chrString && i > 0) {\n      notCamelcase += `${joinString}${lowercase.charAt(i)}`;\n    } else {\n      notCamelcase += chrString;\n    }\n  }\n  return notCamelcase;\n}\nfunction looksLikeNumber(x) {\n  if (x === null || x === undefined) return false;\n  if (typeof x === 'number') return true;\n  if (/^0x[0-9a-f]+$/i.test(x)) return true;\n  if (/^0[^.]/.test(x)) return false;\n  return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n}\nfunction tokenizeArgString(argString) {\n  if (Array.isArray(argString)) {\n    return argString.map(e => typeof e !== 'string' ? e + '' : e);\n  }\n  argString = argString.trim();\n  let i = 0;\n  let prevC = null;\n  let c = null;\n  let opening = null;\n  const args = [];\n  for (let ii = 0; ii < argString.length; ii++) {\n    prevC = c;\n    c = argString.charAt(ii);\n    if (c === ' ' && !opening) {\n      if (!(prevC === ' ')) {\n        i++;\n      }\n      continue;\n    }\n    if (c === opening) {\n      opening = null;\n    } else if ((c === \"'\" || c === '\"') && !opening) {\n      opening = c;\n    }\n    if (!args[i]) args[i] = '';\n    args[i] += c;\n  }\n  return args;\n}\nvar DefaultValuesForTypeKey;\n(function (DefaultValuesForTypeKey) {\n  DefaultValuesForTypeKey[\"BOOLEAN\"] = \"boolean\";\n  DefaultValuesForTypeKey[\"STRING\"] = \"string\";\n  DefaultValuesForTypeKey[\"NUMBER\"] = \"number\";\n  DefaultValuesForTypeKey[\"ARRAY\"] = \"array\";\n})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));\nlet mixin;\nclass YargsParser {\n  constructor(_mixin) {\n    mixin = _mixin;\n  }\n  parse(argsInput, options) {\n    const opts = Object.assign({\n      alias: undefined,\n      array: undefined,\n      boolean: undefined,\n      config: undefined,\n      configObjects: undefined,\n      configuration: undefined,\n      coerce: undefined,\n      count: undefined,\n      default: undefined,\n      envPrefix: undefined,\n      narg: undefined,\n      normalize: undefined,\n      string: undefined,\n      number: undefined,\n      __: undefined,\n      key: undefined\n    }, options);\n    const args = tokenizeArgString(argsInput);\n    const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));\n    const configuration = Object.assign({\n      'boolean-negation': true,\n      'camel-case-expansion': true,\n      'combine-arrays': false,\n      'dot-notation': true,\n      'duplicate-arguments-array': true,\n      'flatten-duplicate-arrays': true,\n      'greedy-arrays': true,\n      'halt-at-non-option': false,\n      'nargs-eats-options': false,\n      'negation-prefix': 'no-',\n      'parse-numbers': true,\n      'parse-positional-numbers': true,\n      'populate--': false,\n      'set-placeholder-key': false,\n      'short-option-groups': true,\n      'strip-aliased': false,\n      'strip-dashed': false,\n      'unknown-options-as-args': false\n    }, opts.configuration);\n    const defaults = Object.assign(Object.create(null), opts.default);\n    const configObjects = opts.configObjects || [];\n    const envPrefix = opts.envPrefix;\n    const notFlagsOption = configuration['populate--'];\n    const notFlagsArgv = notFlagsOption ? '--' : '_';\n    const newAliases = Object.create(null);\n    const defaulted = Object.create(null);\n    const __ = opts.__ || mixin.format;\n    const flags = {\n      aliases: Object.create(null),\n      arrays: Object.create(null),\n      bools: Object.create(null),\n      strings: Object.create(null),\n      numbers: Object.create(null),\n      counts: Object.create(null),\n      normalize: Object.create(null),\n      configs: Object.create(null),\n      nargs: Object.create(null),\n      coercions: Object.create(null),\n      keys: []\n    };\n    const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/;\n    const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');\n    [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {\n      const key = typeof opt === 'object' ? opt.key : opt;\n      const assignment = Object.keys(opt).map(function (key) {\n        const arrayFlagKeys = {\n          boolean: 'bools',\n          string: 'strings',\n          number: 'numbers'\n        };\n        return arrayFlagKeys[key];\n      }).filter(Boolean).pop();\n      if (assignment) {\n        flags[assignment][key] = true;\n      }\n      flags.arrays[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {\n      flags.bools[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.string || []).filter(Boolean).forEach(function (key) {\n      flags.strings[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.number || []).filter(Boolean).forEach(function (key) {\n      flags.numbers[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.count || []).filter(Boolean).forEach(function (key) {\n      flags.counts[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {\n      flags.normalize[key] = true;\n      flags.keys.push(key);\n    });\n    if (typeof opts.narg === 'object') {\n      Object.entries(opts.narg).forEach(([key, value]) => {\n        if (typeof value === 'number') {\n          flags.nargs[key] = value;\n          flags.keys.push(key);\n        }\n      });\n    }\n    if (typeof opts.coerce === 'object') {\n      Object.entries(opts.coerce).forEach(([key, value]) => {\n        if (typeof value === 'function') {\n          flags.coercions[key] = value;\n          flags.keys.push(key);\n        }\n      });\n    }\n    if (typeof opts.config !== 'undefined') {\n      if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n        [].concat(opts.config).filter(Boolean).forEach(function (key) {\n          flags.configs[key] = true;\n        });\n      } else if (typeof opts.config === 'object') {\n        Object.entries(opts.config).forEach(([key, value]) => {\n          if (typeof value === 'boolean' || typeof value === 'function') {\n            flags.configs[key] = value;\n          }\n        });\n      }\n    }\n    extendAliases(opts.key, aliases, opts.default, flags.arrays);\n    Object.keys(defaults).forEach(function (key) {\n      (flags.aliases[key] || []).forEach(function (alias) {\n        defaults[alias] = defaults[key];\n      });\n    });\n    let error = null;\n    checkConfiguration();\n    let notFlags = [];\n    const argv = Object.assign(Object.create(null), {\n      _: []\n    });\n    const argvReturn = {};\n    for (let i = 0; i < args.length; i++) {\n      const arg = args[i];\n      const truncatedArg = arg.replace(/^-{3,}/, '---');\n      let broken;\n      let key;\n      let letters;\n      let m;\n      let next;\n      let value;\n      if (arg !== '--' && isUnknownOptionAsArg(arg)) {\n        pushPositional(arg);\n      } else if (truncatedArg.match(/---+(=|$)/)) {\n        pushPositional(arg);\n        continue;\n      } else if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {\n        m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/);\n        if (m !== null && Array.isArray(m) && m.length >= 3) {\n          if (checkAllAliases(m[1], flags.arrays)) {\n            i = eatArray(i, m[1], args, m[2]);\n          } else if (checkAllAliases(m[1], flags.nargs) !== false) {\n            i = eatNargs(i, m[1], args, m[2]);\n          } else {\n            setArg(m[1], m[2]);\n          }\n        }\n      } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n        m = arg.match(negatedBoolean);\n        if (m !== null && Array.isArray(m) && m.length >= 2) {\n          key = m[1];\n          setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);\n        }\n      } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-[^-]+/)) {\n        m = arg.match(/^--?(.+)/);\n        if (m !== null && Array.isArray(m) && m.length >= 2) {\n          key = m[1];\n          if (checkAllAliases(key, flags.arrays)) {\n            i = eatArray(i, key, args);\n          } else if (checkAllAliases(key, flags.nargs) !== false) {\n            i = eatNargs(i, key, args);\n          } else {\n            next = args[i + 1];\n            if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n              setArg(key, next);\n              i++;\n            } else if (/^(true|false)$/.test(next)) {\n              setArg(key, next);\n              i++;\n            } else {\n              setArg(key, defaultValue(key));\n            }\n          }\n        }\n      } else if (arg.match(/^-.\\..+=/)) {\n        m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n        if (m !== null && Array.isArray(m) && m.length >= 3) {\n          setArg(m[1], m[2]);\n        }\n      } else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n        next = args[i + 1];\n        m = arg.match(/^-(.\\..+)/);\n        if (m !== null && Array.isArray(m) && m.length >= 2) {\n          key = m[1];\n          if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n            setArg(key, next);\n            i++;\n          } else {\n            setArg(key, defaultValue(key));\n          }\n        }\n      } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n        letters = arg.slice(1, -1).split('');\n        broken = false;\n        for (let j = 0; j < letters.length; j++) {\n          next = arg.slice(j + 2);\n          if (letters[j + 1] && letters[j + 1] === '=') {\n            value = arg.slice(j + 3);\n            key = letters[j];\n            if (checkAllAliases(key, flags.arrays)) {\n              i = eatArray(i, key, args, value);\n            } else if (checkAllAliases(key, flags.nargs) !== false) {\n              i = eatNargs(i, key, args, value);\n            } else {\n              setArg(key, value);\n            }\n            broken = true;\n            break;\n          }\n          if (next === '-') {\n            setArg(letters[j], next);\n            continue;\n          }\n          if (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {\n            setArg(letters[j], next);\n            broken = true;\n            break;\n          }\n          if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n            setArg(letters[j], next);\n            broken = true;\n            break;\n          } else {\n            setArg(letters[j], defaultValue(letters[j]));\n          }\n        }\n        key = arg.slice(-1)[0];\n        if (!broken && key !== '-') {\n          if (checkAllAliases(key, flags.arrays)) {\n            i = eatArray(i, key, args);\n          } else if (checkAllAliases(key, flags.nargs) !== false) {\n            i = eatNargs(i, key, args);\n          } else {\n            next = args[i + 1];\n            if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n              setArg(key, next);\n              i++;\n            } else if (/^(true|false)$/.test(next)) {\n              setArg(key, next);\n              i++;\n            } else {\n              setArg(key, defaultValue(key));\n            }\n          }\n        }\n      } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {\n        key = arg.slice(1);\n        setArg(key, defaultValue(key));\n      } else if (arg === '--') {\n        notFlags = args.slice(i + 1);\n        break;\n      } else if (configuration['halt-at-non-option']) {\n        notFlags = args.slice(i);\n        break;\n      } else {\n        pushPositional(arg);\n      }\n    }\n    applyEnvVars(argv, true);\n    applyEnvVars(argv, false);\n    setConfig(argv);\n    setConfigObjects();\n    applyDefaultsAndAliases(argv, flags.aliases, defaults, true);\n    applyCoercions(argv);\n    if (configuration['set-placeholder-key']) setPlaceholderKeys(argv);\n    Object.keys(flags.counts).forEach(function (key) {\n      if (!hasKey(argv, key.split('.'))) setArg(key, 0);\n    });\n    if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];\n    notFlags.forEach(function (key) {\n      argv[notFlagsArgv].push(key);\n    });\n    if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n      Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n        delete argv[key];\n      });\n    }\n    if (configuration['strip-aliased']) {\n      [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n        if (configuration['camel-case-expansion'] && alias.includes('-')) {\n          delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];\n        }\n        delete argv[alias];\n      });\n    }\n    function pushPositional(arg) {\n      const maybeCoercedNumber = maybeCoerceNumber('_', arg);\n      if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {\n        argv._.push(maybeCoercedNumber);\n      }\n    }\n    function eatNargs(i, key, args, argAfterEqualSign) {\n      let ii;\n      let toEat = checkAllAliases(key, flags.nargs);\n      toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;\n      if (toEat === 0) {\n        if (!isUndefined(argAfterEqualSign)) {\n          error = Error(__('Argument unexpected for: %s', key));\n        }\n        setArg(key, defaultValue(key));\n        return i;\n      }\n      let available = isUndefined(argAfterEqualSign) ? 0 : 1;\n      if (configuration['nargs-eats-options']) {\n        if (args.length - (i + 1) + available < toEat) {\n          error = Error(__('Not enough arguments following: %s', key));\n        }\n        available = toEat;\n      } else {\n        for (ii = i + 1; ii < args.length; ii++) {\n          if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++;else break;\n        }\n        if (available < toEat) error = Error(__('Not enough arguments following: %s', key));\n      }\n      let consumed = Math.min(available, toEat);\n      if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n        setArg(key, argAfterEqualSign);\n        consumed--;\n      }\n      for (ii = i + 1; ii < consumed + i + 1; ii++) {\n        setArg(key, args[ii]);\n      }\n      return i + consumed;\n    }\n    function eatArray(i, key, args, argAfterEqualSign) {\n      let argsToSet = [];\n      let next = argAfterEqualSign || args[i + 1];\n      const nargsCount = checkAllAliases(key, flags.nargs);\n      if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {\n        argsToSet.push(true);\n      } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {\n        if (defaults[key] !== undefined) {\n          const defVal = defaults[key];\n          argsToSet = Array.isArray(defVal) ? defVal : [defVal];\n        }\n      } else {\n        if (!isUndefined(argAfterEqualSign)) {\n          argsToSet.push(processValue(key, argAfterEqualSign));\n        }\n        for (let ii = i + 1; ii < args.length; ii++) {\n          if (!configuration['greedy-arrays'] && argsToSet.length > 0 || nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount) break;\n          next = args[ii];\n          if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;\n          i = ii;\n          argsToSet.push(processValue(key, next));\n        }\n      }\n      if (typeof nargsCount === 'number' && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {\n        error = Error(__('Not enough arguments following: %s', key));\n      }\n      setArg(key, argsToSet);\n      return i;\n    }\n    function setArg(key, val) {\n      if (/-/.test(key) && configuration['camel-case-expansion']) {\n        const alias = key.split('.').map(function (prop) {\n          return camelCase(prop);\n        }).join('.');\n        addNewAlias(key, alias);\n      }\n      const value = processValue(key, val);\n      const splitKey = key.split('.');\n      setKey(argv, splitKey, value);\n      if (flags.aliases[key]) {\n        flags.aliases[key].forEach(function (x) {\n          const keyProperties = x.split('.');\n          setKey(argv, keyProperties, value);\n        });\n      }\n      if (splitKey.length > 1 && configuration['dot-notation']) {\n        (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n          let keyProperties = x.split('.');\n          const a = [].concat(splitKey);\n          a.shift();\n          keyProperties = keyProperties.concat(a);\n          if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {\n            setKey(argv, keyProperties, value);\n          }\n        });\n      }\n      if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n        const keys = [key].concat(flags.aliases[key] || []);\n        keys.forEach(function (key) {\n          Object.defineProperty(argvReturn, key, {\n            enumerable: true,\n            get() {\n              return val;\n            },\n            set(value) {\n              val = typeof value === 'string' ? mixin.normalize(value) : value;\n            }\n          });\n        });\n      }\n    }\n    function addNewAlias(key, alias) {\n      if (!(flags.aliases[key] && flags.aliases[key].length)) {\n        flags.aliases[key] = [alias];\n        newAliases[alias] = true;\n      }\n      if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n        addNewAlias(alias, key);\n      }\n    }\n    function processValue(key, val) {\n      if (typeof val === 'string' && (val[0] === \"'\" || val[0] === '\"') && val[val.length - 1] === val[0]) {\n        val = val.substring(1, val.length - 1);\n      }\n      if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n        if (typeof val === 'string') val = val === 'true';\n      }\n      let value = Array.isArray(val) ? val.map(function (v) {\n        return maybeCoerceNumber(key, v);\n      }) : maybeCoerceNumber(key, val);\n      if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n        value = increment();\n      }\n      if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n        if (Array.isArray(val)) value = val.map(val => {\n          return mixin.normalize(val);\n        });else value = mixin.normalize(val);\n      }\n      return value;\n    }\n    function maybeCoerceNumber(key, value) {\n      if (!configuration['parse-positional-numbers'] && key === '_') return value;\n      if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n        const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));\n        if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {\n          value = Number(value);\n        }\n      }\n      return value;\n    }\n    function setConfig(argv) {\n      const configLookup = Object.create(null);\n      applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n      Object.keys(flags.configs).forEach(function (configKey) {\n        const configPath = argv[configKey] || configLookup[configKey];\n        if (configPath) {\n          try {\n            let config = null;\n            const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);\n            const resolveConfig = flags.configs[configKey];\n            if (typeof resolveConfig === 'function') {\n              try {\n                config = resolveConfig(resolvedConfigPath);\n              } catch (e) {\n                config = e;\n              }\n              if (config instanceof Error) {\n                error = config;\n                return;\n              }\n            } else {\n              config = mixin.require(resolvedConfigPath);\n            }\n            setConfigObject(config);\n          } catch (ex) {\n            if (ex.name === 'PermissionDenied') error = ex;else if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));\n          }\n        }\n      });\n    }\n    function setConfigObject(config, prev) {\n      Object.keys(config).forEach(function (key) {\n        const value = config[key];\n        const fullKey = prev ? prev + '.' + key : key;\n        if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n          setConfigObject(value, fullKey);\n        } else {\n          if (!hasKey(argv, fullKey.split('.')) || checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays']) {\n            setArg(fullKey, value);\n          }\n        }\n      });\n    }\n    function setConfigObjects() {\n      if (typeof configObjects !== 'undefined') {\n        configObjects.forEach(function (configObject) {\n          setConfigObject(configObject);\n        });\n      }\n    }\n    function applyEnvVars(argv, configOnly) {\n      if (typeof envPrefix === 'undefined') return;\n      const prefix = typeof envPrefix === 'string' ? envPrefix : '';\n      const env = mixin.env();\n      Object.keys(env).forEach(function (envVar) {\n        if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n          const keys = envVar.split('__').map(function (key, i) {\n            if (i === 0) {\n              key = key.substring(prefix.length);\n            }\n            return camelCase(key);\n          });\n          if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && !hasKey(argv, keys)) {\n            setArg(keys.join('.'), env[envVar]);\n          }\n        }\n      });\n    }\n    function applyCoercions(argv) {\n      let coerce;\n      const applied = new Set();\n      Object.keys(argv).forEach(function (key) {\n        if (!applied.has(key)) {\n          coerce = checkAllAliases(key, flags.coercions);\n          if (typeof coerce === 'function') {\n            try {\n              const value = maybeCoerceNumber(key, coerce(argv[key]));\n              [].concat(flags.aliases[key] || [], key).forEach(ali => {\n                applied.add(ali);\n                argv[ali] = value;\n              });\n            } catch (err) {\n              error = err;\n            }\n          }\n        }\n      });\n    }\n    function setPlaceholderKeys(argv) {\n      flags.keys.forEach(key => {\n        if (~key.indexOf('.')) return;\n        if (typeof argv[key] === 'undefined') argv[key] = undefined;\n      });\n      return argv;\n    }\n    function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {\n      Object.keys(defaults).forEach(function (key) {\n        if (!hasKey(obj, key.split('.'))) {\n          setKey(obj, key.split('.'), defaults[key]);\n          if (canLog) defaulted[key] = true;\n          (aliases[key] || []).forEach(function (x) {\n            if (hasKey(obj, x.split('.'))) return;\n            setKey(obj, x.split('.'), defaults[key]);\n          });\n        }\n      });\n    }\n    function hasKey(obj, keys) {\n      let o = obj;\n      if (!configuration['dot-notation']) keys = [keys.join('.')];\n      keys.slice(0, -1).forEach(function (key) {\n        o = o[key] || {};\n      });\n      const key = keys[keys.length - 1];\n      if (typeof o !== 'object') return false;else return key in o;\n    }\n    function setKey(obj, keys, value) {\n      let o = obj;\n      if (!configuration['dot-notation']) keys = [keys.join('.')];\n      keys.slice(0, -1).forEach(function (key) {\n        key = sanitizeKey(key);\n        if (typeof o === 'object' && o[key] === undefined) {\n          o[key] = {};\n        }\n        if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n          if (Array.isArray(o[key])) {\n            o[key].push({});\n          } else {\n            o[key] = [o[key], {}];\n          }\n          o = o[key][o[key].length - 1];\n        } else {\n          o = o[key];\n        }\n      });\n      const key = sanitizeKey(keys[keys.length - 1]);\n      const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n      const isValueArray = Array.isArray(value);\n      let duplicate = configuration['duplicate-arguments-array'];\n      if (!duplicate && checkAllAliases(key, flags.nargs)) {\n        duplicate = true;\n        if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {\n          o[key] = undefined;\n        }\n      }\n      if (value === increment()) {\n        o[key] = increment(o[key]);\n      } else if (Array.isArray(o[key])) {\n        if (duplicate && isTypeArray && isValueArray) {\n          o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);\n        } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n          o[key] = value;\n        } else {\n          o[key] = o[key].concat([value]);\n        }\n      } else if (o[key] === undefined && isTypeArray) {\n        o[key] = isValueArray ? value : [value];\n      } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {\n        o[key] = [o[key], value];\n      } else {\n        o[key] = value;\n      }\n    }\n    function extendAliases(...args) {\n      args.forEach(function (obj) {\n        Object.keys(obj || {}).forEach(function (key) {\n          if (flags.aliases[key]) return;\n          flags.aliases[key] = [].concat(aliases[key] || []);\n          flags.aliases[key].concat(key).forEach(function (x) {\n            if (/-/.test(x) && configuration['camel-case-expansion']) {\n              const c = camelCase(x);\n              if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                flags.aliases[key].push(c);\n                newAliases[c] = true;\n              }\n            }\n          });\n          flags.aliases[key].concat(key).forEach(function (x) {\n            if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n              const c = decamelize(x, '-');\n              if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                flags.aliases[key].push(c);\n                newAliases[c] = true;\n              }\n            }\n          });\n          flags.aliases[key].forEach(function (x) {\n            flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n              return x !== y;\n            }));\n          });\n        });\n      });\n    }\n    function checkAllAliases(key, flag) {\n      const toCheck = [].concat(flags.aliases[key] || [], key);\n      const keys = Object.keys(flag);\n      const setAlias = toCheck.find(key => keys.includes(key));\n      return setAlias ? flag[setAlias] : false;\n    }\n    function hasAnyFlag(key) {\n      const flagsKeys = Object.keys(flags);\n      const toCheck = [].concat(flagsKeys.map(k => flags[k]));\n      return toCheck.some(function (flag) {\n        return Array.isArray(flag) ? flag.includes(key) : flag[key];\n      });\n    }\n    function hasFlagsMatching(arg, ...patterns) {\n      const toCheck = [].concat(...patterns);\n      return toCheck.some(function (pattern) {\n        const match = arg.match(pattern);\n        return match && hasAnyFlag(match[1]);\n      });\n    }\n    function hasAllShortFlags(arg) {\n      if (arg.match(negative) || !arg.match(/^-[^-]+/)) {\n        return false;\n      }\n      let hasAllFlags = true;\n      let next;\n      const letters = arg.slice(1).split('');\n      for (let j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2);\n        if (!hasAnyFlag(letters[j])) {\n          hasAllFlags = false;\n          break;\n        }\n        if (letters[j + 1] && letters[j + 1] === '=' || next === '-' || /[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          break;\n        }\n      }\n      return hasAllFlags;\n    }\n    function isUnknownOptionAsArg(arg) {\n      return configuration['unknown-options-as-args'] && isUnknownOption(arg);\n    }\n    function isUnknownOption(arg) {\n      arg = arg.replace(/^-{3,}/, '--');\n      if (arg.match(negative)) {\n        return false;\n      }\n      if (hasAllShortFlags(arg)) {\n        return false;\n      }\n      const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/;\n      const normalFlag = /^-+([^=]+?)$/;\n      const flagEndingInHyphen = /^-+([^=]+?)-$/;\n      const flagEndingInDigits = /^-+([^=]+?\\d+)$/;\n      const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/;\n      return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);\n    }\n    function defaultValue(key) {\n      if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {\n        return defaults[key];\n      } else {\n        return defaultForType(guessType(key));\n      }\n    }\n    function defaultForType(type) {\n      const def = {\n        [DefaultValuesForTypeKey.BOOLEAN]: true,\n        [DefaultValuesForTypeKey.STRING]: '',\n        [DefaultValuesForTypeKey.NUMBER]: undefined,\n        [DefaultValuesForTypeKey.ARRAY]: []\n      };\n      return def[type];\n    }\n    function guessType(key) {\n      let type = DefaultValuesForTypeKey.BOOLEAN;\n      if (checkAllAliases(key, flags.strings)) type = DefaultValuesForTypeKey.STRING;else if (checkAllAliases(key, flags.numbers)) type = DefaultValuesForTypeKey.NUMBER;else if (checkAllAliases(key, flags.bools)) type = DefaultValuesForTypeKey.BOOLEAN;else if (checkAllAliases(key, flags.arrays)) type = DefaultValuesForTypeKey.ARRAY;\n      return type;\n    }\n    function isUndefined(num) {\n      return num === undefined;\n    }\n    function checkConfiguration() {\n      Object.keys(flags.counts).find(key => {\n        if (checkAllAliases(key, flags.arrays)) {\n          error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));\n          return true;\n        } else if (checkAllAliases(key, flags.nargs)) {\n          error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));\n          return true;\n        }\n        return false;\n      });\n    }\n    return {\n      aliases: Object.assign({}, flags.aliases),\n      argv: Object.assign(argvReturn, argv),\n      configuration: configuration,\n      defaulted: Object.assign({}, defaulted),\n      error: error,\n      newAliases: Object.assign({}, newAliases)\n    };\n  }\n}\nfunction combineAliases(aliases) {\n  const aliasArrays = [];\n  const combined = Object.create(null);\n  let change = true;\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push([].concat(aliases[key], key));\n  });\n  while (change) {\n    change = false;\n    for (let i = 0; i < aliasArrays.length; i++) {\n      for (let ii = i + 1; ii < aliasArrays.length; ii++) {\n        const intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1;\n        });\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n          aliasArrays.splice(ii, 1);\n          change = true;\n          break;\n        }\n      }\n    }\n  }\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i;\n    });\n    const lastAlias = aliasArray.pop();\n    if (lastAlias !== undefined && typeof lastAlias === 'string') {\n      combined[lastAlias] = aliasArray;\n    }\n  });\n  return combined;\n}\nfunction increment(orig) {\n  return orig !== undefined ? orig + 1 : 1;\n}\nfunction sanitizeKey(key) {\n  if (key === '__proto__') return '___proto___';\n  return key;\n}\nconst minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 10;\nif (process && process.version) {\n  const major = Number(process.version.match(/v([^.]+)/)[1]);\n  if (major < minNodeVersion) {\n    throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);\n  }\n}\nconst env = process ? process.env : {};\nconst parser = new YargsParser({\n  cwd: process.cwd,\n  env: () => {\n    return env;\n  },\n  format: util.format,\n  normalize: path.normalize,\n  resolve: path.resolve,\n  require: path => {\n    if (typeof require !== 'undefined') {\n      return require(path);\n    } else if (path.match(/\\.json$/)) {\n      return fs.readFileSync(path, 'utf8');\n    } else {\n      throw Error('only .json config files are supported in ESM');\n    }\n  }\n});\nconst yargsParser = function Parser(args, opts) {\n  const result = parser.parse(args.slice(), opts);\n  return result.argv;\n};\nyargsParser.detailed = function (args, opts) {\n  return parser.parse(args.slice(), opts);\n};\nyargsParser.camelCase = camelCase;\nyargsParser.decamelize = decamelize;\nyargsParser.looksLikeNumber = looksLikeNumber;\nmodule.exports = yargsParser;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsImZzIiwicGF0aCIsImNhbWVsQ2FzZSIsInN0ciIsImlzQ2FtZWxDYXNlIiwidG9Mb3dlckNhc2UiLCJ0b1VwcGVyQ2FzZSIsImluZGV4T2YiLCJjYW1lbGNhc2UiLCJuZXh0Q2hyVXBwZXIiLCJsZWFkaW5nSHlwaGVucyIsIm1hdGNoIiwiaSIsImxlbmd0aCIsImNociIsImNoYXJBdCIsImRlY2FtZWxpemUiLCJqb2luU3RyaW5nIiwibG93ZXJjYXNlIiwibm90Q2FtZWxjYXNlIiwiY2hyTG93ZXIiLCJjaHJTdHJpbmciLCJsb29rc0xpa2VOdW1iZXIiLCJ4IiwidW5kZWZpbmVkIiwidGVzdCIsInRva2VuaXplQXJnU3RyaW5nIiwiYXJnU3RyaW5nIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiZSIsInRyaW0iLCJwcmV2QyIsImMiLCJvcGVuaW5nIiwiYXJncyIsImlpIiwiRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXkiLCJtaXhpbiIsIllhcmdzUGFyc2VyIiwiY29uc3RydWN0b3IiLCJfbWl4aW4iLCJwYXJzZSIsImFyZ3NJbnB1dCIsIm9wdGlvbnMiLCJvcHRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYWxpYXMiLCJhcnJheSIsImJvb2xlYW4iLCJjb25maWciLCJjb25maWdPYmplY3RzIiwiY29uZmlndXJhdGlvbiIsImNvZXJjZSIsImNvdW50IiwiZGVmYXVsdCIsImVudlByZWZpeCIsIm5hcmciLCJub3JtYWxpemUiLCJzdHJpbmciLCJudW1iZXIiLCJfXyIsImtleSIsImFsaWFzZXMiLCJjb21iaW5lQWxpYXNlcyIsImNyZWF0ZSIsImRlZmF1bHRzIiwibm90RmxhZ3NPcHRpb24iLCJub3RGbGFnc0FyZ3YiLCJuZXdBbGlhc2VzIiwiZGVmYXVsdGVkIiwiZm9ybWF0IiwiZmxhZ3MiLCJhcnJheXMiLCJib29scyIsInN0cmluZ3MiLCJudW1iZXJzIiwiY291bnRzIiwiY29uZmlncyIsIm5hcmdzIiwiY29lcmNpb25zIiwia2V5cyIsIm5lZ2F0aXZlIiwibmVnYXRlZEJvb2xlYW4iLCJSZWdFeHAiLCJjb25jYXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZm9yRWFjaCIsIm9wdCIsImFzc2lnbm1lbnQiLCJhcnJheUZsYWdLZXlzIiwicG9wIiwicHVzaCIsImVudHJpZXMiLCJ2YWx1ZSIsImV4dGVuZEFsaWFzZXMiLCJlcnJvciIsImNoZWNrQ29uZmlndXJhdGlvbiIsIm5vdEZsYWdzIiwiYXJndiIsIl8iLCJhcmd2UmV0dXJuIiwiYXJnIiwidHJ1bmNhdGVkQXJnIiwicmVwbGFjZSIsImJyb2tlbiIsImxldHRlcnMiLCJtIiwibmV4dCIsImlzVW5rbm93bk9wdGlvbkFzQXJnIiwicHVzaFBvc2l0aW9uYWwiLCJjaGVja0FsbEFsaWFzZXMiLCJlYXRBcnJheSIsImVhdE5hcmdzIiwic2V0QXJnIiwiZGVmYXVsdFZhbHVlIiwic2xpY2UiLCJzcGxpdCIsImoiLCJhcHBseUVudlZhcnMiLCJzZXRDb25maWciLCJzZXRDb25maWdPYmplY3RzIiwiYXBwbHlEZWZhdWx0c0FuZEFsaWFzZXMiLCJhcHBseUNvZXJjaW9ucyIsInNldFBsYWNlaG9sZGVyS2V5cyIsImhhc0tleSIsImluY2x1ZGVzIiwiayIsInByb3AiLCJqb2luIiwibWF5YmVDb2VyY2VkTnVtYmVyIiwibWF5YmVDb2VyY2VOdW1iZXIiLCJhcmdBZnRlckVxdWFsU2lnbiIsInRvRWF0IiwiaXNOYU4iLCJpc1VuZGVmaW5lZCIsIkVycm9yIiwiYXZhaWxhYmxlIiwiY29uc3VtZWQiLCJNYXRoIiwibWluIiwiYXJnc1RvU2V0IiwibmFyZ3NDb3VudCIsImRlZlZhbCIsInByb2Nlc3NWYWx1ZSIsInZhbCIsImFkZE5ld0FsaWFzIiwic3BsaXRLZXkiLCJzZXRLZXkiLCJrZXlQcm9wZXJ0aWVzIiwiYSIsInNoaWZ0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2V0Iiwic3Vic3RyaW5nIiwidiIsImluY3JlbWVudCIsInNob3VsZENvZXJjZU51bWJlciIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJmbG9vciIsInBhcnNlRmxvYXQiLCJjb25maWdMb29rdXAiLCJjb25maWdLZXkiLCJjb25maWdQYXRoIiwicmVzb2x2ZWRDb25maWdQYXRoIiwicmVzb2x2ZSIsImN3ZCIsInJlc29sdmVDb25maWciLCJzZXRDb25maWdPYmplY3QiLCJleCIsIm5hbWUiLCJwcmV2IiwiZnVsbEtleSIsImNvbmZpZ09iamVjdCIsImNvbmZpZ09ubHkiLCJwcmVmaXgiLCJlbnYiLCJlbnZWYXIiLCJsYXN0SW5kZXhPZiIsImFwcGxpZWQiLCJTZXQiLCJoYXMiLCJhbGkiLCJhZGQiLCJlcnIiLCJvYmoiLCJjYW5Mb2ciLCJvIiwic2FuaXRpemVLZXkiLCJpc1R5cGVBcnJheSIsImlzVmFsdWVBcnJheSIsImR1cGxpY2F0ZSIsInkiLCJmbGFnIiwidG9DaGVjayIsInNldEFsaWFzIiwiZmluZCIsImhhc0FueUZsYWciLCJmbGFnc0tleXMiLCJzb21lIiwiaGFzRmxhZ3NNYXRjaGluZyIsInBhdHRlcm5zIiwicGF0dGVybiIsImhhc0FsbFNob3J0RmxhZ3MiLCJoYXNBbGxGbGFncyIsImlzVW5rbm93bk9wdGlvbiIsImZsYWdXaXRoRXF1YWxzIiwibm9ybWFsRmxhZyIsImZsYWdFbmRpbmdJbkh5cGhlbiIsImZsYWdFbmRpbmdJbkRpZ2l0cyIsImZsYWdFbmRpbmdJbk5vbldvcmRDaGFyYWN0ZXJzIiwiZGVmYXVsdEZvclR5cGUiLCJndWVzc1R5cGUiLCJ0eXBlIiwiZGVmIiwiQk9PTEVBTiIsIlNUUklORyIsIk5VTUJFUiIsIkFSUkFZIiwibnVtIiwiYWxpYXNBcnJheXMiLCJjb21iaW5lZCIsImNoYW5nZSIsImludGVyc2VjdCIsInNwbGljZSIsImFsaWFzQXJyYXkiLCJzZWxmIiwibGFzdEFsaWFzIiwib3JpZyIsIm1pbk5vZGVWZXJzaW9uIiwicHJvY2VzcyIsIllBUkdTX01JTl9OT0RFX1ZFUlNJT04iLCJ2ZXJzaW9uIiwibWFqb3IiLCJwYXJzZXIiLCJyZWFkRmlsZVN5bmMiLCJ5YXJnc1BhcnNlciIsIlBhcnNlciIsInJlc3VsdCIsImRldGFpbGVkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiQzpcXGNvZGVcXEZsdWlkRnJhbWV3b3JrNVxcbm9kZV9tb2R1bGVzXFwucG5wbVxceWFyZ3MtcGFyc2VyQDIwLjIuOVxcbm9kZV9tb2R1bGVzXFx5YXJncy1wYXJzZXJcXGJ1aWxkXFwiLCJzb3VyY2VzIjpbImluZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5mdW5jdGlvbiBjYW1lbENhc2Uoc3RyKSB7XG4gICAgY29uc3QgaXNDYW1lbENhc2UgPSBzdHIgIT09IHN0ci50b0xvd2VyQ2FzZSgpICYmIHN0ciAhPT0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKCFpc0NhbWVsQ2FzZSkge1xuICAgICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKHN0ci5pbmRleE9mKCctJykgPT09IC0xICYmIHN0ci5pbmRleE9mKCdfJykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgY2FtZWxjYXNlID0gJyc7XG4gICAgICAgIGxldCBuZXh0Q2hyVXBwZXIgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbGVhZGluZ0h5cGhlbnMgPSBzdHIubWF0Y2goL14tKy8pO1xuICAgICAgICBmb3IgKGxldCBpID0gbGVhZGluZ0h5cGhlbnMgPyBsZWFkaW5nSHlwaGVuc1swXS5sZW5ndGggOiAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hyID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChuZXh0Q2hyVXBwZXIpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q2hyVXBwZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjaHIgPSBjaHIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9PSAwICYmIChjaHIgPT09ICctJyB8fCBjaHIgPT09ICdfJykpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q2hyVXBwZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hyICE9PSAnLScgJiYgY2hyICE9PSAnXycpIHtcbiAgICAgICAgICAgICAgICBjYW1lbGNhc2UgKz0gY2hyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW1lbGNhc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVjYW1lbGl6ZShzdHIsIGpvaW5TdHJpbmcpIHtcbiAgICBjb25zdCBsb3dlcmNhc2UgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICBqb2luU3RyaW5nID0gam9pblN0cmluZyB8fCAnLSc7XG4gICAgbGV0IG5vdENhbWVsY2FzZSA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNockxvd2VyID0gbG93ZXJjYXNlLmNoYXJBdChpKTtcbiAgICAgICAgY29uc3QgY2hyU3RyaW5nID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGNockxvd2VyICE9PSBjaHJTdHJpbmcgJiYgaSA+IDApIHtcbiAgICAgICAgICAgIG5vdENhbWVsY2FzZSArPSBgJHtqb2luU3RyaW5nfSR7bG93ZXJjYXNlLmNoYXJBdChpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm90Q2FtZWxjYXNlICs9IGNoclN0cmluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm90Q2FtZWxjYXNlO1xufVxuZnVuY3Rpb24gbG9va3NMaWtlTnVtYmVyKHgpIHtcbiAgICBpZiAoeCA9PT0gbnVsbCB8fCB4ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoL14weFswLTlhLWZdKyQvaS50ZXN0KHgpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoL14wW14uXS8udGVzdCh4KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAvXlstXT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKGVbLStdP1xcZCspPyQvLnRlc3QoeCk7XG59XG5cbmZ1bmN0aW9uIHRva2VuaXplQXJnU3RyaW5nKGFyZ1N0cmluZykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIGFyZ1N0cmluZy5tYXAoZSA9PiB0eXBlb2YgZSAhPT0gJ3N0cmluZycgPyBlICsgJycgOiBlKTtcbiAgICB9XG4gICAgYXJnU3RyaW5nID0gYXJnU3RyaW5nLnRyaW0oKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IHByZXZDID0gbnVsbDtcbiAgICBsZXQgYyA9IG51bGw7XG4gICAgbGV0IG9wZW5pbmcgPSBudWxsO1xuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgYXJnU3RyaW5nLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBwcmV2QyA9IGM7XG4gICAgICAgIGMgPSBhcmdTdHJpbmcuY2hhckF0KGlpKTtcbiAgICAgICAgaWYgKGMgPT09ICcgJyAmJiAhb3BlbmluZykge1xuICAgICAgICAgICAgaWYgKCEocHJldkMgPT09ICcgJykpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gb3BlbmluZykge1xuICAgICAgICAgICAgb3BlbmluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgPT09IFwiJ1wiIHx8IGMgPT09ICdcIicpICYmICFvcGVuaW5nKSB7XG4gICAgICAgICAgICBvcGVuaW5nID0gYztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZ3NbaV0pXG4gICAgICAgICAgICBhcmdzW2ldID0gJyc7XG4gICAgICAgIGFyZ3NbaV0gKz0gYztcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG59XG5cbnZhciBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleTtcbihmdW5jdGlvbiAoRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXkpIHtcbiAgICBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleVtcIkJPT0xFQU5cIl0gPSBcImJvb2xlYW5cIjtcbiAgICBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleVtcIlNUUklOR1wiXSA9IFwic3RyaW5nXCI7XG4gICAgRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXlbXCJOVU1CRVJcIl0gPSBcIm51bWJlclwiO1xuICAgIERlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5W1wiQVJSQVlcIl0gPSBcImFycmF5XCI7XG59KShEZWZhdWx0VmFsdWVzRm9yVHlwZUtleSB8fCAoRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXkgPSB7fSkpO1xuXG5sZXQgbWl4aW47XG5jbGFzcyBZYXJnc1BhcnNlciB7XG4gICAgY29uc3RydWN0b3IoX21peGluKSB7XG4gICAgICAgIG1peGluID0gX21peGluO1xuICAgIH1cbiAgICBwYXJzZShhcmdzSW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgYWxpYXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFycmF5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBib29sZWFuOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25maWc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbmZpZ09iamVjdHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvZXJjZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY291bnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVudlByZWZpeDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbmFyZzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbm9ybWFsaXplOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdHJpbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG51bWJlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX186IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGtleTogdW5kZWZpbmVkXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBhcmdzID0gdG9rZW5pemVBcmdTdHJpbmcoYXJnc0lucHV0KTtcbiAgICAgICAgY29uc3QgYWxpYXNlcyA9IGNvbWJpbmVBbGlhc2VzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgb3B0cy5hbGlhcykpO1xuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAnYm9vbGVhbi1uZWdhdGlvbic6IHRydWUsXG4gICAgICAgICAgICAnY2FtZWwtY2FzZS1leHBhbnNpb24nOiB0cnVlLFxuICAgICAgICAgICAgJ2NvbWJpbmUtYXJyYXlzJzogZmFsc2UsXG4gICAgICAgICAgICAnZG90LW5vdGF0aW9uJzogdHJ1ZSxcbiAgICAgICAgICAgICdkdXBsaWNhdGUtYXJndW1lbnRzLWFycmF5JzogdHJ1ZSxcbiAgICAgICAgICAgICdmbGF0dGVuLWR1cGxpY2F0ZS1hcnJheXMnOiB0cnVlLFxuICAgICAgICAgICAgJ2dyZWVkeS1hcnJheXMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhbHQtYXQtbm9uLW9wdGlvbic6IGZhbHNlLFxuICAgICAgICAgICAgJ25hcmdzLWVhdHMtb3B0aW9ucyc6IGZhbHNlLFxuICAgICAgICAgICAgJ25lZ2F0aW9uLXByZWZpeCc6ICduby0nLFxuICAgICAgICAgICAgJ3BhcnNlLW51bWJlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ3BhcnNlLXBvc2l0aW9uYWwtbnVtYmVycyc6IHRydWUsXG4gICAgICAgICAgICAncG9wdWxhdGUtLSc6IGZhbHNlLFxuICAgICAgICAgICAgJ3NldC1wbGFjZWhvbGRlci1rZXknOiBmYWxzZSxcbiAgICAgICAgICAgICdzaG9ydC1vcHRpb24tZ3JvdXBzJzogdHJ1ZSxcbiAgICAgICAgICAgICdzdHJpcC1hbGlhc2VkJzogZmFsc2UsXG4gICAgICAgICAgICAnc3RyaXAtZGFzaGVkJzogZmFsc2UsXG4gICAgICAgICAgICAndW5rbm93bi1vcHRpb25zLWFzLWFyZ3MnOiBmYWxzZVxuICAgICAgICB9LCBvcHRzLmNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgb3B0cy5kZWZhdWx0KTtcbiAgICAgICAgY29uc3QgY29uZmlnT2JqZWN0cyA9IG9wdHMuY29uZmlnT2JqZWN0cyB8fCBbXTtcbiAgICAgICAgY29uc3QgZW52UHJlZml4ID0gb3B0cy5lbnZQcmVmaXg7XG4gICAgICAgIGNvbnN0IG5vdEZsYWdzT3B0aW9uID0gY29uZmlndXJhdGlvblsncG9wdWxhdGUtLSddO1xuICAgICAgICBjb25zdCBub3RGbGFnc0FyZ3YgPSBub3RGbGFnc09wdGlvbiA/ICctLScgOiAnXyc7XG4gICAgICAgIGNvbnN0IG5ld0FsaWFzZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjb25zdCBkZWZhdWx0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjb25zdCBfXyA9IG9wdHMuX18gfHwgbWl4aW4uZm9ybWF0O1xuICAgICAgICBjb25zdCBmbGFncyA9IHtcbiAgICAgICAgICAgIGFsaWFzZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBhcnJheXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBib29sczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgIHN0cmluZ3M6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBudW1iZXJzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgY291bnRzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgbm9ybWFsaXplOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgY29uZmlnczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgIG5hcmdzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgY29lcmNpb25zOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAga2V5czogW11cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbmVnYXRpdmUgPSAvXi0oWzAtOV0rKFxcLlswLTldKyk/fFxcLlswLTldKykkLztcbiAgICAgICAgY29uc3QgbmVnYXRlZEJvb2xlYW4gPSBuZXcgUmVnRXhwKCdeLS0nICsgY29uZmlndXJhdGlvblsnbmVnYXRpb24tcHJlZml4J10gKyAnKC4rKScpO1xuICAgICAgICBbXS5jb25jYXQob3B0cy5hcnJheSB8fCBbXSkuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdHlwZW9mIG9wdCA9PT0gJ29iamVjdCcgPyBvcHQua2V5IDogb3B0O1xuICAgICAgICAgICAgY29uc3QgYXNzaWdubWVudCA9IE9iamVjdC5rZXlzKG9wdCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheUZsYWdLZXlzID0ge1xuICAgICAgICAgICAgICAgICAgICBib29sZWFuOiAnYm9vbHMnLFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmc6ICdzdHJpbmdzJyxcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyOiAnbnVtYmVycydcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheUZsYWdLZXlzW2tleV07XG4gICAgICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbikucG9wKCk7XG4gICAgICAgICAgICBpZiAoYXNzaWdubWVudCkge1xuICAgICAgICAgICAgICAgIGZsYWdzW2Fzc2lnbm1lbnRdW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhZ3MuYXJyYXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgZmxhZ3Mua2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBbXS5jb25jYXQob3B0cy5ib29sZWFuIHx8IFtdKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBmbGFncy5ib29sc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIGZsYWdzLmtleXMucHVzaChrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgW10uY29uY2F0KG9wdHMuc3RyaW5nIHx8IFtdKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBmbGFncy5zdHJpbmdzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgZmxhZ3Mua2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBbXS5jb25jYXQob3B0cy5udW1iZXIgfHwgW10pLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGZsYWdzLm51bWJlcnNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICBmbGFncy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFtdLmNvbmNhdChvcHRzLmNvdW50IHx8IFtdKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBmbGFncy5jb3VudHNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICBmbGFncy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFtdLmNvbmNhdChvcHRzLm5vcm1hbGl6ZSB8fCBbXSkuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgZmxhZ3Mubm9ybWFsaXplW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgZmxhZ3Mua2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMubmFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG9wdHMubmFyZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MubmFyZ3Nba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdHMuY29lcmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMob3B0cy5jb2VyY2UpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY29lcmNpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3Mua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmNvbmZpZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdHMuY29uZmlnKSB8fCB0eXBlb2Ygb3B0cy5jb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgW10uY29uY2F0KG9wdHMuY29uZmlnKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNvbmZpZ3Nba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0cy5jb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMob3B0cy5jb25maWcpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFncy5jb25maWdzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGV4dGVuZEFsaWFzZXMob3B0cy5rZXksIGFsaWFzZXMsIG9wdHMuZGVmYXVsdCwgZmxhZ3MuYXJyYXlzKTtcbiAgICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgKGZsYWdzLmFsaWFzZXNba2V5XSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0c1thbGlhc10gPSBkZWZhdWx0c1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgICBjaGVja0NvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgbGV0IG5vdEZsYWdzID0gW107XG4gICAgICAgIGNvbnN0IGFyZ3YgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHsgXzogW10gfSk7XG4gICAgICAgIGNvbnN0IGFyZ3ZSZXR1cm4gPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgICAgICAgICAgY29uc3QgdHJ1bmNhdGVkQXJnID0gYXJnLnJlcGxhY2UoL14tezMsfS8sICctLS0nKTtcbiAgICAgICAgICAgIGxldCBicm9rZW47XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgbGV0IGxldHRlcnM7XG4gICAgICAgICAgICBsZXQgbTtcbiAgICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgaWYgKGFyZyAhPT0gJy0tJyAmJiBpc1Vua25vd25PcHRpb25Bc0FyZyhhcmcpKSB7XG4gICAgICAgICAgICAgICAgcHVzaFBvc2l0aW9uYWwoYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRydW5jYXRlZEFyZy5tYXRjaCgvLS0tKyg9fCQpLykpIHtcbiAgICAgICAgICAgICAgICBwdXNoUG9zaXRpb25hbChhcmcpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJnLm1hdGNoKC9eLS0uKz0vKSB8fCAoIWNvbmZpZ3VyYXRpb25bJ3Nob3J0LW9wdGlvbi1ncm91cHMnXSAmJiBhcmcubWF0Y2goL14tLis9LykpKSB7XG4gICAgICAgICAgICAgICAgbSA9IGFyZy5tYXRjaCgvXi0tPyhbXj1dKyk9KFtcXHNcXFNdKikkLyk7XG4gICAgICAgICAgICAgICAgaWYgKG0gIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheShtKSAmJiBtLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0FsbEFsaWFzZXMobVsxXSwgZmxhZ3MuYXJyYXlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGVhdEFycmF5KGksIG1bMV0sIGFyZ3MsIG1bMl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrQWxsQWxpYXNlcyhtWzFdLCBmbGFncy5uYXJncykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZWF0TmFyZ3MoaSwgbVsxXSwgYXJncywgbVsyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcobVsxXSwgbVsyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmcubWF0Y2gobmVnYXRlZEJvb2xlYW4pICYmIGNvbmZpZ3VyYXRpb25bJ2Jvb2xlYW4tbmVnYXRpb24nXSkge1xuICAgICAgICAgICAgICAgIG0gPSBhcmcubWF0Y2gobmVnYXRlZEJvb2xlYW4pO1xuICAgICAgICAgICAgICAgIGlmIChtICE9PSBudWxsICYmIEFycmF5LmlzQXJyYXkobSkgJiYgbS5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBtWzFdO1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpID8gW2ZhbHNlXSA6IGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmcubWF0Y2goL14tLS4rLykgfHwgKCFjb25maWd1cmF0aW9uWydzaG9ydC1vcHRpb24tZ3JvdXBzJ10gJiYgYXJnLm1hdGNoKC9eLVteLV0rLykpKSB7XG4gICAgICAgICAgICAgICAgbSA9IGFyZy5tYXRjaCgvXi0tPyguKykvKTtcbiAgICAgICAgICAgICAgICBpZiAobSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KG0pICYmIG0ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gbVsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmFycmF5cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBlYXRBcnJheShpLCBrZXksIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm5hcmdzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBlYXROYXJncyhpLCBrZXksIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGFyZ3NbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCAmJiAoIW5leHQubWF0Y2goL14tLykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Lm1hdGNoKG5lZ2F0aXZlKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYm9vbHMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXih0cnVlfGZhbHNlKSQvLnRlc3QobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBkZWZhdWx0VmFsdWUoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmcubWF0Y2goL14tLlxcLi4rPS8pKSB7XG4gICAgICAgICAgICAgICAgbSA9IGFyZy5tYXRjaCgvXi0oW149XSspPShbXFxzXFxTXSopJC8pO1xuICAgICAgICAgICAgICAgIGlmIChtICE9PSBudWxsICYmIEFycmF5LmlzQXJyYXkobSkgJiYgbS5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcobVsxXSwgbVsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJnLm1hdGNoKC9eLS5cXC4uKy8pICYmICFhcmcubWF0Y2gobmVnYXRpdmUpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IGFyZ3NbaSArIDFdO1xuICAgICAgICAgICAgICAgIG0gPSBhcmcubWF0Y2goL14tKC5cXC4uKykvKTtcbiAgICAgICAgICAgICAgICBpZiAobSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KG0pICYmIG0ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gbVsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCAmJiAhbmV4dC5tYXRjaCgvXi0vKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmJvb2xzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgZGVmYXVsdFZhbHVlKGtleSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJnLm1hdGNoKC9eLVteLV0rLykgJiYgIWFyZy5tYXRjaChuZWdhdGl2ZSkpIHtcbiAgICAgICAgICAgICAgICBsZXR0ZXJzID0gYXJnLnNsaWNlKDEsIC0xKS5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgYnJva2VuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZXR0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBhcmcuc2xpY2UoaiArIDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGV0dGVyc1tqICsgMV0gJiYgbGV0dGVyc1tqICsgMV0gPT09ICc9Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhcmcuc2xpY2UoaiArIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gbGV0dGVyc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGVhdEFycmF5KGksIGtleSwgYXJncywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MubmFyZ3MpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBlYXROYXJncyhpLCBrZXksIGFyZ3MsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoL1tBLVphLXpdLy50ZXN0KGxldHRlcnNbal0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvXi0/XFxkKyhcXC5cXGQqKT8oZS0/XFxkKyk/JC8udGVzdChuZXh0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tBbGxBbGlhc2VzKG5leHQsIGZsYWdzLmJvb2xzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFyZyhsZXR0ZXJzW2pdLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGV0dGVyc1tqICsgMV0gJiYgbGV0dGVyc1tqICsgMV0ubWF0Y2goL1xcVy8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgZGVmYXVsdFZhbHVlKGxldHRlcnNbal0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZXkgPSBhcmcuc2xpY2UoLTEpWzBdO1xuICAgICAgICAgICAgICAgIGlmICghYnJva2VuICYmIGtleSAhPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZWF0QXJyYXkoaSwga2V5LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5uYXJncykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZWF0TmFyZ3MoaSwga2V5LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgKCEvXigtfC0tKVteLV0vLnRlc3QobmV4dCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Lm1hdGNoKG5lZ2F0aXZlKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYm9vbHMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXih0cnVlfGZhbHNlKSQvLnRlc3QobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBkZWZhdWx0VmFsdWUoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmcubWF0Y2goL14tWzAtOV0kLykgJiZcbiAgICAgICAgICAgICAgICBhcmcubWF0Y2gobmVnYXRpdmUpICYmXG4gICAgICAgICAgICAgICAgY2hlY2tBbGxBbGlhc2VzKGFyZy5zbGljZSgxKSwgZmxhZ3MuYm9vbHMpKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gYXJnLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIGRlZmF1bHRWYWx1ZShrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZyA9PT0gJy0tJykge1xuICAgICAgICAgICAgICAgIG5vdEZsYWdzID0gYXJncy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWd1cmF0aW9uWydoYWx0LWF0LW5vbi1vcHRpb24nXSkge1xuICAgICAgICAgICAgICAgIG5vdEZsYWdzID0gYXJncy5zbGljZShpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1c2hQb3NpdGlvbmFsKGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXBwbHlFbnZWYXJzKGFyZ3YsIHRydWUpO1xuICAgICAgICBhcHBseUVudlZhcnMoYXJndiwgZmFsc2UpO1xuICAgICAgICBzZXRDb25maWcoYXJndik7XG4gICAgICAgIHNldENvbmZpZ09iamVjdHMoKTtcbiAgICAgICAgYXBwbHlEZWZhdWx0c0FuZEFsaWFzZXMoYXJndiwgZmxhZ3MuYWxpYXNlcywgZGVmYXVsdHMsIHRydWUpO1xuICAgICAgICBhcHBseUNvZXJjaW9ucyhhcmd2KTtcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25bJ3NldC1wbGFjZWhvbGRlci1rZXknXSlcbiAgICAgICAgICAgIHNldFBsYWNlaG9sZGVyS2V5cyhhcmd2KTtcbiAgICAgICAgT2JqZWN0LmtleXMoZmxhZ3MuY291bnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICghaGFzS2V5KGFyZ3YsIGtleS5zcGxpdCgnLicpKSlcbiAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChub3RGbGFnc09wdGlvbiAmJiBub3RGbGFncy5sZW5ndGgpXG4gICAgICAgICAgICBhcmd2W25vdEZsYWdzQXJndl0gPSBbXTtcbiAgICAgICAgbm90RmxhZ3MuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBhcmd2W25vdEZsYWdzQXJndl0ucHVzaChrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25bJ2NhbWVsLWNhc2UtZXhwYW5zaW9uJ10gJiYgY29uZmlndXJhdGlvblsnc3RyaXAtZGFzaGVkJ10pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFyZ3YpLmZpbHRlcihrZXkgPT4ga2V5ICE9PSAnLS0nICYmIGtleS5pbmNsdWRlcygnLScpKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFyZ3Zba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWd1cmF0aW9uWydzdHJpcC1hbGlhc2VkJ10pIHtcbiAgICAgICAgICAgIFtdLmNvbmNhdCguLi5PYmplY3Qua2V5cyhhbGlhc2VzKS5tYXAoayA9PiBhbGlhc2VzW2tdKSkuZm9yRWFjaChhbGlhcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25bJ2NhbWVsLWNhc2UtZXhwYW5zaW9uJ10gJiYgYWxpYXMuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXJndlthbGlhcy5zcGxpdCgnLicpLm1hcChwcm9wID0+IGNhbWVsQ2FzZShwcm9wKSkuam9pbignLicpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFyZ3ZbYWxpYXNdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHVzaFBvc2l0aW9uYWwoYXJnKSB7XG4gICAgICAgICAgICBjb25zdCBtYXliZUNvZXJjZWROdW1iZXIgPSBtYXliZUNvZXJjZU51bWJlcignXycsIGFyZyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1heWJlQ29lcmNlZE51bWJlciA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG1heWJlQ29lcmNlZE51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBhcmd2Ll8ucHVzaChtYXliZUNvZXJjZWROdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVhdE5hcmdzKGksIGtleSwgYXJncywgYXJnQWZ0ZXJFcXVhbFNpZ24pIHtcbiAgICAgICAgICAgIGxldCBpaTtcbiAgICAgICAgICAgIGxldCB0b0VhdCA9IGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm5hcmdzKTtcbiAgICAgICAgICAgIHRvRWF0ID0gdHlwZW9mIHRvRWF0ICE9PSAnbnVtYmVyJyB8fCBpc05hTih0b0VhdCkgPyAxIDogdG9FYXQ7XG4gICAgICAgICAgICBpZiAodG9FYXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGFyZ0FmdGVyRXF1YWxTaWduKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IEVycm9yKF9fKCdBcmd1bWVudCB1bmV4cGVjdGVkIGZvcjogJXMnLCBrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgZGVmYXVsdFZhbHVlKGtleSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGF2YWlsYWJsZSA9IGlzVW5kZWZpbmVkKGFyZ0FmdGVyRXF1YWxTaWduKSA/IDAgOiAxO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25bJ25hcmdzLWVhdHMtb3B0aW9ucyddKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIC0gKGkgKyAxKSArIGF2YWlsYWJsZSA8IHRvRWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gRXJyb3IoX18oJ05vdCBlbm91Z2ggYXJndW1lbnRzIGZvbGxvd2luZzogJXMnLCBrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlID0gdG9FYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGlpID0gaSArIDE7IGlpIDwgYXJncy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmdzW2lpXS5tYXRjaCgvXi1bXjAtOV0vKSB8fCBhcmdzW2lpXS5tYXRjaChuZWdhdGl2ZSkgfHwgaXNVbmtub3duT3B0aW9uQXNBcmcoYXJnc1tpaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlKys7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXZhaWxhYmxlIDwgdG9FYXQpXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gRXJyb3IoX18oJ05vdCBlbm91Z2ggYXJndW1lbnRzIGZvbGxvd2luZzogJXMnLCBrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb25zdW1lZCA9IE1hdGgubWluKGF2YWlsYWJsZSwgdG9FYXQpO1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChhcmdBZnRlckVxdWFsU2lnbikgJiYgY29uc3VtZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgYXJnQWZ0ZXJFcXVhbFNpZ24pO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVkLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGlpID0gaSArIDE7IGlpIDwgKGNvbnN1bWVkICsgaSArIDEpOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgYXJnc1tpaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChpICsgY29uc3VtZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVhdEFycmF5KGksIGtleSwgYXJncywgYXJnQWZ0ZXJFcXVhbFNpZ24pIHtcbiAgICAgICAgICAgIGxldCBhcmdzVG9TZXQgPSBbXTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gYXJnQWZ0ZXJFcXVhbFNpZ24gfHwgYXJnc1tpICsgMV07XG4gICAgICAgICAgICBjb25zdCBuYXJnc0NvdW50ID0gY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MubmFyZ3MpO1xuICAgICAgICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmJvb2xzKSAmJiAhKC9eKHRydWV8ZmFsc2UpJC8udGVzdChuZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBhcmdzVG9TZXQucHVzaCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVW5kZWZpbmVkKG5leHQpIHx8XG4gICAgICAgICAgICAgICAgKGlzVW5kZWZpbmVkKGFyZ0FmdGVyRXF1YWxTaWduKSAmJiAvXi0vLnRlc3QobmV4dCkgJiYgIW5lZ2F0aXZlLnRlc3QobmV4dCkgJiYgIWlzVW5rbm93bk9wdGlvbkFzQXJnKG5leHQpKSkge1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0c1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmVmFsID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1RvU2V0ID0gQXJyYXkuaXNBcnJheShkZWZWYWwpID8gZGVmVmFsIDogW2RlZlZhbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChhcmdBZnRlckVxdWFsU2lnbikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1RvU2V0LnB1c2gocHJvY2Vzc1ZhbHVlKGtleSwgYXJnQWZ0ZXJFcXVhbFNpZ24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaWkgPSBpICsgMTsgaWkgPCBhcmdzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKCFjb25maWd1cmF0aW9uWydncmVlZHktYXJyYXlzJ10gJiYgYXJnc1RvU2V0Lmxlbmd0aCA+IDApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAobmFyZ3NDb3VudCAmJiB0eXBlb2YgbmFyZ3NDb3VudCA9PT0gJ251bWJlcicgJiYgYXJnc1RvU2V0Lmxlbmd0aCA+PSBuYXJnc0NvdW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gYXJnc1tpaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICgvXi0vLnRlc3QobmV4dCkgJiYgIW5lZ2F0aXZlLnRlc3QobmV4dCkgJiYgIWlzVW5rbm93bk9wdGlvbkFzQXJnKG5leHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBpaTtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1RvU2V0LnB1c2gocHJvY2Vzc1ZhbHVlKGtleSwgbmV4dCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFyZ3NDb3VudCA9PT0gJ251bWJlcicgJiYgKChuYXJnc0NvdW50ICYmIGFyZ3NUb1NldC5sZW5ndGggPCBuYXJnc0NvdW50KSB8fFxuICAgICAgICAgICAgICAgIChpc05hTihuYXJnc0NvdW50KSAmJiBhcmdzVG9TZXQubGVuZ3RoID09PSAwKSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IEVycm9yKF9fKCdOb3QgZW5vdWdoIGFyZ3VtZW50cyBmb2xsb3dpbmc6ICVzJywga2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRBcmcoa2V5LCBhcmdzVG9TZXQpO1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0QXJnKGtleSwgdmFsKSB7XG4gICAgICAgICAgICBpZiAoLy0vLnRlc3Qoa2V5KSAmJiBjb25maWd1cmF0aW9uWydjYW1lbC1jYXNlLWV4cGFuc2lvbiddKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxpYXMgPSBrZXkuc3BsaXQoJy4nKS5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbWVsQ2FzZShwcm9wKTtcbiAgICAgICAgICAgICAgICB9KS5qb2luKCcuJyk7XG4gICAgICAgICAgICAgICAgYWRkTmV3QWxpYXMoa2V5LCBhbGlhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb2Nlc3NWYWx1ZShrZXksIHZhbCk7XG4gICAgICAgICAgICBjb25zdCBzcGxpdEtleSA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgc2V0S2V5KGFyZ3YsIHNwbGl0S2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZmxhZ3MuYWxpYXNlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MuYWxpYXNlc1trZXldLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5UHJvcGVydGllcyA9IHguc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5KGFyZ3YsIGtleVByb3BlcnRpZXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGxpdEtleS5sZW5ndGggPiAxICYmIGNvbmZpZ3VyYXRpb25bJ2RvdC1ub3RhdGlvbiddKSB7XG4gICAgICAgICAgICAgICAgKGZsYWdzLmFsaWFzZXNbc3BsaXRLZXlbMF1dIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXlQcm9wZXJ0aWVzID0geC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gW10uY29uY2F0KHNwbGl0S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgYS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBrZXlQcm9wZXJ0aWVzID0ga2V5UHJvcGVydGllcy5jb25jYXQoYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGZsYWdzLmFsaWFzZXNba2V5XSB8fCBbXSkuaW5jbHVkZXMoa2V5UHJvcGVydGllcy5qb2luKCcuJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRLZXkoYXJndiwga2V5UHJvcGVydGllcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3Mubm9ybWFsaXplKSAmJiAhY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYXJyYXlzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBba2V5XS5jb25jYXQoZmxhZ3MuYWxpYXNlc1trZXldIHx8IFtdKTtcbiAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJndlJldHVybiwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IG1peGluLm5vcm1hbGl6ZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkTmV3QWxpYXMoa2V5LCBhbGlhcykge1xuICAgICAgICAgICAgaWYgKCEoZmxhZ3MuYWxpYXNlc1trZXldICYmIGZsYWdzLmFsaWFzZXNba2V5XS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MuYWxpYXNlc1trZXldID0gW2FsaWFzXTtcbiAgICAgICAgICAgICAgICBuZXdBbGlhc2VzW2FsaWFzXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShmbGFncy5hbGlhc2VzW2FsaWFzXSAmJiBmbGFncy5hbGlhc2VzW2FsaWFzXS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgYWRkTmV3QWxpYXMoYWxpYXMsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc1ZhbHVlKGtleSwgdmFsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAodmFsWzBdID09PSBcIidcIiB8fCB2YWxbMF0gPT09ICdcIicpICYmXG4gICAgICAgICAgICAgICAgdmFsW3ZhbC5sZW5ndGggLSAxXSA9PT0gdmFsWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLnN1YnN0cmluZygxLCB2YWwubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYm9vbHMpIHx8IGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbCA9PT0gJ3RydWUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gQXJyYXkuaXNBcnJheSh2YWwpXG4gICAgICAgICAgICAgICAgPyB2YWwubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBtYXliZUNvZXJjZU51bWJlcihrZXksIHYpOyB9KVxuICAgICAgICAgICAgICAgIDogbWF5YmVDb2VyY2VOdW1iZXIoa2V5LCB2YWwpO1xuICAgICAgICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykgJiYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGluY3JlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm5vcm1hbGl6ZSkgJiYgY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYXJyYXlzKSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsLm1hcCgodmFsKSA9PiB7IHJldHVybiBtaXhpbi5ub3JtYWxpemUodmFsKTsgfSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1peGluLm5vcm1hbGl6ZSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1heWJlQ29lcmNlTnVtYmVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghY29uZmlndXJhdGlvblsncGFyc2UtcG9zaXRpb25hbC1udW1iZXJzJ10gJiYga2V5ID09PSAnXycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgaWYgKCFjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5zdHJpbmdzKSAmJiAhY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYm9vbHMpICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZENvZXJjZU51bWJlciA9IGxvb2tzTGlrZU51bWJlcih2YWx1ZSkgJiYgY29uZmlndXJhdGlvblsncGFyc2UtbnVtYmVycyddICYmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihNYXRoLmZsb29yKHBhcnNlRmxvYXQoYCR7dmFsdWV9YCkpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZENvZXJjZU51bWJlciB8fCAoIWlzVW5kZWZpbmVkKHZhbHVlKSAmJiBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5udW1iZXJzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRDb25maWcoYXJndikge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnTG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGFwcGx5RGVmYXVsdHNBbmRBbGlhc2VzKGNvbmZpZ0xvb2t1cCwgZmxhZ3MuYWxpYXNlcywgZGVmYXVsdHMpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZmxhZ3MuY29uZmlncykuZm9yRWFjaChmdW5jdGlvbiAoY29uZmlnS2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlnUGF0aCA9IGFyZ3ZbY29uZmlnS2V5XSB8fCBjb25maWdMb29rdXBbY29uZmlnS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZpZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZENvbmZpZ1BhdGggPSBtaXhpbi5yZXNvbHZlKG1peGluLmN3ZCgpLCBjb25maWdQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVDb25maWcgPSBmbGFncy5jb25maWdzW2NvbmZpZ0tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc29sdmVDb25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSByZXNvbHZlQ29uZmlnKHJlc29sdmVkQ29uZmlnUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1peGluLnJlcXVpcmUocmVzb2x2ZWRDb25maWdQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbmZpZ09iamVjdChjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4Lm5hbWUgPT09ICdQZXJtaXNzaW9uRGVuaWVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJndltjb25maWdLZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gRXJyb3IoX18oJ0ludmFsaWQgSlNPTiBjb25maWcgZmlsZTogJXMnLCBjb25maWdQYXRoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRDb25maWdPYmplY3QoY29uZmlnLCBwcmV2KSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb25maWcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgZnVsbEtleSA9IHByZXYgPyBwcmV2ICsgJy4nICsga2V5IDoga2V5O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBjb25maWd1cmF0aW9uWydkb3Qtbm90YXRpb24nXSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRDb25maWdPYmplY3QodmFsdWUsIGZ1bGxLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNLZXkoYXJndiwgZnVsbEtleS5zcGxpdCgnLicpKSB8fCAoY2hlY2tBbGxBbGlhc2VzKGZ1bGxLZXksIGZsYWdzLmFycmF5cykgJiYgY29uZmlndXJhdGlvblsnY29tYmluZS1hcnJheXMnXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFyZyhmdWxsS2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRDb25maWdPYmplY3RzKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWdPYmplY3RzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbmZpZ09iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAoY29uZmlnT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldENvbmZpZ09iamVjdChjb25maWdPYmplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5RW52VmFycyhhcmd2LCBjb25maWdPbmx5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudlByZWZpeCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gdHlwZW9mIGVudlByZWZpeCA9PT0gJ3N0cmluZycgPyBlbnZQcmVmaXggOiAnJztcbiAgICAgICAgICAgIGNvbnN0IGVudiA9IG1peGluLmVudigpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGZ1bmN0aW9uIChlbnZWYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4ID09PSAnJyB8fCBlbnZWYXIubGFzdEluZGV4T2YocHJlZml4LCAwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gZW52VmFyLnNwbGl0KCdfXycpLm1hcChmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGtleS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FtZWxDYXNlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKChjb25maWdPbmx5ICYmIGZsYWdzLmNvbmZpZ3Nba2V5cy5qb2luKCcuJyldKSB8fCAhY29uZmlnT25seSkgJiYgIWhhc0tleShhcmd2LCBrZXlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGtleXMuam9pbignLicpLCBlbnZbZW52VmFyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseUNvZXJjaW9ucyhhcmd2KSB7XG4gICAgICAgICAgICBsZXQgY29lcmNlO1xuICAgICAgICAgICAgY29uc3QgYXBwbGllZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFyZ3YpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmICghYXBwbGllZC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb2VyY2UgPSBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5jb2VyY2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvZXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1heWJlQ29lcmNlTnVtYmVyKGtleSwgY29lcmNlKGFyZ3Zba2V5XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChbXS5jb25jYXQoZmxhZ3MuYWxpYXNlc1trZXldIHx8IFtdLCBrZXkpKS5mb3JFYWNoKGFsaSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWQuYWRkKGFsaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3ZbYWxpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0UGxhY2Vob2xkZXJLZXlzKGFyZ3YpIHtcbiAgICAgICAgICAgIGZsYWdzLmtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKH5rZXkuaW5kZXhPZignLicpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd2W2tleV0gPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICBhcmd2W2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhcmd2O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5RGVmYXVsdHNBbmRBbGlhc2VzKG9iaiwgYWxpYXNlcywgZGVmYXVsdHMsIGNhbkxvZyA9IGZhbHNlKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkZWZhdWx0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNLZXkob2JqLCBrZXkuc3BsaXQoJy4nKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5KG9iaiwga2V5LnNwbGl0KCcuJyksIGRlZmF1bHRzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuTG9nKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdGVkW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAoYWxpYXNlc1trZXldIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzS2V5KG9iaiwgeC5zcGxpdCgnLicpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRLZXkob2JqLCB4LnNwbGl0KCcuJyksIGRlZmF1bHRzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNLZXkob2JqLCBrZXlzKSB7XG4gICAgICAgICAgICBsZXQgbyA9IG9iajtcbiAgICAgICAgICAgIGlmICghY29uZmlndXJhdGlvblsnZG90LW5vdGF0aW9uJ10pXG4gICAgICAgICAgICAgICAga2V5cyA9IFtrZXlzLmpvaW4oJy4nKV07XG4gICAgICAgICAgICBrZXlzLnNsaWNlKDAsIC0xKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBvID0gKG9ba2V5XSB8fCB7fSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNba2V5cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbyAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXkgaW4gbztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRLZXkob2JqLCBrZXlzLCB2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG8gPSBvYmo7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb25bJ2RvdC1ub3RhdGlvbiddKVxuICAgICAgICAgICAgICAgIGtleXMgPSBba2V5cy5qb2luKCcuJyldO1xuICAgICAgICAgICAga2V5cy5zbGljZSgwLCAtMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc2FuaXRpemVLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG9ba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ba2V5XSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ba2V5XS5wdXNoKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ba2V5XSA9IFtvW2tleV0sIHt9XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvID0gb1trZXldW29ba2V5XS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG8gPSBvW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBzYW5pdGl6ZUtleShrZXlzW2tleXMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgY29uc3QgaXNUeXBlQXJyYXkgPSBjaGVja0FsbEFsaWFzZXMoa2V5cy5qb2luKCcuJyksIGZsYWdzLmFycmF5cyk7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbHVlQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICAgICAgICAgIGxldCBkdXBsaWNhdGUgPSBjb25maWd1cmF0aW9uWydkdXBsaWNhdGUtYXJndW1lbnRzLWFycmF5J107XG4gICAgICAgICAgICBpZiAoIWR1cGxpY2F0ZSAmJiBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5uYXJncykpIHtcbiAgICAgICAgICAgICAgICBkdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICgoIWlzVW5kZWZpbmVkKG9ba2V5XSkgJiYgZmxhZ3MubmFyZ3Nba2V5XSA9PT0gMSkgfHwgKEFycmF5LmlzQXJyYXkob1trZXldKSAmJiBvW2tleV0ubGVuZ3RoID09PSBmbGFncy5uYXJnc1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBvW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBpbmNyZW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIG9ba2V5XSA9IGluY3JlbWVudChvW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGR1cGxpY2F0ZSAmJiBpc1R5cGVBcnJheSAmJiBpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgb1trZXldID0gY29uZmlndXJhdGlvblsnZmxhdHRlbi1kdXBsaWNhdGUtYXJyYXlzJ10gPyBvW2tleV0uY29uY2F0KHZhbHVlKSA6IChBcnJheS5pc0FycmF5KG9ba2V5XVswXSkgPyBvW2tleV0gOiBbb1trZXldXSkuY29uY2F0KFt2YWx1ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZHVwbGljYXRlICYmIEJvb2xlYW4oaXNUeXBlQXJyYXkpID09PSBCb29sZWFuKGlzVmFsdWVBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvW2tleV0gPSBvW2tleV0uY29uY2F0KFt2YWx1ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9ba2V5XSA9PT0gdW5kZWZpbmVkICYmIGlzVHlwZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgb1trZXldID0gaXNWYWx1ZUFycmF5ID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZHVwbGljYXRlICYmICEob1trZXldID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5jb3VudHMpIHx8XG4gICAgICAgICAgICAgICAgY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYm9vbHMpKSkge1xuICAgICAgICAgICAgICAgIG9ba2V5XSA9IFtvW2tleV0sIHZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGV4dGVuZEFsaWFzZXMoLi4uYXJncykge1xuICAgICAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhvYmogfHwge30pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MuYWxpYXNlc1trZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5hbGlhc2VzW2tleV0gPSBbXS5jb25jYXQoYWxpYXNlc1trZXldIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYWxpYXNlc1trZXldLmNvbmNhdChrZXkpLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvLS8udGVzdCh4KSAmJiBjb25maWd1cmF0aW9uWydjYW1lbC1jYXNlLWV4cGFuc2lvbiddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGNhbWVsQ2FzZSh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyAhPT0ga2V5ICYmIGZsYWdzLmFsaWFzZXNba2V5XS5pbmRleE9mKGMpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFncy5hbGlhc2VzW2tleV0ucHVzaChjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3QWxpYXNlc1tjXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYWxpYXNlc1trZXldLmNvbmNhdChrZXkpLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4Lmxlbmd0aCA+IDEgJiYgL1tBLVpdLy50ZXN0KHgpICYmIGNvbmZpZ3VyYXRpb25bJ2NhbWVsLWNhc2UtZXhwYW5zaW9uJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gZGVjYW1lbGl6ZSh4LCAnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjICE9PSBrZXkgJiYgZmxhZ3MuYWxpYXNlc1trZXldLmluZGV4T2YoYykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLmFsaWFzZXNba2V5XS5wdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdBbGlhc2VzW2NdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5hbGlhc2VzW2tleV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYWxpYXNlc1t4XSA9IFtrZXldLmNvbmNhdChmbGFncy5hbGlhc2VzW2tleV0uZmlsdGVyKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggIT09IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZykge1xuICAgICAgICAgICAgY29uc3QgdG9DaGVjayA9IFtdLmNvbmNhdChmbGFncy5hbGlhc2VzW2tleV0gfHwgW10sIGtleSk7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmxhZyk7XG4gICAgICAgICAgICBjb25zdCBzZXRBbGlhcyA9IHRvQ2hlY2suZmluZChrZXkgPT4ga2V5cy5pbmNsdWRlcyhrZXkpKTtcbiAgICAgICAgICAgIHJldHVybiBzZXRBbGlhcyA/IGZsYWdbc2V0QWxpYXNdIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzQW55RmxhZyhrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzS2V5cyA9IE9iamVjdC5rZXlzKGZsYWdzKTtcbiAgICAgICAgICAgIGNvbnN0IHRvQ2hlY2sgPSBbXS5jb25jYXQoZmxhZ3NLZXlzLm1hcChrID0+IGZsYWdzW2tdKSk7XG4gICAgICAgICAgICByZXR1cm4gdG9DaGVjay5zb21lKGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZmxhZykgPyBmbGFnLmluY2x1ZGVzKGtleSkgOiBmbGFnW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNGbGFnc01hdGNoaW5nKGFyZywgLi4ucGF0dGVybnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvQ2hlY2sgPSBbXS5jb25jYXQoLi4ucGF0dGVybnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQ2hlY2suc29tZShmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gYXJnLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiBoYXNBbnlGbGFnKG1hdGNoWzFdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc0FsbFNob3J0RmxhZ3MoYXJnKSB7XG4gICAgICAgICAgICBpZiAoYXJnLm1hdGNoKG5lZ2F0aXZlKSB8fCAhYXJnLm1hdGNoKC9eLVteLV0rLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaGFzQWxsRmxhZ3MgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgICAgICBjb25zdCBsZXR0ZXJzID0gYXJnLnNsaWNlKDEpLnNwbGl0KCcnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGV0dGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIG5leHQgPSBhcmcuc2xpY2UoaiArIDIpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzQW55RmxhZyhsZXR0ZXJzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNBbGxGbGFncyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChsZXR0ZXJzW2ogKyAxXSAmJiBsZXR0ZXJzW2ogKyAxXSA9PT0gJz0nKSB8fFxuICAgICAgICAgICAgICAgICAgICBuZXh0ID09PSAnLScgfHxcbiAgICAgICAgICAgICAgICAgICAgKC9bQS1aYS16XS8udGVzdChsZXR0ZXJzW2pdKSAmJiAvXi0/XFxkKyhcXC5cXGQqKT8oZS0/XFxkKyk/JC8udGVzdChuZXh0KSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGxldHRlcnNbaiArIDFdICYmIGxldHRlcnNbaiArIDFdLm1hdGNoKC9cXFcvKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhc0FsbEZsYWdzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzVW5rbm93bk9wdGlvbkFzQXJnKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25bJ3Vua25vd24tb3B0aW9ucy1hcy1hcmdzJ10gJiYgaXNVbmtub3duT3B0aW9uKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNVbmtub3duT3B0aW9uKGFyZykge1xuICAgICAgICAgICAgYXJnID0gYXJnLnJlcGxhY2UoL14tezMsfS8sICctLScpO1xuICAgICAgICAgICAgaWYgKGFyZy5tYXRjaChuZWdhdGl2ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQWxsU2hvcnRGbGFncyhhcmcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmxhZ1dpdGhFcXVhbHMgPSAvXi0rKFtePV0rPyk9W1xcc1xcU10qJC87XG4gICAgICAgICAgICBjb25zdCBub3JtYWxGbGFnID0gL14tKyhbXj1dKz8pJC87XG4gICAgICAgICAgICBjb25zdCBmbGFnRW5kaW5nSW5IeXBoZW4gPSAvXi0rKFtePV0rPyktJC87XG4gICAgICAgICAgICBjb25zdCBmbGFnRW5kaW5nSW5EaWdpdHMgPSAvXi0rKFtePV0rP1xcZCspJC87XG4gICAgICAgICAgICBjb25zdCBmbGFnRW5kaW5nSW5Ob25Xb3JkQ2hhcmFjdGVycyA9IC9eLSsoW149XSs/KVxcVysuKiQvO1xuICAgICAgICAgICAgcmV0dXJuICFoYXNGbGFnc01hdGNoaW5nKGFyZywgZmxhZ1dpdGhFcXVhbHMsIG5lZ2F0ZWRCb29sZWFuLCBub3JtYWxGbGFnLCBmbGFnRW5kaW5nSW5IeXBoZW4sIGZsYWdFbmRpbmdJbkRpZ2l0cywgZmxhZ0VuZGluZ0luTm9uV29yZENoYXJhY3RlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRWYWx1ZShrZXkpIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYm9vbHMpICYmXG4gICAgICAgICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykgJiZcbiAgICAgICAgICAgICAgICBgJHtrZXl9YCBpbiBkZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0c1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGb3JUeXBlKGd1ZXNzVHlwZShrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWZhdWx0Rm9yVHlwZSh0eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBkZWYgPSB7XG4gICAgICAgICAgICAgICAgW0RlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5LkJPT0xFQU5dOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtEZWZhdWx0VmFsdWVzRm9yVHlwZUtleS5TVFJJTkddOiAnJyxcbiAgICAgICAgICAgICAgICBbRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXkuTlVNQkVSXTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFtEZWZhdWx0VmFsdWVzRm9yVHlwZUtleS5BUlJBWV06IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGRlZlt0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBndWVzc1R5cGUoa2V5KSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IERlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5LkJPT0xFQU47XG4gICAgICAgICAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3Muc3RyaW5ncykpXG4gICAgICAgICAgICAgICAgdHlwZSA9IERlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5LlNUUklORztcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm51bWJlcnMpKVxuICAgICAgICAgICAgICAgIHR5cGUgPSBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleS5OVU1CRVI7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5ib29scykpXG4gICAgICAgICAgICAgICAgdHlwZSA9IERlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5LkJPT0xFQU47XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpKVxuICAgICAgICAgICAgICAgIHR5cGUgPSBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleS5BUlJBWTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG51bSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQ29uZmlndXJhdGlvbigpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGZsYWdzLmNvdW50cykuZmluZChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gRXJyb3IoX18oJ0ludmFsaWQgY29uZmlndXJhdGlvbjogJXMsIG9wdHMuY291bnQgZXhjbHVkZXMgb3B0cy5hcnJheS4nLCBrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm5hcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IEVycm9yKF9fKCdJbnZhbGlkIGNvbmZpZ3VyYXRpb246ICVzLCBvcHRzLmNvdW50IGV4Y2x1ZGVzIG9wdHMubmFyZy4nLCBrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbGlhc2VzOiBPYmplY3QuYXNzaWduKHt9LCBmbGFncy5hbGlhc2VzKSxcbiAgICAgICAgICAgIGFyZ3Y6IE9iamVjdC5hc3NpZ24oYXJndlJldHVybiwgYXJndiksXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uOiBjb25maWd1cmF0aW9uLFxuICAgICAgICAgICAgZGVmYXVsdGVkOiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0ZWQpLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgbmV3QWxpYXNlczogT2JqZWN0LmFzc2lnbih7fSwgbmV3QWxpYXNlcylcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21iaW5lQWxpYXNlcyhhbGlhc2VzKSB7XG4gICAgY29uc3QgYWxpYXNBcnJheXMgPSBbXTtcbiAgICBjb25zdCBjb21iaW5lZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNoYW5nZSA9IHRydWU7XG4gICAgT2JqZWN0LmtleXMoYWxpYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGFsaWFzQXJyYXlzLnB1c2goW10uY29uY2F0KGFsaWFzZXNba2V5XSwga2V5KSk7XG4gICAgfSk7XG4gICAgd2hpbGUgKGNoYW5nZSkge1xuICAgICAgICBjaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGlhc0FycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaWkgPSBpICsgMTsgaWkgPCBhbGlhc0FycmF5cy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcnNlY3QgPSBhbGlhc0FycmF5c1tpXS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsaWFzQXJyYXlzW2lpXS5pbmRleE9mKHYpICE9PSAtMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhbGlhc0FycmF5c1tpXSA9IGFsaWFzQXJyYXlzW2ldLmNvbmNhdChhbGlhc0FycmF5c1tpaV0pO1xuICAgICAgICAgICAgICAgICAgICBhbGlhc0FycmF5cy5zcGxpY2UoaWksIDEpO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWxpYXNBcnJheXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXNBcnJheSkge1xuICAgICAgICBhbGlhc0FycmF5ID0gYWxpYXNBcnJheS5maWx0ZXIoZnVuY3Rpb24gKHYsIGksIHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmluZGV4T2YodikgPT09IGk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBsYXN0QWxpYXMgPSBhbGlhc0FycmF5LnBvcCgpO1xuICAgICAgICBpZiAobGFzdEFsaWFzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGxhc3RBbGlhcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbWJpbmVkW2xhc3RBbGlhc10gPSBhbGlhc0FycmF5O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbWJpbmVkO1xufVxuZnVuY3Rpb24gaW5jcmVtZW50KG9yaWcpIHtcbiAgICByZXR1cm4gb3JpZyAhPT0gdW5kZWZpbmVkID8gb3JpZyArIDEgOiAxO1xufVxuZnVuY3Rpb24gc2FuaXRpemVLZXkoa2V5KSB7XG4gICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycpXG4gICAgICAgIHJldHVybiAnX19fcHJvdG9fX18nO1xuICAgIHJldHVybiBrZXk7XG59XG5cbmNvbnN0IG1pbk5vZGVWZXJzaW9uID0gKHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuWUFSR1NfTUlOX05PREVfVkVSU0lPTilcbiAgICA/IE51bWJlcihwcm9jZXNzLmVudi5ZQVJHU19NSU5fTk9ERV9WRVJTSU9OKVxuICAgIDogMTA7XG5pZiAocHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb24pIHtcbiAgICBjb25zdCBtYWpvciA9IE51bWJlcihwcm9jZXNzLnZlcnNpb24ubWF0Y2goL3YoW14uXSspLylbMV0pO1xuICAgIGlmIChtYWpvciA8IG1pbk5vZGVWZXJzaW9uKSB7XG4gICAgICAgIHRocm93IEVycm9yKGB5YXJncyBwYXJzZXIgc3VwcG9ydHMgYSBtaW5pbXVtIE5vZGUuanMgdmVyc2lvbiBvZiAke21pbk5vZGVWZXJzaW9ufS4gUmVhZCBvdXIgdmVyc2lvbiBzdXBwb3J0IHBvbGljeTogaHR0cHM6Ly9naXRodWIuY29tL3lhcmdzL3lhcmdzLXBhcnNlciNzdXBwb3J0ZWQtbm9kZWpzLXZlcnNpb25zYCk7XG4gICAgfVxufVxuY29uc3QgZW52ID0gcHJvY2VzcyA/IHByb2Nlc3MuZW52IDoge307XG5jb25zdCBwYXJzZXIgPSBuZXcgWWFyZ3NQYXJzZXIoe1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QsXG4gICAgZW52OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBlbnY7XG4gICAgfSxcbiAgICBmb3JtYXQ6IHV0aWwuZm9ybWF0LFxuICAgIG5vcm1hbGl6ZTogcGF0aC5ub3JtYWxpemUsXG4gICAgcmVzb2x2ZTogcGF0aC5yZXNvbHZlLFxuICAgIHJlcXVpcmU6IChwYXRoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiByZXF1aXJlKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhdGgubWF0Y2goL1xcLmpzb24kLykpIHtcbiAgICAgICAgICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMocGF0aCwgJ3V0ZjgnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdvbmx5IC5qc29uIGNvbmZpZyBmaWxlcyBhcmUgc3VwcG9ydGVkIGluIEVTTScpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5jb25zdCB5YXJnc1BhcnNlciA9IGZ1bmN0aW9uIFBhcnNlcihhcmdzLCBvcHRzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyLnBhcnNlKGFyZ3Muc2xpY2UoKSwgb3B0cyk7XG4gICAgcmV0dXJuIHJlc3VsdC5hcmd2O1xufTtcbnlhcmdzUGFyc2VyLmRldGFpbGVkID0gZnVuY3Rpb24gKGFyZ3MsIG9wdHMpIHtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlKGFyZ3Muc2xpY2UoKSwgb3B0cyk7XG59O1xueWFyZ3NQYXJzZXIuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xueWFyZ3NQYXJzZXIuZGVjYW1lbGl6ZSA9IGRlY2FtZWxpemU7XG55YXJnc1BhcnNlci5sb29rc0xpa2VOdW1iZXIgPSBsb29rc0xpa2VOdW1iZXI7XG5cbm1vZHVsZS5leHBvcnRzID0geWFyZ3NQYXJzZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBLFlBQVk7O0FBRVosSUFBSUEsSUFBSSxHQUFHQyxPQUFPLENBQUMsTUFBTSxDQUFDO0FBQzFCLElBQUlDLEVBQUUsR0FBR0QsT0FBTyxDQUFDLElBQUksQ0FBQztBQUN0QixJQUFJRSxJQUFJLEdBQUdGLE9BQU8sQ0FBQyxNQUFNLENBQUM7QUFFMUIsU0FBU0csU0FBU0EsQ0FBQ0MsR0FBRyxFQUFFO0VBQ3BCLE1BQU1DLFdBQVcsR0FBR0QsR0FBRyxLQUFLQSxHQUFHLENBQUNFLFdBQVcsQ0FBQyxDQUFDLElBQUlGLEdBQUcsS0FBS0EsR0FBRyxDQUFDRyxXQUFXLENBQUMsQ0FBQztFQUMxRSxJQUFJLENBQUNGLFdBQVcsRUFBRTtJQUNkRCxHQUFHLEdBQUdBLEdBQUcsQ0FBQ0UsV0FBVyxDQUFDLENBQUM7RUFDM0I7RUFDQSxJQUFJRixHQUFHLENBQUNJLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSUosR0FBRyxDQUFDSSxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7SUFDcEQsT0FBT0osR0FBRztFQUNkLENBQUMsTUFDSTtJQUNELElBQUlLLFNBQVMsR0FBRyxFQUFFO0lBQ2xCLElBQUlDLFlBQVksR0FBRyxLQUFLO0lBQ3hCLE1BQU1DLGNBQWMsR0FBR1AsR0FBRyxDQUFDUSxLQUFLLENBQUMsS0FBSyxDQUFDO0lBQ3ZDLEtBQUssSUFBSUMsQ0FBQyxHQUFHRixjQUFjLEdBQUdBLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQ0csTUFBTSxHQUFHLENBQUMsRUFBRUQsQ0FBQyxHQUFHVCxHQUFHLENBQUNVLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUU7TUFDN0UsSUFBSUUsR0FBRyxHQUFHWCxHQUFHLENBQUNZLE1BQU0sQ0FBQ0gsQ0FBQyxDQUFDO01BQ3ZCLElBQUlILFlBQVksRUFBRTtRQUNkQSxZQUFZLEdBQUcsS0FBSztRQUNwQkssR0FBRyxHQUFHQSxHQUFHLENBQUNSLFdBQVcsQ0FBQyxDQUFDO01BQzNCO01BQ0EsSUFBSU0sQ0FBQyxLQUFLLENBQUMsS0FBS0UsR0FBRyxLQUFLLEdBQUcsSUFBSUEsR0FBRyxLQUFLLEdBQUcsQ0FBQyxFQUFFO1FBQ3pDTCxZQUFZLEdBQUcsSUFBSTtNQUN2QixDQUFDLE1BQ0ksSUFBSUssR0FBRyxLQUFLLEdBQUcsSUFBSUEsR0FBRyxLQUFLLEdBQUcsRUFBRTtRQUNqQ04sU0FBUyxJQUFJTSxHQUFHO01BQ3BCO0lBQ0o7SUFDQSxPQUFPTixTQUFTO0VBQ3BCO0FBQ0o7QUFDQSxTQUFTUSxVQUFVQSxDQUFDYixHQUFHLEVBQUVjLFVBQVUsRUFBRTtFQUNqQyxNQUFNQyxTQUFTLEdBQUdmLEdBQUcsQ0FBQ0UsV0FBVyxDQUFDLENBQUM7RUFDbkNZLFVBQVUsR0FBR0EsVUFBVSxJQUFJLEdBQUc7RUFDOUIsSUFBSUUsWUFBWSxHQUFHLEVBQUU7RUFDckIsS0FBSyxJQUFJUCxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdULEdBQUcsQ0FBQ1UsTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtJQUNqQyxNQUFNUSxRQUFRLEdBQUdGLFNBQVMsQ0FBQ0gsTUFBTSxDQUFDSCxDQUFDLENBQUM7SUFDcEMsTUFBTVMsU0FBUyxHQUFHbEIsR0FBRyxDQUFDWSxNQUFNLENBQUNILENBQUMsQ0FBQztJQUMvQixJQUFJUSxRQUFRLEtBQUtDLFNBQVMsSUFBSVQsQ0FBQyxHQUFHLENBQUMsRUFBRTtNQUNqQ08sWUFBWSxJQUFLLEdBQUVGLFVBQVcsR0FBRUMsU0FBUyxDQUFDSCxNQUFNLENBQUNILENBQUMsQ0FBRSxFQUFDO0lBQ3pELENBQUMsTUFDSTtNQUNETyxZQUFZLElBQUlFLFNBQVM7SUFDN0I7RUFDSjtFQUNBLE9BQU9GLFlBQVk7QUFDdkI7QUFDQSxTQUFTRyxlQUFlQSxDQUFDQyxDQUFDLEVBQUU7RUFDeEIsSUFBSUEsQ0FBQyxLQUFLLElBQUksSUFBSUEsQ0FBQyxLQUFLQyxTQUFTLEVBQzdCLE9BQU8sS0FBSztFQUNoQixJQUFJLE9BQU9ELENBQUMsS0FBSyxRQUFRLEVBQ3JCLE9BQU8sSUFBSTtFQUNmLElBQUksZ0JBQWdCLENBQUNFLElBQUksQ0FBQ0YsQ0FBQyxDQUFDLEVBQ3hCLE9BQU8sSUFBSTtFQUNmLElBQUksUUFBUSxDQUFDRSxJQUFJLENBQUNGLENBQUMsQ0FBQyxFQUNoQixPQUFPLEtBQUs7RUFDaEIsT0FBTywyQ0FBMkMsQ0FBQ0UsSUFBSSxDQUFDRixDQUFDLENBQUM7QUFDOUQ7QUFFQSxTQUFTRyxpQkFBaUJBLENBQUNDLFNBQVMsRUFBRTtFQUNsQyxJQUFJQyxLQUFLLENBQUNDLE9BQU8sQ0FBQ0YsU0FBUyxDQUFDLEVBQUU7SUFDMUIsT0FBT0EsU0FBUyxDQUFDRyxHQUFHLENBQUNDLENBQUMsSUFBSSxPQUFPQSxDQUFDLEtBQUssUUFBUSxHQUFHQSxDQUFDLEdBQUcsRUFBRSxHQUFHQSxDQUFDLENBQUM7RUFDakU7RUFDQUosU0FBUyxHQUFHQSxTQUFTLENBQUNLLElBQUksQ0FBQyxDQUFDO0VBQzVCLElBQUlwQixDQUFDLEdBQUcsQ0FBQztFQUNULElBQUlxQixLQUFLLEdBQUcsSUFBSTtFQUNoQixJQUFJQyxDQUFDLEdBQUcsSUFBSTtFQUNaLElBQUlDLE9BQU8sR0FBRyxJQUFJO0VBQ2xCLE1BQU1DLElBQUksR0FBRyxFQUFFO0VBQ2YsS0FBSyxJQUFJQyxFQUFFLEdBQUcsQ0FBQyxFQUFFQSxFQUFFLEdBQUdWLFNBQVMsQ0FBQ2QsTUFBTSxFQUFFd0IsRUFBRSxFQUFFLEVBQUU7SUFDMUNKLEtBQUssR0FBR0MsQ0FBQztJQUNUQSxDQUFDLEdBQUdQLFNBQVMsQ0FBQ1osTUFBTSxDQUFDc0IsRUFBRSxDQUFDO0lBQ3hCLElBQUlILENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQ0MsT0FBTyxFQUFFO01BQ3ZCLElBQUksRUFBRUYsS0FBSyxLQUFLLEdBQUcsQ0FBQyxFQUFFO1FBQ2xCckIsQ0FBQyxFQUFFO01BQ1A7TUFDQTtJQUNKO0lBQ0EsSUFBSXNCLENBQUMsS0FBS0MsT0FBTyxFQUFFO01BQ2ZBLE9BQU8sR0FBRyxJQUFJO0lBQ2xCLENBQUMsTUFDSSxJQUFJLENBQUNELENBQUMsS0FBSyxHQUFHLElBQUlBLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQ0MsT0FBTyxFQUFFO01BQzNDQSxPQUFPLEdBQUdELENBQUM7SUFDZjtJQUNBLElBQUksQ0FBQ0UsSUFBSSxDQUFDeEIsQ0FBQyxDQUFDLEVBQ1J3QixJQUFJLENBQUN4QixDQUFDLENBQUMsR0FBRyxFQUFFO0lBQ2hCd0IsSUFBSSxDQUFDeEIsQ0FBQyxDQUFDLElBQUlzQixDQUFDO0VBQ2hCO0VBQ0EsT0FBT0UsSUFBSTtBQUNmO0FBRUEsSUFBSUUsdUJBQXVCO0FBQzNCLENBQUMsVUFBVUEsdUJBQXVCLEVBQUU7RUFDaENBLHVCQUF1QixDQUFDLFNBQVMsQ0FBQyxHQUFHLFNBQVM7RUFDOUNBLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxHQUFHLFFBQVE7RUFDNUNBLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxHQUFHLFFBQVE7RUFDNUNBLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxHQUFHLE9BQU87QUFDOUMsQ0FBQyxFQUFFQSx1QkFBdUIsS0FBS0EsdUJBQXVCLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUU3RCxJQUFJQyxLQUFLO0FBQ1QsTUFBTUMsV0FBVyxDQUFDO0VBQ2RDLFdBQVdBLENBQUNDLE1BQU0sRUFBRTtJQUNoQkgsS0FBSyxHQUFHRyxNQUFNO0VBQ2xCO0VBQ0FDLEtBQUtBLENBQUNDLFNBQVMsRUFBRUMsT0FBTyxFQUFFO0lBQ3RCLE1BQU1DLElBQUksR0FBR0MsTUFBTSxDQUFDQyxNQUFNLENBQUM7TUFDdkJDLEtBQUssRUFBRXpCLFNBQVM7TUFDaEIwQixLQUFLLEVBQUUxQixTQUFTO01BQ2hCMkIsT0FBTyxFQUFFM0IsU0FBUztNQUNsQjRCLE1BQU0sRUFBRTVCLFNBQVM7TUFDakI2QixhQUFhLEVBQUU3QixTQUFTO01BQ3hCOEIsYUFBYSxFQUFFOUIsU0FBUztNQUN4QitCLE1BQU0sRUFBRS9CLFNBQVM7TUFDakJnQyxLQUFLLEVBQUVoQyxTQUFTO01BQ2hCaUMsT0FBTyxFQUFFakMsU0FBUztNQUNsQmtDLFNBQVMsRUFBRWxDLFNBQVM7TUFDcEJtQyxJQUFJLEVBQUVuQyxTQUFTO01BQ2ZvQyxTQUFTLEVBQUVwQyxTQUFTO01BQ3BCcUMsTUFBTSxFQUFFckMsU0FBUztNQUNqQnNDLE1BQU0sRUFBRXRDLFNBQVM7TUFDakJ1QyxFQUFFLEVBQUV2QyxTQUFTO01BQ2J3QyxHQUFHLEVBQUV4QztJQUNULENBQUMsRUFBRXFCLE9BQU8sQ0FBQztJQUNYLE1BQU1ULElBQUksR0FBR1YsaUJBQWlCLENBQUNrQixTQUFTLENBQUM7SUFDekMsTUFBTXFCLE9BQU8sR0FBR0MsY0FBYyxDQUFDbkIsTUFBTSxDQUFDQyxNQUFNLENBQUNELE1BQU0sQ0FBQ29CLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRXJCLElBQUksQ0FBQ0csS0FBSyxDQUFDLENBQUM7SUFDOUUsTUFBTUssYUFBYSxHQUFHUCxNQUFNLENBQUNDLE1BQU0sQ0FBQztNQUNoQyxrQkFBa0IsRUFBRSxJQUFJO01BQ3hCLHNCQUFzQixFQUFFLElBQUk7TUFDNUIsZ0JBQWdCLEVBQUUsS0FBSztNQUN2QixjQUFjLEVBQUUsSUFBSTtNQUNwQiwyQkFBMkIsRUFBRSxJQUFJO01BQ2pDLDBCQUEwQixFQUFFLElBQUk7TUFDaEMsZUFBZSxFQUFFLElBQUk7TUFDckIsb0JBQW9CLEVBQUUsS0FBSztNQUMzQixvQkFBb0IsRUFBRSxLQUFLO01BQzNCLGlCQUFpQixFQUFFLEtBQUs7TUFDeEIsZUFBZSxFQUFFLElBQUk7TUFDckIsMEJBQTBCLEVBQUUsSUFBSTtNQUNoQyxZQUFZLEVBQUUsS0FBSztNQUNuQixxQkFBcUIsRUFBRSxLQUFLO01BQzVCLHFCQUFxQixFQUFFLElBQUk7TUFDM0IsZUFBZSxFQUFFLEtBQUs7TUFDdEIsY0FBYyxFQUFFLEtBQUs7TUFDckIseUJBQXlCLEVBQUU7SUFDL0IsQ0FBQyxFQUFFRixJQUFJLENBQUNRLGFBQWEsQ0FBQztJQUN0QixNQUFNYyxRQUFRLEdBQUdyQixNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDb0IsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFckIsSUFBSSxDQUFDVyxPQUFPLENBQUM7SUFDakUsTUFBTUosYUFBYSxHQUFHUCxJQUFJLENBQUNPLGFBQWEsSUFBSSxFQUFFO0lBQzlDLE1BQU1LLFNBQVMsR0FBR1osSUFBSSxDQUFDWSxTQUFTO0lBQ2hDLE1BQU1XLGNBQWMsR0FBR2YsYUFBYSxDQUFDLFlBQVksQ0FBQztJQUNsRCxNQUFNZ0IsWUFBWSxHQUFHRCxjQUFjLEdBQUcsSUFBSSxHQUFHLEdBQUc7SUFDaEQsTUFBTUUsVUFBVSxHQUFHeEIsTUFBTSxDQUFDb0IsTUFBTSxDQUFDLElBQUksQ0FBQztJQUN0QyxNQUFNSyxTQUFTLEdBQUd6QixNQUFNLENBQUNvQixNQUFNLENBQUMsSUFBSSxDQUFDO0lBQ3JDLE1BQU1KLEVBQUUsR0FBR2pCLElBQUksQ0FBQ2lCLEVBQUUsSUFBSXhCLEtBQUssQ0FBQ2tDLE1BQU07SUFDbEMsTUFBTUMsS0FBSyxHQUFHO01BQ1ZULE9BQU8sRUFBRWxCLE1BQU0sQ0FBQ29CLE1BQU0sQ0FBQyxJQUFJLENBQUM7TUFDNUJRLE1BQU0sRUFBRTVCLE1BQU0sQ0FBQ29CLE1BQU0sQ0FBQyxJQUFJLENBQUM7TUFDM0JTLEtBQUssRUFBRTdCLE1BQU0sQ0FBQ29CLE1BQU0sQ0FBQyxJQUFJLENBQUM7TUFDMUJVLE9BQU8sRUFBRTlCLE1BQU0sQ0FBQ29CLE1BQU0sQ0FBQyxJQUFJLENBQUM7TUFDNUJXLE9BQU8sRUFBRS9CLE1BQU0sQ0FBQ29CLE1BQU0sQ0FBQyxJQUFJLENBQUM7TUFDNUJZLE1BQU0sRUFBRWhDLE1BQU0sQ0FBQ29CLE1BQU0sQ0FBQyxJQUFJLENBQUM7TUFDM0JQLFNBQVMsRUFBRWIsTUFBTSxDQUFDb0IsTUFBTSxDQUFDLElBQUksQ0FBQztNQUM5QmEsT0FBTyxFQUFFakMsTUFBTSxDQUFDb0IsTUFBTSxDQUFDLElBQUksQ0FBQztNQUM1QmMsS0FBSyxFQUFFbEMsTUFBTSxDQUFDb0IsTUFBTSxDQUFDLElBQUksQ0FBQztNQUMxQmUsU0FBUyxFQUFFbkMsTUFBTSxDQUFDb0IsTUFBTSxDQUFDLElBQUksQ0FBQztNQUM5QmdCLElBQUksRUFBRTtJQUNWLENBQUM7SUFDRCxNQUFNQyxRQUFRLEdBQUcsaUNBQWlDO0lBQ2xELE1BQU1DLGNBQWMsR0FBRyxJQUFJQyxNQUFNLENBQUMsS0FBSyxHQUFHaEMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsTUFBTSxDQUFDO0lBQ3BGLEVBQUUsQ0FBQ2lDLE1BQU0sQ0FBQ3pDLElBQUksQ0FBQ0ksS0FBSyxJQUFJLEVBQUUsQ0FBQyxDQUFDc0MsTUFBTSxDQUFDQyxPQUFPLENBQUMsQ0FBQ0MsT0FBTyxDQUFDLFVBQVVDLEdBQUcsRUFBRTtNQUMvRCxNQUFNM0IsR0FBRyxHQUFHLE9BQU8yQixHQUFHLEtBQUssUUFBUSxHQUFHQSxHQUFHLENBQUMzQixHQUFHLEdBQUcyQixHQUFHO01BQ25ELE1BQU1DLFVBQVUsR0FBRzdDLE1BQU0sQ0FBQ29DLElBQUksQ0FBQ1EsR0FBRyxDQUFDLENBQUM3RCxHQUFHLENBQUMsVUFBVWtDLEdBQUcsRUFBRTtRQUNuRCxNQUFNNkIsYUFBYSxHQUFHO1VBQ2xCMUMsT0FBTyxFQUFFLE9BQU87VUFDaEJVLE1BQU0sRUFBRSxTQUFTO1VBQ2pCQyxNQUFNLEVBQUU7UUFDWixDQUFDO1FBQ0QsT0FBTytCLGFBQWEsQ0FBQzdCLEdBQUcsQ0FBQztNQUM3QixDQUFDLENBQUMsQ0FBQ3dCLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDLENBQUNLLEdBQUcsQ0FBQyxDQUFDO01BQ3hCLElBQUlGLFVBQVUsRUFBRTtRQUNabEIsS0FBSyxDQUFDa0IsVUFBVSxDQUFDLENBQUM1QixHQUFHLENBQUMsR0FBRyxJQUFJO01BQ2pDO01BQ0FVLEtBQUssQ0FBQ0MsTUFBTSxDQUFDWCxHQUFHLENBQUMsR0FBRyxJQUFJO01BQ3hCVSxLQUFLLENBQUNTLElBQUksQ0FBQ1ksSUFBSSxDQUFDL0IsR0FBRyxDQUFDO0lBQ3hCLENBQUMsQ0FBQztJQUNGLEVBQUUsQ0FBQ3VCLE1BQU0sQ0FBQ3pDLElBQUksQ0FBQ0ssT0FBTyxJQUFJLEVBQUUsQ0FBQyxDQUFDcUMsTUFBTSxDQUFDQyxPQUFPLENBQUMsQ0FBQ0MsT0FBTyxDQUFDLFVBQVUxQixHQUFHLEVBQUU7TUFDakVVLEtBQUssQ0FBQ0UsS0FBSyxDQUFDWixHQUFHLENBQUMsR0FBRyxJQUFJO01BQ3ZCVSxLQUFLLENBQUNTLElBQUksQ0FBQ1ksSUFBSSxDQUFDL0IsR0FBRyxDQUFDO0lBQ3hCLENBQUMsQ0FBQztJQUNGLEVBQUUsQ0FBQ3VCLE1BQU0sQ0FBQ3pDLElBQUksQ0FBQ2UsTUFBTSxJQUFJLEVBQUUsQ0FBQyxDQUFDMkIsTUFBTSxDQUFDQyxPQUFPLENBQUMsQ0FBQ0MsT0FBTyxDQUFDLFVBQVUxQixHQUFHLEVBQUU7TUFDaEVVLEtBQUssQ0FBQ0csT0FBTyxDQUFDYixHQUFHLENBQUMsR0FBRyxJQUFJO01BQ3pCVSxLQUFLLENBQUNTLElBQUksQ0FBQ1ksSUFBSSxDQUFDL0IsR0FBRyxDQUFDO0lBQ3hCLENBQUMsQ0FBQztJQUNGLEVBQUUsQ0FBQ3VCLE1BQU0sQ0FBQ3pDLElBQUksQ0FBQ2dCLE1BQU0sSUFBSSxFQUFFLENBQUMsQ0FBQzBCLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDLENBQUNDLE9BQU8sQ0FBQyxVQUFVMUIsR0FBRyxFQUFFO01BQ2hFVSxLQUFLLENBQUNJLE9BQU8sQ0FBQ2QsR0FBRyxDQUFDLEdBQUcsSUFBSTtNQUN6QlUsS0FBSyxDQUFDUyxJQUFJLENBQUNZLElBQUksQ0FBQy9CLEdBQUcsQ0FBQztJQUN4QixDQUFDLENBQUM7SUFDRixFQUFFLENBQUN1QixNQUFNLENBQUN6QyxJQUFJLENBQUNVLEtBQUssSUFBSSxFQUFFLENBQUMsQ0FBQ2dDLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDLENBQUNDLE9BQU8sQ0FBQyxVQUFVMUIsR0FBRyxFQUFFO01BQy9EVSxLQUFLLENBQUNLLE1BQU0sQ0FBQ2YsR0FBRyxDQUFDLEdBQUcsSUFBSTtNQUN4QlUsS0FBSyxDQUFDUyxJQUFJLENBQUNZLElBQUksQ0FBQy9CLEdBQUcsQ0FBQztJQUN4QixDQUFDLENBQUM7SUFDRixFQUFFLENBQUN1QixNQUFNLENBQUN6QyxJQUFJLENBQUNjLFNBQVMsSUFBSSxFQUFFLENBQUMsQ0FBQzRCLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDLENBQUNDLE9BQU8sQ0FBQyxVQUFVMUIsR0FBRyxFQUFFO01BQ25FVSxLQUFLLENBQUNkLFNBQVMsQ0FBQ0ksR0FBRyxDQUFDLEdBQUcsSUFBSTtNQUMzQlUsS0FBSyxDQUFDUyxJQUFJLENBQUNZLElBQUksQ0FBQy9CLEdBQUcsQ0FBQztJQUN4QixDQUFDLENBQUM7SUFDRixJQUFJLE9BQU9sQixJQUFJLENBQUNhLElBQUksS0FBSyxRQUFRLEVBQUU7TUFDL0JaLE1BQU0sQ0FBQ2lELE9BQU8sQ0FBQ2xELElBQUksQ0FBQ2EsSUFBSSxDQUFDLENBQUMrQixPQUFPLENBQUMsQ0FBQyxDQUFDMUIsR0FBRyxFQUFFaUMsS0FBSyxDQUFDLEtBQUs7UUFDaEQsSUFBSSxPQUFPQSxLQUFLLEtBQUssUUFBUSxFQUFFO1VBQzNCdkIsS0FBSyxDQUFDTyxLQUFLLENBQUNqQixHQUFHLENBQUMsR0FBR2lDLEtBQUs7VUFDeEJ2QixLQUFLLENBQUNTLElBQUksQ0FBQ1ksSUFBSSxDQUFDL0IsR0FBRyxDQUFDO1FBQ3hCO01BQ0osQ0FBQyxDQUFDO0lBQ047SUFDQSxJQUFJLE9BQU9sQixJQUFJLENBQUNTLE1BQU0sS0FBSyxRQUFRLEVBQUU7TUFDakNSLE1BQU0sQ0FBQ2lELE9BQU8sQ0FBQ2xELElBQUksQ0FBQ1MsTUFBTSxDQUFDLENBQUNtQyxPQUFPLENBQUMsQ0FBQyxDQUFDMUIsR0FBRyxFQUFFaUMsS0FBSyxDQUFDLEtBQUs7UUFDbEQsSUFBSSxPQUFPQSxLQUFLLEtBQUssVUFBVSxFQUFFO1VBQzdCdkIsS0FBSyxDQUFDUSxTQUFTLENBQUNsQixHQUFHLENBQUMsR0FBR2lDLEtBQUs7VUFDNUJ2QixLQUFLLENBQUNTLElBQUksQ0FBQ1ksSUFBSSxDQUFDL0IsR0FBRyxDQUFDO1FBQ3hCO01BQ0osQ0FBQyxDQUFDO0lBQ047SUFDQSxJQUFJLE9BQU9sQixJQUFJLENBQUNNLE1BQU0sS0FBSyxXQUFXLEVBQUU7TUFDcEMsSUFBSXhCLEtBQUssQ0FBQ0MsT0FBTyxDQUFDaUIsSUFBSSxDQUFDTSxNQUFNLENBQUMsSUFBSSxPQUFPTixJQUFJLENBQUNNLE1BQU0sS0FBSyxRQUFRLEVBQUU7UUFDL0QsRUFBRSxDQUFDbUMsTUFBTSxDQUFDekMsSUFBSSxDQUFDTSxNQUFNLENBQUMsQ0FBQ29DLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDLENBQUNDLE9BQU8sQ0FBQyxVQUFVMUIsR0FBRyxFQUFFO1VBQzFEVSxLQUFLLENBQUNNLE9BQU8sQ0FBQ2hCLEdBQUcsQ0FBQyxHQUFHLElBQUk7UUFDN0IsQ0FBQyxDQUFDO01BQ04sQ0FBQyxNQUNJLElBQUksT0FBT2xCLElBQUksQ0FBQ00sTUFBTSxLQUFLLFFBQVEsRUFBRTtRQUN0Q0wsTUFBTSxDQUFDaUQsT0FBTyxDQUFDbEQsSUFBSSxDQUFDTSxNQUFNLENBQUMsQ0FBQ3NDLE9BQU8sQ0FBQyxDQUFDLENBQUMxQixHQUFHLEVBQUVpQyxLQUFLLENBQUMsS0FBSztVQUNsRCxJQUFJLE9BQU9BLEtBQUssS0FBSyxTQUFTLElBQUksT0FBT0EsS0FBSyxLQUFLLFVBQVUsRUFBRTtZQUMzRHZCLEtBQUssQ0FBQ00sT0FBTyxDQUFDaEIsR0FBRyxDQUFDLEdBQUdpQyxLQUFLO1VBQzlCO1FBQ0osQ0FBQyxDQUFDO01BQ047SUFDSjtJQUNBQyxhQUFhLENBQUNwRCxJQUFJLENBQUNrQixHQUFHLEVBQUVDLE9BQU8sRUFBRW5CLElBQUksQ0FBQ1csT0FBTyxFQUFFaUIsS0FBSyxDQUFDQyxNQUFNLENBQUM7SUFDNUQ1QixNQUFNLENBQUNvQyxJQUFJLENBQUNmLFFBQVEsQ0FBQyxDQUFDc0IsT0FBTyxDQUFDLFVBQVUxQixHQUFHLEVBQUU7TUFDekMsQ0FBQ1UsS0FBSyxDQUFDVCxPQUFPLENBQUNELEdBQUcsQ0FBQyxJQUFJLEVBQUUsRUFBRTBCLE9BQU8sQ0FBQyxVQUFVekMsS0FBSyxFQUFFO1FBQ2hEbUIsUUFBUSxDQUFDbkIsS0FBSyxDQUFDLEdBQUdtQixRQUFRLENBQUNKLEdBQUcsQ0FBQztNQUNuQyxDQUFDLENBQUM7SUFDTixDQUFDLENBQUM7SUFDRixJQUFJbUMsS0FBSyxHQUFHLElBQUk7SUFDaEJDLGtCQUFrQixDQUFDLENBQUM7SUFDcEIsSUFBSUMsUUFBUSxHQUFHLEVBQUU7SUFDakIsTUFBTUMsSUFBSSxHQUFHdkQsTUFBTSxDQUFDQyxNQUFNLENBQUNELE1BQU0sQ0FBQ29CLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtNQUFFb0MsQ0FBQyxFQUFFO0lBQUcsQ0FBQyxDQUFDO0lBQzFELE1BQU1DLFVBQVUsR0FBRyxDQUFDLENBQUM7SUFDckIsS0FBSyxJQUFJNUYsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHd0IsSUFBSSxDQUFDdkIsTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtNQUNsQyxNQUFNNkYsR0FBRyxHQUFHckUsSUFBSSxDQUFDeEIsQ0FBQyxDQUFDO01BQ25CLE1BQU04RixZQUFZLEdBQUdELEdBQUcsQ0FBQ0UsT0FBTyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUM7TUFDakQsSUFBSUMsTUFBTTtNQUNWLElBQUk1QyxHQUFHO01BQ1AsSUFBSTZDLE9BQU87TUFDWCxJQUFJQyxDQUFDO01BQ0wsSUFBSUMsSUFBSTtNQUNSLElBQUlkLEtBQUs7TUFDVCxJQUFJUSxHQUFHLEtBQUssSUFBSSxJQUFJTyxvQkFBb0IsQ0FBQ1AsR0FBRyxDQUFDLEVBQUU7UUFDM0NRLGNBQWMsQ0FBQ1IsR0FBRyxDQUFDO01BQ3ZCLENBQUMsTUFDSSxJQUFJQyxZQUFZLENBQUMvRixLQUFLLENBQUMsV0FBVyxDQUFDLEVBQUU7UUFDdENzRyxjQUFjLENBQUNSLEdBQUcsQ0FBQztRQUNuQjtNQUNKLENBQUMsTUFDSSxJQUFJQSxHQUFHLENBQUM5RixLQUFLLENBQUMsUUFBUSxDQUFDLElBQUssQ0FBQzJDLGFBQWEsQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJbUQsR0FBRyxDQUFDOUYsS0FBSyxDQUFDLE9BQU8sQ0FBRSxFQUFFO1FBQzNGbUcsQ0FBQyxHQUFHTCxHQUFHLENBQUM5RixLQUFLLENBQUMsd0JBQXdCLENBQUM7UUFDdkMsSUFBSW1HLENBQUMsS0FBSyxJQUFJLElBQUlsRixLQUFLLENBQUNDLE9BQU8sQ0FBQ2lGLENBQUMsQ0FBQyxJQUFJQSxDQUFDLENBQUNqRyxNQUFNLElBQUksQ0FBQyxFQUFFO1VBQ2pELElBQUlxRyxlQUFlLENBQUNKLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRXBDLEtBQUssQ0FBQ0MsTUFBTSxDQUFDLEVBQUU7WUFDckMvRCxDQUFDLEdBQUd1RyxRQUFRLENBQUN2RyxDQUFDLEVBQUVrRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUxRSxJQUFJLEVBQUUwRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDckMsQ0FBQyxNQUNJLElBQUlJLGVBQWUsQ0FBQ0osQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFcEMsS0FBSyxDQUFDTyxLQUFLLENBQUMsS0FBSyxLQUFLLEVBQUU7WUFDbkRyRSxDQUFDLEdBQUd3RyxRQUFRLENBQUN4RyxDQUFDLEVBQUVrRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUxRSxJQUFJLEVBQUUwRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDckMsQ0FBQyxNQUNJO1lBQ0RPLE1BQU0sQ0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDdEI7UUFDSjtNQUNKLENBQUMsTUFDSSxJQUFJTCxHQUFHLENBQUM5RixLQUFLLENBQUMwRSxjQUFjLENBQUMsSUFBSS9CLGFBQWEsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO1FBQ3JFd0QsQ0FBQyxHQUFHTCxHQUFHLENBQUM5RixLQUFLLENBQUMwRSxjQUFjLENBQUM7UUFDN0IsSUFBSXlCLENBQUMsS0FBSyxJQUFJLElBQUlsRixLQUFLLENBQUNDLE9BQU8sQ0FBQ2lGLENBQUMsQ0FBQyxJQUFJQSxDQUFDLENBQUNqRyxNQUFNLElBQUksQ0FBQyxFQUFFO1VBQ2pEbUQsR0FBRyxHQUFHOEMsQ0FBQyxDQUFDLENBQUMsQ0FBQztVQUNWTyxNQUFNLENBQUNyRCxHQUFHLEVBQUVrRCxlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ0MsTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7UUFDckU7TUFDSixDQUFDLE1BQ0ksSUFBSThCLEdBQUcsQ0FBQzlGLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSyxDQUFDMkMsYUFBYSxDQUFDLHFCQUFxQixDQUFDLElBQUltRCxHQUFHLENBQUM5RixLQUFLLENBQUMsU0FBUyxDQUFFLEVBQUU7UUFDNUZtRyxDQUFDLEdBQUdMLEdBQUcsQ0FBQzlGLEtBQUssQ0FBQyxVQUFVLENBQUM7UUFDekIsSUFBSW1HLENBQUMsS0FBSyxJQUFJLElBQUlsRixLQUFLLENBQUNDLE9BQU8sQ0FBQ2lGLENBQUMsQ0FBQyxJQUFJQSxDQUFDLENBQUNqRyxNQUFNLElBQUksQ0FBQyxFQUFFO1VBQ2pEbUQsR0FBRyxHQUFHOEMsQ0FBQyxDQUFDLENBQUMsQ0FBQztVQUNWLElBQUlJLGVBQWUsQ0FBQ2xELEdBQUcsRUFBRVUsS0FBSyxDQUFDQyxNQUFNLENBQUMsRUFBRTtZQUNwQy9ELENBQUMsR0FBR3VHLFFBQVEsQ0FBQ3ZHLENBQUMsRUFBRW9ELEdBQUcsRUFBRTVCLElBQUksQ0FBQztVQUM5QixDQUFDLE1BQ0ksSUFBSThFLGVBQWUsQ0FBQ2xELEdBQUcsRUFBRVUsS0FBSyxDQUFDTyxLQUFLLENBQUMsS0FBSyxLQUFLLEVBQUU7WUFDbERyRSxDQUFDLEdBQUd3RyxRQUFRLENBQUN4RyxDQUFDLEVBQUVvRCxHQUFHLEVBQUU1QixJQUFJLENBQUM7VUFDOUIsQ0FBQyxNQUNJO1lBQ0QyRSxJQUFJLEdBQUczRSxJQUFJLENBQUN4QixDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2xCLElBQUltRyxJQUFJLEtBQUt2RixTQUFTLEtBQUssQ0FBQ3VGLElBQUksQ0FBQ3BHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFDeENvRyxJQUFJLENBQUNwRyxLQUFLLENBQUN5RSxRQUFRLENBQUMsQ0FBQyxJQUNyQixDQUFDOEIsZUFBZSxDQUFDbEQsR0FBRyxFQUFFVSxLQUFLLENBQUNFLEtBQUssQ0FBQyxJQUNsQyxDQUFDc0MsZUFBZSxDQUFDbEQsR0FBRyxFQUFFVSxLQUFLLENBQUNLLE1BQU0sQ0FBQyxFQUFFO2NBQ3JDc0MsTUFBTSxDQUFDckQsR0FBRyxFQUFFK0MsSUFBSSxDQUFDO2NBQ2pCbkcsQ0FBQyxFQUFFO1lBQ1AsQ0FBQyxNQUNJLElBQUksZ0JBQWdCLENBQUNhLElBQUksQ0FBQ3NGLElBQUksQ0FBQyxFQUFFO2NBQ2xDTSxNQUFNLENBQUNyRCxHQUFHLEVBQUUrQyxJQUFJLENBQUM7Y0FDakJuRyxDQUFDLEVBQUU7WUFDUCxDQUFDLE1BQ0k7Y0FDRHlHLE1BQU0sQ0FBQ3JELEdBQUcsRUFBRXNELFlBQVksQ0FBQ3RELEdBQUcsQ0FBQyxDQUFDO1lBQ2xDO1VBQ0o7UUFDSjtNQUNKLENBQUMsTUFDSSxJQUFJeUMsR0FBRyxDQUFDOUYsS0FBSyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1FBQzVCbUcsQ0FBQyxHQUFHTCxHQUFHLENBQUM5RixLQUFLLENBQUMsc0JBQXNCLENBQUM7UUFDckMsSUFBSW1HLENBQUMsS0FBSyxJQUFJLElBQUlsRixLQUFLLENBQUNDLE9BQU8sQ0FBQ2lGLENBQUMsQ0FBQyxJQUFJQSxDQUFDLENBQUNqRyxNQUFNLElBQUksQ0FBQyxFQUFFO1VBQ2pEd0csTUFBTSxDQUFDUCxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUVBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QjtNQUNKLENBQUMsTUFDSSxJQUFJTCxHQUFHLENBQUM5RixLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQzhGLEdBQUcsQ0FBQzlGLEtBQUssQ0FBQ3lFLFFBQVEsQ0FBQyxFQUFFO1FBQ25EMkIsSUFBSSxHQUFHM0UsSUFBSSxDQUFDeEIsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNsQmtHLENBQUMsR0FBR0wsR0FBRyxDQUFDOUYsS0FBSyxDQUFDLFdBQVcsQ0FBQztRQUMxQixJQUFJbUcsQ0FBQyxLQUFLLElBQUksSUFBSWxGLEtBQUssQ0FBQ0MsT0FBTyxDQUFDaUYsQ0FBQyxDQUFDLElBQUlBLENBQUMsQ0FBQ2pHLE1BQU0sSUFBSSxDQUFDLEVBQUU7VUFDakRtRCxHQUFHLEdBQUc4QyxDQUFDLENBQUMsQ0FBQyxDQUFDO1VBQ1YsSUFBSUMsSUFBSSxLQUFLdkYsU0FBUyxJQUFJLENBQUN1RixJQUFJLENBQUNwRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQ3ZDLENBQUN1RyxlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ0UsS0FBSyxDQUFDLElBQ2xDLENBQUNzQyxlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ0ssTUFBTSxDQUFDLEVBQUU7WUFDckNzQyxNQUFNLENBQUNyRCxHQUFHLEVBQUUrQyxJQUFJLENBQUM7WUFDakJuRyxDQUFDLEVBQUU7VUFDUCxDQUFDLE1BQ0k7WUFDRHlHLE1BQU0sQ0FBQ3JELEdBQUcsRUFBRXNELFlBQVksQ0FBQ3RELEdBQUcsQ0FBQyxDQUFDO1VBQ2xDO1FBQ0o7TUFDSixDQUFDLE1BQ0ksSUFBSXlDLEdBQUcsQ0FBQzlGLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDOEYsR0FBRyxDQUFDOUYsS0FBSyxDQUFDeUUsUUFBUSxDQUFDLEVBQUU7UUFDbkR5QixPQUFPLEdBQUdKLEdBQUcsQ0FBQ2MsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDQyxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQ3BDWixNQUFNLEdBQUcsS0FBSztRQUNkLEtBQUssSUFBSWEsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHWixPQUFPLENBQUNoRyxNQUFNLEVBQUU0RyxDQUFDLEVBQUUsRUFBRTtVQUNyQ1YsSUFBSSxHQUFHTixHQUFHLENBQUNjLEtBQUssQ0FBQ0UsQ0FBQyxHQUFHLENBQUMsQ0FBQztVQUN2QixJQUFJWixPQUFPLENBQUNZLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSVosT0FBTyxDQUFDWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFO1lBQzFDeEIsS0FBSyxHQUFHUSxHQUFHLENBQUNjLEtBQUssQ0FBQ0UsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN4QnpELEdBQUcsR0FBRzZDLE9BQU8sQ0FBQ1ksQ0FBQyxDQUFDO1lBQ2hCLElBQUlQLGVBQWUsQ0FBQ2xELEdBQUcsRUFBRVUsS0FBSyxDQUFDQyxNQUFNLENBQUMsRUFBRTtjQUNwQy9ELENBQUMsR0FBR3VHLFFBQVEsQ0FBQ3ZHLENBQUMsRUFBRW9ELEdBQUcsRUFBRTVCLElBQUksRUFBRTZELEtBQUssQ0FBQztZQUNyQyxDQUFDLE1BQ0ksSUFBSWlCLGVBQWUsQ0FBQ2xELEdBQUcsRUFBRVUsS0FBSyxDQUFDTyxLQUFLLENBQUMsS0FBSyxLQUFLLEVBQUU7Y0FDbERyRSxDQUFDLEdBQUd3RyxRQUFRLENBQUN4RyxDQUFDLEVBQUVvRCxHQUFHLEVBQUU1QixJQUFJLEVBQUU2RCxLQUFLLENBQUM7WUFDckMsQ0FBQyxNQUNJO2NBQ0RvQixNQUFNLENBQUNyRCxHQUFHLEVBQUVpQyxLQUFLLENBQUM7WUFDdEI7WUFDQVcsTUFBTSxHQUFHLElBQUk7WUFDYjtVQUNKO1VBQ0EsSUFBSUcsSUFBSSxLQUFLLEdBQUcsRUFBRTtZQUNkTSxNQUFNLENBQUNSLE9BQU8sQ0FBQ1ksQ0FBQyxDQUFDLEVBQUVWLElBQUksQ0FBQztZQUN4QjtVQUNKO1VBQ0EsSUFBSSxVQUFVLENBQUN0RixJQUFJLENBQUNvRixPQUFPLENBQUNZLENBQUMsQ0FBQyxDQUFDLElBQzNCLDBCQUEwQixDQUFDaEcsSUFBSSxDQUFDc0YsSUFBSSxDQUFDLElBQ3JDRyxlQUFlLENBQUNILElBQUksRUFBRXJDLEtBQUssQ0FBQ0UsS0FBSyxDQUFDLEtBQUssS0FBSyxFQUFFO1lBQzlDeUMsTUFBTSxDQUFDUixPQUFPLENBQUNZLENBQUMsQ0FBQyxFQUFFVixJQUFJLENBQUM7WUFDeEJILE1BQU0sR0FBRyxJQUFJO1lBQ2I7VUFDSjtVQUNBLElBQUlDLE9BQU8sQ0FBQ1ksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJWixPQUFPLENBQUNZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzlHLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM5QzBHLE1BQU0sQ0FBQ1IsT0FBTyxDQUFDWSxDQUFDLENBQUMsRUFBRVYsSUFBSSxDQUFDO1lBQ3hCSCxNQUFNLEdBQUcsSUFBSTtZQUNiO1VBQ0osQ0FBQyxNQUNJO1lBQ0RTLE1BQU0sQ0FBQ1IsT0FBTyxDQUFDWSxDQUFDLENBQUMsRUFBRUgsWUFBWSxDQUFDVCxPQUFPLENBQUNZLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDaEQ7UUFDSjtRQUNBekQsR0FBRyxHQUFHeUMsR0FBRyxDQUFDYyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDWCxNQUFNLElBQUk1QyxHQUFHLEtBQUssR0FBRyxFQUFFO1VBQ3hCLElBQUlrRCxlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ0MsTUFBTSxDQUFDLEVBQUU7WUFDcEMvRCxDQUFDLEdBQUd1RyxRQUFRLENBQUN2RyxDQUFDLEVBQUVvRCxHQUFHLEVBQUU1QixJQUFJLENBQUM7VUFDOUIsQ0FBQyxNQUNJLElBQUk4RSxlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ08sS0FBSyxDQUFDLEtBQUssS0FBSyxFQUFFO1lBQ2xEckUsQ0FBQyxHQUFHd0csUUFBUSxDQUFDeEcsQ0FBQyxFQUFFb0QsR0FBRyxFQUFFNUIsSUFBSSxDQUFDO1VBQzlCLENBQUMsTUFDSTtZQUNEMkUsSUFBSSxHQUFHM0UsSUFBSSxDQUFDeEIsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNsQixJQUFJbUcsSUFBSSxLQUFLdkYsU0FBUyxLQUFLLENBQUMsYUFBYSxDQUFDQyxJQUFJLENBQUNzRixJQUFJLENBQUMsSUFDaERBLElBQUksQ0FBQ3BHLEtBQUssQ0FBQ3lFLFFBQVEsQ0FBQyxDQUFDLElBQ3JCLENBQUM4QixlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ0UsS0FBSyxDQUFDLElBQ2xDLENBQUNzQyxlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ0ssTUFBTSxDQUFDLEVBQUU7Y0FDckNzQyxNQUFNLENBQUNyRCxHQUFHLEVBQUUrQyxJQUFJLENBQUM7Y0FDakJuRyxDQUFDLEVBQUU7WUFDUCxDQUFDLE1BQ0ksSUFBSSxnQkFBZ0IsQ0FBQ2EsSUFBSSxDQUFDc0YsSUFBSSxDQUFDLEVBQUU7Y0FDbENNLE1BQU0sQ0FBQ3JELEdBQUcsRUFBRStDLElBQUksQ0FBQztjQUNqQm5HLENBQUMsRUFBRTtZQUNQLENBQUMsTUFDSTtjQUNEeUcsTUFBTSxDQUFDckQsR0FBRyxFQUFFc0QsWUFBWSxDQUFDdEQsR0FBRyxDQUFDLENBQUM7WUFDbEM7VUFDSjtRQUNKO01BQ0osQ0FBQyxNQUNJLElBQUl5QyxHQUFHLENBQUM5RixLQUFLLENBQUMsVUFBVSxDQUFDLElBQzFCOEYsR0FBRyxDQUFDOUYsS0FBSyxDQUFDeUUsUUFBUSxDQUFDLElBQ25COEIsZUFBZSxDQUFDVCxHQUFHLENBQUNjLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRTdDLEtBQUssQ0FBQ0UsS0FBSyxDQUFDLEVBQUU7UUFDNUNaLEdBQUcsR0FBR3lDLEdBQUcsQ0FBQ2MsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUNsQkYsTUFBTSxDQUFDckQsR0FBRyxFQUFFc0QsWUFBWSxDQUFDdEQsR0FBRyxDQUFDLENBQUM7TUFDbEMsQ0FBQyxNQUNJLElBQUl5QyxHQUFHLEtBQUssSUFBSSxFQUFFO1FBQ25CSixRQUFRLEdBQUdqRSxJQUFJLENBQUNtRixLQUFLLENBQUMzRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzVCO01BQ0osQ0FBQyxNQUNJLElBQUkwQyxhQUFhLENBQUMsb0JBQW9CLENBQUMsRUFBRTtRQUMxQytDLFFBQVEsR0FBR2pFLElBQUksQ0FBQ21GLEtBQUssQ0FBQzNHLENBQUMsQ0FBQztRQUN4QjtNQUNKLENBQUMsTUFDSTtRQUNEcUcsY0FBYyxDQUFDUixHQUFHLENBQUM7TUFDdkI7SUFDSjtJQUNBaUIsWUFBWSxDQUFDcEIsSUFBSSxFQUFFLElBQUksQ0FBQztJQUN4Qm9CLFlBQVksQ0FBQ3BCLElBQUksRUFBRSxLQUFLLENBQUM7SUFDekJxQixTQUFTLENBQUNyQixJQUFJLENBQUM7SUFDZnNCLGdCQUFnQixDQUFDLENBQUM7SUFDbEJDLHVCQUF1QixDQUFDdkIsSUFBSSxFQUFFNUIsS0FBSyxDQUFDVCxPQUFPLEVBQUVHLFFBQVEsRUFBRSxJQUFJLENBQUM7SUFDNUQwRCxjQUFjLENBQUN4QixJQUFJLENBQUM7SUFDcEIsSUFBSWhELGFBQWEsQ0FBQyxxQkFBcUIsQ0FBQyxFQUNwQ3lFLGtCQUFrQixDQUFDekIsSUFBSSxDQUFDO0lBQzVCdkQsTUFBTSxDQUFDb0MsSUFBSSxDQUFDVCxLQUFLLENBQUNLLE1BQU0sQ0FBQyxDQUFDVyxPQUFPLENBQUMsVUFBVTFCLEdBQUcsRUFBRTtNQUM3QyxJQUFJLENBQUNnRSxNQUFNLENBQUMxQixJQUFJLEVBQUV0QyxHQUFHLENBQUN3RCxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDN0JILE1BQU0sQ0FBQ3JELEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDdEIsQ0FBQyxDQUFDO0lBQ0YsSUFBSUssY0FBYyxJQUFJZ0MsUUFBUSxDQUFDeEYsTUFBTSxFQUNqQ3lGLElBQUksQ0FBQ2hDLFlBQVksQ0FBQyxHQUFHLEVBQUU7SUFDM0IrQixRQUFRLENBQUNYLE9BQU8sQ0FBQyxVQUFVMUIsR0FBRyxFQUFFO01BQzVCc0MsSUFBSSxDQUFDaEMsWUFBWSxDQUFDLENBQUN5QixJQUFJLENBQUMvQixHQUFHLENBQUM7SUFDaEMsQ0FBQyxDQUFDO0lBQ0YsSUFBSVYsYUFBYSxDQUFDLHNCQUFzQixDQUFDLElBQUlBLGFBQWEsQ0FBQyxjQUFjLENBQUMsRUFBRTtNQUN4RVAsTUFBTSxDQUFDb0MsSUFBSSxDQUFDbUIsSUFBSSxDQUFDLENBQUNkLE1BQU0sQ0FBQ3hCLEdBQUcsSUFBSUEsR0FBRyxLQUFLLElBQUksSUFBSUEsR0FBRyxDQUFDaUUsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUN2QyxPQUFPLENBQUMxQixHQUFHLElBQUk7UUFDOUUsT0FBT3NDLElBQUksQ0FBQ3RDLEdBQUcsQ0FBQztNQUNwQixDQUFDLENBQUM7SUFDTjtJQUNBLElBQUlWLGFBQWEsQ0FBQyxlQUFlLENBQUMsRUFBRTtNQUNoQyxFQUFFLENBQUNpQyxNQUFNLENBQUMsR0FBR3hDLE1BQU0sQ0FBQ29DLElBQUksQ0FBQ2xCLE9BQU8sQ0FBQyxDQUFDbkMsR0FBRyxDQUFDb0csQ0FBQyxJQUFJakUsT0FBTyxDQUFDaUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDeEMsT0FBTyxDQUFDekMsS0FBSyxJQUFJO1FBQ3JFLElBQUlLLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJTCxLQUFLLENBQUNnRixRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7VUFDOUQsT0FBTzNCLElBQUksQ0FBQ3JELEtBQUssQ0FBQ3VFLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzFGLEdBQUcsQ0FBQ3FHLElBQUksSUFBSWpJLFNBQVMsQ0FBQ2lJLElBQUksQ0FBQyxDQUFDLENBQUNDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN4RTtRQUNBLE9BQU85QixJQUFJLENBQUNyRCxLQUFLLENBQUM7TUFDdEIsQ0FBQyxDQUFDO0lBQ047SUFDQSxTQUFTZ0UsY0FBY0EsQ0FBQ1IsR0FBRyxFQUFFO01BQ3pCLE1BQU00QixrQkFBa0IsR0FBR0MsaUJBQWlCLENBQUMsR0FBRyxFQUFFN0IsR0FBRyxDQUFDO01BQ3RELElBQUksT0FBTzRCLGtCQUFrQixLQUFLLFFBQVEsSUFBSSxPQUFPQSxrQkFBa0IsS0FBSyxRQUFRLEVBQUU7UUFDbEYvQixJQUFJLENBQUNDLENBQUMsQ0FBQ1IsSUFBSSxDQUFDc0Msa0JBQWtCLENBQUM7TUFDbkM7SUFDSjtJQUNBLFNBQVNqQixRQUFRQSxDQUFDeEcsQ0FBQyxFQUFFb0QsR0FBRyxFQUFFNUIsSUFBSSxFQUFFbUcsaUJBQWlCLEVBQUU7TUFDL0MsSUFBSWxHLEVBQUU7TUFDTixJQUFJbUcsS0FBSyxHQUFHdEIsZUFBZSxDQUFDbEQsR0FBRyxFQUFFVSxLQUFLLENBQUNPLEtBQUssQ0FBQztNQUM3Q3VELEtBQUssR0FBRyxPQUFPQSxLQUFLLEtBQUssUUFBUSxJQUFJQyxLQUFLLENBQUNELEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBR0EsS0FBSztNQUM3RCxJQUFJQSxLQUFLLEtBQUssQ0FBQyxFQUFFO1FBQ2IsSUFBSSxDQUFDRSxXQUFXLENBQUNILGlCQUFpQixDQUFDLEVBQUU7VUFDakNwQyxLQUFLLEdBQUd3QyxLQUFLLENBQUM1RSxFQUFFLENBQUMsNkJBQTZCLEVBQUVDLEdBQUcsQ0FBQyxDQUFDO1FBQ3pEO1FBQ0FxRCxNQUFNLENBQUNyRCxHQUFHLEVBQUVzRCxZQUFZLENBQUN0RCxHQUFHLENBQUMsQ0FBQztRQUM5QixPQUFPcEQsQ0FBQztNQUNaO01BQ0EsSUFBSWdJLFNBQVMsR0FBR0YsV0FBVyxDQUFDSCxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO01BQ3RELElBQUlqRixhQUFhLENBQUMsb0JBQW9CLENBQUMsRUFBRTtRQUNyQyxJQUFJbEIsSUFBSSxDQUFDdkIsTUFBTSxJQUFJRCxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUdnSSxTQUFTLEdBQUdKLEtBQUssRUFBRTtVQUMzQ3JDLEtBQUssR0FBR3dDLEtBQUssQ0FBQzVFLEVBQUUsQ0FBQyxvQ0FBb0MsRUFBRUMsR0FBRyxDQUFDLENBQUM7UUFDaEU7UUFDQTRFLFNBQVMsR0FBR0osS0FBSztNQUNyQixDQUFDLE1BQ0k7UUFDRCxLQUFLbkcsRUFBRSxHQUFHekIsQ0FBQyxHQUFHLENBQUMsRUFBRXlCLEVBQUUsR0FBR0QsSUFBSSxDQUFDdkIsTUFBTSxFQUFFd0IsRUFBRSxFQUFFLEVBQUU7VUFDckMsSUFBSSxDQUFDRCxJQUFJLENBQUNDLEVBQUUsQ0FBQyxDQUFDMUIsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJeUIsSUFBSSxDQUFDQyxFQUFFLENBQUMsQ0FBQzFCLEtBQUssQ0FBQ3lFLFFBQVEsQ0FBQyxJQUFJNEIsb0JBQW9CLENBQUM1RSxJQUFJLENBQUNDLEVBQUUsQ0FBQyxDQUFDLEVBQ3pGdUcsU0FBUyxFQUFFLENBQUMsS0FFWjtRQUNSO1FBQ0EsSUFBSUEsU0FBUyxHQUFHSixLQUFLLEVBQ2pCckMsS0FBSyxHQUFHd0MsS0FBSyxDQUFDNUUsRUFBRSxDQUFDLG9DQUFvQyxFQUFFQyxHQUFHLENBQUMsQ0FBQztNQUNwRTtNQUNBLElBQUk2RSxRQUFRLEdBQUdDLElBQUksQ0FBQ0MsR0FBRyxDQUFDSCxTQUFTLEVBQUVKLEtBQUssQ0FBQztNQUN6QyxJQUFJLENBQUNFLFdBQVcsQ0FBQ0gsaUJBQWlCLENBQUMsSUFBSU0sUUFBUSxHQUFHLENBQUMsRUFBRTtRQUNqRHhCLE1BQU0sQ0FBQ3JELEdBQUcsRUFBRXVFLGlCQUFpQixDQUFDO1FBQzlCTSxRQUFRLEVBQUU7TUFDZDtNQUNBLEtBQUt4RyxFQUFFLEdBQUd6QixDQUFDLEdBQUcsQ0FBQyxFQUFFeUIsRUFBRSxHQUFJd0csUUFBUSxHQUFHakksQ0FBQyxHQUFHLENBQUUsRUFBRXlCLEVBQUUsRUFBRSxFQUFFO1FBQzVDZ0YsTUFBTSxDQUFDckQsR0FBRyxFQUFFNUIsSUFBSSxDQUFDQyxFQUFFLENBQUMsQ0FBQztNQUN6QjtNQUNBLE9BQVF6QixDQUFDLEdBQUdpSSxRQUFRO0lBQ3hCO0lBQ0EsU0FBUzFCLFFBQVFBLENBQUN2RyxDQUFDLEVBQUVvRCxHQUFHLEVBQUU1QixJQUFJLEVBQUVtRyxpQkFBaUIsRUFBRTtNQUMvQyxJQUFJUyxTQUFTLEdBQUcsRUFBRTtNQUNsQixJQUFJakMsSUFBSSxHQUFHd0IsaUJBQWlCLElBQUluRyxJQUFJLENBQUN4QixDQUFDLEdBQUcsQ0FBQyxDQUFDO01BQzNDLE1BQU1xSSxVQUFVLEdBQUcvQixlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ08sS0FBSyxDQUFDO01BQ3BELElBQUlpQyxlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ0UsS0FBSyxDQUFDLElBQUksQ0FBRSxnQkFBZ0IsQ0FBQ25ELElBQUksQ0FBQ3NGLElBQUksQ0FBRSxFQUFFO1FBQ3JFaUMsU0FBUyxDQUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQztNQUN4QixDQUFDLE1BQ0ksSUFBSTJDLFdBQVcsQ0FBQzNCLElBQUksQ0FBQyxJQUNyQjJCLFdBQVcsQ0FBQ0gsaUJBQWlCLENBQUMsSUFBSSxJQUFJLENBQUM5RyxJQUFJLENBQUNzRixJQUFJLENBQUMsSUFBSSxDQUFDM0IsUUFBUSxDQUFDM0QsSUFBSSxDQUFDc0YsSUFBSSxDQUFDLElBQUksQ0FBQ0Msb0JBQW9CLENBQUNELElBQUksQ0FBRSxFQUFFO1FBQzVHLElBQUkzQyxRQUFRLENBQUNKLEdBQUcsQ0FBQyxLQUFLeEMsU0FBUyxFQUFFO1VBQzdCLE1BQU0wSCxNQUFNLEdBQUc5RSxRQUFRLENBQUNKLEdBQUcsQ0FBQztVQUM1QmdGLFNBQVMsR0FBR3BILEtBQUssQ0FBQ0MsT0FBTyxDQUFDcUgsTUFBTSxDQUFDLEdBQUdBLE1BQU0sR0FBRyxDQUFDQSxNQUFNLENBQUM7UUFDekQ7TUFDSixDQUFDLE1BQ0k7UUFDRCxJQUFJLENBQUNSLFdBQVcsQ0FBQ0gsaUJBQWlCLENBQUMsRUFBRTtVQUNqQ1MsU0FBUyxDQUFDakQsSUFBSSxDQUFDb0QsWUFBWSxDQUFDbkYsR0FBRyxFQUFFdUUsaUJBQWlCLENBQUMsQ0FBQztRQUN4RDtRQUNBLEtBQUssSUFBSWxHLEVBQUUsR0FBR3pCLENBQUMsR0FBRyxDQUFDLEVBQUV5QixFQUFFLEdBQUdELElBQUksQ0FBQ3ZCLE1BQU0sRUFBRXdCLEVBQUUsRUFBRSxFQUFFO1VBQ3pDLElBQUssQ0FBQ2lCLGFBQWEsQ0FBQyxlQUFlLENBQUMsSUFBSTBGLFNBQVMsQ0FBQ25JLE1BQU0sR0FBRyxDQUFDLElBQ3ZEb0ksVUFBVSxJQUFJLE9BQU9BLFVBQVUsS0FBSyxRQUFRLElBQUlELFNBQVMsQ0FBQ25JLE1BQU0sSUFBSW9JLFVBQVcsRUFDaEY7VUFDSmxDLElBQUksR0FBRzNFLElBQUksQ0FBQ0MsRUFBRSxDQUFDO1VBQ2YsSUFBSSxJQUFJLENBQUNaLElBQUksQ0FBQ3NGLElBQUksQ0FBQyxJQUFJLENBQUMzQixRQUFRLENBQUMzRCxJQUFJLENBQUNzRixJQUFJLENBQUMsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ0QsSUFBSSxDQUFDLEVBQ3RFO1VBQ0puRyxDQUFDLEdBQUd5QixFQUFFO1VBQ04yRyxTQUFTLENBQUNqRCxJQUFJLENBQUNvRCxZQUFZLENBQUNuRixHQUFHLEVBQUUrQyxJQUFJLENBQUMsQ0FBQztRQUMzQztNQUNKO01BQ0EsSUFBSSxPQUFPa0MsVUFBVSxLQUFLLFFBQVEsS0FBTUEsVUFBVSxJQUFJRCxTQUFTLENBQUNuSSxNQUFNLEdBQUdvSSxVQUFVLElBQzlFUixLQUFLLENBQUNRLFVBQVUsQ0FBQyxJQUFJRCxTQUFTLENBQUNuSSxNQUFNLEtBQUssQ0FBRSxDQUFDLEVBQUU7UUFDaERzRixLQUFLLEdBQUd3QyxLQUFLLENBQUM1RSxFQUFFLENBQUMsb0NBQW9DLEVBQUVDLEdBQUcsQ0FBQyxDQUFDO01BQ2hFO01BQ0FxRCxNQUFNLENBQUNyRCxHQUFHLEVBQUVnRixTQUFTLENBQUM7TUFDdEIsT0FBT3BJLENBQUM7SUFDWjtJQUNBLFNBQVN5RyxNQUFNQSxDQUFDckQsR0FBRyxFQUFFb0YsR0FBRyxFQUFFO01BQ3RCLElBQUksR0FBRyxDQUFDM0gsSUFBSSxDQUFDdUMsR0FBRyxDQUFDLElBQUlWLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxFQUFFO1FBQ3hELE1BQU1MLEtBQUssR0FBR2UsR0FBRyxDQUFDd0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDMUYsR0FBRyxDQUFDLFVBQVVxRyxJQUFJLEVBQUU7VUFDN0MsT0FBT2pJLFNBQVMsQ0FBQ2lJLElBQUksQ0FBQztRQUMxQixDQUFDLENBQUMsQ0FBQ0MsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNaaUIsV0FBVyxDQUFDckYsR0FBRyxFQUFFZixLQUFLLENBQUM7TUFDM0I7TUFDQSxNQUFNZ0QsS0FBSyxHQUFHa0QsWUFBWSxDQUFDbkYsR0FBRyxFQUFFb0YsR0FBRyxDQUFDO01BQ3BDLE1BQU1FLFFBQVEsR0FBR3RGLEdBQUcsQ0FBQ3dELEtBQUssQ0FBQyxHQUFHLENBQUM7TUFDL0IrQixNQUFNLENBQUNqRCxJQUFJLEVBQUVnRCxRQUFRLEVBQUVyRCxLQUFLLENBQUM7TUFDN0IsSUFBSXZCLEtBQUssQ0FBQ1QsT0FBTyxDQUFDRCxHQUFHLENBQUMsRUFBRTtRQUNwQlUsS0FBSyxDQUFDVCxPQUFPLENBQUNELEdBQUcsQ0FBQyxDQUFDMEIsT0FBTyxDQUFDLFVBQVVuRSxDQUFDLEVBQUU7VUFDcEMsTUFBTWlJLGFBQWEsR0FBR2pJLENBQUMsQ0FBQ2lHLEtBQUssQ0FBQyxHQUFHLENBQUM7VUFDbEMrQixNQUFNLENBQUNqRCxJQUFJLEVBQUVrRCxhQUFhLEVBQUV2RCxLQUFLLENBQUM7UUFDdEMsQ0FBQyxDQUFDO01BQ047TUFDQSxJQUFJcUQsUUFBUSxDQUFDekksTUFBTSxHQUFHLENBQUMsSUFBSXlDLGFBQWEsQ0FBQyxjQUFjLENBQUMsRUFBRTtRQUN0RCxDQUFDb0IsS0FBSyxDQUFDVCxPQUFPLENBQUNxRixRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU1RCxPQUFPLENBQUMsVUFBVW5FLENBQUMsRUFBRTtVQUNwRCxJQUFJaUksYUFBYSxHQUFHakksQ0FBQyxDQUFDaUcsS0FBSyxDQUFDLEdBQUcsQ0FBQztVQUNoQyxNQUFNaUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQ2xFLE1BQU0sQ0FBQytELFFBQVEsQ0FBQztVQUM3QkcsQ0FBQyxDQUFDQyxLQUFLLENBQUMsQ0FBQztVQUNURixhQUFhLEdBQUdBLGFBQWEsQ0FBQ2pFLE1BQU0sQ0FBQ2tFLENBQUMsQ0FBQztVQUN2QyxJQUFJLENBQUMsQ0FBQy9FLEtBQUssQ0FBQ1QsT0FBTyxDQUFDRCxHQUFHLENBQUMsSUFBSSxFQUFFLEVBQUVpRSxRQUFRLENBQUN1QixhQUFhLENBQUNwQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtZQUMvRG1CLE1BQU0sQ0FBQ2pELElBQUksRUFBRWtELGFBQWEsRUFBRXZELEtBQUssQ0FBQztVQUN0QztRQUNKLENBQUMsQ0FBQztNQUNOO01BQ0EsSUFBSWlCLGVBQWUsQ0FBQ2xELEdBQUcsRUFBRVUsS0FBSyxDQUFDZCxTQUFTLENBQUMsSUFBSSxDQUFDc0QsZUFBZSxDQUFDbEQsR0FBRyxFQUFFVSxLQUFLLENBQUNDLE1BQU0sQ0FBQyxFQUFFO1FBQzlFLE1BQU1RLElBQUksR0FBRyxDQUFDbkIsR0FBRyxDQUFDLENBQUN1QixNQUFNLENBQUNiLEtBQUssQ0FBQ1QsT0FBTyxDQUFDRCxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDbkRtQixJQUFJLENBQUNPLE9BQU8sQ0FBQyxVQUFVMUIsR0FBRyxFQUFFO1VBQ3hCakIsTUFBTSxDQUFDNEcsY0FBYyxDQUFDbkQsVUFBVSxFQUFFeEMsR0FBRyxFQUFFO1lBQ25DNEYsVUFBVSxFQUFFLElBQUk7WUFDaEJDLEdBQUdBLENBQUEsRUFBRztjQUNGLE9BQU9ULEdBQUc7WUFDZCxDQUFDO1lBQ0RVLEdBQUdBLENBQUM3RCxLQUFLLEVBQUU7Y0FDUG1ELEdBQUcsR0FBRyxPQUFPbkQsS0FBSyxLQUFLLFFBQVEsR0FBRzFELEtBQUssQ0FBQ3FCLFNBQVMsQ0FBQ3FDLEtBQUssQ0FBQyxHQUFHQSxLQUFLO1lBQ3BFO1VBQ0osQ0FBQyxDQUFDO1FBQ04sQ0FBQyxDQUFDO01BQ047SUFDSjtJQUNBLFNBQVNvRCxXQUFXQSxDQUFDckYsR0FBRyxFQUFFZixLQUFLLEVBQUU7TUFDN0IsSUFBSSxFQUFFeUIsS0FBSyxDQUFDVCxPQUFPLENBQUNELEdBQUcsQ0FBQyxJQUFJVSxLQUFLLENBQUNULE9BQU8sQ0FBQ0QsR0FBRyxDQUFDLENBQUNuRCxNQUFNLENBQUMsRUFBRTtRQUNwRDZELEtBQUssQ0FBQ1QsT0FBTyxDQUFDRCxHQUFHLENBQUMsR0FBRyxDQUFDZixLQUFLLENBQUM7UUFDNUJzQixVQUFVLENBQUN0QixLQUFLLENBQUMsR0FBRyxJQUFJO01BQzVCO01BQ0EsSUFBSSxFQUFFeUIsS0FBSyxDQUFDVCxPQUFPLENBQUNoQixLQUFLLENBQUMsSUFBSXlCLEtBQUssQ0FBQ1QsT0FBTyxDQUFDaEIsS0FBSyxDQUFDLENBQUNwQyxNQUFNLENBQUMsRUFBRTtRQUN4RHdJLFdBQVcsQ0FBQ3BHLEtBQUssRUFBRWUsR0FBRyxDQUFDO01BQzNCO0lBQ0o7SUFDQSxTQUFTbUYsWUFBWUEsQ0FBQ25GLEdBQUcsRUFBRW9GLEdBQUcsRUFBRTtNQUM1QixJQUFJLE9BQU9BLEdBQUcsS0FBSyxRQUFRLEtBQ3RCQSxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJQSxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLElBQ2xDQSxHQUFHLENBQUNBLEdBQUcsQ0FBQ3ZJLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBS3VJLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUNoQ0EsR0FBRyxHQUFHQSxHQUFHLENBQUNXLFNBQVMsQ0FBQyxDQUFDLEVBQUVYLEdBQUcsQ0FBQ3ZJLE1BQU0sR0FBRyxDQUFDLENBQUM7TUFDMUM7TUFDQSxJQUFJcUcsZUFBZSxDQUFDbEQsR0FBRyxFQUFFVSxLQUFLLENBQUNFLEtBQUssQ0FBQyxJQUFJc0MsZUFBZSxDQUFDbEQsR0FBRyxFQUFFVSxLQUFLLENBQUNLLE1BQU0sQ0FBQyxFQUFFO1FBQ3pFLElBQUksT0FBT3FFLEdBQUcsS0FBSyxRQUFRLEVBQ3ZCQSxHQUFHLEdBQUdBLEdBQUcsS0FBSyxNQUFNO01BQzVCO01BQ0EsSUFBSW5ELEtBQUssR0FBR3JFLEtBQUssQ0FBQ0MsT0FBTyxDQUFDdUgsR0FBRyxDQUFDLEdBQ3hCQSxHQUFHLENBQUN0SCxHQUFHLENBQUMsVUFBVWtJLENBQUMsRUFBRTtRQUFFLE9BQU8xQixpQkFBaUIsQ0FBQ3RFLEdBQUcsRUFBRWdHLENBQUMsQ0FBQztNQUFFLENBQUMsQ0FBQyxHQUMzRDFCLGlCQUFpQixDQUFDdEUsR0FBRyxFQUFFb0YsR0FBRyxDQUFDO01BQ2pDLElBQUlsQyxlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ0ssTUFBTSxDQUFDLEtBQUsyRCxXQUFXLENBQUN6QyxLQUFLLENBQUMsSUFBSSxPQUFPQSxLQUFLLEtBQUssU0FBUyxDQUFDLEVBQUU7UUFDMUZBLEtBQUssR0FBR2dFLFNBQVMsQ0FBQyxDQUFDO01BQ3ZCO01BQ0EsSUFBSS9DLGVBQWUsQ0FBQ2xELEdBQUcsRUFBRVUsS0FBSyxDQUFDZCxTQUFTLENBQUMsSUFBSXNELGVBQWUsQ0FBQ2xELEdBQUcsRUFBRVUsS0FBSyxDQUFDQyxNQUFNLENBQUMsRUFBRTtRQUM3RSxJQUFJL0MsS0FBSyxDQUFDQyxPQUFPLENBQUN1SCxHQUFHLENBQUMsRUFDbEJuRCxLQUFLLEdBQUdtRCxHQUFHLENBQUN0SCxHQUFHLENBQUVzSCxHQUFHLElBQUs7VUFBRSxPQUFPN0csS0FBSyxDQUFDcUIsU0FBUyxDQUFDd0YsR0FBRyxDQUFDO1FBQUUsQ0FBQyxDQUFDLENBQUMsS0FFM0RuRCxLQUFLLEdBQUcxRCxLQUFLLENBQUNxQixTQUFTLENBQUN3RixHQUFHLENBQUM7TUFDcEM7TUFDQSxPQUFPbkQsS0FBSztJQUNoQjtJQUNBLFNBQVNxQyxpQkFBaUJBLENBQUN0RSxHQUFHLEVBQUVpQyxLQUFLLEVBQUU7TUFDbkMsSUFBSSxDQUFDM0MsYUFBYSxDQUFDLDBCQUEwQixDQUFDLElBQUlVLEdBQUcsS0FBSyxHQUFHLEVBQ3pELE9BQU9pQyxLQUFLO01BQ2hCLElBQUksQ0FBQ2lCLGVBQWUsQ0FBQ2xELEdBQUcsRUFBRVUsS0FBSyxDQUFDRyxPQUFPLENBQUMsSUFBSSxDQUFDcUMsZUFBZSxDQUFDbEQsR0FBRyxFQUFFVSxLQUFLLENBQUNFLEtBQUssQ0FBQyxJQUFJLENBQUNoRCxLQUFLLENBQUNDLE9BQU8sQ0FBQ29FLEtBQUssQ0FBQyxFQUFFO1FBQ3JHLE1BQU1pRSxrQkFBa0IsR0FBRzVJLGVBQWUsQ0FBQzJFLEtBQUssQ0FBQyxJQUFJM0MsYUFBYSxDQUFDLGVBQWUsQ0FBQyxJQUFLNkcsTUFBTSxDQUFDQyxhQUFhLENBQUN0QixJQUFJLENBQUN1QixLQUFLLENBQUNDLFVBQVUsQ0FBRSxHQUFFckUsS0FBTSxFQUFDLENBQUMsQ0FBQyxDQUFFO1FBQ2pKLElBQUlpRSxrQkFBa0IsSUFBSyxDQUFDeEIsV0FBVyxDQUFDekMsS0FBSyxDQUFDLElBQUlpQixlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ0ksT0FBTyxDQUFFLEVBQUU7VUFDcEZtQixLQUFLLEdBQUdrRSxNQUFNLENBQUNsRSxLQUFLLENBQUM7UUFDekI7TUFDSjtNQUNBLE9BQU9BLEtBQUs7SUFDaEI7SUFDQSxTQUFTMEIsU0FBU0EsQ0FBQ3JCLElBQUksRUFBRTtNQUNyQixNQUFNaUUsWUFBWSxHQUFHeEgsTUFBTSxDQUFDb0IsTUFBTSxDQUFDLElBQUksQ0FBQztNQUN4QzBELHVCQUF1QixDQUFDMEMsWUFBWSxFQUFFN0YsS0FBSyxDQUFDVCxPQUFPLEVBQUVHLFFBQVEsQ0FBQztNQUM5RHJCLE1BQU0sQ0FBQ29DLElBQUksQ0FBQ1QsS0FBSyxDQUFDTSxPQUFPLENBQUMsQ0FBQ1UsT0FBTyxDQUFDLFVBQVU4RSxTQUFTLEVBQUU7UUFDcEQsTUFBTUMsVUFBVSxHQUFHbkUsSUFBSSxDQUFDa0UsU0FBUyxDQUFDLElBQUlELFlBQVksQ0FBQ0MsU0FBUyxDQUFDO1FBQzdELElBQUlDLFVBQVUsRUFBRTtVQUNaLElBQUk7WUFDQSxJQUFJckgsTUFBTSxHQUFHLElBQUk7WUFDakIsTUFBTXNILGtCQUFrQixHQUFHbkksS0FBSyxDQUFDb0ksT0FBTyxDQUFDcEksS0FBSyxDQUFDcUksR0FBRyxDQUFDLENBQUMsRUFBRUgsVUFBVSxDQUFDO1lBQ2pFLE1BQU1JLGFBQWEsR0FBR25HLEtBQUssQ0FBQ00sT0FBTyxDQUFDd0YsU0FBUyxDQUFDO1lBQzlDLElBQUksT0FBT0ssYUFBYSxLQUFLLFVBQVUsRUFBRTtjQUNyQyxJQUFJO2dCQUNBekgsTUFBTSxHQUFHeUgsYUFBYSxDQUFDSCxrQkFBa0IsQ0FBQztjQUM5QyxDQUFDLENBQ0QsT0FBTzNJLENBQUMsRUFBRTtnQkFDTnFCLE1BQU0sR0FBR3JCLENBQUM7Y0FDZDtjQUNBLElBQUlxQixNQUFNLFlBQVl1RixLQUFLLEVBQUU7Z0JBQ3pCeEMsS0FBSyxHQUFHL0MsTUFBTTtnQkFDZDtjQUNKO1lBQ0osQ0FBQyxNQUNJO2NBQ0RBLE1BQU0sR0FBR2IsS0FBSyxDQUFDeEMsT0FBTyxDQUFDMkssa0JBQWtCLENBQUM7WUFDOUM7WUFDQUksZUFBZSxDQUFDMUgsTUFBTSxDQUFDO1VBQzNCLENBQUMsQ0FDRCxPQUFPMkgsRUFBRSxFQUFFO1lBQ1AsSUFBSUEsRUFBRSxDQUFDQyxJQUFJLEtBQUssa0JBQWtCLEVBQzlCN0UsS0FBSyxHQUFHNEUsRUFBRSxDQUFDLEtBQ1YsSUFBSXpFLElBQUksQ0FBQ2tFLFNBQVMsQ0FBQyxFQUNwQnJFLEtBQUssR0FBR3dDLEtBQUssQ0FBQzVFLEVBQUUsQ0FBQyw4QkFBOEIsRUFBRTBHLFVBQVUsQ0FBQyxDQUFDO1VBQ3JFO1FBQ0o7TUFDSixDQUFDLENBQUM7SUFDTjtJQUNBLFNBQVNLLGVBQWVBLENBQUMxSCxNQUFNLEVBQUU2SCxJQUFJLEVBQUU7TUFDbkNsSSxNQUFNLENBQUNvQyxJQUFJLENBQUMvQixNQUFNLENBQUMsQ0FBQ3NDLE9BQU8sQ0FBQyxVQUFVMUIsR0FBRyxFQUFFO1FBQ3ZDLE1BQU1pQyxLQUFLLEdBQUc3QyxNQUFNLENBQUNZLEdBQUcsQ0FBQztRQUN6QixNQUFNa0gsT0FBTyxHQUFHRCxJQUFJLEdBQUdBLElBQUksR0FBRyxHQUFHLEdBQUdqSCxHQUFHLEdBQUdBLEdBQUc7UUFDN0MsSUFBSSxPQUFPaUMsS0FBSyxLQUFLLFFBQVEsSUFBSUEsS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDckUsS0FBSyxDQUFDQyxPQUFPLENBQUNvRSxLQUFLLENBQUMsSUFBSTNDLGFBQWEsQ0FBQyxjQUFjLENBQUMsRUFBRTtVQUN2R3dILGVBQWUsQ0FBQzdFLEtBQUssRUFBRWlGLE9BQU8sQ0FBQztRQUNuQyxDQUFDLE1BQ0k7VUFDRCxJQUFJLENBQUNsRCxNQUFNLENBQUMxQixJQUFJLEVBQUU0RSxPQUFPLENBQUMxRCxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBS04sZUFBZSxDQUFDZ0UsT0FBTyxFQUFFeEcsS0FBSyxDQUFDQyxNQUFNLENBQUMsSUFBSXJCLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBRSxFQUFFO1lBQ2xIK0QsTUFBTSxDQUFDNkQsT0FBTyxFQUFFakYsS0FBSyxDQUFDO1VBQzFCO1FBQ0o7TUFDSixDQUFDLENBQUM7SUFDTjtJQUNBLFNBQVMyQixnQkFBZ0JBLENBQUEsRUFBRztNQUN4QixJQUFJLE9BQU92RSxhQUFhLEtBQUssV0FBVyxFQUFFO1FBQ3RDQSxhQUFhLENBQUNxQyxPQUFPLENBQUMsVUFBVXlGLFlBQVksRUFBRTtVQUMxQ0wsZUFBZSxDQUFDSyxZQUFZLENBQUM7UUFDakMsQ0FBQyxDQUFDO01BQ047SUFDSjtJQUNBLFNBQVN6RCxZQUFZQSxDQUFDcEIsSUFBSSxFQUFFOEUsVUFBVSxFQUFFO01BQ3BDLElBQUksT0FBTzFILFNBQVMsS0FBSyxXQUFXLEVBQ2hDO01BQ0osTUFBTTJILE1BQU0sR0FBRyxPQUFPM0gsU0FBUyxLQUFLLFFBQVEsR0FBR0EsU0FBUyxHQUFHLEVBQUU7TUFDN0QsTUFBTTRILEdBQUcsR0FBRy9JLEtBQUssQ0FBQytJLEdBQUcsQ0FBQyxDQUFDO01BQ3ZCdkksTUFBTSxDQUFDb0MsSUFBSSxDQUFDbUcsR0FBRyxDQUFDLENBQUM1RixPQUFPLENBQUMsVUFBVTZGLE1BQU0sRUFBRTtRQUN2QyxJQUFJRixNQUFNLEtBQUssRUFBRSxJQUFJRSxNQUFNLENBQUNDLFdBQVcsQ0FBQ0gsTUFBTSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRTtVQUN0RCxNQUFNbEcsSUFBSSxHQUFHb0csTUFBTSxDQUFDL0QsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDMUYsR0FBRyxDQUFDLFVBQVVrQyxHQUFHLEVBQUVwRCxDQUFDLEVBQUU7WUFDbEQsSUFBSUEsQ0FBQyxLQUFLLENBQUMsRUFBRTtjQUNUb0QsR0FBRyxHQUFHQSxHQUFHLENBQUMrRixTQUFTLENBQUNzQixNQUFNLENBQUN4SyxNQUFNLENBQUM7WUFDdEM7WUFDQSxPQUFPWCxTQUFTLENBQUM4RCxHQUFHLENBQUM7VUFDekIsQ0FBQyxDQUFDO1VBQ0YsSUFBSSxDQUFFb0gsVUFBVSxJQUFJMUcsS0FBSyxDQUFDTSxPQUFPLENBQUNHLElBQUksQ0FBQ2lELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFLLENBQUNnRCxVQUFVLEtBQUssQ0FBQ3BELE1BQU0sQ0FBQzFCLElBQUksRUFBRW5CLElBQUksQ0FBQyxFQUFFO1lBQ3ZGa0MsTUFBTSxDQUFDbEMsSUFBSSxDQUFDaUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFa0QsR0FBRyxDQUFDQyxNQUFNLENBQUMsQ0FBQztVQUN2QztRQUNKO01BQ0osQ0FBQyxDQUFDO0lBQ047SUFDQSxTQUFTekQsY0FBY0EsQ0FBQ3hCLElBQUksRUFBRTtNQUMxQixJQUFJL0MsTUFBTTtNQUNWLE1BQU1rSSxPQUFPLEdBQUcsSUFBSUMsR0FBRyxDQUFDLENBQUM7TUFDekIzSSxNQUFNLENBQUNvQyxJQUFJLENBQUNtQixJQUFJLENBQUMsQ0FBQ1osT0FBTyxDQUFDLFVBQVUxQixHQUFHLEVBQUU7UUFDckMsSUFBSSxDQUFDeUgsT0FBTyxDQUFDRSxHQUFHLENBQUMzSCxHQUFHLENBQUMsRUFBRTtVQUNuQlQsTUFBTSxHQUFHMkQsZUFBZSxDQUFDbEQsR0FBRyxFQUFFVSxLQUFLLENBQUNRLFNBQVMsQ0FBQztVQUM5QyxJQUFJLE9BQU8zQixNQUFNLEtBQUssVUFBVSxFQUFFO1lBQzlCLElBQUk7Y0FDQSxNQUFNMEMsS0FBSyxHQUFHcUMsaUJBQWlCLENBQUN0RSxHQUFHLEVBQUVULE1BQU0sQ0FBQytDLElBQUksQ0FBQ3RDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Y0FDdEQsRUFBRSxDQUFDdUIsTUFBTSxDQUFDYixLQUFLLENBQUNULE9BQU8sQ0FBQ0QsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFFQSxHQUFHLENBQUMsQ0FBRTBCLE9BQU8sQ0FBQ2tHLEdBQUcsSUFBSTtnQkFDdERILE9BQU8sQ0FBQ0ksR0FBRyxDQUFDRCxHQUFHLENBQUM7Z0JBQ2hCdEYsSUFBSSxDQUFDc0YsR0FBRyxDQUFDLEdBQUczRixLQUFLO2NBQ3JCLENBQUMsQ0FBQztZQUNOLENBQUMsQ0FDRCxPQUFPNkYsR0FBRyxFQUFFO2NBQ1IzRixLQUFLLEdBQUcyRixHQUFHO1lBQ2Y7VUFDSjtRQUNKO01BQ0osQ0FBQyxDQUFDO0lBQ047SUFDQSxTQUFTL0Qsa0JBQWtCQSxDQUFDekIsSUFBSSxFQUFFO01BQzlCNUIsS0FBSyxDQUFDUyxJQUFJLENBQUNPLE9BQU8sQ0FBRTFCLEdBQUcsSUFBSztRQUN4QixJQUFJLENBQUNBLEdBQUcsQ0FBQ3pELE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFDakI7UUFDSixJQUFJLE9BQU8rRixJQUFJLENBQUN0QyxHQUFHLENBQUMsS0FBSyxXQUFXLEVBQ2hDc0MsSUFBSSxDQUFDdEMsR0FBRyxDQUFDLEdBQUd4QyxTQUFTO01BQzdCLENBQUMsQ0FBQztNQUNGLE9BQU84RSxJQUFJO0lBQ2Y7SUFDQSxTQUFTdUIsdUJBQXVCQSxDQUFDa0UsR0FBRyxFQUFFOUgsT0FBTyxFQUFFRyxRQUFRLEVBQUU0SCxNQUFNLEdBQUcsS0FBSyxFQUFFO01BQ3JFakosTUFBTSxDQUFDb0MsSUFBSSxDQUFDZixRQUFRLENBQUMsQ0FBQ3NCLE9BQU8sQ0FBQyxVQUFVMUIsR0FBRyxFQUFFO1FBQ3pDLElBQUksQ0FBQ2dFLE1BQU0sQ0FBQytELEdBQUcsRUFBRS9ILEdBQUcsQ0FBQ3dELEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1VBQzlCK0IsTUFBTSxDQUFDd0MsR0FBRyxFQUFFL0gsR0FBRyxDQUFDd0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFcEQsUUFBUSxDQUFDSixHQUFHLENBQUMsQ0FBQztVQUMxQyxJQUFJZ0ksTUFBTSxFQUNOeEgsU0FBUyxDQUFDUixHQUFHLENBQUMsR0FBRyxJQUFJO1VBQ3pCLENBQUNDLE9BQU8sQ0FBQ0QsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFFMEIsT0FBTyxDQUFDLFVBQVVuRSxDQUFDLEVBQUU7WUFDdEMsSUFBSXlHLE1BQU0sQ0FBQytELEdBQUcsRUFBRXhLLENBQUMsQ0FBQ2lHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUN6QjtZQUNKK0IsTUFBTSxDQUFDd0MsR0FBRyxFQUFFeEssQ0FBQyxDQUFDaUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFcEQsUUFBUSxDQUFDSixHQUFHLENBQUMsQ0FBQztVQUM1QyxDQUFDLENBQUM7UUFDTjtNQUNKLENBQUMsQ0FBQztJQUNOO0lBQ0EsU0FBU2dFLE1BQU1BLENBQUMrRCxHQUFHLEVBQUU1RyxJQUFJLEVBQUU7TUFDdkIsSUFBSThHLENBQUMsR0FBR0YsR0FBRztNQUNYLElBQUksQ0FBQ3pJLGFBQWEsQ0FBQyxjQUFjLENBQUMsRUFDOUI2QixJQUFJLEdBQUcsQ0FBQ0EsSUFBSSxDQUFDaUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO01BQzNCakQsSUFBSSxDQUFDb0MsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDN0IsT0FBTyxDQUFDLFVBQVUxQixHQUFHLEVBQUU7UUFDckNpSSxDQUFDLEdBQUlBLENBQUMsQ0FBQ2pJLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBRTtNQUN0QixDQUFDLENBQUM7TUFDRixNQUFNQSxHQUFHLEdBQUdtQixJQUFJLENBQUNBLElBQUksQ0FBQ3RFLE1BQU0sR0FBRyxDQUFDLENBQUM7TUFDakMsSUFBSSxPQUFPb0wsQ0FBQyxLQUFLLFFBQVEsRUFDckIsT0FBTyxLQUFLLENBQUMsS0FFYixPQUFPakksR0FBRyxJQUFJaUksQ0FBQztJQUN2QjtJQUNBLFNBQVMxQyxNQUFNQSxDQUFDd0MsR0FBRyxFQUFFNUcsSUFBSSxFQUFFYyxLQUFLLEVBQUU7TUFDOUIsSUFBSWdHLENBQUMsR0FBR0YsR0FBRztNQUNYLElBQUksQ0FBQ3pJLGFBQWEsQ0FBQyxjQUFjLENBQUMsRUFDOUI2QixJQUFJLEdBQUcsQ0FBQ0EsSUFBSSxDQUFDaUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO01BQzNCakQsSUFBSSxDQUFDb0MsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDN0IsT0FBTyxDQUFDLFVBQVUxQixHQUFHLEVBQUU7UUFDckNBLEdBQUcsR0FBR2tJLFdBQVcsQ0FBQ2xJLEdBQUcsQ0FBQztRQUN0QixJQUFJLE9BQU9pSSxDQUFDLEtBQUssUUFBUSxJQUFJQSxDQUFDLENBQUNqSSxHQUFHLENBQUMsS0FBS3hDLFNBQVMsRUFBRTtVQUMvQ3lLLENBQUMsQ0FBQ2pJLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNmO1FBQ0EsSUFBSSxPQUFPaUksQ0FBQyxDQUFDakksR0FBRyxDQUFDLEtBQUssUUFBUSxJQUFJcEMsS0FBSyxDQUFDQyxPQUFPLENBQUNvSyxDQUFDLENBQUNqSSxHQUFHLENBQUMsQ0FBQyxFQUFFO1VBQ3JELElBQUlwQyxLQUFLLENBQUNDLE9BQU8sQ0FBQ29LLENBQUMsQ0FBQ2pJLEdBQUcsQ0FBQyxDQUFDLEVBQUU7WUFDdkJpSSxDQUFDLENBQUNqSSxHQUFHLENBQUMsQ0FBQytCLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztVQUNuQixDQUFDLE1BQ0k7WUFDRGtHLENBQUMsQ0FBQ2pJLEdBQUcsQ0FBQyxHQUFHLENBQUNpSSxDQUFDLENBQUNqSSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztVQUN6QjtVQUNBaUksQ0FBQyxHQUFHQSxDQUFDLENBQUNqSSxHQUFHLENBQUMsQ0FBQ2lJLENBQUMsQ0FBQ2pJLEdBQUcsQ0FBQyxDQUFDbkQsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUNqQyxDQUFDLE1BQ0k7VUFDRG9MLENBQUMsR0FBR0EsQ0FBQyxDQUFDakksR0FBRyxDQUFDO1FBQ2Q7TUFDSixDQUFDLENBQUM7TUFDRixNQUFNQSxHQUFHLEdBQUdrSSxXQUFXLENBQUMvRyxJQUFJLENBQUNBLElBQUksQ0FBQ3RFLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztNQUM5QyxNQUFNc0wsV0FBVyxHQUFHakYsZUFBZSxDQUFDL0IsSUFBSSxDQUFDaUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFMUQsS0FBSyxDQUFDQyxNQUFNLENBQUM7TUFDakUsTUFBTXlILFlBQVksR0FBR3hLLEtBQUssQ0FBQ0MsT0FBTyxDQUFDb0UsS0FBSyxDQUFDO01BQ3pDLElBQUlvRyxTQUFTLEdBQUcvSSxhQUFhLENBQUMsMkJBQTJCLENBQUM7TUFDMUQsSUFBSSxDQUFDK0ksU0FBUyxJQUFJbkYsZUFBZSxDQUFDbEQsR0FBRyxFQUFFVSxLQUFLLENBQUNPLEtBQUssQ0FBQyxFQUFFO1FBQ2pEb0gsU0FBUyxHQUFHLElBQUk7UUFDaEIsSUFBSyxDQUFDM0QsV0FBVyxDQUFDdUQsQ0FBQyxDQUFDakksR0FBRyxDQUFDLENBQUMsSUFBSVUsS0FBSyxDQUFDTyxLQUFLLENBQUNqQixHQUFHLENBQUMsS0FBSyxDQUFDLElBQU1wQyxLQUFLLENBQUNDLE9BQU8sQ0FBQ29LLENBQUMsQ0FBQ2pJLEdBQUcsQ0FBQyxDQUFDLElBQUlpSSxDQUFDLENBQUNqSSxHQUFHLENBQUMsQ0FBQ25ELE1BQU0sS0FBSzZELEtBQUssQ0FBQ08sS0FBSyxDQUFDakIsR0FBRyxDQUFFLEVBQUU7VUFDbkhpSSxDQUFDLENBQUNqSSxHQUFHLENBQUMsR0FBR3hDLFNBQVM7UUFDdEI7TUFDSjtNQUNBLElBQUl5RSxLQUFLLEtBQUtnRSxTQUFTLENBQUMsQ0FBQyxFQUFFO1FBQ3ZCZ0MsQ0FBQyxDQUFDakksR0FBRyxDQUFDLEdBQUdpRyxTQUFTLENBQUNnQyxDQUFDLENBQUNqSSxHQUFHLENBQUMsQ0FBQztNQUM5QixDQUFDLE1BQ0ksSUFBSXBDLEtBQUssQ0FBQ0MsT0FBTyxDQUFDb0ssQ0FBQyxDQUFDakksR0FBRyxDQUFDLENBQUMsRUFBRTtRQUM1QixJQUFJcUksU0FBUyxJQUFJRixXQUFXLElBQUlDLFlBQVksRUFBRTtVQUMxQ0gsQ0FBQyxDQUFDakksR0FBRyxDQUFDLEdBQUdWLGFBQWEsQ0FBQywwQkFBMEIsQ0FBQyxHQUFHMkksQ0FBQyxDQUFDakksR0FBRyxDQUFDLENBQUN1QixNQUFNLENBQUNVLEtBQUssQ0FBQyxHQUFHLENBQUNyRSxLQUFLLENBQUNDLE9BQU8sQ0FBQ29LLENBQUMsQ0FBQ2pJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUdpSSxDQUFDLENBQUNqSSxHQUFHLENBQUMsR0FBRyxDQUFDaUksQ0FBQyxDQUFDakksR0FBRyxDQUFDLENBQUMsRUFBRXVCLE1BQU0sQ0FBQyxDQUFDVSxLQUFLLENBQUMsQ0FBQztRQUM5SSxDQUFDLE1BQ0ksSUFBSSxDQUFDb0csU0FBUyxJQUFJNUcsT0FBTyxDQUFDMEcsV0FBVyxDQUFDLEtBQUsxRyxPQUFPLENBQUMyRyxZQUFZLENBQUMsRUFBRTtVQUNuRUgsQ0FBQyxDQUFDakksR0FBRyxDQUFDLEdBQUdpQyxLQUFLO1FBQ2xCLENBQUMsTUFDSTtVQUNEZ0csQ0FBQyxDQUFDakksR0FBRyxDQUFDLEdBQUdpSSxDQUFDLENBQUNqSSxHQUFHLENBQUMsQ0FBQ3VCLE1BQU0sQ0FBQyxDQUFDVSxLQUFLLENBQUMsQ0FBQztRQUNuQztNQUNKLENBQUMsTUFDSSxJQUFJZ0csQ0FBQyxDQUFDakksR0FBRyxDQUFDLEtBQUt4QyxTQUFTLElBQUkySyxXQUFXLEVBQUU7UUFDMUNGLENBQUMsQ0FBQ2pJLEdBQUcsQ0FBQyxHQUFHb0ksWUFBWSxHQUFHbkcsS0FBSyxHQUFHLENBQUNBLEtBQUssQ0FBQztNQUMzQyxDQUFDLE1BQ0ksSUFBSW9HLFNBQVMsSUFBSSxFQUFFSixDQUFDLENBQUNqSSxHQUFHLENBQUMsS0FBS3hDLFNBQVMsSUFDeEMwRixlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ0ssTUFBTSxDQUFDLElBQ2xDbUMsZUFBZSxDQUFDbEQsR0FBRyxFQUFFVSxLQUFLLENBQUNFLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDcENxSCxDQUFDLENBQUNqSSxHQUFHLENBQUMsR0FBRyxDQUFDaUksQ0FBQyxDQUFDakksR0FBRyxDQUFDLEVBQUVpQyxLQUFLLENBQUM7TUFDNUIsQ0FBQyxNQUNJO1FBQ0RnRyxDQUFDLENBQUNqSSxHQUFHLENBQUMsR0FBR2lDLEtBQUs7TUFDbEI7SUFDSjtJQUNBLFNBQVNDLGFBQWFBLENBQUMsR0FBRzlELElBQUksRUFBRTtNQUM1QkEsSUFBSSxDQUFDc0QsT0FBTyxDQUFDLFVBQVVxRyxHQUFHLEVBQUU7UUFDeEJoSixNQUFNLENBQUNvQyxJQUFJLENBQUM0RyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQ3JHLE9BQU8sQ0FBQyxVQUFVMUIsR0FBRyxFQUFFO1VBQzFDLElBQUlVLEtBQUssQ0FBQ1QsT0FBTyxDQUFDRCxHQUFHLENBQUMsRUFDbEI7VUFDSlUsS0FBSyxDQUFDVCxPQUFPLENBQUNELEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQ3VCLE1BQU0sQ0FBQ3RCLE9BQU8sQ0FBQ0QsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDO1VBQ2xEVSxLQUFLLENBQUNULE9BQU8sQ0FBQ0QsR0FBRyxDQUFDLENBQUN1QixNQUFNLENBQUN2QixHQUFHLENBQUMsQ0FBQzBCLE9BQU8sQ0FBQyxVQUFVbkUsQ0FBQyxFQUFFO1lBQ2hELElBQUksR0FBRyxDQUFDRSxJQUFJLENBQUNGLENBQUMsQ0FBQyxJQUFJK0IsYUFBYSxDQUFDLHNCQUFzQixDQUFDLEVBQUU7Y0FDdEQsTUFBTXBCLENBQUMsR0FBR2hDLFNBQVMsQ0FBQ3FCLENBQUMsQ0FBQztjQUN0QixJQUFJVyxDQUFDLEtBQUs4QixHQUFHLElBQUlVLEtBQUssQ0FBQ1QsT0FBTyxDQUFDRCxHQUFHLENBQUMsQ0FBQ3pELE9BQU8sQ0FBQzJCLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO2dCQUNuRHdDLEtBQUssQ0FBQ1QsT0FBTyxDQUFDRCxHQUFHLENBQUMsQ0FBQytCLElBQUksQ0FBQzdELENBQUMsQ0FBQztnQkFDMUJxQyxVQUFVLENBQUNyQyxDQUFDLENBQUMsR0FBRyxJQUFJO2NBQ3hCO1lBQ0o7VUFDSixDQUFDLENBQUM7VUFDRndDLEtBQUssQ0FBQ1QsT0FBTyxDQUFDRCxHQUFHLENBQUMsQ0FBQ3VCLE1BQU0sQ0FBQ3ZCLEdBQUcsQ0FBQyxDQUFDMEIsT0FBTyxDQUFDLFVBQVVuRSxDQUFDLEVBQUU7WUFDaEQsSUFBSUEsQ0FBQyxDQUFDVixNQUFNLEdBQUcsQ0FBQyxJQUFJLE9BQU8sQ0FBQ1ksSUFBSSxDQUFDRixDQUFDLENBQUMsSUFBSStCLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxFQUFFO2NBQzFFLE1BQU1wQixDQUFDLEdBQUdsQixVQUFVLENBQUNPLENBQUMsRUFBRSxHQUFHLENBQUM7Y0FDNUIsSUFBSVcsQ0FBQyxLQUFLOEIsR0FBRyxJQUFJVSxLQUFLLENBQUNULE9BQU8sQ0FBQ0QsR0FBRyxDQUFDLENBQUN6RCxPQUFPLENBQUMyQixDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtnQkFDbkR3QyxLQUFLLENBQUNULE9BQU8sQ0FBQ0QsR0FBRyxDQUFDLENBQUMrQixJQUFJLENBQUM3RCxDQUFDLENBQUM7Z0JBQzFCcUMsVUFBVSxDQUFDckMsQ0FBQyxDQUFDLEdBQUcsSUFBSTtjQUN4QjtZQUNKO1VBQ0osQ0FBQyxDQUFDO1VBQ0Z3QyxLQUFLLENBQUNULE9BQU8sQ0FBQ0QsR0FBRyxDQUFDLENBQUMwQixPQUFPLENBQUMsVUFBVW5FLENBQUMsRUFBRTtZQUNwQ21ELEtBQUssQ0FBQ1QsT0FBTyxDQUFDMUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQ3lDLEdBQUcsQ0FBQyxDQUFDdUIsTUFBTSxDQUFDYixLQUFLLENBQUNULE9BQU8sQ0FBQ0QsR0FBRyxDQUFDLENBQUN3QixNQUFNLENBQUMsVUFBVThHLENBQUMsRUFBRTtjQUNuRSxPQUFPL0ssQ0FBQyxLQUFLK0ssQ0FBQztZQUNsQixDQUFDLENBQUMsQ0FBQztVQUNQLENBQUMsQ0FBQztRQUNOLENBQUMsQ0FBQztNQUNOLENBQUMsQ0FBQztJQUNOO0lBQ0EsU0FBU3BGLGVBQWVBLENBQUNsRCxHQUFHLEVBQUV1SSxJQUFJLEVBQUU7TUFDaEMsTUFBTUMsT0FBTyxHQUFHLEVBQUUsQ0FBQ2pILE1BQU0sQ0FBQ2IsS0FBSyxDQUFDVCxPQUFPLENBQUNELEdBQUcsQ0FBQyxJQUFJLEVBQUUsRUFBRUEsR0FBRyxDQUFDO01BQ3hELE1BQU1tQixJQUFJLEdBQUdwQyxNQUFNLENBQUNvQyxJQUFJLENBQUNvSCxJQUFJLENBQUM7TUFDOUIsTUFBTUUsUUFBUSxHQUFHRCxPQUFPLENBQUNFLElBQUksQ0FBQzFJLEdBQUcsSUFBSW1CLElBQUksQ0FBQzhDLFFBQVEsQ0FBQ2pFLEdBQUcsQ0FBQyxDQUFDO01BQ3hELE9BQU95SSxRQUFRLEdBQUdGLElBQUksQ0FBQ0UsUUFBUSxDQUFDLEdBQUcsS0FBSztJQUM1QztJQUNBLFNBQVNFLFVBQVVBLENBQUMzSSxHQUFHLEVBQUU7TUFDckIsTUFBTTRJLFNBQVMsR0FBRzdKLE1BQU0sQ0FBQ29DLElBQUksQ0FBQ1QsS0FBSyxDQUFDO01BQ3BDLE1BQU04SCxPQUFPLEdBQUcsRUFBRSxDQUFDakgsTUFBTSxDQUFDcUgsU0FBUyxDQUFDOUssR0FBRyxDQUFDb0csQ0FBQyxJQUFJeEQsS0FBSyxDQUFDd0QsQ0FBQyxDQUFDLENBQUMsQ0FBQztNQUN2RCxPQUFPc0UsT0FBTyxDQUFDSyxJQUFJLENBQUMsVUFBVU4sSUFBSSxFQUFFO1FBQ2hDLE9BQU8zSyxLQUFLLENBQUNDLE9BQU8sQ0FBQzBLLElBQUksQ0FBQyxHQUFHQSxJQUFJLENBQUN0RSxRQUFRLENBQUNqRSxHQUFHLENBQUMsR0FBR3VJLElBQUksQ0FBQ3ZJLEdBQUcsQ0FBQztNQUMvRCxDQUFDLENBQUM7SUFDTjtJQUNBLFNBQVM4SSxnQkFBZ0JBLENBQUNyRyxHQUFHLEVBQUUsR0FBR3NHLFFBQVEsRUFBRTtNQUN4QyxNQUFNUCxPQUFPLEdBQUcsRUFBRSxDQUFDakgsTUFBTSxDQUFDLEdBQUd3SCxRQUFRLENBQUM7TUFDdEMsT0FBT1AsT0FBTyxDQUFDSyxJQUFJLENBQUMsVUFBVUcsT0FBTyxFQUFFO1FBQ25DLE1BQU1yTSxLQUFLLEdBQUc4RixHQUFHLENBQUM5RixLQUFLLENBQUNxTSxPQUFPLENBQUM7UUFDaEMsT0FBT3JNLEtBQUssSUFBSWdNLFVBQVUsQ0FBQ2hNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztNQUN4QyxDQUFDLENBQUM7SUFDTjtJQUNBLFNBQVNzTSxnQkFBZ0JBLENBQUN4RyxHQUFHLEVBQUU7TUFDM0IsSUFBSUEsR0FBRyxDQUFDOUYsS0FBSyxDQUFDeUUsUUFBUSxDQUFDLElBQUksQ0FBQ3FCLEdBQUcsQ0FBQzlGLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUM5QyxPQUFPLEtBQUs7TUFDaEI7TUFDQSxJQUFJdU0sV0FBVyxHQUFHLElBQUk7TUFDdEIsSUFBSW5HLElBQUk7TUFDUixNQUFNRixPQUFPLEdBQUdKLEdBQUcsQ0FBQ2MsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDQyxLQUFLLENBQUMsRUFBRSxDQUFDO01BQ3RDLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHWixPQUFPLENBQUNoRyxNQUFNLEVBQUU0RyxDQUFDLEVBQUUsRUFBRTtRQUNyQ1YsSUFBSSxHQUFHTixHQUFHLENBQUNjLEtBQUssQ0FBQ0UsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUNrRixVQUFVLENBQUM5RixPQUFPLENBQUNZLENBQUMsQ0FBQyxDQUFDLEVBQUU7VUFDekJ5RixXQUFXLEdBQUcsS0FBSztVQUNuQjtRQUNKO1FBQ0EsSUFBS3JHLE9BQU8sQ0FBQ1ksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJWixPQUFPLENBQUNZLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLElBQ3pDVixJQUFJLEtBQUssR0FBRyxJQUNYLFVBQVUsQ0FBQ3RGLElBQUksQ0FBQ29GLE9BQU8sQ0FBQ1ksQ0FBQyxDQUFDLENBQUMsSUFBSSwwQkFBMEIsQ0FBQ2hHLElBQUksQ0FBQ3NGLElBQUksQ0FBRSxJQUNyRUYsT0FBTyxDQUFDWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUlaLE9BQU8sQ0FBQ1ksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDOUcsS0FBSyxDQUFDLElBQUksQ0FBRSxFQUFFO1VBQ2hEO1FBQ0o7TUFDSjtNQUNBLE9BQU91TSxXQUFXO0lBQ3RCO0lBQ0EsU0FBU2xHLG9CQUFvQkEsQ0FBQ1AsR0FBRyxFQUFFO01BQy9CLE9BQU9uRCxhQUFhLENBQUMseUJBQXlCLENBQUMsSUFBSTZKLGVBQWUsQ0FBQzFHLEdBQUcsQ0FBQztJQUMzRTtJQUNBLFNBQVMwRyxlQUFlQSxDQUFDMUcsR0FBRyxFQUFFO01BQzFCQSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ0UsT0FBTyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUM7TUFDakMsSUFBSUYsR0FBRyxDQUFDOUYsS0FBSyxDQUFDeUUsUUFBUSxDQUFDLEVBQUU7UUFDckIsT0FBTyxLQUFLO01BQ2hCO01BQ0EsSUFBSTZILGdCQUFnQixDQUFDeEcsR0FBRyxDQUFDLEVBQUU7UUFDdkIsT0FBTyxLQUFLO01BQ2hCO01BQ0EsTUFBTTJHLGNBQWMsR0FBRyxzQkFBc0I7TUFDN0MsTUFBTUMsVUFBVSxHQUFHLGNBQWM7TUFDakMsTUFBTUMsa0JBQWtCLEdBQUcsZUFBZTtNQUMxQyxNQUFNQyxrQkFBa0IsR0FBRyxpQkFBaUI7TUFDNUMsTUFBTUMsNkJBQTZCLEdBQUcsbUJBQW1CO01BQ3pELE9BQU8sQ0FBQ1YsZ0JBQWdCLENBQUNyRyxHQUFHLEVBQUUyRyxjQUFjLEVBQUUvSCxjQUFjLEVBQUVnSSxVQUFVLEVBQUVDLGtCQUFrQixFQUFFQyxrQkFBa0IsRUFBRUMsNkJBQTZCLENBQUM7SUFDcEo7SUFDQSxTQUFTbEcsWUFBWUEsQ0FBQ3RELEdBQUcsRUFBRTtNQUN2QixJQUFJLENBQUNrRCxlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ0UsS0FBSyxDQUFDLElBQ2xDLENBQUNzQyxlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ0ssTUFBTSxDQUFDLElBQ2xDLEdBQUVmLEdBQUksRUFBQyxJQUFJSSxRQUFRLEVBQUU7UUFDdEIsT0FBT0EsUUFBUSxDQUFDSixHQUFHLENBQUM7TUFDeEIsQ0FBQyxNQUNJO1FBQ0QsT0FBT3lKLGNBQWMsQ0FBQ0MsU0FBUyxDQUFDMUosR0FBRyxDQUFDLENBQUM7TUFDekM7SUFDSjtJQUNBLFNBQVN5SixjQUFjQSxDQUFDRSxJQUFJLEVBQUU7TUFDMUIsTUFBTUMsR0FBRyxHQUFHO1FBQ1IsQ0FBQ3RMLHVCQUF1QixDQUFDdUwsT0FBTyxHQUFHLElBQUk7UUFDdkMsQ0FBQ3ZMLHVCQUF1QixDQUFDd0wsTUFBTSxHQUFHLEVBQUU7UUFDcEMsQ0FBQ3hMLHVCQUF1QixDQUFDeUwsTUFBTSxHQUFHdk0sU0FBUztRQUMzQyxDQUFDYyx1QkFBdUIsQ0FBQzBMLEtBQUssR0FBRztNQUNyQyxDQUFDO01BQ0QsT0FBT0osR0FBRyxDQUFDRCxJQUFJLENBQUM7SUFDcEI7SUFDQSxTQUFTRCxTQUFTQSxDQUFDMUosR0FBRyxFQUFFO01BQ3BCLElBQUkySixJQUFJLEdBQUdyTCx1QkFBdUIsQ0FBQ3VMLE9BQU87TUFDMUMsSUFBSTNHLGVBQWUsQ0FBQ2xELEdBQUcsRUFBRVUsS0FBSyxDQUFDRyxPQUFPLENBQUMsRUFDbkM4SSxJQUFJLEdBQUdyTCx1QkFBdUIsQ0FBQ3dMLE1BQU0sQ0FBQyxLQUNyQyxJQUFJNUcsZUFBZSxDQUFDbEQsR0FBRyxFQUFFVSxLQUFLLENBQUNJLE9BQU8sQ0FBQyxFQUN4QzZJLElBQUksR0FBR3JMLHVCQUF1QixDQUFDeUwsTUFBTSxDQUFDLEtBQ3JDLElBQUk3RyxlQUFlLENBQUNsRCxHQUFHLEVBQUVVLEtBQUssQ0FBQ0UsS0FBSyxDQUFDLEVBQ3RDK0ksSUFBSSxHQUFHckwsdUJBQXVCLENBQUN1TCxPQUFPLENBQUMsS0FDdEMsSUFBSTNHLGVBQWUsQ0FBQ2xELEdBQUcsRUFBRVUsS0FBSyxDQUFDQyxNQUFNLENBQUMsRUFDdkNnSixJQUFJLEdBQUdyTCx1QkFBdUIsQ0FBQzBMLEtBQUs7TUFDeEMsT0FBT0wsSUFBSTtJQUNmO0lBQ0EsU0FBU2pGLFdBQVdBLENBQUN1RixHQUFHLEVBQUU7TUFDdEIsT0FBT0EsR0FBRyxLQUFLek0sU0FBUztJQUM1QjtJQUNBLFNBQVM0RSxrQkFBa0JBLENBQUEsRUFBRztNQUMxQnJELE1BQU0sQ0FBQ29DLElBQUksQ0FBQ1QsS0FBSyxDQUFDSyxNQUFNLENBQUMsQ0FBQzJILElBQUksQ0FBQzFJLEdBQUcsSUFBSTtRQUNsQyxJQUFJa0QsZUFBZSxDQUFDbEQsR0FBRyxFQUFFVSxLQUFLLENBQUNDLE1BQU0sQ0FBQyxFQUFFO1VBQ3BDd0IsS0FBSyxHQUFHd0MsS0FBSyxDQUFDNUUsRUFBRSxDQUFDLDREQUE0RCxFQUFFQyxHQUFHLENBQUMsQ0FBQztVQUNwRixPQUFPLElBQUk7UUFDZixDQUFDLE1BQ0ksSUFBSWtELGVBQWUsQ0FBQ2xELEdBQUcsRUFBRVUsS0FBSyxDQUFDTyxLQUFLLENBQUMsRUFBRTtVQUN4Q2tCLEtBQUssR0FBR3dDLEtBQUssQ0FBQzVFLEVBQUUsQ0FBQywyREFBMkQsRUFBRUMsR0FBRyxDQUFDLENBQUM7VUFDbkYsT0FBTyxJQUFJO1FBQ2Y7UUFDQSxPQUFPLEtBQUs7TUFDaEIsQ0FBQyxDQUFDO0lBQ047SUFDQSxPQUFPO01BQ0hDLE9BQU8sRUFBRWxCLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFMEIsS0FBSyxDQUFDVCxPQUFPLENBQUM7TUFDekNxQyxJQUFJLEVBQUV2RCxNQUFNLENBQUNDLE1BQU0sQ0FBQ3dELFVBQVUsRUFBRUYsSUFBSSxDQUFDO01BQ3JDaEQsYUFBYSxFQUFFQSxhQUFhO01BQzVCa0IsU0FBUyxFQUFFekIsTUFBTSxDQUFDQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUV3QixTQUFTLENBQUM7TUFDdkMyQixLQUFLLEVBQUVBLEtBQUs7TUFDWjVCLFVBQVUsRUFBRXhCLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFdUIsVUFBVTtJQUM1QyxDQUFDO0VBQ0w7QUFDSjtBQUNBLFNBQVNMLGNBQWNBLENBQUNELE9BQU8sRUFBRTtFQUM3QixNQUFNaUssV0FBVyxHQUFHLEVBQUU7RUFDdEIsTUFBTUMsUUFBUSxHQUFHcEwsTUFBTSxDQUFDb0IsTUFBTSxDQUFDLElBQUksQ0FBQztFQUNwQyxJQUFJaUssTUFBTSxHQUFHLElBQUk7RUFDakJyTCxNQUFNLENBQUNvQyxJQUFJLENBQUNsQixPQUFPLENBQUMsQ0FBQ3lCLE9BQU8sQ0FBQyxVQUFVMUIsR0FBRyxFQUFFO0lBQ3hDa0ssV0FBVyxDQUFDbkksSUFBSSxDQUFDLEVBQUUsQ0FBQ1IsTUFBTSxDQUFDdEIsT0FBTyxDQUFDRCxHQUFHLENBQUMsRUFBRUEsR0FBRyxDQUFDLENBQUM7RUFDbEQsQ0FBQyxDQUFDO0VBQ0YsT0FBT29LLE1BQU0sRUFBRTtJQUNYQSxNQUFNLEdBQUcsS0FBSztJQUNkLEtBQUssSUFBSXhOLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR3NOLFdBQVcsQ0FBQ3JOLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUU7TUFDekMsS0FBSyxJQUFJeUIsRUFBRSxHQUFHekIsQ0FBQyxHQUFHLENBQUMsRUFBRXlCLEVBQUUsR0FBRzZMLFdBQVcsQ0FBQ3JOLE1BQU0sRUFBRXdCLEVBQUUsRUFBRSxFQUFFO1FBQ2hELE1BQU1nTSxTQUFTLEdBQUdILFdBQVcsQ0FBQ3ROLENBQUMsQ0FBQyxDQUFDNEUsTUFBTSxDQUFDLFVBQVV3RSxDQUFDLEVBQUU7VUFDakQsT0FBT2tFLFdBQVcsQ0FBQzdMLEVBQUUsQ0FBQyxDQUFDOUIsT0FBTyxDQUFDeUosQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzVDLENBQUMsQ0FBQztRQUNGLElBQUlxRSxTQUFTLENBQUN4TixNQUFNLEVBQUU7VUFDbEJxTixXQUFXLENBQUN0TixDQUFDLENBQUMsR0FBR3NOLFdBQVcsQ0FBQ3ROLENBQUMsQ0FBQyxDQUFDMkUsTUFBTSxDQUFDMkksV0FBVyxDQUFDN0wsRUFBRSxDQUFDLENBQUM7VUFDdkQ2TCxXQUFXLENBQUNJLE1BQU0sQ0FBQ2pNLEVBQUUsRUFBRSxDQUFDLENBQUM7VUFDekIrTCxNQUFNLEdBQUcsSUFBSTtVQUNiO1FBQ0o7TUFDSjtJQUNKO0VBQ0o7RUFDQUYsV0FBVyxDQUFDeEksT0FBTyxDQUFDLFVBQVU2SSxVQUFVLEVBQUU7SUFDdENBLFVBQVUsR0FBR0EsVUFBVSxDQUFDL0ksTUFBTSxDQUFDLFVBQVV3RSxDQUFDLEVBQUVwSixDQUFDLEVBQUU0TixJQUFJLEVBQUU7TUFDakQsT0FBT0EsSUFBSSxDQUFDak8sT0FBTyxDQUFDeUosQ0FBQyxDQUFDLEtBQUtwSixDQUFDO0lBQ2hDLENBQUMsQ0FBQztJQUNGLE1BQU02TixTQUFTLEdBQUdGLFVBQVUsQ0FBQ3pJLEdBQUcsQ0FBQyxDQUFDO0lBQ2xDLElBQUkySSxTQUFTLEtBQUtqTixTQUFTLElBQUksT0FBT2lOLFNBQVMsS0FBSyxRQUFRLEVBQUU7TUFDMUROLFFBQVEsQ0FBQ00sU0FBUyxDQUFDLEdBQUdGLFVBQVU7SUFDcEM7RUFDSixDQUFDLENBQUM7RUFDRixPQUFPSixRQUFRO0FBQ25CO0FBQ0EsU0FBU2xFLFNBQVNBLENBQUN5RSxJQUFJLEVBQUU7RUFDckIsT0FBT0EsSUFBSSxLQUFLbE4sU0FBUyxHQUFHa04sSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDO0FBQzVDO0FBQ0EsU0FBU3hDLFdBQVdBLENBQUNsSSxHQUFHLEVBQUU7RUFDdEIsSUFBSUEsR0FBRyxLQUFLLFdBQVcsRUFDbkIsT0FBTyxhQUFhO0VBQ3hCLE9BQU9BLEdBQUc7QUFDZDtBQUVBLE1BQU0ySyxjQUFjLEdBQUlDLE9BQU8sSUFBSUEsT0FBTyxDQUFDdEQsR0FBRyxJQUFJc0QsT0FBTyxDQUFDdEQsR0FBRyxDQUFDdUQsc0JBQXNCLEdBQzlFMUUsTUFBTSxDQUFDeUUsT0FBTyxDQUFDdEQsR0FBRyxDQUFDdUQsc0JBQXNCLENBQUMsR0FDMUMsRUFBRTtBQUNSLElBQUlELE9BQU8sSUFBSUEsT0FBTyxDQUFDRSxPQUFPLEVBQUU7RUFDNUIsTUFBTUMsS0FBSyxHQUFHNUUsTUFBTSxDQUFDeUUsT0FBTyxDQUFDRSxPQUFPLENBQUNuTyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDMUQsSUFBSW9PLEtBQUssR0FBR0osY0FBYyxFQUFFO0lBQ3hCLE1BQU1oRyxLQUFLLENBQUUsc0RBQXFEZ0csY0FBZSxvR0FBbUcsQ0FBQztFQUN6TDtBQUNKO0FBQ0EsTUFBTXJELEdBQUcsR0FBR3NELE9BQU8sR0FBR0EsT0FBTyxDQUFDdEQsR0FBRyxHQUFHLENBQUMsQ0FBQztBQUN0QyxNQUFNMEQsTUFBTSxHQUFHLElBQUl4TSxXQUFXLENBQUM7RUFDM0JvSSxHQUFHLEVBQUVnRSxPQUFPLENBQUNoRSxHQUFHO0VBQ2hCVSxHQUFHLEVBQUVBLENBQUEsS0FBTTtJQUNQLE9BQU9BLEdBQUc7RUFDZCxDQUFDO0VBQ0Q3RyxNQUFNLEVBQUUzRSxJQUFJLENBQUMyRSxNQUFNO0VBQ25CYixTQUFTLEVBQUUzRCxJQUFJLENBQUMyRCxTQUFTO0VBQ3pCK0csT0FBTyxFQUFFMUssSUFBSSxDQUFDMEssT0FBTztFQUNyQjVLLE9BQU8sRUFBR0UsSUFBSSxJQUFLO0lBQ2YsSUFBSSxPQUFPRixPQUFPLEtBQUssV0FBVyxFQUFFO01BQ2hDLE9BQU9BLE9BQU8sQ0FBQ0UsSUFBSSxDQUFDO0lBQ3hCLENBQUMsTUFDSSxJQUFJQSxJQUFJLENBQUNVLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRTtNQUM1QixPQUFPWCxFQUFFLENBQUNpUCxZQUFZLENBQUNoUCxJQUFJLEVBQUUsTUFBTSxDQUFDO0lBQ3hDLENBQUMsTUFDSTtNQUNELE1BQU0wSSxLQUFLLENBQUMsOENBQThDLENBQUM7SUFDL0Q7RUFDSjtBQUNKLENBQUMsQ0FBQztBQUNGLE1BQU11RyxXQUFXLEdBQUcsU0FBU0MsTUFBTUEsQ0FBQy9NLElBQUksRUFBRVUsSUFBSSxFQUFFO0VBQzVDLE1BQU1zTSxNQUFNLEdBQUdKLE1BQU0sQ0FBQ3JNLEtBQUssQ0FBQ1AsSUFBSSxDQUFDbUYsS0FBSyxDQUFDLENBQUMsRUFBRXpFLElBQUksQ0FBQztFQUMvQyxPQUFPc00sTUFBTSxDQUFDOUksSUFBSTtBQUN0QixDQUFDO0FBQ0Q0SSxXQUFXLENBQUNHLFFBQVEsR0FBRyxVQUFVak4sSUFBSSxFQUFFVSxJQUFJLEVBQUU7RUFDekMsT0FBT2tNLE1BQU0sQ0FBQ3JNLEtBQUssQ0FBQ1AsSUFBSSxDQUFDbUYsS0FBSyxDQUFDLENBQUMsRUFBRXpFLElBQUksQ0FBQztBQUMzQyxDQUFDO0FBQ0RvTSxXQUFXLENBQUNoUCxTQUFTLEdBQUdBLFNBQVM7QUFDakNnUCxXQUFXLENBQUNsTyxVQUFVLEdBQUdBLFVBQVU7QUFDbkNrTyxXQUFXLENBQUM1TixlQUFlLEdBQUdBLGVBQWU7QUFFN0NnTyxNQUFNLENBQUNDLE9BQU8sR0FBR0wsV0FBVyJ9","map":{"version":3,"names":["util","require","fs","path","camelCase","str","isCamelCase","toLowerCase","toUpperCase","indexOf","camelcase","nextChrUpper","leadingHyphens","match","i","length","chr","charAt","decamelize","joinString","lowercase","notCamelcase","chrLower","chrString","looksLikeNumber","x","undefined","test","tokenizeArgString","argString","Array","isArray","map","e","trim","prevC","c","opening","args","ii","DefaultValuesForTypeKey","mixin","YargsParser","constructor","_mixin","parse","argsInput","options","opts","Object","assign","alias","array","boolean","config","configObjects","configuration","coerce","count","default","envPrefix","narg","normalize","string","number","__","key","aliases","combineAliases","create","defaults","notFlagsOption","notFlagsArgv","newAliases","defaulted","format","flags","arrays","bools","strings","numbers","counts","configs","nargs","coercions","keys","negative","negatedBoolean","RegExp","concat","filter","Boolean","forEach","opt","assignment","arrayFlagKeys","pop","push","entries","value","extendAliases","error","checkConfiguration","notFlags","argv","_","argvReturn","arg","truncatedArg","replace","broken","letters","m","next","isUnknownOptionAsArg","pushPositional","checkAllAliases","eatArray","eatNargs","setArg","defaultValue","slice","split","j","applyEnvVars","setConfig","setConfigObjects","applyDefaultsAndAliases","applyCoercions","setPlaceholderKeys","hasKey","includes","k","prop","join","maybeCoercedNumber","maybeCoerceNumber","argAfterEqualSign","toEat","isNaN","isUndefined","Error","available","consumed","Math","min","argsToSet","nargsCount","defVal","processValue","val","addNewAlias","splitKey","setKey","keyProperties","a","shift","defineProperty","enumerable","get","set","substring","v","increment","shouldCoerceNumber","Number","isSafeInteger","floor","parseFloat","configLookup","configKey","configPath","resolvedConfigPath","resolve","cwd","resolveConfig","setConfigObject","ex","name","prev","fullKey","configObject","configOnly","prefix","env","envVar","lastIndexOf","applied","Set","has","ali","add","err","obj","canLog","o","sanitizeKey","isTypeArray","isValueArray","duplicate","y","flag","toCheck","setAlias","find","hasAnyFlag","flagsKeys","some","hasFlagsMatching","patterns","pattern","hasAllShortFlags","hasAllFlags","isUnknownOption","flagWithEquals","normalFlag","flagEndingInHyphen","flagEndingInDigits","flagEndingInNonWordCharacters","defaultForType","guessType","type","def","BOOLEAN","STRING","NUMBER","ARRAY","num","aliasArrays","combined","change","intersect","splice","aliasArray","self","lastAlias","orig","minNodeVersion","process","YARGS_MIN_NODE_VERSION","version","major","parser","readFileSync","yargsParser","Parser","result","detailed","module","exports"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\yargs-parser@20.2.9\\node_modules\\yargs-parser\\build\\","sources":["index.cjs"],"sourcesContent":["'use strict';\n\nvar util = require('util');\nvar fs = require('fs');\nvar path = require('path');\n\nfunction camelCase(str) {\n    const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();\n    if (!isCamelCase) {\n        str = str.toLowerCase();\n    }\n    if (str.indexOf('-') === -1 && str.indexOf('_') === -1) {\n        return str;\n    }\n    else {\n        let camelcase = '';\n        let nextChrUpper = false;\n        const leadingHyphens = str.match(/^-+/);\n        for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {\n            let chr = str.charAt(i);\n            if (nextChrUpper) {\n                nextChrUpper = false;\n                chr = chr.toUpperCase();\n            }\n            if (i !== 0 && (chr === '-' || chr === '_')) {\n                nextChrUpper = true;\n            }\n            else if (chr !== '-' && chr !== '_') {\n                camelcase += chr;\n            }\n        }\n        return camelcase;\n    }\n}\nfunction decamelize(str, joinString) {\n    const lowercase = str.toLowerCase();\n    joinString = joinString || '-';\n    let notCamelcase = '';\n    for (let i = 0; i < str.length; i++) {\n        const chrLower = lowercase.charAt(i);\n        const chrString = str.charAt(i);\n        if (chrLower !== chrString && i > 0) {\n            notCamelcase += `${joinString}${lowercase.charAt(i)}`;\n        }\n        else {\n            notCamelcase += chrString;\n        }\n    }\n    return notCamelcase;\n}\nfunction looksLikeNumber(x) {\n    if (x === null || x === undefined)\n        return false;\n    if (typeof x === 'number')\n        return true;\n    if (/^0x[0-9a-f]+$/i.test(x))\n        return true;\n    if (/^0[^.]/.test(x))\n        return false;\n    return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n}\n\nfunction tokenizeArgString(argString) {\n    if (Array.isArray(argString)) {\n        return argString.map(e => typeof e !== 'string' ? e + '' : e);\n    }\n    argString = argString.trim();\n    let i = 0;\n    let prevC = null;\n    let c = null;\n    let opening = null;\n    const args = [];\n    for (let ii = 0; ii < argString.length; ii++) {\n        prevC = c;\n        c = argString.charAt(ii);\n        if (c === ' ' && !opening) {\n            if (!(prevC === ' ')) {\n                i++;\n            }\n            continue;\n        }\n        if (c === opening) {\n            opening = null;\n        }\n        else if ((c === \"'\" || c === '\"') && !opening) {\n            opening = c;\n        }\n        if (!args[i])\n            args[i] = '';\n        args[i] += c;\n    }\n    return args;\n}\n\nvar DefaultValuesForTypeKey;\n(function (DefaultValuesForTypeKey) {\n    DefaultValuesForTypeKey[\"BOOLEAN\"] = \"boolean\";\n    DefaultValuesForTypeKey[\"STRING\"] = \"string\";\n    DefaultValuesForTypeKey[\"NUMBER\"] = \"number\";\n    DefaultValuesForTypeKey[\"ARRAY\"] = \"array\";\n})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));\n\nlet mixin;\nclass YargsParser {\n    constructor(_mixin) {\n        mixin = _mixin;\n    }\n    parse(argsInput, options) {\n        const opts = Object.assign({\n            alias: undefined,\n            array: undefined,\n            boolean: undefined,\n            config: undefined,\n            configObjects: undefined,\n            configuration: undefined,\n            coerce: undefined,\n            count: undefined,\n            default: undefined,\n            envPrefix: undefined,\n            narg: undefined,\n            normalize: undefined,\n            string: undefined,\n            number: undefined,\n            __: undefined,\n            key: undefined\n        }, options);\n        const args = tokenizeArgString(argsInput);\n        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));\n        const configuration = Object.assign({\n            'boolean-negation': true,\n            'camel-case-expansion': true,\n            'combine-arrays': false,\n            'dot-notation': true,\n            'duplicate-arguments-array': true,\n            'flatten-duplicate-arrays': true,\n            'greedy-arrays': true,\n            'halt-at-non-option': false,\n            'nargs-eats-options': false,\n            'negation-prefix': 'no-',\n            'parse-numbers': true,\n            'parse-positional-numbers': true,\n            'populate--': false,\n            'set-placeholder-key': false,\n            'short-option-groups': true,\n            'strip-aliased': false,\n            'strip-dashed': false,\n            'unknown-options-as-args': false\n        }, opts.configuration);\n        const defaults = Object.assign(Object.create(null), opts.default);\n        const configObjects = opts.configObjects || [];\n        const envPrefix = opts.envPrefix;\n        const notFlagsOption = configuration['populate--'];\n        const notFlagsArgv = notFlagsOption ? '--' : '_';\n        const newAliases = Object.create(null);\n        const defaulted = Object.create(null);\n        const __ = opts.__ || mixin.format;\n        const flags = {\n            aliases: Object.create(null),\n            arrays: Object.create(null),\n            bools: Object.create(null),\n            strings: Object.create(null),\n            numbers: Object.create(null),\n            counts: Object.create(null),\n            normalize: Object.create(null),\n            configs: Object.create(null),\n            nargs: Object.create(null),\n            coercions: Object.create(null),\n            keys: []\n        };\n        const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/;\n        const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');\n        [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {\n            const key = typeof opt === 'object' ? opt.key : opt;\n            const assignment = Object.keys(opt).map(function (key) {\n                const arrayFlagKeys = {\n                    boolean: 'bools',\n                    string: 'strings',\n                    number: 'numbers'\n                };\n                return arrayFlagKeys[key];\n            }).filter(Boolean).pop();\n            if (assignment) {\n                flags[assignment][key] = true;\n            }\n            flags.arrays[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {\n            flags.bools[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.string || []).filter(Boolean).forEach(function (key) {\n            flags.strings[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.number || []).filter(Boolean).forEach(function (key) {\n            flags.numbers[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.count || []).filter(Boolean).forEach(function (key) {\n            flags.counts[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {\n            flags.normalize[key] = true;\n            flags.keys.push(key);\n        });\n        if (typeof opts.narg === 'object') {\n            Object.entries(opts.narg).forEach(([key, value]) => {\n                if (typeof value === 'number') {\n                    flags.nargs[key] = value;\n                    flags.keys.push(key);\n                }\n            });\n        }\n        if (typeof opts.coerce === 'object') {\n            Object.entries(opts.coerce).forEach(([key, value]) => {\n                if (typeof value === 'function') {\n                    flags.coercions[key] = value;\n                    flags.keys.push(key);\n                }\n            });\n        }\n        if (typeof opts.config !== 'undefined') {\n            if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n                [].concat(opts.config).filter(Boolean).forEach(function (key) {\n                    flags.configs[key] = true;\n                });\n            }\n            else if (typeof opts.config === 'object') {\n                Object.entries(opts.config).forEach(([key, value]) => {\n                    if (typeof value === 'boolean' || typeof value === 'function') {\n                        flags.configs[key] = value;\n                    }\n                });\n            }\n        }\n        extendAliases(opts.key, aliases, opts.default, flags.arrays);\n        Object.keys(defaults).forEach(function (key) {\n            (flags.aliases[key] || []).forEach(function (alias) {\n                defaults[alias] = defaults[key];\n            });\n        });\n        let error = null;\n        checkConfiguration();\n        let notFlags = [];\n        const argv = Object.assign(Object.create(null), { _: [] });\n        const argvReturn = {};\n        for (let i = 0; i < args.length; i++) {\n            const arg = args[i];\n            const truncatedArg = arg.replace(/^-{3,}/, '---');\n            let broken;\n            let key;\n            let letters;\n            let m;\n            let next;\n            let value;\n            if (arg !== '--' && isUnknownOptionAsArg(arg)) {\n                pushPositional(arg);\n            }\n            else if (truncatedArg.match(/---+(=|$)/)) {\n                pushPositional(arg);\n                continue;\n            }\n            else if (arg.match(/^--.+=/) || (!configuration['short-option-groups'] && arg.match(/^-.+=/))) {\n                m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/);\n                if (m !== null && Array.isArray(m) && m.length >= 3) {\n                    if (checkAllAliases(m[1], flags.arrays)) {\n                        i = eatArray(i, m[1], args, m[2]);\n                    }\n                    else if (checkAllAliases(m[1], flags.nargs) !== false) {\n                        i = eatNargs(i, m[1], args, m[2]);\n                    }\n                    else {\n                        setArg(m[1], m[2]);\n                    }\n                }\n            }\n            else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n                m = arg.match(negatedBoolean);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);\n                }\n            }\n            else if (arg.match(/^--.+/) || (!configuration['short-option-groups'] && arg.match(/^-[^-]+/))) {\n                m = arg.match(/^--?(.+)/);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    if (checkAllAliases(key, flags.arrays)) {\n                        i = eatArray(i, key, args);\n                    }\n                    else if (checkAllAliases(key, flags.nargs) !== false) {\n                        i = eatNargs(i, key, args);\n                    }\n                    else {\n                        next = args[i + 1];\n                        if (next !== undefined && (!next.match(/^-/) ||\n                            next.match(negative)) &&\n                            !checkAllAliases(key, flags.bools) &&\n                            !checkAllAliases(key, flags.counts)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else if (/^(true|false)$/.test(next)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else {\n                            setArg(key, defaultValue(key));\n                        }\n                    }\n                }\n            }\n            else if (arg.match(/^-.\\..+=/)) {\n                m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n                if (m !== null && Array.isArray(m) && m.length >= 3) {\n                    setArg(m[1], m[2]);\n                }\n            }\n            else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n                next = args[i + 1];\n                m = arg.match(/^-(.\\..+)/);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    if (next !== undefined && !next.match(/^-/) &&\n                        !checkAllAliases(key, flags.bools) &&\n                        !checkAllAliases(key, flags.counts)) {\n                        setArg(key, next);\n                        i++;\n                    }\n                    else {\n                        setArg(key, defaultValue(key));\n                    }\n                }\n            }\n            else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n                letters = arg.slice(1, -1).split('');\n                broken = false;\n                for (let j = 0; j < letters.length; j++) {\n                    next = arg.slice(j + 2);\n                    if (letters[j + 1] && letters[j + 1] === '=') {\n                        value = arg.slice(j + 3);\n                        key = letters[j];\n                        if (checkAllAliases(key, flags.arrays)) {\n                            i = eatArray(i, key, args, value);\n                        }\n                        else if (checkAllAliases(key, flags.nargs) !== false) {\n                            i = eatNargs(i, key, args, value);\n                        }\n                        else {\n                            setArg(key, value);\n                        }\n                        broken = true;\n                        break;\n                    }\n                    if (next === '-') {\n                        setArg(letters[j], next);\n                        continue;\n                    }\n                    if (/[A-Za-z]/.test(letters[j]) &&\n                        /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) &&\n                        checkAllAliases(next, flags.bools) === false) {\n                        setArg(letters[j], next);\n                        broken = true;\n                        break;\n                    }\n                    if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n                        setArg(letters[j], next);\n                        broken = true;\n                        break;\n                    }\n                    else {\n                        setArg(letters[j], defaultValue(letters[j]));\n                    }\n                }\n                key = arg.slice(-1)[0];\n                if (!broken && key !== '-') {\n                    if (checkAllAliases(key, flags.arrays)) {\n                        i = eatArray(i, key, args);\n                    }\n                    else if (checkAllAliases(key, flags.nargs) !== false) {\n                        i = eatNargs(i, key, args);\n                    }\n                    else {\n                        next = args[i + 1];\n                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n                            next.match(negative)) &&\n                            !checkAllAliases(key, flags.bools) &&\n                            !checkAllAliases(key, flags.counts)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else if (/^(true|false)$/.test(next)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else {\n                            setArg(key, defaultValue(key));\n                        }\n                    }\n                }\n            }\n            else if (arg.match(/^-[0-9]$/) &&\n                arg.match(negative) &&\n                checkAllAliases(arg.slice(1), flags.bools)) {\n                key = arg.slice(1);\n                setArg(key, defaultValue(key));\n            }\n            else if (arg === '--') {\n                notFlags = args.slice(i + 1);\n                break;\n            }\n            else if (configuration['halt-at-non-option']) {\n                notFlags = args.slice(i);\n                break;\n            }\n            else {\n                pushPositional(arg);\n            }\n        }\n        applyEnvVars(argv, true);\n        applyEnvVars(argv, false);\n        setConfig(argv);\n        setConfigObjects();\n        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);\n        applyCoercions(argv);\n        if (configuration['set-placeholder-key'])\n            setPlaceholderKeys(argv);\n        Object.keys(flags.counts).forEach(function (key) {\n            if (!hasKey(argv, key.split('.')))\n                setArg(key, 0);\n        });\n        if (notFlagsOption && notFlags.length)\n            argv[notFlagsArgv] = [];\n        notFlags.forEach(function (key) {\n            argv[notFlagsArgv].push(key);\n        });\n        if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n            Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n                delete argv[key];\n            });\n        }\n        if (configuration['strip-aliased']) {\n            [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n                if (configuration['camel-case-expansion'] && alias.includes('-')) {\n                    delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];\n                }\n                delete argv[alias];\n            });\n        }\n        function pushPositional(arg) {\n            const maybeCoercedNumber = maybeCoerceNumber('_', arg);\n            if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {\n                argv._.push(maybeCoercedNumber);\n            }\n        }\n        function eatNargs(i, key, args, argAfterEqualSign) {\n            let ii;\n            let toEat = checkAllAliases(key, flags.nargs);\n            toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;\n            if (toEat === 0) {\n                if (!isUndefined(argAfterEqualSign)) {\n                    error = Error(__('Argument unexpected for: %s', key));\n                }\n                setArg(key, defaultValue(key));\n                return i;\n            }\n            let available = isUndefined(argAfterEqualSign) ? 0 : 1;\n            if (configuration['nargs-eats-options']) {\n                if (args.length - (i + 1) + available < toEat) {\n                    error = Error(__('Not enough arguments following: %s', key));\n                }\n                available = toEat;\n            }\n            else {\n                for (ii = i + 1; ii < args.length; ii++) {\n                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii]))\n                        available++;\n                    else\n                        break;\n                }\n                if (available < toEat)\n                    error = Error(__('Not enough arguments following: %s', key));\n            }\n            let consumed = Math.min(available, toEat);\n            if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n                setArg(key, argAfterEqualSign);\n                consumed--;\n            }\n            for (ii = i + 1; ii < (consumed + i + 1); ii++) {\n                setArg(key, args[ii]);\n            }\n            return (i + consumed);\n        }\n        function eatArray(i, key, args, argAfterEqualSign) {\n            let argsToSet = [];\n            let next = argAfterEqualSign || args[i + 1];\n            const nargsCount = checkAllAliases(key, flags.nargs);\n            if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {\n                argsToSet.push(true);\n            }\n            else if (isUndefined(next) ||\n                (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {\n                if (defaults[key] !== undefined) {\n                    const defVal = defaults[key];\n                    argsToSet = Array.isArray(defVal) ? defVal : [defVal];\n                }\n            }\n            else {\n                if (!isUndefined(argAfterEqualSign)) {\n                    argsToSet.push(processValue(key, argAfterEqualSign));\n                }\n                for (let ii = i + 1; ii < args.length; ii++) {\n                    if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||\n                        (nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount))\n                        break;\n                    next = args[ii];\n                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))\n                        break;\n                    i = ii;\n                    argsToSet.push(processValue(key, next));\n                }\n            }\n            if (typeof nargsCount === 'number' && ((nargsCount && argsToSet.length < nargsCount) ||\n                (isNaN(nargsCount) && argsToSet.length === 0))) {\n                error = Error(__('Not enough arguments following: %s', key));\n            }\n            setArg(key, argsToSet);\n            return i;\n        }\n        function setArg(key, val) {\n            if (/-/.test(key) && configuration['camel-case-expansion']) {\n                const alias = key.split('.').map(function (prop) {\n                    return camelCase(prop);\n                }).join('.');\n                addNewAlias(key, alias);\n            }\n            const value = processValue(key, val);\n            const splitKey = key.split('.');\n            setKey(argv, splitKey, value);\n            if (flags.aliases[key]) {\n                flags.aliases[key].forEach(function (x) {\n                    const keyProperties = x.split('.');\n                    setKey(argv, keyProperties, value);\n                });\n            }\n            if (splitKey.length > 1 && configuration['dot-notation']) {\n                (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n                    let keyProperties = x.split('.');\n                    const a = [].concat(splitKey);\n                    a.shift();\n                    keyProperties = keyProperties.concat(a);\n                    if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {\n                        setKey(argv, keyProperties, value);\n                    }\n                });\n            }\n            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n                const keys = [key].concat(flags.aliases[key] || []);\n                keys.forEach(function (key) {\n                    Object.defineProperty(argvReturn, key, {\n                        enumerable: true,\n                        get() {\n                            return val;\n                        },\n                        set(value) {\n                            val = typeof value === 'string' ? mixin.normalize(value) : value;\n                        }\n                    });\n                });\n            }\n        }\n        function addNewAlias(key, alias) {\n            if (!(flags.aliases[key] && flags.aliases[key].length)) {\n                flags.aliases[key] = [alias];\n                newAliases[alias] = true;\n            }\n            if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n                addNewAlias(alias, key);\n            }\n        }\n        function processValue(key, val) {\n            if (typeof val === 'string' &&\n                (val[0] === \"'\" || val[0] === '\"') &&\n                val[val.length - 1] === val[0]) {\n                val = val.substring(1, val.length - 1);\n            }\n            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n                if (typeof val === 'string')\n                    val = val === 'true';\n            }\n            let value = Array.isArray(val)\n                ? val.map(function (v) { return maybeCoerceNumber(key, v); })\n                : maybeCoerceNumber(key, val);\n            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n                value = increment();\n            }\n            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n                if (Array.isArray(val))\n                    value = val.map((val) => { return mixin.normalize(val); });\n                else\n                    value = mixin.normalize(val);\n            }\n            return value;\n        }\n        function maybeCoerceNumber(key, value) {\n            if (!configuration['parse-positional-numbers'] && key === '_')\n                return value;\n            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n                const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && (Number.isSafeInteger(Math.floor(parseFloat(`${value}`))));\n                if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) {\n                    value = Number(value);\n                }\n            }\n            return value;\n        }\n        function setConfig(argv) {\n            const configLookup = Object.create(null);\n            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n            Object.keys(flags.configs).forEach(function (configKey) {\n                const configPath = argv[configKey] || configLookup[configKey];\n                if (configPath) {\n                    try {\n                        let config = null;\n                        const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);\n                        const resolveConfig = flags.configs[configKey];\n                        if (typeof resolveConfig === 'function') {\n                            try {\n                                config = resolveConfig(resolvedConfigPath);\n                            }\n                            catch (e) {\n                                config = e;\n                            }\n                            if (config instanceof Error) {\n                                error = config;\n                                return;\n                            }\n                        }\n                        else {\n                            config = mixin.require(resolvedConfigPath);\n                        }\n                        setConfigObject(config);\n                    }\n                    catch (ex) {\n                        if (ex.name === 'PermissionDenied')\n                            error = ex;\n                        else if (argv[configKey])\n                            error = Error(__('Invalid JSON config file: %s', configPath));\n                    }\n                }\n            });\n        }\n        function setConfigObject(config, prev) {\n            Object.keys(config).forEach(function (key) {\n                const value = config[key];\n                const fullKey = prev ? prev + '.' + key : key;\n                if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n                    setConfigObject(value, fullKey);\n                }\n                else {\n                    if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {\n                        setArg(fullKey, value);\n                    }\n                }\n            });\n        }\n        function setConfigObjects() {\n            if (typeof configObjects !== 'undefined') {\n                configObjects.forEach(function (configObject) {\n                    setConfigObject(configObject);\n                });\n            }\n        }\n        function applyEnvVars(argv, configOnly) {\n            if (typeof envPrefix === 'undefined')\n                return;\n            const prefix = typeof envPrefix === 'string' ? envPrefix : '';\n            const env = mixin.env();\n            Object.keys(env).forEach(function (envVar) {\n                if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n                    const keys = envVar.split('__').map(function (key, i) {\n                        if (i === 0) {\n                            key = key.substring(prefix.length);\n                        }\n                        return camelCase(key);\n                    });\n                    if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {\n                        setArg(keys.join('.'), env[envVar]);\n                    }\n                }\n            });\n        }\n        function applyCoercions(argv) {\n            let coerce;\n            const applied = new Set();\n            Object.keys(argv).forEach(function (key) {\n                if (!applied.has(key)) {\n                    coerce = checkAllAliases(key, flags.coercions);\n                    if (typeof coerce === 'function') {\n                        try {\n                            const value = maybeCoerceNumber(key, coerce(argv[key]));\n                            ([].concat(flags.aliases[key] || [], key)).forEach(ali => {\n                                applied.add(ali);\n                                argv[ali] = value;\n                            });\n                        }\n                        catch (err) {\n                            error = err;\n                        }\n                    }\n                }\n            });\n        }\n        function setPlaceholderKeys(argv) {\n            flags.keys.forEach((key) => {\n                if (~key.indexOf('.'))\n                    return;\n                if (typeof argv[key] === 'undefined')\n                    argv[key] = undefined;\n            });\n            return argv;\n        }\n        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {\n            Object.keys(defaults).forEach(function (key) {\n                if (!hasKey(obj, key.split('.'))) {\n                    setKey(obj, key.split('.'), defaults[key]);\n                    if (canLog)\n                        defaulted[key] = true;\n                    (aliases[key] || []).forEach(function (x) {\n                        if (hasKey(obj, x.split('.')))\n                            return;\n                        setKey(obj, x.split('.'), defaults[key]);\n                    });\n                }\n            });\n        }\n        function hasKey(obj, keys) {\n            let o = obj;\n            if (!configuration['dot-notation'])\n                keys = [keys.join('.')];\n            keys.slice(0, -1).forEach(function (key) {\n                o = (o[key] || {});\n            });\n            const key = keys[keys.length - 1];\n            if (typeof o !== 'object')\n                return false;\n            else\n                return key in o;\n        }\n        function setKey(obj, keys, value) {\n            let o = obj;\n            if (!configuration['dot-notation'])\n                keys = [keys.join('.')];\n            keys.slice(0, -1).forEach(function (key) {\n                key = sanitizeKey(key);\n                if (typeof o === 'object' && o[key] === undefined) {\n                    o[key] = {};\n                }\n                if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n                    if (Array.isArray(o[key])) {\n                        o[key].push({});\n                    }\n                    else {\n                        o[key] = [o[key], {}];\n                    }\n                    o = o[key][o[key].length - 1];\n                }\n                else {\n                    o = o[key];\n                }\n            });\n            const key = sanitizeKey(keys[keys.length - 1]);\n            const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n            const isValueArray = Array.isArray(value);\n            let duplicate = configuration['duplicate-arguments-array'];\n            if (!duplicate && checkAllAliases(key, flags.nargs)) {\n                duplicate = true;\n                if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {\n                    o[key] = undefined;\n                }\n            }\n            if (value === increment()) {\n                o[key] = increment(o[key]);\n            }\n            else if (Array.isArray(o[key])) {\n                if (duplicate && isTypeArray && isValueArray) {\n                    o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);\n                }\n                else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n                    o[key] = value;\n                }\n                else {\n                    o[key] = o[key].concat([value]);\n                }\n            }\n            else if (o[key] === undefined && isTypeArray) {\n                o[key] = isValueArray ? value : [value];\n            }\n            else if (duplicate && !(o[key] === undefined ||\n                checkAllAliases(key, flags.counts) ||\n                checkAllAliases(key, flags.bools))) {\n                o[key] = [o[key], value];\n            }\n            else {\n                o[key] = value;\n            }\n        }\n        function extendAliases(...args) {\n            args.forEach(function (obj) {\n                Object.keys(obj || {}).forEach(function (key) {\n                    if (flags.aliases[key])\n                        return;\n                    flags.aliases[key] = [].concat(aliases[key] || []);\n                    flags.aliases[key].concat(key).forEach(function (x) {\n                        if (/-/.test(x) && configuration['camel-case-expansion']) {\n                            const c = camelCase(x);\n                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                                flags.aliases[key].push(c);\n                                newAliases[c] = true;\n                            }\n                        }\n                    });\n                    flags.aliases[key].concat(key).forEach(function (x) {\n                        if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n                            const c = decamelize(x, '-');\n                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                                flags.aliases[key].push(c);\n                                newAliases[c] = true;\n                            }\n                        }\n                    });\n                    flags.aliases[key].forEach(function (x) {\n                        flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n                            return x !== y;\n                        }));\n                    });\n                });\n            });\n        }\n        function checkAllAliases(key, flag) {\n            const toCheck = [].concat(flags.aliases[key] || [], key);\n            const keys = Object.keys(flag);\n            const setAlias = toCheck.find(key => keys.includes(key));\n            return setAlias ? flag[setAlias] : false;\n        }\n        function hasAnyFlag(key) {\n            const flagsKeys = Object.keys(flags);\n            const toCheck = [].concat(flagsKeys.map(k => flags[k]));\n            return toCheck.some(function (flag) {\n                return Array.isArray(flag) ? flag.includes(key) : flag[key];\n            });\n        }\n        function hasFlagsMatching(arg, ...patterns) {\n            const toCheck = [].concat(...patterns);\n            return toCheck.some(function (pattern) {\n                const match = arg.match(pattern);\n                return match && hasAnyFlag(match[1]);\n            });\n        }\n        function hasAllShortFlags(arg) {\n            if (arg.match(negative) || !arg.match(/^-[^-]+/)) {\n                return false;\n            }\n            let hasAllFlags = true;\n            let next;\n            const letters = arg.slice(1).split('');\n            for (let j = 0; j < letters.length; j++) {\n                next = arg.slice(j + 2);\n                if (!hasAnyFlag(letters[j])) {\n                    hasAllFlags = false;\n                    break;\n                }\n                if ((letters[j + 1] && letters[j + 1] === '=') ||\n                    next === '-' ||\n                    (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) ||\n                    (letters[j + 1] && letters[j + 1].match(/\\W/))) {\n                    break;\n                }\n            }\n            return hasAllFlags;\n        }\n        function isUnknownOptionAsArg(arg) {\n            return configuration['unknown-options-as-args'] && isUnknownOption(arg);\n        }\n        function isUnknownOption(arg) {\n            arg = arg.replace(/^-{3,}/, '--');\n            if (arg.match(negative)) {\n                return false;\n            }\n            if (hasAllShortFlags(arg)) {\n                return false;\n            }\n            const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/;\n            const normalFlag = /^-+([^=]+?)$/;\n            const flagEndingInHyphen = /^-+([^=]+?)-$/;\n            const flagEndingInDigits = /^-+([^=]+?\\d+)$/;\n            const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/;\n            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);\n        }\n        function defaultValue(key) {\n            if (!checkAllAliases(key, flags.bools) &&\n                !checkAllAliases(key, flags.counts) &&\n                `${key}` in defaults) {\n                return defaults[key];\n            }\n            else {\n                return defaultForType(guessType(key));\n            }\n        }\n        function defaultForType(type) {\n            const def = {\n                [DefaultValuesForTypeKey.BOOLEAN]: true,\n                [DefaultValuesForTypeKey.STRING]: '',\n                [DefaultValuesForTypeKey.NUMBER]: undefined,\n                [DefaultValuesForTypeKey.ARRAY]: []\n            };\n            return def[type];\n        }\n        function guessType(key) {\n            let type = DefaultValuesForTypeKey.BOOLEAN;\n            if (checkAllAliases(key, flags.strings))\n                type = DefaultValuesForTypeKey.STRING;\n            else if (checkAllAliases(key, flags.numbers))\n                type = DefaultValuesForTypeKey.NUMBER;\n            else if (checkAllAliases(key, flags.bools))\n                type = DefaultValuesForTypeKey.BOOLEAN;\n            else if (checkAllAliases(key, flags.arrays))\n                type = DefaultValuesForTypeKey.ARRAY;\n            return type;\n        }\n        function isUndefined(num) {\n            return num === undefined;\n        }\n        function checkConfiguration() {\n            Object.keys(flags.counts).find(key => {\n                if (checkAllAliases(key, flags.arrays)) {\n                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));\n                    return true;\n                }\n                else if (checkAllAliases(key, flags.nargs)) {\n                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));\n                    return true;\n                }\n                return false;\n            });\n        }\n        return {\n            aliases: Object.assign({}, flags.aliases),\n            argv: Object.assign(argvReturn, argv),\n            configuration: configuration,\n            defaulted: Object.assign({}, defaulted),\n            error: error,\n            newAliases: Object.assign({}, newAliases)\n        };\n    }\n}\nfunction combineAliases(aliases) {\n    const aliasArrays = [];\n    const combined = Object.create(null);\n    let change = true;\n    Object.keys(aliases).forEach(function (key) {\n        aliasArrays.push([].concat(aliases[key], key));\n    });\n    while (change) {\n        change = false;\n        for (let i = 0; i < aliasArrays.length; i++) {\n            for (let ii = i + 1; ii < aliasArrays.length; ii++) {\n                const intersect = aliasArrays[i].filter(function (v) {\n                    return aliasArrays[ii].indexOf(v) !== -1;\n                });\n                if (intersect.length) {\n                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n                    aliasArrays.splice(ii, 1);\n                    change = true;\n                    break;\n                }\n            }\n        }\n    }\n    aliasArrays.forEach(function (aliasArray) {\n        aliasArray = aliasArray.filter(function (v, i, self) {\n            return self.indexOf(v) === i;\n        });\n        const lastAlias = aliasArray.pop();\n        if (lastAlias !== undefined && typeof lastAlias === 'string') {\n            combined[lastAlias] = aliasArray;\n        }\n    });\n    return combined;\n}\nfunction increment(orig) {\n    return orig !== undefined ? orig + 1 : 1;\n}\nfunction sanitizeKey(key) {\n    if (key === '__proto__')\n        return '___proto___';\n    return key;\n}\n\nconst minNodeVersion = (process && process.env && process.env.YARGS_MIN_NODE_VERSION)\n    ? Number(process.env.YARGS_MIN_NODE_VERSION)\n    : 10;\nif (process && process.version) {\n    const major = Number(process.version.match(/v([^.]+)/)[1]);\n    if (major < minNodeVersion) {\n        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);\n    }\n}\nconst env = process ? process.env : {};\nconst parser = new YargsParser({\n    cwd: process.cwd,\n    env: () => {\n        return env;\n    },\n    format: util.format,\n    normalize: path.normalize,\n    resolve: path.resolve,\n    require: (path) => {\n        if (typeof require !== 'undefined') {\n            return require(path);\n        }\n        else if (path.match(/\\.json$/)) {\n            return fs.readFileSync(path, 'utf8');\n        }\n        else {\n            throw Error('only .json config files are supported in ESM');\n        }\n    }\n});\nconst yargsParser = function Parser(args, opts) {\n    const result = parser.parse(args.slice(), opts);\n    return result.argv;\n};\nyargsParser.detailed = function (args, opts) {\n    return parser.parse(args.slice(), opts);\n};\nyargsParser.camelCase = camelCase;\nyargsParser.decamelize = decamelize;\nyargsParser.looksLikeNumber = looksLikeNumber;\n\nmodule.exports = yargsParser;\n"],"mappings":"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"}},"mtime":1674865298662},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\cliui@7.0.4\\\\node_modules\\\\cliui\\\\build\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\cliui@7.0.4\\\\node_modules\\\\cliui\\\\build\\\\index.cjs\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"'use strict';\n\nconst align = {\n  right: alignRight,\n  center: alignCenter\n};\nconst top = 0;\nconst right = 1;\nconst bottom = 2;\nconst left = 3;\nclass UI {\n  constructor(opts) {\n    var _a;\n    this.width = opts.width;\n    this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;\n    this.rows = [];\n  }\n  span(...args) {\n    const cols = this.div(...args);\n    cols.span = true;\n  }\n  resetOutput() {\n    this.rows = [];\n  }\n  div(...args) {\n    if (args.length === 0) {\n      this.div('');\n    }\n    if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {\n      return this.applyLayoutDSL(args[0]);\n    }\n    const cols = args.map(arg => {\n      if (typeof arg === 'string') {\n        return this.colFromString(arg);\n      }\n      return arg;\n    });\n    this.rows.push(cols);\n    return cols;\n  }\n  shouldApplyLayoutDSL(...args) {\n    return args.length === 1 && typeof args[0] === 'string' && /[\\t\\n]/.test(args[0]);\n  }\n  applyLayoutDSL(str) {\n    const rows = str.split('\\n').map(row => row.split('\\t'));\n    let leftColumnWidth = 0;\n    // simple heuristic for layout, make sure the\n    // second column lines up along the left-hand.\n    // don't allow the first column to take up more\n    // than 50% of the screen.\n    rows.forEach(columns => {\n      if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {\n        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));\n      }\n    });\n    // generate a table:\n    //  replacing ' ' with padding calculations.\n    //  using the algorithmically generated width.\n    rows.forEach(columns => {\n      this.div(...columns.map((r, i) => {\n        return {\n          text: r.trim(),\n          padding: this.measurePadding(r),\n          width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined\n        };\n      }));\n    });\n    return this.rows[this.rows.length - 1];\n  }\n  colFromString(text) {\n    return {\n      text,\n      padding: this.measurePadding(text)\n    };\n  }\n  measurePadding(str) {\n    // measure padding without ansi escape codes\n    const noAnsi = mixin.stripAnsi(str);\n    return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n  }\n  toString() {\n    const lines = [];\n    this.rows.forEach(row => {\n      this.rowToString(row, lines);\n    });\n    // don't display any lines with the\n    // hidden flag set.\n    return lines.filter(line => !line.hidden).map(line => line.text).join('\\n');\n  }\n  rowToString(row, lines) {\n    this.rasterize(row).forEach((rrow, r) => {\n      let str = '';\n      rrow.forEach((col, c) => {\n        const {\n          width\n        } = row[c]; // the width with padding.\n        const wrapWidth = this.negatePadding(row[c]); // the width without padding.\n        let ts = col; // temporary string used during alignment/padding.\n        if (wrapWidth > mixin.stringWidth(col)) {\n          ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));\n        }\n        // align the string within its column.\n        if (row[c].align && row[c].align !== 'left' && this.wrap) {\n          const fn = align[row[c].align];\n          ts = fn(ts, wrapWidth);\n          if (mixin.stringWidth(ts) < wrapWidth) {\n            ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);\n          }\n        }\n        // apply border and padding to string.\n        const padding = row[c].padding || [0, 0, 0, 0];\n        if (padding[left]) {\n          str += ' '.repeat(padding[left]);\n        }\n        str += addBorder(row[c], ts, '| ');\n        str += ts;\n        str += addBorder(row[c], ts, ' |');\n        if (padding[right]) {\n          str += ' '.repeat(padding[right]);\n        }\n        // if prior row is span, try to render the\n        // current row on the prior line.\n        if (r === 0 && lines.length > 0) {\n          str = this.renderInline(str, lines[lines.length - 1]);\n        }\n      });\n      // remove trailing whitespace.\n      lines.push({\n        text: str.replace(/ +$/, ''),\n        span: row.span\n      });\n    });\n    return lines;\n  }\n  // if the full 'source' can render in\n  // the target line, do so.\n  renderInline(source, previousLine) {\n    const match = source.match(/^ */);\n    const leadingWhitespace = match ? match[0].length : 0;\n    const target = previousLine.text;\n    const targetTextWidth = mixin.stringWidth(target.trimRight());\n    if (!previousLine.span) {\n      return source;\n    }\n    // if we're not applying wrapping logic,\n    // just always append to the span.\n    if (!this.wrap) {\n      previousLine.hidden = true;\n      return target + source;\n    }\n    if (leadingWhitespace < targetTextWidth) {\n      return source;\n    }\n    previousLine.hidden = true;\n    return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();\n  }\n  rasterize(row) {\n    const rrows = [];\n    const widths = this.columnWidths(row);\n    let wrapped;\n    // word wrap all columns, and create\n    // a data-structure that is easy to rasterize.\n    row.forEach((col, c) => {\n      // leave room for left and right padding.\n      col.width = widths[c];\n      if (this.wrap) {\n        wrapped = mixin.wrap(col.text, this.negatePadding(col), {\n          hard: true\n        }).split('\\n');\n      } else {\n        wrapped = col.text.split('\\n');\n      }\n      if (col.border) {\n        wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');\n        wrapped.push(\"'\" + '-'.repeat(this.negatePadding(col) + 2) + \"'\");\n      }\n      // add top and bottom padding.\n      if (col.padding) {\n        wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));\n        wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));\n      }\n      wrapped.forEach((str, r) => {\n        if (!rrows[r]) {\n          rrows.push([]);\n        }\n        const rrow = rrows[r];\n        for (let i = 0; i < c; i++) {\n          if (rrow[i] === undefined) {\n            rrow.push('');\n          }\n        }\n        rrow.push(str);\n      });\n    });\n    return rrows;\n  }\n  negatePadding(col) {\n    let wrapWidth = col.width || 0;\n    if (col.padding) {\n      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n    }\n    if (col.border) {\n      wrapWidth -= 4;\n    }\n    return wrapWidth;\n  }\n  columnWidths(row) {\n    if (!this.wrap) {\n      return row.map(col => {\n        return col.width || mixin.stringWidth(col.text);\n      });\n    }\n    let unset = row.length;\n    let remainingWidth = this.width;\n    // column widths can be set in config.\n    const widths = row.map(col => {\n      if (col.width) {\n        unset--;\n        remainingWidth -= col.width;\n        return col.width;\n      }\n      return undefined;\n    });\n    // any unset widths should be calculated.\n    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n    return widths.map((w, i) => {\n      if (w === undefined) {\n        return Math.max(unsetWidth, _minWidth(row[i]));\n      }\n      return w;\n    });\n  }\n}\nfunction addBorder(col, ts, style) {\n  if (col.border) {\n    if (/[.']-+[.']/.test(ts)) {\n      return '';\n    }\n    if (ts.trim().length !== 0) {\n      return style;\n    }\n    return '  ';\n  }\n  return '';\n}\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth(col) {\n  const padding = col.padding || [];\n  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n  if (col.border) {\n    return minWidth + 4;\n  }\n  return minWidth;\n}\nfunction getWindowWidth() {\n  /* istanbul ignore next: depends on terminal */\n  if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n    return process.stdout.columns;\n  }\n  return 80;\n}\nfunction alignRight(str, width) {\n  str = str.trim();\n  const strWidth = mixin.stringWidth(str);\n  if (strWidth < width) {\n    return ' '.repeat(width - strWidth) + str;\n  }\n  return str;\n}\nfunction alignCenter(str, width) {\n  str = str.trim();\n  const strWidth = mixin.stringWidth(str);\n  /* istanbul ignore next */\n  if (strWidth >= width) {\n    return str;\n  }\n  return ' '.repeat(width - strWidth >> 1) + str;\n}\nlet mixin;\nfunction cliui(opts, _mixin) {\n  mixin = _mixin;\n  return new UI({\n    width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),\n    wrap: opts === null || opts === void 0 ? void 0 : opts.wrap\n  });\n}\n\n// Bootstrap cliui with CommonJS dependencies:\nconst stringWidth = require('string-width');\nconst stripAnsi = require('strip-ansi');\nconst wrap = require('wrap-ansi');\nfunction ui(opts) {\n  return cliui(opts, {\n    stringWidth,\n    stripAnsi,\n    wrap\n  });\n}\nmodule.exports = ui;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJhbGlnbiIsInJpZ2h0IiwiYWxpZ25SaWdodCIsImNlbnRlciIsImFsaWduQ2VudGVyIiwidG9wIiwiYm90dG9tIiwibGVmdCIsIlVJIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiX2EiLCJ3aWR0aCIsIndyYXAiLCJyb3dzIiwic3BhbiIsImFyZ3MiLCJjb2xzIiwiZGl2IiwicmVzZXRPdXRwdXQiLCJsZW5ndGgiLCJzaG91bGRBcHBseUxheW91dERTTCIsImFwcGx5TGF5b3V0RFNMIiwibWFwIiwiYXJnIiwiY29sRnJvbVN0cmluZyIsInB1c2giLCJ0ZXN0Iiwic3RyIiwic3BsaXQiLCJyb3ciLCJsZWZ0Q29sdW1uV2lkdGgiLCJmb3JFYWNoIiwiY29sdW1ucyIsIm1peGluIiwic3RyaW5nV2lkdGgiLCJNYXRoIiwibWluIiwiZmxvb3IiLCJyIiwiaSIsInRleHQiLCJ0cmltIiwicGFkZGluZyIsIm1lYXN1cmVQYWRkaW5nIiwidW5kZWZpbmVkIiwibm9BbnNpIiwic3RyaXBBbnNpIiwibWF0Y2giLCJ0b1N0cmluZyIsImxpbmVzIiwicm93VG9TdHJpbmciLCJmaWx0ZXIiLCJsaW5lIiwiaGlkZGVuIiwiam9pbiIsInJhc3Rlcml6ZSIsInJyb3ciLCJjb2wiLCJjIiwid3JhcFdpZHRoIiwibmVnYXRlUGFkZGluZyIsInRzIiwicmVwZWF0IiwiZm4iLCJhZGRCb3JkZXIiLCJyZW5kZXJJbmxpbmUiLCJyZXBsYWNlIiwic291cmNlIiwicHJldmlvdXNMaW5lIiwibGVhZGluZ1doaXRlc3BhY2UiLCJ0YXJnZXQiLCJ0YXJnZXRUZXh0V2lkdGgiLCJ0cmltUmlnaHQiLCJ0cmltTGVmdCIsInJyb3dzIiwid2lkdGhzIiwiY29sdW1uV2lkdGhzIiwid3JhcHBlZCIsImhhcmQiLCJib3JkZXIiLCJ1bnNoaWZ0IiwiQXJyYXkiLCJmaWxsIiwidW5zZXQiLCJyZW1haW5pbmdXaWR0aCIsInVuc2V0V2lkdGgiLCJ3IiwibWF4IiwiX21pbldpZHRoIiwic3R5bGUiLCJtaW5XaWR0aCIsImdldFdpbmRvd1dpZHRoIiwicHJvY2VzcyIsInN0ZG91dCIsInN0cldpZHRoIiwiY2xpdWkiLCJfbWl4aW4iLCJyZXF1aXJlIiwidWkiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiJDOlxcY29kZVxcRmx1aWRGcmFtZXdvcms1XFxub2RlX21vZHVsZXNcXC5wbnBtXFxjbGl1aUA3LjAuNFxcbm9kZV9tb2R1bGVzXFxjbGl1aVxcYnVpbGRcXCIsInNvdXJjZXMiOlsiaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgYWxpZ24gPSB7XG4gICAgcmlnaHQ6IGFsaWduUmlnaHQsXG4gICAgY2VudGVyOiBhbGlnbkNlbnRlclxufTtcbmNvbnN0IHRvcCA9IDA7XG5jb25zdCByaWdodCA9IDE7XG5jb25zdCBib3R0b20gPSAyO1xuY29uc3QgbGVmdCA9IDM7XG5jbGFzcyBVSSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoO1xuICAgICAgICB0aGlzLndyYXAgPSAoX2EgPSBvcHRzLndyYXApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gICAgICAgIHRoaXMucm93cyA9IFtdO1xuICAgIH1cbiAgICBzcGFuKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgY29scyA9IHRoaXMuZGl2KC4uLmFyZ3MpO1xuICAgICAgICBjb2xzLnNwYW4gPSB0cnVlO1xuICAgIH1cbiAgICByZXNldE91dHB1dCgpIHtcbiAgICAgICAgdGhpcy5yb3dzID0gW107XG4gICAgfVxuICAgIGRpdiguLi5hcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kaXYoJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndyYXAgJiYgdGhpcy5zaG91bGRBcHBseUxheW91dERTTCguLi5hcmdzKSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5TGF5b3V0RFNMKGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbHMgPSBhcmdzLm1hcChhcmcgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sRnJvbVN0cmluZyhhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucm93cy5wdXNoKGNvbHMpO1xuICAgICAgICByZXR1cm4gY29scztcbiAgICB9XG4gICAgc2hvdWxkQXBwbHlMYXlvdXREU0woLi4uYXJncykge1xuICAgICAgICByZXR1cm4gYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAvW1xcdFxcbl0vLnRlc3QoYXJnc1swXSk7XG4gICAgfVxuICAgIGFwcGx5TGF5b3V0RFNMKHN0cikge1xuICAgICAgICBjb25zdCByb3dzID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAocm93ID0+IHJvdy5zcGxpdCgnXFx0JykpO1xuICAgICAgICBsZXQgbGVmdENvbHVtbldpZHRoID0gMDtcbiAgICAgICAgLy8gc2ltcGxlIGhldXJpc3RpYyBmb3IgbGF5b3V0LCBtYWtlIHN1cmUgdGhlXG4gICAgICAgIC8vIHNlY29uZCBjb2x1bW4gbGluZXMgdXAgYWxvbmcgdGhlIGxlZnQtaGFuZC5cbiAgICAgICAgLy8gZG9uJ3QgYWxsb3cgdGhlIGZpcnN0IGNvbHVtbiB0byB0YWtlIHVwIG1vcmVcbiAgICAgICAgLy8gdGhhbiA1MCUgb2YgdGhlIHNjcmVlbi5cbiAgICAgICAgcm93cy5mb3JFYWNoKGNvbHVtbnMgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoID4gMSAmJiBtaXhpbi5zdHJpbmdXaWR0aChjb2x1bW5zWzBdKSA+IGxlZnRDb2x1bW5XaWR0aCkge1xuICAgICAgICAgICAgICAgIGxlZnRDb2x1bW5XaWR0aCA9IE1hdGgubWluKE1hdGguZmxvb3IodGhpcy53aWR0aCAqIDAuNSksIG1peGluLnN0cmluZ1dpZHRoKGNvbHVtbnNbMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGdlbmVyYXRlIGEgdGFibGU6XG4gICAgICAgIC8vICByZXBsYWNpbmcgJyAnIHdpdGggcGFkZGluZyBjYWxjdWxhdGlvbnMuXG4gICAgICAgIC8vICB1c2luZyB0aGUgYWxnb3JpdGhtaWNhbGx5IGdlbmVyYXRlZCB3aWR0aC5cbiAgICAgICAgcm93cy5mb3JFYWNoKGNvbHVtbnMgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXYoLi4uY29sdW1ucy5tYXAoKHIsIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiByLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogdGhpcy5tZWFzdXJlUGFkZGluZyhyKSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IChpID09PSAwICYmIGNvbHVtbnMubGVuZ3RoID4gMSkgPyBsZWZ0Q29sdW1uV2lkdGggOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93c1t0aGlzLnJvd3MubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNvbEZyb21TdHJpbmcodGV4dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIHBhZGRpbmc6IHRoaXMubWVhc3VyZVBhZGRpbmcodGV4dClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbWVhc3VyZVBhZGRpbmcoc3RyKSB7XG4gICAgICAgIC8vIG1lYXN1cmUgcGFkZGluZyB3aXRob3V0IGFuc2kgZXNjYXBlIGNvZGVzXG4gICAgICAgIGNvbnN0IG5vQW5zaSA9IG1peGluLnN0cmlwQW5zaShzdHIpO1xuICAgICAgICByZXR1cm4gWzAsIG5vQW5zaS5tYXRjaCgvXFxzKiQvKVswXS5sZW5ndGgsIDAsIG5vQW5zaS5tYXRjaCgvXlxccyovKVswXS5sZW5ndGhdO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIHRoaXMucm93VG9TdHJpbmcocm93LCBsaW5lcyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBkb24ndCBkaXNwbGF5IGFueSBsaW5lcyB3aXRoIHRoZVxuICAgICAgICAvLyBoaWRkZW4gZmxhZyBzZXQuXG4gICAgICAgIHJldHVybiBsaW5lc1xuICAgICAgICAgICAgLmZpbHRlcihsaW5lID0+ICFsaW5lLmhpZGRlbilcbiAgICAgICAgICAgIC5tYXAobGluZSA9PiBsaW5lLnRleHQpXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgfVxuICAgIHJvd1RvU3RyaW5nKHJvdywgbGluZXMpIHtcbiAgICAgICAgdGhpcy5yYXN0ZXJpemUocm93KS5mb3JFYWNoKChycm93LCByKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RyID0gJyc7XG4gICAgICAgICAgICBycm93LmZvckVhY2goKGNvbCwgYykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IHJvd1tjXTsgLy8gdGhlIHdpZHRoIHdpdGggcGFkZGluZy5cbiAgICAgICAgICAgICAgICBjb25zdCB3cmFwV2lkdGggPSB0aGlzLm5lZ2F0ZVBhZGRpbmcocm93W2NdKTsgLy8gdGhlIHdpZHRoIHdpdGhvdXQgcGFkZGluZy5cbiAgICAgICAgICAgICAgICBsZXQgdHMgPSBjb2w7IC8vIHRlbXBvcmFyeSBzdHJpbmcgdXNlZCBkdXJpbmcgYWxpZ25tZW50L3BhZGRpbmcuXG4gICAgICAgICAgICAgICAgaWYgKHdyYXBXaWR0aCA+IG1peGluLnN0cmluZ1dpZHRoKGNvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHMgKz0gJyAnLnJlcGVhdCh3cmFwV2lkdGggLSBtaXhpbi5zdHJpbmdXaWR0aChjb2wpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWxpZ24gdGhlIHN0cmluZyB3aXRoaW4gaXRzIGNvbHVtbi5cbiAgICAgICAgICAgICAgICBpZiAocm93W2NdLmFsaWduICYmIHJvd1tjXS5hbGlnbiAhPT0gJ2xlZnQnICYmIHRoaXMud3JhcCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbiA9IGFsaWduW3Jvd1tjXS5hbGlnbl07XG4gICAgICAgICAgICAgICAgICAgIHRzID0gZm4odHMsIHdyYXBXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaXhpbi5zdHJpbmdXaWR0aCh0cykgPCB3cmFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRzICs9ICcgJy5yZXBlYXQoKHdpZHRoIHx8IDApIC0gbWl4aW4uc3RyaW5nV2lkdGgodHMpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgYm9yZGVyIGFuZCBwYWRkaW5nIHRvIHN0cmluZy5cbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gcm93W2NdLnBhZGRpbmcgfHwgWzAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nW2xlZnRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAnICcucmVwZWF0KHBhZGRpbmdbbGVmdF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHIgKz0gYWRkQm9yZGVyKHJvd1tjXSwgdHMsICd8ICcpO1xuICAgICAgICAgICAgICAgIHN0ciArPSB0cztcbiAgICAgICAgICAgICAgICBzdHIgKz0gYWRkQm9yZGVyKHJvd1tjXSwgdHMsICcgfCcpO1xuICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nW3JpZ2h0XSkge1xuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJyAnLnJlcGVhdChwYWRkaW5nW3JpZ2h0XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHByaW9yIHJvdyBpcyBzcGFuLCB0cnkgdG8gcmVuZGVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgcm93IG9uIHRoZSBwcmlvciBsaW5lLlxuICAgICAgICAgICAgICAgIGlmIChyID09PSAwICYmIGxpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gdGhpcy5yZW5kZXJJbmxpbmUoc3RyLCBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIGxpbmVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRleHQ6IHN0ci5yZXBsYWNlKC8gKyQvLCAnJyksXG4gICAgICAgICAgICAgICAgc3Bhbjogcm93LnNwYW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgZnVsbCAnc291cmNlJyBjYW4gcmVuZGVyIGluXG4gICAgLy8gdGhlIHRhcmdldCBsaW5lLCBkbyBzby5cbiAgICByZW5kZXJJbmxpbmUoc291cmNlLCBwcmV2aW91c0xpbmUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBzb3VyY2UubWF0Y2goL14gKi8pO1xuICAgICAgICBjb25zdCBsZWFkaW5nV2hpdGVzcGFjZSA9IG1hdGNoID8gbWF0Y2hbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gcHJldmlvdXNMaW5lLnRleHQ7XG4gICAgICAgIGNvbnN0IHRhcmdldFRleHRXaWR0aCA9IG1peGluLnN0cmluZ1dpZHRoKHRhcmdldC50cmltUmlnaHQoKSk7XG4gICAgICAgIGlmICghcHJldmlvdXNMaW5lLnNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UncmUgbm90IGFwcGx5aW5nIHdyYXBwaW5nIGxvZ2ljLFxuICAgICAgICAvLyBqdXN0IGFsd2F5cyBhcHBlbmQgdG8gdGhlIHNwYW4uXG4gICAgICAgIGlmICghdGhpcy53cmFwKSB7XG4gICAgICAgICAgICBwcmV2aW91c0xpbmUuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQgKyBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlIDwgdGFyZ2V0VGV4dFdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTGluZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGFyZ2V0LnRyaW1SaWdodCgpICsgJyAnLnJlcGVhdChsZWFkaW5nV2hpdGVzcGFjZSAtIHRhcmdldFRleHRXaWR0aCkgKyBzb3VyY2UudHJpbUxlZnQoKTtcbiAgICB9XG4gICAgcmFzdGVyaXplKHJvdykge1xuICAgICAgICBjb25zdCBycm93cyA9IFtdO1xuICAgICAgICBjb25zdCB3aWR0aHMgPSB0aGlzLmNvbHVtbldpZHRocyhyb3cpO1xuICAgICAgICBsZXQgd3JhcHBlZDtcbiAgICAgICAgLy8gd29yZCB3cmFwIGFsbCBjb2x1bW5zLCBhbmQgY3JlYXRlXG4gICAgICAgIC8vIGEgZGF0YS1zdHJ1Y3R1cmUgdGhhdCBpcyBlYXN5IHRvIHJhc3Rlcml6ZS5cbiAgICAgICAgcm93LmZvckVhY2goKGNvbCwgYykgPT4ge1xuICAgICAgICAgICAgLy8gbGVhdmUgcm9vbSBmb3IgbGVmdCBhbmQgcmlnaHQgcGFkZGluZy5cbiAgICAgICAgICAgIGNvbC53aWR0aCA9IHdpZHRoc1tjXTtcbiAgICAgICAgICAgIGlmICh0aGlzLndyYXApIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkID0gbWl4aW4ud3JhcChjb2wudGV4dCwgdGhpcy5uZWdhdGVQYWRkaW5nKGNvbCksIHsgaGFyZDogdHJ1ZSB9KS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkID0gY29sLnRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbC5ib3JkZXIpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkLnVuc2hpZnQoJy4nICsgJy0nLnJlcGVhdCh0aGlzLm5lZ2F0ZVBhZGRpbmcoY29sKSArIDIpICsgJy4nKTtcbiAgICAgICAgICAgICAgICB3cmFwcGVkLnB1c2goXCInXCIgKyAnLScucmVwZWF0KHRoaXMubmVnYXRlUGFkZGluZyhjb2wpICsgMikgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgdG9wIGFuZCBib3R0b20gcGFkZGluZy5cbiAgICAgICAgICAgIGlmIChjb2wucGFkZGluZykge1xuICAgICAgICAgICAgICAgIHdyYXBwZWQudW5zaGlmdCguLi5uZXcgQXJyYXkoY29sLnBhZGRpbmdbdG9wXSB8fCAwKS5maWxsKCcnKSk7XG4gICAgICAgICAgICAgICAgd3JhcHBlZC5wdXNoKC4uLm5ldyBBcnJheShjb2wucGFkZGluZ1tib3R0b21dIHx8IDApLmZpbGwoJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyYXBwZWQuZm9yRWFjaCgoc3RyLCByKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFycm93c1tyXSkge1xuICAgICAgICAgICAgICAgICAgICBycm93cy5wdXNoKFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcnJvdyA9IHJyb3dzW3JdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChycm93W2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJyb3cucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnJvdy5wdXNoKHN0cik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBycm93cztcbiAgICB9XG4gICAgbmVnYXRlUGFkZGluZyhjb2wpIHtcbiAgICAgICAgbGV0IHdyYXBXaWR0aCA9IGNvbC53aWR0aCB8fCAwO1xuICAgICAgICBpZiAoY29sLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIHdyYXBXaWR0aCAtPSAoY29sLnBhZGRpbmdbbGVmdF0gfHwgMCkgKyAoY29sLnBhZGRpbmdbcmlnaHRdIHx8IDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2wuYm9yZGVyKSB7XG4gICAgICAgICAgICB3cmFwV2lkdGggLT0gNDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JhcFdpZHRoO1xuICAgIH1cbiAgICBjb2x1bW5XaWR0aHMocm93KSB7XG4gICAgICAgIGlmICghdGhpcy53cmFwKSB7XG4gICAgICAgICAgICByZXR1cm4gcm93Lm1hcChjb2wgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2wud2lkdGggfHwgbWl4aW4uc3RyaW5nV2lkdGgoY29sLnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVuc2V0ID0gcm93Lmxlbmd0aDtcbiAgICAgICAgbGV0IHJlbWFpbmluZ1dpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgLy8gY29sdW1uIHdpZHRocyBjYW4gYmUgc2V0IGluIGNvbmZpZy5cbiAgICAgICAgY29uc3Qgd2lkdGhzID0gcm93Lm1hcChjb2wgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbC53aWR0aCkge1xuICAgICAgICAgICAgICAgIHVuc2V0LS07XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nV2lkdGggLT0gY29sLndpZHRoO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2wud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gYW55IHVuc2V0IHdpZHRocyBzaG91bGQgYmUgY2FsY3VsYXRlZC5cbiAgICAgICAgY29uc3QgdW5zZXRXaWR0aCA9IHVuc2V0ID8gTWF0aC5mbG9vcihyZW1haW5pbmdXaWR0aCAvIHVuc2V0KSA6IDA7XG4gICAgICAgIHJldHVybiB3aWR0aHMubWFwKCh3LCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAodyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHVuc2V0V2lkdGgsIF9taW5XaWR0aChyb3dbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRCb3JkZXIoY29sLCB0cywgc3R5bGUpIHtcbiAgICBpZiAoY29sLmJvcmRlcikge1xuICAgICAgICBpZiAoL1suJ10tK1suJ10vLnRlc3QodHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRzLnRyaW0oKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyAgJztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuLy8gY2FsY3VsYXRlcyB0aGUgbWluaW11bSB3aWR0aCBvZlxuLy8gYSBjb2x1bW4sIGJhc2VkIG9uIHBhZGRpbmcgcHJlZmVyZW5jZXMuXG5mdW5jdGlvbiBfbWluV2lkdGgoY29sKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IGNvbC5wYWRkaW5nIHx8IFtdO1xuICAgIGNvbnN0IG1pbldpZHRoID0gMSArIChwYWRkaW5nW2xlZnRdIHx8IDApICsgKHBhZGRpbmdbcmlnaHRdIHx8IDApO1xuICAgIGlmIChjb2wuYm9yZGVyKSB7XG4gICAgICAgIHJldHVybiBtaW5XaWR0aCArIDQ7XG4gICAgfVxuICAgIHJldHVybiBtaW5XaWR0aDtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd1dpZHRoKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkZXBlbmRzIG9uIHRlcm1pbmFsICovXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnN0ZG91dCAmJiBwcm9jZXNzLnN0ZG91dC5jb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLnN0ZG91dC5jb2x1bW5zO1xuICAgIH1cbiAgICByZXR1cm4gODA7XG59XG5mdW5jdGlvbiBhbGlnblJpZ2h0KHN0ciwgd2lkdGgpIHtcbiAgICBzdHIgPSBzdHIudHJpbSgpO1xuICAgIGNvbnN0IHN0cldpZHRoID0gbWl4aW4uc3RyaW5nV2lkdGgoc3RyKTtcbiAgICBpZiAoc3RyV2lkdGggPCB3aWR0aCkge1xuICAgICAgICByZXR1cm4gJyAnLnJlcGVhdCh3aWR0aCAtIHN0cldpZHRoKSArIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGFsaWduQ2VudGVyKHN0ciwgd2lkdGgpIHtcbiAgICBzdHIgPSBzdHIudHJpbSgpO1xuICAgIGNvbnN0IHN0cldpZHRoID0gbWl4aW4uc3RyaW5nV2lkdGgoc3RyKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmIChzdHJXaWR0aCA+PSB3aWR0aCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gJyAnLnJlcGVhdCgod2lkdGggLSBzdHJXaWR0aCkgPj4gMSkgKyBzdHI7XG59XG5sZXQgbWl4aW47XG5mdW5jdGlvbiBjbGl1aShvcHRzLCBfbWl4aW4pIHtcbiAgICBtaXhpbiA9IF9taXhpbjtcbiAgICByZXR1cm4gbmV3IFVJKHtcbiAgICAgICAgd2lkdGg6IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMud2lkdGgpIHx8IGdldFdpbmRvd1dpZHRoKCksXG4gICAgICAgIHdyYXA6IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy53cmFwXG4gICAgfSk7XG59XG5cbi8vIEJvb3RzdHJhcCBjbGl1aSB3aXRoIENvbW1vbkpTIGRlcGVuZGVuY2llczpcbmNvbnN0IHN0cmluZ1dpZHRoID0gcmVxdWlyZSgnc3RyaW5nLXdpZHRoJyk7XG5jb25zdCBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG5jb25zdCB3cmFwID0gcmVxdWlyZSgnd3JhcC1hbnNpJyk7XG5mdW5jdGlvbiB1aShvcHRzKSB7XG4gICAgcmV0dXJuIGNsaXVpKG9wdHMsIHtcbiAgICAgICAgc3RyaW5nV2lkdGgsXG4gICAgICAgIHN0cmlwQW5zaSxcbiAgICAgICAgd3JhcFxuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQSxZQUFZOztBQUVaLE1BQU1BLEtBQUssR0FBRztFQUNWQyxLQUFLLEVBQUVDLFVBQVU7RUFDakJDLE1BQU0sRUFBRUM7QUFDWixDQUFDO0FBQ0QsTUFBTUMsR0FBRyxHQUFHLENBQUM7QUFDYixNQUFNSixLQUFLLEdBQUcsQ0FBQztBQUNmLE1BQU1LLE1BQU0sR0FBRyxDQUFDO0FBQ2hCLE1BQU1DLElBQUksR0FBRyxDQUFDO0FBQ2QsTUFBTUMsRUFBRSxDQUFDO0VBQ0xDLFdBQVdBLENBQUNDLElBQUksRUFBRTtJQUNkLElBQUlDLEVBQUU7SUFDTixJQUFJLENB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","map":{"version":3,"names":["align","right","alignRight","center","alignCenter","top","bottom","left","UI","constructor","opts","_a","width","wrap","rows","span","args","cols","div","resetOutput","length","shouldApplyLayoutDSL","applyLayoutDSL","map","arg","colFromString","push","test","str","split","row","leftColumnWidth","forEach","columns","mixin","stringWidth","Math","min","floor","r","i","text","trim","padding","measurePadding","undefined","noAnsi","stripAnsi","match","toString","lines","rowToString","filter","line","hidden","join","rasterize","rrow","col","c","wrapWidth","negatePadding","ts","repeat","fn","addBorder","renderInline","replace","source","previousLine","leadingWhitespace","target","targetTextWidth","trimRight","trimLeft","rrows","widths","columnWidths","wrapped","hard","border","unshift","Array","fill","unset","remainingWidth","unsetWidth","w","max","_minWidth","style","minWidth","getWindowWidth","process","stdout","strWidth","cliui","_mixin","require","ui","module","exports"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\cliui@7.0.4\\node_modules\\cliui\\build\\","sources":["index.cjs"],"sourcesContent":["'use strict';\n\nconst align = {\n    right: alignRight,\n    center: alignCenter\n};\nconst top = 0;\nconst right = 1;\nconst bottom = 2;\nconst left = 3;\nclass UI {\n    constructor(opts) {\n        var _a;\n        this.width = opts.width;\n        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;\n        this.rows = [];\n    }\n    span(...args) {\n        const cols = this.div(...args);\n        cols.span = true;\n    }\n    resetOutput() {\n        this.rows = [];\n    }\n    div(...args) {\n        if (args.length === 0) {\n            this.div('');\n        }\n        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {\n            return this.applyLayoutDSL(args[0]);\n        }\n        const cols = args.map(arg => {\n            if (typeof arg === 'string') {\n                return this.colFromString(arg);\n            }\n            return arg;\n        });\n        this.rows.push(cols);\n        return cols;\n    }\n    shouldApplyLayoutDSL(...args) {\n        return args.length === 1 && typeof args[0] === 'string' &&\n            /[\\t\\n]/.test(args[0]);\n    }\n    applyLayoutDSL(str) {\n        const rows = str.split('\\n').map(row => row.split('\\t'));\n        let leftColumnWidth = 0;\n        // simple heuristic for layout, make sure the\n        // second column lines up along the left-hand.\n        // don't allow the first column to take up more\n        // than 50% of the screen.\n        rows.forEach(columns => {\n            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {\n                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));\n            }\n        });\n        // generate a table:\n        //  replacing ' ' with padding calculations.\n        //  using the algorithmically generated width.\n        rows.forEach(columns => {\n            this.div(...columns.map((r, i) => {\n                return {\n                    text: r.trim(),\n                    padding: this.measurePadding(r),\n                    width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined\n                };\n            }));\n        });\n        return this.rows[this.rows.length - 1];\n    }\n    colFromString(text) {\n        return {\n            text,\n            padding: this.measurePadding(text)\n        };\n    }\n    measurePadding(str) {\n        // measure padding without ansi escape codes\n        const noAnsi = mixin.stripAnsi(str);\n        return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n    }\n    toString() {\n        const lines = [];\n        this.rows.forEach(row => {\n            this.rowToString(row, lines);\n        });\n        // don't display any lines with the\n        // hidden flag set.\n        return lines\n            .filter(line => !line.hidden)\n            .map(line => line.text)\n            .join('\\n');\n    }\n    rowToString(row, lines) {\n        this.rasterize(row).forEach((rrow, r) => {\n            let str = '';\n            rrow.forEach((col, c) => {\n                const { width } = row[c]; // the width with padding.\n                const wrapWidth = this.negatePadding(row[c]); // the width without padding.\n                let ts = col; // temporary string used during alignment/padding.\n                if (wrapWidth > mixin.stringWidth(col)) {\n                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));\n                }\n                // align the string within its column.\n                if (row[c].align && row[c].align !== 'left' && this.wrap) {\n                    const fn = align[row[c].align];\n                    ts = fn(ts, wrapWidth);\n                    if (mixin.stringWidth(ts) < wrapWidth) {\n                        ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);\n                    }\n                }\n                // apply border and padding to string.\n                const padding = row[c].padding || [0, 0, 0, 0];\n                if (padding[left]) {\n                    str += ' '.repeat(padding[left]);\n                }\n                str += addBorder(row[c], ts, '| ');\n                str += ts;\n                str += addBorder(row[c], ts, ' |');\n                if (padding[right]) {\n                    str += ' '.repeat(padding[right]);\n                }\n                // if prior row is span, try to render the\n                // current row on the prior line.\n                if (r === 0 && lines.length > 0) {\n                    str = this.renderInline(str, lines[lines.length - 1]);\n                }\n            });\n            // remove trailing whitespace.\n            lines.push({\n                text: str.replace(/ +$/, ''),\n                span: row.span\n            });\n        });\n        return lines;\n    }\n    // if the full 'source' can render in\n    // the target line, do so.\n    renderInline(source, previousLine) {\n        const match = source.match(/^ */);\n        const leadingWhitespace = match ? match[0].length : 0;\n        const target = previousLine.text;\n        const targetTextWidth = mixin.stringWidth(target.trimRight());\n        if (!previousLine.span) {\n            return source;\n        }\n        // if we're not applying wrapping logic,\n        // just always append to the span.\n        if (!this.wrap) {\n            previousLine.hidden = true;\n            return target + source;\n        }\n        if (leadingWhitespace < targetTextWidth) {\n            return source;\n        }\n        previousLine.hidden = true;\n        return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();\n    }\n    rasterize(row) {\n        const rrows = [];\n        const widths = this.columnWidths(row);\n        let wrapped;\n        // word wrap all columns, and create\n        // a data-structure that is easy to rasterize.\n        row.forEach((col, c) => {\n            // leave room for left and right padding.\n            col.width = widths[c];\n            if (this.wrap) {\n                wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split('\\n');\n            }\n            else {\n                wrapped = col.text.split('\\n');\n            }\n            if (col.border) {\n                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');\n                wrapped.push(\"'\" + '-'.repeat(this.negatePadding(col) + 2) + \"'\");\n            }\n            // add top and bottom padding.\n            if (col.padding) {\n                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));\n                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));\n            }\n            wrapped.forEach((str, r) => {\n                if (!rrows[r]) {\n                    rrows.push([]);\n                }\n                const rrow = rrows[r];\n                for (let i = 0; i < c; i++) {\n                    if (rrow[i] === undefined) {\n                        rrow.push('');\n                    }\n                }\n                rrow.push(str);\n            });\n        });\n        return rrows;\n    }\n    negatePadding(col) {\n        let wrapWidth = col.width || 0;\n        if (col.padding) {\n            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n        }\n        if (col.border) {\n            wrapWidth -= 4;\n        }\n        return wrapWidth;\n    }\n    columnWidths(row) {\n        if (!this.wrap) {\n            return row.map(col => {\n                return col.width || mixin.stringWidth(col.text);\n            });\n        }\n        let unset = row.length;\n        let remainingWidth = this.width;\n        // column widths can be set in config.\n        const widths = row.map(col => {\n            if (col.width) {\n                unset--;\n                remainingWidth -= col.width;\n                return col.width;\n            }\n            return undefined;\n        });\n        // any unset widths should be calculated.\n        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n        return widths.map((w, i) => {\n            if (w === undefined) {\n                return Math.max(unsetWidth, _minWidth(row[i]));\n            }\n            return w;\n        });\n    }\n}\nfunction addBorder(col, ts, style) {\n    if (col.border) {\n        if (/[.']-+[.']/.test(ts)) {\n            return '';\n        }\n        if (ts.trim().length !== 0) {\n            return style;\n        }\n        return '  ';\n    }\n    return '';\n}\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth(col) {\n    const padding = col.padding || [];\n    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n    if (col.border) {\n        return minWidth + 4;\n    }\n    return minWidth;\n}\nfunction getWindowWidth() {\n    /* istanbul ignore next: depends on terminal */\n    if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n        return process.stdout.columns;\n    }\n    return 80;\n}\nfunction alignRight(str, width) {\n    str = str.trim();\n    const strWidth = mixin.stringWidth(str);\n    if (strWidth < width) {\n        return ' '.repeat(width - strWidth) + str;\n    }\n    return str;\n}\nfunction alignCenter(str, width) {\n    str = str.trim();\n    const strWidth = mixin.stringWidth(str);\n    /* istanbul ignore next */\n    if (strWidth >= width) {\n        return str;\n    }\n    return ' '.repeat((width - strWidth) >> 1) + str;\n}\nlet mixin;\nfunction cliui(opts, _mixin) {\n    mixin = _mixin;\n    return new UI({\n        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),\n        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap\n    });\n}\n\n// Bootstrap cliui with CommonJS dependencies:\nconst stringWidth = require('string-width');\nconst stripAnsi = require('strip-ansi');\nconst wrap = require('wrap-ansi');\nfunction ui(opts) {\n    return cliui(opts, {\n        stringWidth,\n        stripAnsi,\n        wrap\n    });\n}\n\nmodule.exports = ui;\n"],"mappings":"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"}},"mtime":1674865351343},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\string-width@4.2.3\\\\node_modules\\\\string-width\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\string-width@4.2.3\\\\node_modules\\\\string-width\\\\index.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"'use strict';\n\nconst stripAnsi = require('strip-ansi');\nconst isFullwidthCodePoint = require('is-fullwidth-code-point');\nconst emojiRegex = require('emoji-regex');\nconst stringWidth = string => {\n  if (typeof string !== 'string' || string.length === 0) {\n    return 0;\n  }\n  string = stripAnsi(string);\n  if (string.length === 0) {\n    return 0;\n  }\n  string = string.replace(emojiRegex(), '  ');\n  let width = 0;\n  for (let i = 0; i < string.length; i++) {\n    const code = string.codePointAt(i);\n\n    // Ignore control characters\n    if (code <= 0x1F || code >= 0x7F && code <= 0x9F) {\n      continue;\n    }\n\n    // Ignore combining characters\n    if (code >= 0x300 && code <= 0x36F) {\n      continue;\n    }\n\n    // Surrogates\n    if (code > 0xFFFF) {\n      i++;\n    }\n    width += isFullwidthCodePoint(code) ? 2 : 1;\n  }\n  return width;\n};\nmodule.exports = stringWidth;\n// TODO: remove this in the next major version\nmodule.exports.default = stringWidth;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJzdHJpcEFuc2kiLCJyZXF1aXJlIiwiaXNGdWxsd2lkdGhDb2RlUG9pbnQiLCJlbW9qaVJlZ2V4Iiwic3RyaW5nV2lkdGgiLCJzdHJpbmciLCJsZW5ndGgiLCJyZXBsYWNlIiwid2lkdGgiLCJpIiwiY29kZSIsImNvZGVQb2ludEF0IiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IkM6XFxjb2RlXFxGbHVpZEZyYW1ld29yazVcXG5vZGVfbW9kdWxlc1xcLnBucG1cXHN0cmluZy13aWR0aEA0LjIuM1xcbm9kZV9tb2R1bGVzXFxzdHJpbmctd2lkdGhcXCIsInNvdXJjZXMiOlsiaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgc3RyaXBBbnNpID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpO1xuY29uc3QgaXNGdWxsd2lkdGhDb2RlUG9pbnQgPSByZXF1aXJlKCdpcy1mdWxsd2lkdGgtY29kZS1wb2ludCcpO1xuY29uc3QgZW1vamlSZWdleCA9IHJlcXVpcmUoJ2Vtb2ppLXJlZ2V4Jyk7XG5cbmNvbnN0IHN0cmluZ1dpZHRoID0gc3RyaW5nID0+IHtcblx0aWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnIHx8IHN0cmluZy5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdHN0cmluZyA9IHN0cmlwQW5zaShzdHJpbmcpO1xuXG5cdGlmIChzdHJpbmcubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShlbW9qaVJlZ2V4KCksICcgICcpO1xuXG5cdGxldCB3aWR0aCA9IDA7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBjb2RlID0gc3RyaW5nLmNvZGVQb2ludEF0KGkpO1xuXG5cdFx0Ly8gSWdub3JlIGNvbnRyb2wgY2hhcmFjdGVyc1xuXHRcdGlmIChjb2RlIDw9IDB4MUYgfHwgKGNvZGUgPj0gMHg3RiAmJiBjb2RlIDw9IDB4OUYpKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHQvLyBJZ25vcmUgY29tYmluaW5nIGNoYXJhY3RlcnNcblx0XHRpZiAoY29kZSA+PSAweDMwMCAmJiBjb2RlIDw9IDB4MzZGKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHQvLyBTdXJyb2dhdGVzXG5cdFx0aWYgKGNvZGUgPiAweEZGRkYpIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHR3aWR0aCArPSBpc0Z1bGx3aWR0aENvZGVQb2ludChjb2RlKSA/IDIgOiAxO1xuXHR9XG5cblx0cmV0dXJuIHdpZHRoO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdXaWR0aDtcbi8vIFRPRE86IHJlbW92ZSB0aGlzIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBzdHJpbmdXaWR0aDtcbiJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFDWixNQUFNQSxTQUFTLEdBQUdDLE9BQU8sQ0FBQyxZQUFZLENBQUM7QUFDdkMsTUFBTUMsb0JBQW9CLEdBQUdELE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQztBQUMvRCxNQUFNRSxVQUFVLEdBQUdGLE9BQU8sQ0FBQyxhQUFhLENBQUM7QUFFekMsTUFBTUcsV0FBVyxHQUFHQyxNQUFNLElBQUk7RUFDN0IsSUFBSSxPQUFPQSxNQUFNLEtBQUssUUFBUSxJQUFJQSxNQUFNLENBQUNDLE1BQU0sS0FBSyxDQUFDLEVBQUU7SUFDdEQsT0FBTyxDQUFDO0VBQ1Q7RUFFQUQsTUFBTSxHQUFHTCxTQUFTLENBQUNLLE1BQU0sQ0FBQztFQUUxQixJQUFJQSxNQUFNLENBQUNDLE1BQU0sS0FBSyxDQUFDLEVBQUU7SUFDeEIsT0FBTyxDQUFDO0VBQ1Q7RUFFQUQsTUFBTSxHQUFHQSxNQUFNLENBQUNFLE9BQU8sQ0FBQ0osVUFBVSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM7RUFFM0MsSUFBSUssS0FBSyxHQUFHLENBQUM7RUFFYixLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0osTUFBTSxDQUFDQyxNQUFNLEVBQUVHLENBQUMsRUFBRSxFQUFFO0lBQ3ZDLE1BQU1DLElBQUksR0FBR0wsTUFBTSxDQUFDTSxXQUFXLENBQUNGLENBQUMsQ0FBQzs7SUFFbEM7SUFDQSxJQUFJQyxJQUFJLElBQUksSUFBSSxJQUFLQSxJQUFJLElBQUksSUFBSSxJQUFJQSxJQUFJLElBQUksSUFBSyxFQUFFO01BQ25EO0lBQ0Q7O0lBRUE7SUFDQSxJQUFJQSxJQUFJLElBQUksS0FBSyxJQUFJQSxJQUFJLElBQUksS0FBSyxFQUFFO01BQ25DO0lBQ0Q7O0lBRUE7SUFDQSxJQUFJQSxJQUFJLEdBQUcsTUFBTSxFQUFFO01BQ2xCRCxDQUFDLEVBQUU7SUFDSjtJQUVBRCxLQUFLLElBQUlOLG9CQUFvQixDQUFDUSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztFQUM1QztFQUVBLE9BQU9GLEtBQUs7QUFDYixDQUFDO0FBRURJLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHVCxXQUFXO0FBQzVCO0FBQ0FRLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDQyxPQUFPLEdBQUdWLFdBQVcifQ==","map":{"version":3,"names":["stripAnsi","require","isFullwidthCodePoint","emojiRegex","stringWidth","string","length","replace","width","i","code","codePointAt","module","exports","default"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\string-width@4.2.3\\node_modules\\string-width\\","sources":["index.js"],"sourcesContent":["'use strict';\nconst stripAnsi = require('strip-ansi');\nconst isFullwidthCodePoint = require('is-fullwidth-code-point');\nconst emojiRegex = require('emoji-regex');\n\nconst stringWidth = string => {\n\tif (typeof string !== 'string' || string.length === 0) {\n\t\treturn 0;\n\t}\n\n\tstring = stripAnsi(string);\n\n\tif (string.length === 0) {\n\t\treturn 0;\n\t}\n\n\tstring = string.replace(emojiRegex(), '  ');\n\n\tlet width = 0;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tconst code = string.codePointAt(i);\n\n\t\t// Ignore control characters\n\t\tif (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Ignore combining characters\n\t\tif (code >= 0x300 && code <= 0x36F) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Surrogates\n\t\tif (code > 0xFFFF) {\n\t\t\ti++;\n\t\t}\n\n\t\twidth += isFullwidthCodePoint(code) ? 2 : 1;\n\t}\n\n\treturn width;\n};\n\nmodule.exports = stringWidth;\n// TODO: remove this in the next major version\nmodule.exports.default = stringWidth;\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,SAAS,GAAGC,OAAO,CAAC,YAAY,CAAC;AACvC,MAAMC,oBAAoB,GAAGD,OAAO,CAAC,yBAAyB,CAAC;AAC/D,MAAME,UAAU,GAAGF,OAAO,CAAC,aAAa,CAAC;AAEzC,MAAMG,WAAW,GAAGC,MAAM,IAAI;EAC7B,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAIA,MAAM,CAACC,MAAM,KAAK,CAAC,EAAE;IACtD,OAAO,CAAC;EACT;EAEAD,MAAM,GAAGL,SAAS,CAACK,MAAM,CAAC;EAE1B,IAAIA,MAAM,CAACC,MAAM,KAAK,CAAC,EAAE;IACxB,OAAO,CAAC;EACT;EAEAD,MAAM,GAAGA,MAAM,CAACE,OAAO,CAACJ,UAAU,CAAC,CAAC,EAAE,IAAI,CAAC;EAE3C,IAAIK,KAAK,GAAG,CAAC;EAEb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,CAACC,MAAM,EAAEG,CAAC,EAAE,EAAE;IACvC,MAAMC,IAAI,GAAGL,MAAM,CAACM,WAAW,CAACF,CAAC,CAAC;;IAElC;IACA,IAAIC,IAAI,IAAI,IAAI,IAAKA,IAAI,IAAI,IAAI,IAAIA,IAAI,IAAI,IAAK,EAAE;MACnD;IACD;;IAEA;IACA,IAAIA,IAAI,IAAI,KAAK,IAAIA,IAAI,IAAI,KAAK,EAAE;MACnC;IACD;;IAEA;IACA,IAAIA,IAAI,GAAG,MAAM,EAAE;MAClBD,CAAC,EAAE;IACJ;IAEAD,KAAK,IAAIN,oBAAoB,CAACQ,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;EAC5C;EAEA,OAAOF,KAAK;AACb,CAAC;AAEDI,MAAM,CAACC,OAAO,GAAGT,WAAW;AAC5B;AACAQ,MAAM,CAACC,OAAO,CAACC,OAAO,GAAGV,WAAW"}},"mtime":1674865335182},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\strip-ansi@6.0.1\\\\node_modules\\\\strip-ansi\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\strip-ansi@6.0.1\\\\node_modules\\\\strip-ansi\\\\index.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"'use strict';\n\nconst ansiRegex = require('ansi-regex');\nmodule.exports = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJhbnNpUmVnZXgiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsInN0cmluZyIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IkM6XFxjb2RlXFxGbHVpZEZyYW1ld29yazVcXG5vZGVfbW9kdWxlc1xcLnBucG1cXHN0cmlwLWFuc2lANi4wLjFcXG5vZGVfbW9kdWxlc1xcc3RyaXAtYW5zaVxcIiwic291cmNlcyI6WyJpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nID0+IHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnID8gc3RyaW5nLnJlcGxhY2UoYW5zaVJlZ2V4KCksICcnKSA6IHN0cmluZztcbiJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFDWixNQUFNQSxTQUFTLEdBQUdDLE9BQU8sQ0FBQyxZQUFZLENBQUM7QUFFdkNDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHQyxNQUFNLElBQUksT0FBT0EsTUFBTSxLQUFLLFFBQVEsR0FBR0EsTUFBTSxDQUFDQyxPQUFPLENBQUNMLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUdJLE1BQU0ifQ==","map":{"version":3,"names":["ansiRegex","require","module","exports","string","replace"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\strip-ansi@6.0.1\\node_modules\\strip-ansi\\","sources":["index.js"],"sourcesContent":["'use strict';\nconst ansiRegex = require('ansi-regex');\n\nmodule.exports = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,SAAS,GAAGC,OAAO,CAAC,YAAY,CAAC;AAEvCC,MAAM,CAACC,OAAO,GAAGC,MAAM,IAAI,OAAOA,MAAM,KAAK,QAAQ,GAAGA,MAAM,CAACC,OAAO,CAACL,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,GAAGI,MAAM"}},"mtime":1674865295531},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\ansi-regex@5.0.1\\\\node_modules\\\\ansi-regex\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\ansi-regex@5.0.1\\\\node_modules\\\\ansi-regex\\\\index.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"'use strict';\n\nmodule.exports = ({\n  onlyFirst = false\n} = {}) => {\n  const pattern = ['[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)', '(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'].join('|');\n  return new RegExp(pattern, onlyFirst ? undefined : 'g');\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwib25seUZpcnN0IiwicGF0dGVybiIsImpvaW4iLCJSZWdFeHAiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IkM6XFxjb2RlXFxGbHVpZEZyYW1ld29yazVcXG5vZGVfbW9kdWxlc1xcLnBucG1cXGFuc2ktcmVnZXhANS4wLjFcXG5vZGVfbW9kdWxlc1xcYW5zaS1yZWdleFxcIiwic291cmNlcyI6WyJpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKHtvbmx5Rmlyc3QgPSBmYWxzZX0gPSB7fSkgPT4ge1xuXHRjb25zdCBwYXR0ZXJuID0gW1xuXHRcdCdbXFxcXHUwMDFCXFxcXHUwMDlCXVtbXFxcXF0oKSM7P10qKD86KD86KD86KD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKykqfFthLXpBLVpcXFxcZF0rKD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKikqKT9cXFxcdTAwMDcpJyxcblx0XHQnKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSknXG5cdF0uam9pbignfCcpO1xuXG5cdHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIG9ubHlGaXJzdCA/IHVuZGVmaW5lZCA6ICdnJyk7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQSxZQUFZOztBQUVaQSxNQUFNLENBQUNDLE9BQU8sR0FBRyxDQUFDO0VBQUNDLFNBQVMsR0FBRztBQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSztFQUM5QyxNQUFNQyxPQUFPLEdBQUcsQ0FDZiw4SEFBOEgsRUFDOUgsMERBQTBELENBQzFELENBQUNDLElBQUksQ0FBQyxHQUFHLENBQUM7RUFFWCxPQUFPLElBQUlDLE1BQU0sQ0FBQ0YsT0FBTyxFQUFFRCxTQUFTLEdBQUdJLFNBQVMsR0FBRyxHQUFHLENBQUM7QUFDeEQsQ0FBQyJ9","map":{"version":3,"names":["module","exports","onlyFirst","pattern","join","RegExp","undefined"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\ansi-regex@5.0.1\\node_modules\\ansi-regex\\","sources":["index.js"],"sourcesContent":["'use strict';\n\nmodule.exports = ({onlyFirst = false} = {}) => {\n\tconst pattern = [\n\t\t'[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, onlyFirst ? undefined : 'g');\n};\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,OAAO,GAAG,CAAC;EAACC,SAAS,GAAG;AAAK,CAAC,GAAG,CAAC,CAAC,KAAK;EAC9C,MAAMC,OAAO,GAAG,CACf,8HAA8H,EAC9H,0DAA0D,CAC1D,CAACC,IAAI,CAAC,GAAG,CAAC;EAEX,OAAO,IAAIC,MAAM,CAACF,OAAO,EAAED,SAAS,GAAGI,SAAS,GAAG,GAAG,CAAC;AACxD,CAAC"}},"mtime":1674865316498},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\is-fullwidth-code-point@3.0.0\\\\node_modules\\\\is-fullwidth-code-point\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\is-fullwidth-code-point@3.0.0\\\\node_modules\\\\is-fullwidth-code-point\\\\index.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"/* eslint-disable yoda */\n'use strict';\n\nconst isFullwidthCodePoint = codePoint => {\n  if (Number.isNaN(codePoint)) {\n    return false;\n  }\n\n  // Code points are derived from:\n  // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt\n  if (codePoint >= 0x1100 && (codePoint <= 0x115F ||\n  // Hangul Jamo\n  codePoint === 0x2329 ||\n  // LEFT-POINTING ANGLE BRACKET\n  codePoint === 0x232A ||\n  // RIGHT-POINTING ANGLE BRACKET\n  // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n  0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F ||\n  // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n  0x3250 <= codePoint && codePoint <= 0x4DBF ||\n  // CJK Unified Ideographs .. Yi Radicals\n  0x4E00 <= codePoint && codePoint <= 0xA4C6 ||\n  // Hangul Jamo Extended-A\n  0xA960 <= codePoint && codePoint <= 0xA97C ||\n  // Hangul Syllables\n  0xAC00 <= codePoint && codePoint <= 0xD7A3 ||\n  // CJK Compatibility Ideographs\n  0xF900 <= codePoint && codePoint <= 0xFAFF ||\n  // Vertical Forms\n  0xFE10 <= codePoint && codePoint <= 0xFE19 ||\n  // CJK Compatibility Forms .. Small Form Variants\n  0xFE30 <= codePoint && codePoint <= 0xFE6B ||\n  // Halfwidth and Fullwidth Forms\n  0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 ||\n  // Kana Supplement\n  0x1B000 <= codePoint && codePoint <= 0x1B001 ||\n  // Enclosed Ideographic Supplement\n  0x1F200 <= codePoint && codePoint <= 0x1F251 ||\n  // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n  0x20000 <= codePoint && codePoint <= 0x3FFFD)) {\n    return true;\n  }\n  return false;\n};\nmodule.exports = isFullwidthCodePoint;\nmodule.exports.default = isFullwidthCodePoint;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpc0Z1bGx3aWR0aENvZGVQb2ludCIsImNvZGVQb2ludCIsIk51bWJlciIsImlzTmFOIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IkM6XFxjb2RlXFxGbHVpZEZyYW1ld29yazVcXG5vZGVfbW9kdWxlc1xcLnBucG1cXGlzLWZ1bGx3aWR0aC1jb2RlLXBvaW50QDMuMC4wXFxub2RlX21vZHVsZXNcXGlzLWZ1bGx3aWR0aC1jb2RlLXBvaW50XFwiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIHlvZGEgKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNGdWxsd2lkdGhDb2RlUG9pbnQgPSBjb2RlUG9pbnQgPT4ge1xuXHRpZiAoTnVtYmVyLmlzTmFOKGNvZGVQb2ludCkpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBDb2RlIHBvaW50cyBhcmUgZGVyaXZlZCBmcm9tOlxuXHQvLyBodHRwOi8vd3d3LnVuaXgub3JnL1B1YmxpYy9VTklEQVRBL0Vhc3RBc2lhbldpZHRoLnR4dFxuXHRpZiAoXG5cdFx0Y29kZVBvaW50ID49IDB4MTEwMCAmJiAoXG5cdFx0XHRjb2RlUG9pbnQgPD0gMHgxMTVGIHx8IC8vIEhhbmd1bCBKYW1vXG5cdFx0XHRjb2RlUG9pbnQgPT09IDB4MjMyOSB8fCAvLyBMRUZULVBPSU5USU5HIEFOR0xFIEJSQUNLRVRcblx0XHRcdGNvZGVQb2ludCA9PT0gMHgyMzJBIHx8IC8vIFJJR0hULVBPSU5USU5HIEFOR0xFIEJSQUNLRVRcblx0XHRcdC8vIENKSyBSYWRpY2FscyBTdXBwbGVtZW50IC4uIEVuY2xvc2VkIENKSyBMZXR0ZXJzIGFuZCBNb250aHNcblx0XHRcdCgweDJFODAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweDMyNDcgJiYgY29kZVBvaW50ICE9PSAweDMwM0YpIHx8XG5cdFx0XHQvLyBFbmNsb3NlZCBDSksgTGV0dGVycyBhbmQgTW9udGhzIC4uIENKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEFcblx0XHRcdCgweDMyNTAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweDREQkYpIHx8XG5cdFx0XHQvLyBDSksgVW5pZmllZCBJZGVvZ3JhcGhzIC4uIFlpIFJhZGljYWxzXG5cdFx0XHQoMHg0RTAwIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHhBNEM2KSB8fFxuXHRcdFx0Ly8gSGFuZ3VsIEphbW8gRXh0ZW5kZWQtQVxuXHRcdFx0KDB4QTk2MCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4QTk3QykgfHxcblx0XHRcdC8vIEhhbmd1bCBTeWxsYWJsZXNcblx0XHRcdCgweEFDMDAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweEQ3QTMpIHx8XG5cdFx0XHQvLyBDSksgQ29tcGF0aWJpbGl0eSBJZGVvZ3JhcGhzXG5cdFx0XHQoMHhGOTAwIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHhGQUZGKSB8fFxuXHRcdFx0Ly8gVmVydGljYWwgRm9ybXNcblx0XHRcdCgweEZFMTAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweEZFMTkpIHx8XG5cdFx0XHQvLyBDSksgQ29tcGF0aWJpbGl0eSBGb3JtcyAuLiBTbWFsbCBGb3JtIFZhcmlhbnRzXG5cdFx0XHQoMHhGRTMwIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHhGRTZCKSB8fFxuXHRcdFx0Ly8gSGFsZndpZHRoIGFuZCBGdWxsd2lkdGggRm9ybXNcblx0XHRcdCgweEZGMDEgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweEZGNjApIHx8XG5cdFx0XHQoMHhGRkUwIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHhGRkU2KSB8fFxuXHRcdFx0Ly8gS2FuYSBTdXBwbGVtZW50XG5cdFx0XHQoMHgxQjAwMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4MUIwMDEpIHx8XG5cdFx0XHQvLyBFbmNsb3NlZCBJZGVvZ3JhcGhpYyBTdXBwbGVtZW50XG5cdFx0XHQoMHgxRjIwMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4MUYyNTEpIHx8XG5cdFx0XHQvLyBDSksgVW5pZmllZCBJZGVvZ3JhcGhzIEV4dGVuc2lvbiBCIC4uIFRlcnRpYXJ5IElkZW9ncmFwaGljIFBsYW5lXG5cdFx0XHQoMHgyMDAwMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4M0ZGRkQpXG5cdFx0KVxuXHQpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdWxsd2lkdGhDb2RlUG9pbnQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gaXNGdWxsd2lkdGhDb2RlUG9pbnQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWTs7QUFFWixNQUFNQSxvQkFBb0IsR0FBR0MsU0FBUyxJQUFJO0VBQ3pDLElBQUlDLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDRixTQUFTLENBQUMsRUFBRTtJQUM1QixPQUFPLEtBQUs7RUFDYjs7RUFFQTtFQUNBO0VBQ0EsSUFDQ0EsU0FBUyxJQUFJLE1BQU0sS0FDbEJBLFNBQVMsSUFBSSxNQUFNO0VBQUk7RUFDdkJBLFNBQVMsS0FBSyxNQUFNO0VBQUk7RUFDeEJBLFNBQVMsS0FBSyxNQUFNO0VBQUk7RUFDeEI7RUFDQyxNQUFNLElBQUlBLFNBQVMsSUFBSUEsU0FBUyxJQUFJLE1BQU0sSUFBSUEsU0FBUyxLQUFLLE1BQU87RUFDcEU7RUFDQyxNQUFNLElBQUlBLFNBQVMsSUFBSUEsU0FBUyxJQUFJLE1BQU87RUFDNUM7RUFDQyxNQUFNLElBQUlBLFNBQVMsSUFBSUEsU0FBUyxJQUFJLE1BQU87RUFDNUM7RUFDQyxNQUFNLElBQUlBLFNBQVMsSUFBSUEsU0FBUyxJQUFJLE1BQU87RUFDNUM7RUFDQyxNQUFNLElBQUlBLFNBQVMsSUFBSUEsU0FBUyxJQUFJLE1BQU87RUFDNUM7RUFDQyxNQUFNLElBQUlBLFNBQVMsSUFBSUEsU0FBUyxJQUFJLE1BQU87RUFDNUM7RUFDQyxNQUFNLElBQUlBLFNBQVMsSUFBSUEsU0FBUyxJQUFJLE1BQU87RUFDNUM7RUFDQyxNQUFNLElBQUlBLFNBQVMsSUFBSUEsU0FBUyxJQUFJLE1BQU87RUFDNUM7RUFDQyxNQUFNLElBQUlBLFNBQVMsSUFBSUEsU0FBUyxJQUFJLE1BQU8sSUFDM0MsTUFBTSxJQUFJQSxTQUFTLElBQUlBLFNBQVMsSUFBSSxNQUFPO0VBQzVDO0VBQ0MsT0FBTyxJQUFJQSxTQUFTLElBQUlBLFNBQVMsSUFBSSxPQUFRO0VBQzlDO0VBQ0MsT0FBTyxJQUFJQSxTQUFTLElBQUlBLFNBQVMsSUFBSSxPQUFRO0VBQzlDO0VBQ0MsT0FBTyxJQUFJQSxTQUFTLElBQUlBLFNBQVMsSUFBSSxPQUFRLENBQzlDLEVBQ0E7SUFDRCxPQUFPLElBQUk7RUFDWjtFQUVBLE9BQU8sS0FBSztBQUNiLENBQUM7QUFFREcsTUFBTSxDQUFDQyxPQUFPLEdBQUdMLG9CQUFvQjtBQUNyQ0ksTUFBTSxDQUFDQyxPQUFPLENBQUNDLE9BQU8sR0FBR04sb0JBQW9CIn0=","map":{"version":3,"names":["isFullwidthCodePoint","codePoint","Number","isNaN","module","exports","default"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\is-fullwidth-code-point@3.0.0\\node_modules\\is-fullwidth-code-point\\","sources":["index.js"],"sourcesContent":["/* eslint-disable yoda */\n'use strict';\n\nconst isFullwidthCodePoint = codePoint => {\n\tif (Number.isNaN(codePoint)) {\n\t\treturn false;\n\t}\n\n\t// Code points are derived from:\n\t// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt\n\tif (\n\t\tcodePoint >= 0x1100 && (\n\t\t\tcodePoint <= 0x115F || // Hangul Jamo\n\t\t\tcodePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n\t\t\tcodePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET\n\t\t\t// CJK Radicals Supplement .. Enclosed CJK Letters and Months\n\t\t\t(0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F) ||\n\t\t\t// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n\t\t\t(0x3250 <= codePoint && codePoint <= 0x4DBF) ||\n\t\t\t// CJK Unified Ideographs .. Yi Radicals\n\t\t\t(0x4E00 <= codePoint && codePoint <= 0xA4C6) ||\n\t\t\t// Hangul Jamo Extended-A\n\t\t\t(0xA960 <= codePoint && codePoint <= 0xA97C) ||\n\t\t\t// Hangul Syllables\n\t\t\t(0xAC00 <= codePoint && codePoint <= 0xD7A3) ||\n\t\t\t// CJK Compatibility Ideographs\n\t\t\t(0xF900 <= codePoint && codePoint <= 0xFAFF) ||\n\t\t\t// Vertical Forms\n\t\t\t(0xFE10 <= codePoint && codePoint <= 0xFE19) ||\n\t\t\t// CJK Compatibility Forms .. Small Form Variants\n\t\t\t(0xFE30 <= codePoint && codePoint <= 0xFE6B) ||\n\t\t\t// Halfwidth and Fullwidth Forms\n\t\t\t(0xFF01 <= codePoint && codePoint <= 0xFF60) ||\n\t\t\t(0xFFE0 <= codePoint && codePoint <= 0xFFE6) ||\n\t\t\t// Kana Supplement\n\t\t\t(0x1B000 <= codePoint && codePoint <= 0x1B001) ||\n\t\t\t// Enclosed Ideographic Supplement\n\t\t\t(0x1F200 <= codePoint && codePoint <= 0x1F251) ||\n\t\t\t// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n\t\t\t(0x20000 <= codePoint && codePoint <= 0x3FFFD)\n\t\t)\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nmodule.exports = isFullwidthCodePoint;\nmodule.exports.default = isFullwidthCodePoint;\n"],"mappings":"AAAA;AACA,YAAY;;AAEZ,MAAMA,oBAAoB,GAAGC,SAAS,IAAI;EACzC,IAAIC,MAAM,CAACC,KAAK,CAACF,SAAS,CAAC,EAAE;IAC5B,OAAO,KAAK;EACb;;EAEA;EACA;EACA,IACCA,SAAS,IAAI,MAAM,KAClBA,SAAS,IAAI,MAAM;EAAI;EACvBA,SAAS,KAAK,MAAM;EAAI;EACxBA,SAAS,KAAK,MAAM;EAAI;EACxB;EACC,MAAM,IAAIA,SAAS,IAAIA,SAAS,IAAI,MAAM,IAAIA,SAAS,KAAK,MAAO;EACpE;EACC,MAAM,IAAIA,SAAS,IAAIA,SAAS,IAAI,MAAO;EAC5C;EACC,MAAM,IAAIA,SAAS,IAAIA,SAAS,IAAI,MAAO;EAC5C;EACC,MAAM,IAAIA,SAAS,IAAIA,SAAS,IAAI,MAAO;EAC5C;EACC,MAAM,IAAIA,SAAS,IAAIA,SAAS,IAAI,MAAO;EAC5C;EACC,MAAM,IAAIA,SAAS,IAAIA,SAAS,IAAI,MAAO;EAC5C;EACC,MAAM,IAAIA,SAAS,IAAIA,SAAS,IAAI,MAAO;EAC5C;EACC,MAAM,IAAIA,SAAS,IAAIA,SAAS,IAAI,MAAO;EAC5C;EACC,MAAM,IAAIA,SAAS,IAAIA,SAAS,IAAI,MAAO,IAC3C,MAAM,IAAIA,SAAS,IAAIA,SAAS,IAAI,MAAO;EAC5C;EACC,OAAO,IAAIA,SAAS,IAAIA,SAAS,IAAI,OAAQ;EAC9C;EACC,OAAO,IAAIA,SAAS,IAAIA,SAAS,IAAI,OAAQ;EAC9C;EACC,OAAO,IAAIA,SAAS,IAAIA,SAAS,IAAI,OAAQ,CAC9C,EACA;IACD,OAAO,IAAI;EACZ;EAEA,OAAO,KAAK;AACb,CAAC;AAEDG,MAAM,CAACC,OAAO,GAAGL,oBAAoB;AACrCI,MAAM,CAACC,OAAO,CAACC,OAAO,GAAGN,oBAAoB"}},"mtime":1674865348272},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\emoji-regex@8.0.0\\\\node_modules\\\\emoji-regex\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\emoji-regex@8.0.0\\\\node_modules\\\\emoji-regex\\\\index.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"\"use strict\";\n\nmodule.exports = function () {\n  // https://mths.be/emoji\n  return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C\\uDFFB|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83D[\\uDC66\\uDC67]|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)\\uD83C\\uDFFB|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83D\\uDC69(?:\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|(?:(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)\\uFE0F|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\u200D[\\u2640\\u2642])|\\uD83C\\uDFF4\\u200D\\u2620)\\uFE0F|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDF6\\uD83C\\uDDE6|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDB5\\uDDB6\\uDDBB\\uDDD2-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5\\uDEEB\\uDEEC\\uDEF4-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiJDOlxcY29kZVxcRmx1aWRGcmFtZXdvcms1XFxub2RlX21vZHVsZXNcXC5wbnBtXFxlbW9qaS1yZWdleEA4LjAuMFxcbm9kZV9tb2R1bGVzXFxlbW9qaS1yZWdleFxcIiwic291cmNlcyI6WyJpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGh0dHBzOi8vbXRocy5iZS9lbW9qaVxuICByZXR1cm4gL1xcdUQ4M0NcXHVERkY0XFx1REI0MFxcdURDNjdcXHVEQjQwXFx1REM2Mig/OlxcdURCNDBcXHVEQzY1XFx1REI0MFxcdURDNkVcXHVEQjQwXFx1REM2N3xcXHVEQjQwXFx1REM3M1xcdURCNDBcXHVEQzYzXFx1REI0MFxcdURDNzR8XFx1REI0MFxcdURDNzdcXHVEQjQwXFx1REM2Q1xcdURCNDBcXHVEQzczKVxcdURCNDBcXHVEQzdGfFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1xcdURGRkNcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjhcXHVEODNDXFx1REZGQnxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkZcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRV0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRVxcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZEXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZEXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCXFx1REZGQ10pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHUyMDBEKD86XFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNEXFx1REM2OHwoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKD86XFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pKXxcXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEZ8XFx1RDgzRFtcXHVEQzY2XFx1REM2N118XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfCg/OlxcdUQ4M0NcXHVERkZCXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZGXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZFXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZEXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZDXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdKVxcdUZFMEZ8XFx1RDgzQ1xcdURGRkJcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86XFx1RDgzRVxcdURERDFcXHVEODNDXFx1REZGQlxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMXxcXHVEODNEXFx1REM2OVxcdUQ4M0NcXHVERkZDXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY5KVxcdUQ4M0NcXHVERkZCfFxcdUQ4M0VcXHVEREQxKD86XFx1RDgzQ1xcdURGRkZcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDEoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMSl8KD86XFx1RDgzRVxcdURERDFcXHVEODNDXFx1REZGRVxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMXxcXHVEODNEXFx1REM2OVxcdUQ4M0NcXHVERkZGXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRV0pfCg/OlxcdUQ4M0VcXHVEREQxXFx1RDgzQ1xcdURGRkNcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDF8XFx1RDgzRFxcdURDNjlcXHVEODNDXFx1REZGRFxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OSkoPzpcXHVEODNDW1xcdURGRkJcXHVERkZDXSl8XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDXFx1REZGRVxcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZEXFx1REZGRl0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGQ1xcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQlxcdURGRkQtXFx1REZGRl0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGQlxcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZEXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCXFx1REZGQ1xcdURGRkVcXHVERkZGXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdTIwMEQoPzpcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSl8XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRlxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSkpfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY5XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKSl8KD86XFx1RDgzRVxcdURERDFcXHVEODNDXFx1REZGRFxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMXxcXHVEODNEXFx1REM2OVxcdUQ4M0NcXHVERkZFXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY5KSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZEXSl8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjlcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfCg/OlxcdUQ4M0RcXHVEQzQxXFx1RkUwRlxcdTIwMERcXHVEODNEXFx1RERFOHxcXHVEODNEXFx1REM2OSg/OlxcdUQ4M0NcXHVERkZGXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZFXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZDXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZCXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZEXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XSl8KD86KD86XFx1MjZGOXxcXHVEODNDW1xcdURGQ0JcXHVERkNDXXxcXHVEODNEXFx1REQ3NSlcXHVGRTBGfFxcdUQ4M0RcXHVEQzZGfFxcdUQ4M0VbXFx1REQzQ1xcdUREREVcXHVERERGXSlcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXXwoPzpcXHUyNkY5fFxcdUQ4M0NbXFx1REZDQlxcdURGQ0NdfFxcdUQ4M0RcXHVERDc1KSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXXwoPzpcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERCOFxcdUREQjlcXHVERENELVxcdUREQ0ZcXHVEREQ2LVxcdURERERdKSg/Oig/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXXxcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXSl8XFx1RDgzQ1xcdURGRjRcXHUyMDBEXFx1MjYyMClcXHVGRTBGfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNDXFx1REZGM1xcdUZFMEZcXHUyMDBEXFx1RDgzQ1xcdURGMDh8XFx1RDgzRFxcdURDMTVcXHUyMDBEXFx1RDgzRVxcdUREQkF8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjd8XFx1RDgzQ1xcdURERkRcXHVEODNDXFx1RERGMHxcXHVEODNDXFx1RERGNFxcdUQ4M0NcXHVEREYyfFxcdUQ4M0NcXHVEREY2XFx1RDgzQ1xcdURERTZ8WyNcXCowLTldXFx1RkUwRlxcdTIwRTN8XFx1RDgzQ1xcdURERTcoPzpcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVGXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREY5KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERTlcXHVEREVCLVxcdURERURcXHVEREVGLVxcdURERjRcXHVEREY3XFx1RERGOVxcdURERkJcXHVEREZDXFx1RERGRl0pfFxcdUQ4M0NcXHVEREVBKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUFcXHVEREVDXFx1RERFRFxcdURERjctXFx1RERGQV0pfFxcdUQ4M0VcXHVEREQxKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHVEODNDXFx1RERGNyg/OlxcdUQ4M0NbXFx1RERFQVxcdURERjRcXHVEREY4XFx1RERGQVxcdURERkNdKXxcXHVEODNEXFx1REM2OSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzQ1xcdURERjIoPzpcXHVEODNDW1xcdURERTZcXHVEREU4LVxcdURERURcXHVEREYwLVxcdURERkZdKXxcXHVEODNDXFx1RERFNig/OlxcdUQ4M0NbXFx1RERFOC1cXHVEREVDXFx1RERFRVxcdURERjFcXHVEREYyXFx1RERGNFxcdURERjYtXFx1RERGQVxcdURERkNcXHVEREZEXFx1RERGRl0pfFxcdUQ4M0NcXHVEREYwKD86XFx1RDgzQ1tcXHVEREVBXFx1RERFQy1cXHVEREVFXFx1RERGMlxcdURERjNcXHVEREY1XFx1RERGN1xcdURERkNcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREVEKD86XFx1RDgzQ1tcXHVEREYwXFx1RERGMlxcdURERjNcXHVEREY3XFx1RERGOVxcdURERkFdKXxcXHVEODNDXFx1RERFOSg/OlxcdUQ4M0NbXFx1RERFQVxcdURERUNcXHVEREVGXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGRl0pfFxcdUQ4M0NcXHVEREZFKD86XFx1RDgzQ1tcXHVEREVBXFx1RERGOV0pfFxcdUQ4M0NcXHVEREVDKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFN1xcdURERTktXFx1RERFRVxcdURERjEtXFx1RERGM1xcdURERjUtXFx1RERGQVxcdURERkNcXHVEREZFXSl8XFx1RDgzQ1xcdURERjgoPzpcXHVEODNDW1xcdURERTYtXFx1RERFQVxcdURERUMtXFx1RERGNFxcdURERjctXFx1RERGOVxcdURERkJcXHVEREZELVxcdURERkZdKXxcXHVEODNDXFx1RERFQig/OlxcdUQ4M0NbXFx1RERFRS1cXHVEREYwXFx1RERGMlxcdURERjRcXHVEREY3XSl8XFx1RDgzQ1xcdURERjUoPzpcXHVEODNDW1xcdURERTZcXHVEREVBLVxcdURERURcXHVEREYwLVxcdURERjNcXHVEREY3LVxcdURERjlcXHVEREZDXFx1RERGRV0pfFxcdUQ4M0NcXHVEREZCKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUFcXHVEREVDXFx1RERFRVxcdURERjNcXHVEREZBXSl8XFx1RDgzQ1xcdURERjMoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQS1cXHVEREVDXFx1RERFRVxcdURERjFcXHVEREY0XFx1RERGNVxcdURERjdcXHVEREZBXFx1RERGRl0pfFxcdUQ4M0NcXHVEREU4KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERTlcXHVEREVCLVxcdURERUVcXHVEREYwLVxcdURERjVcXHVEREY3XFx1RERGQS1cXHVEREZGXSl8XFx1RDgzQ1xcdURERjEoPzpcXHVEODNDW1xcdURERTYtXFx1RERFOFxcdURERUVcXHVEREYwXFx1RERGNy1cXHVEREZCXFx1RERGRV0pfFxcdUQ4M0NcXHVEREZGKD86XFx1RDgzQ1tcXHVEREU2XFx1RERGMlxcdURERkNdKXxcXHVEODNDXFx1RERGQyg/OlxcdUQ4M0NbXFx1RERFQlxcdURERjhdKXxcXHVEODNDXFx1RERGQSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERUNcXHVEREYyXFx1RERGM1xcdURERjhcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREVFKD86XFx1RDgzQ1tcXHVEREU4LVxcdURERUFcXHVEREYxLVxcdURERjRcXHVEREY2LVxcdURERjldKXxcXHVEODNDXFx1RERFRig/OlxcdUQ4M0NbXFx1RERFQVxcdURERjJcXHVEREY0XFx1RERGNV0pfCg/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREI4XFx1RERCOVxcdUREQ0QtXFx1RERDRlxcdURERDYtXFx1RERERF0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpcXHUyNkY5fFxcdUQ4M0NbXFx1REZDQlxcdURGQ0NdfFxcdUQ4M0RcXHVERDc1KSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86W1xcdTI2MURcXHUyNzBBLVxcdTI3MERdfFxcdUQ4M0NbXFx1REY4NVxcdURGQzJcXHVERkM3XXxcXHVEODNEW1xcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2NlxcdURDNjdcXHVEQzZCLVxcdURDNkRcXHVEQzcwXFx1REM3MlxcdURDNzQtXFx1REM3NlxcdURDNzhcXHVEQzdDXFx1REM4M1xcdURDODVcXHVEQ0FBXFx1REQ3NFxcdUREN0FcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVERTRDXFx1REU0RlxcdURFQzBcXHVERUNDXXxcXHVEODNFW1xcdUREMEZcXHVERDE4LVxcdUREMUNcXHVERDFFXFx1REQxRlxcdUREMzAtXFx1REQzNlxcdUREQjVcXHVEREI2XFx1RERCQlxcdURERDItXFx1RERENV0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpbXFx1MjMxQVxcdTIzMUJcXHUyM0U5LVxcdTIzRUNcXHUyM0YwXFx1MjNGM1xcdTI1RkRcXHUyNUZFXFx1MjYxNFxcdTI2MTVcXHUyNjQ4LVxcdTI2NTNcXHUyNjdGXFx1MjY5M1xcdTI2QTFcXHUyNkFBXFx1MjZBQlxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzVcXHUyNkNFXFx1MjZENFxcdTI2RUFcXHUyNkYyXFx1MjZGM1xcdTI2RjVcXHUyNkZBXFx1MjZGRFxcdTI3MDVcXHUyNzBBXFx1MjcwQlxcdTI3MjhcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzk1LVxcdTI3OTdcXHUyN0IwXFx1MjdCRlxcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVdfFxcdUQ4M0NbXFx1REMwNFxcdURDQ0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERFNi1cXHVEREZGXFx1REUwMVxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTM2XFx1REUzOC1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjBcXHVERjJELVxcdURGMzVcXHVERjM3LVxcdURGN0NcXHVERjdFLVxcdURGOTNcXHVERkEwLVxcdURGQ0FcXHVERkNGLVxcdURGRDNcXHVERkUwLVxcdURGRjBcXHVERkY0XFx1REZGOC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REMzRVxcdURDNDBcXHVEQzQyLVxcdURDRkNcXHVEQ0ZGLVxcdUREM0RcXHVERDRCLVxcdURENEVcXHVERDUwLVxcdURENjdcXHVERDdBXFx1REQ5NVxcdUREOTZcXHVEREE0XFx1RERGQi1cXHVERTRGXFx1REU4MC1cXHVERUM1XFx1REVDQ1xcdURFRDAtXFx1REVEMlxcdURFRDVcXHVERUVCXFx1REVFQ1xcdURFRjQtXFx1REVGQVxcdURGRTAtXFx1REZFQl18XFx1RDgzRVtcXHVERDBELVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURENzFcXHVERDczLVxcdURENzZcXHVERDdBLVxcdUREQTJcXHVEREE1LVxcdUREQUFcXHVEREFFLVxcdUREQ0FcXHVERENELVxcdURERkZcXHVERTcwLVxcdURFNzNcXHVERTc4LVxcdURFN0FcXHVERTgwLVxcdURFODJcXHVERTkwLVxcdURFOTVdKXwoPzpbI1xcKjAtOVxceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDRcXHUyNjBFXFx1MjYxMVxcdTI2MTRcXHUyNjE1XFx1MjYxOFxcdTI2MURcXHUyNjIwXFx1MjYyMlxcdTI2MjNcXHUyNjI2XFx1MjYyQVxcdTI2MkVcXHUyNjJGXFx1MjYzOC1cXHUyNjNBXFx1MjY0MFxcdTI2NDJcXHUyNjQ4LVxcdTI2NTNcXHUyNjVGXFx1MjY2MFxcdTI2NjNcXHUyNjY1XFx1MjY2NlxcdTI2NjhcXHUyNjdCXFx1MjY3RVxcdTI2N0ZcXHUyNjkyLVxcdTI2OTdcXHUyNjk5XFx1MjY5QlxcdTI2OUNcXHUyNkEwXFx1MjZBMVxcdTI2QUFcXHUyNkFCXFx1MjZCMFxcdTI2QjFcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM1XFx1MjZDOFxcdTI2Q0VcXHUyNkNGXFx1MjZEMVxcdTI2RDNcXHUyNkQ0XFx1MjZFOVxcdTI2RUFcXHUyNkYwLVxcdTI2RjVcXHUyNkY3LVxcdTI2RkFcXHUyNkZEXFx1MjcwMlxcdTI3MDVcXHUyNzA4LVxcdTI3MERcXHUyNzBGXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjNcXHUyNzY0XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzA0XFx1RENDRlxcdURENzBcXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERFNi1cXHVEREZGXFx1REUwMVxcdURFMDJcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzQVxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERjIxXFx1REYyNC1cXHVERjkzXFx1REY5NlxcdURGOTdcXHVERjk5LVxcdURGOUJcXHVERjlFLVxcdURGRjBcXHVERkYzLVxcdURGRjVcXHVERkY3LVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVEQ0ZEXFx1RENGRi1cXHVERDNEXFx1REQ0OS1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1REQ2RlxcdURENzBcXHVERDczLVxcdUREN0FcXHVERDg3XFx1REQ4QS1cXHVERDhEXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1RERBNFxcdUREQTVcXHVEREE4XFx1RERCMVxcdUREQjJcXHVEREJDXFx1RERDMi1cXHVEREM0XFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERFXFx1RERFMVxcdURERTNcXHVEREU4XFx1RERFRlxcdURERjNcXHVEREZBLVxcdURFNEZcXHVERTgwLVxcdURFQzVcXHVERUNCLVxcdURFRDJcXHVERUQ1XFx1REVFMC1cXHVERUU1XFx1REVFOVxcdURFRUJcXHVERUVDXFx1REVGMFxcdURFRjMtXFx1REVGQVxcdURGRTAtXFx1REZFQl18XFx1RDgzRVtcXHVERDBELVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURENzFcXHVERDczLVxcdURENzZcXHVERDdBLVxcdUREQTJcXHVEREE1LVxcdUREQUFcXHVEREFFLVxcdUREQ0FcXHVERENELVxcdURERkZcXHVERTcwLVxcdURFNzNcXHVERTc4LVxcdURFN0FcXHVERTgwLVxcdURFODJcXHVERTkwLVxcdURFOTVdKVxcdUZFMEZ8KD86W1xcdTI2MURcXHUyNkY5XFx1MjcwQS1cXHUyNzBEXXxcXHVEODNDW1xcdURGODVcXHVERkMyLVxcdURGQzRcXHVERkM3XFx1REZDQS1cXHVERkNDXXxcXHVEODNEW1xcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2Ni1cXHVEQzc4XFx1REM3Q1xcdURDODEtXFx1REM4M1xcdURDODUtXFx1REM4N1xcdURDOEZcXHVEQzkxXFx1RENBQVxcdURENzRcXHVERDc1XFx1REQ3QVxcdUREOTBcXHVERDk1XFx1REQ5NlxcdURFNDUtXFx1REU0N1xcdURFNEItXFx1REU0RlxcdURFQTNcXHVERUI0LVxcdURFQjZcXHVERUMwXFx1REVDQ118XFx1RDgzRVtcXHVERDBGXFx1REQxOC1cXHVERDFGXFx1REQyNlxcdUREMzAtXFx1REQzOVxcdUREM0MtXFx1REQzRVxcdUREQjVcXHVEREI2XFx1RERCOFxcdUREQjlcXHVEREJCXFx1RERDRC1cXHVERENGXFx1REREMS1cXHVEREREXSkvZztcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBLFlBQVk7O0FBRVpBLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHLFlBQVk7RUFDM0I7RUFDQSxPQUFPLHU5VEFBdTlUO0FBQ2grVCxDQUFDIn0=","map":{"version":3,"names":["module","exports"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\emoji-regex@8.0.0\\node_modules\\emoji-regex\\","sources":["index.js"],"sourcesContent":["\"use strict\";\n\nmodule.exports = function () {\n  // https://mths.be/emoji\n  return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C\\uDFFB|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83D[\\uDC66\\uDC67]|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)\\uD83C\\uDFFB|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83D\\uDC69(?:\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|(?:(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)\\uFE0F|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\u200D[\\u2640\\u2642])|\\uD83C\\uDFF4\\u200D\\u2620)\\uFE0F|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDF6\\uD83C\\uDDE6|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDB5\\uDDB6\\uDDBB\\uDDD2-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5\\uDEEB\\uDEEC\\uDEF4-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n};\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,OAAO,GAAG,YAAY;EAC3B;EACA,OAAO,u9TAAu9T;AACh+T,CAAC"}},"mtime":1674865367901},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\wrap-ansi@7.0.0\\\\node_modules\\\\wrap-ansi\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\wrap-ansi@7.0.0\\\\node_modules\\\\wrap-ansi\\\\index.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"'use strict';\n\nconst stringWidth = require('string-width');\nconst stripAnsi = require('strip-ansi');\nconst ansiStyles = require('ansi-styles');\nconst ESCAPES = new Set(['\\u001B', '\\u009B']);\nconst END_CODE = 39;\nconst ANSI_ESCAPE_BELL = '\\u0007';\nconst ANSI_CSI = '[';\nconst ANSI_OSC = ']';\nconst ANSI_SGR_TERMINATOR = 'm';\nconst ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;\nconst wrapAnsi = code => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;\nconst wrapAnsiHyperlink = uri => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;\n\n// Calculate the length of words split on ' ', ignoring\n// the extra characters added by ansi escape codes\nconst wordLengths = string => string.split(' ').map(character => stringWidth(character));\n\n// Wrap a long word across multiple rows\n// Ansi escape codes do not count towards length\nconst wrapWord = (rows, word, columns) => {\n  const characters = [...word];\n  let isInsideEscape = false;\n  let isInsideLinkEscape = false;\n  let visible = stringWidth(stripAnsi(rows[rows.length - 1]));\n  for (const [index, character] of characters.entries()) {\n    const characterLength = stringWidth(character);\n    if (visible + characterLength <= columns) {\n      rows[rows.length - 1] += character;\n    } else {\n      rows.push(character);\n      visible = 0;\n    }\n    if (ESCAPES.has(character)) {\n      isInsideEscape = true;\n      isInsideLinkEscape = characters.slice(index + 1).join('').startsWith(ANSI_ESCAPE_LINK);\n    }\n    if (isInsideEscape) {\n      if (isInsideLinkEscape) {\n        if (character === ANSI_ESCAPE_BELL) {\n          isInsideEscape = false;\n          isInsideLinkEscape = false;\n        }\n      } else if (character === ANSI_SGR_TERMINATOR) {\n        isInsideEscape = false;\n      }\n      continue;\n    }\n    visible += characterLength;\n    if (visible === columns && index < characters.length - 1) {\n      rows.push('');\n      visible = 0;\n    }\n  }\n\n  // It's possible that the last row we copy over is only\n  // ansi escape characters, handle this edge-case\n  if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {\n    rows[rows.length - 2] += rows.pop();\n  }\n};\n\n// Trims spaces from a string ignoring invisible sequences\nconst stringVisibleTrimSpacesRight = string => {\n  const words = string.split(' ');\n  let last = words.length;\n  while (last > 0) {\n    if (stringWidth(words[last - 1]) > 0) {\n      break;\n    }\n    last--;\n  }\n  if (last === words.length) {\n    return string;\n  }\n  return words.slice(0, last).join(' ') + words.slice(last).join('');\n};\n\n// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode\n//\n// 'hard' will never allow a string to take up more than columns characters\n//\n// 'soft' allows long words to expand past the column length\nconst exec = (string, columns, options = {}) => {\n  if (options.trim !== false && string.trim() === '') {\n    return '';\n  }\n  let returnValue = '';\n  let escapeCode;\n  let escapeUrl;\n  const lengths = wordLengths(string);\n  let rows = [''];\n  for (const [index, word] of string.split(' ').entries()) {\n    if (options.trim !== false) {\n      rows[rows.length - 1] = rows[rows.length - 1].trimStart();\n    }\n    let rowLength = stringWidth(rows[rows.length - 1]);\n    if (index !== 0) {\n      if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {\n        // If we start with a new word but the current row length equals the length of the columns, add a new row\n        rows.push('');\n        rowLength = 0;\n      }\n      if (rowLength > 0 || options.trim === false) {\n        rows[rows.length - 1] += ' ';\n        rowLength++;\n      }\n    }\n\n    // In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'\n    if (options.hard && lengths[index] > columns) {\n      const remainingColumns = columns - rowLength;\n      const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);\n      const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);\n      if (breaksStartingNextLine < breaksStartingThisLine) {\n        rows.push('');\n      }\n      wrapWord(rows, word, columns);\n      continue;\n    }\n    if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {\n      if (options.wordWrap === false && rowLength < columns) {\n        wrapWord(rows, word, columns);\n        continue;\n      }\n      rows.push('');\n    }\n    if (rowLength + lengths[index] > columns && options.wordWrap === false) {\n      wrapWord(rows, word, columns);\n      continue;\n    }\n    rows[rows.length - 1] += word;\n  }\n  if (options.trim !== false) {\n    rows = rows.map(stringVisibleTrimSpacesRight);\n  }\n  const pre = [...rows.join('\\n')];\n  for (const [index, character] of pre.entries()) {\n    returnValue += character;\n    if (ESCAPES.has(character)) {\n      const {\n        groups\n      } = new RegExp(`(?:\\\\${ANSI_CSI}(?<code>\\\\d+)m|\\\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index).join('')) || {\n        groups: {}\n      };\n      if (groups.code !== undefined) {\n        const code = Number.parseFloat(groups.code);\n        escapeCode = code === END_CODE ? undefined : code;\n      } else if (groups.uri !== undefined) {\n        escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;\n      }\n    }\n    const code = ansiStyles.codes.get(Number(escapeCode));\n    if (pre[index + 1] === '\\n') {\n      if (escapeUrl) {\n        returnValue += wrapAnsiHyperlink('');\n      }\n      if (escapeCode && code) {\n        returnValue += wrapAnsi(code);\n      }\n    } else if (character === '\\n') {\n      if (escapeCode && code) {\n        returnValue += wrapAnsi(escapeCode);\n      }\n      if (escapeUrl) {\n        returnValue += wrapAnsiHyperlink(escapeUrl);\n      }\n    }\n  }\n  return returnValue;\n};\n\n// For each newline, invoke the method separately\nmodule.exports = (string, columns, options) => {\n  return String(string).normalize().replace(/\\r\\n/g, '\\n').split('\\n').map(line => exec(line, columns, options)).join('\\n');\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJzdHJpbmdXaWR0aCIsInJlcXVpcmUiLCJzdHJpcEFuc2kiLCJhbnNpU3R5bGVzIiwiRVNDQVBFUyIsIlNldCIsIkVORF9DT0RFIiwiQU5TSV9FU0NBUEVfQkVMTCIsIkFOU0lfQ1NJIiwiQU5TSV9PU0MiLCJBTlNJX1NHUl9URVJNSU5BVE9SIiwiQU5TSV9FU0NBUEVfTElOSyIsIndyYXBBbnNpIiwiY29kZSIsInZhbHVlcyIsIm5leHQiLCJ2YWx1ZSIsIndyYXBBbnNpSHlwZXJsaW5rIiwidXJpIiwid29yZExlbmd0aHMiLCJzdHJpbmciLCJzcGxpdCIsIm1hcCIsImNoYXJhY3RlciIsIndyYXBXb3JkIiwicm93cyIsIndvcmQiLCJjb2x1bW5zIiwiY2hhcmFjdGVycyIsImlzSW5zaWRlRXNjYXBlIiwiaXNJbnNpZGVMaW5rRXNjYXBlIiwidmlzaWJsZSIsImxlbmd0aCIsImluZGV4IiwiZW50cmllcyIsImNoYXJhY3Rlckxlbmd0aCIsInB1c2giLCJoYXMiLCJzbGljZSIsImpvaW4iLCJzdGFydHNXaXRoIiwicG9wIiwic3RyaW5nVmlzaWJsZVRyaW1TcGFjZXNSaWdodCIsIndvcmRzIiwibGFzdCIsImV4ZWMiLCJvcHRpb25zIiwidHJpbSIsInJldHVyblZhbHVlIiwiZXNjYXBlQ29kZSIsImVzY2FwZVVybCIsImxlbmd0aHMiLCJ0cmltU3RhcnQiLCJyb3dMZW5ndGgiLCJ3b3JkV3JhcCIsImhhcmQiLCJyZW1haW5pbmdDb2x1bW5zIiwiYnJlYWtzU3RhcnRpbmdUaGlzTGluZSIsIk1hdGgiLCJmbG9vciIsImJyZWFrc1N0YXJ0aW5nTmV4dExpbmUiLCJwcmUiLCJncm91cHMiLCJSZWdFeHAiLCJ1bmRlZmluZWQiLCJOdW1iZXIiLCJwYXJzZUZsb2F0IiwiY29kZXMiLCJnZXQiLCJtb2R1bGUiLCJleHBvcnRzIiwiU3RyaW5nIiwibm9ybWFsaXplIiwicmVwbGFjZSIsImxpbmUiXSwic291cmNlUm9vdCI6IkM6XFxjb2RlXFxGbHVpZEZyYW1ld29yazVcXG5vZGVfbW9kdWxlc1xcLnBucG1cXHdyYXAtYW5zaUA3LjAuMFxcbm9kZV9tb2R1bGVzXFx3cmFwLWFuc2lcXCIsInNvdXJjZXMiOlsiaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgc3RyaW5nV2lkdGggPSByZXF1aXJlKCdzdHJpbmctd2lkdGgnKTtcbmNvbnN0IHN0cmlwQW5zaSA9IHJlcXVpcmUoJ3N0cmlwLWFuc2knKTtcbmNvbnN0IGFuc2lTdHlsZXMgPSByZXF1aXJlKCdhbnNpLXN0eWxlcycpO1xuXG5jb25zdCBFU0NBUEVTID0gbmV3IFNldChbXG5cdCdcXHUwMDFCJyxcblx0J1xcdTAwOUInXG5dKTtcblxuY29uc3QgRU5EX0NPREUgPSAzOTtcblxuY29uc3QgQU5TSV9FU0NBUEVfQkVMTCA9ICdcXHUwMDA3JztcbmNvbnN0IEFOU0lfQ1NJID0gJ1snO1xuY29uc3QgQU5TSV9PU0MgPSAnXSc7XG5jb25zdCBBTlNJX1NHUl9URVJNSU5BVE9SID0gJ20nO1xuY29uc3QgQU5TSV9FU0NBUEVfTElOSyA9IGAke0FOU0lfT1NDfTg7O2A7XG5cbmNvbnN0IHdyYXBBbnNpID0gY29kZSA9PiBgJHtFU0NBUEVTLnZhbHVlcygpLm5leHQoKS52YWx1ZX0ke0FOU0lfQ1NJfSR7Y29kZX0ke0FOU0lfU0dSX1RFUk1JTkFUT1J9YDtcbmNvbnN0IHdyYXBBbnNpSHlwZXJsaW5rID0gdXJpID0+IGAke0VTQ0FQRVMudmFsdWVzKCkubmV4dCgpLnZhbHVlfSR7QU5TSV9FU0NBUEVfTElOS30ke3VyaX0ke0FOU0lfRVNDQVBFX0JFTEx9YDtcblxuLy8gQ2FsY3VsYXRlIHRoZSBsZW5ndGggb2Ygd29yZHMgc3BsaXQgb24gJyAnLCBpZ25vcmluZ1xuLy8gdGhlIGV4dHJhIGNoYXJhY3RlcnMgYWRkZWQgYnkgYW5zaSBlc2NhcGUgY29kZXNcbmNvbnN0IHdvcmRMZW5ndGhzID0gc3RyaW5nID0+IHN0cmluZy5zcGxpdCgnICcpLm1hcChjaGFyYWN0ZXIgPT4gc3RyaW5nV2lkdGgoY2hhcmFjdGVyKSk7XG5cbi8vIFdyYXAgYSBsb25nIHdvcmQgYWNyb3NzIG11bHRpcGxlIHJvd3Ncbi8vIEFuc2kgZXNjYXBlIGNvZGVzIGRvIG5vdCBjb3VudCB0b3dhcmRzIGxlbmd0aFxuY29uc3Qgd3JhcFdvcmQgPSAocm93cywgd29yZCwgY29sdW1ucykgPT4ge1xuXHRjb25zdCBjaGFyYWN0ZXJzID0gWy4uLndvcmRdO1xuXG5cdGxldCBpc0luc2lkZUVzY2FwZSA9IGZhbHNlO1xuXHRsZXQgaXNJbnNpZGVMaW5rRXNjYXBlID0gZmFsc2U7XG5cdGxldCB2aXNpYmxlID0gc3RyaW5nV2lkdGgoc3RyaXBBbnNpKHJvd3Nbcm93cy5sZW5ndGggLSAxXSkpO1xuXG5cdGZvciAoY29uc3QgW2luZGV4LCBjaGFyYWN0ZXJdIG9mIGNoYXJhY3RlcnMuZW50cmllcygpKSB7XG5cdFx0Y29uc3QgY2hhcmFjdGVyTGVuZ3RoID0gc3RyaW5nV2lkdGgoY2hhcmFjdGVyKTtcblxuXHRcdGlmICh2aXNpYmxlICsgY2hhcmFjdGVyTGVuZ3RoIDw9IGNvbHVtbnMpIHtcblx0XHRcdHJvd3Nbcm93cy5sZW5ndGggLSAxXSArPSBjaGFyYWN0ZXI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJvd3MucHVzaChjaGFyYWN0ZXIpO1xuXHRcdFx0dmlzaWJsZSA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKEVTQ0FQRVMuaGFzKGNoYXJhY3RlcikpIHtcblx0XHRcdGlzSW5zaWRlRXNjYXBlID0gdHJ1ZTtcblx0XHRcdGlzSW5zaWRlTGlua0VzY2FwZSA9IGNoYXJhY3RlcnMuc2xpY2UoaW5kZXggKyAxKS5qb2luKCcnKS5zdGFydHNXaXRoKEFOU0lfRVNDQVBFX0xJTkspO1xuXHRcdH1cblxuXHRcdGlmIChpc0luc2lkZUVzY2FwZSkge1xuXHRcdFx0aWYgKGlzSW5zaWRlTGlua0VzY2FwZSkge1xuXHRcdFx0XHRpZiAoY2hhcmFjdGVyID09PSBBTlNJX0VTQ0FQRV9CRUxMKSB7XG5cdFx0XHRcdFx0aXNJbnNpZGVFc2NhcGUgPSBmYWxzZTtcblx0XHRcdFx0XHRpc0luc2lkZUxpbmtFc2NhcGUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IEFOU0lfU0dSX1RFUk1JTkFUT1IpIHtcblx0XHRcdFx0aXNJbnNpZGVFc2NhcGUgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmlzaWJsZSArPSBjaGFyYWN0ZXJMZW5ndGg7XG5cblx0XHRpZiAodmlzaWJsZSA9PT0gY29sdW1ucyAmJiBpbmRleCA8IGNoYXJhY3RlcnMubGVuZ3RoIC0gMSkge1xuXHRcdFx0cm93cy5wdXNoKCcnKTtcblx0XHRcdHZpc2libGUgPSAwO1xuXHRcdH1cblx0fVxuXG5cdC8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgbGFzdCByb3cgd2UgY29weSBvdmVyIGlzIG9ubHlcblx0Ly8gYW5zaSBlc2NhcGUgY2hhcmFjdGVycywgaGFuZGxlIHRoaXMgZWRnZS1jYXNlXG5cdGlmICghdmlzaWJsZSAmJiByb3dzW3Jvd3MubGVuZ3RoIC0gMV0ubGVuZ3RoID4gMCAmJiByb3dzLmxlbmd0aCA+IDEpIHtcblx0XHRyb3dzW3Jvd3MubGVuZ3RoIC0gMl0gKz0gcm93cy5wb3AoKTtcblx0fVxufTtcblxuLy8gVHJpbXMgc3BhY2VzIGZyb20gYSBzdHJpbmcgaWdub3JpbmcgaW52aXNpYmxlIHNlcXVlbmNlc1xuY29uc3Qgc3RyaW5nVmlzaWJsZVRyaW1TcGFjZXNSaWdodCA9IHN0cmluZyA9PiB7XG5cdGNvbnN0IHdvcmRzID0gc3RyaW5nLnNwbGl0KCcgJyk7XG5cdGxldCBsYXN0ID0gd29yZHMubGVuZ3RoO1xuXG5cdHdoaWxlIChsYXN0ID4gMCkge1xuXHRcdGlmIChzdHJpbmdXaWR0aCh3b3Jkc1tsYXN0IC0gMV0pID4gMCkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0bGFzdC0tO1xuXHR9XG5cblx0aWYgKGxhc3QgPT09IHdvcmRzLmxlbmd0aCkge1xuXHRcdHJldHVybiBzdHJpbmc7XG5cdH1cblxuXHRyZXR1cm4gd29yZHMuc2xpY2UoMCwgbGFzdCkuam9pbignICcpICsgd29yZHMuc2xpY2UobGFzdCkuam9pbignJyk7XG59O1xuXG4vLyBUaGUgd3JhcC1hbnNpIG1vZHVsZSBjYW4gYmUgaW52b2tlZCBpbiBlaXRoZXIgJ2hhcmQnIG9yICdzb2Z0JyB3cmFwIG1vZGVcbi8vXG4vLyAnaGFyZCcgd2lsbCBuZXZlciBhbGxvdyBhIHN0cmluZyB0byB0YWtlIHVwIG1vcmUgdGhhbiBjb2x1bW5zIGNoYXJhY3RlcnNcbi8vXG4vLyAnc29mdCcgYWxsb3dzIGxvbmcgd29yZHMgdG8gZXhwYW5kIHBhc3QgdGhlIGNvbHVtbiBsZW5ndGhcbmNvbnN0IGV4ZWMgPSAoc3RyaW5nLCBjb2x1bW5zLCBvcHRpb25zID0ge30pID0+IHtcblx0aWYgKG9wdGlvbnMudHJpbSAhPT0gZmFsc2UgJiYgc3RyaW5nLnRyaW0oKSA9PT0gJycpIHtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHRsZXQgcmV0dXJuVmFsdWUgPSAnJztcblx0bGV0IGVzY2FwZUNvZGU7XG5cdGxldCBlc2NhcGVVcmw7XG5cblx0Y29uc3QgbGVuZ3RocyA9IHdvcmRMZW5ndGhzKHN0cmluZyk7XG5cdGxldCByb3dzID0gWycnXTtcblxuXHRmb3IgKGNvbnN0IFtpbmRleCwgd29yZF0gb2Ygc3RyaW5nLnNwbGl0KCcgJykuZW50cmllcygpKSB7XG5cdFx0aWYgKG9wdGlvbnMudHJpbSAhPT0gZmFsc2UpIHtcblx0XHRcdHJvd3Nbcm93cy5sZW5ndGggLSAxXSA9IHJvd3Nbcm93cy5sZW5ndGggLSAxXS50cmltU3RhcnQoKTtcblx0XHR9XG5cblx0XHRsZXQgcm93TGVuZ3RoID0gc3RyaW5nV2lkdGgocm93c1tyb3dzLmxlbmd0aCAtIDFdKTtcblxuXHRcdGlmIChpbmRleCAhPT0gMCkge1xuXHRcdFx0aWYgKHJvd0xlbmd0aCA+PSBjb2x1bW5zICYmIChvcHRpb25zLndvcmRXcmFwID09PSBmYWxzZSB8fCBvcHRpb25zLnRyaW0gPT09IGZhbHNlKSkge1xuXHRcdFx0XHQvLyBJZiB3ZSBzdGFydCB3aXRoIGEgbmV3IHdvcmQgYnV0IHRoZSBjdXJyZW50IHJvdyBsZW5ndGggZXF1YWxzIHRoZSBsZW5ndGggb2YgdGhlIGNvbHVtbnMsIGFkZCBhIG5ldyByb3dcblx0XHRcdFx0cm93cy5wdXNoKCcnKTtcblx0XHRcdFx0cm93TGVuZ3RoID0gMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJvd0xlbmd0aCA+IDAgfHwgb3B0aW9ucy50cmltID09PSBmYWxzZSkge1xuXHRcdFx0XHRyb3dzW3Jvd3MubGVuZ3RoIC0gMV0gKz0gJyAnO1xuXHRcdFx0XHRyb3dMZW5ndGgrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJbiAnaGFyZCcgd3JhcCBtb2RlLCB0aGUgbGVuZ3RoIG9mIGEgbGluZSBpcyBuZXZlciBhbGxvd2VkIHRvIGV4dGVuZCBwYXN0ICdjb2x1bW5zJ1xuXHRcdGlmIChvcHRpb25zLmhhcmQgJiYgbGVuZ3Roc1tpbmRleF0gPiBjb2x1bW5zKSB7XG5cdFx0XHRjb25zdCByZW1haW5pbmdDb2x1bW5zID0gKGNvbHVtbnMgLSByb3dMZW5ndGgpO1xuXHRcdFx0Y29uc3QgYnJlYWtzU3RhcnRpbmdUaGlzTGluZSA9IDEgKyBNYXRoLmZsb29yKChsZW5ndGhzW2luZGV4XSAtIHJlbWFpbmluZ0NvbHVtbnMgLSAxKSAvIGNvbHVtbnMpO1xuXHRcdFx0Y29uc3QgYnJlYWtzU3RhcnRpbmdOZXh0TGluZSA9IE1hdGguZmxvb3IoKGxlbmd0aHNbaW5kZXhdIC0gMSkgLyBjb2x1bW5zKTtcblx0XHRcdGlmIChicmVha3NTdGFydGluZ05leHRMaW5lIDwgYnJlYWtzU3RhcnRpbmdUaGlzTGluZSkge1xuXHRcdFx0XHRyb3dzLnB1c2goJycpO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwV29yZChyb3dzLCB3b3JkLCBjb2x1bW5zKTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmIChyb3dMZW5ndGggKyBsZW5ndGhzW2luZGV4XSA+IGNvbHVtbnMgJiYgcm93TGVuZ3RoID4gMCAmJiBsZW5ndGhzW2luZGV4XSA+IDApIHtcblx0XHRcdGlmIChvcHRpb25zLndvcmRXcmFwID09PSBmYWxzZSAmJiByb3dMZW5ndGggPCBjb2x1bW5zKSB7XG5cdFx0XHRcdHdyYXBXb3JkKHJvd3MsIHdvcmQsIGNvbHVtbnMpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0cm93cy5wdXNoKCcnKTtcblx0XHR9XG5cblx0XHRpZiAocm93TGVuZ3RoICsgbGVuZ3Roc1tpbmRleF0gPiBjb2x1bW5zICYmIG9wdGlvbnMud29yZFdyYXAgPT09IGZhbHNlKSB7XG5cdFx0XHR3cmFwV29yZChyb3dzLCB3b3JkLCBjb2x1bW5zKTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHJvd3Nbcm93cy5sZW5ndGggLSAxXSArPSB3b3JkO1xuXHR9XG5cblx0aWYgKG9wdGlvbnMudHJpbSAhPT0gZmFsc2UpIHtcblx0XHRyb3dzID0gcm93cy5tYXAoc3RyaW5nVmlzaWJsZVRyaW1TcGFjZXNSaWdodCk7XG5cdH1cblxuXHRjb25zdCBwcmUgPSBbLi4ucm93cy5qb2luKCdcXG4nKV07XG5cblx0Zm9yIChjb25zdCBbaW5kZXgsIGNoYXJhY3Rlcl0gb2YgcHJlLmVudHJpZXMoKSkge1xuXHRcdHJldHVyblZhbHVlICs9IGNoYXJhY3RlcjtcblxuXHRcdGlmIChFU0NBUEVTLmhhcyhjaGFyYWN0ZXIpKSB7XG5cdFx0XHRjb25zdCB7Z3JvdXBzfSA9IG5ldyBSZWdFeHAoYCg/OlxcXFwke0FOU0lfQ1NJfSg/PGNvZGU+XFxcXGQrKW18XFxcXCR7QU5TSV9FU0NBUEVfTElOS30oPzx1cmk+LiopJHtBTlNJX0VTQ0FQRV9CRUxMfSlgKS5leGVjKHByZS5zbGljZShpbmRleCkuam9pbignJykpIHx8IHtncm91cHM6IHt9fTtcblx0XHRcdGlmIChncm91cHMuY29kZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnN0IGNvZGUgPSBOdW1iZXIucGFyc2VGbG9hdChncm91cHMuY29kZSk7XG5cdFx0XHRcdGVzY2FwZUNvZGUgPSBjb2RlID09PSBFTkRfQ09ERSA/IHVuZGVmaW5lZCA6IGNvZGU7XG5cdFx0XHR9IGVsc2UgaWYgKGdyb3Vwcy51cmkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRlc2NhcGVVcmwgPSBncm91cHMudXJpLmxlbmd0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IGdyb3Vwcy51cmk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgY29kZSA9IGFuc2lTdHlsZXMuY29kZXMuZ2V0KE51bWJlcihlc2NhcGVDb2RlKSk7XG5cblx0XHRpZiAocHJlW2luZGV4ICsgMV0gPT09ICdcXG4nKSB7XG5cdFx0XHRpZiAoZXNjYXBlVXJsKSB7XG5cdFx0XHRcdHJldHVyblZhbHVlICs9IHdyYXBBbnNpSHlwZXJsaW5rKCcnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGVzY2FwZUNvZGUgJiYgY29kZSkge1xuXHRcdFx0XHRyZXR1cm5WYWx1ZSArPSB3cmFwQW5zaShjb2RlKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gJ1xcbicpIHtcblx0XHRcdGlmIChlc2NhcGVDb2RlICYmIGNvZGUpIHtcblx0XHRcdFx0cmV0dXJuVmFsdWUgKz0gd3JhcEFuc2koZXNjYXBlQ29kZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChlc2NhcGVVcmwpIHtcblx0XHRcdFx0cmV0dXJuVmFsdWUgKz0gd3JhcEFuc2lIeXBlcmxpbmsoZXNjYXBlVXJsKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xuXG4vLyBGb3IgZWFjaCBuZXdsaW5lLCBpbnZva2UgdGhlIG1ldGhvZCBzZXBhcmF0ZWx5XG5tb2R1bGUuZXhwb3J0cyA9IChzdHJpbmcsIGNvbHVtbnMsIG9wdGlvbnMpID0+IHtcblx0cmV0dXJuIFN0cmluZyhzdHJpbmcpXG5cdFx0Lm5vcm1hbGl6ZSgpXG5cdFx0LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJylcblx0XHQuc3BsaXQoJ1xcbicpXG5cdFx0Lm1hcChsaW5lID0+IGV4ZWMobGluZSwgY29sdW1ucywgb3B0aW9ucykpXG5cdFx0LmpvaW4oJ1xcbicpO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFDWixNQUFNQSxXQUFXLEdBQUdDLE9BQU8sQ0FBQyxjQUFjLENBQUM7QUFDM0MsTUFBTUMsU0FBUyxHQUFHRCxPQUFPLENBQUMsWUFBWSxDQUFDO0FBQ3ZDLE1BQU1FLFVBQVUsR0FBR0YsT0FBTyxDQUFDLGFBQWEsQ0FBQztBQUV6QyxNQUFNRyxPQUFPLEdBQUcsSUFBSUMsR0FBRyxDQUFDLENBQ3ZCLFFBQVEsRUFDUixRQUFRLENBQ1IsQ0FBQztBQUVGLE1BQU1DLFFBQVEsR0FBRyxFQUFFO0FBRW5CLE1BQU1DLGdCQUFnQixHQUFHLFFBQVE7QUFDakMsTUFBTUMsUUFBUSxHQUFHLEdBQUc7QUFDcEIsTUFBTUMsUUFBUSxHQUFHLEdBQUc7QUFDcEIsTUFBTUMsbUJBQW1CLEdBQUcsR0FBRztBQUMvQixNQUFNQyxnQkFBZ0IsR0FBSSxHQUFFRixRQUFTLEtBQUk7QUFFekMsTUFBTUcsUUFBUSxHQUFHQyxJQUFJLElBQUssR0FBRVQsT0FBTyxDQUFDVSxNQUFNLENBQUMsQ0FBQyxDQUFDQyxJQUFJLENBQUMsQ0FBQyxDQUFDQyxLQUFNLEdBQUVSLFFBQVMsR0FBRUssSUFBSyxHQUFFSCxtQkFBb0IsRUFBQztBQUNuRyxNQUFNTyxpQkFBaUIsR0FBR0MsR0FBRyxJQUFLLEdBQUVkLE9BQU8sQ0FBQ1UsTUFBTSxDQUFDLENBQUMsQ0FBQ0MsSUFBSSxDQUFDLENBQUMsQ0FBQ0MsS0FBTSxHQUFFTCxnQkFBaUIsR0FBRU8sR0FBSSxHQUFFWCxnQkFBaUIsRUFBQzs7QUFFL0c7QUFDQTtBQUNBLE1BQU1ZLFdBQVcsR0FBR0MsTUFBTSxJQUFJQSxNQUFNLENBQUNDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQ0Ms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","map":{"version":3,"names":["stringWidth","require","stripAnsi","ansiStyles","ESCAPES","Set","END_CODE","ANSI_ESCAPE_BELL","ANSI_CSI","ANSI_OSC","ANSI_SGR_TERMINATOR","ANSI_ESCAPE_LINK","wrapAnsi","code","values","next","value","wrapAnsiHyperlink","uri","wordLengths","string","split","map","character","wrapWord","rows","word","columns","characters","isInsideEscape","isInsideLinkEscape","visible","length","index","entries","characterLength","push","has","slice","join","startsWith","pop","stringVisibleTrimSpacesRight","words","last","exec","options","trim","returnValue","escapeCode","escapeUrl","lengths","trimStart","rowLength","wordWrap","hard","remainingColumns","breaksStartingThisLine","Math","floor","breaksStartingNextLine","pre","groups","RegExp","undefined","Number","parseFloat","codes","get","module","exports","String","normalize","replace","line"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\wrap-ansi@7.0.0\\node_modules\\wrap-ansi\\","sources":["index.js"],"sourcesContent":["'use strict';\nconst stringWidth = require('string-width');\nconst stripAnsi = require('strip-ansi');\nconst ansiStyles = require('ansi-styles');\n\nconst ESCAPES = new Set([\n\t'\\u001B',\n\t'\\u009B'\n]);\n\nconst END_CODE = 39;\n\nconst ANSI_ESCAPE_BELL = '\\u0007';\nconst ANSI_CSI = '[';\nconst ANSI_OSC = ']';\nconst ANSI_SGR_TERMINATOR = 'm';\nconst ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;\n\nconst wrapAnsi = code => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;\nconst wrapAnsiHyperlink = uri => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;\n\n// Calculate the length of words split on ' ', ignoring\n// the extra characters added by ansi escape codes\nconst wordLengths = string => string.split(' ').map(character => stringWidth(character));\n\n// Wrap a long word across multiple rows\n// Ansi escape codes do not count towards length\nconst wrapWord = (rows, word, columns) => {\n\tconst characters = [...word];\n\n\tlet isInsideEscape = false;\n\tlet isInsideLinkEscape = false;\n\tlet visible = stringWidth(stripAnsi(rows[rows.length - 1]));\n\n\tfor (const [index, character] of characters.entries()) {\n\t\tconst characterLength = stringWidth(character);\n\n\t\tif (visible + characterLength <= columns) {\n\t\t\trows[rows.length - 1] += character;\n\t\t} else {\n\t\t\trows.push(character);\n\t\t\tvisible = 0;\n\t\t}\n\n\t\tif (ESCAPES.has(character)) {\n\t\t\tisInsideEscape = true;\n\t\t\tisInsideLinkEscape = characters.slice(index + 1).join('').startsWith(ANSI_ESCAPE_LINK);\n\t\t}\n\n\t\tif (isInsideEscape) {\n\t\t\tif (isInsideLinkEscape) {\n\t\t\t\tif (character === ANSI_ESCAPE_BELL) {\n\t\t\t\t\tisInsideEscape = false;\n\t\t\t\t\tisInsideLinkEscape = false;\n\t\t\t\t}\n\t\t\t} else if (character === ANSI_SGR_TERMINATOR) {\n\t\t\t\tisInsideEscape = false;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tvisible += characterLength;\n\n\t\tif (visible === columns && index < characters.length - 1) {\n\t\t\trows.push('');\n\t\t\tvisible = 0;\n\t\t}\n\t}\n\n\t// It's possible that the last row we copy over is only\n\t// ansi escape characters, handle this edge-case\n\tif (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {\n\t\trows[rows.length - 2] += rows.pop();\n\t}\n};\n\n// Trims spaces from a string ignoring invisible sequences\nconst stringVisibleTrimSpacesRight = string => {\n\tconst words = string.split(' ');\n\tlet last = words.length;\n\n\twhile (last > 0) {\n\t\tif (stringWidth(words[last - 1]) > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast--;\n\t}\n\n\tif (last === words.length) {\n\t\treturn string;\n\t}\n\n\treturn words.slice(0, last).join(' ') + words.slice(last).join('');\n};\n\n// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode\n//\n// 'hard' will never allow a string to take up more than columns characters\n//\n// 'soft' allows long words to expand past the column length\nconst exec = (string, columns, options = {}) => {\n\tif (options.trim !== false && string.trim() === '') {\n\t\treturn '';\n\t}\n\n\tlet returnValue = '';\n\tlet escapeCode;\n\tlet escapeUrl;\n\n\tconst lengths = wordLengths(string);\n\tlet rows = [''];\n\n\tfor (const [index, word] of string.split(' ').entries()) {\n\t\tif (options.trim !== false) {\n\t\t\trows[rows.length - 1] = rows[rows.length - 1].trimStart();\n\t\t}\n\n\t\tlet rowLength = stringWidth(rows[rows.length - 1]);\n\n\t\tif (index !== 0) {\n\t\t\tif (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {\n\t\t\t\t// If we start with a new word but the current row length equals the length of the columns, add a new row\n\t\t\t\trows.push('');\n\t\t\t\trowLength = 0;\n\t\t\t}\n\n\t\t\tif (rowLength > 0 || options.trim === false) {\n\t\t\t\trows[rows.length - 1] += ' ';\n\t\t\t\trowLength++;\n\t\t\t}\n\t\t}\n\n\t\t// In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'\n\t\tif (options.hard && lengths[index] > columns) {\n\t\t\tconst remainingColumns = (columns - rowLength);\n\t\t\tconst breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);\n\t\t\tconst breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);\n\t\t\tif (breaksStartingNextLine < breaksStartingThisLine) {\n\t\t\t\trows.push('');\n\t\t\t}\n\n\t\t\twrapWord(rows, word, columns);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {\n\t\t\tif (options.wordWrap === false && rowLength < columns) {\n\t\t\t\twrapWord(rows, word, columns);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trows.push('');\n\t\t}\n\n\t\tif (rowLength + lengths[index] > columns && options.wordWrap === false) {\n\t\t\twrapWord(rows, word, columns);\n\t\t\tcontinue;\n\t\t}\n\n\t\trows[rows.length - 1] += word;\n\t}\n\n\tif (options.trim !== false) {\n\t\trows = rows.map(stringVisibleTrimSpacesRight);\n\t}\n\n\tconst pre = [...rows.join('\\n')];\n\n\tfor (const [index, character] of pre.entries()) {\n\t\treturnValue += character;\n\n\t\tif (ESCAPES.has(character)) {\n\t\t\tconst {groups} = new RegExp(`(?:\\\\${ANSI_CSI}(?<code>\\\\d+)m|\\\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index).join('')) || {groups: {}};\n\t\t\tif (groups.code !== undefined) {\n\t\t\t\tconst code = Number.parseFloat(groups.code);\n\t\t\t\tescapeCode = code === END_CODE ? undefined : code;\n\t\t\t} else if (groups.uri !== undefined) {\n\t\t\t\tescapeUrl = groups.uri.length === 0 ? undefined : groups.uri;\n\t\t\t}\n\t\t}\n\n\t\tconst code = ansiStyles.codes.get(Number(escapeCode));\n\n\t\tif (pre[index + 1] === '\\n') {\n\t\t\tif (escapeUrl) {\n\t\t\t\treturnValue += wrapAnsiHyperlink('');\n\t\t\t}\n\n\t\t\tif (escapeCode && code) {\n\t\t\t\treturnValue += wrapAnsi(code);\n\t\t\t}\n\t\t} else if (character === '\\n') {\n\t\t\tif (escapeCode && code) {\n\t\t\t\treturnValue += wrapAnsi(escapeCode);\n\t\t\t}\n\n\t\t\tif (escapeUrl) {\n\t\t\t\treturnValue += wrapAnsiHyperlink(escapeUrl);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn returnValue;\n};\n\n// For each newline, invoke the method separately\nmodule.exports = (string, columns, options) => {\n\treturn String(string)\n\t\t.normalize()\n\t\t.replace(/\\r\\n/g, '\\n')\n\t\t.split('\\n')\n\t\t.map(line => exec(line, columns, options))\n\t\t.join('\\n');\n};\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,WAAW,GAAGC,OAAO,CAAC,cAAc,CAAC;AAC3C,MAAMC,SAAS,GAAGD,OAAO,CAAC,YAAY,CAAC;AACvC,MAAME,UAAU,GAAGF,OAAO,CAAC,aAAa,CAAC;AAEzC,MAAMG,OAAO,GAAG,IAAIC,GAAG,CAAC,CACvB,QAAQ,EACR,QAAQ,CACR,CAAC;AAEF,MAAMC,QAAQ,GAAG,EAAE;AAEnB,MAAMC,gBAAgB,GAAG,QAAQ;AACjC,MAAMC,QAAQ,GAAG,GAAG;AACpB,MAAMC,QAAQ,GAAG,GAAG;AACpB,MAAMC,mBAAmB,GAAG,GAAG;AAC/B,MAAMC,gBAAgB,GAAI,GAAEF,QAAS,KAAI;AAEzC,MAAMG,QAAQ,GAAGC,IAAI,IAAK,GAAET,OAAO,CAACU,MAAM,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,KAAM,GAAER,QAAS,GAAEK,IAAK,GAAEH,mBAAoB,EAAC;AACnG,MAAMO,iBAAiB,GAAGC,GAAG,IAAK,GAAEd,OAAO,CAACU,MAAM,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,KAAM,GAAEL,gBAAiB,GAAEO,GAAI,GAAEX,gBAAiB,EAAC;;AAE/G;AACA;AACA,MAAMY,WAAW,GAAGC,MAAM,IAAIA,MAAM,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,SAAS,IAAIvB,WAAW,CAACuB,SAAS,CAAC,CAAC;;AAExF;AACA;AACA,MAAMC,QAAQ,GAAGA,CAACC,IAAI,EAAEC,IAAI,EAAEC,OAAO,KAAK;EACzC,MAAMC,UAAU,GAAG,CAAC,GAAGF,IAAI,CAAC;EAE5B,IAAIG,cAAc,GAAG,KAAK;EAC1B,IAAIC,kBAAkB,GAAG,KAAK;EAC9B,IAAIC,OAAO,GAAG/B,WAAW,CAACE,SAAS,CAACuB,IAAI,CAACA,IAAI,CAACO,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;EAE3D,KAAK,MAAM,CAACC,KAAK,EAAEV,SAAS,CAAC,IAAIK,UAAU,CAACM,OAAO,CAAC,CAAC,EAAE;IACtD,MAAMC,eAAe,GAAGnC,WAAW,CAACuB,SAAS,CAAC;IAE9C,IAAIQ,OAAO,GAAGI,eAAe,IAAIR,OAAO,EAAE;MACzCF,IAAI,CAACA,IAAI,CAACO,MAAM,GAAG,CAAC,CAAC,IAAIT,SAAS;IACnC,CAAC,MAAM;MACNE,IAAI,CAACW,IAAI,CAACb,SAAS,CAAC;MACpBQ,OAAO,GAAG,CAAC;IACZ;IAEA,IAAI3B,OAAO,CAACiC,GAAG,CAACd,SAAS,CAAC,EAAE;MAC3BM,cAAc,GAAG,IAAI;MACrBC,kBAAkB,GAAGF,UAAU,CAACU,KAAK,CAACL,KAAK,GAAG,CAAC,CAAC,CAACM,IAAI,CAAC,EAAE,CAAC,CAACC,UAAU,CAAC7B,gBAAgB,CAAC;IACvF;IAEA,IAAIkB,cAAc,EAAE;MACnB,IAAIC,kBAAkB,EAAE;QACvB,IAAIP,SAAS,KAAKhB,gBAAgB,EAAE;UACnCsB,cAAc,GAAG,KAAK;UACtBC,kBAAkB,GAAG,KAAK;QAC3B;MACD,CAAC,MAAM,IAAIP,SAAS,KAAKb,mBAAmB,EAAE;QAC7CmB,cAAc,GAAG,KAAK;MACvB;MAEA;IACD;IAEAE,OAAO,IAAII,eAAe;IAE1B,IAAIJ,OAAO,KAAKJ,OAAO,IAAIM,KAAK,GAAGL,UAAU,CAACI,MAAM,GAAG,CAAC,EAAE;MACzDP,IAAI,CAACW,IAAI,CAAC,EAAE,CAAC;MACbL,OAAO,GAAG,CAAC;IACZ;EACD;;EAEA;EACA;EACA,IAAI,CAACA,OAAO,IAAIN,IAAI,CAACA,IAAI,CAACO,MAAM,GAAG,CAAC,CAAC,CAACA,MAAM,GAAG,CAAC,IAAIP,IAAI,CAACO,MAAM,GAAG,CAAC,EAAE;IACpEP,IAAI,CAACA,IAAI,CAACO,MAAM,GAAG,CAAC,CAAC,IAAIP,IAAI,CAACgB,GAAG,CAAC,CAAC;EACpC;AACD,CAAC;;AAED;AACA,MAAMC,4BAA4B,GAAGtB,MAAM,IAAI;EAC9C,MAAMuB,KAAK,GAAGvB,MAAM,CAACC,KAAK,CAAC,GAAG,CAAC;EAC/B,IAAIuB,IAAI,GAAGD,KAAK,CAACX,MAAM;EAEvB,OAAOY,IAAI,GAAG,CAAC,EAAE;IAChB,IAAI5C,WAAW,CAAC2C,KAAK,CAACC,IAAI,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;MACrC;IACD;IAEAA,IAAI,EAAE;EACP;EAEA,IAAIA,IAAI,KAAKD,KAAK,CAACX,MAAM,EAAE;IAC1B,OAAOZ,MAAM;EACd;EAEA,OAAOuB,KAAK,CAACL,KAAK,CAAC,CAAC,EAAEM,IAAI,CAAC,CAACL,IAAI,CAAC,GAAG,CAAC,GAAGI,KAAK,CAACL,KAAK,CAACM,IAAI,CAAC,CAACL,IAAI,CAAC,EAAE,CAAC;AACnE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMM,IAAI,GAAGA,CAACzB,MAAM,EAAEO,OAAO,EAAEmB,OAAO,GAAG,CAAC,CAAC,KAAK;EAC/C,IAAIA,OAAO,CAACC,IAAI,KAAK,KAAK,IAAI3B,MAAM,CAAC2B,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;IACnD,OAAO,EAAE;EACV;EAEA,IAAIC,WAAW,GAAG,EAAE;EACpB,IAAIC,UAAU;EACd,IAAIC,SAAS;EAEb,MAAMC,OAAO,GAAGhC,WAAW,CAACC,MAAM,CAAC;EACnC,IAAIK,IAAI,GAAG,CAAC,EAAE,CAAC;EAEf,KAAK,MAAM,CAACQ,KAAK,EAAEP,IAAI,CAAC,IAAIN,MAAM,CAACC,KAAK,CAAC,GAAG,CAAC,CAACa,OAAO,CAAC,CAAC,EAAE;IACxD,IAAIY,OAAO,CAACC,IAAI,KAAK,KAAK,EAAE;MAC3BtB,IAAI,CAACA,IAAI,CAACO,MAAM,GAAG,CAAC,CAAC,GAAGP,IAAI,CAACA,IAAI,CAACO,MAAM,GAAG,CAAC,CAAC,CAACoB,SAAS,CAAC,CAAC;IAC1D;IAEA,IAAIC,SAAS,GAAGrD,WAAW,CAACyB,IAAI,CAACA,IAAI,CAACO,MAAM,GAAG,CAAC,CAAC,CAAC;IAElD,IAAIC,KAAK,KAAK,CAAC,EAAE;MAChB,IAAIoB,SAAS,IAAI1B,OAAO,KAAKmB,OAAO,CAACQ,QAAQ,KAAK,KAAK,IAAIR,OAAO,CAACC,IAAI,KAAK,KAAK,CAAC,EAAE;QACnF;QACAtB,IAAI,CAACW,IAAI,CAAC,EAAE,CAAC;QACbiB,SAAS,GAAG,CAAC;MACd;MAEA,IAAIA,SAAS,GAAG,CAAC,IAAIP,OAAO,CAACC,IAAI,KAAK,KAAK,EAAE;QAC5CtB,IAAI,CAACA,IAAI,CAACO,MAAM,GAAG,CAAC,CAAC,IAAI,GAAG;QAC5BqB,SAAS,EAAE;MACZ;IACD;;IAEA;IACA,IAAIP,OAAO,CAACS,IAAI,IAAIJ,OAAO,CAAClB,KAAK,CAAC,GAAGN,OAAO,EAAE;MAC7C,MAAM6B,gBAAgB,GAAI7B,OAAO,GAAG0B,SAAU;MAC9C,MAAMI,sBAAsB,GAAG,CAAC,GAAGC,IAAI,CAACC,KAAK,CAAC,CAACR,OAAO,CAAClB,KAAK,CAAC,GAAGuB,gBAAgB,GAAG,CAAC,IAAI7B,OAAO,CAAC;MAChG,MAAMiC,sBAAsB,GAAGF,IAAI,CAACC,KAAK,CAAC,CAACR,OAAO,CAAClB,KAAK,CAAC,GAAG,CAAC,IAAIN,OAAO,CAAC;MACzE,IAAIiC,sBAAsB,GAAGH,sBAAsB,EAAE;QACpDhC,IAAI,CAACW,IAAI,CAAC,EAAE,CAAC;MACd;MAEAZ,QAAQ,CAACC,IAAI,EAAEC,IAAI,EAAEC,OAAO,CAAC;MAC7B;IACD;IAEA,IAAI0B,SAAS,GAAGF,OAAO,CAAClB,KAAK,CAAC,GAAGN,OAAO,IAAI0B,SAAS,GAAG,CAAC,IAAIF,OAAO,CAAClB,KAAK,CAAC,GAAG,CAAC,EAAE;MAChF,IAAIa,OAAO,CAACQ,QAAQ,KAAK,KAAK,IAAID,SAAS,GAAG1B,OAAO,EAAE;QACtDH,QAAQ,CAACC,IAAI,EAAEC,IAAI,EAAEC,OAAO,CAAC;QAC7B;MACD;MAEAF,IAAI,CAACW,IAAI,CAAC,EAAE,CAAC;IACd;IAEA,IAAIiB,SAAS,GAAGF,OAAO,CAAClB,KAAK,CAAC,GAAGN,OAAO,IAAImB,OAAO,CAACQ,QAAQ,KAAK,KAAK,EAAE;MACvE9B,QAAQ,CAACC,IAAI,EAAEC,IAAI,EAAEC,OAAO,CAAC;MAC7B;IACD;IAEAF,IAAI,CAACA,IAAI,CAACO,MAAM,GAAG,CAAC,CAAC,IAAIN,IAAI;EAC9B;EAEA,IAAIoB,OAAO,CAACC,IAAI,KAAK,KAAK,EAAE;IAC3BtB,IAAI,GAAGA,IAAI,CAACH,GAAG,CAACoB,4BAA4B,CAAC;EAC9C;EAEA,MAAMmB,GAAG,GAAG,CAAC,GAAGpC,IAAI,CAACc,IAAI,CAAC,IAAI,CAAC,CAAC;EAEhC,KAAK,MAAM,CAACN,KAAK,EAAEV,SAAS,CAAC,IAAIsC,GAAG,CAAC3B,OAAO,CAAC,CAAC,EAAE;IAC/Cc,WAAW,IAAIzB,SAAS;IAExB,IAAInB,OAAO,CAACiC,GAAG,CAACd,SAAS,CAAC,EAAE;MAC3B,MAAM;QAACuC;MAAM,CAAC,GAAG,IAAIC,MAAM,CAAE,QAAOvD,QAAS,oBAAmBG,gBAAiB,aAAYJ,gBAAiB,GAAE,CAAC,CAACsC,IAAI,CAACgB,GAAG,CAACvB,KAAK,CAACL,KAAK,CAAC,CAACM,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI;QAACuB,MAAM,EAAE,CAAC;MAAC,CAAC;MACjK,IAAIA,MAAM,CAACjD,IAAI,KAAKmD,SAAS,EAAE;QAC9B,MAAMnD,IAAI,GAAGoD,MAAM,CAACC,UAAU,CAACJ,MAAM,CAACjD,IAAI,CAAC;QAC3CoC,UAAU,GAAGpC,IAAI,KAAKP,QAAQ,GAAG0D,SAAS,GAAGnD,IAAI;MAClD,CAAC,MAAM,IAAIiD,MAAM,CAAC5C,GAAG,KAAK8C,SAAS,EAAE;QACpCd,SAAS,GAAGY,MAAM,CAAC5C,GAAG,CAACc,MAAM,KAAK,CAAC,GAAGgC,SAAS,GAAGF,MAAM,CAAC5C,GAAG;MAC7D;IACD;IAEA,MAAML,IAAI,GAAGV,UAAU,CAACgE,KAAK,CAACC,GAAG,CAACH,MAAM,CAAChB,UAAU,CAAC,CAAC;IAErD,IAAIY,GAAG,CAAC5B,KAAK,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;MAC5B,IAAIiB,SAAS,EAAE;QACdF,WAAW,IAAI/B,iBAAiB,CAAC,EAAE,CAAC;MACrC;MAEA,IAAIgC,UAAU,IAAIpC,IAAI,EAAE;QACvBmC,WAAW,IAAIpC,QAAQ,CAACC,IAAI,CAAC;MAC9B;IACD,CAAC,MAAM,IAAIU,SAAS,KAAK,IAAI,EAAE;MAC9B,IAAI0B,UAAU,IAAIpC,IAAI,EAAE;QACvBmC,WAAW,IAAIpC,QAAQ,CAACqC,UAAU,CAAC;MACpC;MAEA,IAAIC,SAAS,EAAE;QACdF,WAAW,IAAI/B,iBAAiB,CAACiC,SAAS,CAAC;MAC5C;IACD;EACD;EAEA,OAAOF,WAAW;AACnB,CAAC;;AAED;AACAqB,MAAM,CAACC,OAAO,GAAG,CAAClD,MAAM,EAAEO,OAAO,EAAEmB,OAAO,KAAK;EAC9C,OAAOyB,MAAM,CAACnD,MAAM,CAAC,CACnBoD,SAAS,CAAC,CAAC,CACXC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CACtBpD,KAAK,CAAC,IAAI,CAAC,CACXC,GAAG,CAACoD,IAAI,IAAI7B,IAAI,CAAC6B,IAAI,EAAE/C,OAAO,EAAEmB,OAAO,CAAC,CAAC,CACzCP,IAAI,CAAC,IAAI,CAAC;AACb,CAAC"}},"mtime":1674865326386},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\escalade@3.1.1\\\\node_modules\\\\escalade\\\\sync\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\escalade@3.1.1\\\\node_modules\\\\escalade\\\\sync\\\\index.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"\"use strict\";\n\nconst {\n  dirname,\n  resolve\n} = require('path');\nconst {\n  readdirSync,\n  statSync\n} = require('fs');\nmodule.exports = function (start, callback) {\n  let dir = resolve('.', start);\n  let tmp,\n    stats = statSync(dir);\n  if (!stats.isDirectory()) {\n    dir = dirname(dir);\n  }\n  while (true) {\n    tmp = callback(dir, readdirSync(dir));\n    if (tmp) return resolve(dir, tmp);\n    dir = dirname(tmp = dir);\n    if (tmp === dir) break;\n  }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkaXJuYW1lIiwicmVzb2x2ZSIsInJlcXVpcmUiLCJyZWFkZGlyU3luYyIsInN0YXRTeW5jIiwibW9kdWxlIiwiZXhwb3J0cyIsInN0YXJ0IiwiY2FsbGJhY2siLCJkaXIiLCJ0bXAiLCJzdGF0cyIsImlzRGlyZWN0b3J5Il0sInNvdXJjZVJvb3QiOiJDOlxcY29kZVxcRmx1aWRGcmFtZXdvcms1XFxub2RlX21vZHVsZXNcXC5wbnBtXFxlc2NhbGFkZUAzLjEuMVxcbm9kZV9tb2R1bGVzXFxlc2NhbGFkZVxcc3luY1xcIiwic291cmNlcyI6WyJpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGRpcm5hbWUsIHJlc29sdmUgfSA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHsgcmVhZGRpclN5bmMsIHN0YXRTeW5jIH0gPSByZXF1aXJlKCdmcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdGFydCwgY2FsbGJhY2spIHtcblx0bGV0IGRpciA9IHJlc29sdmUoJy4nLCBzdGFydCk7XG5cdGxldCB0bXAsIHN0YXRzID0gc3RhdFN5bmMoZGlyKTtcblxuXHRpZiAoIXN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcblx0XHRkaXIgPSBkaXJuYW1lKGRpcik7XG5cdH1cblxuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdHRtcCA9IGNhbGxiYWNrKGRpciwgcmVhZGRpclN5bmMoZGlyKSk7XG5cdFx0aWYgKHRtcCkgcmV0dXJuIHJlc29sdmUoZGlyLCB0bXApO1xuXHRcdGRpciA9IGRpcm5hbWUodG1wID0gZGlyKTtcblx0XHRpZiAodG1wID09PSBkaXIpIGJyZWFrO1xuXHR9XG59XG4iXSwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTTtFQUFFQSxPQUFPO0VBQUVDO0FBQVEsQ0FBQyxHQUFHQyxPQUFPLENBQUMsTUFBTSxDQUFDO0FBQzVDLE1BQU07RUFBRUMsV0FBVztFQUFFQztBQUFTLENBQUMsR0FBR0YsT0FBTyxDQUFDLElBQUksQ0FBQztBQUUvQ0csTUFBTSxDQUFDQyxPQUFPLEdBQUcsVUFBVUMsS0FBSyxFQUFFQyxRQUFRLEVBQUU7RUFDM0MsSUFBSUMsR0FBRyxHQUFHUixPQUFPLENBQUMsR0FBRyxFQUFFTSxLQUFLLENBQUM7RUFDN0IsSUFBSUcsR0FBRztJQUFFQyxLQUFLLEdBQUdQLFFBQVEsQ0FBQ0ssR0FBRyxDQUFDO0VBRTlCLElBQUksQ0FBQ0UsS0FBSyxDQUFDQyxXQUFXLENBQUMsQ0FBQyxFQUFFO0lBQ3pCSCxHQUFHLEdBQUdULE9BQU8sQ0FBQ1MsR0FBRyxDQUFDO0VBQ25CO0VBRUEsT0FBTyxJQUFJLEVBQUU7SUFDWkMsR0FBRyxHQUFHRixRQUFRLENBQUNDLEdBQUcsRUFBRU4sV0FBVyxDQUFDTSxHQUFHLENBQUMsQ0FBQztJQUNyQyxJQUFJQyxHQUFHLEVBQUUsT0FBT1QsT0FBTyxDQUFDUSxHQUFHLEVBQUVDLEdBQUcsQ0FBQztJQUNqQ0QsR0FBRyxHQUFHVCxPQUFPLENBQUNVLEdBQUcsR0FBR0QsR0FBRyxDQUFDO0lBQ3hCLElBQUlDLEdBQUcsS0FBS0QsR0FBRyxFQUFFO0VBQ2xCO0FBQ0QsQ0FBQyJ9","map":{"version":3,"names":["dirname","resolve","require","readdirSync","statSync","module","exports","start","callback","dir","tmp","stats","isDirectory"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\escalade@3.1.1\\node_modules\\escalade\\sync\\","sources":["index.js"],"sourcesContent":["const { dirname, resolve } = require('path');\nconst { readdirSync, statSync } = require('fs');\n\nmodule.exports = function (start, callback) {\n\tlet dir = resolve('.', start);\n\tlet tmp, stats = statSync(dir);\n\n\tif (!stats.isDirectory()) {\n\t\tdir = dirname(dir);\n\t}\n\n\twhile (true) {\n\t\ttmp = callback(dir, readdirSync(dir));\n\t\tif (tmp) return resolve(dir, tmp);\n\t\tdir = dirname(tmp = dir);\n\t\tif (tmp === dir) break;\n\t}\n}\n"],"mappings":";;AAAA,MAAM;EAAEA,OAAO;EAAEC;AAAQ,CAAC,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC5C,MAAM;EAAEC,WAAW;EAAEC;AAAS,CAAC,GAAGF,OAAO,CAAC,IAAI,CAAC;AAE/CG,MAAM,CAACC,OAAO,GAAG,UAAUC,KAAK,EAAEC,QAAQ,EAAE;EAC3C,IAAIC,GAAG,GAAGR,OAAO,CAAC,GAAG,EAAEM,KAAK,CAAC;EAC7B,IAAIG,GAAG;IAAEC,KAAK,GAAGP,QAAQ,CAACK,GAAG,CAAC;EAE9B,IAAI,CAACE,KAAK,CAACC,WAAW,CAAC,CAAC,EAAE;IACzBH,GAAG,GAAGT,OAAO,CAACS,GAAG,CAAC;EACnB;EAEA,OAAO,IAAI,EAAE;IACZC,GAAG,GAAGF,QAAQ,CAACC,GAAG,EAAEN,WAAW,CAACM,GAAG,CAAC,CAAC;IACrC,IAAIC,GAAG,EAAE,OAAOT,OAAO,CAACQ,GAAG,EAAEC,GAAG,CAAC;IACjCD,GAAG,GAAGT,OAAO,CAACU,GAAG,GAAGD,GAAG,CAAC;IACxB,IAAIC,GAAG,KAAKD,GAAG,EAAE;EAClB;AACD,CAAC"}},"mtime":1674865335172},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\get-caller-file@2.0.5\\\\node_modules\\\\get-caller-file\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\get-caller-file@2.0.5\\\\node_modules\\\\get-caller-file\\\\index.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"\"use strict\";\n\n// Call this function in a another function to find out the file from\n// which that function was called from. (Inspects the v8 stack trace)\n//\n// Inspired by http://stackoverflow.com/questions/13227489\nmodule.exports = function getCallerFile(position) {\n  if (position === void 0) {\n    position = 2;\n  }\n  if (position >= Error.stackTraceLimit) {\n    throw new TypeError('getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `' + position + '` and Error.stackTraceLimit was: `' + Error.stackTraceLimit + '`');\n  }\n  var oldPrepareStackTrace = Error.prepareStackTrace;\n  Error.prepareStackTrace = function (_, stack) {\n    return stack;\n  };\n  var stack = new Error().stack;\n  Error.prepareStackTrace = oldPrepareStackTrace;\n  if (stack !== null && typeof stack === 'object') {\n    // stack[0] holds this file\n    // stack[1] holds where this function was called\n    // stack[2] holds the file we're interested in\n    return stack[position] ? stack[position].getFileName() : undefined;\n  }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZ2V0Q2FsbGVyRmlsZSIsInBvc2l0aW9uIiwiRXJyb3IiLCJzdGFja1RyYWNlTGltaXQiLCJUeXBlRXJyb3IiLCJvbGRQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwiXyIsInN0YWNrIiwiZ2V0RmlsZU5hbWUiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IkM6XFxjb2RlXFxGbHVpZEZyYW1ld29yazVcXG5vZGVfbW9kdWxlc1xcLnBucG1cXGdldC1jYWxsZXItZmlsZUAyLjAuNVxcbm9kZV9tb2R1bGVzXFxnZXQtY2FsbGVyLWZpbGVcXCIsInNvdXJjZXMiOlsiaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOltudWxsXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQUEsTUFBQSxDQUFBQyxPQUFBLEdBQVMsU0FBU0MsYUFBYUEsQ0FBQ0MsUUFBWTtFQUFaLElBQUFBLFFBQUE7SUFBQUEsUUFBQSxJQUFZO0VBQUE7RUFDMUMsSUFBSUEsUUFBUSxJQUFJQyxLQUFLLENBQUNDLGVBQWUsRUFBRTtJQUNyQyxNQUFNLElBQUlDLFNBQVMsQ0FBQyxrR0FBa0csR0FBR0gsUUFBUSxHQUFHLG9DQUFvQyxHQUFHQyxLQUFLLENBQUNDLGVBQWUsR0FBRyxHQUFHLENBQUM7O0VBR3pNLElBQU1FLG9CQUFvQixHQUFHSCxLQUFLLENBQUNJLGlCQUFpQjtFQUNwREosS0FBSyxDQUFDSSxpQkFBaUIsR0FBRyxVQUFDQyxDQUFDLEVBQUVDLEtBQUs7SUFBTSxPQUFBQSxLQUFLO0VBQUwsQ0FBSztFQUM5QyxJQUFNQSxLQUFLLEdBQUcsSUFBSU4sS0FBSyxFQUFFLENBQUNNLEtBQUs7RUFDL0JOLEtBQUssQ0FBQ0ksaUJBQWlCLEdBQUdELG9CQUFvQjtFQUc5QyxJQUFJRyxLQUFLLEtBQUssSUFBSSxJQUFJLE9BQU9BLEtBQUssS0FBSyxRQUFRLEVBQUU7SUFDL0M7SUFDQTtJQUNBO0lBQ0EsT0FBT0EsS0FBSyxDQUFDUCxRQUFRLENBQUMsR0FBSU8sS0FBSyxDQUFDUCxRQUFRLENBQVMsQ0FBQ1EsV0FBVyxFQUFFLEdBQUdDLFNBQVM7O0FBRS9FLENBQUMifQ==","map":{"version":3,"names":["module","exports","getCallerFile","position","Error","stackTraceLimit","TypeError","oldPrepareStackTrace","prepareStackTrace","_","stack","getFileName","undefined"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\get-caller-file@2.0.5\\node_modules\\get-caller-file\\","sources":["index.ts"],"sourcesContent":[null],"mappings":";;AAAA;AACA;AACA;AACA;AAEAA,MAAA,CAAAC,OAAA,GAAS,SAASC,aAAaA,CAACC,QAAY;EAAZ,IAAAA,QAAA;IAAAA,QAAA,IAAY;EAAA;EAC1C,IAAIA,QAAQ,IAAIC,KAAK,CAACC,eAAe,EAAE;IACrC,MAAM,IAAIC,SAAS,CAAC,kGAAkG,GAAGH,QAAQ,GAAG,oCAAoC,GAAGC,KAAK,CAACC,eAAe,GAAG,GAAG,CAAC;;EAGzM,IAAME,oBAAoB,GAAGH,KAAK,CAACI,iBAAiB;EACpDJ,KAAK,CAACI,iBAAiB,GAAG,UAACC,CAAC,EAAEC,KAAK;IAAM,OAAAA,KAAK;EAAL,CAAK;EAC9C,IAAMA,KAAK,GAAG,IAAIN,KAAK,EAAE,CAACM,KAAK;EAC/BN,KAAK,CAACI,iBAAiB,GAAGD,oBAAoB;EAG9C,IAAIG,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC/C;IACA;IACA;IACA,OAAOA,KAAK,CAACP,QAAQ,CAAC,GAAIO,KAAK,CAACP,QAAQ,CAAS,CAACQ,WAAW,EAAE,GAAGC,SAAS;;AAE/E,CAAC"}},"mtime":1674865325026},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\require-directory@2.1.1\\\\node_modules\\\\require-directory\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\require-directory@2.1.1\\\\node_modules\\\\require-directory\\\\index.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"'use strict';\n\nvar fs = require('fs'),\n  join = require('path').join,\n  resolve = require('path').resolve,\n  dirname = require('path').dirname,\n  defaultOptions = {\n    extensions: ['js', 'json', 'coffee'],\n    recurse: true,\n    rename: function (name) {\n      return name;\n    },\n    visit: function (obj) {\n      return obj;\n    }\n  };\nfunction checkFileInclusion(path, filename, options) {\n  return (\n    // verify file has valid extension\n    new RegExp('\\\\.(' + options.extensions.join('|') + ')$', 'i').test(filename) &&\n    // if options.include is a RegExp, evaluate it and make sure the path passes\n    !(options.include && options.include instanceof RegExp && !options.include.test(path)) &&\n    // if options.include is a function, evaluate it and make sure the path passes\n    !(options.include && typeof options.include === 'function' && !options.include(path, filename)) &&\n    // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass\n    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) &&\n    // if options.exclude is a function, evaluate it and make sure the path doesn't pass\n    !(options.exclude && typeof options.exclude === 'function' && options.exclude(path, filename))\n  );\n}\nfunction requireDirectory(m, path, options) {\n  var retval = {};\n\n  // path is optional\n  if (path && !options && typeof path !== 'string') {\n    options = path;\n    path = null;\n  }\n\n  // default options\n  options = options || {};\n  for (var prop in defaultOptions) {\n    if (typeof options[prop] === 'undefined') {\n      options[prop] = defaultOptions[prop];\n    }\n  }\n\n  // if no path was passed in, assume the equivelant of __dirname from caller\n  // otherwise, resolve path relative to the equivalent of __dirname\n  path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);\n\n  // get the path of each file in specified directory, append to current tree node, recurse\n  fs.readdirSync(path).forEach(function (filename) {\n    var joined = join(path, filename),\n      files,\n      key,\n      obj;\n    if (fs.statSync(joined).isDirectory() && options.recurse) {\n      // this node is a directory; recurse\n      files = requireDirectory(m, joined, options);\n      // exclude empty directories\n      if (Object.keys(files).length) {\n        retval[options.rename(filename, joined, filename)] = files;\n      }\n    } else {\n      if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {\n        // hash node key shouldn't include file extension\n        key = filename.substring(0, filename.lastIndexOf('.'));\n        obj = m.require(joined);\n        retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;\n      }\n    }\n  });\n  return retval;\n}\nmodule.exports = requireDirectory;\nmodule.exports.defaults = defaultOptions;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJqb2luIiwicmVzb2x2ZSIsImRpcm5hbWUiLCJkZWZhdWx0T3B0aW9ucyIsImV4dGVuc2lvbnMiLCJyZWN1cnNlIiwicmVuYW1lIiwibmFtZSIsInZpc2l0Iiwib2JqIiwiY2hlY2tGaWxlSW5jbHVzaW9uIiwicGF0aCIsImZpbGVuYW1lIiwib3B0aW9ucyIsIlJlZ0V4cCIsInRlc3QiLCJpbmNsdWRlIiwiZXhjbHVkZSIsInJlcXVpcmVEaXJlY3RvcnkiLCJtIiwicmV0dmFsIiwicHJvcCIsInJlYWRkaXJTeW5jIiwiZm9yRWFjaCIsImpvaW5lZCIsImZpbGVzIiwia2V5Iiwic3RhdFN5bmMiLCJpc0RpcmVjdG9yeSIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZWZhdWx0cyJdLCJzb3VyY2VSb290IjoiQzpcXGNvZGVcXEZsdWlkRnJhbWV3b3JrNVxcbm9kZV9tb2R1bGVzXFwucG5wbVxccmVxdWlyZS1kaXJlY3RvcnlAMi4xLjFcXG5vZGVfbW9kdWxlc1xccmVxdWlyZS1kaXJlY3RvcnlcXCIsInNvdXJjZXMiOlsiaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpLFxuICBqb2luID0gcmVxdWlyZSgncGF0aCcpLmpvaW4sXG4gIHJlc29sdmUgPSByZXF1aXJlKCdwYXRoJykucmVzb2x2ZSxcbiAgZGlybmFtZSA9IHJlcXVpcmUoJ3BhdGgnKS5kaXJuYW1lLFxuICBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBleHRlbnNpb25zOiBbJ2pzJywgJ2pzb24nLCAnY29mZmVlJ10sXG4gICAgcmVjdXJzZTogdHJ1ZSxcbiAgICByZW5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9LFxuICAgIHZpc2l0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfTtcblxuZnVuY3Rpb24gY2hlY2tGaWxlSW5jbHVzaW9uKHBhdGgsIGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gIHJldHVybiAoXG4gICAgLy8gdmVyaWZ5IGZpbGUgaGFzIHZhbGlkIGV4dGVuc2lvblxuICAgIChuZXcgUmVnRXhwKCdcXFxcLignICsgb3B0aW9ucy5leHRlbnNpb25zLmpvaW4oJ3wnKSArICcpJCcsICdpJykudGVzdChmaWxlbmFtZSkpICYmXG5cbiAgICAvLyBpZiBvcHRpb25zLmluY2x1ZGUgaXMgYSBSZWdFeHAsIGV2YWx1YXRlIGl0IGFuZCBtYWtlIHN1cmUgdGhlIHBhdGggcGFzc2VzXG4gICAgIShvcHRpb25zLmluY2x1ZGUgJiYgb3B0aW9ucy5pbmNsdWRlIGluc3RhbmNlb2YgUmVnRXhwICYmICFvcHRpb25zLmluY2x1ZGUudGVzdChwYXRoKSkgJiZcblxuICAgIC8vIGlmIG9wdGlvbnMuaW5jbHVkZSBpcyBhIGZ1bmN0aW9uLCBldmFsdWF0ZSBpdCBhbmQgbWFrZSBzdXJlIHRoZSBwYXRoIHBhc3Nlc1xuICAgICEob3B0aW9ucy5pbmNsdWRlICYmIHR5cGVvZiBvcHRpb25zLmluY2x1ZGUgPT09ICdmdW5jdGlvbicgJiYgIW9wdGlvbnMuaW5jbHVkZShwYXRoLCBmaWxlbmFtZSkpICYmXG5cbiAgICAvLyBpZiBvcHRpb25zLmV4Y2x1ZGUgaXMgYSBSZWdFeHAsIGV2YWx1YXRlIGl0IGFuZCBtYWtlIHN1cmUgdGhlIHBhdGggZG9lc24ndCBwYXNzXG4gICAgIShvcHRpb25zLmV4Y2x1ZGUgJiYgb3B0aW9ucy5leGNsdWRlIGluc3RhbmNlb2YgUmVnRXhwICYmIG9wdGlvbnMuZXhjbHVkZS50ZXN0KHBhdGgpKSAmJlxuXG4gICAgLy8gaWYgb3B0aW9ucy5leGNsdWRlIGlzIGEgZnVuY3Rpb24sIGV2YWx1YXRlIGl0IGFuZCBtYWtlIHN1cmUgdGhlIHBhdGggZG9lc24ndCBwYXNzXG4gICAgIShvcHRpb25zLmV4Y2x1ZGUgJiYgdHlwZW9mIG9wdGlvbnMuZXhjbHVkZSA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zLmV4Y2x1ZGUocGF0aCwgZmlsZW5hbWUpKVxuICApO1xufVxuXG5mdW5jdGlvbiByZXF1aXJlRGlyZWN0b3J5KG0sIHBhdGgsIG9wdGlvbnMpIHtcbiAgdmFyIHJldHZhbCA9IHt9O1xuXG4gIC8vIHBhdGggaXMgb3B0aW9uYWxcbiAgaWYgKHBhdGggJiYgIW9wdGlvbnMgJiYgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHBhdGg7XG4gICAgcGF0aCA9IG51bGw7XG4gIH1cblxuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZvciAodmFyIHByb3AgaW4gZGVmYXVsdE9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNbcHJvcF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRpb25zW3Byb3BdID0gZGVmYXVsdE9wdGlvbnNbcHJvcF07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgbm8gcGF0aCB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhlIGVxdWl2ZWxhbnQgb2YgX19kaXJuYW1lIGZyb20gY2FsbGVyXG4gIC8vIG90aGVyd2lzZSwgcmVzb2x2ZSBwYXRoIHJlbGF0aXZlIHRvIHRoZSBlcXVpdmFsZW50IG9mIF9fZGlybmFtZVxuICBwYXRoID0gIXBhdGggPyBkaXJuYW1lKG0uZmlsZW5hbWUpIDogcmVzb2x2ZShkaXJuYW1lKG0uZmlsZW5hbWUpLCBwYXRoKTtcblxuICAvLyBnZXQgdGhlIHBhdGggb2YgZWFjaCBmaWxlIGluIHNwZWNpZmllZCBkaXJlY3RvcnksIGFwcGVuZCB0byBjdXJyZW50IHRyZWUgbm9kZSwgcmVjdXJzZVxuICBmcy5yZWFkZGlyU3luYyhwYXRoKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuICAgIHZhciBqb2luZWQgPSBqb2luKHBhdGgsIGZpbGVuYW1lKSxcbiAgICAgIGZpbGVzLFxuICAgICAga2V5LFxuICAgICAgb2JqO1xuXG4gICAgaWYgKGZzLnN0YXRTeW5jKGpvaW5lZCkuaXNEaXJlY3RvcnkoKSAmJiBvcHRpb25zLnJlY3Vyc2UpIHtcbiAgICAgIC8vIHRoaXMgbm9kZSBpcyBhIGRpcmVjdG9yeTsgcmVjdXJzZVxuICAgICAgZmlsZXMgPSByZXF1aXJlRGlyZWN0b3J5KG0sIGpvaW5lZCwgb3B0aW9ucyk7XG4gICAgICAvLyBleGNsdWRlIGVtcHR5IGRpcmVjdG9yaWVzXG4gICAgICBpZiAoT2JqZWN0LmtleXMoZmlsZXMpLmxlbmd0aCkge1xuICAgICAgICByZXR2YWxbb3B0aW9ucy5yZW5hbWUoZmlsZW5hbWUsIGpvaW5lZCwgZmlsZW5hbWUpXSA9IGZpbGVzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoam9pbmVkICE9PSBtLmZpbGVuYW1lICYmIGNoZWNrRmlsZUluY2x1c2lvbihqb2luZWQsIGZpbGVuYW1lLCBvcHRpb25zKSkge1xuICAgICAgICAvLyBoYXNoIG5vZGUga2V5IHNob3VsZG4ndCBpbmNsdWRlIGZpbGUgZXh0ZW5zaW9uXG4gICAgICAgIGtleSA9IGZpbGVuYW1lLnN1YnN0cmluZygwLCBmaWxlbmFtZS5sYXN0SW5kZXhPZignLicpKTtcbiAgICAgICAgb2JqID0gbS5yZXF1aXJlKGpvaW5lZCk7XG4gICAgICAgIHJldHZhbFtvcHRpb25zLnJlbmFtZShrZXksIGpvaW5lZCwgZmlsZW5hbWUpXSA9IG9wdGlvbnMudmlzaXQob2JqLCBqb2luZWQsIGZpbGVuYW1lKSB8fCBvYmo7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmV0dmFsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVEaXJlY3Rvcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0cyA9IGRlZmF1bHRPcHRpb25zO1xuIl0sIm1hcHBpbmdzIjoiQUFBQSxZQUFZOztBQUVaLElBQUlBLEVBQUUsR0FBR0MsT0FBTyxDQUFDLElBQUksQ0FBQztF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","map":{"version":3,"names":["fs","require","join","resolve","dirname","defaultOptions","extensions","recurse","rename","name","visit","obj","checkFileInclusion","path","filename","options","RegExp","test","include","exclude","requireDirectory","m","retval","prop","readdirSync","forEach","joined","files","key","statSync","isDirectory","Object","keys","length","substring","lastIndexOf","module","exports","defaults"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\require-directory@2.1.1\\node_modules\\require-directory\\","sources":["index.js"],"sourcesContent":["'use strict';\n\nvar fs = require('fs'),\n  join = require('path').join,\n  resolve = require('path').resolve,\n  dirname = require('path').dirname,\n  defaultOptions = {\n    extensions: ['js', 'json', 'coffee'],\n    recurse: true,\n    rename: function (name) {\n      return name;\n    },\n    visit: function (obj) {\n      return obj;\n    }\n  };\n\nfunction checkFileInclusion(path, filename, options) {\n  return (\n    // verify file has valid extension\n    (new RegExp('\\\\.(' + options.extensions.join('|') + ')$', 'i').test(filename)) &&\n\n    // if options.include is a RegExp, evaluate it and make sure the path passes\n    !(options.include && options.include instanceof RegExp && !options.include.test(path)) &&\n\n    // if options.include is a function, evaluate it and make sure the path passes\n    !(options.include && typeof options.include === 'function' && !options.include(path, filename)) &&\n\n    // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass\n    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) &&\n\n    // if options.exclude is a function, evaluate it and make sure the path doesn't pass\n    !(options.exclude && typeof options.exclude === 'function' && options.exclude(path, filename))\n  );\n}\n\nfunction requireDirectory(m, path, options) {\n  var retval = {};\n\n  // path is optional\n  if (path && !options && typeof path !== 'string') {\n    options = path;\n    path = null;\n  }\n\n  // default options\n  options = options || {};\n  for (var prop in defaultOptions) {\n    if (typeof options[prop] === 'undefined') {\n      options[prop] = defaultOptions[prop];\n    }\n  }\n\n  // if no path was passed in, assume the equivelant of __dirname from caller\n  // otherwise, resolve path relative to the equivalent of __dirname\n  path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);\n\n  // get the path of each file in specified directory, append to current tree node, recurse\n  fs.readdirSync(path).forEach(function (filename) {\n    var joined = join(path, filename),\n      files,\n      key,\n      obj;\n\n    if (fs.statSync(joined).isDirectory() && options.recurse) {\n      // this node is a directory; recurse\n      files = requireDirectory(m, joined, options);\n      // exclude empty directories\n      if (Object.keys(files).length) {\n        retval[options.rename(filename, joined, filename)] = files;\n      }\n    } else {\n      if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {\n        // hash node key shouldn't include file extension\n        key = filename.substring(0, filename.lastIndexOf('.'));\n        obj = m.require(joined);\n        retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;\n      }\n    }\n  });\n\n  return retval;\n}\n\nmodule.exports = requireDirectory;\nmodule.exports.defaults = defaultOptions;\n"],"mappings":"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"}},"mtime":1674865325045},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf\\\\stores\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf\\\\stores\\\\env.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"\"use strict\";\n\n/*\n * env.js: Simple memory-based store for environment variables\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar util = require('util'),\n  common = require('../common'),\n  Memory = require('./memory').Memory;\n\n//\n// ### function Env (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Env nconf store, a simple abstraction\n// around the Memory store that can read process environment variables.\n//\nvar Env = exports.Env = function (options) {\n  Memory.call(this, options);\n  options = options || {};\n  this.type = 'env';\n  this.readOnly = true;\n  this.whitelist = options.whitelist || [];\n  this.separator = options.separator || '';\n  this.lowerCase = options.lowerCase || false;\n  this.parseValues = options.parseValues || false;\n  this.transform = options.transform || false;\n  if ({}.toString.call(options.match) === '[object RegExp]' && typeof options !== 'string') {\n    this.match = options.match;\n  }\n  if (options instanceof Array) {\n    this.whitelist = options;\n  }\n  if (typeof options === 'string' || options instanceof RegExp) {\n    this.separator = options;\n  }\n};\n\n// Inherit from the Memory store\nutil.inherits(Env, Memory);\n\n//\n// ### function loadSync ()\n// Loads the data passed in from `process.env` into this instance.\n//\nEnv.prototype.loadSync = function () {\n  this.loadEnv();\n  return this.store;\n};\n\n//\n// ### function loadEnv ()\n// Loads the data passed in from `process.env` into this instance.\n//\nEnv.prototype.loadEnv = function () {\n  var self = this;\n  var env = process.env;\n  if (this.lowerCase) {\n    env = {};\n    Object.keys(process.env).forEach(function (key) {\n      env[key.toLowerCase()] = process.env[key];\n    });\n  }\n  if (this.transform) {\n    env = common.transform(env, this.transform);\n  }\n  this.readOnly = false;\n  Object.keys(env).filter(function (key) {\n    if (self.match && self.whitelist.length) {\n      return key.match(self.match) || self.whitelist.indexOf(key) !== -1;\n    } else if (self.match) {\n      return key.match(self.match);\n    } else {\n      return !self.whitelist.length || self.whitelist.indexOf(key) !== -1;\n    }\n  }).forEach(function (key) {\n    var val = env[key];\n    if (self.parseValues) {\n      val = common.parseValues(val);\n    }\n    if (self.separator) {\n      self.set(common.key.apply(common, key.split(self.separator)), val);\n    } else {\n      self.set(key, val);\n    }\n  });\n  this.readOnly = true;\n  return this.store;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsImNvbW1vbiIsIk1lbW9yeSIsIkVudiIsImV4cG9ydHMiLCJvcHRpb25zIiwiY2FsbCIsInR5cGUiLCJyZWFkT25seSIsIndoaXRlbGlzdCIsInNlcGFyYXRvciIsImxvd2VyQ2FzZSIsInBhcnNlVmFsdWVzIiwidHJhbnNmb3JtIiwidG9TdHJpbmciLCJtYXRjaCIsIkFycmF5IiwiUmVnRXhwIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJsb2FkU3luYyIsImxvYWRFbnYiLCJzdG9yZSIsInNlbGYiLCJlbnYiLCJwcm9jZXNzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsImZpbHRlciIsImxlbmd0aCIsImluZGV4T2YiLCJ2YWwiLCJzZXQiLCJhcHBseSIsInNwbGl0Il0sInNvdXJjZVJvb3QiOiJDOlxcY29kZVxcRmx1aWRGcmFtZXdvcms1XFxub2RlX21vZHVsZXNcXC5wbnBtXFxuY29uZkAwLjEyLjBcXG5vZGVfbW9kdWxlc1xcbmNvbmZcXGxpYlxcbmNvbmZcXHN0b3Jlc1xcIiwic291cmNlcyI6WyJlbnYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIGVudi5qczogU2ltcGxlIG1lbW9yeS1iYXNlZCBzdG9yZSBmb3IgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKlxuICogKEMpIDIwMTEsIENoYXJsaWUgUm9iYmlucyBhbmQgdGhlIENvbnRyaWJ1dG9ycy5cbiAqXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXG4gICAgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyksXG4gICAgTWVtb3J5ID0gcmVxdWlyZSgnLi9tZW1vcnknKS5NZW1vcnk7XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gRW52IChvcHRpb25zKVxuLy8gIyMjIyBAb3B0aW9ucyB7T2JqZWN0fSBPcHRpb25zIGZvciB0aGlzIGluc3RhbmNlLlxuLy8gQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBFbnYgbmNvbmYgc3RvcmUsIGEgc2ltcGxlIGFic3RyYWN0aW9uXG4vLyBhcm91bmQgdGhlIE1lbW9yeSBzdG9yZSB0aGF0IGNhbiByZWFkIHByb2Nlc3MgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuLy9cbnZhciBFbnYgPSBleHBvcnRzLkVudiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIE1lbW9yeS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIG9wdGlvbnMgICAgICAgID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy50eXBlICAgICAgPSAnZW52JztcbiAgdGhpcy5yZWFkT25seSAgPSB0cnVlO1xuICB0aGlzLndoaXRlbGlzdCA9IG9wdGlvbnMud2hpdGVsaXN0IHx8IFtdO1xuICB0aGlzLnNlcGFyYXRvciA9IG9wdGlvbnMuc2VwYXJhdG9yIHx8ICcnO1xuICB0aGlzLmxvd2VyQ2FzZSA9IG9wdGlvbnMubG93ZXJDYXNlIHx8IGZhbHNlO1xuICB0aGlzLnBhcnNlVmFsdWVzID0gb3B0aW9ucy5wYXJzZVZhbHVlcyB8fCBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybSB8fCBmYWxzZTtcblxuICBpZiAoKHt9KS50b1N0cmluZy5jYWxsKG9wdGlvbnMubWF0Y2gpID09PSAnW29iamVjdCBSZWdFeHBdJ1xuICAgICAgJiYgdHlwZW9mIG9wdGlvbnMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5tYXRjaCA9IG9wdGlvbnMubWF0Y2g7XG4gIH1cblxuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdGhpcy53aGl0ZWxpc3QgPSBvcHRpb25zO1xuICB9XG4gIGlmICh0eXBlb2Yob3B0aW9ucykgPT09ICdzdHJpbmcnIHx8IG9wdGlvbnMgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICB0aGlzLnNlcGFyYXRvciA9IG9wdGlvbnM7XG4gIH1cbn07XG5cbi8vIEluaGVyaXQgZnJvbSB0aGUgTWVtb3J5IHN0b3JlXG51dGlsLmluaGVyaXRzKEVudiwgTWVtb3J5KTtcblxuLy9cbi8vICMjIyBmdW5jdGlvbiBsb2FkU3luYyAoKVxuLy8gTG9hZHMgdGhlIGRhdGEgcGFzc2VkIGluIGZyb20gYHByb2Nlc3MuZW52YCBpbnRvIHRoaXMgaW5zdGFuY2UuXG4vL1xuRW52LnByb3RvdHlwZS5sb2FkU3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sb2FkRW52KCk7XG4gIHJldHVybiB0aGlzLnN0b3JlO1xufTtcblxuLy9cbi8vICMjIyBmdW5jdGlvbiBsb2FkRW52ICgpXG4vLyBMb2FkcyB0aGUgZGF0YSBwYXNzZWQgaW4gZnJvbSBgcHJvY2Vzcy5lbnZgIGludG8gdGhpcyBpbnN0YW5jZS5cbi8vXG5FbnYucHJvdG90eXBlLmxvYWRFbnYgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgZW52ID0gcHJvY2Vzcy5lbnY7XG5cbiAgaWYgKHRoaXMubG93ZXJDYXNlKSB7XG4gICAgZW52ID0ge307XG4gICAgT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgZW52W2tleS50b0xvd2VyQ2FzZSgpXSA9IHByb2Nlc3MuZW52W2tleV07XG4gICAgfSk7XG4gIH1cblxuICBpZiAodGhpcy50cmFuc2Zvcm0pIHtcbiAgICBlbnYgPSBjb21tb24udHJhbnNmb3JtKGVudiwgdGhpcy50cmFuc2Zvcm0pO1xuICB9XG5cbiAgdGhpcy5yZWFkT25seSA9IGZhbHNlO1xuICBPYmplY3Qua2V5cyhlbnYpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKHNlbGYubWF0Y2ggJiYgc2VsZi53aGl0ZWxpc3QubGVuZ3RoKSB7XG4gICAgICByZXR1cm4ga2V5Lm1hdGNoKHNlbGYubWF0Y2gpIHx8IHNlbGYud2hpdGVsaXN0LmluZGV4T2Yoa2V5KSAhPT0gLTFcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsZi5tYXRjaCkge1xuICAgICAgcmV0dXJuIGtleS5tYXRjaChzZWxmLm1hdGNoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gIXNlbGYud2hpdGVsaXN0Lmxlbmd0aCB8fCBzZWxmLndoaXRlbGlzdC5pbmRleE9mKGtleSkgIT09IC0xXG4gICAgfVxuICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBcbiAgICB2YXIgdmFsID0gZW52W2tleV07XG5cbiAgICBpZiAoc2VsZi5wYXJzZVZhbHVlcykge1xuICAgICAgdmFsID0gY29tbW9uLnBhcnNlVmFsdWVzKHZhbCk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuc2VwYXJhdG9yKSB7XG4gICAgICBzZWxmLnNldChjb21tb24ua2V5LmFwcGx5KGNvbW1vbiwga2V5LnNwbGl0KHNlbGYuc2VwYXJhdG9yKSksIHZhbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2VsZi5zZXQoa2V5LCB2YWwpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5yZWFkT25seSA9IHRydWU7XG4gIHJldHVybiB0aGlzLnN0b3JlO1xufTtcblxuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJQSxJQUFJLEdBQUdDLE9BQU8sQ0FBQyxNQUFNLENBQUM7RUFDdEJDLE1BQU0sR0FBR0QsT0FBTyxDQUFDLFdBQVcsQ0FBQztFQUM3QkUsTUFBTSxHQUFHRixPQUFPLENBQUMsVUFBVSxDQUFDLENBQUNFLE1BQU07O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUlDLEdBQUcsR0FBR0MsT0FBTyxDQUFDRCxHQUFHLEdBQUcsVUFBVUUsT0FBTyxFQUFFO0VBQ3pDSCxNQUFNLENBQUNJLElBQUksQ0FBQyxJQUFJLEVBQUVELE9BQU8sQ0FBQztFQUUxQkEsT0FBTyxHQUFVQSxPQUFPLElBQUksQ0FBQyxDQUFDO0VBQzlCLElBQUksQ0FBQ0UsSUFBSSxHQUFRLEtBQUs7RUFDdEIsSUFBSSxDQUFDQyxRQUFRLEdBQUksSUFBSTtFQUNyQixJQUFJ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","map":{"version":3,"names":["util","require","common","Memory","Env","exports","options","call","type","readOnly","whitelist","separator","lowerCase","parseValues","transform","toString","match","Array","RegExp","inherits","prototype","loadSync","loadEnv","store","self","env","process","Object","keys","forEach","key","toLowerCase","filter","length","indexOf","val","set","apply","split"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\nconf@0.12.0\\node_modules\\nconf\\lib\\nconf\\stores\\","sources":["env.js"],"sourcesContent":["/*\n * env.js: Simple memory-based store for environment variables\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar util = require('util'),\n    common = require('../common'),\n    Memory = require('./memory').Memory;\n\n//\n// ### function Env (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Env nconf store, a simple abstraction\n// around the Memory store that can read process environment variables.\n//\nvar Env = exports.Env = function (options) {\n  Memory.call(this, options);\n\n  options        = options || {};\n  this.type      = 'env';\n  this.readOnly  = true;\n  this.whitelist = options.whitelist || [];\n  this.separator = options.separator || '';\n  this.lowerCase = options.lowerCase || false;\n  this.parseValues = options.parseValues || false;\n  this.transform = options.transform || false;\n\n  if (({}).toString.call(options.match) === '[object RegExp]'\n      && typeof options !== 'string') {\n    this.match = options.match;\n  }\n\n  if (options instanceof Array) {\n    this.whitelist = options;\n  }\n  if (typeof(options) === 'string' || options instanceof RegExp) {\n    this.separator = options;\n  }\n};\n\n// Inherit from the Memory store\nutil.inherits(Env, Memory);\n\n//\n// ### function loadSync ()\n// Loads the data passed in from `process.env` into this instance.\n//\nEnv.prototype.loadSync = function () {\n  this.loadEnv();\n  return this.store;\n};\n\n//\n// ### function loadEnv ()\n// Loads the data passed in from `process.env` into this instance.\n//\nEnv.prototype.loadEnv = function () {\n  var self = this;\n\n  var env = process.env;\n\n  if (this.lowerCase) {\n    env = {};\n    Object.keys(process.env).forEach(function (key) {\n      env[key.toLowerCase()] = process.env[key];\n    });\n  }\n\n  if (this.transform) {\n    env = common.transform(env, this.transform);\n  }\n\n  this.readOnly = false;\n  Object.keys(env).filter(function (key) {\n    if (self.match && self.whitelist.length) {\n      return key.match(self.match) || self.whitelist.indexOf(key) !== -1\n    }\n    else if (self.match) {\n      return key.match(self.match);\n    }\n    else {\n      return !self.whitelist.length || self.whitelist.indexOf(key) !== -1\n    }\n  }).forEach(function (key) {\n    \n    var val = env[key];\n\n    if (self.parseValues) {\n      val = common.parseValues(val);\n    }\n\n    if (self.separator) {\n      self.set(common.key.apply(common, key.split(self.separator)), val);\n    }\n    else {\n      self.set(key, val);\n    }\n  });\n\n  this.readOnly = true;\n  return this.store;\n};\n\n"],"mappings":"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"}},"mtime":1674865250460},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf\\\\stores\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\node_modules\\\\.pnpm\\\\nconf@0.12.0\\\\node_modules\\\\nconf\\\\lib\\\\nconf\\\\stores\\\\literal.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"\"use strict\";\n\n/*\n * literal.js: Simple literal Object store for nconf.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar util = require('util'),\n  Memory = require('./memory').Memory;\nvar Literal = exports.Literal = function Literal(options) {\n  Memory.call(this, options);\n  options = options || {};\n  this.type = 'literal';\n  this.readOnly = true;\n  this.store = options.store || options;\n};\n\n// Inherit from Memory store.\nutil.inherits(Literal, Memory);\n\n//\n// ### function loadSync (callback)\n// Returns the data stored in `this.store` synchronously.\n//\nLiteral.prototype.loadSync = function () {\n  return this.store;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsIk1lbW9yeSIsIkxpdGVyYWwiLCJleHBvcnRzIiwib3B0aW9ucyIsImNhbGwiLCJ0eXBlIiwicmVhZE9ubHkiLCJzdG9yZSIsImluaGVyaXRzIiwicHJvdG90eXBlIiwibG9hZFN5bmMiXSwic291cmNlUm9vdCI6IkM6XFxjb2RlXFxGbHVpZEZyYW1ld29yazVcXG5vZGVfbW9kdWxlc1xcLnBucG1cXG5jb25mQDAuMTIuMFxcbm9kZV9tb2R1bGVzXFxuY29uZlxcbGliXFxuY29uZlxcc3RvcmVzXFwiLCJzb3VyY2VzIjpbImxpdGVyYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIGxpdGVyYWwuanM6IFNpbXBsZSBsaXRlcmFsIE9iamVjdCBzdG9yZSBmb3IgbmNvbmYuXG4gKlxuICogKEMpIDIwMTEsIENoYXJsaWUgUm9iYmlucyBhbmQgdGhlIENvbnRyaWJ1dG9ycy5cbiAqXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXG4gICAgTWVtb3J5ID0gcmVxdWlyZSgnLi9tZW1vcnknKS5NZW1vcnlcblxudmFyIExpdGVyYWwgPSBleHBvcnRzLkxpdGVyYWwgPSBmdW5jdGlvbiBMaXRlcmFsIChvcHRpb25zKSB7XG4gIE1lbW9yeS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIG9wdGlvbnMgICAgICAgPSBvcHRpb25zIHx8IHt9XG4gIHRoaXMudHlwZSAgICAgPSAnbGl0ZXJhbCc7XG4gIHRoaXMucmVhZE9ubHkgPSB0cnVlO1xuICB0aGlzLnN0b3JlICAgID0gb3B0aW9ucy5zdG9yZSB8fCBvcHRpb25zO1xufTtcblxuLy8gSW5oZXJpdCBmcm9tIE1lbW9yeSBzdG9yZS5cbnV0aWwuaW5oZXJpdHMoTGl0ZXJhbCwgTWVtb3J5KTtcblxuLy9cbi8vICMjIyBmdW5jdGlvbiBsb2FkU3luYyAoY2FsbGJhY2spXG4vLyBSZXR1cm5zIHRoZSBkYXRhIHN0b3JlZCBpbiBgdGhpcy5zdG9yZWAgc3luY2hyb25vdXNseS5cbi8vXG5MaXRlcmFsLnByb3RvdHlwZS5sb2FkU3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc3RvcmU7XG59OyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUEsSUFBSSxHQUFHQyxPQUFPLENBQUMsTUFBTSxDQUFDO0VBQ3RCQyxNQUFNLEdBQUdELE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQ0MsTUFBTTtBQUV2QyxJQUFJQyxPQUFPLEdBQUdDLE9BQU8sQ0FBQ0QsT0FBTyxHQUFHLFNBQVNBLE9BQU9BLENBQUVFLE9BQU8sRUFBRTtFQUN6REgsTUFBTSxDQUFDSSxJQUFJLENBQUMsSUFBSSxFQUFFRCxPQUFPLENBQUM7RUFFMUJBLE9BQU8sR0FBU0EsT0FBTyxJQUFJLENBQUMsQ0FBQztFQUM3QixJQUFJLENBQUNFLElBQUksR0FBTyxTQUFTO0VBQ3pCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUk7RUFDcEIsSUFBSSxDQUFDQyxLQUFLLEdBQU1KLE9BQU8sQ0FBQ0ksS0FBSyxJQUFJSixPQUFPO0FBQzFDLENBQUM7O0FBRUQ7QUFDQUwsSUFBSSxDQUFDVSxRQUFRLENBQUNQLE9BQU8sRUFBRUQsTUFBTSxDQUFDOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxPQUFPLENBQUNRLFNBQVMsQ0FBQ0MsUUFBUSxHQUFHLFlBQVk7RUFDdkMsT0FBTyxJQUFJLENBQUNILEtBQUs7QUFDbkIsQ0FBQyJ9","map":{"version":3,"names":["util","require","Memory","Literal","exports","options","call","type","readOnly","store","inherits","prototype","loadSync"],"sourceRoot":"C:\\code\\FluidFramework5\\node_modules\\.pnpm\\nconf@0.12.0\\node_modules\\nconf\\lib\\nconf\\stores\\","sources":["literal.js"],"sourcesContent":["/*\n * literal.js: Simple literal Object store for nconf.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar util = require('util'),\n    Memory = require('./memory').Memory\n\nvar Literal = exports.Literal = function Literal (options) {\n  Memory.call(this, options);\n\n  options       = options || {}\n  this.type     = 'literal';\n  this.readOnly = true;\n  this.store    = options.store || options;\n};\n\n// Inherit from Memory store.\nutil.inherits(Literal, Memory);\n\n//\n// ### function loadSync (callback)\n// Returns the data stored in `this.store` synchronously.\n//\nLiteral.prototype.loadSync = function () {\n  return this.store;\n};"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;EACtBC,MAAM,GAAGD,OAAO,CAAC,UAAU,CAAC,CAACC,MAAM;AAEvC,IAAIC,OAAO,GAAGC,OAAO,CAACD,OAAO,GAAG,SAASA,OAAOA,CAAEE,OAAO,EAAE;EACzDH,MAAM,CAACI,IAAI,CAAC,IAAI,EAAED,OAAO,CAAC;EAE1BA,OAAO,GAASA,OAAO,IAAI,CAAC,CAAC;EAC7B,IAAI,CAACE,IAAI,GAAO,SAAS;EACzB,IAAI,CAACC,QAAQ,GAAG,IAAI;EACpB,IAAI,CAACC,KAAK,GAAMJ,OAAO,CAACI,KAAK,IAAIJ,OAAO;AAC1C,CAAC;;AAED;AACAL,IAAI,CAACU,QAAQ,CAACP,OAAO,EAAED,MAAM,CAAC;;AAE9B;AACA;AACA;AACA;AACAC,OAAO,CAACQ,SAAS,CAACC,QAAQ,GAAG,YAAY;EACvC,OAAO,IAAI,CAACH,KAAK;AACnB,CAAC"}},"mtime":1674865250520},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\mocha-test-setup\\\\\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"filename\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\mocha-test-setup\\\\mocharc-common.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\code\\\\FluidFramework5\\\\packages\\\\test\\\\test-end-to-end-tests\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.22.6:development":{"value":{"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\"use strict\";\n\nconst {\n  existsSync\n} = require(\"fs\");\nconst path = require(\"path\");\nfunction getFluidTestMochaConfig(packageDir, additionalRequiredModules, testReportPrefix) {\n  const moduleDir = `${packageDir}/node_modules`;\n  const requiredModules = [\n  // General mocha setup e.g. suppresses console.log,\n  // This has to be before others (except logger) so that registerMochaTestWrapperFuncs is available\n  `@fluidframework/mocha-test-setup`, ...(additionalRequiredModules ? additionalRequiredModules : [])];\n\n  // mocha install node_modules directory might not be the same as the module required because of hoisting\n  // We need to give the full path in that case.\n  // TODO: this path mapping might not be necessary once we move to pnpm, since it sets up node_modules differently\n  // from what Lerna does (all dependencies of a given package show up in its own node_modules folder and just symlink\n  // to the actual location of the installed package, instead of common dependencies being hoisted to a parent\n  // node_modules folder and not being present at all in the package's own node_modules).\n  const requiredModulePaths = requiredModules.map(mod => {\n    // Just return if it is path already\n    if (existsSync(mod) || existsSync(`${mod}.js`)) {\n      return mod;\n    }\n\n    // Try to find it in the test package's directory\n    const modulePath = path.join(moduleDir, mod);\n    if (existsSync(modulePath)) {\n      return modulePath;\n    }\n\n    // Otherwise keep it as is\n    return mod;\n  });\n  if (process.env.FLUID_TEST_LOGGER_PKG_PATH) {\n    // Inject implementation of getTestLogger, put it first before mocha-test-setup\n    requiredModulePaths.unshift(process.env.FLUID_TEST_LOGGER_PKG_PATH);\n  }\n  const config = {\n    \"exit\": true,\n    \"recursive\": true,\n    \"require\": requiredModulePaths,\n    \"unhandled-rejections\": \"strict\",\n    // Performance tests benefit from having access to GC, and memory tests require it.\n    // Exposing it here avoids all packages which do perf testing from having to expose it.\n    \"v8-expose-gc\": true\n  };\n  if (process.env.FLUID_TEST_TIMEOUT !== undefined) {\n    config[\"timeout\"] = process.env.FLUID_TEST_TIMEOUT;\n  }\n  if (process.env.FLUID_TEST_REPORT === \"1\") {\n    const packageJson = require(`${packageDir}/package.json`);\n    config[\"reporter\"] = `xunit`;\n    if (testReportPrefix) {\n      config[\"reporter-options\"] = [\n      // give the report file a unique name based on testReportPrefix\n      `output=${packageDir}/nyc/${testReportPrefix}-junit-report.xml`, `suiteName=${packageJson.name} - ${testReportPrefix}`];\n    } else {\n      config[\"reporter-options\"] = [`output=${packageDir}/nyc/junit-report.xml`, `suiteName=${packageJson.name}`];\n    }\n  }\n  if (process.env.FLUID_TEST_MULTIREPORT === \"1\") {\n    config[\"reporter\"] = `mocha-multi-reporters`;\n    // See https://www.npmjs.com/package/mocha-multi-reporters#cmroutput-option\n    const outputFilePrefix = testReportPrefix !== undefined ? `${testReportPrefix}-` : \"\";\n    console.log(`Writing test results relative to package to nyc/${outputFilePrefix}junit-report.xml and nyc/${outputFilePrefix}junit-report.json`);\n    config[\"reporter-options\"] = [`configFile=${path.join(__dirname, \"test-config.json\")},cmrOutput=xunit+output+${outputFilePrefix}:mocha-json-output-reporter+output+${outputFilePrefix}`];\n  }\n  if (process.env.FLUID_TEST_FORBID_ONLY !== undefined) {\n    config[\"forbid-only\"] = true;\n  }\n  return config;\n}\nmodule.exports = getFluidTestMochaConfig;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJleGlzdHNTeW5jIiwicmVxdWlyZSIsInBhdGgiLCJnZXRGbHVpZFRlc3RNb2NoYUNvbmZpZyIsInBhY2thZ2VEaXIiLCJhZGRpdGlvbmFsUmVxdWlyZWRNb2R1bGVzIiwidGVzdFJlcG9ydFByZWZpeCIsIm1vZHVsZURpciIsInJlcXVpcmVkTW9kdWxlcyIsInJlcXVpcmVkTW9kdWxlUGF0aHMiLCJtYXAiLCJtb2QiLCJtb2R1bGVQYXRoIiwiam9pbiIsInByb2Nlc3MiLCJlbnYiLCJGTFVJRF9URVNUX0xPR0dFUl9QS0dfUEFUSCIsInVuc2hpZnQiLCJjb25maWciLCJGTFVJRF9URVNUX1RJTUVPVVQiLCJ1bmRlZmluZWQiLCJGTFVJRF9URVNUX1JFUE9SVCIsInBhY2thZ2VKc29uIiwibmFtZSIsIkZMVUlEX1RFU1RfTVVMVElSRVBPUlQiLCJvdXRwdXRGaWxlUHJlZml4IiwiY29uc29sZSIsImxvZyIsIl9fZGlybmFtZSIsIkZMVUlEX1RFU1RfRk9SQklEX09OTFkiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiJDOlxcY29kZVxcRmx1aWRGcmFtZXdvcms1XFxwYWNrYWdlc1xcdGVzdFxcbW9jaGEtdGVzdC1zZXR1cFxcIiwic291cmNlcyI6WyJtb2NoYXJjLWNvbW1vbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uIGFuZCBjb250cmlidXRvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHsgZXhpc3RzU3luYyB9ID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuXG5mdW5jdGlvbiBnZXRGbHVpZFRlc3RNb2NoYUNvbmZpZyhwYWNrYWdlRGlyLCBhZGRpdGlvbmFsUmVxdWlyZWRNb2R1bGVzLCB0ZXN0UmVwb3J0UHJlZml4KSB7XG5cdGNvbnN0IG1vZHVsZURpciA9IGAke3BhY2thZ2VEaXJ9L25vZGVfbW9kdWxlc2A7XG5cblx0Y29uc3QgcmVxdWlyZWRNb2R1bGVzID0gW1xuXHRcdC8vIEdlbmVyYWwgbW9jaGEgc2V0dXAgZS5nLiBzdXBwcmVzc2VzIGNvbnNvbGUubG9nLFxuXHRcdC8vIFRoaXMgaGFzIHRvIGJlIGJlZm9yZSBvdGhlcnMgKGV4Y2VwdCBsb2dnZXIpIHNvIHRoYXQgcmVnaXN0ZXJNb2NoYVRlc3RXcmFwcGVyRnVuY3MgaXMgYXZhaWxhYmxlXG5cdFx0YEBmbHVpZGZyYW1ld29yay9tb2NoYS10ZXN0LXNldHVwYCxcblx0XHQuLi4oYWRkaXRpb25hbFJlcXVpcmVkTW9kdWxlcyA/IGFkZGl0aW9uYWxSZXF1aXJlZE1vZHVsZXMgOiBbXSksXG5cdF07XG5cblx0Ly8gbW9jaGEgaW5zdGFsbCBub2RlX21vZHVsZXMgZGlyZWN0b3J5IG1pZ2h0IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgbW9kdWxlIHJlcXVpcmVkIGJlY2F1c2Ugb2YgaG9pc3Rpbmdcblx0Ly8gV2UgbmVlZCB0byBnaXZlIHRoZSBmdWxsIHBhdGggaW4gdGhhdCBjYXNlLlxuXHQvLyBUT0RPOiB0aGlzIHBhdGggbWFwcGluZyBtaWdodCBub3QgYmUgbmVjZXNzYXJ5IG9uY2Ugd2UgbW92ZSB0byBwbnBtLCBzaW5jZSBpdCBzZXRzIHVwIG5vZGVfbW9kdWxlcyBkaWZmZXJlbnRseVxuXHQvLyBmcm9tIHdoYXQgTGVybmEgZG9lcyAoYWxsIGRlcGVuZGVuY2llcyBvZiBhIGdpdmVuIHBhY2thZ2Ugc2hvdyB1cCBpbiBpdHMgb3duIG5vZGVfbW9kdWxlcyBmb2xkZXIgYW5kIGp1c3Qgc3ltbGlua1xuXHQvLyB0byB0aGUgYWN0dWFsIGxvY2F0aW9uIG9mIHRoZSBpbnN0YWxsZWQgcGFja2FnZSwgaW5zdGVhZCBvZiBjb21tb24gZGVwZW5kZW5jaWVzIGJlaW5nIGhvaXN0ZWQgdG8gYSBwYXJlbnRcblx0Ly8gbm9kZV9tb2R1bGVzIGZvbGRlciBhbmQgbm90IGJlaW5nIHByZXNlbnQgYXQgYWxsIGluIHRoZSBwYWNrYWdlJ3Mgb3duIG5vZGVfbW9kdWxlcykuXG5cdGNvbnN0IHJlcXVpcmVkTW9kdWxlUGF0aHMgPSByZXF1aXJlZE1vZHVsZXMubWFwKChtb2QpID0+IHtcblx0XHQvLyBKdXN0IHJldHVybiBpZiBpdCBpcyBwYXRoIGFscmVhZHlcblx0XHRpZiAoZXhpc3RzU3luYyhtb2QpIHx8IGV4aXN0c1N5bmMoYCR7bW9kfS5qc2ApKSB7XG5cdFx0XHRyZXR1cm4gbW9kO1xuXHRcdH1cblxuXHRcdC8vIFRyeSB0byBmaW5kIGl0IGluIHRoZSB0ZXN0IHBhY2thZ2UncyBkaXJlY3Rvcnlcblx0XHRjb25zdCBtb2R1bGVQYXRoID0gcGF0aC5qb2luKG1vZHVsZURpciwgbW9kKTtcblx0XHRpZiAoZXhpc3RzU3luYyhtb2R1bGVQYXRoKSkge1xuXHRcdFx0cmV0dXJuIG1vZHVsZVBhdGg7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIGtlZXAgaXQgYXMgaXNcblx0XHRyZXR1cm4gbW9kO1xuXHR9KTtcblxuXHRpZiAocHJvY2Vzcy5lbnYuRkxVSURfVEVTVF9MT0dHRVJfUEtHX1BBVEgpIHtcblx0XHQvLyBJbmplY3QgaW1wbGVtZW50YXRpb24gb2YgZ2V0VGVzdExvZ2dlciwgcHV0IGl0IGZpcnN0IGJlZm9yZSBtb2NoYS10ZXN0LXNldHVwXG5cdFx0cmVxdWlyZWRNb2R1bGVQYXRocy51bnNoaWZ0KHByb2Nlc3MuZW52LkZMVUlEX1RFU1RfTE9HR0VSX1BLR19QQVRIKTtcblx0fVxuXG5cdGNvbnN0IGNvbmZpZyA9IHtcblx0XHRcImV4aXRcIjogdHJ1ZSxcblx0XHRcInJlY3Vyc2l2ZVwiOiB0cnVlLFxuXHRcdFwicmVxdWlyZVwiOiByZXF1aXJlZE1vZHVsZVBhdGhzLFxuXHRcdFwidW5oYW5kbGVkLXJlamVjdGlvbnNcIjogXCJzdHJpY3RcIixcblx0XHQvLyBQZXJmb3JtYW5jZSB0ZXN0cyBiZW5lZml0IGZyb20gaGF2aW5nIGFjY2VzcyB0byBHQywgYW5kIG1lbW9yeSB0ZXN0cyByZXF1aXJlIGl0LlxuXHRcdC8vIEV4cG9zaW5nIGl0IGhlcmUgYXZvaWRzIGFsbCBwYWNrYWdlcyB3aGljaCBkbyBwZXJmIHRlc3RpbmcgZnJvbSBoYXZpbmcgdG8gZXhwb3NlIGl0LlxuXHRcdFwidjgtZXhwb3NlLWdjXCI6IHRydWUsXG5cdH07XG5cblx0aWYgKHByb2Nlc3MuZW52LkZMVUlEX1RFU1RfVElNRU9VVCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29uZmlnW1widGltZW91dFwiXSA9IHByb2Nlc3MuZW52LkZMVUlEX1RFU1RfVElNRU9VVDtcblx0fVxuXG5cdGlmIChwcm9jZXNzLmVudi5GTFVJRF9URVNUX1JFUE9SVCA9PT0gXCIxXCIpIHtcblx0XHRjb25zdCBwYWNrYWdlSnNvbiA9IHJlcXVpcmUoYCR7cGFja2FnZURpcn0vcGFja2FnZS5qc29uYCk7XG5cdFx0Y29uZmlnW1wicmVwb3J0ZXJcIl0gPSBgeHVuaXRgO1xuXHRcdGlmICh0ZXN0UmVwb3J0UHJlZml4KSB7XG5cdFx0XHRjb25maWdbXCJyZXBvcnRlci1vcHRpb25zXCJdID0gW1xuXHRcdFx0XHQvLyBnaXZlIHRoZSByZXBvcnQgZmlsZSBhIHVuaXF1ZSBuYW1lIGJhc2VkIG9uIHRlc3RSZXBvcnRQcmVmaXhcblx0XHRcdFx0YG91dHB1dD0ke3BhY2thZ2VEaXJ9L255Yy8ke3Rlc3RSZXBvcnRQcmVmaXh9LWp1bml0LXJlcG9ydC54bWxgLFxuXHRcdFx0XHRgc3VpdGVOYW1lPSR7cGFja2FnZUpzb24ubmFtZX0gLSAke3Rlc3RSZXBvcnRQcmVmaXh9YCxcblx0XHRcdF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbmZpZ1tcInJlcG9ydGVyLW9wdGlvbnNcIl0gPSBbXG5cdFx0XHRcdGBvdXRwdXQ9JHtwYWNrYWdlRGlyfS9ueWMvanVuaXQtcmVwb3J0LnhtbGAsXG5cdFx0XHRcdGBzdWl0ZU5hbWU9JHtwYWNrYWdlSnNvbi5uYW1lfWAsXG5cdFx0XHRdO1xuXHRcdH1cblx0fVxuXG5cdGlmIChwcm9jZXNzLmVudi5GTFVJRF9URVNUX01VTFRJUkVQT1JUID09PSBcIjFcIikge1xuXHRcdGNvbmZpZ1tcInJlcG9ydGVyXCJdID0gYG1vY2hhLW11bHRpLXJlcG9ydGVyc2A7XG5cdFx0Ly8gU2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21vY2hhLW11bHRpLXJlcG9ydGVycyNjbXJvdXRwdXQtb3B0aW9uXG5cdFx0Y29uc3Qgb3V0cHV0RmlsZVByZWZpeCA9IHRlc3RSZXBvcnRQcmVmaXggIT09IHVuZGVmaW5lZCA/IGAke3Rlc3RSZXBvcnRQcmVmaXh9LWAgOiBcIlwiO1xuXHRcdGNvbnNvbGUubG9nKFxuXHRcdFx0YFdyaXRpbmcgdGVzdCByZXN1bHRzIHJlbGF0aXZlIHRvIHBhY2thZ2UgdG8gbnljLyR7b3V0cHV0RmlsZVByZWZpeH1qdW5pdC1yZXBvcnQueG1sIGFuZCBueWMvJHtvdXRwdXRGaWxlUHJlZml4fWp1bml0LXJlcG9ydC5qc29uYCxcblx0XHQpO1xuXHRcdGNvbmZpZ1tcInJlcG9ydGVyLW9wdGlvbnNcIl0gPSBbXG5cdFx0XHRgY29uZmlnRmlsZT0ke3BhdGguam9pbihcblx0XHRcdFx0X19kaXJuYW1lLFxuXHRcdFx0XHRcInRlc3QtY29uZmlnLmpzb25cIixcblx0XHRcdCl9LGNtck91dHB1dD14dW5pdCtvdXRwdXQrJHtvdXRwdXRGaWxlUHJlZml4fTptb2NoYS1qc29uLW91dHB1dC1yZXBvcnRlcitvdXRwdXQrJHtvdXRwdXRGaWxlUHJlZml4fWAsXG5cdFx0XTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLmVudi5GTFVJRF9URVNUX0ZPUkJJRF9PTkxZICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb25maWdbXCJmb3JiaWQtb25seVwiXSA9IHRydWU7XG5cdH1cblxuXHRyZXR1cm4gY29uZmlnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEZsdWlkVGVzdE1vY2hhQ29uZmlnO1xuIl0sIm1hcHBpbmdzIjoiQUFB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","map":{"version":3,"names":["existsSync","require","path","getFluidTestMochaConfig","packageDir","additionalRequiredModules","testReportPrefix","moduleDir","requiredModules","requiredModulePaths","map","mod","modulePath","join","process","env","FLUID_TEST_LOGGER_PKG_PATH","unshift","config","FLUID_TEST_TIMEOUT","undefined","FLUID_TEST_REPORT","packageJson","name","FLUID_TEST_MULTIREPORT","outputFilePrefix","console","log","__dirname","FLUID_TEST_FORBID_ONLY","module","exports"],"sourceRoot":"C:\\code\\FluidFramework5\\packages\\test\\mocha-test-setup\\","sources":["mocharc-common.js"],"sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\"use strict\";\n\nconst { existsSync } = require(\"fs\");\nconst path = require(\"path\");\n\nfunction getFluidTestMochaConfig(packageDir, additionalRequiredModules, testReportPrefix) {\n\tconst moduleDir = `${packageDir}/node_modules`;\n\n\tconst requiredModules = [\n\t\t// General mocha setup e.g. suppresses console.log,\n\t\t// This has to be before others (except logger) so that registerMochaTestWrapperFuncs is available\n\t\t`@fluidframework/mocha-test-setup`,\n\t\t...(additionalRequiredModules ? additionalRequiredModules : []),\n\t];\n\n\t// mocha install node_modules directory might not be the same as the module required because of hoisting\n\t// We need to give the full path in that case.\n\t// TODO: this path mapping might not be necessary once we move to pnpm, since it sets up node_modules differently\n\t// from what Lerna does (all dependencies of a given package show up in its own node_modules folder and just symlink\n\t// to the actual location of the installed package, instead of common dependencies being hoisted to a parent\n\t// node_modules folder and not being present at all in the package's own node_modules).\n\tconst requiredModulePaths = requiredModules.map((mod) => {\n\t\t// Just return if it is path already\n\t\tif (existsSync(mod) || existsSync(`${mod}.js`)) {\n\t\t\treturn mod;\n\t\t}\n\n\t\t// Try to find it in the test package's directory\n\t\tconst modulePath = path.join(moduleDir, mod);\n\t\tif (existsSync(modulePath)) {\n\t\t\treturn modulePath;\n\t\t}\n\n\t\t// Otherwise keep it as is\n\t\treturn mod;\n\t});\n\n\tif (process.env.FLUID_TEST_LOGGER_PKG_PATH) {\n\t\t// Inject implementation of getTestLogger, put it first before mocha-test-setup\n\t\trequiredModulePaths.unshift(process.env.FLUID_TEST_LOGGER_PKG_PATH);\n\t}\n\n\tconst config = {\n\t\t\"exit\": true,\n\t\t\"recursive\": true,\n\t\t\"require\": requiredModulePaths,\n\t\t\"unhandled-rejections\": \"strict\",\n\t\t// Performance tests benefit from having access to GC, and memory tests require it.\n\t\t// Exposing it here avoids all packages which do perf testing from having to expose it.\n\t\t\"v8-expose-gc\": true,\n\t};\n\n\tif (process.env.FLUID_TEST_TIMEOUT !== undefined) {\n\t\tconfig[\"timeout\"] = process.env.FLUID_TEST_TIMEOUT;\n\t}\n\n\tif (process.env.FLUID_TEST_REPORT === \"1\") {\n\t\tconst packageJson = require(`${packageDir}/package.json`);\n\t\tconfig[\"reporter\"] = `xunit`;\n\t\tif (testReportPrefix) {\n\t\t\tconfig[\"reporter-options\"] = [\n\t\t\t\t// give the report file a unique name based on testReportPrefix\n\t\t\t\t`output=${packageDir}/nyc/${testReportPrefix}-junit-report.xml`,\n\t\t\t\t`suiteName=${packageJson.name} - ${testReportPrefix}`,\n\t\t\t];\n\t\t} else {\n\t\t\tconfig[\"reporter-options\"] = [\n\t\t\t\t`output=${packageDir}/nyc/junit-report.xml`,\n\t\t\t\t`suiteName=${packageJson.name}`,\n\t\t\t];\n\t\t}\n\t}\n\n\tif (process.env.FLUID_TEST_MULTIREPORT === \"1\") {\n\t\tconfig[\"reporter\"] = `mocha-multi-reporters`;\n\t\t// See https://www.npmjs.com/package/mocha-multi-reporters#cmroutput-option\n\t\tconst outputFilePrefix = testReportPrefix !== undefined ? `${testReportPrefix}-` : \"\";\n\t\tconsole.log(\n\t\t\t`Writing test results relative to package to nyc/${outputFilePrefix}junit-report.xml and nyc/${outputFilePrefix}junit-report.json`,\n\t\t);\n\t\tconfig[\"reporter-options\"] = [\n\t\t\t`configFile=${path.join(\n\t\t\t\t__dirname,\n\t\t\t\t\"test-config.json\",\n\t\t\t)},cmrOutput=xunit+output+${outputFilePrefix}:mocha-json-output-reporter+output+${outputFilePrefix}`,\n\t\t];\n\t}\n\n\tif (process.env.FLUID_TEST_FORBID_ONLY !== undefined) {\n\t\tconfig[\"forbid-only\"] = true;\n\t}\n\n\treturn config;\n}\n\nmodule.exports = getFluidTestMochaConfig;\n"],"mappings":"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"}},"mtime":1687986257686}}