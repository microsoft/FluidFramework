## API Report File for "@fluid-experimental/tree2"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { IChannel } from '@fluidframework/datastore-definitions';
import { IChannelAttributes } from '@fluidframework/datastore-definitions';
import { IChannelFactory } from '@fluidframework/datastore-definitions';
import { IChannelServices } from '@fluidframework/datastore-definitions';
import { IFluidDataStoreRuntime } from '@fluidframework/datastore-definitions';
import { IFluidHandle } from '@fluidframework/core-interfaces';
import { ISharedObject } from '@fluidframework/shared-object-base';
import { SessionSpaceCompressedId } from '@fluidframework/runtime-definitions';
import { StableId } from '@fluidframework/runtime-definitions';
import type { Static } from '@sinclair/typebox';
import type { TSchema } from '@sinclair/typebox';

// @alpha
export interface Adapters {
    // (undocumented)
    readonly tree?: readonly TreeAdapter[];
}

// @alpha
export type AllowedTypes = readonly [Any] | readonly LazyItem<TreeNodeSchema>[];

// @alpha
export type AllowedTypeSet = Any | ReadonlySet<TreeNodeSchema>;

// @alpha
type AllowedTypesToTypedTrees<Mode extends ApiMode, T extends AllowedTypes> = [
T extends InternalTypedSchemaTypes.FlexList<TreeNodeSchema> ? InternalTypedSchemaTypes.ArrayToUnion<TypeArrayToTypedTreeArray<Mode, Assume<InternalTypedSchemaTypes.ConstantFlexListToNonLazyArray<T>, readonly TreeNodeSchema[]>>> : UntypedApi<Mode>
][_InlineTrick];

// @alpha
export enum AllowedUpdateType {
    None = 0,
    SchemaCompatible = 1
}

// @alpha
type AllowOptional<T> = [FlattenKeys<RequiredFields<T> & OptionalFields<T>>][_InlineTrick];

// @alpha
type AllowOptionalNotFlattened<T> = [RequiredFields<T> & OptionalFields<T>][_InlineTrick];

// @alpha
export type Anchor = Brand<number, "rebaser.Anchor">;

// @alpha
export interface AnchorEvents {
    afterChange(anchor: AnchorNode): void;
    afterDestroy(anchor: AnchorNode): void;
    beforeChange(anchor: AnchorNode): void;
    childrenChanging(anchor: AnchorNode): void;
    subtreeChanging(anchor: AnchorNode): PathVisitor | void;
    valueChanging(anchor: AnchorNode, value: Value): void;
}

// @alpha
export interface AnchorLocator {
    locate(anchor: Anchor): AnchorNode | undefined;
}

// @alpha
export interface AnchorNode extends UpPath<AnchorNode>, ISubscribable<AnchorEvents> {
    child(key: FieldKey, index: number): UpPath<AnchorNode>;
    getOrCreateChildRef(key: FieldKey, index: number): [Anchor, AnchorNode];
    readonly slots: BrandedMapSubset<AnchorSlot<any>>;
}

// @alpha
export type AnchorsCompare = CompareFunction<UpPath>;

// @alpha @sealed
export class AnchorSet implements ISubscribable<AnchorSetRootEvents>, AnchorLocator {
    constructor();
    acquireVisitor(): AnnouncedVisitor & DeltaVisitor;
    // (undocumented)
    forget(anchor: Anchor): void;
    generationNumber: number;
    internalizePath(originalPath: UpPath): UpPath;
    isEmpty(): boolean;
    // (undocumented)
    locate(anchor: Anchor): AnchorNode | undefined;
    // (undocumented)
    on<K extends keyof AnchorSetRootEvents>(eventName: K, listener: AnchorSetRootEvents[K]): () => void;
    track(path: UpPath | null): Anchor;
}

// @alpha
export interface AnchorSetRootEvents {
    childrenChanging(anchors: AnchorSet): void;
    treeChanging(anchors: AnchorSet): void;
}

// @alpha
export type AnchorSlot<TContent> = BrandedKey<Opaque<Brand<number, "AnchorSlot">>, TContent>;

// @alpha
export function anchorSlot<TContent>(): AnchorSlot<TContent>;

// @alpha
export interface AnnouncedVisitor {
    // (undocumented)
    afterAttach(source: FieldKey, destination: Range_2): void;
    afterCreate(content: Delta.ProtoNodes, destination: FieldKey): void;
    // (undocumented)
    afterDetach(source: PlaceIndex, count: number, destination: FieldKey): void;
    // (undocumented)
    afterReplace(newContentSource: FieldKey, newContent: Range_2, oldContent: FieldKey): void;
    // (undocumented)
    beforeAttach(source: FieldKey, count: number, destination: PlaceIndex): void;
    // (undocumented)
    beforeDestroy(field: FieldKey, count: number): void;
    // (undocumented)
    beforeDetach(source: Range_2, destination: FieldKey): void;
    // (undocumented)
    beforeReplace(newContent: FieldKey, oldContent: Range_2, oldContentDestination: FieldKey): void;
}

// @alpha
export const Any: "Any";

// @alpha
export type Any = typeof Any;

// @alpha
const enum ApiMode {
    Editable = 1,
    EditableUnwrapped = 2,
    Flexible = 0,
    Simple = 4,
    Wrapped = 3
}

// @alpha
type ApplyMultiplicity<TMultiplicity extends Multiplicity, TypedChild, Mode extends ApiMode> = {
    [Multiplicity.Forbidden]: undefined;
    [Multiplicity.Optional]: Mode extends ApiMode.Editable ? EditableOptionalField<TypedChild> : undefined | TypedChild;
    [Multiplicity.Sequence]: Mode extends ApiMode.Editable | ApiMode.EditableUnwrapped ? EditableSequenceField<TypedChild> : TypedChild[];
    [Multiplicity.Single]: Mode extends ApiMode.Editable ? EditableValueField<TypedChild> : TypedChild;
}[TMultiplicity];

// @alpha
type ArrayHasFixedLength<List extends readonly unknown[]> = number extends List["length"] ? false : true;

// @alpha
export interface ArrayLikeMut<TGet, TSet extends TGet = TGet> extends ArrayLike<TGet> {
    // (undocumented)
    [n: number]: TSet;
}

// @alpha
type ArrayToUnion<T extends readonly unknown[]> = T extends readonly (infer TValue)[] ? TValue : never;

// @alpha
export type AssignableFieldKinds = typeof FieldKinds.optional | typeof FieldKinds.required;

// @alpha
type Assume<TInput, TAssumeToBe> = [TInput] extends [TAssumeToBe] ? TInput : TAssumeToBe;

// @alpha
export interface BatchBindingContext extends BindingContext {
    // (undocumented)
    readonly events: VisitorBindingContext[];
    // (undocumented)
    readonly type: typeof BindingType.Batch;
}

// @alpha
export type BinderEventsCompare = CompareFunction<VisitorBindingContext>;

// @alpha
export interface BinderOptions {
    // (undocumented)
    sortFn?: BinderEventsCompare;
}

// @alpha
export interface BindingContext {
    // (undocumented)
    readonly type: BindingContextType;
}

// @alpha
export type BindingContextType = (typeof BindingType)[keyof typeof BindingType];

// @alpha
export const BindingType: {
    readonly Delete: "delete";
    readonly Insert: "insert";
    readonly Invalidation: "invalidation";
    readonly Batch: "batch";
};

// @alpha
export type BindPath = DownPath;

// @alpha
export interface BindPolicy {
    // (undocumented)
    readonly bindTree: BindTree;
    // (undocumented)
    readonly matchPolicy: MatchPolicy;
}

// @alpha
export interface BindSyntaxTree {
    // (undocumented)
    readonly [indexSymbol]?: number;
    // (undocumented)
    readonly [key: string]: true | BindSyntaxTree;
}

// @alpha
export interface BindTree<T = BindTreeDefault> extends PathStep {
    // (undocumented)
    readonly children: Map<FieldKey, T>;
}

// @alpha
export type BindTreeDefault = BindTree;

// @alpha
export type Brand<ValueType, Name extends string> = ValueType & BrandedType<ValueType, Name>;

// @alpha
export function brand<T extends Brand<any, string>>(value: T extends BrandedType<infer ValueType, string> ? ValueType : never): T;

// @alpha
export type BrandedKey<TKey, TContent> = TKey & Invariant<TContent>;

// @alpha (undocumented)
type BrandedKeyContent<TKey extends BrandedKey<unknown, any>> = TKey extends BrandedKey<unknown, infer TContent> ? TContent : never;

// @alpha
export interface BrandedMapSubset<K extends BrandedKey<unknown, any>> {
    // (undocumented)
    delete(key: K): boolean;
    // (undocumented)
    get<K2 extends K>(key: K2): BrandedKeyContent<K2> | undefined;
    // (undocumented)
    has(key: K): boolean;
    // (undocumented)
    set<K2 extends K>(key: K2, value: BrandedKeyContent<K2>): this;
}

// @alpha @sealed
abstract class BrandedType<ValueType, Name extends string> {
    protected readonly _type_brand: Name;
    // (undocumented)
    protected _typeCheck?: Invariant<ValueType>;
}

// @alpha
export function brandOpaque<T extends BrandedType<any, string>>(value: isAny<ValueFromBranded<T>> extends true ? never : ValueFromBranded<T>): BrandedType<ValueFromBranded<T>, NameFromBranded<T>>;

// @alpha
export type ChangesetLocalId = Brand<number, "ChangesetLocalId">;

// @alpha
export type CheckTypesOverlap<T, TCheck> = [Extract<T, TCheck> extends never ? never : T][0];

// @alpha
export type ChildCollection = FieldKey | RootField;

// @alpha
export interface ChildLocation {
    // (undocumented)
    readonly container: ChildCollection;
    // (undocumented)
    readonly index: number;
}

// @alpha
type CollectOptions<Mode extends ApiMode, TTypedFields, TValueSchema extends ValueSchema | undefined, TName> = {
    [ApiMode.Flexible]: EmptyObject extends TTypedFields ? TypedValueOrUndefined<TValueSchema> | FlexibleObject<TValueSchema, TName> : FlexibleObject<TValueSchema, TName> & TTypedFields;
    [ApiMode.Editable]: {
        [typeNameSymbol]: TName & TreeNodeSchemaIdentifier;
    } & ValuePropertyFromSchema<TValueSchema> & TTypedFields & UntypedTreeCore;
    [ApiMode.EditableUnwrapped]: [EmptyObject, TValueSchema] extends [
    TTypedFields,
    PrimitiveValueSchema
    ] ? TypedValueOrUndefined<TValueSchema> : CollectOptions<ApiMode.Editable, TTypedFields, TValueSchema, TName>;
    [ApiMode.Wrapped]: {
        [typeNameSymbol]: TName;
        [valueSymbol]: TypedValueOrUndefined<TValueSchema>;
    } & TTypedFields;
    [ApiMode.Simple]: EmptyObject extends TTypedFields ? TypedValueOrUndefined<TValueSchema> : FlexibleObject<TValueSchema, TName> & TTypedFields;
}[Mode];

// @alpha
export type CompareFunction<T> = (a: T, b: T) => number;

// @alpha
export function compareLocalNodeKeys(a: LocalNodeKey, b: LocalNodeKey): -1 | 0 | 1;

// @alpha
export function comparePipeline<T>(...fns: CompareFunction<T>[]): CompareFunction<T>;

// @alpha
export function compileSyntaxTree(syntaxTree: BindSyntaxTree, matchPolicy?: MatchPolicy): BindPolicy;

// @alpha
type ConstantFlexListToNonLazyArray<List extends FlexList> = List extends readonly [
infer Head,
...infer Tail
] ? [ExtractItemType<Head>, ...ConstantFlexListToNonLazyArray<Tail>] : [];

// @alpha
export const contextSymbol: unique symbol;

// @alpha
export type ContextuallyTypedFieldData = ContextuallyTypedNodeData | undefined;

// @alpha
export type ContextuallyTypedNodeData = ContextuallyTypedNodeDataObject | PrimitiveValue | readonly ContextuallyTypedNodeData[] | MarkedArrayLike<ContextuallyTypedNodeData>;

// @alpha
export interface ContextuallyTypedNodeDataObject {
    readonly [typeNameSymbol]?: string;
    readonly [valueSymbol]?: Value;
    [key: FieldKey]: ContextuallyTypedFieldData;
    [key: string]: ContextuallyTypedFieldData;
}

// @alpha
interface Contravariant<in T> {
    // (undocumented)
    _removeCovariance?: (_: T) => void;
}

// @alpha
interface Covariant<out T> {
    // (undocumented)
    _removeContravariance?: T;
}

// @alpha
export function createBinderOptions({ sortFn }: {
    sortFn?: BinderEventsCompare;
}): BinderOptions;

// @alpha
export function createDataBinderBuffering<E extends Events<E>>(view: ISubscribable<E>, options: FlushableBinderOptions<E>): FlushableDataBinder<OperationBinderEvents>;

// @alpha
export function createDataBinderDirect<E extends Events<E>>(view: ISubscribable<E>, options: BinderOptions): DataBinder<OperationBinderEvents>;

// @alpha
export function createDataBinderInvalidating<E extends Events<E>>(view: ISubscribable<E>, options: FlushableBinderOptions<E>): FlushableDataBinder<InvalidationBinderEvents>;

// @alpha
export function createEmitter<E extends Events<E>>(noListeners?: NoListenersCallback<E>): ISubscribable<E> & IEmitter<E> & HasListeners<E>;

// @alpha
export function createFlushableBinderOptions<E extends Events<E>>({ sortFn, sortAnchorsFn, autoFlush, autoFlushPolicy, }: {
    sortFn?: BinderEventsCompare;
    sortAnchorsFn?: AnchorsCompare;
    autoFlush?: boolean;
    autoFlushPolicy: keyof Events<E>;
}): FlushableBinderOptions<E>;

// @alpha
export interface CursorAdapter<TNode> {
    // (undocumented)
    getFieldFromNode(node: TNode, key: FieldKey): readonly TNode[];
    // (undocumented)
    keysFromNode(node: TNode): readonly FieldKey[];
    // (undocumented)
    type(node: TNode): TreeType;
    // (undocumented)
    value(node: TNode): Value;
}

// @alpha
export function cursorForTypedTreeData<T extends TreeNodeSchema>(context: TreeDataContext, schema: T, data: TypedNode_2<T, ApiMode.Simple>): ITreeCursorSynchronous;

// @alpha
export function cursorFromContextualData(context: TreeDataContext, typeSet: TreeTypeSet, data: ContextuallyTypedNodeData): ITreeCursorSynchronous;

// @alpha (undocumented)
export const enum CursorLocationType {
    Fields = 1,
    Nodes = 0
}

// @alpha
export function cursorToJsonObject(reader: ITreeCursor): JsonCompatible;

// @alpha
export interface CursorWithNode<TNode> extends ITreeCursorSynchronous {
    fork(): CursorWithNode<TNode>;
    getNode(): TNode;
}

// @alpha
export interface DataBinder<B extends OperationBinderEvents | InvalidationBinderEvents> {
    register<K extends keyof Events<B>>(anchor: EditableTree, eventType: K, eventTrees: BindPolicy[], listener?: B[K]): void;
    unregisterAll(): void;
}

// @alpha
export const defaultSchemaPolicy: FullSchemaPolicy;

// @alpha
export interface DeleteBindingContext extends BindingContext {
    // (undocumented)
    readonly count: number;
    // (undocumented)
    readonly path: UpPath;
    // (undocumented)
    readonly type: typeof BindingType.Delete;
}

declare namespace Delta {
    export {
        Root,
        ProtoNode,
        ProtoNodes,
        Mark,
        DetachedNodeId,
        FieldMap,
        DetachedNodeChanges,
        DetachedNodeBuild,
        DetachedNodeDestruction,
        DetachedNodeRename,
        FieldChanges
    }
}
export { Delta }

// @alpha
export interface DeltaVisitor {
    attach(source: FieldKey, count: number, destination: PlaceIndex): void;
    create(content: Delta.ProtoNodes, destination: FieldKey): void;
    destroy(detachedField: FieldKey, count: number): void;
    detach(source: Range_2, destination: FieldKey): void;
    enterField(key: FieldKey): void;
    enterNode(index: NodeIndex): void;
    exitField(key: FieldKey): void;
    exitNode(index: NodeIndex): void;
    free(): void;
    replace(newContentSource: FieldKey, range: Range_2, oldContentDestination: FieldKey): void;
}

// @alpha
export interface Dependee extends NamedComputation {
    registerDependent(dependent: Dependent): boolean;
    removeDependent(dependent: Dependent): void;
}

// @alpha
export interface Dependent extends NamedComputation {
    markInvalid(token?: InvalidationToken): void;
}

// @alpha
export interface DetachedField extends Opaque<Brand<string, "tree.DetachedField">> {
}

// @alpha
interface DetachedNodeBuild<TTree = ProtoNode> {
    // (undocumented)
    readonly id: DetachedNodeId;
    // (undocumented)
    readonly trees: readonly TTree[];
}

// @alpha
interface DetachedNodeChanges<TTree = ProtoNode> {
    // (undocumented)
    readonly fields: FieldMap<TTree>;
    // (undocumented)
    readonly id: DetachedNodeId;
}

// @alpha
interface DetachedNodeDestruction {
    // (undocumented)
    readonly count: number;
    // (undocumented)
    readonly id: DetachedNodeId;
}

// @alpha
interface DetachedNodeId {
    // (undocumented)
    readonly major?: string | number;
    // (undocumented)
    readonly minor: number;
}

// @alpha
interface DetachedNodeRename {
    // (undocumented)
    readonly count: number;
    // (undocumented)
    readonly newId: DetachedNodeId;
    // (undocumented)
    readonly oldId: DetachedNodeId;
}

// @alpha
export type DetachedPlaceUpPath = Brand<Omit<PlaceUpPath, "parent">, "DetachedRangeUpPath">;

// @alpha
export type DetachedRangeUpPath = Brand<Omit<RangeUpPath, "parent">, "DetachedRangeUpPath">;

// @alpha
export enum DiscardResult {
    Failure = 1,
    Success = 0
}

// @alpha
function downCast<TSchema extends TreeNodeSchema>(schema: TSchema, tree: UntypedTreeCore<any, any>): tree is TypedNode_2<TSchema>;

// @alpha
export type DownPath = PathStep[];

// @alpha
export interface EditableField extends UntypedField<EditableTreeContext, EditableTree, EditableTree, UnwrappedEditableTree> {
    readonly [proxyTargetSymbol]: object;
    get content(): EditableTree | undefined | EditableField;
    insertNodes(index: number, newContent: NewFieldContent): void;
    moveNodes(sourceIndex: number, count: number, destIndex: number, destinationField?: EditableField): void;
    remove(): void;
    removeNodes(index: number, count?: number): void;
    replaceNodes(index: number, newContent: NewFieldContent, count?: number): void;
    setContent(newContent: NewFieldContent): void;
}

// @alpha (undocumented)
type EditableOptionalField<TypedChild> = [
UntypedOptionalField & MarkedArrayLike<TypedChild>
][_InlineTrick];

// @alpha (undocumented)
type EditableSequenceField<TypedChild> = [
UntypedSequenceField & MarkedArrayLike<TypedChild>
][_InlineTrick];

// @alpha
export interface EditableTree extends Iterable<EditableField>, Omit<UntypedTreeCore<EditableTreeContext, EditableField>, typeof Symbol.iterator> {
    readonly [localNodeKeySymbol]?: LocalNodeKey;
    readonly [parentField]: {
        readonly parent: EditableField;
        readonly index: number;
    };
    readonly [proxyTargetSymbol]: object;
    [setField](fieldKey: FieldKey, content: NewFieldContent): void;
    readonly [typeNameSymbol]: TreeNodeSchemaIdentifier;
    readonly [valueSymbol]: Value;
    [key: string]: UnwrappedEditableField;
}

// @alpha
export interface EditableTreeContext extends ISubscribable<ForestEvents> {
    clear(): void;
    fieldSource?(key: FieldKey, schema: TreeFieldStoredSchema): undefined | FieldGenerator;
    free(): void;
    prepareForEdit(): void;
    get root(): EditableField;
    readonly schema: TreeStoredSchema;
    setContent(data: NewFieldContent): void;
    get unwrappedRoot(): UnwrappedEditableField;
}

// @alpha
export interface EditableTreeEvents {
    afterChange(event: TreeEvent): void;
    beforeChange(event: TreeEvent): void;
    changing(upPath: UpPath): void;
    subtreeChanging(upPath: UpPath): PathVisitor | void;
}

// @alpha
export type EditableTreeOrPrimitive = EditableTree | PrimitiveValue;

// @alpha (undocumented)
type EditableValueField<TypedChild> = [
UntypedValueField & MarkedArrayLike<TypedChild>
][_InlineTrick];

// @alpha
export const EmptyKey: FieldKey;

// @alpha
type EmptyObject = {};

// @alpha
export function encodeTreeSchema(schema: TreeStoredSchema): JsonCompatible;

// @alpha
export type Events<E> = {
    [P in (string | symbol) & keyof E as IsEvent<E[P]> extends true ? P : never]: E[P];
};

// @alpha
type ExtractFromOpaque<TOpaque extends BrandedType<any, string>> = TOpaque extends BrandedType<infer ValueType, infer Name> ? isAny<ValueType> extends true ? unknown : Brand<ValueType, Name> : never;

// @alpha
export function extractFromOpaque<TOpaque extends BrandedType<any, string>>(value: TOpaque): ExtractFromOpaque<TOpaque>;

// @alpha (undocumented)
type ExtractItemType<Item extends LazyItem> = Item extends () => infer Result ? Result : Item;

// @alpha (undocumented)
type ExtractListItemType<List extends FlexList> = List extends FlexList<infer Item> ? Item : unknown;

// @alpha
type FactoryObjectNodeSchema<TScope extends string, Name extends number | string, T extends RestrictiveReadonlyRecord<string, ImplicitFieldSchema>> = FactoryTreeSchema<TreeNodeSchema<`${TScope}.${Name}`, {
    objectNodeFields: {
        [key in keyof T]: NormalizeField_2<T[key], Required_2>;
    };
}>>;

// @alpha
type FactoryObjectNodeSchemaRecursive<TScope extends string, Name extends number | string, T extends Unenforced<RestrictiveReadonlyRecord<string, ImplicitFieldSchema>>> = FactoryTreeSchema<TreeNodeSchema<`${TScope}.${Name}`, {
    objectNodeFields: T;
}>>;

// @alpha
export type FactoryTreeSchema<TSchema extends TreeNodeSchema<string, unknown>> = TSchema & SharedTreeObjectFactory<TSchema>;

// @alpha (undocumented)
export function fail(message: string): never;

// @alpha
export interface FieldAnchor {
    // (undocumented)
    fieldKey: FieldKey;
    parent: Anchor | undefined;
}

// @alpha
interface FieldChanges<TTree = ProtoNode> {
    readonly build?: readonly DetachedNodeBuild<TTree>[];
    readonly destroy?: readonly DetachedNodeDestruction[];
    readonly global?: readonly DetachedNodeChanges<TTree>[];
    readonly local?: readonly Mark<TTree>[];
    readonly rename?: readonly DetachedNodeRename[];
}

// @alpha
export type FieldGenerator = () => MapTree[];

// @alpha
export type FieldKey = Brand<string, "tree.FieldKey">;

// @alpha @sealed
export abstract class FieldKind<TName extends string = string, TMultiplicity extends Multiplicity = Multiplicity> implements FieldKindSpecifier {
    protected constructor(identifier: TName & FieldKindIdentifier, multiplicity: TMultiplicity);
    // (undocumented)
    readonly identifier: TName & FieldKindIdentifier;
    // (undocumented)
    readonly multiplicity: TMultiplicity;
}

// @alpha
export type FieldKindIdentifier = Brand<string, "tree.FieldKindIdentifier">;

// @alpha
export const FieldKinds: {
    readonly required: Required_2;
    readonly optional: Optional;
    readonly sequence: Sequence_2;
    readonly nodeKey: NodeKeyFieldKind;
    readonly forbidden: Forbidden;
};

// @alpha
export interface FieldKindSpecifier<T = FieldKindIdentifier> {
    // (undocumented)
    identifier: T;
}

// @alpha
export interface FieldLocation {
    // (undocumented)
    readonly key: FieldKey;
    // (undocumented)
    readonly parent: ForestLocation;
}

// @alpha (undocumented)
type FieldMap<TTree = ProtoNode> = ReadonlyMap<FieldKey, FieldChanges<TTree>>;

// @alpha
export interface FieldMapObject<TChild> {
    // (undocumented)
    [key: string]: TChild[];
}

// @alpha
export interface FieldNode<in out TSchema extends FieldNodeSchema> extends TreeNode {
    readonly boxedContent: TypedField<TSchema["objectNodeFieldsObject"][""]>;
    readonly content: UnboxField<TSchema["objectNodeFieldsObject"][""]>;
}

// @alpha
export type FieldNodeSchema = ObjectNodeSchema & {
    objectNodeFieldsObject: {
        [""]: TreeFieldSchema;
    };
};

// @alpha (undocumented)
interface Fields {
    // (undocumented)
    readonly [key: string]: TreeFieldSchema;
}

// @alpha
export function fieldSchema(kind: {
    identifier: FieldKindIdentifier;
}, types?: Iterable<TreeNodeSchemaIdentifier>): TreeFieldStoredSchema;

// @alpha
export interface FieldUpPath<TUpPath extends UpPath = UpPath> {
    readonly field: FieldKey;
    readonly parent: TUpPath | undefined;
}

// @alpha
type FixedSizeTypeArrayToTypedTree<T extends readonly TreeNodeSchema[]> = [
T extends readonly [infer Head, ...infer Tail] ? [
TypedNode<Assume<Head, TreeNodeSchema>>,
...FixedSizeTypeArrayToTypedTree<Assume<Tail, readonly TreeNodeSchema[]>>
] : []
][_InlineTrick];

// @alpha
type FlattenKeys<T> = [{
    [Property in keyof T]: T[Property];
}][_InlineTrick];

// @alpha
export type FlexibleFieldContent<TSchema extends TreeFieldSchema> = SchemaAware.TypedField<TSchema, SchemaAware.ApiMode.Flexible>;

// @alpha
export type FlexibleNodeContent<TTypes extends AllowedTypes> = SchemaAware.AllowedTypesToTypedTrees<SchemaAware.ApiMode.Flexible, TTypes>;

// @alpha
type FlexibleObject<TValueSchema extends ValueSchema | undefined, TName> = [
FlattenKeys<{
    [typeNameSymbol]?: UnbrandedName<TName>;
} & ValuePropertyFromSchema<TValueSchema>>
][_InlineTrick];

// @alpha
type FlexList<Item = unknown> = readonly LazyItem<Item>[];

// @alpha
type FlexListToNonLazyArray<List extends FlexList> = ArrayHasFixedLength<List> extends true ? ConstantFlexListToNonLazyArray<List> : NormalizedFlexList<ExtractListItemType<List>>;

// @alpha
export interface Flushable<T> {
    // (undocumented)
    flush(): T;
}

// @alpha
export interface FlushableBinderOptions<E extends Events<E>> extends BinderOptions {
    // (undocumented)
    autoFlush: boolean;
    // (undocumented)
    autoFlushPolicy: keyof Events<E>;
    // (undocumented)
    sortAnchorsFn?: AnchorsCompare;
}

// @alpha
export interface FlushableDataBinder<B extends OperationBinderEvents | InvalidationBinderEvents> extends DataBinder<B>, Flushable<FlushableDataBinder<B>> {
}

// @alpha (undocumented)
interface Forbidden extends FieldKind<typeof forbiddenFieldKindIdentifier, Multiplicity.Forbidden> {
}

// @alpha
export const forbiddenFieldKindIdentifier = "Forbidden";

// @alpha
export interface ForestEvents {
    afterChange(): void;
    beforeChange(): void;
}

// @alpha
export type ForestLocation = ITreeSubscriptionCursor | Anchor;

// @alpha
export enum ForestType {
    Optimized = 1,
    Reference = 0
}

// @alpha
export interface FullSchemaPolicy {
    readonly fieldKinds: ReadonlyMap<FieldKindIdentifier, FieldKind>;
}

// @alpha
export interface GenericFieldsNode<TChild> {
    // (undocumented)
    fields?: FieldMapObject<TChild>;
}

// @alpha
export interface GenericTreeNode<TChild> extends GenericFieldsNode<TChild>, NodeData {
}

// @alpha
export const getField: unique symbol;

// @alpha (undocumented)
export function getPrimaryField(schema: TreeNodeStoredSchema): {
    key: FieldKey;
    schema: TreeFieldStoredSchema;
} | undefined;

// @alpha (undocumented)
export interface HasListeners<E extends Events<E>> {
    hasListeners(eventName?: keyof Events<E>): boolean;
}

// @alpha
export interface ICodecOptions {
    readonly jsonValidator: JsonValidator;
}

// @alpha
export interface IdAllocator<TId = number> {
    allocate: (count?: number) => TId;
    // (undocumented)
    getNextId: () => TId;
}

// @alpha
export interface IDefaultEditBuilder {
    // (undocumented)
    addNodeExistsConstraint(path: UpPath): void;
    move(sourceField: FieldUpPath, sourceIndex: number, count: number, destinationField: FieldUpPath, destinationIndex: number): void;
    // (undocumented)
    optionalField(field: FieldUpPath): OptionalFieldEditBuilder;
    // (undocumented)
    sequenceField(field: FieldUpPath): SequenceFieldEditBuilder;
    // (undocumented)
    valueField(field: FieldUpPath): ValueFieldEditBuilder;
}

// @alpha
export interface IEditableForest extends IForestSubscription {
    acquireVisitor(): DeltaVisitor;
    readonly anchors: AnchorSet;
}

// @alpha
export interface IEmitter<E extends Events<E>> {
    emit<K extends keyof Events<E>>(eventName: K, ...args: Parameters<E[K]>): void;
    emitAndCollect<K extends keyof Events<E>>(eventName: K, ...args: Parameters<E[K]>): ReturnType<E[K]>[];
}

// @alpha
export interface IForestSubscription extends Dependee, ISubscribable<ForestEvents> {
    allocateCursor(): ITreeSubscriptionCursor;
    clone(schema: StoredSchemaRepository, anchors: AnchorSet): IEditableForest;
    forgetAnchor(anchor: Anchor): void;
    readonly isEmpty: boolean;
    moveCursorToPath(destination: UpPath | undefined, cursorToMove: ITreeSubscriptionCursor): void;
    tryMoveCursorToField(destination: FieldAnchor, cursorToMove: ITreeSubscriptionCursor): TreeNavigationResult;
    tryMoveCursorToNode(destination: Anchor, cursorToMove: ITreeSubscriptionCursor): TreeNavigationResult;
}

// @alpha
export type ImplicitAllowedTypes = AllowedTypes | TreeNodeSchema | Any;

// @alpha
export type ImplicitFieldSchema = TreeFieldSchema | ImplicitAllowedTypes;

// @alpha
export const indexSymbol: unique symbol;

// @alpha
export interface InitializeAndSchematizeConfiguration<TRoot extends TreeFieldSchema = TreeFieldSchema> extends TreeContent<TRoot>, SchematizeConfiguration<TRoot> {
}

// @alpha
type _InlineTrick = 0;

// @alpha
export interface InsertBindingContext extends BindingContext {
    // (undocumented)
    readonly content: ProtoNodes;
    // (undocumented)
    readonly path: UpPath;
    // (undocumented)
    readonly type: typeof BindingType.Insert;
}

declare namespace InternalEditableTreeTypes {
    export {
        TypedFieldInner,
        UnboxFieldInner,
        TypeArrayToTypedTreeArray_2 as TypeArrayToTypedTreeArray,
        ObjectNodeFields,
        UnboxField,
        UnboxNode,
        UnboxNodeUnion,
        NodeKeyField,
        IsArrayOfOne,
        UnknownUnboxed,
        FixedSizeTypeArrayToTypedTree,
        TypedNodeUnionHelper,
        NodeKeys
    }
}
export { InternalEditableTreeTypes }

declare namespace InternalTypedSchemaTypes {
    export {
        ObjectToMap,
        WithDefault,
        Unbrand,
        UnbrandList,
        ArrayToUnion,
        TreeSchemaSpecification,
        NormalizeObjectNodeFieldsInner,
        NormalizeObjectNodeFields,
        NormalizeField,
        Fields,
        ObjectSchemaSpecification,
        MapSchemaSpecification,
        LeafSchemaSpecification,
        MapFieldSchema,
        FlexList,
        FlexListToNonLazyArray,
        ConstantFlexListToNonLazyArray,
        LazyItem,
        NormalizedFlexList,
        ExtractItemType,
        ArrayHasFixedLength,
        ExtractListItemType
    }
}
export { InternalTypedSchemaTypes }

declare namespace InternalTypes {
    export {
        MakeNominal,
        Invariant,
        Contravariant,
        Covariant,
        BrandedType,
        ExtractFromOpaque,
        Assume,
        AllowOptional,
        RequiredFields,
        OptionalFields,
        _InlineTrick,
        _RecursiveTrick,
        FlattenKeys,
        AllowOptionalNotFlattened,
        isAny,
        RestrictiveReadonlyRecord,
        BrandedKeyContent,
        NormalizeField_2 as NormalizeField,
        NormalizeAllowedTypes,
        Required_2 as Required,
        Optional,
        NodeKeyFieldKind,
        Forbidden,
        Sequence_2 as SequenceFieldKind,
        FactoryObjectNodeSchema,
        FactoryObjectNodeSchemaRecursive,
        testRecursiveDomain
    }
}
export { InternalTypes }

declare namespace InternalTypes_2 {
    export {
        AllowedTypesToTypedTrees,
        CollectOptions,
        TypedFields,
        ApplyMultiplicity,
        ValuePropertyFromSchema,
        FlexibleObject,
        EditableSequenceField,
        EditableValueField,
        EditableOptionalField,
        TypedField_2 as TypedField,
        UnbrandedName,
        TypeArrayToTypedTreeArray,
        UntypedApi,
        EmptyObject,
        ValuesOf,
        TypedValueOrUndefined,
        PrimitiveValueSchema,
        UntypedSequenceField,
        UntypedOptionalField,
        UntypedValueField
    }
}

// @alpha
export interface InvalidationBinderEvents {
    // (undocumented)
    invalidation(context: InvalidationBindingContext): void;
}

// @alpha
export interface InvalidationBindingContext extends BindingContext {
    // (undocumented)
    readonly type: typeof BindingType.Invalidation;
}

// @alpha
export class InvalidationToken {
    constructor(description: string, isSecondaryInvalidation?: boolean);
    // (undocumented)
    readonly description: string;
    // (undocumented)
    readonly isSecondaryInvalidation: boolean;
    // (undocumented)
    protected readonly _typeCheck: MakeNominal;
}

// @alpha
interface Invariant<in out T> extends Contravariant<T>, Covariant<T> {
}

// @alpha
type isAny<T> = boolean extends (T extends never ? true : false) ? true : false;

// @alpha
type IsArrayOfOne<T extends readonly unknown[]> = T["length"] extends 1 ? true : 1 extends T["length"] ? boolean : false;

// @alpha
export function isContextuallyTypedNodeDataObject(data: ContextuallyTypedNodeData | undefined): data is ContextuallyTypedNodeDataObject;

// @alpha
export function isEditableField(field: UnwrappedEditableField): field is EditableField;

// @alpha
export function isEditableTree(field: UnwrappedEditableField): field is EditableTree;

// @alpha
export type IsEvent<Event> = Event extends (...args: any[]) => any ? true : false;

// @alpha
export interface ISharedTree extends ISharedObject, TypedTreeChannel {
    contentSnapshot(): SharedTreeContentSnapshot;
    schematizeView<TRoot extends TreeFieldSchema>(config: InitializeAndSchematizeConfiguration<TRoot>): ISharedTreeView;
    // @deprecated
    readonly view: ISharedTreeView;
}

// @alpha
export interface ISharedTreeBranchView extends ISharedTreeView {
    rebaseOnto(view: ISharedTreeView): void;
}

// @alpha
export interface ISharedTreeView extends AnchorLocator {
    readonly context: EditableTreeContext;
    editableTree2<TRoot extends TreeFieldSchema>(viewSchema: TreeSchema<TRoot>): TypedField<TRoot>;
    readonly editor: IDefaultEditBuilder;
    readonly events: ISubscribable<ViewEvents>;
    readonly forest: IForestSubscription;
    fork(): ISharedTreeBranchView;
    merge(view: ISharedTreeBranchView): void;
    merge(view: ISharedTreeBranchView, disposeView: boolean): void;
    rebase(view: ISharedTreeBranchView): void;
    get root(): UnwrappedEditableField;
    // (undocumented)
    root2<TRoot extends TreeFieldSchema>(viewSchema: TreeSchema<TRoot>): ProxyField<TRoot>;
    readonly rootEvents: ISubscribable<AnchorSetRootEvents>;
    setContent(data: NewFieldContent): void;
    readonly storedSchema: StoredSchemaRepository;
    readonly transaction: ITransaction;
}

// @alpha (undocumented)
export function isNeverField(policy: FullSchemaPolicy, originalData: TreeStoredSchema, field: TreeFieldStoredSchema): boolean;

// @alpha (undocumented)
export function isPrimitive(schema: TreeNodeStoredSchema): boolean;

// @alpha
export interface ISubscribable<E extends Events<E>> {
    on<K extends keyof Events<E>>(eventName: K, listener: E[K]): () => void;
}

// @alpha
export interface ITransaction {
    abort(): TransactionResult.Abort;
    commit(): TransactionResult.Commit;
    inProgress(): boolean;
    start(): void;
}

// @alpha
export interface ITreeCursor {
    readonly [CursorMarker]: true;
    readonly chunkLength: number;
    readonly chunkStart: number;
    enterField(key: FieldKey): void;
    enterNode(childIndex: number): void;
    exitField(): void;
    exitNode(): void;
    readonly fieldIndex: number;
    firstField(): boolean;
    firstNode(): boolean;
    getFieldKey(): FieldKey;
    // (undocumented)
    getFieldLength(): number;
    getFieldPath(prefix?: PathRootPrefix): FieldUpPath;
    getPath(prefix?: PathRootPrefix): UpPath | undefined;
    readonly mode: CursorLocationType;
    nextField(): boolean;
    nextNode(): boolean;
    // (undocumented)
    readonly pending: boolean;
    seekNodes(offset: number): boolean;
    skipPendingFields(): boolean;
    readonly type: TreeType;
    readonly value: Value;
}

// @alpha
export interface ITreeCursorSynchronous extends ITreeCursor {
    // (undocumented)
    readonly pending: false;
}

// @alpha
export interface ITreeSubscriptionCursor extends ITreeCursor {
    buildAnchor(): Anchor;
    buildFieldAnchor(): FieldAnchor;
    clear(): void;
    // (undocumented)
    fork(): ITreeSubscriptionCursor;
    free(): void;
    readonly state: ITreeSubscriptionCursorState;
}

// @alpha (undocumented)
export enum ITreeSubscriptionCursorState {
    Cleared = 1,
    Current = 0,
    Freed = 2
}

// @alpha
export interface JsonableTree extends GenericTreeNode<JsonableTree> {
}

// @alpha
export function jsonableTreeFromCursor(cursor: ITreeCursor): JsonableTree;

// @alpha (undocumented)
export const jsonArray: TreeNodeSchema<"com.fluidframework.json.array", {
objectNodeFields: {
"": TreeFieldSchema<Sequence_2, readonly [() => TreeNodeSchema<"com.fluidframework.json.object", {
mapFields: TreeFieldSchema<Optional, readonly [any, () => TreeNodeSchema<"com.fluidframework.json.array", any>, TreeNodeSchema<"com.fluidframework.leaf.number", {
leafValue: ValueSchema.Number;
}>, TreeNodeSchema<"com.fluidframework.leaf.boolean", {
leafValue: ValueSchema.Boolean;
}>, TreeNodeSchema<"com.fluidframework.leaf.string", {
leafValue: ValueSchema.String;
}>, TreeNodeSchema<"com.fluidframework.leaf.null", {
leafValue: ValueSchema.Null;
}>]>;
}>, () => TreeNodeSchema<"com.fluidframework.json.array", any>, TreeNodeSchema<"com.fluidframework.leaf.number", {
leafValue: ValueSchema.Number;
}>, TreeNodeSchema<"com.fluidframework.leaf.boolean", {
leafValue: ValueSchema.Boolean;
}>, TreeNodeSchema<"com.fluidframework.leaf.string", {
leafValue: ValueSchema.String;
}>, TreeNodeSchema<"com.fluidframework.leaf.null", {
leafValue: ValueSchema.Null;
}>]>;
};
}>;

// @alpha
export type JsonCompatible = string | number | boolean | null | JsonCompatible[] | JsonCompatibleObject;

// @alpha
export type JsonCompatibleObject = {
    [P in string]?: JsonCompatible;
};

// @alpha
export type JsonCompatibleReadOnly = string | number | boolean | null | readonly JsonCompatibleReadOnly[] | {
    readonly [P in string]?: JsonCompatibleReadOnly;
};

// @alpha (undocumented)
export const jsonObject: TreeNodeSchema<"com.fluidframework.json.object", {
mapFields: TreeFieldSchema<Optional, readonly [() => TreeNodeSchema<"com.fluidframework.json.object", any>, () => TreeNodeSchema<"com.fluidframework.json.array", {
objectNodeFields: {
"": TreeFieldSchema<Sequence_2, readonly [() => TreeNodeSchema<"com.fluidframework.json.object", any>, any, TreeNodeSchema<"com.fluidframework.leaf.number", {
leafValue: ValueSchema.Number;
}>, TreeNodeSchema<"com.fluidframework.leaf.boolean", {
leafValue: ValueSchema.Boolean;
}>, TreeNodeSchema<"com.fluidframework.leaf.string", {
leafValue: ValueSchema.String;
}>, TreeNodeSchema<"com.fluidframework.leaf.null", {
leafValue: ValueSchema.Null;
}>]>;
};
}>, TreeNodeSchema<"com.fluidframework.leaf.number", {
leafValue: ValueSchema.Number;
}>, TreeNodeSchema<"com.fluidframework.leaf.boolean", {
leafValue: ValueSchema.Boolean;
}>, TreeNodeSchema<"com.fluidframework.leaf.string", {
leafValue: ValueSchema.String;
}>, TreeNodeSchema<"com.fluidframework.leaf.null", {
leafValue: ValueSchema.Null;
}>]>;
}>;

// @alpha (undocumented)
export const jsonSchema: SchemaLibrary;

// @alpha
export interface JsonValidator {
    compile<Schema extends TSchema>(schema: Schema): SchemaValidationFunction<Schema>;
}

// @alpha
type LazyItem<Item = unknown> = Item | (() => Item);

// @alpha
export type LazyTreeNodeSchema = TreeNodeSchema | (() => TreeNodeSchema);

// @alpha
export interface Leaf<in out TSchema extends LeafSchema> extends TreeNode {
    readonly value: TreeValue<TSchema["leafValue"]>;
}

// @alpha
export const leaf: {
    number: TreeNodeSchema<"com.fluidframework.leaf.number", {
    leafValue: ValueSchema.Number;
    }>;
    boolean: TreeNodeSchema<"com.fluidframework.leaf.boolean", {
    leafValue: ValueSchema.Boolean;
    }>;
    string: TreeNodeSchema<"com.fluidframework.leaf.string", {
    leafValue: ValueSchema.String;
    }>;
    handle: TreeNodeSchema<"com.fluidframework.leaf.handle", {
    leafValue: ValueSchema.FluidHandle;
    }>;
    null: TreeNodeSchema<"com.fluidframework.leaf.null", {
    leafValue: ValueSchema.Null;
    }>;
    primitives: readonly [TreeNodeSchema<"com.fluidframework.leaf.number", {
    leafValue: ValueSchema.Number;
    }>, TreeNodeSchema<"com.fluidframework.leaf.boolean", {
    leafValue: ValueSchema.Boolean;
    }>, TreeNodeSchema<"com.fluidframework.leaf.string", {
    leafValue: ValueSchema.String;
    }>];
    all: readonly [TreeNodeSchema<"com.fluidframework.leaf.handle", {
    leafValue: ValueSchema.FluidHandle;
    }>, TreeNodeSchema<"com.fluidframework.leaf.null", {
    leafValue: ValueSchema.Null;
    }>, TreeNodeSchema<"com.fluidframework.leaf.number", {
    leafValue: ValueSchema.Number;
    }>, TreeNodeSchema<"com.fluidframework.leaf.boolean", {
    leafValue: ValueSchema.Boolean;
    }>, TreeNodeSchema<"com.fluidframework.leaf.string", {
    leafValue: ValueSchema.String;
    }>];
    library: SchemaLibrary;
};

// @alpha (undocumented)
export type LeafSchema = TreeNodeSchema & LeafSchemaSpecification;

// @alpha
interface LeafSchemaSpecification {
    // (undocumented)
    readonly leafValue: ValueSchema;
}

// @alpha (undocumented)
const library: SchemaLibrary;

// @alpha
export interface LocalNodeKey extends Opaque<Brand<SessionSpaceCompressedId, "Local Node Key">> {
}

// @alpha
export const localNodeKeySymbol: unique symbol;

// @alpha
interface MakeNominal {
}

// @alpha
type MapFieldSchema = TreeFieldSchema<typeof FieldKinds.optional | typeof FieldKinds.sequence>;

// @alpha
export interface MapNode<in out TSchema extends MapSchema> extends TreeNode {
    [boxedIterator](): IterableIterator<TypedField<TSchema["mapFields"]>>;
    // (undocumented)
    [Symbol.iterator](): IterableIterator<[FieldKey, UnboxField<TSchema["mapFields"], "notEmpty">]>;
    readonly asObject: {
        readonly [P in FieldKey]?: UnboxField<TSchema["mapFields"], "notEmpty">;
    };
    entries(): IterableIterator<[FieldKey, UnboxField<TSchema["mapFields"], "notEmpty">]>;
    forEach(callbackFn: (value: UnboxField<TSchema["mapFields"], "notEmpty">, key: FieldKey, map: MapNode<TSchema>) => void, thisArg?: any): void;
    get(key: string): UnboxField<TSchema["mapFields"]>;
    getBoxed(key: string): TypedField<TSchema["mapFields"]>;
    has(key: string): boolean;
    keys(): IterableIterator<FieldKey>;
    readonly size: number;
    values(): IterableIterator<UnboxField<TSchema["mapFields"], "notEmpty">>;
}

// @alpha (undocumented)
export type MapSchema = TreeNodeSchema & MapSchemaSpecification;

// @alpha
interface MapSchemaSpecification {
    // (undocumented)
    readonly mapFields: MapFieldSchema;
}

// @alpha
export interface MapTree extends NodeData {
    // (undocumented)
    fields: Map<FieldKey, MapTree[]>;
}

// @alpha
interface Mark<TTree = ProtoNode> {
    readonly attach?: DetachedNodeId;
    readonly count: number;
    readonly detach?: DetachedNodeId;
    readonly fields?: FieldMap<TTree>;
}

// @alpha
export interface MarkedArrayLike<TGet, TSet extends TGet = TGet> extends ArrayLikeMut<TGet, TSet> {
    // (undocumented)
    readonly [arrayLikeMarkerSymbol]: true;
    // (undocumented)
    [Symbol.iterator](): IterableIterator<TGet>;
}

// @alpha
export type MatchPolicy = SubtreePolicy | "subtree" | "path";

// @alpha
export enum Multiplicity {
    Forbidden = 3,
    Optional = 1,
    Sequence = 2,
    Single = 0
}

// @alpha
export interface Named<TName> {
    // (undocumented)
    readonly name: TName;
}

// @alpha
export interface NamedComputation {
    readonly computationName: string;
    listDependees?(): Iterable<Dependee>;
    listDependents?(): Iterable<Dependent>;
}

// @alpha
export type NameFromBranded<T extends BrandedType<any, string>> = T extends BrandedType<any, infer Name> ? Name : never;

// @alpha
export type NestedMap<Key1, Key2, Value> = Map<Key1, Map<Key2, Value>>;

// @alpha
export type NewFieldContent = ITreeCursorSynchronous | readonly ITreeCursorSynchronous[] | ContextuallyTypedFieldData;

// @alpha
export const node: NodeApi;

// @alpha
export interface NodeApi {
    readonly is: <TSchema extends TreeNodeSchema>(value: unknown, schema: TSchema) => value is ProxyNode<TSchema>;
    readonly key: (node: SharedTreeNode) => string | number;
    readonly on: <K extends keyof EditableTreeEvents>(node: SharedTreeNode, eventName: K, listener: EditableTreeEvents[K]) => () => void;
    readonly parent: (node: SharedTreeNode) => SharedTreeNode | undefined;
    readonly schema: (node: SharedTreeNode) => TreeNodeSchema;
    readonly status: (node: SharedTreeNode) => TreeStatus;
}

// @alpha
export interface NodeData {
    readonly type: TreeNodeSchemaIdentifier;
    value?: TreeValue;
}

// @alpha @deprecated
type NodeDataFor<Mode extends ApiMode, TSchema extends TreeNodeSchema> = TypedNode_2<TSchema, Mode>;

// @alpha (undocumented)
export interface NodeExistsConstraint {
    // (undocumented)
    violated: boolean;
}

// @alpha
export type NodeIndex = number;

// @alpha
interface NodeKeyField extends TreeField {
    // (undocumented)
    readonly localNodeKey: LocalNodeKey;
    // (undocumented)
    readonly stableNodeKey: StableNodeKey;
}

// @alpha
export const nodeKeyField: {
    __n_id__: TreeFieldSchema<NodeKeyFieldKind, readonly [TreeNodeSchema<"com.fluidframework.nodeKey.NodeKey", {
    leafValue: ValueSchema.String;
    }>]>;
};

// @alpha
export const nodeKeyFieldKey = "__n_id__";

// @alpha (undocumented)
interface NodeKeyFieldKind extends FieldKind<"NodeKey", Multiplicity.Single> {
}

// @alpha
interface NodeKeys {
    generate(): LocalNodeKey;
    localize(key: StableNodeKey): LocalNodeKey;
    readonly map: ReadonlyMap<LocalNodeKey, ObjectNode>;
    stabilize(key: LocalNodeKey): StableNodeKey;
}

// @alpha
export const nodeKeySchema: SchemaLibrary;

// @alpha
export type NoListenersCallback<E extends Events<E>> = (eventName: keyof Events<E>) => void;

// @alpha
export const noopValidator: JsonValidator;

// @alpha
type NormalizeAllowedTypes<TSchema extends ImplicitAllowedTypes> = TSchema extends TreeNodeSchema ? readonly [TSchema] : TSchema extends Any ? readonly [Any] : TSchema;

// @alpha (undocumented)
type NormalizedFlexList<Item> = readonly Item[];

// @alpha
type NormalizeField<T extends TreeFieldSchema | undefined> = T extends TreeFieldSchema ? T : TreeFieldSchema<typeof FieldKinds.forbidden, []>;

// @alpha
type NormalizeField_2<TSchema extends ImplicitFieldSchema, TDefault extends FieldKind> = TSchema extends TreeFieldSchema ? TSchema : TreeFieldSchema<TDefault, NormalizeAllowedTypes<Assume<TSchema, ImplicitAllowedTypes>>>;

// @alpha (undocumented)
type NormalizeObjectNodeFields<T extends Fields | undefined> = NormalizeObjectNodeFieldsInner<WithDefault<T, Record<string, never>>>;

// @alpha (undocumented)
type NormalizeObjectNodeFieldsInner<T extends Fields> = {
    [Property in keyof T]: NormalizeField<T[Property]>;
};

// @alpha
export type ObjectFields<TFields extends RestrictiveReadonlyRecord<string, TreeFieldSchema>, API extends "javaScript" | "sharedTree" = "sharedTree"> = {
    -readonly [key in keyof TFields as TFields[key]["kind"] extends AssignableFieldKinds ? TFields[key]["kind"] extends typeof FieldKinds.optional ? key : never : never]?: ProxyField<TFields[key], API>;
} & {
    -readonly [key in keyof TFields as TFields[key]["kind"] extends AssignableFieldKinds ? TFields[key]["kind"] extends typeof FieldKinds.optional ? never : key : never]-?: ProxyField<TFields[key], API>;
} & {
    readonly [key in keyof TFields as TFields[key]["kind"] extends AssignableFieldKinds ? never : TFields[key]["kind"] extends typeof FieldKinds.optional ? key : never]?: ProxyField<TFields[key], API>;
} & {
    readonly [key in keyof TFields as TFields[key]["kind"] extends AssignableFieldKinds ? never : TFields[key]["kind"] extends typeof FieldKinds.optional ? never : key]-?: ProxyField<TFields[key], API>;
};

// @alpha
export interface ObjectNode extends TreeNode {
    readonly localNodeKey?: LocalNodeKey;
}

// @alpha
type ObjectNodeFields<TFields extends RestrictiveReadonlyRecord<string, TreeFieldSchema>> = FlattenKeys<{
    readonly [key in keyof TFields as `boxed${Capitalize<key & string>}`]: TypedField<TFields[key]>;
} & {
    readonly [key in keyof TFields as TFields[key]["kind"] extends AssignableFieldKinds ? never : key]: UnboxField<TFields[key]>;
} & {
    -readonly [key in keyof TFields as TFields[key]["kind"] extends AssignableFieldKinds ? key : never]: UnboxField<TFields[key]>;
} & {
    readonly [key in keyof TFields as TFields[key]["kind"] extends AssignableFieldKinds ? `set${Capitalize<key & string>}` : never]: (content: FlexibleFieldContent<TFields[key]>) => void;
}>;

// @alpha
export type ObjectNodeSchema = TreeNodeSchema & {
    [P in keyof (MapSchemaSpecification & LeafSchemaSpecification)]?: undefined;
};

// @alpha
export type ObjectNodeTyped<TSchema extends ObjectNodeSchema> = ObjectNodeSchema extends TSchema ? ObjectNode : ObjectNode & ObjectNodeFields<TSchema["objectNodeFieldsObject"]>;

// @alpha
interface ObjectSchemaSpecification {
    // (undocumented)
    readonly objectNodeFields: RestrictiveReadonlyRecord<string, TreeFieldSchema>;
}

// @alpha
type ObjectToMap<ObjectMap, MapKey extends number | string, MapValue> = ReadonlyMap<MapKey, MapValue> & {
    get<TKey extends keyof ObjectMap>(key: TKey): ObjectMap[TKey];
};

// @alpha
export interface ObservingDependent extends Dependent {
    // @override
    listDependees(): Iterable<Dependee>;
    registerDependee(dependee: Dependee): void;
}

// @alpha
export const on: unique symbol;

// @alpha
export function oneFromSet<T>(set: ReadonlySet<T> | undefined): T | undefined;

// @alpha
export type Opaque<T extends Brand<any, string>> = T extends Brand<infer ValueType, infer Name> ? BrandedType<ValueType, Name> : never;

// @alpha
export interface OperationBinderEvents {
    // (undocumented)
    batch(context: BatchBindingContext): void;
    // (undocumented)
    delete(context: DeleteBindingContext): void;
    // (undocumented)
    insert(context: InsertBindingContext): void;
}

// @alpha (undocumented)
interface Optional extends FieldKind<"Optional", Multiplicity.Optional> {
}

// @alpha
export interface OptionalField<TTypes extends AllowedTypes> extends TreeField {
    // (undocumented)
    readonly boxedContent?: TypedNodeUnion<TTypes>;
    // (undocumented)
    get content(): UnboxNodeUnion<TTypes> | undefined;
    set content(newContent: FlexibleNodeContent<TTypes> | undefined);
}

// @alpha (undocumented)
export interface OptionalFieldEditBuilder {
    set(newContent: ITreeCursor | undefined, wasEmpty: boolean): void;
}

// @alpha
type OptionalFields<T> = [
    {
    [P in keyof T as undefined extends T[P] ? T[P] extends undefined ? never : P : never]?: T[P];
}
][_InlineTrick];

// @alpha
export const parentField: unique symbol;

// @alpha
export interface PathRootPrefix {
    indexOffset?: number;
    parent?: UpPath | undefined;
    rootFieldOverride?: FieldKey;
}

// @alpha
export interface PathStep {
    readonly field: FieldKey;
    readonly index?: number;
}

// @alpha
export interface PathVisitor {
    afterAttach(source: DetachedPlaceUpPath, destination: RangeUpPath): void;
    afterCreate(content: DetachedRangeUpPath): void;
    afterDetach(source: PlaceUpPath, destination: DetachedRangeUpPath): void;
    afterReplace(newContentSource: DetachedPlaceUpPath, newContent: RangeUpPath, oldContent: DetachedRangeUpPath): void;
    beforeAttach(source: DetachedRangeUpPath, destination: PlaceUpPath): void;
    beforeDestroy(content: DetachedRangeUpPath): void;
    beforeDetach(source: RangeUpPath, destination: DetachedPlaceUpPath): void;
    beforeReplace(newContent: DetachedRangeUpPath, oldContent: RangeUpPath, oldContentDestination: DetachedPlaceUpPath): void;
    // @deprecated
    onDelete(path: UpPath, count: number): void;
    // @deprecated (undocumented)
    onInsert(path: UpPath, content: Delta.ProtoNodes): void;
}

// @alpha
export type PlaceIndex = number;

// @alpha
export interface PlaceUpPath<TUpPath extends UpPath = UpPath> extends FieldUpPath<TUpPath> {
    readonly index: PlaceIndex;
}

// @alpha
export function prefixFieldPath(prefix: PathRootPrefix | undefined, path: FieldUpPath): FieldUpPath;

// @alpha
export function prefixPath(prefix: PathRootPrefix | undefined, path: UpPath | undefined): UpPath | undefined;

// @alpha (undocumented)
export type PrimitiveValue = string | boolean | number;

// @alpha
type PrimitiveValueSchema = ValueSchema.Number | ValueSchema.String | ValueSchema.Boolean;

// @alpha
type ProtoNode = ITreeCursorSynchronous;

// @alpha
type ProtoNodes = readonly ProtoNode[];

// @alpha
export type ProxyField<TSchema extends TreeFieldSchema, API extends "javaScript" | "sharedTree" = "sharedTree", Emptiness extends "maybeEmpty" | "notEmpty" = "maybeEmpty"> = ProxyFieldInner<TSchema["kind"], TSchema["allowedTypes"], API, Emptiness>;

// @alpha
export type ProxyFieldInner<Kind extends FieldKind, TTypes extends AllowedTypes, API extends "javaScript" | "sharedTree", Emptiness extends "maybeEmpty" | "notEmpty"> = Kind extends typeof FieldKinds.sequence ? never : Kind extends typeof FieldKinds.required ? ProxyNodeUnion<TTypes, API> : Kind extends typeof FieldKinds.optional ? ProxyNodeUnion<TTypes, API> | (Emptiness extends "notEmpty" ? never : undefined) : unknown;

// @alpha
export type ProxyNode<TSchema extends TreeNodeSchema, API extends "javaScript" | "sharedTree" = "sharedTree"> = TSchema extends LeafSchema ? TreeValue<TSchema["leafValue"]> : TSchema extends MapSchema ? API extends "sharedTree" ? SharedTreeMap<TSchema> : Map<string, ProxyField<TSchema["mapFields"], API>> : TSchema extends FieldNodeSchema ? API extends "sharedTree" ? SharedTreeList<TSchema["objectNodeFieldsObject"][""]["allowedTypes"], API> : readonly ProxyNodeUnion<TSchema["objectNodeFieldsObject"][""]["allowedTypes"], API>[] : TSchema extends ObjectNodeSchema ? SharedTreeObject<TSchema, API> : unknown;

// @alpha
export type ProxyNodeUnion<TTypes extends AllowedTypes, API extends "javaScript" | "sharedTree" = "sharedTree"> = TTypes extends readonly [Any] ? unknown : {
    [Index in keyof TTypes]: TTypes[Index] extends InternalTypedSchemaTypes.LazyItem<infer InnerType> ? InnerType extends TreeNodeSchema ? ProxyNode<InnerType, API> : never : never;
}[number];

// @alpha
export const proxyTargetSymbol: unique symbol;

// @alpha
interface Range_2 {
    readonly end: PlaceIndex;
    readonly start: PlaceIndex;
}
export { Range_2 as Range }

// @alpha
export interface RangeEntry<T> {
    // (undocumented)
    length: number;
    // (undocumented)
    start: number;
    // (undocumented)
    value: T;
}

// @alpha
export interface RangeUpPath<TUpPath extends UpPath = UpPath> extends FieldUpPath<TUpPath>, Range_2 {
}

// @alpha
export function recordDependency(dependent: ObservingDependent | undefined, dependee: Dependee): void;

// @alpha (undocumented)
const recursiveObject: FactoryObjectNodeSchemaRecursive<"Test Recursive Domain", "object", {
readonly recursive: TreeFieldSchema<Optional, readonly [() => FactoryObjectNodeSchemaRecursive<"Test Recursive Domain", "object", any>]>;
readonly number: TreeNodeSchema<"com.fluidframework.leaf.number", {
leafValue: import("..").ValueSchema.Number;
}>;
}>;

// @alpha (undocumented)
const recursiveObject2: FactoryObjectNodeSchema<"Test Recursive Domain", "object2", {
readonly recursive: TreeFieldSchema<Optional, readonly [() => FactoryObjectNodeSchema<"Test Recursive Domain", "object2", any>]>;
readonly number: TreeNodeSchema<"com.fluidframework.leaf.number", {
leafValue: import("..").ValueSchema.Number;
}>;
}>;

// @alpha
type _RecursiveTrick = never;

// @alpha (undocumented)
interface Required_2 extends FieldKind<"Value", Multiplicity.Single> {
}

// @alpha
export interface RequiredField<TTypes extends AllowedTypes> extends TreeField {
    // (undocumented)
    readonly boxedContent: TypedNodeUnion<TTypes>;
    // (undocumented)
    get content(): UnboxNodeUnion<TTypes>;
    set content(content: FlexibleNodeContent<TTypes>);
}

// @alpha
type RequiredFields<T> = [
    {
    [P in keyof T as undefined extends T[P] ? never : P]: T[P];
}
][_InlineTrick];

// @alpha
type RestrictiveReadonlyRecord<K extends symbol | string, T> = {
    readonly [P in symbol | string]: P extends K ? T : never;
};

// @alpha
export interface Revertible {
    discard(): DiscardResult;
    readonly kind: RevertibleKind;
    // (undocumented)
    readonly origin: {
        readonly isLocal: boolean;
    };
    revert(): RevertResult;
}

// @alpha
export enum RevertibleKind {
    Default = 0,
    Rebase = 3,
    Redo = 2,
    Undo = 1
}

// @alpha
export enum RevertResult {
    Failure = 1,
    Success = 0
}

// @alpha
type Root<TTree = ProtoNode> = FieldMap<TTree>;

// @alpha
export interface RootField {
    // (undocumented)
    readonly key: DetachedField;
}

// @alpha (undocumented)
export const rootField: DetachedField;

// @alpha
export const rootFieldKey: FieldKey;

// @alpha
export function runSynchronous(view: ISharedTreeView, transaction: (view: ISharedTreeView) => TransactionResult | void): TransactionResult;

declare namespace SchemaAware {
    export {
        ApiMode,
        NodeDataFor,
        TypedNode_2 as TypedNode,
        TypedField_2 as TypedField,
        AllowedTypesToTypedTrees,
        downCast,
        InternalTypes_2 as InternalTypes
    }
}
export { SchemaAware }

// @alpha @sealed
export class SchemaBuilder<TScope extends string = string, TName extends string | number = string> extends SchemaBuilderBase<TScope, typeof FieldKinds.required, TName> {
    constructor(options: SchemaBuilderOptions<TScope>);
    // (undocumented)
    readonly boolean: TreeNodeSchema<"com.fluidframework.leaf.boolean", {
        leafValue: import("..").ValueSchema.Boolean;
    }>;
    fixRecursiveReference<T extends AllowedTypes>(...types: T): void;
    // (undocumented)
    readonly handle: TreeNodeSchema<"com.fluidframework.leaf.handle", {
        leafValue: import("..").ValueSchema.FluidHandle;
    }>;
    list<const T extends TreeNodeSchema | Any | readonly TreeNodeSchema[]>(allowedTypes: T): TreeNodeSchema<`${TScope}.List<${string}>`, {
        objectNodeFields: {
            [""]: TreeFieldSchema<typeof FieldKinds.sequence, NormalizeAllowedTypes<T>>;
        };
    }>;
    list<Name extends TName, const T extends ImplicitAllowedTypes>(name: Name, allowedTypes: T): TreeNodeSchema<`${TScope}.${Name}`, {
        objectNodeFields: {
            [""]: TreeFieldSchema<typeof FieldKinds.sequence, NormalizeAllowedTypes<T>>;
        };
    }>;
    map<const T extends TreeNodeSchema | Any | readonly TreeNodeSchema[]>(allowedTypes: T): TreeNodeSchema<`${TScope}.Map<${string}>`, {
        mapFields: NormalizeField_2<T, typeof FieldKinds.optional>;
    }>;
    map<Name extends TName, const T extends MapFieldSchema | ImplicitAllowedTypes>(name: Name, fieldSchema: T): TreeNodeSchema<`${TScope}.${Name}`, {
        mapFields: NormalizeField_2<T, typeof FieldKinds.optional>;
    }>;
    // (undocumented)
    readonly null: TreeNodeSchema<"com.fluidframework.leaf.null", {
        leafValue: import("..").ValueSchema.Null;
    }>;
    // (undocumented)
    readonly number: TreeNodeSchema<"com.fluidframework.leaf.number", {
        leafValue: import("..").ValueSchema.Number;
    }>;
    // (undocumented)
    object<const Name extends TName, const T extends RestrictiveReadonlyRecord<string, ImplicitFieldSchema>>(name: Name, t: T): FactoryObjectNodeSchema<TScope, Name, T>;
    // (undocumented)
    objectRecursive<const Name extends TName, const T extends Unenforced<RestrictiveReadonlyRecord<string, ImplicitFieldSchema>>>(name: Name, t: T): FactoryObjectNodeSchemaRecursive<TScope, Name, T>;
    static optional: <const T extends ImplicitAllowedTypes>(allowedTypes: T) => TreeFieldSchema<Optional, NormalizeAllowedTypes<T>>;
    readonly optional: <const T extends ImplicitAllowedTypes>(allowedTypes: T) => TreeFieldSchema<Optional, NormalizeAllowedTypes<T>>;
    static required: <const T extends ImplicitAllowedTypes>(allowedTypes: T) => TreeFieldSchema<Required_2, NormalizeAllowedTypes<T>>;
    readonly required: <const T extends ImplicitAllowedTypes>(allowedTypes: T) => TreeFieldSchema<Required_2, NormalizeAllowedTypes<T>>;
    static sequence: <const T extends ImplicitAllowedTypes>(allowedTypes: T) => TreeFieldSchema<Sequence_2, NormalizeAllowedTypes<T>>;
    readonly sequence: <const T extends ImplicitAllowedTypes>(allowedTypes: T) => TreeFieldSchema<Sequence_2, NormalizeAllowedTypes<T>>;
    // (undocumented)
    readonly string: TreeNodeSchema<"com.fluidframework.leaf.string", {
        leafValue: import("..").ValueSchema.String;
    }>;
}

// @alpha
export class SchemaBuilderBase<TScope extends string, TDefaultKind extends FieldKind, TName extends number | string = string> {
    constructor(defaultKind: TDefaultKind, options: SchemaBuilderOptions<TScope>);
    // (undocumented)
    protected addNodeSchema<T extends TreeNodeSchema<string, any>>(schema: T): void;
    static field<Kind extends FieldKind, T extends ImplicitAllowedTypes>(kind: Kind, allowedTypes: T): TreeFieldSchema<Kind, NormalizeAllowedTypes<T>>;
    fieldNode<Name extends TName, const T extends ImplicitFieldSchema>(name: Name, fieldSchema: T): TreeNodeSchema<`${TScope}.${Name}`, {
        objectNodeFields: {
            [""]: NormalizeField_2<T, TDefaultKind>;
        };
    }>;
    fieldNodeRecursive<Name extends TName, const T extends Unenforced<ImplicitFieldSchema>>(name: Name, t: T): TreeNodeSchema<`${TScope}.${Name}`, {
        objectNodeFields: {
            [""]: T;
        };
    }>;
    static fieldRecursive<Kind extends FieldKind, T extends FlexList<Unenforced<TreeNodeSchema>>>(kind: Kind, ...allowedTypes: T): TreeFieldSchema<Kind, T>;
    intoLibrary(): SchemaLibrary;
    intoSchema<const TSchema extends ImplicitFieldSchema>(root: TSchema): TreeSchema<NormalizeField_2<TSchema, TDefaultKind>>;
    map<Name extends TName, const T extends MapFieldSchema>(name: Name, fieldSchema: T): TreeNodeSchema<`${TScope}.${Name}`, {
        mapFields: T;
    }>;
    mapRecursive<Name extends TName, const T extends Unenforced<MapFieldSchema>>(name: Name, t: T): TreeNodeSchema<`${TScope}.${Name}`, {
        mapFields: T;
    }>;
    readonly name: string;
    protected normalizeField<TSchema extends ImplicitFieldSchema>(schema: TSchema): NormalizeField_2<TSchema, TDefaultKind>;
    object<const Name extends TName, const T extends RestrictiveReadonlyRecord<string, ImplicitFieldSchema>>(name: Name, t: T): TreeNodeSchema<`${TScope}.${Name}`, {
        objectNodeFields: {
            [key in keyof T]: NormalizeField_2<T[key], TDefaultKind>;
        };
    }>;
    objectRecursive<const Name extends TName, const T extends Unenforced<RestrictiveReadonlyRecord<string, ImplicitFieldSchema>>>(name: Name, t: T): TreeNodeSchema<`${TScope}.${Name}`, {
        objectNodeFields: T;
    }>;
    readonly scope: TScope;
    // (undocumented)
    protected scoped<Name extends TName>(name: Name): `${TScope}.${Name}` & TreeNodeSchemaIdentifier;
}

// @alpha
export interface SchemaBuilderOptions<TScope extends string = string> {
    libraries?: SchemaLibrary[];
    lint?: Partial<SchemaLintConfiguration>;
    name?: string;
    scope: TScope;
}

// @alpha
export interface SchemaCollection extends StoredSchemaCollection {
    readonly treeSchema: ReadonlyMap<TreeNodeSchemaIdentifier, TreeNodeSchema>;
}

// @alpha
export interface SchemaConfiguration<TRoot extends TreeFieldSchema = TreeFieldSchema> {
    readonly schema: TreeSchema<TRoot>;
}

// @alpha
export interface SchemaEvents {
    afterSchemaChange(newSchema: TreeStoredSchema): void;
    beforeSchemaChange(newSchema: TreeStoredSchema): void;
}

// @alpha
export function schemaIsFieldNode(schema: TreeNodeSchema): schema is FieldNodeSchema;

// @alpha
export interface SchemaLibrary extends SchemaCollection {
    readonly libraries: ReadonlySet<SchemaLibraryData>;
}

// @alpha
export interface SchemaLibraryData extends SchemaCollection {
    // (undocumented)
    readonly adapters: Adapters;
    // (undocumented)
    readonly name: string;
}

// @alpha
export interface SchemaLintConfiguration {
    // (undocumented)
    readonly rejectEmpty: boolean;
    // (undocumented)
    readonly rejectForbidden: boolean;
}

// @alpha
export interface SchematizeConfiguration<TRoot extends TreeFieldSchema = TreeFieldSchema> extends SchemaConfiguration<TRoot> {
    readonly allowedSchemaModifications: AllowedUpdateType;
}

// @alpha
export interface SchemaValidationFunction<Schema extends TSchema> {
    // (undocumented)
    check(data: unknown): data is Static<Schema>;
}

// @alpha
export interface Sequence<in out TTypes extends AllowedTypes> extends TreeField {
    // (undocumented)
    [boxedIterator](): IterableIterator<TypedNodeUnion<TTypes>>;
    // (undocumented)
    [Symbol.iterator](): IterableIterator<UnboxNodeUnion<TTypes>>;
    readonly asArray: readonly UnboxNodeUnion<TTypes>[];
    at(index: number): UnboxNodeUnion<TTypes>;
    boxedAt(index: number): TypedNodeUnion<TTypes>;
    insertAt(index: number, value: Iterable<FlexibleNodeContent<TTypes>>): void;
    insertAtEnd(value: Iterable<FlexibleNodeContent<TTypes>>): void;
    insertAtStart(value: Iterable<FlexibleNodeContent<TTypes>>): void;
    // (undocumented)
    readonly length: number;
    map<U>(callbackfn: (value: UnboxNodeUnion<TTypes>, index: number) => U): U[];
    mapBoxed<U>(callbackfn: (value: TypedNodeUnion<TTypes>, index: number) => U): U[];
    moveToEnd(sourceStart: number, sourceEnd: number): void;
    moveToEnd<TTypesSource extends AllowedTypes>(sourceStart: number, sourceEnd: number, source: Sequence<CheckTypesOverlap<TTypesSource, TTypes>>): void;
    moveToIndex(index: number, sourceStart: number, sourceEnd: number): void;
    moveToIndex<TTypesSource extends AllowedTypes>(index: number, sourceStart: number, sourceEnd: number, source: Sequence<CheckTypesOverlap<TTypesSource, TTypes>>): void;
    moveToStart(sourceStart: number, sourceEnd: number): void;
    moveToStart<TTypesSource extends AllowedTypes>(sourceStart: number, sourceEnd: number, source: Sequence<CheckTypesOverlap<TTypesSource, TTypes>>): void;
    removeAt(index: number): void;
    removeRange(start?: number, end?: number): void;
}

// @alpha (undocumented)
interface Sequence_2 extends FieldKind<"Sequence", Multiplicity.Sequence> {
}

// @alpha (undocumented)
export interface SequenceFieldEditBuilder {
    delete(index: number, count: number): void;
    insert(index: number, newContent: ITreeCursor | readonly ITreeCursor[]): void;
    move(sourceIndex: number, count: number, destIndex: number): void;
}

// @alpha
export interface SharedTreeContentSnapshot {
    readonly schema: TreeStoredSchema;
    readonly tree: JsonableTree[];
}

// @alpha
export class SharedTreeFactory implements IChannelFactory {
    constructor(options?: SharedTreeOptions);
    // (undocumented)
    readonly attributes: IChannelAttributes;
    // (undocumented)
    create(runtime: IFluidDataStoreRuntime, id: string): ISharedTree;
    // (undocumented)
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, channelAttributes: Readonly<IChannelAttributes>): Promise<ISharedTree>;
    // (undocumented)
    readonly type: string;
}

// @alpha
export interface SharedTreeList<TTypes extends AllowedTypes, API extends "javaScript" | "sharedTree" = "sharedTree"> extends ReadonlyArray<ProxyNodeUnion<TTypes, API>> {
    insertAt(index: number, value: Iterable<ProxyNodeUnion<TTypes>>): void;
    insertAtEnd(value: Iterable<ProxyNodeUnion<TTypes>>): void;
    insertAtStart(value: Iterable<ProxyNodeUnion<TTypes>>): void;
    moveToEnd(sourceStart: number, sourceEnd: number): void;
    moveToEnd<TTypesSource extends AllowedTypes>(sourceStart: number, sourceEnd: number, source: SharedTreeList<CheckTypesOverlap<TTypesSource, TTypes>>): void;
    moveToIndex(index: number, sourceStart: number, sourceEnd: number): void;
    moveToIndex<TTypesSource extends AllowedTypes>(index: number, sourceStart: number, sourceEnd: number, source: SharedTreeList<CheckTypesOverlap<TTypesSource, TTypes>>): void;
    moveToStart(sourceStart: number, sourceEnd: number): void;
    moveToStart<TTypesSource extends AllowedTypes>(sourceStart: number, sourceEnd: number, source: SharedTreeList<CheckTypesOverlap<TTypesSource, TTypes>>): void;
    removeAt(index: number): void;
    removeRange(start?: number, end?: number): void;
}

// @alpha
export type SharedTreeMap<TSchema extends MapSchema> = Map<string, ProxyNode<TSchema>>;

// @alpha
export type SharedTreeNode = SharedTreeList<AllowedTypes> | SharedTreeObject<ObjectNodeSchema> | SharedTreeMap<MapSchema>;

// @alpha
export type SharedTreeObject<TSchema extends ObjectNodeSchema, API extends "javaScript" | "sharedTree" = "sharedTree"> = ObjectFields<TSchema["objectNodeFieldsObject"], API>;

// @alpha
export interface SharedTreeObjectFactory<TSchema extends TreeNodeSchema<string, unknown>> {
    create(content: ProxyNode<Assume<TSchema, ObjectNodeSchema>, "javaScript">): SharedTreeObject<Assume<TSchema, ObjectNodeSchema>>;
}

// @alpha (undocumented)
export interface SharedTreeOptions extends Partial<ICodecOptions> {
    forest?: ForestType;
}

// @alpha
export class SimpleDependee implements Dependee {
    constructor(computationName?: string);
    // (undocumented)
    readonly computationName: string;
    invalidateDependents(token?: InvalidationToken): void;
    // @sealed (undocumented)
    listDependents(): Set<Dependent>;
    // (undocumented)
    registerDependent(dependent: Dependent): boolean;
    // (undocumented)
    removeDependent(dependent: Dependent): void;
}

// @alpha
export function singleJsonCursor(root: JsonCompatible): ITreeCursorSynchronous;

// @alpha
export function singleStackTreeCursor<TNode>(root: TNode, adapter: CursorAdapter<TNode>): CursorWithNode<TNode>;

// @alpha
export function singleTextCursor(root: JsonableTree): ITreeCursorSynchronous;

// @alpha
export type StableNodeKey = Brand<StableId, "Stable Node Key">;

// @alpha
export interface StoredSchemaCollection {
    readonly treeSchema: ReadonlyMap<TreeNodeSchemaIdentifier, TreeNodeStoredSchema>;
}

// @alpha
export interface StoredSchemaRepository extends Dependee, ISubscribable<SchemaEvents>, TreeStoredSchema {
    update(newSchema: TreeStoredSchema): void;
}

// @alpha
export interface SubtreePolicy {
    // (undocumented)
    maxDepth: number;
}

declare namespace testRecursiveDomain {
    export {
        recursiveObject,
        recursiveObject2,
        library
    }
}

// @alpha
export function toDownPath(upPath: UpPath): DownPath;

// @alpha
export enum TransactionResult {
    Abort = 0,
    Commit = 1
}

// @alpha
export interface Tree<out TSchema = unknown> {
    [boxedIterator](): IterableIterator<Tree>;
    readonly context: TreeContext;
    readonly schema: TSchema;
    treeStatus(): TreeStatus;
}

// @alpha (undocumented)
export interface TreeAdapter {
    // (undocumented)
    readonly input: TreeNodeSchemaIdentifier;
    // (undocumented)
    readonly output: TreeNodeSchemaIdentifier;
}

// @alpha
export interface TreeContent<TRoot extends TreeFieldSchema = TreeFieldSchema> extends SchemaConfiguration<TRoot> {
    readonly initialTree: SchemaAware.TypedField<TRoot, SchemaAware.ApiMode.Flexible> | readonly ITreeCursorSynchronous[] | ITreeCursorSynchronous;
}

// @alpha
export interface TreeContext extends ISubscribable<ForestEvents> {
    // (undocumented)
    readonly nodeKeys: NodeKeys;
    get root(): TreeField;
    readonly schema: TreeSchema;
}

// @alpha
export interface TreeDataContext {
    fieldSource?(key: FieldKey, schema: TreeFieldStoredSchema): undefined | FieldGenerator;
    readonly schema: TreeStoredSchema;
}

// @alpha
export interface TreeEvent {
    readonly target: TreeNode;
}

// @alpha
export interface TreeField extends Tree<TreeFieldSchema> {
    // (undocumented)
    [boxedIterator](): IterableIterator<TreeNode>;
    is<TSchema extends TreeFieldSchema>(schema: TSchema): this is TypedField<TSchema>;
    isSameAs(other: TreeField): boolean;
    readonly key: FieldKey;
    readonly parent?: TreeNode;
}

// @alpha @sealed
export class TreeFieldSchema<out TKind extends FieldKind = FieldKind, const out TTypes extends Unenforced<AllowedTypes> = AllowedTypes> {
    // (undocumented)
    readonly allowedTypes: TTypes;
    get allowedTypeSet(): AllowedTypeSet;
    static create<TKind extends FieldKind, const Types extends AllowedTypes>(kind: TKind, allowedTypes: Types): TreeFieldSchema<TKind, Types>;
    static createUnsafe<TKind extends FieldKind, const Types>(kind: TKind, allowedTypes: Types): TreeFieldSchema<TKind, Types>;
    static readonly empty: TreeFieldSchema<Forbidden, readonly []>;
    equals(other: TreeFieldSchema): boolean;
    // (undocumented)
    readonly kind: TKind;
    // (undocumented)
    protected _typeCheck?: MakeNominal;
    get types(): TreeTypeSet;
}

// @alpha (undocumented)
export interface TreeFieldStoredSchema {
    // (undocumented)
    readonly kind: FieldKindSpecifier;
    readonly types?: TreeTypeSet;
}

// @alpha (undocumented)
export interface TreeLocation {
    // (undocumented)
    readonly index: number;
    // (undocumented)
    readonly range: FieldLocation | DetachedField;
}

// @alpha (undocumented)
export const enum TreeNavigationResult {
    NotFound = -1,
    Ok = 1,
    Pending = 0
}

// @alpha
export interface TreeNode extends Tree<TreeNodeSchema> {
    // (undocumented)
    [boxedIterator](): IterableIterator<TreeField>;
    is<TSchema extends TreeNodeSchema>(schema: TSchema): this is TypedNode<TSchema>;
    // (undocumented)
    on<K extends keyof EditableTreeEvents>(eventName: K, listener: EditableTreeEvents[K]): () => void;
    readonly parentField: {
        readonly parent: TreeField;
        readonly index: number;
    };
    tryGetField(key: FieldKey): undefined | TreeField;
    readonly type: TreeNodeSchemaIdentifier;
    readonly value?: TreeValue;
}

// @alpha
export class TreeNodeSchema<Name extends string = string, T extends Unenforced<TreeSchemaSpecification> = TreeSchemaSpecification> {
    constructor(builder: Named<string>, name: Name, info: T);
    // (undocumented)
    readonly builder: Named<string>;
    // (undocumented)
    readonly info: Assume<T, TreeSchemaSpecification>;
    // (undocumented)
    readonly leafValue: WithDefault<Assume<T, TreeSchemaSpecification>["leafValue"], undefined>;
    // (undocumented)
    readonly mapFields: WithDefault<Assume<T, TreeSchemaSpecification>["mapFields"], undefined>;
    // (undocumented)
    readonly name: Name & TreeNodeSchemaIdentifier;
    // (undocumented)
    readonly objectNodeFields: ObjectToMap<NormalizeObjectNodeFields<Assume<T, TreeSchemaSpecification>["objectNodeFields"]>, FieldKey, TreeFieldSchema>;
    // (undocumented)
    readonly objectNodeFieldsObject: NormalizeObjectNodeFields<Assume<T, TreeSchemaSpecification>["objectNodeFields"]>;
}

// @alpha
export type TreeNodeSchemaIdentifier = Brand<string, "tree.TreeNodeSchemaIdentifier">;

// @alpha (undocumented)
export interface TreeNodeStoredSchema {
    readonly leafValue?: ValueSchema;
    readonly mapFields?: TreeFieldStoredSchema;
    readonly objectNodeFields: ReadonlyMap<FieldKey, TreeFieldStoredSchema>;
}

// @alpha
export interface TreeSchema<out T extends TreeFieldSchema = TreeFieldSchema> extends SchemaCollection {
    readonly adapters: Adapters;
    readonly policy: FullSchemaPolicy;
    readonly rootFieldSchema: T;
}

// @alpha
type TreeSchemaSpecification = [
FlattenKeys<(ObjectSchemaSpecification | MapSchemaSpecification | LeafSchemaSpecification) & Partial<ObjectSchemaSpecification & MapSchemaSpecification & LeafSchemaSpecification>>
][_InlineTrick];

// @alpha
export enum TreeStatus {
    Deleted = 2,
    InDocument = 0,
    Removed = 1
}

// @alpha
export const treeStatus: unique symbol;

// @alpha
export interface TreeStoredSchema extends StoredSchemaCollection {
    readonly rootFieldSchema: TreeFieldStoredSchema;
}

// @alpha (undocumented)
export type TreeType = TreeNodeSchemaIdentifier;

// @alpha
export type TreeTypeSet = ReadonlySet<TreeNodeSchemaIdentifier> | undefined;

// @alpha
export type TreeValue<TSchema extends ValueSchema = ValueSchema> = [
    {
    [ValueSchema.Number]: number;
    [ValueSchema.String]: string;
    [ValueSchema.Boolean]: boolean;
    [ValueSchema.FluidHandle]: IFluidHandle;
    [ValueSchema.Null]: null;
}[TSchema]
][_InlineTrick];

// @alpha
type TypeArrayToTypedTreeArray<Mode extends ApiMode, T extends readonly TreeNodeSchema[]> = [
T extends readonly [infer Head, ...infer Tail] ? [
TypedNode_2<Assume<Head, TreeNodeSchema>, Mode>,
...TypeArrayToTypedTreeArray<Mode, Assume<Tail, readonly TreeNodeSchema[]>>
] : []
][_InlineTrick];

// @alpha
type TypeArrayToTypedTreeArray_2<T extends readonly TreeNodeSchema[]> = [
ArrayHasFixedLength<T> extends false ? T extends readonly (infer InnerT)[] ? [TypedNode<Assume<InnerT, TreeNodeSchema>>] : never : FixedSizeTypeArrayToTypedTree<T>
][_InlineTrick];

// @alpha
export const typeboxValidator: JsonValidator;

// @alpha
export type Typed<TSchema extends TreeFieldSchema | TreeNodeSchema> = TSchema extends TreeNodeSchema ? TypedNode<TSchema> : TypedField<Assume<TSchema, TreeFieldSchema>>;

// @alpha
export type TypedField<TSchema extends TreeFieldSchema> = TypedFieldInner<TSchema["kind"], TSchema["allowedTypes"]>;

// @alpha
type TypedField_2<TField extends TreeFieldSchema, Mode extends ApiMode = ApiMode.Editable> = [
ApplyMultiplicity<TField["kind"]["multiplicity"], AllowedTypesToTypedTrees<Mode, TField["allowedTypes"]>, Mode>
][_InlineTrick];

// @alpha
type TypedFieldInner<Kind extends FieldKind, Types extends AllowedTypes> = Kind extends typeof FieldKinds.sequence ? Sequence<Types> : Kind extends typeof FieldKinds.required ? RequiredField<Types> : Kind extends typeof FieldKinds.optional ? OptionalField<Types> : Kind extends typeof FieldKinds.nodeKey ? NodeKeyField : TreeField;

// @alpha
type TypedFields<Mode extends ApiMode, TFields extends undefined | {
    [key: string]: TreeFieldSchema;
}> = [
TFields extends {
    [key: string]: TreeFieldSchema;
} ? {
    -readonly [key in keyof TFields]: TypedField_2<TFields[key], Mode extends ApiMode.Editable ? ApiMode.EditableUnwrapped : Mode>;
} : EmptyObject
][_InlineTrick];

// @alpha
export type TypedNode<TSchema extends TreeNodeSchema> = TSchema extends LeafSchema ? Leaf<TSchema> : TSchema extends MapSchema ? MapNode<TSchema> : TSchema extends FieldNodeSchema ? FieldNode<TSchema> : TSchema extends ObjectNodeSchema ? ObjectNodeTyped<TSchema> : TreeNode;

// @alpha
type TypedNode_2<TSchema extends TreeNodeSchema, Mode extends ApiMode = ApiMode.Editable> = FlattenKeys<CollectOptions<Mode, TypedFields<Mode extends ApiMode.Editable ? ApiMode.EditableUnwrapped : Mode, TSchema["objectNodeFieldsObject"]>, TSchema["leafValue"], TSchema["name"]>>;

// @alpha
export type TypedNodeUnion<TTypes extends AllowedTypes> = TTypes extends InternalTypedSchemaTypes.FlexList<TreeNodeSchema> ? TypedNodeUnionHelper<TTypes> : TreeNode;

// @alpha
type TypedNodeUnionHelper<TTypes extends InternalTypedSchemaTypes.FlexList<TreeNodeSchema>> = InternalTypedSchemaTypes.ArrayToUnion<TypeArrayToTypedTreeArray_2<Assume<InternalTypedSchemaTypes.FlexListToNonLazyArray<TTypes>, readonly TreeNodeSchema[]>>>;

// @alpha
export interface TypedTreeChannel extends IChannel {
    schematize<TRoot extends TreeFieldSchema>(config: InitializeAndSchematizeConfiguration<TRoot>): TypedField<TRoot>;
}

// @alpha
export class TypedTreeFactory implements IChannelFactory {
    constructor(options: TypedTreeOptions);
    // (undocumented)
    readonly attributes: IChannelAttributes;
    // (undocumented)
    create(runtime: IFluidDataStoreRuntime, id: string): TypedTreeChannel;
    // (undocumented)
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, channelAttributes: Readonly<IChannelAttributes>): Promise<TypedTreeChannel>;
    // (undocumented)
    readonly type: string;
}

// @alpha
export interface TypedTreeOptions extends SharedTreeOptions {
    readonly subtype: string;
}

// @alpha
type TypedValueOrUndefined<TValue extends ValueSchema | undefined> = TValue extends ValueSchema ? TreeValue<TValue> : undefined;

// @alpha
export const typeNameSymbol: unique symbol;

// @alpha
export const typeSymbol: unique symbol;

// @alpha
type UnboxField<TSchema extends TreeFieldSchema, Emptiness extends "maybeEmpty" | "notEmpty" = "maybeEmpty"> = UnboxFieldInner<TSchema["kind"], TSchema["allowedTypes"], Emptiness>;

// @alpha
type UnboxFieldInner<Kind extends FieldKind, TTypes extends AllowedTypes, Emptiness extends "maybeEmpty" | "notEmpty"> = Kind extends typeof FieldKinds.sequence ? Sequence<TTypes> : Kind extends typeof FieldKinds.required ? UnboxNodeUnion<TTypes> : Kind extends typeof FieldKinds.optional ? UnboxNodeUnion<TTypes> | (Emptiness extends "notEmpty" ? never : undefined) : Kind extends typeof FieldKinds.nodeKey ? NodeKeyField : unknown;

// @alpha
type UnboxNode<TSchema extends TreeNodeSchema> = TSchema extends LeafSchema ? TreeValue<TSchema["leafValue"]> : TSchema extends MapSchema ? MapNode<TSchema> : TSchema extends FieldNodeSchema ? UnboxField<TSchema["objectNodeFieldsObject"][""]> : TSchema extends ObjectNodeSchema ? ObjectNodeTyped<TSchema> : UnknownUnboxed;

// @alpha
type UnboxNodeUnion<TTypes extends AllowedTypes> = TTypes extends readonly [
InternalTypedSchemaTypes.LazyItem<infer InnerType>
] ? InnerType extends TreeNodeSchema ? UnboxNode<InnerType> : InnerType extends Any ? TreeNode : unknown : boolean extends IsArrayOfOne<TTypes> ? UnknownUnboxed : TypedNodeUnion<TTypes>;

// @alpha
type Unbrand<T, B> = T extends infer S & B ? S : T;

// @alpha
type UnbrandedName<TName> = [
TName extends infer S & TreeNodeSchemaIdentifier ? S : string
][_InlineTrick];

// @alpha
type UnbrandList<T extends unknown[], B> = T extends [infer Head, ...infer Tail] ? [Unbrand<Head, B>, ...UnbrandList<Tail, B>] : [];

// @alpha
export type Unenforced<_DesiredExtendsConstraint> = unknown;

// @alpha
type UnknownUnboxed = TreeValue | TreeNode | TreeField;

// @alpha
type UntypedApi<Mode extends ApiMode> = {
    [ApiMode.Editable]: UntypedTree;
    [ApiMode.EditableUnwrapped]: UntypedTree | PrimitiveValue;
    [ApiMode.Flexible]: ContextuallyTypedNodeData;
    [ApiMode.Simple]: ContextuallyTypedNodeData;
    [ApiMode.Wrapped]: UntypedTree;
}[Mode];

// @alpha
export interface UntypedField<TContext = UntypedTreeContext, TChild = UntypedTree<TContext>, TParent = UntypedTree<TContext>, TUnwrappedChild = UnwrappedUntypedTree<TContext>> extends MarkedArrayLike<TUnwrappedChild> {
    readonly context: TContext;
    readonly fieldKey: FieldKey;
    readonly fieldSchema: TreeFieldStoredSchema;
    getNode(index: number): TChild;
    readonly parent?: TParent;
    treeStatus(): TreeStatus;
}

// @alpha
interface UntypedOptionalField<TContext = UntypedTreeContext, TChild = UntypedTree<TContext>, TUnwrappedChild = UnwrappedUntypedTree<TContext>> extends UntypedField<TContext, TChild, UntypedTree<TContext>, TUnwrappedChild> {
    readonly content: TChild;
    readonly fieldSchema: TreeFieldStoredSchema & {
        readonly kind: Optional;
    };
    remove(): void;
    setContent(newContent: ITreeCursor | ContextuallyTypedNodeData | undefined): void;
}

// @alpha
interface UntypedSequenceField<TContext = UntypedTreeContext, TChild = UntypedTree<TContext>, TUnwrappedChild = UnwrappedUntypedTree<TContext>, TNewFieldContent = NewFieldContent> extends UntypedField<TContext, TChild, UntypedTree<TContext>, TUnwrappedChild> {
    readonly fieldSchema: TreeFieldStoredSchema & {
        readonly kind: Sequence_2;
    };
    insertNodes(index: number, newContent: TNewFieldContent): void;
    moveNodes(sourceIndex: number, count: number, destIndex: number, destinationField?: UntypedField): void;
    remove(): void;
    removeNodes(index: number, count?: number): void;
    replaceNodes(index: number, newContent: TNewFieldContent, count?: number): void;
    setContent(newContent: TNewFieldContent): void;
}

// @alpha
export interface UntypedTree<TContext = UntypedTreeContext> extends UntypedTreeCore<TContext> {
    readonly [typeNameSymbol]: TreeNodeSchemaIdentifier;
    readonly [valueSymbol]: Value;
    readonly [key: FieldKey]: UnwrappedUntypedField<TContext>;
}

// @alpha
export interface UntypedTreeContext extends ISubscribable<ForestEvents> {
    clear(): void;
    free(): void;
    prepareForEdit(): void;
    readonly root: UntypedField;
    readonly schema: TreeStoredSchema;
    readonly unwrappedRoot: UnwrappedUntypedField;
}

// @alpha
export interface UntypedTreeCore<TContext = UntypedTreeContext, TField = UntypedField<TContext>> extends Iterable<TField> {
    readonly [contextSymbol]: TContext;
    [getField](fieldKey: FieldKey): TField;
    // (undocumented)
    [on]<K extends keyof EditableTreeEvents>(eventName: K, listener: EditableTreeEvents[K]): () => void;
    readonly [parentField]: {
        readonly parent: TField;
        readonly index: number;
    };
    [treeStatus](): TreeStatus;
    readonly [typeSymbol]: TreeNodeStoredSchema & Named<TreeNodeSchemaIdentifier>;
}

// @alpha
export type UntypedTreeOrPrimitive<TContext = UntypedTreeContext> = UntypedTree<TContext> | PrimitiveValue;

// @alpha
interface UntypedValueField<TContext = UntypedTreeContext, TChild = UntypedTree<TContext>, TUnwrappedChild = UnwrappedUntypedTree<TContext>, TNewContent = ContextuallyTypedNodeData> extends UntypedField<TContext, TChild, UntypedTree<TContext>, TUnwrappedChild> {
    readonly content: TChild;
    readonly fieldSchema: TreeFieldStoredSchema & {
        readonly kind: Required_2;
    };
    setContent(newContent: ITreeCursor | TNewContent): void;
}

// @alpha
export type UnwrappedEditableField = UnwrappedEditableTree | undefined | EditableField;

// @alpha
export type UnwrappedEditableTree = EditableTreeOrPrimitive | EditableField;

// @alpha
export type UnwrappedUntypedField<TContext = UntypedTreeContext> = UnwrappedUntypedTree<TContext> | undefined | UntypedField<TContext>;

// @alpha
export type UnwrappedUntypedTree<TContext = UntypedTreeContext> = UntypedTreeOrPrimitive<TContext> | UntypedField<TContext>;

// @alpha
export interface UpPath<TParent = UpPathDefault> {
    readonly parent: TParent | undefined;
    readonly parentField: FieldKey;
    readonly parentIndex: NodeIndex;
}

// @alpha
export type UpPathDefault = UpPath;

// @alpha
export type Value = undefined | TreeValue;

// @alpha (undocumented)
export interface ValueFieldEditBuilder {
    set(newContent: ITreeCursor): void;
}

// @alpha
export type ValueFromBranded<T extends BrandedType<any, string>> = T extends BrandedType<infer ValueType, string> ? ValueType : never;

// @alpha (undocumented)
type ValuePropertyFromSchema<TSchema extends ValueSchema | undefined> = TSchema extends ValueSchema ? {
    [valueSymbol]: TreeValue<TSchema>;
} : EmptyObject;

// @alpha
export enum ValueSchema {
    // (undocumented)
    Boolean = 2,
    // (undocumented)
    FluidHandle = 3,
    // (undocumented)
    Null = 4,
    // (undocumented)
    Number = 0,
    // (undocumented)
    String = 1
}

// @alpha (undocumented)
type ValuesOf<T> = T[keyof T];

// @alpha
export const valueSymbol: unique symbol;

// @alpha
export interface ViewEvents {
    afterBatch(): void;
    revertible(revertible: Revertible): void;
}

// @alpha
export type VisitorBindingContext = DeleteBindingContext | InsertBindingContext;

// @alpha
type WithDefault<T, Default> = T extends undefined ? Default : unknown extends T ? Default : T;

// (No @packageDocumentation comment for this package)

```
