/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { UsageError } from "@fluidframework/telemetry-utils";
import { fail } from "../util";
import { EmptyObject } from "../feature-libraries";
import { SchemaFactory } from "./schemaFactory";
// This type is referred to by the base type generated by schema.
// Adding the import of it here prevents TypeScript from generating inline includes for it in the d.ts file.
// If we let TypeScript generate these includes, they use relative paths which break API extractor's rollup.
// eslint-disable-next-line unused-imports/no-unused-imports
import { NodeFromSchema, type NodeKind as _dummy } from "./schemaTypes";

/**
 * Create a schema for a node with no state.
 * @remarks
 * This is commonly used in unions when the only information needed is which kind of node the value is.
 * Enums are a common example of this pattern.
 * @alpha
 */
export function singletonSchema<TScope extends string, TName extends string | number>(
	factory: SchemaFactory<TScope, TName>,
	name: TName,
) {
	return class SingletonSchema extends factory.object(name, {}) {
		public constructor(data?: EmptyObject) {
			super(data ?? {});
		}
		public get value(): TName {
			return name;
		}
	};
}

/**
 * Converts an enum into a collection of schema which can be used in a union.
 * @remarks
 * Currently only supports `string` enums.
 * @example
 * ```typescript
 * enum Mode {
 * 	a = "A",
 * 	b = "B",
 * }
 * const ModeNodes = adaptEnum(schema, Mode);
 * type ModeNodes = NodeFromSchema<(typeof ModeNodes)[keyof typeof ModeNodes]>;
 * const nodeFromString: ModeNodes = ModeNodes(Mode.a);
 * const nodeFromSchema: ModeNodes = new ModeNodes.a();
 * const nameFromNode: Mode = nodeFromSchema.value;
 * class Parent extends schemaFactory.object("Parent", {
 * 	mode: typedObjectValues(ModeNodes),
 * }) {}
 * ```
 * @privateRemarks
 * TODO:
 * Extends this to support numeric enums.
 * Maybe require an explicit nested scope to group them under, or at least a warning about collisions.
 * Maybe just provide `SchemaFactory.nested` to east creating nested scopes?
 * @alpha
 */
export function adaptEnum<TScope extends string, const TEnum extends Record<string, string>>(
	factory: SchemaFactory<TScope>,
	members: TEnum,
) {
	type Values = TEnum[keyof TEnum];
	const values = Object.values(members) as Values[];
	const inverse = new Map(Object.entries(members).map(([key, value]) => [value, key])) as Map<
		Values,
		keyof TEnum
	>;

	if (inverse.size !== values.length) {
		throw new UsageError("All members of enums must have distinct values.");
	}

	type TOut = {
		readonly [Property in keyof TEnum]: ReturnType<
			typeof singletonSchema<TScope, TEnum[Property]>
		>;
	};
	const factoryOut = <TValue extends Values>(value: TValue) => {
		return new out[inverse.get(value) ?? fail("missing enum value")]({}) as NodeFromSchema<
			ReturnType<typeof singletonSchema<TScope, TValue>>
		>;
	};
	const out = factoryOut as typeof factoryOut & TOut;
	for (const [key, value] of Object.entries(members)) {
		Object.defineProperty(out, key, {
			enumerable: true,
			configurable: false,
			writable: false,
			value: singletonSchema(factory, value),
		});
	}

	return out;
}

/**
 * `Object.values`, but with more specific types.
 * @alpha
 */
export function typedObjectValues<TKey extends string, TValues>(
	object: Record<TKey, TValues>,
): TValues[] {
	return Object.values(object);
}

/**
 * Converts an array of distinct strings into a collection of schema which can be used like an enum style union.
 * @remarks
 * The returned collection is also a function which can be used to convert strings into {@link Unhydrated} nodes in the union.
 * Each node type has a `.value` getter which returns the associated string.
 *
 * The produced nodes use the provided strings as their `name`, and don't store any data beyond that.
 * @example
 * ```typescript
 * const Mode = enumFromStrings(schemaFactory, ["Fun", "Cool"]);
 * type Mode = NodeFromSchema<(typeof Mode)[keyof typeof Mode]>;
 * const nodeFromString: Mode = Mode("Fun");
 * const nodeFromSchema: Mode = new Mode.Fun();
 * const nameFromNode = nodeFromSchema.value;
 *
 * class Parent extends schemaFactory.object("Parent", { mode: typedObjectValues(Mode) }) {}
 * ```
 * @alpha
 */
export function enumFromStrings<TScope extends string, const Members extends string>(
	factory: SchemaFactory<TScope>,
	members: Members[],
) {
	const names = new Set(members);
	if (names.size !== members.length) {
		throw new UsageError("All members of enums must have distinct names");
	}

	type TOut = Record<Members, ReturnType<typeof singletonSchema<TScope, Members>>>;
	const factoryOut = <TValue extends Members>(value: TValue) => {
		return new out[value]({}) as NodeFromSchema<
			ReturnType<typeof singletonSchema<TScope, TValue>>
		>;
	};
	const out = factoryOut as typeof factoryOut & TOut;
	for (const name of members) {
		Object.defineProperty(out, name, {
			enumerable: true,
			configurable: false,
			writable: false,
			value: singletonSchema(factory, name),
		});
	}

	return out;
}

// TODO: Why does this one generate an invalid d.ts file if exported?
// Tracked by https://github.com/microsoft/TypeScript/issues/56718
// TODO: replace enumFromStrings above with this simpler implementation when the TypeScript bug is resolved.
function _enumFromStrings2<TScope extends string, const Members extends readonly string[]>(
	factory: SchemaFactory<TScope>,
	members: Members,
) {
	const enumObject: {
		[key in keyof Members as Members[key] extends string ? Members[key] : string]: Members[key];
	} = Object.create(null);
	for (const name of members) {
		Object.defineProperty(enumObject, name, {
			enumerable: true,
			configurable: false,
			writable: false,
			value: name,
		});
	}

	return adaptEnum(factory, enumObject);
}
