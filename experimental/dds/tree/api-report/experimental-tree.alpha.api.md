## Alpha API Report File for "@fluid-experimental/tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @alpha
export type AttributionId = UuidString;

// @alpha
export type BadPlaceValidationResult = Exclude<PlaceValidationResult, PlaceValidationResult.Valid>;

// @alpha
export type BadRangeValidationResult = Exclude<RangeValidationResult, RangeValidationResultKind.Valid>;

// @alpha
export interface Build {
    // (undocumented)
    readonly destination: number;
    // (undocumented)
    readonly source: BuildNode | TreeNodeSequence<BuildNode>;
    // (undocumented)
    readonly type: typeof ChangeType.Build;
}

// @alpha
export interface BuildInternal extends Omit<BuildInternal_0_0_2, 'source'> {
    // (undocumented)
    readonly source: TreeNodeSequence<BuildNodeInternal>;
}

// @alpha
export interface BuildInternal_0_0_2 {
    // (undocumented)
    readonly destination: DetachedSequenceId;
    // (undocumented)
    readonly source: TreeNodeSequence<BuildNodeInternal_0_0_2>;
    // (undocumented)
    readonly type: typeof ChangeTypeInternal.Build;
}

// @alpha
export type BuildNode = BuildTreeNode | number;

// @alpha
export type BuildNodeInternal = TreeNode<BuildNodeInternal, NodeId> | DetachedSequenceId;

// @alpha
export type BuildNodeInternal_0_0_2 = TreeNode<BuildNodeInternal_0_0_2, StableNodeId> | DetachedSequenceId;

// @alpha
export interface BuildTreeNode extends HasVariadicTraits<BuildNode> {
    // (undocumented)
    definition: string;
    // (undocumented)
    identifier?: NodeId;
    // (undocumented)
    payload?: Payload;
}

// @alpha
export type Change = Insert | Detach | Build | SetValue | Constraint;

// @alpha (undocumented)
export const Change: {
    build: (source: BuildNode | TreeNodeSequence<BuildNode>, destination: number) => Build;
    insert: (source: number, destination: StablePlace) => Insert;
    detach: (source: StableRange, destination?: number) => Detach;
    setPayload: (nodeToModify: NodeId, payload: Payload) => SetValue;
    clearPayload: (nodeToModify: NodeId) => SetValue;
    constraint: (toConstrain: StableRange, effect: ConstraintEffect, identityHash?: UuidString, length?: number, contentHash?: UuidString, parentNode?: NodeId, label?: TraitLabel) => Constraint;
    delete: (stableRange: StableRange) => Change;
    insertTree: (nodes: BuildNode | TreeNodeSequence<BuildNode>, destination: StablePlace) => Change[];
    move: (source: StableRange, destination: StablePlace) => Change[];
};

// @alpha
export type ChangeInternal = InsertInternal | DetachInternal | BuildInternal | SetValueInternal | ConstraintInternal;

// @alpha (undocumented)
export const ChangeInternal: {
    build: (source: TreeNodeSequence<BuildNodeInternal>, destination: DetachedSequenceId) => BuildInternal;
    insert: (source: DetachedSequenceId, destination: StablePlaceInternal) => InsertInternal;
    detach: (source: StableRangeInternal, destination?: DetachedSequenceId) => DetachInternal;
    setPayload: (nodeToModify: NodeData<NodeId> | NodeId, payload: Payload) => SetValueInternal;
    clearPayload: (nodeToModify: NodeData<NodeId> | NodeId) => SetValueInternal;
    constraint: (toConstrain: StableRangeInternal, effect: ConstraintEffect, identityHash?: UuidString, length?: number, contentHash?: UuidString, parentNode?: NodeId, label?: TraitLabel) => ConstraintInternal;
    delete: (stableRange: StableRangeInternal) => ChangeInternal;
    insertTree: (nodes: TreeNodeSequence<BuildNodeInternal>, destination: StablePlaceInternal) => ChangeInternal[];
    move: (source: StableRangeInternal, destination: StablePlaceInternal) => ChangeInternal[];
};

// @alpha
export type ChangeNode_0_0_2 = TreeNode<ChangeNode_0_0_2, StableNodeId>;

// @alpha
export enum ChangeType {
    // (undocumented)
    Build = 2,
    // (undocumented)
    Constraint = 4,
    // (undocumented)
    Detach = 1,
    // (undocumented)
    Insert = 0,
    // (undocumented)
    SetValue = 3
}

// @alpha
export enum ChangeTypeInternal {
    // (undocumented)
    Build = 2,
    // (undocumented)
    CompressedBuild = 5,
    // (undocumented)
    Constraint = 4,
    // (undocumented)
    Detach = 1,
    // (undocumented)
    Insert = 0,
    // (undocumented)
    SetValue = 3
}

// @alpha
export abstract class Checkout extends EventEmitterWithErrorHandling<ICheckoutEvents> implements IDisposable {
    protected constructor(tree: SharedTree, currentView: RevisionView, onEditCommitted: EditCommittedHandler);
    abortEdit(): void;
    applyChanges(changes: readonly Change[]): void;
    // (undocumented)
    applyChanges(...changes: readonly Change[]): void;
    applyEdit(changes: readonly Change[]): EditId;
    // (undocumented)
    applyEdit(...changes: readonly Change[]): EditId;
    closeEdit(): EditId;
    // (undocumented)
    get currentView(): TreeView;
    dispose(error?: Error): void;
    // (undocumented)
    disposed: boolean;
    protected emitChange(): void;
    // (undocumented)
    getEditStatus(): EditStatus;
    protected handleNewEdit(id: EditId, result: ValidEditingResult): void;
    // (undocumented)
    hasOpenEdit(): boolean;
    protected hintKnownEditingResult(edit: Edit<ChangeInternal>, result: ValidEditingResult): void;
    protected abstract get latestCommittedView(): RevisionView;
    openEdit(): void;
    rebaseCurrentEdit(): EditValidationResult.Valid | EditValidationResult.Invalid;
    revert(editId: EditId): void;
    readonly tree: SharedTree;
    protected tryApplyChangesInternal(changes: readonly ChangeInternal[]): EditStatus;
    // (undocumented)
    protected tryApplyChangesInternal(...changes: readonly ChangeInternal[]): EditStatus;
    tryApplyEdit(changes: readonly Change[]): EditId | undefined;
    // (undocumented)
    tryApplyEdit(...changes: readonly Change[]): EditId | undefined;
    // (undocumented)
    abstract waitForEditsToSubmit(): Promise<void>;
    // (undocumented)
    abstract waitForPendingUpdates(): Promise<void>;
}

// @alpha
export enum CheckoutEvent {
    ViewChange = "viewChange"
}

// @alpha (undocumented)
export function comparePayloads(a: Payload, b: Payload): boolean;

// @alpha
export type CompressedId = FinalCompressedId | LocalCompressedId;

// @alpha
export interface Constraint {
    readonly contentHash?: UuidString;
    readonly effect: ConstraintEffect;
    readonly identityHash?: UuidString;
    readonly label?: TraitLabel;
    readonly length?: number;
    readonly parentNode?: NodeId;
    readonly toConstrain: StableRange;
    readonly type: typeof ChangeType.Constraint;
}

// @alpha
export enum ConstraintEffect {
    InvalidAndDiscard = 0,
    InvalidRetry = 1,
    ValidRetry = 2
}

// @alpha
export interface ConstraintInternal extends Omit<ConstraintInternal_0_0_2, 'toConstrain' | 'parentNode'> {
    readonly parentNode?: NodeId;
    readonly toConstrain: StableRangeInternal;
}

// @alpha
export interface ConstraintInternal_0_0_2 {
    readonly contentHash?: UuidString;
    readonly effect: ConstraintEffect;
    readonly identityHash?: UuidString;
    readonly label?: TraitLabel;
    readonly length?: number;
    readonly parentNode?: StableNodeId;
    readonly toConstrain: StableRangeInternal_0_0_2;
    readonly type: typeof ChangeTypeInternal.Constraint;
}

// @alpha
export type Definition = UuidString & {
    readonly Definition: 'c0ef9488-2a78-482d-aeed-37fba996354c';
};

// @alpha
export interface Delta<NodeId> {
    readonly added: readonly NodeId[];
    readonly changed: readonly NodeId[];
    readonly removed: readonly NodeId[];
}

// @alpha
export interface Detach {
    // (undocumented)
    readonly destination?: number;
    // (undocumented)
    readonly source: StableRange;
    // (undocumented)
    readonly type: typeof ChangeType.Detach;
}

// @alpha
export type DetachedSequenceId = number & {
    readonly DetachedSequenceId: 'f7d7903a-194e-45e7-8e82-c9ef4333577d';
};

// @alpha
export interface DetachInternal extends Omit<DetachInternal_0_0_2, 'source'> {
    // (undocumented)
    readonly source: StableRangeInternal;
}

// @alpha
export interface DetachInternal_0_0_2 {
    // (undocumented)
    readonly destination?: DetachedSequenceId;
    // (undocumented)
    readonly source: StableRangeInternal_0_0_2;
    // (undocumented)
    readonly type: typeof ChangeTypeInternal.Detach;
}

// @alpha @sealed
export class EagerCheckout extends Checkout {
    constructor(tree: SharedTree);
    // (undocumented)
    protected get latestCommittedView(): RevisionView;
    // (undocumented)
    waitForEditsToSubmit(): Promise<void>;
    // (undocumented)
    waitForPendingUpdates(): Promise<void>;
}

// @alpha
export interface Edit<TChange> extends EditBase<TChange> {
    readonly id: EditId;
}

// @alpha
export type EditApplicationOutcome = {
    readonly view: RevisionView;
    readonly status: EditStatus.Applied;
} | {
    readonly failure: TransactionInternal.Failure;
    readonly status: EditStatus.Invalid | EditStatus.Malformed;
};

// @alpha
export interface EditBase<TChange> {
    readonly changes: readonly TChange[];
    readonly pastAttemptCount?: number;
}

// @alpha
export interface EditCommittedEventArguments {
    readonly editId: EditId;
    readonly local: boolean;
    readonly tree: SharedTree;
}

// @alpha
export type EditCommittedHandler = (args: EditCommittedEventArguments) => void;

// @alpha
export type EditId = UuidString & {
    readonly EditId: '56897beb-53e4-4e66-85da-4bf5cd5d0d49';
};

// @alpha
export interface EditingResultBase {
    readonly before: RevisionView;
    readonly changes: readonly ChangeInternal[];
    readonly status: EditStatus;
    readonly steps: readonly ReconciliationChange[];
}

// @alpha
export enum EditStatus {
    Applied = 2,
    Invalid = 1,
    Malformed = 0
}

// @alpha
export enum EditValidationResult {
    Invalid = 1,
    Malformed = 0,
    Valid = 2
}

// @alpha
export type FinalCompressedId = number & {
    readonly FinalCompressedId: '5d83d1e2-98b7-4e4e-a889-54c855cfa73d';
    readonly OpNormalized: '9209432d-a959-4df7-b2ad-767ead4dbcae';
};

// @alpha
export class Forest {
    add(nodes: Iterable<ForestNode>): Forest;
    assertConsistent(): void;
    attachRangeOfChildren(parentId: NodeId, label: TraitLabel, index: number, childIds: readonly NodeId[]): Forest;
    static create(expensiveValidation?: boolean): Forest;
    delete(ids: Iterable<NodeId>, deleteChildren: boolean): Forest;
    delta(forest: Forest): Delta<NodeId>;
    detachRangeOfChildren(parentId: NodeId, label: TraitLabel, startIndex: number, endIndex: number): {
        forest: Forest;
        detached: readonly NodeId[];
    };
    equals(forest: Forest): boolean;
    // (undocumented)
    get(id: NodeId): ForestNode;
    // (undocumented)
    getParent(id: NodeId): ParentData;
    // (undocumented)
    has(id: NodeId): boolean;
    setValue(nodeId: NodeId, value: Payload | null): Forest;
    get size(): number;
    // (undocumented)
    tryGet(id: NodeId): ForestNode | undefined;
    // (undocumented)
    tryGetParent(id: NodeId): ParentData | undefined;
}

// @alpha
export interface ForestNode extends NodeData<NodeId> {
    // (undocumented)
    readonly traits: ReadonlyMap<TraitLabel, readonly NodeId[]>;
}

export { getSerializedUploadedEditChunkContents }
export { getSerializedUploadedEditChunkContents as getUploadedEditChunkContents }

// @alpha
export interface HasTraits<TChild> {
    // (undocumented)
    readonly traits: TraitMap<TChild>;
}

// @alpha
export interface HasVariadicTraits<TChild> {
    // (undocumented)
    readonly traits?: {
        readonly [key: string]: TChild | TreeNodeSequence<TChild> | undefined;
    };
}

// @alpha
export interface ICheckoutEvents extends IErrorEvent {
    // (undocumented)
    (event: 'viewChange', listener: (before: TreeView, after: TreeView) => void): any;
}

// @alpha
export const initialTree: ChangeNode_0_0_2;

// @alpha
export interface Insert {
    // (undocumented)
    readonly destination: StablePlace;
    // (undocumented)
    readonly source: number;
    // (undocumented)
    readonly type: typeof ChangeType.Insert;
}

// @alpha
export interface InsertInternal extends Omit<InsertInternal_0_0_2, 'destination'> {
    // (undocumented)
    readonly destination: StablePlaceInternal;
}

// @alpha
export interface InsertInternal_0_0_2 {
    // (undocumented)
    readonly destination: StablePlaceInternal_0_0_2;
    // (undocumented)
    readonly source: DetachedSequenceId;
    // (undocumented)
    readonly type: typeof ChangeTypeInternal.Insert;
}

// @alpha
export interface InternalizedChange {
    // (undocumented)
    InternalChangeBrand: '2cae1045-61cf-4ef7-a6a3-8ad920cb7ab3';
}

// @alpha
export interface ISharedTreeEvents extends ISharedObjectEvents {
    // (undocumented)
    (event: 'committedEdit', listener: EditCommittedHandler): any;
    // (undocumented)
    (event: 'appliedSequencedEdit', listener: SequencedEditAppliedHandler): any;
}

// @alpha
export type LocalCompressedId = number & {
    readonly LocalCompressedId: '6fccb42f-e2a4-4243-bd29-f13d12b9c6d1';
} & SessionUnique;

// @alpha
export interface LogViewer {
    // @deprecated
    getRevisionView(revision: Revision): Promise<RevisionView>;
    getRevisionViewInMemory(revision: Revision): RevisionView;
    // @deprecated
    getRevisionViewInSession(revision: Revision): RevisionView;
}

// @alpha
export interface NodeData<TId> {
    readonly definition: Definition;
    readonly identifier: TId;
    readonly payload?: Payload;
}

// @alpha
export type NodeId = number & SessionSpaceCompressedId & NodeIdBrand;

// @alpha (undocumented)
export interface NodeIdBrand {
    // (undocumented)
    readonly NodeId: 'e53e7d6b-c8b9-431a-8805-4843fc639342';
}

// @alpha
export interface NodeIdContext extends NodeIdGenerator, NodeIdConverter {
}

// @alpha
export interface NodeIdConverter {
    convertToNodeId(id: StableNodeId): NodeId;
    convertToStableNodeId(id: NodeId): StableNodeId;
    tryConvertToNodeId(id: StableNodeId): NodeId | undefined;
    tryConvertToStableNodeId(id: NodeId): StableNodeId | undefined;
}

// @alpha
export interface NodeIdGenerator {
    generateNodeId(override?: string): NodeId;
}

// @alpha @sealed
export interface OrderedEditSet<TChange = unknown> {
    readonly editIds: readonly EditId[];
    // @deprecated (undocumented)
    getEditAtIndex(index: number): Promise<Edit<TChange>>;
    // @deprecated (undocumented)
    getEditInSessionAtIndex(index: number): Edit<TChange>;
    // (undocumented)
    getIdAtIndex(index: number): EditId;
    // (undocumented)
    getIndexOfId(editId: EditId): number;
    readonly length: number;
    // @deprecated (undocumented)
    tryGetEdit(editId: EditId): Promise<Edit<TChange> | undefined>;
    // (undocumented)
    tryGetEditAtIndex(index: number): Edit<TChange> | undefined;
    // (undocumented)
    tryGetEditFromId(editId: EditId): Edit<TChange> | undefined;
    // (undocumented)
    tryGetIndexOfId(editId: EditId): number | undefined;
}

// @alpha
export interface ParentData {
    // (undocumented)
    readonly parentId: NodeId;
    // (undocumented)
    readonly traitParent: TraitLabel;
}

// @alpha
export type Payload = any;

// @alpha
export type PlaceIndex = number & {
    readonly PlaceIndex: unique symbol;
};

// @alpha
export enum PlaceValidationResult {
    // (undocumented)
    Malformed = "Malformed",
    // (undocumented)
    MissingParent = "MissingParent",
    // (undocumented)
    MissingSibling = "MissingSibling",
    // (undocumented)
    SiblingIsRootOrDetached = "SiblingIsRootOrDetached",
    // (undocumented)
    Valid = "Valid"
}

// @alpha
export type RangeValidationResult = RangeValidationResultKind.Valid | RangeValidationResultKind.PlacesInDifferentTraits | RangeValidationResultKind.Inverted | {
    kind: RangeValidationResultKind.BadPlace;
    place: StablePlaceInternal;
    placeFailure: BadPlaceValidationResult;
};

// @alpha
export enum RangeValidationResultKind {
    // (undocumented)
    BadPlace = "BadPlace",
    // (undocumented)
    Inverted = "Inverted",
    // (undocumented)
    PlacesInDifferentTraits = "PlacesInDifferentTraits",
    // (undocumented)
    Valid = "Valid"
}

// @alpha
export interface ReconciliationChange {
    readonly after: TransactionView;
    readonly resolvedChange: ChangeInternal;
}

// @alpha
export interface ReconciliationEdit {
    readonly [index: number]: ReconciliationChange;
    readonly after: TreeView;
    readonly before: TreeView;
    readonly length: number;
}

// @alpha
export interface ReconciliationPath {
    readonly [index: number]: ReconciliationEdit;
    readonly length: number;
}

// @alpha
export type Revision = number;

// @alpha
export class RevisionView extends TreeView {
    // (undocumented)
    equals(view: TreeView): boolean;
    static fromTree<T extends TreeNode<T, NodeId>>(root: T, expensiveValidation?: boolean): RevisionView;
    static fromTree<T extends TreeNode<T, StableNodeId>>(root: T, idConverter: NodeIdConverter, expensiveValidation?: boolean): RevisionView;
    openForTransaction(): TransactionView;
}

// @alpha
export interface SequencedEditAppliedEventArguments {
    readonly edit: Edit<ChangeInternal>;
    readonly logger: ITelemetryLoggerExt;
    readonly outcome: EditApplicationOutcome;
    readonly reconciliationPath: ReconciliationPath;
    readonly tree: SharedTree;
    readonly wasLocal: boolean;
}

// @alpha
export type SequencedEditAppliedHandler = (args: SequencedEditAppliedEventArguments) => void;

// @alpha
export type SessionSpaceCompressedId = CompressedId & SessionUnique;

// @alpha
export interface SessionUnique {
    // (undocumented)
    readonly SessionUnique: 'cea55054-6b82-4cbf-ad19-1fa645ea3b3e';
}

// @alpha
export interface SetValue {
    // (undocumented)
    readonly nodeToModify: NodeId;
    readonly payload: Payload | null;
    // (undocumented)
    readonly type: typeof ChangeType.SetValue;
}

// @alpha
export interface SetValueInternal extends Omit<SetValueInternal_0_0_2, 'nodeToModify'> {
    // (undocumented)
    readonly nodeToModify: NodeId;
}

// @alpha
export interface SetValueInternal_0_0_2 {
    // (undocumented)
    readonly nodeToModify: StableNodeId;
    readonly payload: Payload | null;
    // (undocumented)
    readonly type: typeof ChangeTypeInternal.SetValue;
}

// @alpha
export class SharedTree extends SharedObject<ISharedTreeEvents> implements NodeIdContext {
    constructor(runtime: IFluidDataStoreRuntime, id: string, ...args: SharedTreeArgs<WriteFormat.v0_0_2>);
    constructor(runtime: IFluidDataStoreRuntime, id: string, ...args: SharedTreeArgs<WriteFormat.v0_1_1>);
    applyEdit(...changes: readonly Change[]): Edit<InternalizedChange>;
    // (undocumented)
    applyEdit(changes: readonly Change[]): Edit<InternalizedChange>;
    applyEditInternal(editOrChanges: Edit<ChangeInternal> | readonly ChangeInternal[]): Edit<ChangeInternal>;
    protected applyStashedOp(op: unknown): void;
    attributeNodeId(id: NodeId): AttributionId;
    get attributionId(): AttributionId;
    convertToNodeId(id: StableNodeId): NodeId;
    convertToStableNodeId(id: NodeId): StableNodeId;
    static create(runtime: IFluidDataStoreRuntime, id?: string): SharedTree;
    // (undocumented)
    get currentView(): RevisionView;
    // (undocumented)
    get edits(): OrderedEditSet<InternalizedChange>;
    equals(sharedTree: SharedTree): boolean;
    generateNodeId(override?: string): NodeId;
    getAttachSummary(fullTree?: boolean | undefined, trackState?: boolean | undefined, telemetryContext?: ITelemetryContext | undefined): ISummaryTreeWithStats;
    static getFactory(...args: SharedTreeArgs<WriteFormat.v0_0_2>): SharedTreeFactory;
    // (undocumented)
    static getFactory(...args: SharedTreeArgs<WriteFormat.v0_1_1>): SharedTreeFactory;
    static getFactory(): SharedTreeFactory;
    // (undocumented)
    getRuntime(): IFluidDataStoreRuntime;
    getWriteFormat(): WriteFormat;
    internalizeChange(change: Change): ChangeInternal;
    protected loadCore(storage: IChannelStorageService): Promise<void>;
    loadSerializedSummary(blobData: string): ITelemetryBaseProperties;
    loadSummary(summary: SharedTreeSummaryBase): void;
    readonly logger: ITelemetryLoggerExt;
    get logViewer(): LogViewer;
    mergeEditsFrom(other: SharedTree, edits: Iterable<Edit<InternalizedChange>>, stableIdRemapper?: (id: StableNodeId) => StableNodeId): EditId[];
    protected onDisconnect(): void;
    protected processCore(message: unknown, local: boolean): void;
    protected registerCore(): void;
    // (undocumented)
    protected reSubmitCore(op: unknown, localOpMetadata?: StashedLocalOpMetadata): void;
    revert(editId: EditId): EditId | undefined;
    revertChanges(changes: readonly InternalizedChange[], before: RevisionView): ChangeInternal[] | undefined;
    saveSerializedSummary(options?: {
        serializer?: IFluidSerializer;
    }): string;
    saveSummary(): SharedTreeSummaryBase;
    summarizeCore(serializer: IFluidSerializer): ISummaryTreeWithStats;
    tryConvertToNodeId(id: StableNodeId): NodeId | undefined;
    tryConvertToStableNodeId(id: NodeId): StableNodeId | undefined;
}

// @alpha
export type SharedTreeArgs<WF extends WriteFormat = WriteFormat> = [writeFormat: WF, options?: SharedTreeOptions<WF>];

// @alpha
export interface SharedTreeBaseOptions {
    editEvictionFrequency?: number;
    inMemoryHistorySize?: number;
}

// @alpha
export enum SharedTreeEvent {
    EditCommitted = "committedEdit",
    SequencedEditApplied = "sequencedEditApplied"
}

// @alpha
export class SharedTreeFactory implements IChannelFactory {
    constructor(...args: SharedTreeArgs);
    static Attributes: IChannelAttributes;
    get attributes(): IChannelAttributes;
    create(runtime: IFluidDataStoreRuntime, id: string): SharedTree;
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, _channelAttributes: Readonly<IChannelAttributes>): Promise<SharedTree>;
    static Type: string;
    get type(): string;
}

// @alpha
export type SharedTreeOptions<WF extends WriteFormat, HistoryCompatibility extends 'Forwards' | 'None' = 'Forwards'> = SharedTreeBaseOptions & Omit<WF extends WriteFormat.v0_0_2 ? SharedTreeOptions_0_0_2 : WF extends WriteFormat.v0_1_1 ? SharedTreeOptions_0_1_1 : never, HistoryCompatibility extends 'Forwards' ? 'summarizeHistory' : never>;

// @alpha
export interface SharedTreeOptions_0_0_2 {
    summarizeHistory?: boolean;
}

// @alpha
export interface SharedTreeOptions_0_1_1 {
    attributionId?: AttributionId;
    summarizeHistory?: false | {
        uploadEditChunks: boolean;
    };
}

// @alpha
export interface SharedTreeSummaryBase {
    readonly version: WriteFormat;
}

// @alpha
export enum Side {
    // (undocumented)
    After = 1,
    // (undocumented)
    Before = 0
}

// @alpha
export type StableNodeId = string & {
    readonly StableNodeId: 'a0843b38-699d-4bb2-aa7a-16c502a71151';
};

// @alpha
export interface StablePlace {
    readonly referenceSibling?: NodeId;
    readonly referenceTrait?: TraitLocation;
    readonly side: Side;
}

// @alpha (undocumented)
export const StablePlace: {
    before: (node: NodeData<NodeId> | NodeId) => StablePlace;
    after: (node: NodeData<NodeId> | NodeId) => StablePlace;
    atStartOf: (trait: TraitLocation) => StablePlace;
    atEndOf: (trait: TraitLocation) => StablePlace;
};

// @alpha
export interface StablePlaceInternal extends Omit<StablePlaceInternal_0_0_2, 'referenceSibling' | 'referenceTrait'> {
    readonly referenceSibling?: NodeId;
    readonly referenceTrait?: TraitLocationInternal;
}

// @alpha (undocumented)
export const StablePlaceInternal: {
    before: (node: NodeData<NodeId> | NodeId) => StablePlaceInternal;
    after: (node: NodeData<NodeId> | NodeId) => StablePlaceInternal;
    atStartOf: (trait: TraitLocationInternal) => StablePlaceInternal;
    atEndOf: (trait: TraitLocationInternal) => StablePlaceInternal;
};

// @alpha
export interface StablePlaceInternal_0_0_2 {
    readonly referenceSibling?: StableNodeId;
    readonly referenceTrait?: TraitLocationInternal_0_0_2;
    readonly side: Side;
}

// @alpha
export interface StableRange {
    // (undocumented)
    readonly end: StablePlace;
    // (undocumented)
    readonly start: StablePlace;
}

// @alpha (undocumented)
export const StableRange: {
    from: (start: StablePlace) => {
        to: (end: StablePlace) => StableRange;
    };
    only: (node: NodeData<NodeId> | NodeId) => StableRange;
    all: (trait: TraitLocation) => StableRange;
};

// @alpha
export interface StableRangeInternal {
    // (undocumented)
    readonly end: StablePlaceInternal;
    // (undocumented)
    readonly start: StablePlaceInternal;
}

// @alpha (undocumented)
export const StableRangeInternal: {
    from: (start: StablePlaceInternal) => {
        to: (end: StablePlaceInternal) => StableRangeInternal;
    };
    only: (node: NodeData<NodeId> | NodeId) => StableRangeInternal;
    all: (trait: TraitLocationInternal) => StableRangeInternal;
};

// @alpha
export interface StableRangeInternal_0_0_2 {
    // (undocumented)
    readonly end: StablePlaceInternal_0_0_2;
    // (undocumented)
    readonly start: StablePlaceInternal_0_0_2;
}

// @alpha
export interface StashedLocalOpMetadata {
    transformedEdit?: Edit<ChangeInternal>;
}

// @alpha
export interface SucceedingTransactionState {
    readonly changes: readonly ChangeInternal[];
    readonly status: EditStatus.Applied;
    readonly steps: readonly ReconciliationChange[];
    readonly view: TransactionView;
}

// @alpha
export type TraitLabel = UuidString & {
    readonly TraitLabel: '613826ed-49cc-4df3-b2b8-bfc6866af8e3';
};

// @alpha
export interface TraitLocation {
    // (undocumented)
    readonly label: TraitLabel;
    // (undocumented)
    readonly parent: NodeId;
}

// @alpha
export interface TraitLocationInternal extends Omit<TraitLocationInternal_0_0_2, 'parent'> {
    // (undocumented)
    readonly parent: NodeId;
}

// @alpha
export interface TraitLocationInternal_0_0_2 {
    // (undocumented)
    readonly label: TraitLabel;
    // (undocumented)
    readonly parent: StableNodeId;
}

// @alpha
export interface TraitMap<TChild> {
    // (undocumented)
    readonly [key: string]: TreeNodeSequence<TChild>;
}

// @alpha
export type TraitNodeIndex = number & {
    readonly TraitNodeIndex: unique symbol;
};

// @alpha
export class Transaction extends TypedEventEmitter<TransactionEvents> {
    constructor(tree: SharedTree);
    apply(...changes: readonly Change[]): EditStatus;
    // (undocumented)
    apply(changes: readonly Change[]): EditStatus;
    closeAndCommit(): void;
    get currentView(): TreeView;
    get isOpen(): boolean;
    readonly startingView: TreeView;
    get status(): EditStatus;
    // (undocumented)
    readonly tree: SharedTree;
}

// @alpha
export enum TransactionEvent {
    ViewChange = "viewChange"
}

// @alpha
export interface TransactionEvents extends IErrorEvent {
    // (undocumented)
    (event: TransactionEvent.ViewChange, listener: (before: TreeView, after: TreeView) => void): any;
}

// @alpha
export namespace TransactionInternal {
    export interface BadPlaceFailure {
        readonly change: ChangeInternal;
        readonly kind: FailureKind.BadPlace;
        readonly place: StablePlaceInternal;
        readonly placeFailure: BadPlaceValidationResult;
    }
    export interface BadRangeFailure {
        readonly change: ChangeInternal;
        readonly kind: FailureKind.BadRange;
        readonly range: StableRangeInternal;
        readonly rangeFailure: BadRangeValidationResult;
    }
    export interface ConstraintViolationFailure {
        readonly constraint: ConstraintInternal;
        readonly kind: FailureKind.ConstraintViolation;
        readonly violation: ConstraintViolationResult;
    }
    export enum ConstraintViolationKind {
        BadLabel = "BadLabel",
        BadLength = "BadLength",
        BadParent = "BadParent",
        BadRange = "BadRange"
    }
    export type ConstraintViolationResult = {
        readonly kind: ConstraintViolationKind.BadRange;
        readonly rangeFailure: BadRangeValidationResult;
    } | {
        readonly kind: ConstraintViolationKind.BadLength;
        readonly actual: number;
    } | {
        readonly kind: ConstraintViolationKind.BadParent;
        readonly actual: NodeId;
    } | {
        readonly kind: ConstraintViolationKind.BadLabel;
        readonly actual: TraitLabel;
    };
    export interface DetachedSequenceIdAlreadyInUseFailure {
        readonly change: ChangeInternal;
        readonly kind: FailureKind.DetachedSequenceIdAlreadyInUse;
        readonly sequenceId: DetachedSequenceId;
    }
    export interface DetachedSequenceNotFoundFailure {
        readonly change: ChangeInternal;
        readonly kind: FailureKind.DetachedSequenceNotFound;
        readonly sequenceId: DetachedSequenceId;
    }
    export interface DuplicateIdInBuildFailure {
        readonly change: ChangeInternal;
        readonly id: NodeId;
        readonly kind: FailureKind.DuplicateIdInBuild;
    }
    export type Failure = UnusedDetachedSequenceFailure | DetachedSequenceIdAlreadyInUseFailure | DetachedSequenceNotFoundFailure | DuplicateIdInBuildFailure | IdAlreadyInUseFailure | UnknownIdFailure | BadPlaceFailure | BadRangeFailure | ConstraintViolationFailure;
    export enum FailureKind {
        BadPlace = "BadPlace",
        BadRange = "BadRange",
        ConstraintViolation = "ConstraintViolation",
        DetachedSequenceIdAlreadyInUse = "DetachedSequenceIdAlreadyInUse",
        DetachedSequenceNotFound = "DetachedSequenceNotFound",
        DuplicateIdInBuild = "DuplicateIdInBuild",
        IdAlreadyInUse = "IdAlreadyInUse",
        UnknownId = "UnknownId",
        UnusedDetachedSequence = "UnusedDetachedSequence"
    }
    export interface IdAlreadyInUseFailure {
        readonly change: ChangeInternal;
        readonly id: NodeId;
        readonly kind: FailureKind.IdAlreadyInUse;
    }
    export interface UnknownIdFailure {
        readonly change: ChangeInternal;
        readonly id: NodeId;
        readonly kind: FailureKind.UnknownId;
    }
    export interface UnusedDetachedSequenceFailure {
        readonly kind: FailureKind.UnusedDetachedSequence;
        readonly sequenceId: DetachedSequenceId;
    }
    // (undocumented)
    export type ValidState = SucceedingTransactionState;
        {};
}

// @alpha
export class TransactionView extends TreeView {
    addNodes(sequence: Iterable<TreeViewNode>): TransactionView;
    attachRange(nodesToAttach: readonly NodeId[], place: TreeViewPlace): TransactionView;
    close(): RevisionView;
    deleteNodes(nodes: Iterable<NodeId>): TransactionView;
    detachRange(rangeToDetach: TreeViewRange): {
        view: TransactionView;
        detached: readonly NodeId[];
    };
    // (undocumented)
    equals(view: TreeView): boolean;
    setNodeValue(nodeId: NodeId, value: Payload): TransactionView;
}

// @alpha
export interface TreeNode<TChild, TId> extends NodeData<TId>, HasTraits<TChild> {
}

// @alpha
export type TreeNodeSequence<TChild> = readonly TChild[];

// @alpha
export abstract class TreeView {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<TreeViewNode>;
    protected constructor(root: NodeId, forest: Forest);
    assertConsistent(): void;
    delta(view: TreeView): Delta<NodeId>;
    // (undocumented)
    abstract equals(view: TreeView): boolean;
    // (undocumented)
    findIndexWithinTrait(place: TreeViewPlace): PlaceIndex;
    // (undocumented)
    protected readonly forest: Forest;
    // (undocumented)
    getIndexInTrait(id: NodeId): TraitNodeIndex;
    // (undocumented)
    getParentViewNode(id: NodeId): TreeViewNode;
    // (undocumented)
    getTrait(traitLocation: TraitLocation): readonly NodeId[];
    // (undocumented)
    getTraitLabel(id: NodeId): TraitLabel;
    // (undocumented)
    getTraitLocation(id: NodeId): TraitLocation;
    // (undocumented)
    getViewNode(id: NodeId): TreeViewNode;
    // (undocumented)
    hasEqualForest(view: TreeView, strict?: boolean): boolean;
    // (undocumented)
    hasNode(id: NodeId): boolean;
    // (undocumented)
    readonly root: NodeId;
    // (undocumented)
    get size(): number;
    // (undocumented)
    tryGetIndexInTrait(id: NodeId): TraitNodeIndex | undefined;
    // (undocumented)
    tryGetParentViewNode(id: NodeId): TreeViewNode | undefined;
    // (undocumented)
    tryGetTraitLabel(id: NodeId): TraitLabel | undefined;
    // (undocumented)
    tryGetTraitLocation(id: NodeId): TraitLocation | undefined;
    // (undocumented)
    tryGetViewNode(id: NodeId): TreeViewNode | undefined;
}

// @alpha
export interface TreeViewNode extends NodeData<NodeId> {
    readonly parentage?: TraitLocation;
    readonly traits: ReadonlyMap<TraitLabel, readonly NodeId[]>;
}

// @alpha
export interface TreeViewPlace {
    // (undocumented)
    readonly sibling?: NodeId;
    // (undocumented)
    readonly side: Side;
    // (undocumented)
    readonly trait: TraitLocation;
}

// @alpha
export interface TreeViewRange {
    // (undocumented)
    readonly end: TreeViewPlace;
    // (undocumented)
    readonly start: TreeViewPlace;
}

// @alpha
export type UuidString = string & {
    readonly UuidString: '9d40d0ae-90d9-44b1-9482-9f55d59d5465';
};

// @alpha
export interface ValidEditingResult extends EditingResultBase {
    readonly after: RevisionView;
    readonly status: EditStatus.Applied;
}

// @alpha
export enum WriteFormat {
    v0_0_2 = "0.0.2",
    v0_1_1 = "0.1.1"
}

```
