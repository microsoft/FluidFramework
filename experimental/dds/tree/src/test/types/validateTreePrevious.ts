/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from '@fluid-experimental/tree-previous';
import * as current from '../../index';

type TypeOnly<T> = {
	[P in keyof T]: TypeOnly<T[P]>;
};

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_areRevisionViewsSemanticallyEqual": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_areRevisionViewsSemanticallyEqual(): TypeOnly<
	typeof old.areRevisionViewsSemanticallyEqual
>;
declare function use_current_FunctionDeclaration_areRevisionViewsSemanticallyEqual(
	use: TypeOnly<typeof current.areRevisionViewsSemanticallyEqual>
);
use_current_FunctionDeclaration_areRevisionViewsSemanticallyEqual(
	get_old_FunctionDeclaration_areRevisionViewsSemanticallyEqual()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_areRevisionViewsSemanticallyEqual": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_areRevisionViewsSemanticallyEqual(): TypeOnly<
	typeof current.areRevisionViewsSemanticallyEqual
>;
declare function use_old_FunctionDeclaration_areRevisionViewsSemanticallyEqual(
	use: TypeOnly<typeof old.areRevisionViewsSemanticallyEqual>
);
use_old_FunctionDeclaration_areRevisionViewsSemanticallyEqual(
	get_current_FunctionDeclaration_areRevisionViewsSemanticallyEqual()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_AttributionId": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_AttributionId(): TypeOnly<old.AttributionId>;
declare function use_current_TypeAliasDeclaration_AttributionId(use: TypeOnly<current.AttributionId>);
use_current_TypeAliasDeclaration_AttributionId(get_old_TypeAliasDeclaration_AttributionId());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_AttributionId": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_AttributionId(): TypeOnly<current.AttributionId>;
declare function use_old_TypeAliasDeclaration_AttributionId(use: TypeOnly<old.AttributionId>);
use_old_TypeAliasDeclaration_AttributionId(get_current_TypeAliasDeclaration_AttributionId());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_BadPlaceValidationResult": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_BadPlaceValidationResult(): TypeOnly<old.BadPlaceValidationResult>;
declare function use_current_TypeAliasDeclaration_BadPlaceValidationResult(
	use: TypeOnly<current.BadPlaceValidationResult>
);
use_current_TypeAliasDeclaration_BadPlaceValidationResult(get_old_TypeAliasDeclaration_BadPlaceValidationResult());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_BadPlaceValidationResult": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_BadPlaceValidationResult(): TypeOnly<current.BadPlaceValidationResult>;
declare function use_old_TypeAliasDeclaration_BadPlaceValidationResult(use: TypeOnly<old.BadPlaceValidationResult>);
use_old_TypeAliasDeclaration_BadPlaceValidationResult(get_current_TypeAliasDeclaration_BadPlaceValidationResult());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_BadRangeValidationResult": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_BadRangeValidationResult(): TypeOnly<old.BadRangeValidationResult>;
declare function use_current_TypeAliasDeclaration_BadRangeValidationResult(
	use: TypeOnly<current.BadRangeValidationResult>
);
use_current_TypeAliasDeclaration_BadRangeValidationResult(get_old_TypeAliasDeclaration_BadRangeValidationResult());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_BadRangeValidationResult": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_BadRangeValidationResult(): TypeOnly<current.BadRangeValidationResult>;
declare function use_old_TypeAliasDeclaration_BadRangeValidationResult(use: TypeOnly<old.BadRangeValidationResult>);
use_old_TypeAliasDeclaration_BadRangeValidationResult(get_current_TypeAliasDeclaration_BadRangeValidationResult());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Build": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_Build(): TypeOnly<old.Build>;
declare function use_current_InterfaceDeclaration_Build(use: TypeOnly<current.Build>);
use_current_InterfaceDeclaration_Build(get_old_InterfaceDeclaration_Build());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Build": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_Build(): TypeOnly<current.Build>;
declare function use_old_InterfaceDeclaration_Build(use: TypeOnly<old.Build>);
use_old_InterfaceDeclaration_Build(get_current_InterfaceDeclaration_Build());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_BuildInternal": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_BuildInternal(): TypeOnly<old.BuildInternal>;
declare function use_current_InterfaceDeclaration_BuildInternal(use: TypeOnly<current.BuildInternal>);
use_current_InterfaceDeclaration_BuildInternal(get_old_InterfaceDeclaration_BuildInternal());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_BuildInternal": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_BuildInternal(): TypeOnly<current.BuildInternal>;
declare function use_old_InterfaceDeclaration_BuildInternal(use: TypeOnly<old.BuildInternal>);
use_old_InterfaceDeclaration_BuildInternal(get_current_InterfaceDeclaration_BuildInternal());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_BuildInternal_0_0_2": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_BuildInternal_0_0_2(): TypeOnly<old.BuildInternal_0_0_2>;
declare function use_current_InterfaceDeclaration_BuildInternal_0_0_2(use: TypeOnly<current.BuildInternal_0_0_2>);
use_current_InterfaceDeclaration_BuildInternal_0_0_2(get_old_InterfaceDeclaration_BuildInternal_0_0_2());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_BuildInternal_0_0_2": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_BuildInternal_0_0_2(): TypeOnly<current.BuildInternal_0_0_2>;
declare function use_old_InterfaceDeclaration_BuildInternal_0_0_2(use: TypeOnly<old.BuildInternal_0_0_2>);
use_old_InterfaceDeclaration_BuildInternal_0_0_2(get_current_InterfaceDeclaration_BuildInternal_0_0_2());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_BuildNode": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_BuildNode(): TypeOnly<old.BuildNode>;
declare function use_current_TypeAliasDeclaration_BuildNode(use: TypeOnly<current.BuildNode>);
use_current_TypeAliasDeclaration_BuildNode(get_old_TypeAliasDeclaration_BuildNode());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_BuildNode": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_BuildNode(): TypeOnly<current.BuildNode>;
declare function use_old_TypeAliasDeclaration_BuildNode(use: TypeOnly<old.BuildNode>);
use_old_TypeAliasDeclaration_BuildNode(get_current_TypeAliasDeclaration_BuildNode());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_BuildNodeInternal": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_BuildNodeInternal(): TypeOnly<old.BuildNodeInternal>;
declare function use_current_TypeAliasDeclaration_BuildNodeInternal(use: TypeOnly<current.BuildNodeInternal>);
use_current_TypeAliasDeclaration_BuildNodeInternal(get_old_TypeAliasDeclaration_BuildNodeInternal());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_BuildNodeInternal": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_BuildNodeInternal(): TypeOnly<current.BuildNodeInternal>;
declare function use_old_TypeAliasDeclaration_BuildNodeInternal(use: TypeOnly<old.BuildNodeInternal>);
use_old_TypeAliasDeclaration_BuildNodeInternal(get_current_TypeAliasDeclaration_BuildNodeInternal());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_BuildNodeInternal_0_0_2": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_BuildNodeInternal_0_0_2(): TypeOnly<old.BuildNodeInternal_0_0_2>;
declare function use_current_TypeAliasDeclaration_BuildNodeInternal_0_0_2(
	use: TypeOnly<current.BuildNodeInternal_0_0_2>
);
use_current_TypeAliasDeclaration_BuildNodeInternal_0_0_2(get_old_TypeAliasDeclaration_BuildNodeInternal_0_0_2());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_BuildNodeInternal_0_0_2": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_BuildNodeInternal_0_0_2(): TypeOnly<current.BuildNodeInternal_0_0_2>;
declare function use_old_TypeAliasDeclaration_BuildNodeInternal_0_0_2(use: TypeOnly<old.BuildNodeInternal_0_0_2>);
use_old_TypeAliasDeclaration_BuildNodeInternal_0_0_2(get_current_TypeAliasDeclaration_BuildNodeInternal_0_0_2());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_BuildTreeNode": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_BuildTreeNode(): TypeOnly<old.BuildTreeNode>;
declare function use_current_InterfaceDeclaration_BuildTreeNode(use: TypeOnly<current.BuildTreeNode>);
use_current_InterfaceDeclaration_BuildTreeNode(get_old_InterfaceDeclaration_BuildTreeNode());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_BuildTreeNode": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_BuildTreeNode(): TypeOnly<current.BuildTreeNode>;
declare function use_old_InterfaceDeclaration_BuildTreeNode(use: TypeOnly<old.BuildTreeNode>);
use_old_InterfaceDeclaration_BuildTreeNode(get_current_InterfaceDeclaration_BuildTreeNode());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_Change": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_Change(): TypeOnly<old.Change>;
declare function use_current_TypeAliasDeclaration_Change(use: TypeOnly<current.Change>);
use_current_TypeAliasDeclaration_Change(get_old_TypeAliasDeclaration_Change());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_Change": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_Change(): TypeOnly<current.Change>;
declare function use_old_TypeAliasDeclaration_Change(use: TypeOnly<old.Change>);
use_old_TypeAliasDeclaration_Change(get_current_TypeAliasDeclaration_Change());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_Change": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_Change(): TypeOnly<typeof old.Change>;
declare function use_current_VariableDeclaration_Change(use: TypeOnly<typeof current.Change>);
use_current_VariableDeclaration_Change(get_old_VariableDeclaration_Change());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_Change": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_Change(): TypeOnly<typeof current.Change>;
declare function use_old_VariableDeclaration_Change(use: TypeOnly<typeof old.Change>);
use_old_VariableDeclaration_Change(get_current_VariableDeclaration_Change());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_ChangeInternal": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ChangeInternal(): TypeOnly<old.ChangeInternal>;
declare function use_current_TypeAliasDeclaration_ChangeInternal(use: TypeOnly<current.ChangeInternal>);
use_current_TypeAliasDeclaration_ChangeInternal(get_old_TypeAliasDeclaration_ChangeInternal());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_ChangeInternal": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ChangeInternal(): TypeOnly<current.ChangeInternal>;
declare function use_old_TypeAliasDeclaration_ChangeInternal(use: TypeOnly<old.ChangeInternal>);
use_old_TypeAliasDeclaration_ChangeInternal(get_current_TypeAliasDeclaration_ChangeInternal());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_ChangeInternal": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_ChangeInternal(): TypeOnly<typeof old.ChangeInternal>;
declare function use_current_VariableDeclaration_ChangeInternal(use: TypeOnly<typeof current.ChangeInternal>);
use_current_VariableDeclaration_ChangeInternal(get_old_VariableDeclaration_ChangeInternal());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_ChangeInternal": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_ChangeInternal(): TypeOnly<typeof current.ChangeInternal>;
declare function use_old_VariableDeclaration_ChangeInternal(use: TypeOnly<typeof old.ChangeInternal>);
use_old_VariableDeclaration_ChangeInternal(get_current_VariableDeclaration_ChangeInternal());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_ChangeNode": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ChangeNode(): TypeOnly<old.ChangeNode>;
declare function use_current_TypeAliasDeclaration_ChangeNode(use: TypeOnly<current.ChangeNode>);
use_current_TypeAliasDeclaration_ChangeNode(get_old_TypeAliasDeclaration_ChangeNode());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_ChangeNode": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ChangeNode(): TypeOnly<current.ChangeNode>;
declare function use_old_TypeAliasDeclaration_ChangeNode(use: TypeOnly<old.ChangeNode>);
use_old_TypeAliasDeclaration_ChangeNode(get_current_TypeAliasDeclaration_ChangeNode());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_ChangeNode_0_0_2": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ChangeNode_0_0_2(): TypeOnly<old.ChangeNode_0_0_2>;
declare function use_current_TypeAliasDeclaration_ChangeNode_0_0_2(use: TypeOnly<current.ChangeNode_0_0_2>);
use_current_TypeAliasDeclaration_ChangeNode_0_0_2(get_old_TypeAliasDeclaration_ChangeNode_0_0_2());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_ChangeNode_0_0_2": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ChangeNode_0_0_2(): TypeOnly<current.ChangeNode_0_0_2>;
declare function use_old_TypeAliasDeclaration_ChangeNode_0_0_2(use: TypeOnly<old.ChangeNode_0_0_2>);
use_old_TypeAliasDeclaration_ChangeNode_0_0_2(get_current_TypeAliasDeclaration_ChangeNode_0_0_2());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_ChangeResult": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_ChangeResult(): TypeOnly<old.ChangeResult>;
declare function use_current_TypeAliasDeclaration_ChangeResult(use: TypeOnly<current.ChangeResult>);
use_current_TypeAliasDeclaration_ChangeResult(get_old_TypeAliasDeclaration_ChangeResult());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_ChangeResult": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_ChangeResult(): TypeOnly<current.ChangeResult>;
declare function use_old_TypeAliasDeclaration_ChangeResult(use: TypeOnly<old.ChangeResult>);
use_old_TypeAliasDeclaration_ChangeResult(get_current_TypeAliasDeclaration_ChangeResult());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_ChangeType": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_ChangeType(): TypeOnly<old.ChangeType>;
declare function use_current_EnumDeclaration_ChangeType(use: TypeOnly<current.ChangeType>);
use_current_EnumDeclaration_ChangeType(get_old_EnumDeclaration_ChangeType());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_ChangeType": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_ChangeType(): TypeOnly<current.ChangeType>;
declare function use_old_EnumDeclaration_ChangeType(use: TypeOnly<old.ChangeType>);
use_old_EnumDeclaration_ChangeType(get_current_EnumDeclaration_ChangeType());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_ChangeTypeInternal": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_ChangeTypeInternal(): TypeOnly<old.ChangeTypeInternal>;
declare function use_current_EnumDeclaration_ChangeTypeInternal(use: TypeOnly<current.ChangeTypeInternal>);
use_current_EnumDeclaration_ChangeTypeInternal(get_old_EnumDeclaration_ChangeTypeInternal());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_ChangeTypeInternal": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_ChangeTypeInternal(): TypeOnly<current.ChangeTypeInternal>;
declare function use_old_EnumDeclaration_ChangeTypeInternal(use: TypeOnly<old.ChangeTypeInternal>);
use_old_EnumDeclaration_ChangeTypeInternal(get_current_EnumDeclaration_ChangeTypeInternal());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_Checkout": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_Checkout(): TypeOnly<old.Checkout>;
declare function use_current_ClassDeclaration_Checkout(use: TypeOnly<current.Checkout>);
use_current_ClassDeclaration_Checkout(get_old_ClassDeclaration_Checkout());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_Checkout": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_Checkout(): TypeOnly<current.Checkout>;
declare function use_old_ClassDeclaration_Checkout(use: TypeOnly<old.Checkout>);
use_old_ClassDeclaration_Checkout(get_current_ClassDeclaration_Checkout());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_CheckoutEvent": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_CheckoutEvent(): TypeOnly<old.CheckoutEvent>;
declare function use_current_EnumDeclaration_CheckoutEvent(use: TypeOnly<current.CheckoutEvent>);
use_current_EnumDeclaration_CheckoutEvent(get_old_EnumDeclaration_CheckoutEvent());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_CheckoutEvent": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_CheckoutEvent(): TypeOnly<current.CheckoutEvent>;
declare function use_old_EnumDeclaration_CheckoutEvent(use: TypeOnly<old.CheckoutEvent>);
use_old_EnumDeclaration_CheckoutEvent(get_current_EnumDeclaration_CheckoutEvent());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_comparePayloads": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_comparePayloads(): TypeOnly<typeof old.comparePayloads>;
declare function use_current_FunctionDeclaration_comparePayloads(use: TypeOnly<typeof current.comparePayloads>);
use_current_FunctionDeclaration_comparePayloads(get_old_FunctionDeclaration_comparePayloads());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_comparePayloads": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_comparePayloads(): TypeOnly<typeof current.comparePayloads>;
declare function use_old_FunctionDeclaration_comparePayloads(use: TypeOnly<typeof old.comparePayloads>);
use_old_FunctionDeclaration_comparePayloads(get_current_FunctionDeclaration_comparePayloads());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_CompressedId": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_CompressedId(): TypeOnly<old.CompressedId>;
declare function use_current_TypeAliasDeclaration_CompressedId(use: TypeOnly<current.CompressedId>);
use_current_TypeAliasDeclaration_CompressedId(get_old_TypeAliasDeclaration_CompressedId());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_CompressedId": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_CompressedId(): TypeOnly<current.CompressedId>;
declare function use_old_TypeAliasDeclaration_CompressedId(use: TypeOnly<old.CompressedId>);
use_old_TypeAliasDeclaration_CompressedId(get_current_TypeAliasDeclaration_CompressedId());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Constraint": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_Constraint(): TypeOnly<old.Constraint>;
declare function use_current_InterfaceDeclaration_Constraint(use: TypeOnly<current.Constraint>);
use_current_InterfaceDeclaration_Constraint(get_old_InterfaceDeclaration_Constraint());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Constraint": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_Constraint(): TypeOnly<current.Constraint>;
declare function use_old_InterfaceDeclaration_Constraint(use: TypeOnly<old.Constraint>);
use_old_InterfaceDeclaration_Constraint(get_current_InterfaceDeclaration_Constraint());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_ConstraintEffect": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_ConstraintEffect(): TypeOnly<old.ConstraintEffect>;
declare function use_current_EnumDeclaration_ConstraintEffect(use: TypeOnly<current.ConstraintEffect>);
use_current_EnumDeclaration_ConstraintEffect(get_old_EnumDeclaration_ConstraintEffect());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_ConstraintEffect": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_ConstraintEffect(): TypeOnly<current.ConstraintEffect>;
declare function use_old_EnumDeclaration_ConstraintEffect(use: TypeOnly<old.ConstraintEffect>);
use_old_EnumDeclaration_ConstraintEffect(get_current_EnumDeclaration_ConstraintEffect());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ConstraintInternal": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ConstraintInternal(): TypeOnly<old.ConstraintInternal>;
declare function use_current_InterfaceDeclaration_ConstraintInternal(use: TypeOnly<current.ConstraintInternal>);
use_current_InterfaceDeclaration_ConstraintInternal(get_old_InterfaceDeclaration_ConstraintInternal());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ConstraintInternal": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ConstraintInternal(): TypeOnly<current.ConstraintInternal>;
declare function use_old_InterfaceDeclaration_ConstraintInternal(use: TypeOnly<old.ConstraintInternal>);
use_old_InterfaceDeclaration_ConstraintInternal(get_current_InterfaceDeclaration_ConstraintInternal());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ConstraintInternal_0_0_2": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ConstraintInternal_0_0_2(): TypeOnly<old.ConstraintInternal_0_0_2>;
declare function use_current_InterfaceDeclaration_ConstraintInternal_0_0_2(
	use: TypeOnly<current.ConstraintInternal_0_0_2>
);
use_current_InterfaceDeclaration_ConstraintInternal_0_0_2(get_old_InterfaceDeclaration_ConstraintInternal_0_0_2());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ConstraintInternal_0_0_2": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ConstraintInternal_0_0_2(): TypeOnly<current.ConstraintInternal_0_0_2>;
declare function use_old_InterfaceDeclaration_ConstraintInternal_0_0_2(use: TypeOnly<old.ConstraintInternal_0_0_2>);
use_old_InterfaceDeclaration_ConstraintInternal_0_0_2(get_current_InterfaceDeclaration_ConstraintInternal_0_0_2());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_Definition": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_Definition(): TypeOnly<old.Definition>;
declare function use_current_TypeAliasDeclaration_Definition(use: TypeOnly<current.Definition>);
use_current_TypeAliasDeclaration_Definition(get_old_TypeAliasDeclaration_Definition());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_Definition": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_Definition(): TypeOnly<current.Definition>;
declare function use_old_TypeAliasDeclaration_Definition(use: TypeOnly<old.Definition>);
use_old_TypeAliasDeclaration_Definition(get_current_TypeAliasDeclaration_Definition());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Delta": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_Delta(): TypeOnly<old.Delta<any>>;
declare function use_current_InterfaceDeclaration_Delta(use: TypeOnly<current.Delta<any>>);
use_current_InterfaceDeclaration_Delta(get_old_InterfaceDeclaration_Delta());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Delta": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_Delta(): TypeOnly<current.Delta<any>>;
declare function use_old_InterfaceDeclaration_Delta(use: TypeOnly<old.Delta<any>>);
use_old_InterfaceDeclaration_Delta(get_current_InterfaceDeclaration_Delta());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Detach": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_Detach(): TypeOnly<old.Detach>;
declare function use_current_InterfaceDeclaration_Detach(use: TypeOnly<current.Detach>);
use_current_InterfaceDeclaration_Detach(get_old_InterfaceDeclaration_Detach());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Detach": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_Detach(): TypeOnly<current.Detach>;
declare function use_old_InterfaceDeclaration_Detach(use: TypeOnly<old.Detach>);
use_old_InterfaceDeclaration_Detach(get_current_InterfaceDeclaration_Detach());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_DetachedSequenceId": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_DetachedSequenceId(): TypeOnly<old.DetachedSequenceId>;
declare function use_current_TypeAliasDeclaration_DetachedSequenceId(use: TypeOnly<current.DetachedSequenceId>);
use_current_TypeAliasDeclaration_DetachedSequenceId(get_old_TypeAliasDeclaration_DetachedSequenceId());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_DetachedSequenceId": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_DetachedSequenceId(): TypeOnly<current.DetachedSequenceId>;
declare function use_old_TypeAliasDeclaration_DetachedSequenceId(use: TypeOnly<old.DetachedSequenceId>);
use_old_TypeAliasDeclaration_DetachedSequenceId(get_current_TypeAliasDeclaration_DetachedSequenceId());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_DetachInternal": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_DetachInternal(): TypeOnly<old.DetachInternal>;
declare function use_current_InterfaceDeclaration_DetachInternal(use: TypeOnly<current.DetachInternal>);
use_current_InterfaceDeclaration_DetachInternal(get_old_InterfaceDeclaration_DetachInternal());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_DetachInternal": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_DetachInternal(): TypeOnly<current.DetachInternal>;
declare function use_old_InterfaceDeclaration_DetachInternal(use: TypeOnly<old.DetachInternal>);
use_old_InterfaceDeclaration_DetachInternal(get_current_InterfaceDeclaration_DetachInternal());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_DetachInternal_0_0_2": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_DetachInternal_0_0_2(): TypeOnly<old.DetachInternal_0_0_2>;
declare function use_current_InterfaceDeclaration_DetachInternal_0_0_2(use: TypeOnly<current.DetachInternal_0_0_2>);
use_current_InterfaceDeclaration_DetachInternal_0_0_2(get_old_InterfaceDeclaration_DetachInternal_0_0_2());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_DetachInternal_0_0_2": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_DetachInternal_0_0_2(): TypeOnly<current.DetachInternal_0_0_2>;
declare function use_old_InterfaceDeclaration_DetachInternal_0_0_2(use: TypeOnly<old.DetachInternal_0_0_2>);
use_old_InterfaceDeclaration_DetachInternal_0_0_2(get_current_InterfaceDeclaration_DetachInternal_0_0_2());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_EagerCheckout": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_EagerCheckout(): TypeOnly<old.EagerCheckout>;
declare function use_current_ClassDeclaration_EagerCheckout(use: TypeOnly<current.EagerCheckout>);
use_current_ClassDeclaration_EagerCheckout(get_old_ClassDeclaration_EagerCheckout());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_EagerCheckout": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_EagerCheckout(): TypeOnly<current.EagerCheckout>;
declare function use_old_ClassDeclaration_EagerCheckout(use: TypeOnly<old.EagerCheckout>);
use_old_ClassDeclaration_EagerCheckout(get_current_ClassDeclaration_EagerCheckout());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Edit": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_Edit(): TypeOnly<old.Edit<any>>;
declare function use_current_InterfaceDeclaration_Edit(use: TypeOnly<current.Edit<any>>);
use_current_InterfaceDeclaration_Edit(get_old_InterfaceDeclaration_Edit());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Edit": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_Edit(): TypeOnly<current.Edit<any>>;
declare function use_old_InterfaceDeclaration_Edit(use: TypeOnly<old.Edit<any>>);
use_old_InterfaceDeclaration_Edit(get_current_InterfaceDeclaration_Edit());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_EditApplicationOutcome": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_EditApplicationOutcome(): TypeOnly<old.EditApplicationOutcome>;
declare function use_current_TypeAliasDeclaration_EditApplicationOutcome(use: TypeOnly<current.EditApplicationOutcome>);
use_current_TypeAliasDeclaration_EditApplicationOutcome(get_old_TypeAliasDeclaration_EditApplicationOutcome());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_EditApplicationOutcome": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_EditApplicationOutcome(): TypeOnly<current.EditApplicationOutcome>;
declare function use_old_TypeAliasDeclaration_EditApplicationOutcome(use: TypeOnly<old.EditApplicationOutcome>);
use_old_TypeAliasDeclaration_EditApplicationOutcome(get_current_TypeAliasDeclaration_EditApplicationOutcome());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_EditBase": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_EditBase(): TypeOnly<old.EditBase<any>>;
declare function use_current_InterfaceDeclaration_EditBase(use: TypeOnly<current.EditBase<any>>);
use_current_InterfaceDeclaration_EditBase(get_old_InterfaceDeclaration_EditBase());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_EditBase": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_EditBase(): TypeOnly<current.EditBase<any>>;
declare function use_old_InterfaceDeclaration_EditBase(use: TypeOnly<old.EditBase<any>>);
use_old_InterfaceDeclaration_EditBase(get_current_InterfaceDeclaration_EditBase());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_EditCommittedEventArguments": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_EditCommittedEventArguments(): TypeOnly<old.EditCommittedEventArguments>;
declare function use_current_InterfaceDeclaration_EditCommittedEventArguments(
	use: TypeOnly<current.EditCommittedEventArguments>
);
use_current_InterfaceDeclaration_EditCommittedEventArguments(
	get_old_InterfaceDeclaration_EditCommittedEventArguments()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_EditCommittedEventArguments": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_EditCommittedEventArguments(): TypeOnly<current.EditCommittedEventArguments>;
declare function use_old_InterfaceDeclaration_EditCommittedEventArguments(
	use: TypeOnly<old.EditCommittedEventArguments>
);
use_old_InterfaceDeclaration_EditCommittedEventArguments(
	get_current_InterfaceDeclaration_EditCommittedEventArguments()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_EditCommittedHandler": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_EditCommittedHandler(): TypeOnly<old.EditCommittedHandler>;
declare function use_current_TypeAliasDeclaration_EditCommittedHandler(use: TypeOnly<current.EditCommittedHandler>);
use_current_TypeAliasDeclaration_EditCommittedHandler(get_old_TypeAliasDeclaration_EditCommittedHandler());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_EditCommittedHandler": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_EditCommittedHandler(): TypeOnly<current.EditCommittedHandler>;
declare function use_old_TypeAliasDeclaration_EditCommittedHandler(use: TypeOnly<old.EditCommittedHandler>);
use_old_TypeAliasDeclaration_EditCommittedHandler(get_current_TypeAliasDeclaration_EditCommittedHandler());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_EditHandle": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_EditHandle(): TypeOnly<old.EditHandle<any>>;
declare function use_current_InterfaceDeclaration_EditHandle(use: TypeOnly<current.EditHandle<any>>);
use_current_InterfaceDeclaration_EditHandle(get_old_InterfaceDeclaration_EditHandle());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_EditHandle": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_EditHandle(): TypeOnly<current.EditHandle<any>>;
declare function use_old_InterfaceDeclaration_EditHandle(use: TypeOnly<old.EditHandle<any>>);
use_old_InterfaceDeclaration_EditHandle(get_current_InterfaceDeclaration_EditHandle());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_EditId": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_EditId(): TypeOnly<old.EditId>;
declare function use_current_TypeAliasDeclaration_EditId(use: TypeOnly<current.EditId>);
use_current_TypeAliasDeclaration_EditId(get_old_TypeAliasDeclaration_EditId());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_EditId": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_EditId(): TypeOnly<current.EditId>;
declare function use_old_TypeAliasDeclaration_EditId(use: TypeOnly<old.EditId>);
use_old_TypeAliasDeclaration_EditId(get_current_TypeAliasDeclaration_EditId());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_EditingResult": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_EditingResult(): TypeOnly<old.EditingResult>;
declare function use_current_TypeAliasDeclaration_EditingResult(use: TypeOnly<current.EditingResult>);
use_current_TypeAliasDeclaration_EditingResult(get_old_TypeAliasDeclaration_EditingResult());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_EditingResult": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_EditingResult(): TypeOnly<current.EditingResult>;
declare function use_old_TypeAliasDeclaration_EditingResult(use: TypeOnly<old.EditingResult>);
use_old_TypeAliasDeclaration_EditingResult(get_current_TypeAliasDeclaration_EditingResult());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_EditingResultBase": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_EditingResultBase(): TypeOnly<old.EditingResultBase>;
declare function use_current_InterfaceDeclaration_EditingResultBase(use: TypeOnly<current.EditingResultBase>);
use_current_InterfaceDeclaration_EditingResultBase(get_old_InterfaceDeclaration_EditingResultBase());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_EditingResultBase": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_EditingResultBase(): TypeOnly<current.EditingResultBase>;
declare function use_old_InterfaceDeclaration_EditingResultBase(use: TypeOnly<old.EditingResultBase>);
use_old_InterfaceDeclaration_EditingResultBase(get_current_InterfaceDeclaration_EditingResultBase());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_EditLogSummary": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_EditLogSummary(): TypeOnly<old.EditLogSummary<any, any>>;
declare function use_current_InterfaceDeclaration_EditLogSummary(use: TypeOnly<current.EditLogSummary<any, any>>);
use_current_InterfaceDeclaration_EditLogSummary(get_old_InterfaceDeclaration_EditLogSummary());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_EditLogSummary": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_EditLogSummary(): TypeOnly<current.EditLogSummary<any, any>>;
declare function use_old_InterfaceDeclaration_EditLogSummary(use: TypeOnly<old.EditLogSummary<any, any>>);
use_old_InterfaceDeclaration_EditLogSummary(get_current_InterfaceDeclaration_EditLogSummary());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_EditStatus": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_EditStatus(): TypeOnly<old.EditStatus>;
declare function use_current_EnumDeclaration_EditStatus(use: TypeOnly<current.EditStatus>);
use_current_EnumDeclaration_EditStatus(get_old_EnumDeclaration_EditStatus());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_EditStatus": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_EditStatus(): TypeOnly<current.EditStatus>;
declare function use_old_EnumDeclaration_EditStatus(use: TypeOnly<old.EditStatus>);
use_old_EnumDeclaration_EditStatus(get_current_EnumDeclaration_EditStatus());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_EditValidationResult": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_EditValidationResult(): TypeOnly<old.EditValidationResult>;
declare function use_current_EnumDeclaration_EditValidationResult(use: TypeOnly<current.EditValidationResult>);
use_current_EnumDeclaration_EditValidationResult(get_old_EnumDeclaration_EditValidationResult());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_EditValidationResult": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_EditValidationResult(): TypeOnly<current.EditValidationResult>;
declare function use_old_EnumDeclaration_EditValidationResult(use: TypeOnly<old.EditValidationResult>);
use_old_EnumDeclaration_EditValidationResult(get_current_EnumDeclaration_EditValidationResult());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_EditWithoutId": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_EditWithoutId(): TypeOnly<old.EditWithoutId<any>>;
declare function use_current_InterfaceDeclaration_EditWithoutId(use: TypeOnly<current.EditWithoutId<any>>);
use_current_InterfaceDeclaration_EditWithoutId(get_old_InterfaceDeclaration_EditWithoutId());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_EditWithoutId": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_EditWithoutId(): TypeOnly<current.EditWithoutId<any>>;
declare function use_old_InterfaceDeclaration_EditWithoutId(use: TypeOnly<old.EditWithoutId<any>>);
use_old_InterfaceDeclaration_EditWithoutId(get_current_InterfaceDeclaration_EditWithoutId());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_FailedEditingResult": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_FailedEditingResult(): TypeOnly<old.FailedEditingResult>;
declare function use_current_InterfaceDeclaration_FailedEditingResult(use: TypeOnly<current.FailedEditingResult>);
use_current_InterfaceDeclaration_FailedEditingResult(get_old_InterfaceDeclaration_FailedEditingResult());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_FailedEditingResult": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_FailedEditingResult(): TypeOnly<current.FailedEditingResult>;
declare function use_old_InterfaceDeclaration_FailedEditingResult(use: TypeOnly<old.FailedEditingResult>);
use_old_InterfaceDeclaration_FailedEditingResult(get_current_InterfaceDeclaration_FailedEditingResult());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_FailingTransactionState": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_FailingTransactionState(): TypeOnly<old.FailingTransactionState>;
declare function use_current_InterfaceDeclaration_FailingTransactionState(
	use: TypeOnly<current.FailingTransactionState>
);
use_current_InterfaceDeclaration_FailingTransactionState(get_old_InterfaceDeclaration_FailingTransactionState());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_FailingTransactionState": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_FailingTransactionState(): TypeOnly<current.FailingTransactionState>;
declare function use_old_InterfaceDeclaration_FailingTransactionState(use: TypeOnly<old.FailingTransactionState>);
use_old_InterfaceDeclaration_FailingTransactionState(get_current_InterfaceDeclaration_FailingTransactionState());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_FinalCompressedId": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_FinalCompressedId(): TypeOnly<old.FinalCompressedId>;
declare function use_current_TypeAliasDeclaration_FinalCompressedId(use: TypeOnly<current.FinalCompressedId>);
use_current_TypeAliasDeclaration_FinalCompressedId(get_old_TypeAliasDeclaration_FinalCompressedId());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_FinalCompressedId": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_FinalCompressedId(): TypeOnly<current.FinalCompressedId>;
declare function use_old_TypeAliasDeclaration_FinalCompressedId(use: TypeOnly<old.FinalCompressedId>);
use_old_TypeAliasDeclaration_FinalCompressedId(get_current_TypeAliasDeclaration_FinalCompressedId());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_FluidEditHandle": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_FluidEditHandle(): TypeOnly<old.FluidEditHandle>;
declare function use_current_InterfaceDeclaration_FluidEditHandle(use: TypeOnly<current.FluidEditHandle>);
use_current_InterfaceDeclaration_FluidEditHandle(get_old_InterfaceDeclaration_FluidEditHandle());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_FluidEditHandle": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_FluidEditHandle(): TypeOnly<current.FluidEditHandle>;
declare function use_old_InterfaceDeclaration_FluidEditHandle(use: TypeOnly<old.FluidEditHandle>);
use_old_InterfaceDeclaration_FluidEditHandle(get_current_InterfaceDeclaration_FluidEditHandle());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_Forest": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_Forest(): TypeOnly<old.Forest>;
declare function use_current_ClassDeclaration_Forest(use: TypeOnly<current.Forest>);
use_current_ClassDeclaration_Forest(get_old_ClassDeclaration_Forest());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_Forest": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_Forest(): TypeOnly<current.Forest>;
declare function use_old_ClassDeclaration_Forest(use: TypeOnly<old.Forest>);
use_old_ClassDeclaration_Forest(get_current_ClassDeclaration_Forest());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ForestNode": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ForestNode(): TypeOnly<old.ForestNode>;
declare function use_current_InterfaceDeclaration_ForestNode(use: TypeOnly<current.ForestNode>);
use_current_InterfaceDeclaration_ForestNode(get_old_InterfaceDeclaration_ForestNode());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ForestNode": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ForestNode(): TypeOnly<current.ForestNode>;
declare function use_old_InterfaceDeclaration_ForestNode(use: TypeOnly<old.ForestNode>);
use_old_InterfaceDeclaration_ForestNode(get_current_InterfaceDeclaration_ForestNode());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_GenericTransaction": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_GenericTransaction(): TypeOnly<old.GenericTransaction>;
declare function use_current_ClassDeclaration_GenericTransaction(use: TypeOnly<current.GenericTransaction>);
use_current_ClassDeclaration_GenericTransaction(get_old_ClassDeclaration_GenericTransaction());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_GenericTransaction": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_GenericTransaction(): TypeOnly<current.GenericTransaction>;
declare function use_old_ClassDeclaration_GenericTransaction(use: TypeOnly<old.GenericTransaction>);
use_old_ClassDeclaration_GenericTransaction(get_current_ClassDeclaration_GenericTransaction());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_GenericTransactionPolicy": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_GenericTransactionPolicy(): TypeOnly<old.GenericTransactionPolicy>;
declare function use_current_InterfaceDeclaration_GenericTransactionPolicy(
	use: TypeOnly<current.GenericTransactionPolicy>
);
use_current_InterfaceDeclaration_GenericTransactionPolicy(get_old_InterfaceDeclaration_GenericTransactionPolicy());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_GenericTransactionPolicy": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_GenericTransactionPolicy(): TypeOnly<current.GenericTransactionPolicy>;
declare function use_old_InterfaceDeclaration_GenericTransactionPolicy(use: TypeOnly<old.GenericTransactionPolicy>);
use_old_InterfaceDeclaration_GenericTransactionPolicy(get_current_InterfaceDeclaration_GenericTransactionPolicy());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_getSerializedUploadedEditChunkContents": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getSerializedUploadedEditChunkContents(): TypeOnly<
	typeof old.getSerializedUploadedEditChunkContents
>;
declare function use_current_FunctionDeclaration_getSerializedUploadedEditChunkContents(
	use: TypeOnly<typeof current.getSerializedUploadedEditChunkContents>
);
use_current_FunctionDeclaration_getSerializedUploadedEditChunkContents(
	get_old_FunctionDeclaration_getSerializedUploadedEditChunkContents()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_getSerializedUploadedEditChunkContents": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getSerializedUploadedEditChunkContents(): TypeOnly<
	typeof current.getSerializedUploadedEditChunkContents
>;
declare function use_old_FunctionDeclaration_getSerializedUploadedEditChunkContents(
	use: TypeOnly<typeof old.getSerializedUploadedEditChunkContents>
);
use_old_FunctionDeclaration_getSerializedUploadedEditChunkContents(
	get_current_FunctionDeclaration_getSerializedUploadedEditChunkContents()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_getTraitLocationOfRange": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_getTraitLocationOfRange(): TypeOnly<typeof old.getTraitLocationOfRange>;
declare function use_current_FunctionDeclaration_getTraitLocationOfRange(
	use: TypeOnly<typeof current.getTraitLocationOfRange>
);
use_current_FunctionDeclaration_getTraitLocationOfRange(get_old_FunctionDeclaration_getTraitLocationOfRange());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_getTraitLocationOfRange": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_getTraitLocationOfRange(): TypeOnly<
	typeof current.getTraitLocationOfRange
>;
declare function use_old_FunctionDeclaration_getTraitLocationOfRange(use: TypeOnly<typeof old.getTraitLocationOfRange>);
use_old_FunctionDeclaration_getTraitLocationOfRange(get_current_FunctionDeclaration_getTraitLocationOfRange());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_HasTraits": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_HasTraits(): TypeOnly<old.HasTraits<any>>;
declare function use_current_InterfaceDeclaration_HasTraits(use: TypeOnly<current.HasTraits<any>>);
use_current_InterfaceDeclaration_HasTraits(get_old_InterfaceDeclaration_HasTraits());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_HasTraits": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_HasTraits(): TypeOnly<current.HasTraits<any>>;
declare function use_old_InterfaceDeclaration_HasTraits(use: TypeOnly<old.HasTraits<any>>);
use_old_InterfaceDeclaration_HasTraits(get_current_InterfaceDeclaration_HasTraits());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_HasVariadicTraits": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_HasVariadicTraits(): TypeOnly<old.HasVariadicTraits<any>>;
declare function use_current_InterfaceDeclaration_HasVariadicTraits(use: TypeOnly<current.HasVariadicTraits<any>>);
use_current_InterfaceDeclaration_HasVariadicTraits(get_old_InterfaceDeclaration_HasVariadicTraits());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_HasVariadicTraits": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_HasVariadicTraits(): TypeOnly<current.HasVariadicTraits<any>>;
declare function use_old_InterfaceDeclaration_HasVariadicTraits(use: TypeOnly<old.HasVariadicTraits<any>>);
use_old_InterfaceDeclaration_HasVariadicTraits(get_current_InterfaceDeclaration_HasVariadicTraits());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ICheckoutEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ICheckoutEvents(): TypeOnly<old.ICheckoutEvents>;
declare function use_current_InterfaceDeclaration_ICheckoutEvents(use: TypeOnly<current.ICheckoutEvents>);
use_current_InterfaceDeclaration_ICheckoutEvents(get_old_InterfaceDeclaration_ICheckoutEvents());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ICheckoutEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ICheckoutEvents(): TypeOnly<current.ICheckoutEvents>;
declare function use_old_InterfaceDeclaration_ICheckoutEvents(use: TypeOnly<old.ICheckoutEvents>);
use_old_InterfaceDeclaration_ICheckoutEvents(get_current_InterfaceDeclaration_ICheckoutEvents());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_initialTree": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_initialTree(): TypeOnly<typeof old.initialTree>;
declare function use_current_VariableDeclaration_initialTree(use: TypeOnly<typeof current.initialTree>);
use_current_VariableDeclaration_initialTree(get_old_VariableDeclaration_initialTree());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_initialTree": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_initialTree(): TypeOnly<typeof current.initialTree>;
declare function use_old_VariableDeclaration_initialTree(use: TypeOnly<typeof old.initialTree>);
use_old_VariableDeclaration_initialTree(get_current_VariableDeclaration_initialTree());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Insert": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_Insert(): TypeOnly<old.Insert>;
declare function use_current_InterfaceDeclaration_Insert(use: TypeOnly<current.Insert>);
use_current_InterfaceDeclaration_Insert(get_old_InterfaceDeclaration_Insert());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Insert": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_Insert(): TypeOnly<current.Insert>;
declare function use_old_InterfaceDeclaration_Insert(use: TypeOnly<old.Insert>);
use_old_InterfaceDeclaration_Insert(get_current_InterfaceDeclaration_Insert());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_InsertInternal": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_InsertInternal(): TypeOnly<old.InsertInternal>;
declare function use_current_InterfaceDeclaration_InsertInternal(use: TypeOnly<current.InsertInternal>);
use_current_InterfaceDeclaration_InsertInternal(get_old_InterfaceDeclaration_InsertInternal());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_InsertInternal": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_InsertInternal(): TypeOnly<current.InsertInternal>;
declare function use_old_InterfaceDeclaration_InsertInternal(use: TypeOnly<old.InsertInternal>);
use_old_InterfaceDeclaration_InsertInternal(get_current_InterfaceDeclaration_InsertInternal());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_InsertInternal_0_0_2": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_InsertInternal_0_0_2(): TypeOnly<old.InsertInternal_0_0_2>;
declare function use_current_InterfaceDeclaration_InsertInternal_0_0_2(use: TypeOnly<current.InsertInternal_0_0_2>);
use_current_InterfaceDeclaration_InsertInternal_0_0_2(get_old_InterfaceDeclaration_InsertInternal_0_0_2());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_InsertInternal_0_0_2": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_InsertInternal_0_0_2(): TypeOnly<current.InsertInternal_0_0_2>;
declare function use_old_InterfaceDeclaration_InsertInternal_0_0_2(use: TypeOnly<old.InsertInternal_0_0_2>);
use_old_InterfaceDeclaration_InsertInternal_0_0_2(get_current_InterfaceDeclaration_InsertInternal_0_0_2());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_InternalizedChange": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_InternalizedChange(): TypeOnly<old.InternalizedChange>;
declare function use_current_InterfaceDeclaration_InternalizedChange(use: TypeOnly<current.InternalizedChange>);
use_current_InterfaceDeclaration_InternalizedChange(get_old_InterfaceDeclaration_InternalizedChange());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_InternalizedChange": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_InternalizedChange(): TypeOnly<current.InternalizedChange>;
declare function use_old_InterfaceDeclaration_InternalizedChange(use: TypeOnly<old.InternalizedChange>);
use_old_InterfaceDeclaration_InternalizedChange(get_current_InterfaceDeclaration_InternalizedChange());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_InternedStringId": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_InternedStringId(): TypeOnly<old.InternedStringId>;
declare function use_current_TypeAliasDeclaration_InternedStringId(use: TypeOnly<current.InternedStringId>);
use_current_TypeAliasDeclaration_InternedStringId(get_old_TypeAliasDeclaration_InternedStringId());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_InternedStringId": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_InternedStringId(): TypeOnly<current.InternedStringId>;
declare function use_old_TypeAliasDeclaration_InternedStringId(use: TypeOnly<old.InternedStringId>);
use_old_TypeAliasDeclaration_InternedStringId(get_current_TypeAliasDeclaration_InternedStringId());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_isDetachedSequenceId": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_isDetachedSequenceId(): TypeOnly<typeof old.isDetachedSequenceId>;
declare function use_current_FunctionDeclaration_isDetachedSequenceId(
	use: TypeOnly<typeof current.isDetachedSequenceId>
);
use_current_FunctionDeclaration_isDetachedSequenceId(get_old_FunctionDeclaration_isDetachedSequenceId());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_isDetachedSequenceId": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_isDetachedSequenceId(): TypeOnly<typeof current.isDetachedSequenceId>;
declare function use_old_FunctionDeclaration_isDetachedSequenceId(use: TypeOnly<typeof old.isDetachedSequenceId>);
use_old_FunctionDeclaration_isDetachedSequenceId(get_current_FunctionDeclaration_isDetachedSequenceId());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ISharedTreeEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ISharedTreeEvents(): TypeOnly<old.ISharedTreeEvents>;
declare function use_current_InterfaceDeclaration_ISharedTreeEvents(use: TypeOnly<current.ISharedTreeEvents>);
use_current_InterfaceDeclaration_ISharedTreeEvents(get_old_InterfaceDeclaration_ISharedTreeEvents());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ISharedTreeEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ISharedTreeEvents(): TypeOnly<current.ISharedTreeEvents>;
declare function use_old_InterfaceDeclaration_ISharedTreeEvents(use: TypeOnly<old.ISharedTreeEvents>);
use_old_InterfaceDeclaration_ISharedTreeEvents(get_current_InterfaceDeclaration_ISharedTreeEvents());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_isSharedTreeEvent": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_isSharedTreeEvent(): TypeOnly<typeof old.isSharedTreeEvent>;
declare function use_current_FunctionDeclaration_isSharedTreeEvent(use: TypeOnly<typeof current.isSharedTreeEvent>);
use_current_FunctionDeclaration_isSharedTreeEvent(get_old_FunctionDeclaration_isSharedTreeEvent());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_isSharedTreeEvent": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_isSharedTreeEvent(): TypeOnly<typeof current.isSharedTreeEvent>;
declare function use_old_FunctionDeclaration_isSharedTreeEvent(use: TypeOnly<typeof old.isSharedTreeEvent>);
use_old_FunctionDeclaration_isSharedTreeEvent(get_current_FunctionDeclaration_isSharedTreeEvent());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_LazyCheckout": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_LazyCheckout(): TypeOnly<old.LazyCheckout>;
declare function use_current_ClassDeclaration_LazyCheckout(use: TypeOnly<current.LazyCheckout>);
use_current_ClassDeclaration_LazyCheckout(get_old_ClassDeclaration_LazyCheckout());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_LazyCheckout": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_LazyCheckout(): TypeOnly<current.LazyCheckout>;
declare function use_old_ClassDeclaration_LazyCheckout(use: TypeOnly<old.LazyCheckout>);
use_old_ClassDeclaration_LazyCheckout(get_current_ClassDeclaration_LazyCheckout());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_LocalCompressedId": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_LocalCompressedId(): TypeOnly<old.LocalCompressedId>;
declare function use_current_TypeAliasDeclaration_LocalCompressedId(use: TypeOnly<current.LocalCompressedId>);
use_current_TypeAliasDeclaration_LocalCompressedId(get_old_TypeAliasDeclaration_LocalCompressedId());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_LocalCompressedId": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_LocalCompressedId(): TypeOnly<current.LocalCompressedId>;
declare function use_old_TypeAliasDeclaration_LocalCompressedId(use: TypeOnly<old.LocalCompressedId>);
use_old_TypeAliasDeclaration_LocalCompressedId(get_current_TypeAliasDeclaration_LocalCompressedId());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_LogViewer": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_LogViewer(): TypeOnly<old.LogViewer>;
declare function use_current_InterfaceDeclaration_LogViewer(use: TypeOnly<current.LogViewer>);
use_current_InterfaceDeclaration_LogViewer(get_old_InterfaceDeclaration_LogViewer());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_LogViewer": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_LogViewer(): TypeOnly<current.LogViewer>;
declare function use_old_InterfaceDeclaration_LogViewer(use: TypeOnly<old.LogViewer>);
use_old_InterfaceDeclaration_LogViewer(get_current_InterfaceDeclaration_LogViewer());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_MergeHealthStats": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_MergeHealthStats(): TypeOnly<old.MergeHealthStats>;
declare function use_current_InterfaceDeclaration_MergeHealthStats(use: TypeOnly<current.MergeHealthStats>);
use_current_InterfaceDeclaration_MergeHealthStats(get_old_InterfaceDeclaration_MergeHealthStats());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_MergeHealthStats": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_MergeHealthStats(): TypeOnly<current.MergeHealthStats>;
declare function use_old_InterfaceDeclaration_MergeHealthStats(use: TypeOnly<old.MergeHealthStats>);
use_old_InterfaceDeclaration_MergeHealthStats(get_current_InterfaceDeclaration_MergeHealthStats());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_NodeData": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_NodeData(): TypeOnly<old.NodeData<any>>;
declare function use_current_InterfaceDeclaration_NodeData(use: TypeOnly<current.NodeData<any>>);
use_current_InterfaceDeclaration_NodeData(get_old_InterfaceDeclaration_NodeData());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_NodeData": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_NodeData(): TypeOnly<current.NodeData<any>>;
declare function use_old_InterfaceDeclaration_NodeData(use: TypeOnly<old.NodeData<any>>);
use_old_InterfaceDeclaration_NodeData(get_current_InterfaceDeclaration_NodeData());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_NodeId": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_NodeId(): TypeOnly<old.NodeId>;
declare function use_current_TypeAliasDeclaration_NodeId(use: TypeOnly<current.NodeId>);
use_current_TypeAliasDeclaration_NodeId(get_old_TypeAliasDeclaration_NodeId());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_NodeId": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_NodeId(): TypeOnly<current.NodeId>;
declare function use_old_TypeAliasDeclaration_NodeId(use: TypeOnly<old.NodeId>);
use_old_TypeAliasDeclaration_NodeId(get_current_TypeAliasDeclaration_NodeId());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_NodeIdBrand": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_NodeIdBrand(): TypeOnly<old.NodeIdBrand>;
declare function use_current_InterfaceDeclaration_NodeIdBrand(use: TypeOnly<current.NodeIdBrand>);
use_current_InterfaceDeclaration_NodeIdBrand(get_old_InterfaceDeclaration_NodeIdBrand());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_NodeIdBrand": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_NodeIdBrand(): TypeOnly<current.NodeIdBrand>;
declare function use_old_InterfaceDeclaration_NodeIdBrand(use: TypeOnly<old.NodeIdBrand>);
use_old_InterfaceDeclaration_NodeIdBrand(get_current_InterfaceDeclaration_NodeIdBrand());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_NodeIdContext": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_NodeIdContext(): TypeOnly<old.NodeIdContext>;
declare function use_current_InterfaceDeclaration_NodeIdContext(use: TypeOnly<current.NodeIdContext>);
use_current_InterfaceDeclaration_NodeIdContext(get_old_InterfaceDeclaration_NodeIdContext());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_NodeIdContext": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_NodeIdContext(): TypeOnly<current.NodeIdContext>;
declare function use_old_InterfaceDeclaration_NodeIdContext(use: TypeOnly<old.NodeIdContext>);
use_old_InterfaceDeclaration_NodeIdContext(get_current_InterfaceDeclaration_NodeIdContext());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_NodeIdConverter": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_NodeIdConverter(): TypeOnly<old.NodeIdConverter>;
declare function use_current_InterfaceDeclaration_NodeIdConverter(use: TypeOnly<current.NodeIdConverter>);
use_current_InterfaceDeclaration_NodeIdConverter(get_old_InterfaceDeclaration_NodeIdConverter());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_NodeIdConverter": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_NodeIdConverter(): TypeOnly<current.NodeIdConverter>;
declare function use_old_InterfaceDeclaration_NodeIdConverter(use: TypeOnly<old.NodeIdConverter>);
use_old_InterfaceDeclaration_NodeIdConverter(get_current_InterfaceDeclaration_NodeIdConverter());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_NodeIdGenerator": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_NodeIdGenerator(): TypeOnly<old.NodeIdGenerator>;
declare function use_current_InterfaceDeclaration_NodeIdGenerator(use: TypeOnly<current.NodeIdGenerator>);
use_current_InterfaceDeclaration_NodeIdGenerator(get_old_InterfaceDeclaration_NodeIdGenerator());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_NodeIdGenerator": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_NodeIdGenerator(): TypeOnly<current.NodeIdGenerator>;
declare function use_old_InterfaceDeclaration_NodeIdGenerator(use: TypeOnly<old.NodeIdGenerator>);
use_old_InterfaceDeclaration_NodeIdGenerator(get_current_InterfaceDeclaration_NodeIdGenerator());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_NodeInTrait": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_NodeInTrait(): TypeOnly<old.NodeInTrait>;
declare function use_current_InterfaceDeclaration_NodeInTrait(use: TypeOnly<current.NodeInTrait>);
use_current_InterfaceDeclaration_NodeInTrait(get_old_InterfaceDeclaration_NodeInTrait());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_NodeInTrait": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_NodeInTrait(): TypeOnly<current.NodeInTrait>;
declare function use_old_InterfaceDeclaration_NodeInTrait(use: TypeOnly<old.NodeInTrait>);
use_old_InterfaceDeclaration_NodeInTrait(get_current_InterfaceDeclaration_NodeInTrait());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_OrderedEditSet": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_OrderedEditSet(): TypeOnly<old.OrderedEditSet>;
declare function use_current_InterfaceDeclaration_OrderedEditSet(use: TypeOnly<current.OrderedEditSet>);
use_current_InterfaceDeclaration_OrderedEditSet(get_old_InterfaceDeclaration_OrderedEditSet());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_OrderedEditSet": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_OrderedEditSet(): TypeOnly<current.OrderedEditSet>;
declare function use_old_InterfaceDeclaration_OrderedEditSet(use: TypeOnly<old.OrderedEditSet>);
use_old_InterfaceDeclaration_OrderedEditSet(get_current_InterfaceDeclaration_OrderedEditSet());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ParentData": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ParentData(): TypeOnly<old.ParentData>;
declare function use_current_InterfaceDeclaration_ParentData(use: TypeOnly<current.ParentData>);
use_current_InterfaceDeclaration_ParentData(get_old_InterfaceDeclaration_ParentData());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ParentData": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ParentData(): TypeOnly<current.ParentData>;
declare function use_old_InterfaceDeclaration_ParentData(use: TypeOnly<old.ParentData>);
use_old_InterfaceDeclaration_ParentData(get_current_InterfaceDeclaration_ParentData());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_Payload": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_Payload(): TypeOnly<old.Payload>;
declare function use_current_TypeAliasDeclaration_Payload(use: TypeOnly<current.Payload>);
use_current_TypeAliasDeclaration_Payload(get_old_TypeAliasDeclaration_Payload());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_Payload": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_Payload(): TypeOnly<current.Payload>;
declare function use_old_TypeAliasDeclaration_Payload(use: TypeOnly<old.Payload>);
use_old_TypeAliasDeclaration_Payload(get_current_TypeAliasDeclaration_Payload());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_placeFromStablePlace": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_placeFromStablePlace(): TypeOnly<typeof old.placeFromStablePlace>;
declare function use_current_FunctionDeclaration_placeFromStablePlace(
	use: TypeOnly<typeof current.placeFromStablePlace>
);
use_current_FunctionDeclaration_placeFromStablePlace(get_old_FunctionDeclaration_placeFromStablePlace());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_placeFromStablePlace": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_placeFromStablePlace(): TypeOnly<typeof current.placeFromStablePlace>;
declare function use_old_FunctionDeclaration_placeFromStablePlace(use: TypeOnly<typeof old.placeFromStablePlace>);
use_old_FunctionDeclaration_placeFromStablePlace(get_current_FunctionDeclaration_placeFromStablePlace());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_PlaceholderTree": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_PlaceholderTree(): TypeOnly<old.PlaceholderTree>;
declare function use_current_TypeAliasDeclaration_PlaceholderTree(use: TypeOnly<current.PlaceholderTree>);
use_current_TypeAliasDeclaration_PlaceholderTree(get_old_TypeAliasDeclaration_PlaceholderTree());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_PlaceholderTree": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_PlaceholderTree(): TypeOnly<current.PlaceholderTree>;
declare function use_old_TypeAliasDeclaration_PlaceholderTree(use: TypeOnly<old.PlaceholderTree>);
use_old_TypeAliasDeclaration_PlaceholderTree(get_current_TypeAliasDeclaration_PlaceholderTree());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_PlaceIndex": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_PlaceIndex(): TypeOnly<old.PlaceIndex>;
declare function use_current_TypeAliasDeclaration_PlaceIndex(use: TypeOnly<current.PlaceIndex>);
use_current_TypeAliasDeclaration_PlaceIndex(get_old_TypeAliasDeclaration_PlaceIndex());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_PlaceIndex": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_PlaceIndex(): TypeOnly<current.PlaceIndex>;
declare function use_old_TypeAliasDeclaration_PlaceIndex(use: TypeOnly<old.PlaceIndex>);
use_old_TypeAliasDeclaration_PlaceIndex(get_current_TypeAliasDeclaration_PlaceIndex());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_PlaceValidationResult": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_PlaceValidationResult(): TypeOnly<old.PlaceValidationResult>;
declare function use_current_EnumDeclaration_PlaceValidationResult(use: TypeOnly<current.PlaceValidationResult>);
use_current_EnumDeclaration_PlaceValidationResult(get_old_EnumDeclaration_PlaceValidationResult());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_PlaceValidationResult": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_PlaceValidationResult(): TypeOnly<current.PlaceValidationResult>;
declare function use_old_EnumDeclaration_PlaceValidationResult(use: TypeOnly<old.PlaceValidationResult>);
use_old_EnumDeclaration_PlaceValidationResult(get_current_EnumDeclaration_PlaceValidationResult());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_rangeFromStableRange": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_rangeFromStableRange(): TypeOnly<typeof old.rangeFromStableRange>;
declare function use_current_FunctionDeclaration_rangeFromStableRange(
	use: TypeOnly<typeof current.rangeFromStableRange>
);
use_current_FunctionDeclaration_rangeFromStableRange(get_old_FunctionDeclaration_rangeFromStableRange());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_rangeFromStableRange": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_rangeFromStableRange(): TypeOnly<typeof current.rangeFromStableRange>;
declare function use_old_FunctionDeclaration_rangeFromStableRange(use: TypeOnly<typeof old.rangeFromStableRange>);
use_old_FunctionDeclaration_rangeFromStableRange(get_current_FunctionDeclaration_rangeFromStableRange());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_RangeValidationResult": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_RangeValidationResult(): TypeOnly<old.RangeValidationResult>;
declare function use_current_TypeAliasDeclaration_RangeValidationResult(use: TypeOnly<current.RangeValidationResult>);
use_current_TypeAliasDeclaration_RangeValidationResult(get_old_TypeAliasDeclaration_RangeValidationResult());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_RangeValidationResult": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_RangeValidationResult(): TypeOnly<current.RangeValidationResult>;
declare function use_old_TypeAliasDeclaration_RangeValidationResult(use: TypeOnly<old.RangeValidationResult>);
use_old_TypeAliasDeclaration_RangeValidationResult(get_current_TypeAliasDeclaration_RangeValidationResult());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_RangeValidationResultKind": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_RangeValidationResultKind(): TypeOnly<old.RangeValidationResultKind>;
declare function use_current_EnumDeclaration_RangeValidationResultKind(
	use: TypeOnly<current.RangeValidationResultKind>
);
use_current_EnumDeclaration_RangeValidationResultKind(get_old_EnumDeclaration_RangeValidationResultKind());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_RangeValidationResultKind": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_RangeValidationResultKind(): TypeOnly<current.RangeValidationResultKind>;
declare function use_old_EnumDeclaration_RangeValidationResultKind(use: TypeOnly<old.RangeValidationResultKind>);
use_old_EnumDeclaration_RangeValidationResultKind(get_current_EnumDeclaration_RangeValidationResultKind());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ReconciliationChange": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ReconciliationChange(): TypeOnly<old.ReconciliationChange>;
declare function use_current_InterfaceDeclaration_ReconciliationChange(use: TypeOnly<current.ReconciliationChange>);
use_current_InterfaceDeclaration_ReconciliationChange(get_old_InterfaceDeclaration_ReconciliationChange());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ReconciliationChange": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ReconciliationChange(): TypeOnly<current.ReconciliationChange>;
declare function use_old_InterfaceDeclaration_ReconciliationChange(use: TypeOnly<old.ReconciliationChange>);
use_old_InterfaceDeclaration_ReconciliationChange(get_current_InterfaceDeclaration_ReconciliationChange());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ReconciliationEdit": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ReconciliationEdit(): TypeOnly<old.ReconciliationEdit>;
declare function use_current_InterfaceDeclaration_ReconciliationEdit(use: TypeOnly<current.ReconciliationEdit>);
use_current_InterfaceDeclaration_ReconciliationEdit(get_old_InterfaceDeclaration_ReconciliationEdit());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ReconciliationEdit": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ReconciliationEdit(): TypeOnly<current.ReconciliationEdit>;
declare function use_old_InterfaceDeclaration_ReconciliationEdit(use: TypeOnly<old.ReconciliationEdit>);
use_old_InterfaceDeclaration_ReconciliationEdit(get_current_InterfaceDeclaration_ReconciliationEdit());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ReconciliationPath": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ReconciliationPath(): TypeOnly<old.ReconciliationPath>;
declare function use_current_InterfaceDeclaration_ReconciliationPath(use: TypeOnly<current.ReconciliationPath>);
use_current_InterfaceDeclaration_ReconciliationPath(get_old_InterfaceDeclaration_ReconciliationPath());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ReconciliationPath": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ReconciliationPath(): TypeOnly<current.ReconciliationPath>;
declare function use_old_InterfaceDeclaration_ReconciliationPath(use: TypeOnly<old.ReconciliationPath>);
use_old_InterfaceDeclaration_ReconciliationPath(get_current_InterfaceDeclaration_ReconciliationPath());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_Result": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_Result(): TypeOnly<old.Result<any, any>>;
declare function use_current_TypeAliasDeclaration_Result(use: TypeOnly<current.Result<any, any>>);
use_current_TypeAliasDeclaration_Result(get_old_TypeAliasDeclaration_Result());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_Result": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_Result(): TypeOnly<current.Result<any, any>>;
declare function use_old_TypeAliasDeclaration_Result(use: TypeOnly<old.Result<any, any>>);
use_old_TypeAliasDeclaration_Result(get_current_TypeAliasDeclaration_Result());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_Result.error": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_Result_error(): TypeOnly<typeof old.Result.error>;
declare function use_current_FunctionDeclaration_Result_error(use: TypeOnly<typeof current.Result.error>);
use_current_FunctionDeclaration_Result_error(get_old_FunctionDeclaration_Result_error());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_Result.error": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_Result_error(): TypeOnly<typeof current.Result.error>;
declare function use_old_FunctionDeclaration_Result_error(use: TypeOnly<typeof old.Result.error>);
use_old_FunctionDeclaration_Result_error(get_current_FunctionDeclaration_Result_error());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Result.Error": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_Result_Error(): TypeOnly<old.Result.Error<any>>;
declare function use_current_InterfaceDeclaration_Result_Error(use: TypeOnly<current.Result.Error<any>>);
use_current_InterfaceDeclaration_Result_Error(get_old_InterfaceDeclaration_Result_Error());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Result.Error": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_Result_Error(): TypeOnly<current.Result.Error<any>>;
declare function use_old_InterfaceDeclaration_Result_Error(use: TypeOnly<old.Result.Error<any>>);
use_old_InterfaceDeclaration_Result_Error(get_current_InterfaceDeclaration_Result_Error());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_Result.isError": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_Result_isError(): TypeOnly<typeof old.Result.isError>;
declare function use_current_FunctionDeclaration_Result_isError(use: TypeOnly<typeof current.Result.isError>);
use_current_FunctionDeclaration_Result_isError(get_old_FunctionDeclaration_Result_isError());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_Result.isError": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_Result_isError(): TypeOnly<typeof current.Result.isError>;
declare function use_old_FunctionDeclaration_Result_isError(use: TypeOnly<typeof old.Result.isError>);
use_old_FunctionDeclaration_Result_isError(get_current_FunctionDeclaration_Result_isError());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_Result.isOk": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_Result_isOk(): TypeOnly<typeof old.Result.isOk>;
declare function use_current_FunctionDeclaration_Result_isOk(use: TypeOnly<typeof current.Result.isOk>);
use_current_FunctionDeclaration_Result_isOk(get_old_FunctionDeclaration_Result_isOk());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_Result.isOk": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_Result_isOk(): TypeOnly<typeof current.Result.isOk>;
declare function use_old_FunctionDeclaration_Result_isOk(use: TypeOnly<typeof old.Result.isOk>);
use_old_FunctionDeclaration_Result_isOk(get_current_FunctionDeclaration_Result_isOk());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_Result.mapError": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_Result_mapError(): TypeOnly<typeof old.Result.mapError>;
declare function use_current_FunctionDeclaration_Result_mapError(use: TypeOnly<typeof current.Result.mapError>);
use_current_FunctionDeclaration_Result_mapError(get_old_FunctionDeclaration_Result_mapError());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_Result.mapError": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_Result_mapError(): TypeOnly<typeof current.Result.mapError>;
declare function use_old_FunctionDeclaration_Result_mapError(use: TypeOnly<typeof old.Result.mapError>);
use_old_FunctionDeclaration_Result_mapError(get_current_FunctionDeclaration_Result_mapError());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_Result.mapOk": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_Result_mapOk(): TypeOnly<typeof old.Result.mapOk>;
declare function use_current_FunctionDeclaration_Result_mapOk(use: TypeOnly<typeof current.Result.mapOk>);
use_current_FunctionDeclaration_Result_mapOk(get_old_FunctionDeclaration_Result_mapOk());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_Result.mapOk": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_Result_mapOk(): TypeOnly<typeof current.Result.mapOk>;
declare function use_old_FunctionDeclaration_Result_mapOk(use: TypeOnly<typeof old.Result.mapOk>);
use_old_FunctionDeclaration_Result_mapOk(get_current_FunctionDeclaration_Result_mapOk());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_Result.ok": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_Result_ok(): TypeOnly<typeof old.Result.ok>;
declare function use_current_FunctionDeclaration_Result_ok(use: TypeOnly<typeof current.Result.ok>);
use_current_FunctionDeclaration_Result_ok(get_old_FunctionDeclaration_Result_ok());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_Result.ok": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_Result_ok(): TypeOnly<typeof current.Result.ok>;
declare function use_old_FunctionDeclaration_Result_ok(use: TypeOnly<typeof old.Result.ok>);
use_old_FunctionDeclaration_Result_ok(get_current_FunctionDeclaration_Result_ok());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Result.Ok": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_Result_Ok(): TypeOnly<old.Result.Ok<any>>;
declare function use_current_InterfaceDeclaration_Result_Ok(use: TypeOnly<current.Result.Ok<any>>);
use_current_InterfaceDeclaration_Result_Ok(get_old_InterfaceDeclaration_Result_Ok());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_Result.Ok": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_Result_Ok(): TypeOnly<current.Result.Ok<any>>;
declare function use_old_InterfaceDeclaration_Result_Ok(use: TypeOnly<old.Result.Ok<any>>);
use_old_InterfaceDeclaration_Result_Ok(get_current_InterfaceDeclaration_Result_Ok());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_Result.ResultType": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_Result_ResultType(): TypeOnly<old.Result.ResultType>;
declare function use_current_EnumDeclaration_Result_ResultType(use: TypeOnly<current.Result.ResultType>);
use_current_EnumDeclaration_Result_ResultType(get_old_EnumDeclaration_Result_ResultType());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_Result.ResultType": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_Result_ResultType(): TypeOnly<current.Result.ResultType>;
declare function use_old_EnumDeclaration_Result_ResultType(use: TypeOnly<old.Result.ResultType>);
use_old_EnumDeclaration_Result_ResultType(get_current_EnumDeclaration_Result_ResultType());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_Revision": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_Revision(): TypeOnly<old.Revision>;
declare function use_current_TypeAliasDeclaration_Revision(use: TypeOnly<current.Revision>);
use_current_TypeAliasDeclaration_Revision(get_old_TypeAliasDeclaration_Revision());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_Revision": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_Revision(): TypeOnly<current.Revision>;
declare function use_old_TypeAliasDeclaration_Revision(use: TypeOnly<old.Revision>);
use_old_TypeAliasDeclaration_Revision(get_current_TypeAliasDeclaration_Revision());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_RevisionView": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_RevisionView(): TypeOnly<old.RevisionView>;
declare function use_current_ClassDeclaration_RevisionView(use: TypeOnly<current.RevisionView>);
use_current_ClassDeclaration_RevisionView(get_old_ClassDeclaration_RevisionView());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_RevisionView": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_RevisionView(): TypeOnly<current.RevisionView>;
declare function use_old_ClassDeclaration_RevisionView(use: TypeOnly<old.RevisionView>);
use_old_ClassDeclaration_RevisionView(get_current_ClassDeclaration_RevisionView());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SequencedEditAppliedEventArguments": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SequencedEditAppliedEventArguments(): TypeOnly<old.SequencedEditAppliedEventArguments>;
declare function use_current_InterfaceDeclaration_SequencedEditAppliedEventArguments(
	use: TypeOnly<current.SequencedEditAppliedEventArguments>
);
use_current_InterfaceDeclaration_SequencedEditAppliedEventArguments(
	get_old_InterfaceDeclaration_SequencedEditAppliedEventArguments()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SequencedEditAppliedEventArguments": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SequencedEditAppliedEventArguments(): TypeOnly<current.SequencedEditAppliedEventArguments>;
declare function use_old_InterfaceDeclaration_SequencedEditAppliedEventArguments(
	use: TypeOnly<old.SequencedEditAppliedEventArguments>
);
use_old_InterfaceDeclaration_SequencedEditAppliedEventArguments(
	get_current_InterfaceDeclaration_SequencedEditAppliedEventArguments()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_SequencedEditAppliedHandler": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SequencedEditAppliedHandler(): TypeOnly<old.SequencedEditAppliedHandler>;
declare function use_current_TypeAliasDeclaration_SequencedEditAppliedHandler(
	use: TypeOnly<current.SequencedEditAppliedHandler>
);
use_current_TypeAliasDeclaration_SequencedEditAppliedHandler(
	get_old_TypeAliasDeclaration_SequencedEditAppliedHandler()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_SequencedEditAppliedHandler": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SequencedEditAppliedHandler(): TypeOnly<current.SequencedEditAppliedHandler>;
declare function use_old_TypeAliasDeclaration_SequencedEditAppliedHandler(
	use: TypeOnly<old.SequencedEditAppliedHandler>
);
use_old_TypeAliasDeclaration_SequencedEditAppliedHandler(
	get_current_TypeAliasDeclaration_SequencedEditAppliedHandler()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_SessionSpaceCompressedId": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SessionSpaceCompressedId(): TypeOnly<old.SessionSpaceCompressedId>;
declare function use_current_TypeAliasDeclaration_SessionSpaceCompressedId(
	use: TypeOnly<current.SessionSpaceCompressedId>
);
use_current_TypeAliasDeclaration_SessionSpaceCompressedId(get_old_TypeAliasDeclaration_SessionSpaceCompressedId());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_SessionSpaceCompressedId": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SessionSpaceCompressedId(): TypeOnly<current.SessionSpaceCompressedId>;
declare function use_old_TypeAliasDeclaration_SessionSpaceCompressedId(use: TypeOnly<old.SessionSpaceCompressedId>);
use_old_TypeAliasDeclaration_SessionSpaceCompressedId(get_current_TypeAliasDeclaration_SessionSpaceCompressedId());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SessionUnique": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SessionUnique(): TypeOnly<old.SessionUnique>;
declare function use_current_InterfaceDeclaration_SessionUnique(use: TypeOnly<current.SessionUnique>);
use_current_InterfaceDeclaration_SessionUnique(get_old_InterfaceDeclaration_SessionUnique());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SessionUnique": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SessionUnique(): TypeOnly<current.SessionUnique>;
declare function use_old_InterfaceDeclaration_SessionUnique(use: TypeOnly<old.SessionUnique>);
use_old_InterfaceDeclaration_SessionUnique(get_current_InterfaceDeclaration_SessionUnique());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_setTrait": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_setTrait(): TypeOnly<typeof old.setTrait>;
declare function use_current_FunctionDeclaration_setTrait(use: TypeOnly<typeof current.setTrait>);
use_current_FunctionDeclaration_setTrait(get_old_FunctionDeclaration_setTrait());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_setTrait": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_setTrait(): TypeOnly<typeof current.setTrait>;
declare function use_old_FunctionDeclaration_setTrait(use: TypeOnly<typeof old.setTrait>);
use_old_FunctionDeclaration_setTrait(get_current_FunctionDeclaration_setTrait());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SetValue": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SetValue(): TypeOnly<old.SetValue>;
declare function use_current_InterfaceDeclaration_SetValue(use: TypeOnly<current.SetValue>);
use_current_InterfaceDeclaration_SetValue(get_old_InterfaceDeclaration_SetValue());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SetValue": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SetValue(): TypeOnly<current.SetValue>;
declare function use_old_InterfaceDeclaration_SetValue(use: TypeOnly<old.SetValue>);
use_old_InterfaceDeclaration_SetValue(get_current_InterfaceDeclaration_SetValue());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SetValueInternal": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SetValueInternal(): TypeOnly<old.SetValueInternal>;
declare function use_current_InterfaceDeclaration_SetValueInternal(use: TypeOnly<current.SetValueInternal>);
use_current_InterfaceDeclaration_SetValueInternal(get_old_InterfaceDeclaration_SetValueInternal());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SetValueInternal": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SetValueInternal(): TypeOnly<current.SetValueInternal>;
declare function use_old_InterfaceDeclaration_SetValueInternal(use: TypeOnly<old.SetValueInternal>);
use_old_InterfaceDeclaration_SetValueInternal(get_current_InterfaceDeclaration_SetValueInternal());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SetValueInternal_0_0_2": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SetValueInternal_0_0_2(): TypeOnly<old.SetValueInternal_0_0_2>;
declare function use_current_InterfaceDeclaration_SetValueInternal_0_0_2(use: TypeOnly<current.SetValueInternal_0_0_2>);
use_current_InterfaceDeclaration_SetValueInternal_0_0_2(get_old_InterfaceDeclaration_SetValueInternal_0_0_2());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SetValueInternal_0_0_2": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SetValueInternal_0_0_2(): TypeOnly<current.SetValueInternal_0_0_2>;
declare function use_old_InterfaceDeclaration_SetValueInternal_0_0_2(use: TypeOnly<old.SetValueInternal_0_0_2>);
use_old_InterfaceDeclaration_SetValueInternal_0_0_2(get_current_InterfaceDeclaration_SetValueInternal_0_0_2());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_SharedTree": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SharedTree(): TypeOnly<old.SharedTree>;
declare function use_current_ClassDeclaration_SharedTree(use: TypeOnly<current.SharedTree>);
use_current_ClassDeclaration_SharedTree(get_old_ClassDeclaration_SharedTree());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_SharedTree": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SharedTree(): TypeOnly<current.SharedTree>;
declare function use_old_ClassDeclaration_SharedTree(use: TypeOnly<old.SharedTree>);
use_old_ClassDeclaration_SharedTree(get_current_ClassDeclaration_SharedTree());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_SharedTreeArgs": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SharedTreeArgs(): TypeOnly<old.SharedTreeArgs>;
declare function use_current_TypeAliasDeclaration_SharedTreeArgs(use: TypeOnly<current.SharedTreeArgs>);
use_current_TypeAliasDeclaration_SharedTreeArgs(get_old_TypeAliasDeclaration_SharedTreeArgs());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_SharedTreeArgs": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SharedTreeArgs(): TypeOnly<current.SharedTreeArgs>;
declare function use_old_TypeAliasDeclaration_SharedTreeArgs(use: TypeOnly<old.SharedTreeArgs>);
use_old_TypeAliasDeclaration_SharedTreeArgs(get_current_TypeAliasDeclaration_SharedTreeArgs());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_sharedTreeAssertionErrorType": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_sharedTreeAssertionErrorType(): TypeOnly<
	typeof old.sharedTreeAssertionErrorType
>;
declare function use_current_VariableDeclaration_sharedTreeAssertionErrorType(
	use: TypeOnly<typeof current.sharedTreeAssertionErrorType>
);
use_current_VariableDeclaration_sharedTreeAssertionErrorType(
	get_old_VariableDeclaration_sharedTreeAssertionErrorType()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_sharedTreeAssertionErrorType": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_sharedTreeAssertionErrorType(): TypeOnly<
	typeof current.sharedTreeAssertionErrorType
>;
declare function use_old_VariableDeclaration_sharedTreeAssertionErrorType(
	use: TypeOnly<typeof old.sharedTreeAssertionErrorType>
);
use_old_VariableDeclaration_sharedTreeAssertionErrorType(
	get_current_VariableDeclaration_sharedTreeAssertionErrorType()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_SharedTreeDiagnosticEvent": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_SharedTreeDiagnosticEvent(): TypeOnly<old.SharedTreeDiagnosticEvent>;
declare function use_current_EnumDeclaration_SharedTreeDiagnosticEvent(
	use: TypeOnly<current.SharedTreeDiagnosticEvent>
);
use_current_EnumDeclaration_SharedTreeDiagnosticEvent(get_old_EnumDeclaration_SharedTreeDiagnosticEvent());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_SharedTreeDiagnosticEvent": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_SharedTreeDiagnosticEvent(): TypeOnly<current.SharedTreeDiagnosticEvent>;
declare function use_old_EnumDeclaration_SharedTreeDiagnosticEvent(use: TypeOnly<old.SharedTreeDiagnosticEvent>);
use_old_EnumDeclaration_SharedTreeDiagnosticEvent(get_current_EnumDeclaration_SharedTreeDiagnosticEvent());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_SharedTreeEvent": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_SharedTreeEvent(): TypeOnly<old.SharedTreeEvent>;
declare function use_current_EnumDeclaration_SharedTreeEvent(use: TypeOnly<current.SharedTreeEvent>);
use_current_EnumDeclaration_SharedTreeEvent(get_old_EnumDeclaration_SharedTreeEvent());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_SharedTreeEvent": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_SharedTreeEvent(): TypeOnly<current.SharedTreeEvent>;
declare function use_old_EnumDeclaration_SharedTreeEvent(use: TypeOnly<old.SharedTreeEvent>);
use_old_EnumDeclaration_SharedTreeEvent(get_current_EnumDeclaration_SharedTreeEvent());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_SharedTreeFactory": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SharedTreeFactory(): TypeOnly<old.SharedTreeFactory>;
declare function use_current_ClassDeclaration_SharedTreeFactory(use: TypeOnly<current.SharedTreeFactory>);
use_current_ClassDeclaration_SharedTreeFactory(get_old_ClassDeclaration_SharedTreeFactory());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_SharedTreeFactory": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SharedTreeFactory(): TypeOnly<current.SharedTreeFactory>;
declare function use_old_ClassDeclaration_SharedTreeFactory(use: TypeOnly<old.SharedTreeFactory>);
use_old_ClassDeclaration_SharedTreeFactory(get_current_ClassDeclaration_SharedTreeFactory());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_SharedTreeMergeHealthTelemetryHeartbeat": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_SharedTreeMergeHealthTelemetryHeartbeat(): TypeOnly<old.SharedTreeMergeHealthTelemetryHeartbeat>;
declare function use_current_ClassDeclaration_SharedTreeMergeHealthTelemetryHeartbeat(
	use: TypeOnly<current.SharedTreeMergeHealthTelemetryHeartbeat>
);
use_current_ClassDeclaration_SharedTreeMergeHealthTelemetryHeartbeat(
	get_old_ClassDeclaration_SharedTreeMergeHealthTelemetryHeartbeat()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_SharedTreeMergeHealthTelemetryHeartbeat": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_SharedTreeMergeHealthTelemetryHeartbeat(): TypeOnly<current.SharedTreeMergeHealthTelemetryHeartbeat>;
declare function use_old_ClassDeclaration_SharedTreeMergeHealthTelemetryHeartbeat(
	use: TypeOnly<old.SharedTreeMergeHealthTelemetryHeartbeat>
);
use_old_ClassDeclaration_SharedTreeMergeHealthTelemetryHeartbeat(
	get_current_ClassDeclaration_SharedTreeMergeHealthTelemetryHeartbeat()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_SharedTreeOptions": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_SharedTreeOptions(): TypeOnly<old.SharedTreeOptions<any, any>>;
declare function use_current_TypeAliasDeclaration_SharedTreeOptions(use: TypeOnly<current.SharedTreeOptions<any, any>>);
use_current_TypeAliasDeclaration_SharedTreeOptions(get_old_TypeAliasDeclaration_SharedTreeOptions());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_SharedTreeOptions": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_SharedTreeOptions(): TypeOnly<current.SharedTreeOptions<any, any>>;
declare function use_old_TypeAliasDeclaration_SharedTreeOptions(use: TypeOnly<old.SharedTreeOptions<any, any>>);
use_old_TypeAliasDeclaration_SharedTreeOptions(get_current_TypeAliasDeclaration_SharedTreeOptions());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SharedTreeOptions_0_0_2": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SharedTreeOptions_0_0_2(): TypeOnly<old.SharedTreeOptions_0_0_2>;
declare function use_current_InterfaceDeclaration_SharedTreeOptions_0_0_2(
	use: TypeOnly<current.SharedTreeOptions_0_0_2>
);
use_current_InterfaceDeclaration_SharedTreeOptions_0_0_2(get_old_InterfaceDeclaration_SharedTreeOptions_0_0_2());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SharedTreeOptions_0_0_2": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SharedTreeOptions_0_0_2(): TypeOnly<current.SharedTreeOptions_0_0_2>;
declare function use_old_InterfaceDeclaration_SharedTreeOptions_0_0_2(use: TypeOnly<old.SharedTreeOptions_0_0_2>);
use_old_InterfaceDeclaration_SharedTreeOptions_0_0_2(get_current_InterfaceDeclaration_SharedTreeOptions_0_0_2());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SharedTreeOptions_0_1_1": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SharedTreeOptions_0_1_1(): TypeOnly<old.SharedTreeOptions_0_1_1>;
declare function use_current_InterfaceDeclaration_SharedTreeOptions_0_1_1(
	use: TypeOnly<current.SharedTreeOptions_0_1_1>
);
use_current_InterfaceDeclaration_SharedTreeOptions_0_1_1(get_old_InterfaceDeclaration_SharedTreeOptions_0_1_1());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SharedTreeOptions_0_1_1": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SharedTreeOptions_0_1_1(): TypeOnly<current.SharedTreeOptions_0_1_1>;
declare function use_old_InterfaceDeclaration_SharedTreeOptions_0_1_1(use: TypeOnly<old.SharedTreeOptions_0_1_1>);
use_old_InterfaceDeclaration_SharedTreeOptions_0_1_1(get_current_InterfaceDeclaration_SharedTreeOptions_0_1_1());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SharedTreeSummaryBase": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SharedTreeSummaryBase(): TypeOnly<old.SharedTreeSummaryBase>;
declare function use_current_InterfaceDeclaration_SharedTreeSummaryBase(use: TypeOnly<current.SharedTreeSummaryBase>);
use_current_InterfaceDeclaration_SharedTreeSummaryBase(get_old_InterfaceDeclaration_SharedTreeSummaryBase());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SharedTreeSummaryBase": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SharedTreeSummaryBase(): TypeOnly<current.SharedTreeSummaryBase>;
declare function use_old_InterfaceDeclaration_SharedTreeSummaryBase(use: TypeOnly<old.SharedTreeSummaryBase>);
use_old_InterfaceDeclaration_SharedTreeSummaryBase(get_current_InterfaceDeclaration_SharedTreeSummaryBase());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_Side": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_Side(): TypeOnly<old.Side>;
declare function use_current_EnumDeclaration_Side(use: TypeOnly<current.Side>);
use_current_EnumDeclaration_Side(get_old_EnumDeclaration_Side());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_Side": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_Side(): TypeOnly<current.Side>;
declare function use_old_EnumDeclaration_Side(use: TypeOnly<old.Side>);
use_old_EnumDeclaration_Side(get_current_EnumDeclaration_Side());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_StableNodeId": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_StableNodeId(): TypeOnly<old.StableNodeId>;
declare function use_current_TypeAliasDeclaration_StableNodeId(use: TypeOnly<current.StableNodeId>);
use_current_TypeAliasDeclaration_StableNodeId(get_old_TypeAliasDeclaration_StableNodeId());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_StableNodeId": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_StableNodeId(): TypeOnly<current.StableNodeId>;
declare function use_old_TypeAliasDeclaration_StableNodeId(use: TypeOnly<old.StableNodeId>);
use_old_TypeAliasDeclaration_StableNodeId(get_current_TypeAliasDeclaration_StableNodeId());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StablePlace": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_StablePlace(): TypeOnly<old.StablePlace>;
declare function use_current_InterfaceDeclaration_StablePlace(use: TypeOnly<current.StablePlace>);
use_current_InterfaceDeclaration_StablePlace(get_old_InterfaceDeclaration_StablePlace());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StablePlace": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_StablePlace(): TypeOnly<current.StablePlace>;
declare function use_old_InterfaceDeclaration_StablePlace(use: TypeOnly<old.StablePlace>);
use_old_InterfaceDeclaration_StablePlace(get_current_InterfaceDeclaration_StablePlace());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_StablePlace": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_StablePlace(): TypeOnly<typeof old.StablePlace>;
declare function use_current_VariableDeclaration_StablePlace(use: TypeOnly<typeof current.StablePlace>);
use_current_VariableDeclaration_StablePlace(get_old_VariableDeclaration_StablePlace());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_StablePlace": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_StablePlace(): TypeOnly<typeof current.StablePlace>;
declare function use_old_VariableDeclaration_StablePlace(use: TypeOnly<typeof old.StablePlace>);
use_old_VariableDeclaration_StablePlace(get_current_VariableDeclaration_StablePlace());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StablePlaceInternal": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_StablePlaceInternal(): TypeOnly<old.StablePlaceInternal>;
declare function use_current_InterfaceDeclaration_StablePlaceInternal(use: TypeOnly<current.StablePlaceInternal>);
use_current_InterfaceDeclaration_StablePlaceInternal(get_old_InterfaceDeclaration_StablePlaceInternal());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StablePlaceInternal": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_StablePlaceInternal(): TypeOnly<current.StablePlaceInternal>;
declare function use_old_InterfaceDeclaration_StablePlaceInternal(use: TypeOnly<old.StablePlaceInternal>);
use_old_InterfaceDeclaration_StablePlaceInternal(get_current_InterfaceDeclaration_StablePlaceInternal());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_StablePlaceInternal": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_StablePlaceInternal(): TypeOnly<typeof old.StablePlaceInternal>;
declare function use_current_VariableDeclaration_StablePlaceInternal(use: TypeOnly<typeof current.StablePlaceInternal>);
use_current_VariableDeclaration_StablePlaceInternal(get_old_VariableDeclaration_StablePlaceInternal());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_StablePlaceInternal": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_StablePlaceInternal(): TypeOnly<typeof current.StablePlaceInternal>;
declare function use_old_VariableDeclaration_StablePlaceInternal(use: TypeOnly<typeof old.StablePlaceInternal>);
use_old_VariableDeclaration_StablePlaceInternal(get_current_VariableDeclaration_StablePlaceInternal());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StablePlaceInternal_0_0_2": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_StablePlaceInternal_0_0_2(): TypeOnly<old.StablePlaceInternal_0_0_2>;
declare function use_current_InterfaceDeclaration_StablePlaceInternal_0_0_2(
	use: TypeOnly<current.StablePlaceInternal_0_0_2>
);
use_current_InterfaceDeclaration_StablePlaceInternal_0_0_2(get_old_InterfaceDeclaration_StablePlaceInternal_0_0_2());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StablePlaceInternal_0_0_2": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_StablePlaceInternal_0_0_2(): TypeOnly<current.StablePlaceInternal_0_0_2>;
declare function use_old_InterfaceDeclaration_StablePlaceInternal_0_0_2(use: TypeOnly<old.StablePlaceInternal_0_0_2>);
use_old_InterfaceDeclaration_StablePlaceInternal_0_0_2(get_current_InterfaceDeclaration_StablePlaceInternal_0_0_2());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StableRange": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_StableRange(): TypeOnly<old.StableRange>;
declare function use_current_InterfaceDeclaration_StableRange(use: TypeOnly<current.StableRange>);
use_current_InterfaceDeclaration_StableRange(get_old_InterfaceDeclaration_StableRange());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StableRange": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_StableRange(): TypeOnly<current.StableRange>;
declare function use_old_InterfaceDeclaration_StableRange(use: TypeOnly<old.StableRange>);
use_old_InterfaceDeclaration_StableRange(get_current_InterfaceDeclaration_StableRange());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_StableRange": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_StableRange(): TypeOnly<typeof old.StableRange>;
declare function use_current_VariableDeclaration_StableRange(use: TypeOnly<typeof current.StableRange>);
use_current_VariableDeclaration_StableRange(get_old_VariableDeclaration_StableRange());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_StableRange": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_StableRange(): TypeOnly<typeof current.StableRange>;
declare function use_old_VariableDeclaration_StableRange(use: TypeOnly<typeof old.StableRange>);
use_old_VariableDeclaration_StableRange(get_current_VariableDeclaration_StableRange());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StableRangeInternal": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_StableRangeInternal(): TypeOnly<old.StableRangeInternal>;
declare function use_current_InterfaceDeclaration_StableRangeInternal(use: TypeOnly<current.StableRangeInternal>);
use_current_InterfaceDeclaration_StableRangeInternal(get_old_InterfaceDeclaration_StableRangeInternal());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StableRangeInternal": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_StableRangeInternal(): TypeOnly<current.StableRangeInternal>;
declare function use_old_InterfaceDeclaration_StableRangeInternal(use: TypeOnly<old.StableRangeInternal>);
use_old_InterfaceDeclaration_StableRangeInternal(get_current_InterfaceDeclaration_StableRangeInternal());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_StableRangeInternal": {"forwardCompat": false}
 */
declare function get_old_VariableDeclaration_StableRangeInternal(): TypeOnly<typeof old.StableRangeInternal>;
declare function use_current_VariableDeclaration_StableRangeInternal(use: TypeOnly<typeof current.StableRangeInternal>);
use_current_VariableDeclaration_StableRangeInternal(get_old_VariableDeclaration_StableRangeInternal());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "VariableDeclaration_StableRangeInternal": {"backCompat": false}
 */
declare function get_current_VariableDeclaration_StableRangeInternal(): TypeOnly<typeof current.StableRangeInternal>;
declare function use_old_VariableDeclaration_StableRangeInternal(use: TypeOnly<typeof old.StableRangeInternal>);
use_old_VariableDeclaration_StableRangeInternal(get_current_VariableDeclaration_StableRangeInternal());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StableRangeInternal_0_0_2": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_StableRangeInternal_0_0_2(): TypeOnly<old.StableRangeInternal_0_0_2>;
declare function use_current_InterfaceDeclaration_StableRangeInternal_0_0_2(
	use: TypeOnly<current.StableRangeInternal_0_0_2>
);
use_current_InterfaceDeclaration_StableRangeInternal_0_0_2(get_old_InterfaceDeclaration_StableRangeInternal_0_0_2());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StableRangeInternal_0_0_2": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_StableRangeInternal_0_0_2(): TypeOnly<current.StableRangeInternal_0_0_2>;
declare function use_old_InterfaceDeclaration_StableRangeInternal_0_0_2(use: TypeOnly<old.StableRangeInternal_0_0_2>);
use_old_InterfaceDeclaration_StableRangeInternal_0_0_2(get_current_InterfaceDeclaration_StableRangeInternal_0_0_2());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StashedLocalOpMetadata": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_StashedLocalOpMetadata(): TypeOnly<old.StashedLocalOpMetadata>;
declare function use_current_InterfaceDeclaration_StashedLocalOpMetadata(use: TypeOnly<current.StashedLocalOpMetadata>);
use_current_InterfaceDeclaration_StashedLocalOpMetadata(get_old_InterfaceDeclaration_StashedLocalOpMetadata());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StashedLocalOpMetadata": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_StashedLocalOpMetadata(): TypeOnly<current.StashedLocalOpMetadata>;
declare function use_old_InterfaceDeclaration_StashedLocalOpMetadata(use: TypeOnly<old.StashedLocalOpMetadata>);
use_old_InterfaceDeclaration_StashedLocalOpMetadata(get_current_InterfaceDeclaration_StashedLocalOpMetadata());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StringInterner": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_StringInterner(): TypeOnly<old.StringInterner>;
declare function use_current_InterfaceDeclaration_StringInterner(use: TypeOnly<current.StringInterner>);
use_current_InterfaceDeclaration_StringInterner(get_old_InterfaceDeclaration_StringInterner());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_StringInterner": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_StringInterner(): TypeOnly<current.StringInterner>;
declare function use_old_InterfaceDeclaration_StringInterner(use: TypeOnly<old.StringInterner>);
use_old_InterfaceDeclaration_StringInterner(get_current_InterfaceDeclaration_StringInterner());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SucceedingTransactionState": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_SucceedingTransactionState(): TypeOnly<old.SucceedingTransactionState>;
declare function use_current_InterfaceDeclaration_SucceedingTransactionState(
	use: TypeOnly<current.SucceedingTransactionState>
);
use_current_InterfaceDeclaration_SucceedingTransactionState(get_old_InterfaceDeclaration_SucceedingTransactionState());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_SucceedingTransactionState": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_SucceedingTransactionState(): TypeOnly<current.SucceedingTransactionState>;
declare function use_old_InterfaceDeclaration_SucceedingTransactionState(use: TypeOnly<old.SucceedingTransactionState>);
use_old_InterfaceDeclaration_SucceedingTransactionState(get_current_InterfaceDeclaration_SucceedingTransactionState());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_TraitLabel": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_TraitLabel(): TypeOnly<old.TraitLabel>;
declare function use_current_TypeAliasDeclaration_TraitLabel(use: TypeOnly<current.TraitLabel>);
use_current_TypeAliasDeclaration_TraitLabel(get_old_TypeAliasDeclaration_TraitLabel());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_TraitLabel": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_TraitLabel(): TypeOnly<current.TraitLabel>;
declare function use_old_TypeAliasDeclaration_TraitLabel(use: TypeOnly<old.TraitLabel>);
use_old_TypeAliasDeclaration_TraitLabel(get_current_TypeAliasDeclaration_TraitLabel());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TraitLocation": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TraitLocation(): TypeOnly<old.TraitLocation>;
declare function use_current_InterfaceDeclaration_TraitLocation(use: TypeOnly<current.TraitLocation>);
use_current_InterfaceDeclaration_TraitLocation(get_old_InterfaceDeclaration_TraitLocation());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TraitLocation": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TraitLocation(): TypeOnly<current.TraitLocation>;
declare function use_old_InterfaceDeclaration_TraitLocation(use: TypeOnly<old.TraitLocation>);
use_old_InterfaceDeclaration_TraitLocation(get_current_InterfaceDeclaration_TraitLocation());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TraitLocationInternal": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TraitLocationInternal(): TypeOnly<old.TraitLocationInternal>;
declare function use_current_InterfaceDeclaration_TraitLocationInternal(use: TypeOnly<current.TraitLocationInternal>);
use_current_InterfaceDeclaration_TraitLocationInternal(get_old_InterfaceDeclaration_TraitLocationInternal());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TraitLocationInternal": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TraitLocationInternal(): TypeOnly<current.TraitLocationInternal>;
declare function use_old_InterfaceDeclaration_TraitLocationInternal(use: TypeOnly<old.TraitLocationInternal>);
use_old_InterfaceDeclaration_TraitLocationInternal(get_current_InterfaceDeclaration_TraitLocationInternal());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TraitLocationInternal_0_0_2": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TraitLocationInternal_0_0_2(): TypeOnly<old.TraitLocationInternal_0_0_2>;
declare function use_current_InterfaceDeclaration_TraitLocationInternal_0_0_2(
	use: TypeOnly<current.TraitLocationInternal_0_0_2>
);
use_current_InterfaceDeclaration_TraitLocationInternal_0_0_2(
	get_old_InterfaceDeclaration_TraitLocationInternal_0_0_2()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TraitLocationInternal_0_0_2": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TraitLocationInternal_0_0_2(): TypeOnly<current.TraitLocationInternal_0_0_2>;
declare function use_old_InterfaceDeclaration_TraitLocationInternal_0_0_2(
	use: TypeOnly<old.TraitLocationInternal_0_0_2>
);
use_old_InterfaceDeclaration_TraitLocationInternal_0_0_2(
	get_current_InterfaceDeclaration_TraitLocationInternal_0_0_2()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TraitMap": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TraitMap(): TypeOnly<old.TraitMap<any>>;
declare function use_current_InterfaceDeclaration_TraitMap(use: TypeOnly<current.TraitMap<any>>);
use_current_InterfaceDeclaration_TraitMap(get_old_InterfaceDeclaration_TraitMap());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TraitMap": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TraitMap(): TypeOnly<current.TraitMap<any>>;
declare function use_old_InterfaceDeclaration_TraitMap(use: TypeOnly<old.TraitMap<any>>);
use_old_InterfaceDeclaration_TraitMap(get_current_InterfaceDeclaration_TraitMap());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_TraitNodeIndex": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_TraitNodeIndex(): TypeOnly<old.TraitNodeIndex>;
declare function use_current_TypeAliasDeclaration_TraitNodeIndex(use: TypeOnly<current.TraitNodeIndex>);
use_current_TypeAliasDeclaration_TraitNodeIndex(get_old_TypeAliasDeclaration_TraitNodeIndex());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_TraitNodeIndex": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_TraitNodeIndex(): TypeOnly<current.TraitNodeIndex>;
declare function use_old_TypeAliasDeclaration_TraitNodeIndex(use: TypeOnly<old.TraitNodeIndex>);
use_old_TypeAliasDeclaration_TraitNodeIndex(get_current_TypeAliasDeclaration_TraitNodeIndex());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_Transaction": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_Transaction(): TypeOnly<old.Transaction>;
declare function use_current_ClassDeclaration_Transaction(use: TypeOnly<current.Transaction>);
use_current_ClassDeclaration_Transaction(get_old_ClassDeclaration_Transaction());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_Transaction": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_Transaction(): TypeOnly<current.Transaction>;
declare function use_old_ClassDeclaration_Transaction(use: TypeOnly<old.Transaction>);
use_old_ClassDeclaration_Transaction(get_current_ClassDeclaration_Transaction());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_TransactionEvent": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_TransactionEvent(): TypeOnly<old.TransactionEvent>;
declare function use_current_EnumDeclaration_TransactionEvent(use: TypeOnly<current.TransactionEvent>);
use_current_EnumDeclaration_TransactionEvent(get_old_EnumDeclaration_TransactionEvent());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_TransactionEvent": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_TransactionEvent(): TypeOnly<current.TransactionEvent>;
declare function use_old_EnumDeclaration_TransactionEvent(use: TypeOnly<old.TransactionEvent>);
use_old_EnumDeclaration_TransactionEvent(get_current_EnumDeclaration_TransactionEvent());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionEvents": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TransactionEvents(): TypeOnly<old.TransactionEvents>;
declare function use_current_InterfaceDeclaration_TransactionEvents(use: TypeOnly<current.TransactionEvents>);
use_current_InterfaceDeclaration_TransactionEvents(get_old_InterfaceDeclaration_TransactionEvents());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionEvents": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TransactionEvents(): TypeOnly<current.TransactionEvents>;
declare function use_old_InterfaceDeclaration_TransactionEvents(use: TypeOnly<old.TransactionEvents>);
use_old_InterfaceDeclaration_TransactionEvents(get_current_InterfaceDeclaration_TransactionEvents());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionFailure": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TransactionFailure(): TypeOnly<old.TransactionFailure>;
declare function use_current_InterfaceDeclaration_TransactionFailure(use: TypeOnly<current.TransactionFailure>);
use_current_InterfaceDeclaration_TransactionFailure(get_old_InterfaceDeclaration_TransactionFailure());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionFailure": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TransactionFailure(): TypeOnly<current.TransactionFailure>;
declare function use_old_InterfaceDeclaration_TransactionFailure(use: TypeOnly<old.TransactionFailure>);
use_old_InterfaceDeclaration_TransactionFailure(get_current_InterfaceDeclaration_TransactionFailure());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.BadPlaceFailure": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TransactionInternal_BadPlaceFailure(): TypeOnly<old.TransactionInternal.BadPlaceFailure>;
declare function use_current_InterfaceDeclaration_TransactionInternal_BadPlaceFailure(
	use: TypeOnly<current.TransactionInternal.BadPlaceFailure>
);
use_current_InterfaceDeclaration_TransactionInternal_BadPlaceFailure(
	get_old_InterfaceDeclaration_TransactionInternal_BadPlaceFailure()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.BadPlaceFailure": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TransactionInternal_BadPlaceFailure(): TypeOnly<current.TransactionInternal.BadPlaceFailure>;
declare function use_old_InterfaceDeclaration_TransactionInternal_BadPlaceFailure(
	use: TypeOnly<old.TransactionInternal.BadPlaceFailure>
);
use_old_InterfaceDeclaration_TransactionInternal_BadPlaceFailure(
	get_current_InterfaceDeclaration_TransactionInternal_BadPlaceFailure()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.BadRangeFailure": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TransactionInternal_BadRangeFailure(): TypeOnly<old.TransactionInternal.BadRangeFailure>;
declare function use_current_InterfaceDeclaration_TransactionInternal_BadRangeFailure(
	use: TypeOnly<current.TransactionInternal.BadRangeFailure>
);
use_current_InterfaceDeclaration_TransactionInternal_BadRangeFailure(
	get_old_InterfaceDeclaration_TransactionInternal_BadRangeFailure()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.BadRangeFailure": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TransactionInternal_BadRangeFailure(): TypeOnly<current.TransactionInternal.BadRangeFailure>;
declare function use_old_InterfaceDeclaration_TransactionInternal_BadRangeFailure(
	use: TypeOnly<old.TransactionInternal.BadRangeFailure>
);
use_old_InterfaceDeclaration_TransactionInternal_BadRangeFailure(
	get_current_InterfaceDeclaration_TransactionInternal_BadRangeFailure()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.ConstraintViolationFailure": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TransactionInternal_ConstraintViolationFailure(): TypeOnly<old.TransactionInternal.ConstraintViolationFailure>;
declare function use_current_InterfaceDeclaration_TransactionInternal_ConstraintViolationFailure(
	use: TypeOnly<current.TransactionInternal.ConstraintViolationFailure>
);
use_current_InterfaceDeclaration_TransactionInternal_ConstraintViolationFailure(
	get_old_InterfaceDeclaration_TransactionInternal_ConstraintViolationFailure()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.ConstraintViolationFailure": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TransactionInternal_ConstraintViolationFailure(): TypeOnly<current.TransactionInternal.ConstraintViolationFailure>;
declare function use_old_InterfaceDeclaration_TransactionInternal_ConstraintViolationFailure(
	use: TypeOnly<old.TransactionInternal.ConstraintViolationFailure>
);
use_old_InterfaceDeclaration_TransactionInternal_ConstraintViolationFailure(
	get_current_InterfaceDeclaration_TransactionInternal_ConstraintViolationFailure()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_TransactionInternal.ConstraintViolationKind": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_TransactionInternal_ConstraintViolationKind(): TypeOnly<old.TransactionInternal.ConstraintViolationKind>;
declare function use_current_EnumDeclaration_TransactionInternal_ConstraintViolationKind(
	use: TypeOnly<current.TransactionInternal.ConstraintViolationKind>
);
use_current_EnumDeclaration_TransactionInternal_ConstraintViolationKind(
	get_old_EnumDeclaration_TransactionInternal_ConstraintViolationKind()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_TransactionInternal.ConstraintViolationKind": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_TransactionInternal_ConstraintViolationKind(): TypeOnly<current.TransactionInternal.ConstraintViolationKind>;
declare function use_old_EnumDeclaration_TransactionInternal_ConstraintViolationKind(
	use: TypeOnly<old.TransactionInternal.ConstraintViolationKind>
);
use_old_EnumDeclaration_TransactionInternal_ConstraintViolationKind(
	get_current_EnumDeclaration_TransactionInternal_ConstraintViolationKind()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_TransactionInternal.ConstraintViolationResult": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_TransactionInternal_ConstraintViolationResult(): TypeOnly<old.TransactionInternal.ConstraintViolationResult>;
declare function use_current_TypeAliasDeclaration_TransactionInternal_ConstraintViolationResult(
	use: TypeOnly<current.TransactionInternal.ConstraintViolationResult>
);
use_current_TypeAliasDeclaration_TransactionInternal_ConstraintViolationResult(
	get_old_TypeAliasDeclaration_TransactionInternal_ConstraintViolationResult()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_TransactionInternal.ConstraintViolationResult": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_TransactionInternal_ConstraintViolationResult(): TypeOnly<current.TransactionInternal.ConstraintViolationResult>;
declare function use_old_TypeAliasDeclaration_TransactionInternal_ConstraintViolationResult(
	use: TypeOnly<old.TransactionInternal.ConstraintViolationResult>
);
use_old_TypeAliasDeclaration_TransactionInternal_ConstraintViolationResult(
	get_current_TypeAliasDeclaration_TransactionInternal_ConstraintViolationResult()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.DetachedSequenceIdAlreadyInUseFailure": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TransactionInternal_DetachedSequenceIdAlreadyInUseFailure(): TypeOnly<old.TransactionInternal.DetachedSequenceIdAlreadyInUseFailure>;
declare function use_current_InterfaceDeclaration_TransactionInternal_DetachedSequenceIdAlreadyInUseFailure(
	use: TypeOnly<current.TransactionInternal.DetachedSequenceIdAlreadyInUseFailure>
);
use_current_InterfaceDeclaration_TransactionInternal_DetachedSequenceIdAlreadyInUseFailure(
	get_old_InterfaceDeclaration_TransactionInternal_DetachedSequenceIdAlreadyInUseFailure()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.DetachedSequenceIdAlreadyInUseFailure": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TransactionInternal_DetachedSequenceIdAlreadyInUseFailure(): TypeOnly<current.TransactionInternal.DetachedSequenceIdAlreadyInUseFailure>;
declare function use_old_InterfaceDeclaration_TransactionInternal_DetachedSequenceIdAlreadyInUseFailure(
	use: TypeOnly<old.TransactionInternal.DetachedSequenceIdAlreadyInUseFailure>
);
use_old_InterfaceDeclaration_TransactionInternal_DetachedSequenceIdAlreadyInUseFailure(
	get_current_InterfaceDeclaration_TransactionInternal_DetachedSequenceIdAlreadyInUseFailure()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.DetachedSequenceNotFoundFailure": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TransactionInternal_DetachedSequenceNotFoundFailure(): TypeOnly<old.TransactionInternal.DetachedSequenceNotFoundFailure>;
declare function use_current_InterfaceDeclaration_TransactionInternal_DetachedSequenceNotFoundFailure(
	use: TypeOnly<current.TransactionInternal.DetachedSequenceNotFoundFailure>
);
use_current_InterfaceDeclaration_TransactionInternal_DetachedSequenceNotFoundFailure(
	get_old_InterfaceDeclaration_TransactionInternal_DetachedSequenceNotFoundFailure()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.DetachedSequenceNotFoundFailure": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TransactionInternal_DetachedSequenceNotFoundFailure(): TypeOnly<current.TransactionInternal.DetachedSequenceNotFoundFailure>;
declare function use_old_InterfaceDeclaration_TransactionInternal_DetachedSequenceNotFoundFailure(
	use: TypeOnly<old.TransactionInternal.DetachedSequenceNotFoundFailure>
);
use_old_InterfaceDeclaration_TransactionInternal_DetachedSequenceNotFoundFailure(
	get_current_InterfaceDeclaration_TransactionInternal_DetachedSequenceNotFoundFailure()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.DuplicateIdInBuildFailure": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TransactionInternal_DuplicateIdInBuildFailure(): TypeOnly<old.TransactionInternal.DuplicateIdInBuildFailure>;
declare function use_current_InterfaceDeclaration_TransactionInternal_DuplicateIdInBuildFailure(
	use: TypeOnly<current.TransactionInternal.DuplicateIdInBuildFailure>
);
use_current_InterfaceDeclaration_TransactionInternal_DuplicateIdInBuildFailure(
	get_old_InterfaceDeclaration_TransactionInternal_DuplicateIdInBuildFailure()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.DuplicateIdInBuildFailure": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TransactionInternal_DuplicateIdInBuildFailure(): TypeOnly<current.TransactionInternal.DuplicateIdInBuildFailure>;
declare function use_old_InterfaceDeclaration_TransactionInternal_DuplicateIdInBuildFailure(
	use: TypeOnly<old.TransactionInternal.DuplicateIdInBuildFailure>
);
use_old_InterfaceDeclaration_TransactionInternal_DuplicateIdInBuildFailure(
	get_current_InterfaceDeclaration_TransactionInternal_DuplicateIdInBuildFailure()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_TransactionInternal.factory": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_TransactionInternal_factory(): TypeOnly<
	typeof old.TransactionInternal.factory
>;
declare function use_current_FunctionDeclaration_TransactionInternal_factory(
	use: TypeOnly<typeof current.TransactionInternal.factory>
);
use_current_FunctionDeclaration_TransactionInternal_factory(get_old_FunctionDeclaration_TransactionInternal_factory());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_TransactionInternal.factory": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_TransactionInternal_factory(): TypeOnly<
	typeof current.TransactionInternal.factory
>;
declare function use_old_FunctionDeclaration_TransactionInternal_factory(
	use: TypeOnly<typeof old.TransactionInternal.factory>
);
use_old_FunctionDeclaration_TransactionInternal_factory(get_current_FunctionDeclaration_TransactionInternal_factory());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_TransactionInternal.Failure": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_TransactionInternal_Failure(): TypeOnly<old.TransactionInternal.Failure>;
declare function use_current_TypeAliasDeclaration_TransactionInternal_Failure(
	use: TypeOnly<current.TransactionInternal.Failure>
);
use_current_TypeAliasDeclaration_TransactionInternal_Failure(
	get_old_TypeAliasDeclaration_TransactionInternal_Failure()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_TransactionInternal.Failure": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_TransactionInternal_Failure(): TypeOnly<current.TransactionInternal.Failure>;
declare function use_old_TypeAliasDeclaration_TransactionInternal_Failure(
	use: TypeOnly<old.TransactionInternal.Failure>
);
use_old_TypeAliasDeclaration_TransactionInternal_Failure(
	get_current_TypeAliasDeclaration_TransactionInternal_Failure()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_TransactionInternal.FailureKind": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_TransactionInternal_FailureKind(): TypeOnly<old.TransactionInternal.FailureKind>;
declare function use_current_EnumDeclaration_TransactionInternal_FailureKind(
	use: TypeOnly<current.TransactionInternal.FailureKind>
);
use_current_EnumDeclaration_TransactionInternal_FailureKind(get_old_EnumDeclaration_TransactionInternal_FailureKind());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_TransactionInternal.FailureKind": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_TransactionInternal_FailureKind(): TypeOnly<current.TransactionInternal.FailureKind>;
declare function use_old_EnumDeclaration_TransactionInternal_FailureKind(
	use: TypeOnly<old.TransactionInternal.FailureKind>
);
use_old_EnumDeclaration_TransactionInternal_FailureKind(get_current_EnumDeclaration_TransactionInternal_FailureKind());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.IdAlreadyInUseFailure": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TransactionInternal_IdAlreadyInUseFailure(): TypeOnly<old.TransactionInternal.IdAlreadyInUseFailure>;
declare function use_current_InterfaceDeclaration_TransactionInternal_IdAlreadyInUseFailure(
	use: TypeOnly<current.TransactionInternal.IdAlreadyInUseFailure>
);
use_current_InterfaceDeclaration_TransactionInternal_IdAlreadyInUseFailure(
	get_old_InterfaceDeclaration_TransactionInternal_IdAlreadyInUseFailure()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.IdAlreadyInUseFailure": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TransactionInternal_IdAlreadyInUseFailure(): TypeOnly<current.TransactionInternal.IdAlreadyInUseFailure>;
declare function use_old_InterfaceDeclaration_TransactionInternal_IdAlreadyInUseFailure(
	use: TypeOnly<old.TransactionInternal.IdAlreadyInUseFailure>
);
use_old_InterfaceDeclaration_TransactionInternal_IdAlreadyInUseFailure(
	get_current_InterfaceDeclaration_TransactionInternal_IdAlreadyInUseFailure()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_TransactionInternal.Policy": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TransactionInternal_Policy(): TypeOnly<old.TransactionInternal.Policy>;
declare function use_current_ClassDeclaration_TransactionInternal_Policy(
	use: TypeOnly<current.TransactionInternal.Policy>
);
use_current_ClassDeclaration_TransactionInternal_Policy(get_old_ClassDeclaration_TransactionInternal_Policy());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_TransactionInternal.Policy": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TransactionInternal_Policy(): TypeOnly<current.TransactionInternal.Policy>;
declare function use_old_ClassDeclaration_TransactionInternal_Policy(use: TypeOnly<old.TransactionInternal.Policy>);
use_old_ClassDeclaration_TransactionInternal_Policy(get_current_ClassDeclaration_TransactionInternal_Policy());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.UnknownIdFailure": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TransactionInternal_UnknownIdFailure(): TypeOnly<old.TransactionInternal.UnknownIdFailure>;
declare function use_current_InterfaceDeclaration_TransactionInternal_UnknownIdFailure(
	use: TypeOnly<current.TransactionInternal.UnknownIdFailure>
);
use_current_InterfaceDeclaration_TransactionInternal_UnknownIdFailure(
	get_old_InterfaceDeclaration_TransactionInternal_UnknownIdFailure()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.UnknownIdFailure": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TransactionInternal_UnknownIdFailure(): TypeOnly<current.TransactionInternal.UnknownIdFailure>;
declare function use_old_InterfaceDeclaration_TransactionInternal_UnknownIdFailure(
	use: TypeOnly<old.TransactionInternal.UnknownIdFailure>
);
use_old_InterfaceDeclaration_TransactionInternal_UnknownIdFailure(
	get_current_InterfaceDeclaration_TransactionInternal_UnknownIdFailure()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.UnusedDetachedSequenceFailure": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TransactionInternal_UnusedDetachedSequenceFailure(): TypeOnly<old.TransactionInternal.UnusedDetachedSequenceFailure>;
declare function use_current_InterfaceDeclaration_TransactionInternal_UnusedDetachedSequenceFailure(
	use: TypeOnly<current.TransactionInternal.UnusedDetachedSequenceFailure>
);
use_current_InterfaceDeclaration_TransactionInternal_UnusedDetachedSequenceFailure(
	get_old_InterfaceDeclaration_TransactionInternal_UnusedDetachedSequenceFailure()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TransactionInternal.UnusedDetachedSequenceFailure": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TransactionInternal_UnusedDetachedSequenceFailure(): TypeOnly<current.TransactionInternal.UnusedDetachedSequenceFailure>;
declare function use_old_InterfaceDeclaration_TransactionInternal_UnusedDetachedSequenceFailure(
	use: TypeOnly<old.TransactionInternal.UnusedDetachedSequenceFailure>
);
use_old_InterfaceDeclaration_TransactionInternal_UnusedDetachedSequenceFailure(
	get_current_InterfaceDeclaration_TransactionInternal_UnusedDetachedSequenceFailure()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_TransactionState": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_TransactionState(): TypeOnly<old.TransactionState>;
declare function use_current_TypeAliasDeclaration_TransactionState(use: TypeOnly<current.TransactionState>);
use_current_TypeAliasDeclaration_TransactionState(get_old_TypeAliasDeclaration_TransactionState());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_TransactionState": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_TransactionState(): TypeOnly<current.TransactionState>;
declare function use_old_TypeAliasDeclaration_TransactionState(use: TypeOnly<old.TransactionState>);
use_old_TypeAliasDeclaration_TransactionState(get_current_TypeAliasDeclaration_TransactionState());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_TransactionView": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TransactionView(): TypeOnly<old.TransactionView>;
declare function use_current_ClassDeclaration_TransactionView(use: TypeOnly<current.TransactionView>);
use_current_ClassDeclaration_TransactionView(get_old_ClassDeclaration_TransactionView());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_TransactionView": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TransactionView(): TypeOnly<current.TransactionView>;
declare function use_old_ClassDeclaration_TransactionView(use: TypeOnly<old.TransactionView>);
use_old_ClassDeclaration_TransactionView(get_current_ClassDeclaration_TransactionView());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TreeNode": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TreeNode(): TypeOnly<old.TreeNode<any, any>>;
declare function use_current_InterfaceDeclaration_TreeNode(use: TypeOnly<current.TreeNode<any, any>>);
use_current_InterfaceDeclaration_TreeNode(get_old_InterfaceDeclaration_TreeNode());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TreeNode": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TreeNode(): TypeOnly<current.TreeNode<any, any>>;
declare function use_old_InterfaceDeclaration_TreeNode(use: TypeOnly<old.TreeNode<any, any>>);
use_old_InterfaceDeclaration_TreeNode(get_current_InterfaceDeclaration_TreeNode());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_TreeNodeHandle": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TreeNodeHandle(): TypeOnly<old.TreeNodeHandle>;
declare function use_current_ClassDeclaration_TreeNodeHandle(use: TypeOnly<current.TreeNodeHandle>);
use_current_ClassDeclaration_TreeNodeHandle(get_old_ClassDeclaration_TreeNodeHandle());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_TreeNodeHandle": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TreeNodeHandle(): TypeOnly<current.TreeNodeHandle>;
declare function use_old_ClassDeclaration_TreeNodeHandle(use: TypeOnly<old.TreeNodeHandle>);
use_old_ClassDeclaration_TreeNodeHandle(get_current_ClassDeclaration_TreeNodeHandle());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_TreeNodeSequence": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_TreeNodeSequence(): TypeOnly<old.TreeNodeSequence<any>>;
declare function use_current_TypeAliasDeclaration_TreeNodeSequence(use: TypeOnly<current.TreeNodeSequence<any>>);
use_current_TypeAliasDeclaration_TreeNodeSequence(get_old_TypeAliasDeclaration_TreeNodeSequence());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_TreeNodeSequence": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_TreeNodeSequence(): TypeOnly<current.TreeNodeSequence<any>>;
declare function use_old_TypeAliasDeclaration_TreeNodeSequence(use: TypeOnly<old.TreeNodeSequence<any>>);
use_old_TypeAliasDeclaration_TreeNodeSequence(get_current_TypeAliasDeclaration_TreeNodeSequence());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_TreeView": {"forwardCompat": false}
 */
declare function get_old_ClassDeclaration_TreeView(): TypeOnly<old.TreeView>;
declare function use_current_ClassDeclaration_TreeView(use: TypeOnly<current.TreeView>);
use_current_ClassDeclaration_TreeView(get_old_ClassDeclaration_TreeView());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "ClassDeclaration_TreeView": {"backCompat": false}
 */
declare function get_current_ClassDeclaration_TreeView(): TypeOnly<current.TreeView>;
declare function use_old_ClassDeclaration_TreeView(use: TypeOnly<old.TreeView>);
use_old_ClassDeclaration_TreeView(get_current_ClassDeclaration_TreeView());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TreeViewNode": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TreeViewNode(): TypeOnly<old.TreeViewNode>;
declare function use_current_InterfaceDeclaration_TreeViewNode(use: TypeOnly<current.TreeViewNode>);
use_current_InterfaceDeclaration_TreeViewNode(get_old_InterfaceDeclaration_TreeViewNode());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TreeViewNode": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TreeViewNode(): TypeOnly<current.TreeViewNode>;
declare function use_old_InterfaceDeclaration_TreeViewNode(use: TypeOnly<old.TreeViewNode>);
use_old_InterfaceDeclaration_TreeViewNode(get_current_InterfaceDeclaration_TreeViewNode());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TreeViewPlace": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TreeViewPlace(): TypeOnly<old.TreeViewPlace>;
declare function use_current_InterfaceDeclaration_TreeViewPlace(use: TypeOnly<current.TreeViewPlace>);
use_current_InterfaceDeclaration_TreeViewPlace(get_old_InterfaceDeclaration_TreeViewPlace());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TreeViewPlace": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TreeViewPlace(): TypeOnly<current.TreeViewPlace>;
declare function use_old_InterfaceDeclaration_TreeViewPlace(use: TypeOnly<old.TreeViewPlace>);
use_old_InterfaceDeclaration_TreeViewPlace(get_current_InterfaceDeclaration_TreeViewPlace());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TreeViewRange": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_TreeViewRange(): TypeOnly<old.TreeViewRange>;
declare function use_current_InterfaceDeclaration_TreeViewRange(use: TypeOnly<current.TreeViewRange>);
use_current_InterfaceDeclaration_TreeViewRange(get_old_InterfaceDeclaration_TreeViewRange());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_TreeViewRange": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_TreeViewRange(): TypeOnly<current.TreeViewRange>;
declare function use_old_InterfaceDeclaration_TreeViewRange(use: TypeOnly<old.TreeViewRange>);
use_old_InterfaceDeclaration_TreeViewRange(get_current_InterfaceDeclaration_TreeViewRange());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_useFailedSequencedEditTelemetry": {"forwardCompat": false}
 */
declare function get_old_FunctionDeclaration_useFailedSequencedEditTelemetry(): TypeOnly<
	typeof old.useFailedSequencedEditTelemetry
>;
declare function use_current_FunctionDeclaration_useFailedSequencedEditTelemetry(
	use: TypeOnly<typeof current.useFailedSequencedEditTelemetry>
);
use_current_FunctionDeclaration_useFailedSequencedEditTelemetry(
	get_old_FunctionDeclaration_useFailedSequencedEditTelemetry()
);

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "FunctionDeclaration_useFailedSequencedEditTelemetry": {"backCompat": false}
 */
declare function get_current_FunctionDeclaration_useFailedSequencedEditTelemetry(): TypeOnly<
	typeof current.useFailedSequencedEditTelemetry
>;
declare function use_old_FunctionDeclaration_useFailedSequencedEditTelemetry(
	use: TypeOnly<typeof old.useFailedSequencedEditTelemetry>
);
use_old_FunctionDeclaration_useFailedSequencedEditTelemetry(
	get_current_FunctionDeclaration_useFailedSequencedEditTelemetry()
);

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_UuidString": {"forwardCompat": false}
 */
declare function get_old_TypeAliasDeclaration_UuidString(): TypeOnly<old.UuidString>;
declare function use_current_TypeAliasDeclaration_UuidString(use: TypeOnly<current.UuidString>);
use_current_TypeAliasDeclaration_UuidString(get_old_TypeAliasDeclaration_UuidString());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "TypeAliasDeclaration_UuidString": {"backCompat": false}
 */
declare function get_current_TypeAliasDeclaration_UuidString(): TypeOnly<current.UuidString>;
declare function use_old_TypeAliasDeclaration_UuidString(use: TypeOnly<old.UuidString>);
use_old_TypeAliasDeclaration_UuidString(get_current_TypeAliasDeclaration_UuidString());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ValidEditingResult": {"forwardCompat": false}
 */
declare function get_old_InterfaceDeclaration_ValidEditingResult(): TypeOnly<old.ValidEditingResult>;
declare function use_current_InterfaceDeclaration_ValidEditingResult(use: TypeOnly<current.ValidEditingResult>);
use_current_InterfaceDeclaration_ValidEditingResult(get_old_InterfaceDeclaration_ValidEditingResult());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "InterfaceDeclaration_ValidEditingResult": {"backCompat": false}
 */
declare function get_current_InterfaceDeclaration_ValidEditingResult(): TypeOnly<current.ValidEditingResult>;
declare function use_old_InterfaceDeclaration_ValidEditingResult(use: TypeOnly<old.ValidEditingResult>);
use_old_InterfaceDeclaration_ValidEditingResult(get_current_InterfaceDeclaration_ValidEditingResult());

/*
 * Validate forward compat by using old type in place of current type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_WriteFormat": {"forwardCompat": false}
 */
declare function get_old_EnumDeclaration_WriteFormat(): TypeOnly<old.WriteFormat>;
declare function use_current_EnumDeclaration_WriteFormat(use: TypeOnly<current.WriteFormat>);
use_current_EnumDeclaration_WriteFormat(get_old_EnumDeclaration_WriteFormat());

/*
 * Validate back compat by using current type in place of old type
 * If breaking change required, add in package.json under typeValidation.broken:
 * "EnumDeclaration_WriteFormat": {"backCompat": false}
 */
declare function get_current_EnumDeclaration_WriteFormat(): TypeOnly<current.WriteFormat>;
declare function use_old_EnumDeclaration_WriteFormat(use: TypeOnly<old.WriteFormat>);
use_old_EnumDeclaration_WriteFormat(get_current_EnumDeclaration_WriteFormat());
