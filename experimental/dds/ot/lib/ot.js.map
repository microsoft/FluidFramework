{"version":3,"file":"ot.js","sourceRoot":"","sources":["../src/ot.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { bufferToString } from \"@fluidframework/common-utils\";\nimport { IFluidSerializer } from \"@fluidframework/core-interfaces\";\n\nimport {\n    FileMode,\n    ISequencedDocumentMessage,\n    ITree,\n    TreeEntry,\n} from \"@fluidframework/protocol-definitions\";\nimport {\n    IChannelAttributes,\n    IFluidDataStoreRuntime,\n    IChannelStorageService,\n    IChannelFactory,\n    Serializable,\n} from \"@fluidframework/datastore-definitions\";\nimport { SharedObject } from \"@fluidframework/shared-object-base\";\nimport { Doc, type, JSONOp, replaceOp, insertOp, moveOp, removeOp } from \"ot-json1\";\nimport { OTFactory } from \"./factory\";\nimport { debug } from \"./debug\";\nimport { ISharedOT } from \"./interfaces\";\n\nexport class SharedOT extends SharedObject implements ISharedOT {\n    private readonly pendingOps: JSONOp[] = [];\n\n    /**\n     * Create a new shared OT\n     *\n     * @param runtime - data store runtime the new shared map belongs to\n     * @param id - optional name of the shared map\n     * @returns newly create shared map (but not attached yet)\n     */\n    public static create(runtime: IFluidDataStoreRuntime, id?: string) {\n        return runtime.createChannel(id, OTFactory.Type) as SharedOT;\n    }\n\n    /**\n     * Get a factory for SharedOT to register with the data store.\n     *\n     * @returns a factory that creates and load SharedOT\n     */\n    public static getFactory(): IChannelFactory {\n        return new OTFactory();\n    }\n\n    // eslint-disable-next-line no-null/no-null\n    private root: Doc = null;\n\n    /**\n     * Constructs a new shared OT. If the object is non-local an id and service interfaces will\n     * be provided\n     *\n     * @param runtime - data store runtime the shared map belongs to\n     * @param id - optional name of the shared map\n     */\n    constructor(id: string, runtime: IFluidDataStoreRuntime, attributes: IChannelAttributes) {\n        super(id, runtime, attributes);\n    }\n\n    public get(): Doc { return this.root; }\n\n    public insert(path: (string | number)[], value: Serializable) {\n        this.apply(insertOp(path, value as Doc));\n    }\n\n    public move(from: (string | number)[], to: (string | number)[]) {\n        this.apply(moveOp(from, to));\n    }\n\n    public remove(path: (string | number)[], value?: boolean) {\n        this.apply(removeOp(path, value));\n    }\n\n    public replace(path: (string | number)[], oldValue: Serializable, newValue: Serializable) {\n        this.apply(replaceOp(path, oldValue as Doc, newValue as Doc));\n    }\n\n    public apply(op: JSONOp) {\n        this.root = type.apply(this.root, op) as Doc;\n\n        // If we are not attached, don't submit the op.\n        if (!this.isAttached()) {\n            return;\n        }\n\n        this.pendingOps.push(op);\n        this.submitLocalMessage(op);\n    }\n\n    protected snapshotCore(serializer: IFluidSerializer): ITree {\n        const tree: ITree = {\n            entries: [\n                {\n                    mode: FileMode.File,\n                    path: \"header\",\n                    type: TreeEntry.Blob,\n                    value: {\n                        contents: serializer.stringify(this.root, this.handle),\n                        encoding: \"utf-8\",\n                    },\n                },\n            ],\n        };\n\n        return tree;\n    }\n\n    protected async loadCore(storage: IChannelStorageService): Promise<void> {\n        const blob = await storage.readBlob(\"header\");\n        const rawContent = bufferToString(blob, \"utf8\");\n        this.root = this.runtime.IFluidSerializer.parse(rawContent);\n    }\n\n    protected initializeLocalCore() {\n        this.root = {};\n    }\n\n    protected registerCore() {}\n\n    protected onDisconnect() {\n        debug(`OT ${this.id} is now disconnected`);\n    }\n\n    protected processCore(message: ISequencedDocumentMessage, local: boolean) {\n        if (local) {\n            this.pendingOps.shift();\n        } else {\n            let remoteOp = message.contents;\n\n            for (const localPendingOp of this.pendingOps) {\n                remoteOp = type.transformNoConflict(remoteOp, localPendingOp, \"right\");\n            }\n\n            this.root = type.apply(this.root, remoteOp) as Doc;\n        }\n    }\n\n    protected applyStashedOp() {\n        throw new Error(\"not implemented\");\n    }\n}\n"]}