/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "@fluid-experimental/property-properties-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ArrayProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ArrayProperty():
    TypeOnly<old.ArrayProperty>;
declare function use_current_ClassDeclaration_ArrayProperty(
    use: TypeOnly<current.ArrayProperty>);
use_current_ClassDeclaration_ArrayProperty(
    get_old_ClassDeclaration_ArrayProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ArrayProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ArrayProperty():
    TypeOnly<current.ArrayProperty>;
declare function use_old_ClassDeclaration_ArrayProperty(
    use: TypeOnly<old.ArrayProperty>);
use_old_ClassDeclaration_ArrayProperty(
    get_current_ClassDeclaration_ArrayProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BaseProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_BaseProperty():
    TypeOnly<old.BaseProperty>;
declare function use_current_ClassDeclaration_BaseProperty(
    use: TypeOnly<current.BaseProperty>);
use_current_ClassDeclaration_BaseProperty(
    get_old_ClassDeclaration_BaseProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BaseProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_BaseProperty():
    TypeOnly<current.BaseProperty>;
declare function use_old_ClassDeclaration_BaseProperty(
    use: TypeOnly<old.BaseProperty>);
use_old_ClassDeclaration_BaseProperty(
    get_current_ClassDeclaration_BaseProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ContainerProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ContainerProperty():
    TypeOnly<old.ContainerProperty>;
declare function use_current_ClassDeclaration_ContainerProperty(
    use: TypeOnly<current.ContainerProperty>);
use_current_ClassDeclaration_ContainerProperty(
    get_old_ClassDeclaration_ContainerProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ContainerProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ContainerProperty():
    TypeOnly<current.ContainerProperty>;
declare function use_old_ClassDeclaration_ContainerProperty(
    use: TypeOnly<old.ContainerProperty>);
use_old_ClassDeclaration_ContainerProperty(
    get_current_ClassDeclaration_ContainerProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_enableValidations": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_enableValidations():
    TypeOnly<typeof old.enableValidations>;
declare function use_current_FunctionDeclaration_enableValidations(
    use: TypeOnly<typeof current.enableValidations>);
use_current_FunctionDeclaration_enableValidations(
    get_old_FunctionDeclaration_enableValidations());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_enableValidations": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_enableValidations():
    TypeOnly<typeof current.enableValidations>;
declare function use_old_FunctionDeclaration_enableValidations(
    use: TypeOnly<typeof old.enableValidations>);
use_old_FunctionDeclaration_enableValidations(
    get_current_FunctionDeclaration_enableValidations());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EnumArrayProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_EnumArrayProperty():
    TypeOnly<old.EnumArrayProperty>;
declare function use_current_ClassDeclaration_EnumArrayProperty(
    use: TypeOnly<current.EnumArrayProperty>);
use_current_ClassDeclaration_EnumArrayProperty(
    get_old_ClassDeclaration_EnumArrayProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EnumArrayProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_EnumArrayProperty():
    TypeOnly<current.EnumArrayProperty>;
declare function use_old_ClassDeclaration_EnumArrayProperty(
    use: TypeOnly<old.EnumArrayProperty>);
use_old_ClassDeclaration_EnumArrayProperty(
    get_current_ClassDeclaration_EnumArrayProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EnumProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_EnumProperty():
    TypeOnly<old.EnumProperty>;
declare function use_current_ClassDeclaration_EnumProperty(
    use: TypeOnly<current.EnumProperty>);
use_current_ClassDeclaration_EnumProperty(
    get_old_ClassDeclaration_EnumProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EnumProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_EnumProperty():
    TypeOnly<current.EnumProperty>;
declare function use_old_ClassDeclaration_EnumProperty(
    use: TypeOnly<old.EnumProperty>);
use_old_ClassDeclaration_EnumProperty(
    get_current_ClassDeclaration_EnumProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Int64Property": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Int64Property():
    TypeOnly<old.Int64Property>;
declare function use_current_ClassDeclaration_Int64Property(
    use: TypeOnly<current.Int64Property>);
use_current_ClassDeclaration_Int64Property(
    get_old_ClassDeclaration_Int64Property());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Int64Property": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Int64Property():
    TypeOnly<current.Int64Property>;
declare function use_old_ClassDeclaration_Int64Property(
    use: TypeOnly<old.Int64Property>);
use_old_ClassDeclaration_Int64Property(
    get_current_ClassDeclaration_Int64Property());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MapProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MapProperty():
    TypeOnly<old.MapProperty>;
declare function use_current_ClassDeclaration_MapProperty(
    use: TypeOnly<current.MapProperty>);
use_current_ClassDeclaration_MapProperty(
    get_old_ClassDeclaration_MapProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MapProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MapProperty():
    TypeOnly<current.MapProperty>;
declare function use_old_ClassDeclaration_MapProperty(
    use: TypeOnly<old.MapProperty>);
use_old_ClassDeclaration_MapProperty(
    get_current_ClassDeclaration_MapProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_NodeProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_NodeProperty():
    TypeOnly<old.NodeProperty>;
declare function use_current_ClassDeclaration_NodeProperty(
    use: TypeOnly<current.NodeProperty>);
use_current_ClassDeclaration_NodeProperty(
    get_old_ClassDeclaration_NodeProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_NodeProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_NodeProperty():
    TypeOnly<current.NodeProperty>;
declare function use_old_ClassDeclaration_NodeProperty(
    use: TypeOnly<old.NodeProperty>);
use_old_ClassDeclaration_NodeProperty(
    get_current_ClassDeclaration_NodeProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_PropertyFactorySingleton": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_PropertyFactorySingleton():
    TypeOnly<typeof old.PropertyFactorySingleton>;
declare function use_current_VariableDeclaration_PropertyFactorySingleton(
    use: TypeOnly<typeof current.PropertyFactorySingleton>);
use_current_VariableDeclaration_PropertyFactorySingleton(
    get_old_VariableDeclaration_PropertyFactorySingleton());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_PropertyFactorySingleton": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_PropertyFactorySingleton():
    TypeOnly<typeof current.PropertyFactorySingleton>;
declare function use_old_VariableDeclaration_PropertyFactorySingleton(
    use: TypeOnly<typeof old.PropertyFactorySingleton>);
use_old_VariableDeclaration_PropertyFactorySingleton(
    get_current_VariableDeclaration_PropertyFactorySingleton());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PropertyUtils": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_PropertyUtils():
    TypeOnly<old.PropertyUtils>;
declare function use_current_ClassDeclaration_PropertyUtils(
    use: TypeOnly<current.PropertyUtils>);
use_current_ClassDeclaration_PropertyUtils(
    get_old_ClassDeclaration_PropertyUtils());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PropertyUtils": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_PropertyUtils():
    TypeOnly<current.PropertyUtils>;
declare function use_old_ClassDeclaration_PropertyUtils(
    use: TypeOnly<old.PropertyUtils>);
use_old_ClassDeclaration_PropertyUtils(
    get_current_ClassDeclaration_PropertyUtils());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ReferenceArrayProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ReferenceArrayProperty():
    TypeOnly<old.ReferenceArrayProperty>;
declare function use_current_ClassDeclaration_ReferenceArrayProperty(
    use: TypeOnly<current.ReferenceArrayProperty>);
use_current_ClassDeclaration_ReferenceArrayProperty(
    get_old_ClassDeclaration_ReferenceArrayProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ReferenceArrayProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ReferenceArrayProperty():
    TypeOnly<current.ReferenceArrayProperty>;
declare function use_old_ClassDeclaration_ReferenceArrayProperty(
    use: TypeOnly<old.ReferenceArrayProperty>);
use_old_ClassDeclaration_ReferenceArrayProperty(
    get_current_ClassDeclaration_ReferenceArrayProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ReferenceMapProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ReferenceMapProperty():
    TypeOnly<old.ReferenceMapProperty>;
declare function use_current_ClassDeclaration_ReferenceMapProperty(
    use: TypeOnly<current.ReferenceMapProperty>);
use_current_ClassDeclaration_ReferenceMapProperty(
    get_old_ClassDeclaration_ReferenceMapProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ReferenceMapProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ReferenceMapProperty():
    TypeOnly<current.ReferenceMapProperty>;
declare function use_old_ClassDeclaration_ReferenceMapProperty(
    use: TypeOnly<old.ReferenceMapProperty>);
use_old_ClassDeclaration_ReferenceMapProperty(
    get_current_ClassDeclaration_ReferenceMapProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ReferenceProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ReferenceProperty():
    TypeOnly<old.ReferenceProperty>;
declare function use_current_ClassDeclaration_ReferenceProperty(
    use: TypeOnly<current.ReferenceProperty>);
use_current_ClassDeclaration_ReferenceProperty(
    get_old_ClassDeclaration_ReferenceProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ReferenceProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ReferenceProperty():
    TypeOnly<current.ReferenceProperty>;
declare function use_old_ClassDeclaration_ReferenceProperty(
    use: TypeOnly<old.ReferenceProperty>);
use_old_ClassDeclaration_ReferenceProperty(
    get_current_ClassDeclaration_ReferenceProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SetProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SetProperty():
    TypeOnly<old.SetProperty>;
declare function use_current_ClassDeclaration_SetProperty(
    use: TypeOnly<current.SetProperty>);
use_current_ClassDeclaration_SetProperty(
    get_old_ClassDeclaration_SetProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SetProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SetProperty():
    TypeOnly<current.SetProperty>;
declare function use_old_ClassDeclaration_SetProperty(
    use: TypeOnly<old.SetProperty>);
use_old_ClassDeclaration_SetProperty(
    get_current_ClassDeclaration_SetProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_StringProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_StringProperty():
    TypeOnly<old.StringProperty>;
declare function use_current_ClassDeclaration_StringProperty(
    use: TypeOnly<current.StringProperty>);
use_current_ClassDeclaration_StringProperty(
    get_old_ClassDeclaration_StringProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_StringProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_StringProperty():
    TypeOnly<current.StringProperty>;
declare function use_old_ClassDeclaration_StringProperty(
    use: TypeOnly<old.StringProperty>);
use_old_ClassDeclaration_StringProperty(
    get_current_ClassDeclaration_StringProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Uint64Property": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Uint64Property():
    TypeOnly<old.Uint64Property>;
declare function use_current_ClassDeclaration_Uint64Property(
    use: TypeOnly<current.Uint64Property>);
use_current_ClassDeclaration_Uint64Property(
    get_old_ClassDeclaration_Uint64Property());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Uint64Property": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Uint64Property():
    TypeOnly<current.Uint64Property>;
declare function use_old_ClassDeclaration_Uint64Property(
    use: TypeOnly<old.Uint64Property>);
use_old_ClassDeclaration_Uint64Property(
    get_current_ClassDeclaration_Uint64Property());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ValueArrayProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ValueArrayProperty():
    TypeOnly<old.ValueArrayProperty>;
declare function use_current_ClassDeclaration_ValueArrayProperty(
    use: TypeOnly<current.ValueArrayProperty>);
use_current_ClassDeclaration_ValueArrayProperty(
    get_old_ClassDeclaration_ValueArrayProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ValueArrayProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ValueArrayProperty():
    TypeOnly<current.ValueArrayProperty>;
declare function use_old_ClassDeclaration_ValueArrayProperty(
    use: TypeOnly<old.ValueArrayProperty>);
use_old_ClassDeclaration_ValueArrayProperty(
    get_current_ClassDeclaration_ValueArrayProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ValueMapProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ValueMapProperty():
    TypeOnly<old.ValueMapProperty>;
declare function use_current_ClassDeclaration_ValueMapProperty(
    use: TypeOnly<current.ValueMapProperty>);
use_current_ClassDeclaration_ValueMapProperty(
    get_old_ClassDeclaration_ValueMapProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ValueMapProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ValueMapProperty():
    TypeOnly<current.ValueMapProperty>;
declare function use_old_ClassDeclaration_ValueMapProperty(
    use: TypeOnly<old.ValueMapProperty>);
use_old_ClassDeclaration_ValueMapProperty(
    get_current_ClassDeclaration_ValueMapProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ValueProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ValueProperty():
    TypeOnly<old.ValueProperty>;
declare function use_current_ClassDeclaration_ValueProperty(
    use: TypeOnly<current.ValueProperty>);
use_current_ClassDeclaration_ValueProperty(
    get_old_ClassDeclaration_ValueProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ValueProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ValueProperty():
    TypeOnly<current.ValueProperty>;
declare function use_old_ClassDeclaration_ValueProperty(
    use: TypeOnly<old.ValueProperty>);
use_old_ClassDeclaration_ValueProperty(
    get_current_ClassDeclaration_ValueProperty());
