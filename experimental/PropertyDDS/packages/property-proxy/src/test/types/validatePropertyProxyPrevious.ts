/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "@fluid-experimental/property-proxy-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BaseProxifiedProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_BaseProxifiedProperty():
    TypeOnly<old.BaseProxifiedProperty>;
declare function use_current_ClassDeclaration_BaseProxifiedProperty(
    use: TypeOnly<current.BaseProxifiedProperty>);
use_current_ClassDeclaration_BaseProxifiedProperty(
    get_old_ClassDeclaration_BaseProxifiedProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BaseProxifiedProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_BaseProxifiedProperty():
    TypeOnly<current.BaseProxifiedProperty>;
declare function use_old_ClassDeclaration_BaseProxifiedProperty(
    use: TypeOnly<old.BaseProxifiedProperty>);
use_old_ClassDeclaration_BaseProxifiedProperty(
    get_current_ClassDeclaration_BaseProxifiedProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CollectionTypes": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_CollectionTypes():
    TypeOnly<old.CollectionTypes>;
declare function use_current_TypeAliasDeclaration_CollectionTypes(
    use: TypeOnly<current.CollectionTypes>);
use_current_TypeAliasDeclaration_CollectionTypes(
    get_old_TypeAliasDeclaration_CollectionTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_CollectionTypes": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_CollectionTypes():
    TypeOnly<current.CollectionTypes>;
declare function use_old_TypeAliasDeclaration_CollectionTypes(
    use: TypeOnly<old.CollectionTypes>);
use_old_TypeAliasDeclaration_CollectionTypes(
    get_current_TypeAliasDeclaration_CollectionTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GenericProxify": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_GenericProxify():
    TypeOnly<old.GenericProxify<any>>;
declare function use_current_TypeAliasDeclaration_GenericProxify(
    use: TypeOnly<current.GenericProxify<any>>);
use_current_TypeAliasDeclaration_GenericProxify(
    get_old_TypeAliasDeclaration_GenericProxify());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_GenericProxify": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_GenericProxify():
    TypeOnly<current.GenericProxify<any>>;
declare function use_old_TypeAliasDeclaration_GenericProxify(
    use: TypeOnly<old.GenericProxify<any>>);
use_old_TypeAliasDeclaration_GenericProxify(
    get_current_TypeAliasDeclaration_GenericProxify());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IParentAndPathOfReferencedProperty": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IParentAndPathOfReferencedProperty():
    TypeOnly<old.IParentAndPathOfReferencedProperty>;
declare function use_current_InterfaceDeclaration_IParentAndPathOfReferencedProperty(
    use: TypeOnly<current.IParentAndPathOfReferencedProperty>);
use_current_InterfaceDeclaration_IParentAndPathOfReferencedProperty(
    get_old_InterfaceDeclaration_IParentAndPathOfReferencedProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IParentAndPathOfReferencedProperty": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IParentAndPathOfReferencedProperty():
    TypeOnly<current.IParentAndPathOfReferencedProperty>;
declare function use_old_InterfaceDeclaration_IParentAndPathOfReferencedProperty(
    use: TypeOnly<old.IParentAndPathOfReferencedProperty>);
use_old_InterfaceDeclaration_IParentAndPathOfReferencedProperty(
    get_current_InterfaceDeclaration_IParentAndPathOfReferencedProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_PrimitiveTypes": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_PrimitiveTypes():
    TypeOnly<old.PrimitiveTypes>;
declare function use_current_TypeAliasDeclaration_PrimitiveTypes(
    use: TypeOnly<current.PrimitiveTypes>);
use_current_TypeAliasDeclaration_PrimitiveTypes(
    get_old_TypeAliasDeclaration_PrimitiveTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_PrimitiveTypes": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_PrimitiveTypes():
    TypeOnly<current.PrimitiveTypes>;
declare function use_old_TypeAliasDeclaration_PrimitiveTypes(
    use: TypeOnly<old.PrimitiveTypes>);
use_old_TypeAliasDeclaration_PrimitiveTypes(
    get_current_TypeAliasDeclaration_PrimitiveTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_PropertyTypes": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_PropertyTypes():
    TypeOnly<old.PropertyTypes>;
declare function use_current_TypeAliasDeclaration_PropertyTypes(
    use: TypeOnly<current.PropertyTypes>);
use_current_TypeAliasDeclaration_PropertyTypes(
    get_old_TypeAliasDeclaration_PropertyTypes());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_PropertyTypes": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_PropertyTypes():
    TypeOnly<current.PropertyTypes>;
declare function use_old_TypeAliasDeclaration_PropertyTypes(
    use: TypeOnly<old.PropertyTypes>);
use_old_TypeAliasDeclaration_PropertyTypes(
    get_current_TypeAliasDeclaration_PropertyTypes());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ProxifiedArrayProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ProxifiedArrayProperty():
    TypeOnly<old.ProxifiedArrayProperty>;
declare function use_current_ClassDeclaration_ProxifiedArrayProperty(
    use: TypeOnly<current.ProxifiedArrayProperty>);
use_current_ClassDeclaration_ProxifiedArrayProperty(
    get_old_ClassDeclaration_ProxifiedArrayProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ProxifiedArrayProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ProxifiedArrayProperty():
    TypeOnly<current.ProxifiedArrayProperty>;
declare function use_old_ClassDeclaration_ProxifiedArrayProperty(
    use: TypeOnly<old.ProxifiedArrayProperty>);
use_old_ClassDeclaration_ProxifiedArrayProperty(
    get_current_ClassDeclaration_ProxifiedArrayProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ProxifiedMapProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ProxifiedMapProperty():
    TypeOnly<old.ProxifiedMapProperty>;
declare function use_current_ClassDeclaration_ProxifiedMapProperty(
    use: TypeOnly<current.ProxifiedMapProperty>);
use_current_ClassDeclaration_ProxifiedMapProperty(
    get_old_ClassDeclaration_ProxifiedMapProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ProxifiedMapProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ProxifiedMapProperty():
    TypeOnly<current.ProxifiedMapProperty>;
declare function use_old_ClassDeclaration_ProxifiedMapProperty(
    use: TypeOnly<old.ProxifiedMapProperty>);
use_old_ClassDeclaration_ProxifiedMapProperty(
    get_current_ClassDeclaration_ProxifiedMapProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ProxifiedPropertyValueArray": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ProxifiedPropertyValueArray():
    TypeOnly<old.ProxifiedPropertyValueArray>;
declare function use_current_ClassDeclaration_ProxifiedPropertyValueArray(
    use: TypeOnly<current.ProxifiedPropertyValueArray>);
use_current_ClassDeclaration_ProxifiedPropertyValueArray(
    get_old_ClassDeclaration_ProxifiedPropertyValueArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ProxifiedPropertyValueArray": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ProxifiedPropertyValueArray():
    TypeOnly<current.ProxifiedPropertyValueArray>;
declare function use_old_ClassDeclaration_ProxifiedPropertyValueArray(
    use: TypeOnly<old.ProxifiedPropertyValueArray>);
use_old_ClassDeclaration_ProxifiedPropertyValueArray(
    get_current_ClassDeclaration_ProxifiedPropertyValueArray());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ProxifiedSetProperty": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ProxifiedSetProperty():
    TypeOnly<old.ProxifiedSetProperty>;
declare function use_current_ClassDeclaration_ProxifiedSetProperty(
    use: TypeOnly<current.ProxifiedSetProperty>);
use_current_ClassDeclaration_ProxifiedSetProperty(
    get_old_ClassDeclaration_ProxifiedSetProperty());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ProxifiedSetProperty": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ProxifiedSetProperty():
    TypeOnly<current.ProxifiedSetProperty>;
declare function use_old_ClassDeclaration_ProxifiedSetProperty(
    use: TypeOnly<old.ProxifiedSetProperty>);
use_old_ClassDeclaration_ProxifiedSetProperty(
    get_current_ClassDeclaration_ProxifiedSetProperty());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_proxySymbol": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_proxySymbol():
    TypeOnly<typeof old.proxySymbol>;
declare function use_current_VariableDeclaration_proxySymbol(
    use: TypeOnly<typeof current.proxySymbol>);
use_current_VariableDeclaration_proxySymbol(
    get_old_VariableDeclaration_proxySymbol());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_proxySymbol": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_proxySymbol():
    TypeOnly<typeof current.proxySymbol>;
declare function use_old_VariableDeclaration_proxySymbol(
    use: TypeOnly<typeof old.proxySymbol>);
use_old_VariableDeclaration_proxySymbol(
    get_current_VariableDeclaration_proxySymbol());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ProxyType": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ProxyType():
    TypeOnly<old.ProxyType<any>>;
declare function use_current_TypeAliasDeclaration_ProxyType(
    use: TypeOnly<current.ProxyType<any>>);
use_current_TypeAliasDeclaration_ProxyType(
    get_old_TypeAliasDeclaration_ProxyType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ProxyType": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ProxyType():
    TypeOnly<current.ProxyType<any>>;
declare function use_old_TypeAliasDeclaration_ProxyType(
    use: TypeOnly<old.ProxyType<any>>);
use_old_TypeAliasDeclaration_ProxyType(
    get_current_TypeAliasDeclaration_ProxyType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ReferenceType": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ReferenceType():
    TypeOnly<old.ReferenceType>;
declare function use_current_TypeAliasDeclaration_ReferenceType(
    use: TypeOnly<current.ReferenceType>);
use_current_TypeAliasDeclaration_ReferenceType(
    get_old_TypeAliasDeclaration_ReferenceType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ReferenceType": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ReferenceType():
    TypeOnly<current.ReferenceType>;
declare function use_old_TypeAliasDeclaration_ReferenceType(
    use: TypeOnly<old.ReferenceType>);
use_old_TypeAliasDeclaration_ReferenceType(
    get_current_TypeAliasDeclaration_ReferenceType());
