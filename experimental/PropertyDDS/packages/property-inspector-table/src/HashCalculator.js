/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
import base64js from 'base64-js';

/**
 * @fileoverview Utility class to compute an hash for a given set of variables
 * using the murmur3 hash (see https://code.google.com/p/smhasher/)
 *
 * This is a reimplementation of the original C++ code in JavaScript. The original
 * code is licensed under a MIT license.
 */

/**
 * Helper class to store the array buffers needed for the hash computation.
 *
 * TODO: should we cache these classes to avoid unnecessary reallocation
 *       of these buffers. Is it worth the effort?
 * @constructor
 */
var HashBuffer = function() {
  // This is the internal array buffer we are going to use for conversions
  this.hashBuffer = new ArrayBuffer(32);

  this.dataView = new DataView(this.hashBuffer);
  this.Uint8HashArray = new Uint8Array(this.hashBuffer, 0, 32);
  this.Uint32HashArray = new Uint32Array(this.hashBuffer, 0, 8);

  this.pos = 0;
};

/**
 * Shifts the buffers forward by 16 bytes
 */
HashBuffer.prototype.shiftBuffers = function() {
  this.Uint32HashArray[0] = this.Uint32HashArray[4];
  this.Uint32HashArray[1] = this.Uint32HashArray[5];
  this.Uint32HashArray[2] = this.Uint32HashArray[6];
  this.Uint32HashArray[3] = this.Uint32HashArray[7];
  this.Uint32HashArray[4] = 0;
  this.Uint32HashArray[5] = 0;
  this.Uint32HashArray[6] = 0;
  this.Uint32HashArray[7] = 0;
  this.pos -= 16;
};

// If available, we use the browser imul function, otherwise we emulate it
// Emulation code is from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
// License: public domain, according to https://developer.mozilla.org/en-US/docs/MDN/About#Copyrights_and_licenses:
//   Code samples added on or after August 20, 2010 are in the public domain.
//   No licensing notice is necessary, but if you need one, you can use:
//   "Any copyright is dedicated to the Public Domain.
//    http://creativecommons.org/publicdomain/zero/1.0/".
var imul = Math.imul || function(a, b) {
  var ah = (a >>> 16) & 0xffff;
  var al = a & 0xffff;
  var bh = (b >>> 16) & 0xffff;
  var bl = b & 0xffff;
  // the shift by 0 fixes the sign on the high part
  // the final |0 converts the unsigned value into a signed value
  return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
};

// Helper functions for the hash computation
/**
 * ROT function required for the hash computation
 *
 * @param {number} x - 32 bit integer
 * @param {number} r - amount to shift
 * @return {number} Rotated 32-bit integer.
 */
var rotl32 = function(x, r) {
  return (((x << r) >>> 0) | (x >>> (32 - r))) >>> 0;
};

/**
 * Mixing function for the finalization
 * @param {number} h - 32 bit integer
 * @return {number} The scrambled 32-bit integer.
 */
var fmix32 = function(h) {
  h = (h ^ (h >>> 16)) >>> 0;
  h = imul(h, 0x85ebca6b) >>> 0;
  h = (h ^ (h >>> 13)) >>> 0;
  h = imul(h, 0xc2b2ae35) >>> 0;
  h = (h ^ (h >>> 16)) >>> 0;

  return h;
};

// Constants
var c1 = 0x239b961b;
var c2 = 0xab0e9789;
var c3 = 0x38b34ae5;
var c4 = 0xa1e38b93;

/**
 * Helper class which computes a Murmur3 hash for binary data. The user
 * can successively push data in different binary types into the hash
 * computation function and will then get a hash computed over these fields.
 *
 * NOTE: By default JavaScript uses big-endian byte order. So the hashes
 *       generated by this class might correspond to those generated natively
 *       on a little-endian architecture.
 *
 * @param {number} [in_seed = 1] - Seed value used for the hash computation
 * @constructor
 * @alias property-inspector.HashCalculator
 * @private
 */
export const HashCalculator = function(in_seed = 1) {
  // Initialize the hash computation with the seed value
  this._h1 = in_seed;
  this._h2 = in_seed;
  this._h3 = in_seed;
  this._h4 = in_seed;
  this.length = 0;
  this.finalized = false;

  this.hashBuffer = new HashBuffer();
};

/**
 * Pushes a single unsigned integer with 16 bits into the hash computation
 *
 * @param {number} in_value - The value to push
 */
HashCalculator.prototype.pushUint16 = function(in_value) {
  this.hashBuffer.dataView.setUint16(this.hashBuffer.pos, in_value);
  this.hashBuffer.pos += 2;

  if (this.hashBuffer.pos >= 16) {
    this._computeHashFor16ByteBlock();
  }
};

/**
 * Pushes a string into the hash computation
 *
 * @param {string} in_string - The value to push
 */
HashCalculator.prototype.pushString = function(in_string) {

  // Push each character individually. We have to use uin16 here, as
  // JavaScript strings are UTF16
  for (var i = 0; i < in_string.length; i++) {
    this.pushUint16(in_string.charCodeAt(i));
  }
};

/**
 * The type to use when pushing values
 * @enum
 */
HashCalculator.Type = {};

/* eslint-disable no-multi-spaces */
/** Signed integer with 8 bits */
HashCalculator.Type.Int8    = 0;
/** Signed integer with 16 bits */
HashCalculator.Type.Int16   = 1;
/** Signed integer with 32 bits */
HashCalculator.Type.Int32   = 2;
/** Unsigned integer with 8 bits */
HashCalculator.Type.Uint8   = 3;
/** Unsigned integer with 16 bits */
HashCalculator.Type.Uint16  = 4;
/** Unsigned integer with 32 bits */
HashCalculator.Type.Uint32  = 5;
/** Floating point value with 32 bits */
HashCalculator.Type.Float32 = 6;
/** Floating point value with 64 bits */
HashCalculator.Type.Float64 = 7;
/* eslint-enable no-multi-spaces */

/**
 * @return {string} the computed Hash
 * Note: after calling this function you no longer may push more data!
 */
HashCalculator.prototype.getHash = function() {
  if (!this.finalized) {
    this._finalizeHash();
  }

  // Convert the hash to a string
  return uint32x4ToGUID([this._h1, this._h2, this._h3, this._h4]);
};

/**
 * Computes the murmur3 hash for a block of 16 bytes
 * @private
 */
HashCalculator.prototype._computeHashFor16ByteBlock = function() {
  var k1 = this.hashBuffer.Uint32HashArray[0];
  var k2 = this.hashBuffer.Uint32HashArray[1];
  var k3 = this.hashBuffer.Uint32HashArray[2];
  var k4 = this.hashBuffer.Uint32HashArray[3];
  this.hashBuffer.shiftBuffers();

  k1 = imul(k1, c1) >>> 0; k1 = rotl32(k1, 15); k1 = imul(k1, c2) >>> 0; this._h1 = (this._h1 ^ k1) >>> 0;
  this._h1 = rotl32(this._h1, 19);
  this._h1 = (this._h1 + this._h2) >>> 0;
  this._h1 = ((imul(this._h1, 5) >>> 0) + 0x561ccd1b) >>> 0;

  k2 = imul(k2, c2) >>> 0; k2 = rotl32(k2, 16); k2 = imul(k2, c3) >>> 0; this._h2 = (this._h2 ^ k2) >>> 0;
  this._h2 = rotl32(this._h2, 17);
  this._h2 = (this._h2 + this._h3) >>> 0;
  this._h2 = ((imul(this._h2, 5) >>> 0) + 0x0bcaa747) >>> 0;

  k3 = imul(k3, c3) >>> 0; k3 = rotl32(k3, 17); k3 = imul(k3, c4) >>> 0; this._h3 = (this._h3 ^ k3) >>> 0;
  this._h3 = rotl32(this._h3, 15);
  this._h3 = (this._h3 + this._h4) >>> 0;
  this._h3 = ((imul(this._h3, 5) >>> 0) + 0x96cd1c35) >>> 0;

  k4 = imul(k4, c4) >>> 0; k4 = rotl32(k4, 18); k4 = imul(k4, c1) >>> 0; this._h4 = (this._h4 ^ k4) >>> 0;
  this._h4 = rotl32(this._h4, 13);
  this._h4 = (this._h4 + this._h1) >>> 0;
  this._h4 = ((imul(this._h4, 5) >>> 0) + 0x32ac3b17) >>> 0;

  this.length += 16;
};

/**
 * Finalizes the hash computation
 * @private
 */
HashCalculator.prototype._finalizeHash = function() {
  var k1 = 0;
  var k2 = 0;
  var k3 = 0;
  var k4 = 0;

  // Compute the hash for the remaining bytes in the buffer
  var buffer = this.hashBuffer.Uint8HashArray;
  /* eslint-disable no-fallthrough, no-multi-spaces */  // Allows cases to fallthrough without complaints.
  switch (this.hashBuffer.pos) {

    case 15: k4 = (k4 ^ (buffer[14] << 16)) >>> 0;
    case 14: k4 = (k4 ^ (buffer[13] << 8)) >>> 0;
    case 13: k4 = (k4 ^ (buffer[12] << 0)) >>> 0;
      k4 = imul(k4, c4) >>> 0;
      k4 = rotl32(k4, 18);
      k4 = imul(k4, c1) >>> 0;
      this._h4 = (this._h4 ^ k4) >>> 0;

    case 12: k3 = (k3 ^ (buffer[11] << 24)) >>> 0;
    case 11: k3 = (k3 ^ (buffer[10] << 16)) >>> 0;
    case 10: k3 = (k3 ^ (buffer[ 9] << 8)) >>> 0;
    case  9: k3 = (k3 ^ (buffer[ 8] << 0)) >>> 0;
      k3 = imul(k3, c3) >>> 0;
      k3 = rotl32(k3, 17);
      k3 = imul(k3, c4) >>> 0;
      this._h3 = (this._h3 ^ k3) >>> 0;

    case  8: k2 = (k2 ^ (buffer[ 7] << 24)) >>> 0;
    case  7: k2 = (k2 ^ (buffer[ 6] << 16)) >>> 0;
    case  6: k2 = (k2 ^ (buffer[ 5] << 8)) >>> 0;
    case  5: k2 = (k2 ^ (buffer[ 4] << 0)) >>> 0;
      k2 = imul(k2, c2) >>> 0;
      k2 = rotl32(k2, 16);
      k2 = imul(k2, c3) >>> 0;
      this._h2 = (this._h2 ^ k2) >>> 0;

    case  4: k1 = (k1 ^ (buffer[ 3] << 24)) >>> 0;
    case  3: k1 = (k1 ^ (buffer[ 2] << 16)) >>> 0;
    case  2: k1 = (k1 ^ (buffer[ 1] << 8)) >>> 0;
    case  1: k1 = (k1 ^ (buffer[ 0] << 0)) >>> 0;
      k1 = imul(k1, c1) >>> 0;
      k1 = rotl32(k1, 15);
      k1 = imul(k1, c2) >>> 0;
      this._h1 = (this._h1 ^ k1) >>> 0;
      break;
    case  0:
      // Bug fix for previously unhandled condition
      break;

    default:
      throw new Error('_finalizeHash: We should never get into the default case.');
  }
  /* eslint-enable no-fallthrough, no-multi-spaces */

  // Perform the finalization
  var len = this.length + this.hashBuffer.pos;
  this._h1 = (this._h1 ^ len) >>> 0;
  this._h2 = (this._h2 ^ len) >>> 0;
  this._h3 = (this._h3 ^ len) >>> 0;
  this._h4 = (this._h4 ^ len) >>> 0;

  this._h1 = (this._h1 + this._h2) >>> 0;
  this._h1 = (this._h1 + this._h3) >>> 0;
  this._h1 = (this._h1 + this._h4) >>> 0;
  this._h2 = (this._h2 + this._h1) >>> 0;
  this._h3 = (this._h3 + this._h1) >>> 0;
  this._h4 = (this._h4 + this._h1) >>> 0;

  this._h1 = fmix32(this._h1);
  this._h2 = fmix32(this._h2);
  this._h3 = fmix32(this._h3);
  this._h4 = fmix32(this._h4);

  this._h1 = (this._h1 + this._h2) >>> 0;
  this._h1 = (this._h1 + this._h3) >>> 0;
  this._h1 = (this._h1 + this._h4) >>> 0;

  this._h2 = (this._h2 + this._h1) >>> 0;
  this._h3 = (this._h3 + this._h1) >>> 0;
  this._h4 = (this._h4 + this._h1) >>> 0;

  this.finalized = true;
};

var toUrlBase64 = function(base64) {
  return base64.replace(/\+/g, '-').replace(/\//g, '_').split('=')[0];
};

var uint32x4ToGUID = function(in_guidArray) {
  const intArray = new Uint32Array(in_guidArray);
  const byteArray = new Uint8Array(intArray.buffer);
  const base64guid = base64js.fromByteArray(byteArray);
  // return url-friendly base64
  return toUrlBase64(base64guid);
};
