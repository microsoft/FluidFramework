/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "@fluid-experimental/property-inspector-table-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_addDataForm": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_addDataForm():
    TypeOnly<typeof old.addDataForm>;
declare function use_current_VariableDeclaration_addDataForm(
    use: TypeOnly<typeof current.addDataForm>);
use_current_VariableDeclaration_addDataForm(
    get_old_VariableDeclaration_addDataForm());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_addDataForm": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_addDataForm():
    TypeOnly<typeof current.addDataForm>;
declare function use_old_VariableDeclaration_addDataForm(
    use: TypeOnly<typeof old.addDataForm>);
use_old_VariableDeclaration_addDataForm(
    get_current_VariableDeclaration_addDataForm());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_collectionChildTableRow": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_collectionChildTableRow():
    TypeOnly<typeof old.collectionChildTableRow>;
declare function use_current_VariableDeclaration_collectionChildTableRow(
    use: TypeOnly<typeof current.collectionChildTableRow>);
use_current_VariableDeclaration_collectionChildTableRow(
    get_old_VariableDeclaration_collectionChildTableRow());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_collectionChildTableRow": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_collectionChildTableRow():
    TypeOnly<typeof current.collectionChildTableRow>;
declare function use_old_VariableDeclaration_collectionChildTableRow(
    use: TypeOnly<typeof old.collectionChildTableRow>);
use_old_VariableDeclaration_collectionChildTableRow(
    get_current_VariableDeclaration_collectionChildTableRow());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ColumnRendererType": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ColumnRendererType():
    TypeOnly<old.ColumnRendererType>;
declare function use_current_InterfaceDeclaration_ColumnRendererType(
    use: TypeOnly<current.ColumnRendererType>);
use_current_InterfaceDeclaration_ColumnRendererType(
    get_old_InterfaceDeclaration_ColumnRendererType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ColumnRendererType": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ColumnRendererType():
    TypeOnly<current.ColumnRendererType>;
declare function use_old_InterfaceDeclaration_ColumnRendererType(
    use: TypeOnly<old.ColumnRendererType>);
use_old_InterfaceDeclaration_ColumnRendererType(
    get_current_InterfaceDeclaration_ColumnRendererType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_CustomChip": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_CustomChip():
    TypeOnly<typeof old.CustomChip>;
declare function use_current_VariableDeclaration_CustomChip(
    use: TypeOnly<typeof current.CustomChip>);
use_current_VariableDeclaration_CustomChip(
    get_old_VariableDeclaration_CustomChip());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_CustomChip": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_CustomChip():
    TypeOnly<typeof current.CustomChip>;
declare function use_old_VariableDeclaration_CustomChip(
    use: TypeOnly<typeof old.CustomChip>);
use_old_VariableDeclaration_CustomChip(
    get_current_VariableDeclaration_CustomChip());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultInspectorTableChildGetter": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_defaultInspectorTableChildGetter():
    TypeOnly<typeof old.defaultInspectorTableChildGetter>;
declare function use_current_VariableDeclaration_defaultInspectorTableChildGetter(
    use: TypeOnly<typeof current.defaultInspectorTableChildGetter>);
use_current_VariableDeclaration_defaultInspectorTableChildGetter(
    get_old_VariableDeclaration_defaultInspectorTableChildGetter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultInspectorTableChildGetter": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_defaultInspectorTableChildGetter():
    TypeOnly<typeof current.defaultInspectorTableChildGetter>;
declare function use_old_VariableDeclaration_defaultInspectorTableChildGetter(
    use: TypeOnly<typeof old.defaultInspectorTableChildGetter>);
use_old_VariableDeclaration_defaultInspectorTableChildGetter(
    get_current_VariableDeclaration_defaultInspectorTableChildGetter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultInspectorTableDataGetter": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_defaultInspectorTableDataGetter():
    TypeOnly<typeof old.defaultInspectorTableDataGetter>;
declare function use_current_VariableDeclaration_defaultInspectorTableDataGetter(
    use: TypeOnly<typeof current.defaultInspectorTableDataGetter>);
use_current_VariableDeclaration_defaultInspectorTableDataGetter(
    get_old_VariableDeclaration_defaultInspectorTableDataGetter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultInspectorTableDataGetter": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_defaultInspectorTableDataGetter():
    TypeOnly<typeof current.defaultInspectorTableDataGetter>;
declare function use_old_VariableDeclaration_defaultInspectorTableDataGetter(
    use: TypeOnly<typeof old.defaultInspectorTableDataGetter>);
use_old_VariableDeclaration_defaultInspectorTableDataGetter(
    get_current_VariableDeclaration_defaultInspectorTableDataGetter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultInspectorTableNameGetter": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_defaultInspectorTableNameGetter():
    TypeOnly<typeof old.defaultInspectorTableNameGetter>;
declare function use_current_VariableDeclaration_defaultInspectorTableNameGetter(
    use: TypeOnly<typeof current.defaultInspectorTableNameGetter>);
use_current_VariableDeclaration_defaultInspectorTableNameGetter(
    get_old_VariableDeclaration_defaultInspectorTableNameGetter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultInspectorTableNameGetter": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_defaultInspectorTableNameGetter():
    TypeOnly<typeof current.defaultInspectorTableNameGetter>;
declare function use_old_VariableDeclaration_defaultInspectorTableNameGetter(
    use: TypeOnly<typeof old.defaultInspectorTableNameGetter>);
use_old_VariableDeclaration_defaultInspectorTableNameGetter(
    get_current_VariableDeclaration_defaultInspectorTableNameGetter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_dummyChild": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_dummyChild():
    TypeOnly<typeof old.dummyChild>;
declare function use_current_VariableDeclaration_dummyChild(
    use: TypeOnly<typeof current.dummyChild>);
use_current_VariableDeclaration_dummyChild(
    get_old_VariableDeclaration_dummyChild());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_dummyChild": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_dummyChild():
    TypeOnly<typeof current.dummyChild>;
declare function use_old_VariableDeclaration_dummyChild(
    use: TypeOnly<typeof old.dummyChild>);
use_old_VariableDeclaration_dummyChild(
    get_current_VariableDeclaration_dummyChild());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_EditReferenceView": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_EditReferenceView():
    TypeOnly<typeof old.EditReferenceView>;
declare function use_current_VariableDeclaration_EditReferenceView(
    use: TypeOnly<typeof current.EditReferenceView>);
use_current_VariableDeclaration_EditReferenceView(
    get_old_VariableDeclaration_EditReferenceView());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_EditReferenceView": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_EditReferenceView():
    TypeOnly<typeof current.EditReferenceView>;
declare function use_old_VariableDeclaration_EditReferenceView(
    use: TypeOnly<typeof old.EditReferenceView>);
use_old_VariableDeclaration_EditReferenceView(
    get_current_VariableDeclaration_EditReferenceView());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_expandAll": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_expandAll():
    TypeOnly<typeof old.expandAll>;
declare function use_current_VariableDeclaration_expandAll(
    use: TypeOnly<typeof current.expandAll>);
use_current_VariableDeclaration_expandAll(
    get_old_VariableDeclaration_expandAll());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_expandAll": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_expandAll():
    TypeOnly<typeof current.expandAll>;
declare function use_old_VariableDeclaration_expandAll(
    use: TypeOnly<typeof old.expandAll>);
use_old_VariableDeclaration_expandAll(
    get_current_VariableDeclaration_expandAll());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_fetchRegisteredTemplates": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_fetchRegisteredTemplates():
    TypeOnly<typeof old.fetchRegisteredTemplates>;
declare function use_current_VariableDeclaration_fetchRegisteredTemplates(
    use: TypeOnly<typeof current.fetchRegisteredTemplates>);
use_current_VariableDeclaration_fetchRegisteredTemplates(
    get_old_VariableDeclaration_fetchRegisteredTemplates());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_fetchRegisteredTemplates": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_fetchRegisteredTemplates():
    TypeOnly<typeof current.fetchRegisteredTemplates>;
declare function use_old_VariableDeclaration_fetchRegisteredTemplates(
    use: TypeOnly<typeof old.fetchRegisteredTemplates>);
use_old_VariableDeclaration_fetchRegisteredTemplates(
    get_current_VariableDeclaration_fetchRegisteredTemplates());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_fillExpanded": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_fillExpanded():
    TypeOnly<typeof old.fillExpanded>;
declare function use_current_VariableDeclaration_fillExpanded(
    use: TypeOnly<typeof current.fillExpanded>);
use_current_VariableDeclaration_fillExpanded(
    get_old_VariableDeclaration_fillExpanded());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_fillExpanded": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_fillExpanded():
    TypeOnly<typeof current.fillExpanded>;
declare function use_old_VariableDeclaration_fillExpanded(
    use: TypeOnly<typeof old.fillExpanded>);
use_old_VariableDeclaration_fillExpanded(
    get_current_VariableDeclaration_fillExpanded());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_generateForm": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_generateForm():
    TypeOnly<typeof old.generateForm>;
declare function use_current_VariableDeclaration_generateForm(
    use: TypeOnly<typeof current.generateForm>);
use_current_VariableDeclaration_generateForm(
    get_old_VariableDeclaration_generateForm());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_generateForm": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_generateForm():
    TypeOnly<typeof current.generateForm>;
declare function use_old_VariableDeclaration_generateForm(
    use: TypeOnly<typeof old.generateForm>);
use_old_VariableDeclaration_generateForm(
    get_current_VariableDeclaration_generateForm());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getCollectionTypeid": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getCollectionTypeid():
    TypeOnly<typeof old.getCollectionTypeid>;
declare function use_current_VariableDeclaration_getCollectionTypeid(
    use: TypeOnly<typeof current.getCollectionTypeid>);
use_current_VariableDeclaration_getCollectionTypeid(
    get_old_VariableDeclaration_getCollectionTypeid());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getCollectionTypeid": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getCollectionTypeid():
    TypeOnly<typeof current.getCollectionTypeid>;
declare function use_old_VariableDeclaration_getCollectionTypeid(
    use: TypeOnly<typeof old.getCollectionTypeid>);
use_old_VariableDeclaration_getCollectionTypeid(
    get_current_VariableDeclaration_getCollectionTypeid());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getDefaultInspectorTableIcons": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getDefaultInspectorTableIcons():
    TypeOnly<typeof old.getDefaultInspectorTableIcons>;
declare function use_current_VariableDeclaration_getDefaultInspectorTableIcons(
    use: TypeOnly<typeof current.getDefaultInspectorTableIcons>);
use_current_VariableDeclaration_getDefaultInspectorTableIcons(
    get_old_VariableDeclaration_getDefaultInspectorTableIcons());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getDefaultInspectorTableIcons": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getDefaultInspectorTableIcons():
    TypeOnly<typeof current.getDefaultInspectorTableIcons>;
declare function use_old_VariableDeclaration_getDefaultInspectorTableIcons(
    use: TypeOnly<typeof old.getDefaultInspectorTableIcons>);
use_old_VariableDeclaration_getDefaultInspectorTableIcons(
    get_current_VariableDeclaration_getDefaultInspectorTableIcons());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getDefaultPropertyTableProps": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getDefaultPropertyTableProps():
    TypeOnly<typeof old.getDefaultPropertyTableProps>;
declare function use_current_VariableDeclaration_getDefaultPropertyTableProps(
    use: TypeOnly<typeof current.getDefaultPropertyTableProps>);
use_current_VariableDeclaration_getDefaultPropertyTableProps(
    get_old_VariableDeclaration_getDefaultPropertyTableProps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getDefaultPropertyTableProps": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getDefaultPropertyTableProps():
    TypeOnly<typeof current.getDefaultPropertyTableProps>;
declare function use_old_VariableDeclaration_getDefaultPropertyTableProps(
    use: TypeOnly<typeof old.getDefaultPropertyTableProps>);
use_old_VariableDeclaration_getDefaultPropertyTableProps(
    get_current_VariableDeclaration_getDefaultPropertyTableProps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getIconFromTypeId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getIconFromTypeId():
    TypeOnly<typeof old.getIconFromTypeId>;
declare function use_current_VariableDeclaration_getIconFromTypeId(
    use: TypeOnly<typeof current.getIconFromTypeId>);
use_current_VariableDeclaration_getIconFromTypeId(
    get_old_VariableDeclaration_getIconFromTypeId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getIconFromTypeId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getIconFromTypeId():
    TypeOnly<typeof current.getIconFromTypeId>;
declare function use_old_VariableDeclaration_getIconFromTypeId(
    use: TypeOnly<typeof old.getIconFromTypeId>);
use_old_VariableDeclaration_getIconFromTypeId(
    get_current_VariableDeclaration_getIconFromTypeId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getPropertyValue": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getPropertyValue():
    TypeOnly<typeof old.getPropertyValue>;
declare function use_current_VariableDeclaration_getPropertyValue(
    use: TypeOnly<typeof current.getPropertyValue>);
use_current_VariableDeclaration_getPropertyValue(
    get_old_VariableDeclaration_getPropertyValue());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getPropertyValue": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getPropertyValue():
    TypeOnly<typeof current.getPropertyValue>;
declare function use_old_VariableDeclaration_getPropertyValue(
    use: TypeOnly<typeof old.getPropertyValue>);
use_old_VariableDeclaration_getPropertyValue(
    get_current_VariableDeclaration_getPropertyValue());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getReferenceValue": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getReferenceValue():
    TypeOnly<typeof old.getReferenceValue>;
declare function use_current_VariableDeclaration_getReferenceValue(
    use: TypeOnly<typeof current.getReferenceValue>);
use_current_VariableDeclaration_getReferenceValue(
    get_old_VariableDeclaration_getReferenceValue());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getReferenceValue": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getReferenceValue():
    TypeOnly<typeof current.getReferenceValue>;
declare function use_old_VariableDeclaration_getReferenceValue(
    use: TypeOnly<typeof old.getReferenceValue>);
use_old_VariableDeclaration_getReferenceValue(
    get_current_VariableDeclaration_getReferenceValue());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_handlePropertyDataCreation": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_handlePropertyDataCreation():
    TypeOnly<typeof old.handlePropertyDataCreation>;
declare function use_current_VariableDeclaration_handlePropertyDataCreation(
    use: TypeOnly<typeof current.handlePropertyDataCreation>);
use_current_VariableDeclaration_handlePropertyDataCreation(
    get_old_VariableDeclaration_handlePropertyDataCreation());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_handlePropertyDataCreation": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_handlePropertyDataCreation():
    TypeOnly<typeof current.handlePropertyDataCreation>;
declare function use_old_VariableDeclaration_handlePropertyDataCreation(
    use: TypeOnly<typeof old.handlePropertyDataCreation>);
use_old_VariableDeclaration_handlePropertyDataCreation(
    get_current_VariableDeclaration_handlePropertyDataCreation());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_handlePropertyDataCreationOptionGeneration": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_handlePropertyDataCreationOptionGeneration():
    TypeOnly<typeof old.handlePropertyDataCreationOptionGeneration>;
declare function use_current_VariableDeclaration_handlePropertyDataCreationOptionGeneration(
    use: TypeOnly<typeof current.handlePropertyDataCreationOptionGeneration>);
use_current_VariableDeclaration_handlePropertyDataCreationOptionGeneration(
    get_old_VariableDeclaration_handlePropertyDataCreationOptionGeneration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_handlePropertyDataCreationOptionGeneration": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_handlePropertyDataCreationOptionGeneration():
    TypeOnly<typeof current.handlePropertyDataCreationOptionGeneration>;
declare function use_old_VariableDeclaration_handlePropertyDataCreationOptionGeneration(
    use: TypeOnly<typeof old.handlePropertyDataCreationOptionGeneration>);
use_old_VariableDeclaration_handlePropertyDataCreationOptionGeneration(
    get_current_VariableDeclaration_handlePropertyDataCreationOptionGeneration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_handleReferencePropertyEdit": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_handleReferencePropertyEdit():
    TypeOnly<typeof old.handleReferencePropertyEdit>;
declare function use_current_VariableDeclaration_handleReferencePropertyEdit(
    use: TypeOnly<typeof current.handleReferencePropertyEdit>);
use_current_VariableDeclaration_handleReferencePropertyEdit(
    get_old_VariableDeclaration_handleReferencePropertyEdit());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_handleReferencePropertyEdit": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_handleReferencePropertyEdit():
    TypeOnly<typeof current.handleReferencePropertyEdit>;
declare function use_old_VariableDeclaration_handleReferencePropertyEdit(
    use: TypeOnly<typeof old.handleReferencePropertyEdit>);
use_old_VariableDeclaration_handleReferencePropertyEdit(
    get_current_VariableDeclaration_handleReferencePropertyEdit());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IColumns": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IColumns():
    TypeOnly<old.IColumns>;
declare function use_current_InterfaceDeclaration_IColumns(
    use: TypeOnly<current.IColumns>);
use_current_InterfaceDeclaration_IColumns(
    get_old_InterfaceDeclaration_IColumns());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IColumns": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IColumns():
    TypeOnly<current.IColumns>;
declare function use_old_InterfaceDeclaration_IColumns(
    use: TypeOnly<old.IColumns>);
use_old_InterfaceDeclaration_IColumns(
    get_current_InterfaceDeclaration_IColumns());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDataCreationOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDataCreationOptions():
    TypeOnly<old.IDataCreationOptions>;
declare function use_current_InterfaceDeclaration_IDataCreationOptions(
    use: TypeOnly<current.IDataCreationOptions>);
use_current_InterfaceDeclaration_IDataCreationOptions(
    get_old_InterfaceDeclaration_IDataCreationOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDataCreationOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDataCreationOptions():
    TypeOnly<current.IDataCreationOptions>;
declare function use_old_InterfaceDeclaration_IDataCreationOptions(
    use: TypeOnly<old.IDataCreationOptions>);
use_old_InterfaceDeclaration_IDataCreationOptions(
    get_current_InterfaceDeclaration_IDataCreationOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDataGetterParameter": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDataGetterParameter():
    TypeOnly<old.IDataGetterParameter>;
declare function use_current_InterfaceDeclaration_IDataGetterParameter(
    use: TypeOnly<current.IDataGetterParameter>);
use_current_InterfaceDeclaration_IDataGetterParameter(
    get_old_InterfaceDeclaration_IDataGetterParameter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDataGetterParameter": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDataGetterParameter():
    TypeOnly<current.IDataGetterParameter>;
declare function use_old_InterfaceDeclaration_IDataGetterParameter(
    use: TypeOnly<old.IDataGetterParameter>);
use_old_InterfaceDeclaration_IDataGetterParameter(
    get_current_InterfaceDeclaration_IDataGetterParameter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_idSeparator": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_idSeparator():
    TypeOnly<typeof old.idSeparator>;
declare function use_current_VariableDeclaration_idSeparator(
    use: TypeOnly<typeof current.idSeparator>);
use_current_VariableDeclaration_idSeparator(
    get_old_VariableDeclaration_idSeparator());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_idSeparator": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_idSeparator():
    TypeOnly<typeof current.idSeparator>;
declare function use_old_VariableDeclaration_idSeparator(
    use: TypeOnly<typeof old.idSeparator>);
use_old_VariableDeclaration_idSeparator(
    get_current_VariableDeclaration_idSeparator());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEditableValueCellProps": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IEditableValueCellProps():
    TypeOnly<old.IEditableValueCellProps>;
declare function use_current_InterfaceDeclaration_IEditableValueCellProps(
    use: TypeOnly<current.IEditableValueCellProps>);
use_current_InterfaceDeclaration_IEditableValueCellProps(
    get_old_InterfaceDeclaration_IEditableValueCellProps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEditableValueCellProps": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IEditableValueCellProps():
    TypeOnly<current.IEditableValueCellProps>;
declare function use_old_InterfaceDeclaration_IEditableValueCellProps(
    use: TypeOnly<old.IEditableValueCellProps>);
use_old_InterfaceDeclaration_IEditableValueCellProps(
    get_current_InterfaceDeclaration_IEditableValueCellProps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IExpandedMap": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IExpandedMap():
    TypeOnly<old.IExpandedMap>;
declare function use_current_InterfaceDeclaration_IExpandedMap(
    use: TypeOnly<current.IExpandedMap>);
use_current_InterfaceDeclaration_IExpandedMap(
    get_old_InterfaceDeclaration_IExpandedMap());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IExpandedMap": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IExpandedMap():
    TypeOnly<current.IExpandedMap>;
declare function use_old_InterfaceDeclaration_IExpandedMap(
    use: TypeOnly<old.IExpandedMap>);
use_old_InterfaceDeclaration_IExpandedMap(
    get_current_InterfaceDeclaration_IExpandedMap());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IInspectorColumnsKeys": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IInspectorColumnsKeys():
    TypeOnly<old.IInspectorColumnsKeys>;
declare function use_current_TypeAliasDeclaration_IInspectorColumnsKeys(
    use: TypeOnly<current.IInspectorColumnsKeys>);
use_current_TypeAliasDeclaration_IInspectorColumnsKeys(
    get_old_TypeAliasDeclaration_IInspectorColumnsKeys());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IInspectorColumnsKeys": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IInspectorColumnsKeys():
    TypeOnly<current.IInspectorColumnsKeys>;
declare function use_old_TypeAliasDeclaration_IInspectorColumnsKeys(
    use: TypeOnly<old.IInspectorColumnsKeys>);
use_old_TypeAliasDeclaration_IInspectorColumnsKeys(
    get_current_TypeAliasDeclaration_IInspectorColumnsKeys());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorRow": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInspectorRow():
    TypeOnly<old.IInspectorRow>;
declare function use_current_InterfaceDeclaration_IInspectorRow(
    use: TypeOnly<current.IInspectorRow>);
use_current_InterfaceDeclaration_IInspectorRow(
    get_old_InterfaceDeclaration_IInspectorRow());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorRow": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInspectorRow():
    TypeOnly<current.IInspectorRow>;
declare function use_old_InterfaceDeclaration_IInspectorRow(
    use: TypeOnly<old.IInspectorRow>);
use_old_InterfaceDeclaration_IInspectorRow(
    get_current_InterfaceDeclaration_IInspectorRow());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IInspectorSearchAbortHandler": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IInspectorSearchAbortHandler():
    TypeOnly<old.IInspectorSearchAbortHandler>;
declare function use_current_TypeAliasDeclaration_IInspectorSearchAbortHandler(
    use: TypeOnly<current.IInspectorSearchAbortHandler>);
use_current_TypeAliasDeclaration_IInspectorSearchAbortHandler(
    get_old_TypeAliasDeclaration_IInspectorSearchAbortHandler());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IInspectorSearchAbortHandler": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IInspectorSearchAbortHandler():
    TypeOnly<current.IInspectorSearchAbortHandler>;
declare function use_old_TypeAliasDeclaration_IInspectorSearchAbortHandler(
    use: TypeOnly<old.IInspectorSearchAbortHandler>);
use_old_TypeAliasDeclaration_IInspectorSearchAbortHandler(
    get_current_TypeAliasDeclaration_IInspectorSearchAbortHandler());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IInspectorSearchCallback": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IInspectorSearchCallback():
    TypeOnly<old.IInspectorSearchCallback>;
declare function use_current_TypeAliasDeclaration_IInspectorSearchCallback(
    use: TypeOnly<current.IInspectorSearchCallback>);
use_current_TypeAliasDeclaration_IInspectorSearchCallback(
    get_old_TypeAliasDeclaration_IInspectorSearchCallback());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IInspectorSearchCallback": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IInspectorSearchCallback():
    TypeOnly<current.IInspectorSearchCallback>;
declare function use_old_TypeAliasDeclaration_IInspectorSearchCallback(
    use: TypeOnly<old.IInspectorSearchCallback>);
use_old_TypeAliasDeclaration_IInspectorSearchCallback(
    get_current_TypeAliasDeclaration_IInspectorSearchCallback());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorSearchControls": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInspectorSearchControls():
    TypeOnly<old.IInspectorSearchControls>;
declare function use_current_InterfaceDeclaration_IInspectorSearchControls(
    use: TypeOnly<current.IInspectorSearchControls>);
use_current_InterfaceDeclaration_IInspectorSearchControls(
    get_old_InterfaceDeclaration_IInspectorSearchControls());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorSearchControls": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInspectorSearchControls():
    TypeOnly<current.IInspectorSearchControls>;
declare function use_old_InterfaceDeclaration_IInspectorSearchControls(
    use: TypeOnly<old.IInspectorSearchControls>);
use_old_InterfaceDeclaration_IInspectorSearchControls(
    get_current_InterfaceDeclaration_IInspectorSearchControls());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorSearchMatch": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInspectorSearchMatch():
    TypeOnly<old.IInspectorSearchMatch>;
declare function use_current_InterfaceDeclaration_IInspectorSearchMatch(
    use: TypeOnly<current.IInspectorSearchMatch>);
use_current_InterfaceDeclaration_IInspectorSearchMatch(
    get_old_InterfaceDeclaration_IInspectorSearchMatch());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorSearchMatch": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInspectorSearchMatch():
    TypeOnly<current.IInspectorSearchMatch>;
declare function use_old_InterfaceDeclaration_IInspectorSearchMatch(
    use: TypeOnly<old.IInspectorSearchMatch>);
use_old_InterfaceDeclaration_IInspectorSearchMatch(
    get_current_InterfaceDeclaration_IInspectorSearchMatch());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorSearchMatchMap": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInspectorSearchMatchMap():
    TypeOnly<old.IInspectorSearchMatchMap>;
declare function use_current_InterfaceDeclaration_IInspectorSearchMatchMap(
    use: TypeOnly<current.IInspectorSearchMatchMap>);
use_current_InterfaceDeclaration_IInspectorSearchMatchMap(
    get_old_InterfaceDeclaration_IInspectorSearchMatchMap());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorSearchMatchMap": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInspectorSearchMatchMap():
    TypeOnly<current.IInspectorSearchMatchMap>;
declare function use_old_InterfaceDeclaration_IInspectorSearchMatchMap(
    use: TypeOnly<old.IInspectorSearchMatchMap>);
use_old_InterfaceDeclaration_IInspectorSearchMatchMap(
    get_current_InterfaceDeclaration_IInspectorSearchMatchMap());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorSearchState": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInspectorSearchState():
    TypeOnly<old.IInspectorSearchState>;
declare function use_current_InterfaceDeclaration_IInspectorSearchState(
    use: TypeOnly<current.IInspectorSearchState>);
use_current_InterfaceDeclaration_IInspectorSearchState(
    get_old_InterfaceDeclaration_IInspectorSearchState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorSearchState": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInspectorSearchState():
    TypeOnly<current.IInspectorSearchState>;
declare function use_old_InterfaceDeclaration_IInspectorSearchState(
    use: TypeOnly<old.IInspectorSearchState>);
use_old_InterfaceDeclaration_IInspectorSearchState(
    get_current_InterfaceDeclaration_IInspectorSearchState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorTableProps": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInspectorTableProps():
    TypeOnly<old.IInspectorTableProps>;
declare function use_current_InterfaceDeclaration_IInspectorTableProps(
    use: TypeOnly<current.IInspectorTableProps>);
use_current_InterfaceDeclaration_IInspectorTableProps(
    get_old_InterfaceDeclaration_IInspectorTableProps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorTableProps": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInspectorTableProps():
    TypeOnly<current.IInspectorTableProps>;
declare function use_old_InterfaceDeclaration_IInspectorTableProps(
    use: TypeOnly<old.IInspectorTableProps>);
use_old_InterfaceDeclaration_IInspectorTableProps(
    get_current_InterfaceDeclaration_IInspectorTableProps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorTableState": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInspectorTableState():
    TypeOnly<old.IInspectorTableState>;
declare function use_current_InterfaceDeclaration_IInspectorTableState(
    use: TypeOnly<current.IInspectorTableState>);
use_current_InterfaceDeclaration_IInspectorTableState(
    get_old_InterfaceDeclaration_IInspectorTableState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorTableState": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInspectorTableState():
    TypeOnly<current.IInspectorTableState>;
declare function use_old_InterfaceDeclaration_IInspectorTableState(
    use: TypeOnly<old.IInspectorTableState>);
use_old_InterfaceDeclaration_IInspectorTableState(
    get_current_InterfaceDeclaration_IInspectorTableState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPropertyToTableRowOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPropertyToTableRowOptions():
    TypeOnly<old.IPropertyToTableRowOptions>;
declare function use_current_InterfaceDeclaration_IPropertyToTableRowOptions(
    use: TypeOnly<current.IPropertyToTableRowOptions>);
use_current_InterfaceDeclaration_IPropertyToTableRowOptions(
    get_old_InterfaceDeclaration_IPropertyToTableRowOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPropertyToTableRowOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPropertyToTableRowOptions():
    TypeOnly<current.IPropertyToTableRowOptions>;
declare function use_old_InterfaceDeclaration_IPropertyToTableRowOptions(
    use: TypeOnly<old.IPropertyToTableRowOptions>);
use_old_InterfaceDeclaration_IPropertyToTableRowOptions(
    get_current_InterfaceDeclaration_IPropertyToTableRowOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRowData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRowData():
    TypeOnly<old.IRowData>;
declare function use_current_InterfaceDeclaration_IRowData(
    use: TypeOnly<current.IRowData>);
use_current_InterfaceDeclaration_IRowData(
    get_old_InterfaceDeclaration_IRowData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRowData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRowData():
    TypeOnly<current.IRowData>;
declare function use_old_InterfaceDeclaration_IRowData(
    use: TypeOnly<old.IRowData>);
use_old_InterfaceDeclaration_IRowData(
    get_current_InterfaceDeclaration_IRowData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISanitizer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISanitizer():
    TypeOnly<old.ISanitizer>;
declare function use_current_InterfaceDeclaration_ISanitizer(
    use: TypeOnly<current.ISanitizer>);
use_current_InterfaceDeclaration_ISanitizer(
    get_old_InterfaceDeclaration_ISanitizer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISanitizer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISanitizer():
    TypeOnly<current.ISanitizer>;
declare function use_old_InterfaceDeclaration_ISanitizer(
    use: TypeOnly<old.ISanitizer>);
use_old_InterfaceDeclaration_ISanitizer(
    get_current_InterfaceDeclaration_ISanitizer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IShowNextResultResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IShowNextResultResult():
    TypeOnly<old.IShowNextResultResult>;
declare function use_current_InterfaceDeclaration_IShowNextResultResult(
    use: TypeOnly<current.IShowNextResultResult>);
use_current_InterfaceDeclaration_IShowNextResultResult(
    get_old_InterfaceDeclaration_IShowNextResultResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IShowNextResultResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IShowNextResultResult():
    TypeOnly<current.IShowNextResultResult>;
declare function use_old_InterfaceDeclaration_IShowNextResultResult(
    use: TypeOnly<old.IShowNextResultResult>);
use_old_InterfaceDeclaration_IShowNextResultResult(
    get_current_InterfaceDeclaration_IShowNextResultResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isPrimitive": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_isPrimitive():
    TypeOnly<typeof old.isPrimitive>;
declare function use_current_VariableDeclaration_isPrimitive(
    use: TypeOnly<typeof current.isPrimitive>);
use_current_VariableDeclaration_isPrimitive(
    get_old_VariableDeclaration_isPrimitive());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_isPrimitive": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_isPrimitive():
    TypeOnly<typeof current.isPrimitive>;
declare function use_old_VariableDeclaration_isPrimitive(
    use: TypeOnly<typeof old.isPrimitive>);
use_old_VariableDeclaration_isPrimitive(
    get_current_VariableDeclaration_isPrimitive());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IToTableRowsOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IToTableRowsOptions():
    TypeOnly<old.IToTableRowsOptions>;
declare function use_current_InterfaceDeclaration_IToTableRowsOptions(
    use: TypeOnly<current.IToTableRowsOptions>);
use_current_InterfaceDeclaration_IToTableRowsOptions(
    get_old_InterfaceDeclaration_IToTableRowsOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IToTableRowsOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IToTableRowsOptions():
    TypeOnly<current.IToTableRowsOptions>;
declare function use_old_InterfaceDeclaration_IToTableRowsOptions(
    use: TypeOnly<old.IToTableRowsOptions>);
use_old_InterfaceDeclaration_IToTableRowsOptions(
    get_current_InterfaceDeclaration_IToTableRowsOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IToTableRowsProps": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IToTableRowsProps():
    TypeOnly<old.IToTableRowsProps>;
declare function use_current_TypeAliasDeclaration_IToTableRowsProps(
    use: TypeOnly<current.IToTableRowsProps>);
use_current_TypeAliasDeclaration_IToTableRowsProps(
    get_old_TypeAliasDeclaration_IToTableRowsProps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IToTableRowsProps": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IToTableRowsProps():
    TypeOnly<current.IToTableRowsProps>;
declare function use_old_TypeAliasDeclaration_IToTableRowsProps(
    use: TypeOnly<old.IToTableRowsProps>);
use_old_TypeAliasDeclaration_IToTableRowsProps(
    get_current_TypeAliasDeclaration_IToTableRowsProps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ModalConsumer": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_ModalConsumer():
    TypeOnly<typeof old.ModalConsumer>;
declare function use_current_VariableDeclaration_ModalConsumer(
    use: TypeOnly<typeof current.ModalConsumer>);
use_current_VariableDeclaration_ModalConsumer(
    get_old_VariableDeclaration_ModalConsumer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ModalConsumer": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_ModalConsumer():
    TypeOnly<typeof current.ModalConsumer>;
declare function use_old_VariableDeclaration_ModalConsumer(
    use: TypeOnly<typeof old.ModalConsumer>);
use_old_VariableDeclaration_ModalConsumer(
    get_current_VariableDeclaration_ModalConsumer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ModalContext": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_ModalContext():
    TypeOnly<typeof old.ModalContext>;
declare function use_current_VariableDeclaration_ModalContext(
    use: TypeOnly<typeof current.ModalContext>);
use_current_VariableDeclaration_ModalContext(
    get_old_VariableDeclaration_ModalContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ModalContext": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_ModalContext():
    TypeOnly<typeof current.ModalContext>;
declare function use_old_VariableDeclaration_ModalContext(
    use: TypeOnly<typeof old.ModalContext>);
use_old_VariableDeclaration_ModalContext(
    get_current_VariableDeclaration_ModalContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ModalManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ModalManager():
    TypeOnly<old.ModalManager>;
declare function use_current_ClassDeclaration_ModalManager(
    use: TypeOnly<current.ModalManager>);
use_current_ClassDeclaration_ModalManager(
    get_old_ClassDeclaration_ModalManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ModalManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ModalManager():
    TypeOnly<current.ModalManager>;
declare function use_old_ClassDeclaration_ModalManager(
    use: TypeOnly<old.ModalManager>);
use_old_ClassDeclaration_ModalManager(
    get_current_ClassDeclaration_ModalManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ModalRoot": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_ModalRoot():
    TypeOnly<typeof old.ModalRoot>;
declare function use_current_VariableDeclaration_ModalRoot(
    use: TypeOnly<typeof current.ModalRoot>);
use_current_VariableDeclaration_ModalRoot(
    get_old_VariableDeclaration_ModalRoot());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ModalRoot": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_ModalRoot():
    TypeOnly<typeof current.ModalRoot>;
declare function use_old_VariableDeclaration_ModalRoot(
    use: TypeOnly<typeof old.ModalRoot>);
use_old_VariableDeclaration_ModalRoot(
    get_current_VariableDeclaration_ModalRoot());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_nameCellRenderer": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_nameCellRenderer():
    TypeOnly<typeof old.nameCellRenderer>;
declare function use_current_FunctionDeclaration_nameCellRenderer(
    use: TypeOnly<typeof current.nameCellRenderer>);
use_current_FunctionDeclaration_nameCellRenderer(
    get_old_FunctionDeclaration_nameCellRenderer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_nameCellRenderer": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_nameCellRenderer():
    TypeOnly<typeof current.nameCellRenderer>;
declare function use_old_FunctionDeclaration_nameCellRenderer(
    use: TypeOnly<typeof old.nameCellRenderer>);
use_old_FunctionDeclaration_nameCellRenderer(
    get_current_FunctionDeclaration_nameCellRenderer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_sanitizePath": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_sanitizePath():
    TypeOnly<typeof old.sanitizePath>;
declare function use_current_VariableDeclaration_sanitizePath(
    use: TypeOnly<typeof current.sanitizePath>);
use_current_VariableDeclaration_sanitizePath(
    get_old_VariableDeclaration_sanitizePath());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_sanitizePath": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_sanitizePath():
    TypeOnly<typeof current.sanitizePath>;
declare function use_old_VariableDeclaration_sanitizePath(
    use: TypeOnly<typeof old.sanitizePath>);
use_old_VariableDeclaration_sanitizePath(
    get_current_VariableDeclaration_sanitizePath());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_search": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_search():
    TypeOnly<typeof old.search>;
declare function use_current_VariableDeclaration_search(
    use: TypeOnly<typeof current.search>);
use_current_VariableDeclaration_search(
    get_old_VariableDeclaration_search());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_search": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_search():
    TypeOnly<typeof current.search>;
declare function use_old_VariableDeclaration_search(
    use: TypeOnly<typeof old.search>);
use_old_VariableDeclaration_search(
    get_current_VariableDeclaration_search());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SearchResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_SearchResult():
    TypeOnly<old.SearchResult>;
declare function use_current_InterfaceDeclaration_SearchResult(
    use: TypeOnly<current.SearchResult>);
use_current_InterfaceDeclaration_SearchResult(
    get_old_InterfaceDeclaration_SearchResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_SearchResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_SearchResult():
    TypeOnly<current.SearchResult>;
declare function use_old_InterfaceDeclaration_SearchResult(
    use: TypeOnly<old.SearchResult>);
use_old_InterfaceDeclaration_SearchResult(
    get_current_InterfaceDeclaration_SearchResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_showNextResult": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_showNextResult():
    TypeOnly<typeof old.showNextResult>;
declare function use_current_VariableDeclaration_showNextResult(
    use: TypeOnly<typeof current.showNextResult>);
use_current_VariableDeclaration_showNextResult(
    get_old_VariableDeclaration_showNextResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_showNextResult": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_showNextResult():
    TypeOnly<typeof current.showNextResult>;
declare function use_old_VariableDeclaration_showNextResult(
    use: TypeOnly<typeof old.showNextResult>);
use_old_VariableDeclaration_showNextResult(
    get_current_VariableDeclaration_showNextResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_singlePropertyTableRow": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_singlePropertyTableRow():
    TypeOnly<typeof old.singlePropertyTableRow>;
declare function use_current_VariableDeclaration_singlePropertyTableRow(
    use: TypeOnly<typeof current.singlePropertyTableRow>);
use_current_VariableDeclaration_singlePropertyTableRow(
    get_old_VariableDeclaration_singlePropertyTableRow());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_singlePropertyTableRow": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_singlePropertyTableRow():
    TypeOnly<typeof current.singlePropertyTableRow>;
declare function use_old_VariableDeclaration_singlePropertyTableRow(
    use: TypeOnly<typeof old.singlePropertyTableRow>);
use_old_VariableDeclaration_singlePropertyTableRow(
    get_current_VariableDeclaration_singlePropertyTableRow());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_StyledInspectorTable": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_StyledInspectorTable():
    TypeOnly<typeof old.StyledInspectorTable>;
declare function use_current_VariableDeclaration_StyledInspectorTable(
    use: TypeOnly<typeof current.StyledInspectorTable>);
use_current_VariableDeclaration_StyledInspectorTable(
    get_old_VariableDeclaration_StyledInspectorTable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_StyledInspectorTable": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_StyledInspectorTable():
    TypeOnly<typeof current.StyledInspectorTable>;
declare function use_old_VariableDeclaration_StyledInspectorTable(
    use: TypeOnly<typeof old.StyledInspectorTable>);
use_old_VariableDeclaration_StyledInspectorTable(
    get_current_VariableDeclaration_StyledInspectorTable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_toTableRows": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_toTableRows():
    TypeOnly<typeof old.toTableRows>;
declare function use_current_VariableDeclaration_toTableRows(
    use: TypeOnly<typeof current.toTableRows>);
use_current_VariableDeclaration_toTableRows(
    get_old_VariableDeclaration_toTableRows());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_toTableRows": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_toTableRows():
    TypeOnly<typeof current.toTableRows>;
declare function use_old_VariableDeclaration_toTableRows(
    use: TypeOnly<typeof old.toTableRows>);
use_old_VariableDeclaration_toTableRows(
    get_current_VariableDeclaration_toTableRows());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_typeCellRenderer": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_typeCellRenderer():
    TypeOnly<typeof old.typeCellRenderer>;
declare function use_current_FunctionDeclaration_typeCellRenderer(
    use: TypeOnly<typeof current.typeCellRenderer>);
use_current_FunctionDeclaration_typeCellRenderer(
    get_old_FunctionDeclaration_typeCellRenderer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_typeCellRenderer": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_typeCellRenderer():
    TypeOnly<typeof current.typeCellRenderer>;
declare function use_old_FunctionDeclaration_typeCellRenderer(
    use: TypeOnly<typeof old.typeCellRenderer>);
use_old_FunctionDeclaration_typeCellRenderer(
    get_current_FunctionDeclaration_typeCellRenderer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TypeColumn": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_TypeColumn():
    TypeOnly<typeof old.TypeColumn>;
declare function use_current_VariableDeclaration_TypeColumn(
    use: TypeOnly<typeof current.TypeColumn>);
use_current_VariableDeclaration_TypeColumn(
    get_old_VariableDeclaration_TypeColumn());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TypeColumn": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_TypeColumn():
    TypeOnly<typeof current.TypeColumn>;
declare function use_old_VariableDeclaration_TypeColumn(
    use: TypeOnly<typeof old.TypeColumn>);
use_old_VariableDeclaration_TypeColumn(
    get_current_VariableDeclaration_TypeColumn());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_typeidToIconMap": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_typeidToIconMap():
    TypeOnly<typeof old.typeidToIconMap>;
declare function use_current_VariableDeclaration_typeidToIconMap(
    use: TypeOnly<typeof current.typeidToIconMap>);
use_current_VariableDeclaration_typeidToIconMap(
    get_old_VariableDeclaration_typeidToIconMap());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_typeidToIconMap": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_typeidToIconMap():
    TypeOnly<typeof current.typeidToIconMap>;
declare function use_old_VariableDeclaration_typeidToIconMap(
    use: TypeOnly<typeof old.typeidToIconMap>);
use_old_VariableDeclaration_typeidToIconMap(
    get_current_VariableDeclaration_typeidToIconMap());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_useChipStyles": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_useChipStyles():
    TypeOnly<typeof old.useChipStyles>;
declare function use_current_VariableDeclaration_useChipStyles(
    use: TypeOnly<typeof current.useChipStyles>);
use_current_VariableDeclaration_useChipStyles(
    get_old_VariableDeclaration_useChipStyles());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_useChipStyles": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_useChipStyles():
    TypeOnly<typeof current.useChipStyles>;
declare function use_old_VariableDeclaration_useChipStyles(
    use: TypeOnly<typeof old.useChipStyles>);
use_old_VariableDeclaration_useChipStyles(
    get_current_VariableDeclaration_useChipStyles());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_valueCellRenderer": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_valueCellRenderer():
    TypeOnly<typeof old.valueCellRenderer>;
declare function use_current_FunctionDeclaration_valueCellRenderer(
    use: TypeOnly<typeof current.valueCellRenderer>);
use_current_FunctionDeclaration_valueCellRenderer(
    get_old_FunctionDeclaration_valueCellRenderer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_valueCellRenderer": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_valueCellRenderer():
    TypeOnly<typeof current.valueCellRenderer>;
declare function use_old_FunctionDeclaration_valueCellRenderer(
    use: TypeOnly<typeof old.valueCellRenderer>);
use_old_FunctionDeclaration_valueCellRenderer(
    get_current_FunctionDeclaration_valueCellRenderer());
