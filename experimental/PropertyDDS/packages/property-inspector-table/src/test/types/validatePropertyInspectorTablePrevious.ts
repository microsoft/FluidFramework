/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "@fluid-experimental/property-inspector-table-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultInspectorTableChildGetter": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_defaultInspectorTableChildGetter():
    TypeOnly<typeof old.defaultInspectorTableChildGetter>;
declare function use_current_VariableDeclaration_defaultInspectorTableChildGetter(
    use: TypeOnly<typeof current.defaultInspectorTableChildGetter>);
use_current_VariableDeclaration_defaultInspectorTableChildGetter(
    get_old_VariableDeclaration_defaultInspectorTableChildGetter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultInspectorTableChildGetter": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_defaultInspectorTableChildGetter():
    TypeOnly<typeof current.defaultInspectorTableChildGetter>;
declare function use_old_VariableDeclaration_defaultInspectorTableChildGetter(
    use: TypeOnly<typeof old.defaultInspectorTableChildGetter>);
use_old_VariableDeclaration_defaultInspectorTableChildGetter(
    get_current_VariableDeclaration_defaultInspectorTableChildGetter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultInspectorTableDataGetter": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_defaultInspectorTableDataGetter():
    TypeOnly<typeof old.defaultInspectorTableDataGetter>;
declare function use_current_VariableDeclaration_defaultInspectorTableDataGetter(
    use: TypeOnly<typeof current.defaultInspectorTableDataGetter>);
use_current_VariableDeclaration_defaultInspectorTableDataGetter(
    get_old_VariableDeclaration_defaultInspectorTableDataGetter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultInspectorTableDataGetter": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_defaultInspectorTableDataGetter():
    TypeOnly<typeof current.defaultInspectorTableDataGetter>;
declare function use_old_VariableDeclaration_defaultInspectorTableDataGetter(
    use: TypeOnly<typeof old.defaultInspectorTableDataGetter>);
use_old_VariableDeclaration_defaultInspectorTableDataGetter(
    get_current_VariableDeclaration_defaultInspectorTableDataGetter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultInspectorTableNameGetter": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_defaultInspectorTableNameGetter():
    TypeOnly<typeof old.defaultInspectorTableNameGetter>;
declare function use_current_VariableDeclaration_defaultInspectorTableNameGetter(
    use: TypeOnly<typeof current.defaultInspectorTableNameGetter>);
use_current_VariableDeclaration_defaultInspectorTableNameGetter(
    get_old_VariableDeclaration_defaultInspectorTableNameGetter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultInspectorTableNameGetter": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_defaultInspectorTableNameGetter():
    TypeOnly<typeof current.defaultInspectorTableNameGetter>;
declare function use_old_VariableDeclaration_defaultInspectorTableNameGetter(
    use: TypeOnly<typeof old.defaultInspectorTableNameGetter>);
use_old_VariableDeclaration_defaultInspectorTableNameGetter(
    get_current_VariableDeclaration_defaultInspectorTableNameGetter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_fetchRegisteredTemplates": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_fetchRegisteredTemplates():
    TypeOnly<typeof old.fetchRegisteredTemplates>;
declare function use_current_VariableDeclaration_fetchRegisteredTemplates(
    use: TypeOnly<typeof current.fetchRegisteredTemplates>);
use_current_VariableDeclaration_fetchRegisteredTemplates(
    get_old_VariableDeclaration_fetchRegisteredTemplates());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_fetchRegisteredTemplates": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_fetchRegisteredTemplates():
    TypeOnly<typeof current.fetchRegisteredTemplates>;
declare function use_old_VariableDeclaration_fetchRegisteredTemplates(
    use: TypeOnly<typeof old.fetchRegisteredTemplates>);
use_old_VariableDeclaration_fetchRegisteredTemplates(
    get_current_VariableDeclaration_fetchRegisteredTemplates());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getDefaultInspectorTableIcons": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getDefaultInspectorTableIcons():
    TypeOnly<typeof old.getDefaultInspectorTableIcons>;
declare function use_current_VariableDeclaration_getDefaultInspectorTableIcons(
    use: TypeOnly<typeof current.getDefaultInspectorTableIcons>);
use_current_VariableDeclaration_getDefaultInspectorTableIcons(
    get_old_VariableDeclaration_getDefaultInspectorTableIcons());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getDefaultInspectorTableIcons": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getDefaultInspectorTableIcons():
    TypeOnly<typeof current.getDefaultInspectorTableIcons>;
declare function use_old_VariableDeclaration_getDefaultInspectorTableIcons(
    use: TypeOnly<typeof old.getDefaultInspectorTableIcons>);
use_old_VariableDeclaration_getDefaultInspectorTableIcons(
    get_current_VariableDeclaration_getDefaultInspectorTableIcons());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getIconFromTypeId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getIconFromTypeId():
    TypeOnly<typeof old.getIconFromTypeId>;
declare function use_current_VariableDeclaration_getIconFromTypeId(
    use: TypeOnly<typeof current.getIconFromTypeId>);
use_current_VariableDeclaration_getIconFromTypeId(
    get_old_VariableDeclaration_getIconFromTypeId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getIconFromTypeId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getIconFromTypeId():
    TypeOnly<typeof current.getIconFromTypeId>;
declare function use_old_VariableDeclaration_getIconFromTypeId(
    use: TypeOnly<typeof old.getIconFromTypeId>);
use_old_VariableDeclaration_getIconFromTypeId(
    get_current_VariableDeclaration_getIconFromTypeId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_handlePropertyDataCreation": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_handlePropertyDataCreation():
    TypeOnly<typeof old.handlePropertyDataCreation>;
declare function use_current_VariableDeclaration_handlePropertyDataCreation(
    use: TypeOnly<typeof current.handlePropertyDataCreation>);
use_current_VariableDeclaration_handlePropertyDataCreation(
    get_old_VariableDeclaration_handlePropertyDataCreation());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_handlePropertyDataCreation": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_handlePropertyDataCreation():
    TypeOnly<typeof current.handlePropertyDataCreation>;
declare function use_old_VariableDeclaration_handlePropertyDataCreation(
    use: TypeOnly<typeof old.handlePropertyDataCreation>);
use_old_VariableDeclaration_handlePropertyDataCreation(
    get_current_VariableDeclaration_handlePropertyDataCreation());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_handlePropertyDataCreationOptionGeneration": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_handlePropertyDataCreationOptionGeneration():
    TypeOnly<typeof old.handlePropertyDataCreationOptionGeneration>;
declare function use_current_VariableDeclaration_handlePropertyDataCreationOptionGeneration(
    use: TypeOnly<typeof current.handlePropertyDataCreationOptionGeneration>);
use_current_VariableDeclaration_handlePropertyDataCreationOptionGeneration(
    get_old_VariableDeclaration_handlePropertyDataCreationOptionGeneration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_handlePropertyDataCreationOptionGeneration": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_handlePropertyDataCreationOptionGeneration():
    TypeOnly<typeof current.handlePropertyDataCreationOptionGeneration>;
declare function use_old_VariableDeclaration_handlePropertyDataCreationOptionGeneration(
    use: TypeOnly<typeof old.handlePropertyDataCreationOptionGeneration>);
use_old_VariableDeclaration_handlePropertyDataCreationOptionGeneration(
    get_current_VariableDeclaration_handlePropertyDataCreationOptionGeneration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IColumns": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IColumns():
    TypeOnly<old.IColumns>;
declare function use_current_InterfaceDeclaration_IColumns(
    use: TypeOnly<current.IColumns>);
use_current_InterfaceDeclaration_IColumns(
    get_old_InterfaceDeclaration_IColumns());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IColumns": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IColumns():
    TypeOnly<current.IColumns>;
declare function use_old_InterfaceDeclaration_IColumns(
    use: TypeOnly<old.IColumns>);
use_old_InterfaceDeclaration_IColumns(
    get_current_InterfaceDeclaration_IColumns());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDataCreationOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDataCreationOptions():
    TypeOnly<old.IDataCreationOptions>;
declare function use_current_InterfaceDeclaration_IDataCreationOptions(
    use: TypeOnly<current.IDataCreationOptions>);
use_current_InterfaceDeclaration_IDataCreationOptions(
    get_old_InterfaceDeclaration_IDataCreationOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDataCreationOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDataCreationOptions():
    TypeOnly<current.IDataCreationOptions>;
declare function use_old_InterfaceDeclaration_IDataCreationOptions(
    use: TypeOnly<old.IDataCreationOptions>);
use_old_InterfaceDeclaration_IDataCreationOptions(
    get_current_InterfaceDeclaration_IDataCreationOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDataGetterParameter": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDataGetterParameter():
    TypeOnly<old.IDataGetterParameter>;
declare function use_current_InterfaceDeclaration_IDataGetterParameter(
    use: TypeOnly<current.IDataGetterParameter>);
use_current_InterfaceDeclaration_IDataGetterParameter(
    get_old_InterfaceDeclaration_IDataGetterParameter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDataGetterParameter": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDataGetterParameter():
    TypeOnly<current.IDataGetterParameter>;
declare function use_old_InterfaceDeclaration_IDataGetterParameter(
    use: TypeOnly<old.IDataGetterParameter>);
use_old_InterfaceDeclaration_IDataGetterParameter(
    get_current_InterfaceDeclaration_IDataGetterParameter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IExpandedMap": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IExpandedMap():
    TypeOnly<old.IExpandedMap>;
declare function use_current_InterfaceDeclaration_IExpandedMap(
    use: TypeOnly<current.IExpandedMap>);
use_current_InterfaceDeclaration_IExpandedMap(
    get_old_InterfaceDeclaration_IExpandedMap());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IExpandedMap": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IExpandedMap():
    TypeOnly<current.IExpandedMap>;
declare function use_old_InterfaceDeclaration_IExpandedMap(
    use: TypeOnly<old.IExpandedMap>);
use_old_InterfaceDeclaration_IExpandedMap(
    get_current_InterfaceDeclaration_IExpandedMap());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IInspectorColumnsKeys": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IInspectorColumnsKeys():
    TypeOnly<old.IInspectorColumnsKeys>;
declare function use_current_TypeAliasDeclaration_IInspectorColumnsKeys(
    use: TypeOnly<current.IInspectorColumnsKeys>);
use_current_TypeAliasDeclaration_IInspectorColumnsKeys(
    get_old_TypeAliasDeclaration_IInspectorColumnsKeys());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IInspectorColumnsKeys": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IInspectorColumnsKeys():
    TypeOnly<current.IInspectorColumnsKeys>;
declare function use_old_TypeAliasDeclaration_IInspectorColumnsKeys(
    use: TypeOnly<old.IInspectorColumnsKeys>);
use_old_TypeAliasDeclaration_IInspectorColumnsKeys(
    get_current_TypeAliasDeclaration_IInspectorColumnsKeys());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorRow": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInspectorRow():
    TypeOnly<old.IInspectorRow>;
declare function use_current_InterfaceDeclaration_IInspectorRow(
    use: TypeOnly<current.IInspectorRow>);
use_current_InterfaceDeclaration_IInspectorRow(
    get_old_InterfaceDeclaration_IInspectorRow());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorRow": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInspectorRow():
    TypeOnly<current.IInspectorRow>;
declare function use_old_InterfaceDeclaration_IInspectorRow(
    use: TypeOnly<old.IInspectorRow>);
use_old_InterfaceDeclaration_IInspectorRow(
    get_current_InterfaceDeclaration_IInspectorRow());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IInspectorSearchAbortHandler": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IInspectorSearchAbortHandler():
    TypeOnly<old.IInspectorSearchAbortHandler>;
declare function use_current_TypeAliasDeclaration_IInspectorSearchAbortHandler(
    use: TypeOnly<current.IInspectorSearchAbortHandler>);
use_current_TypeAliasDeclaration_IInspectorSearchAbortHandler(
    get_old_TypeAliasDeclaration_IInspectorSearchAbortHandler());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IInspectorSearchAbortHandler": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IInspectorSearchAbortHandler():
    TypeOnly<current.IInspectorSearchAbortHandler>;
declare function use_old_TypeAliasDeclaration_IInspectorSearchAbortHandler(
    use: TypeOnly<old.IInspectorSearchAbortHandler>);
use_old_TypeAliasDeclaration_IInspectorSearchAbortHandler(
    get_current_TypeAliasDeclaration_IInspectorSearchAbortHandler());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IInspectorSearchCallback": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IInspectorSearchCallback():
    TypeOnly<old.IInspectorSearchCallback>;
declare function use_current_TypeAliasDeclaration_IInspectorSearchCallback(
    use: TypeOnly<current.IInspectorSearchCallback>);
use_current_TypeAliasDeclaration_IInspectorSearchCallback(
    get_old_TypeAliasDeclaration_IInspectorSearchCallback());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IInspectorSearchCallback": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IInspectorSearchCallback():
    TypeOnly<current.IInspectorSearchCallback>;
declare function use_old_TypeAliasDeclaration_IInspectorSearchCallback(
    use: TypeOnly<old.IInspectorSearchCallback>);
use_old_TypeAliasDeclaration_IInspectorSearchCallback(
    get_current_TypeAliasDeclaration_IInspectorSearchCallback());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorSearchMatch": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInspectorSearchMatch():
    TypeOnly<old.IInspectorSearchMatch>;
declare function use_current_InterfaceDeclaration_IInspectorSearchMatch(
    use: TypeOnly<current.IInspectorSearchMatch>);
use_current_InterfaceDeclaration_IInspectorSearchMatch(
    get_old_InterfaceDeclaration_IInspectorSearchMatch());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorSearchMatch": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInspectorSearchMatch():
    TypeOnly<current.IInspectorSearchMatch>;
declare function use_old_InterfaceDeclaration_IInspectorSearchMatch(
    use: TypeOnly<old.IInspectorSearchMatch>);
use_old_InterfaceDeclaration_IInspectorSearchMatch(
    get_current_InterfaceDeclaration_IInspectorSearchMatch());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorSearchMatchMap": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInspectorSearchMatchMap():
    TypeOnly<old.IInspectorSearchMatchMap>;
declare function use_current_InterfaceDeclaration_IInspectorSearchMatchMap(
    use: TypeOnly<current.IInspectorSearchMatchMap>);
use_current_InterfaceDeclaration_IInspectorSearchMatchMap(
    get_old_InterfaceDeclaration_IInspectorSearchMatchMap());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorSearchMatchMap": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInspectorSearchMatchMap():
    TypeOnly<current.IInspectorSearchMatchMap>;
declare function use_old_InterfaceDeclaration_IInspectorSearchMatchMap(
    use: TypeOnly<old.IInspectorSearchMatchMap>);
use_old_InterfaceDeclaration_IInspectorSearchMatchMap(
    get_current_InterfaceDeclaration_IInspectorSearchMatchMap());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorTableProps": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInspectorTableProps():
    TypeOnly<old.IInspectorTableProps>;
declare function use_current_InterfaceDeclaration_IInspectorTableProps(
    use: TypeOnly<current.IInspectorTableProps>);
use_current_InterfaceDeclaration_IInspectorTableProps(
    get_old_InterfaceDeclaration_IInspectorTableProps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorTableProps": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInspectorTableProps():
    TypeOnly<current.IInspectorTableProps>;
declare function use_old_InterfaceDeclaration_IInspectorTableProps(
    use: TypeOnly<old.IInspectorTableProps>);
use_old_InterfaceDeclaration_IInspectorTableProps(
    get_current_InterfaceDeclaration_IInspectorTableProps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorTableState": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IInspectorTableState():
    TypeOnly<old.IInspectorTableState>;
declare function use_current_InterfaceDeclaration_IInspectorTableState(
    use: TypeOnly<current.IInspectorTableState>);
use_current_InterfaceDeclaration_IInspectorTableState(
    get_old_InterfaceDeclaration_IInspectorTableState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IInspectorTableState": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IInspectorTableState():
    TypeOnly<current.IInspectorTableState>;
declare function use_old_InterfaceDeclaration_IInspectorTableState(
    use: TypeOnly<old.IInspectorTableState>);
use_old_InterfaceDeclaration_IInspectorTableState(
    get_current_InterfaceDeclaration_IInspectorTableState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ModalConsumer": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_ModalConsumer():
    TypeOnly<typeof old.ModalConsumer>;
declare function use_current_VariableDeclaration_ModalConsumer(
    use: TypeOnly<typeof current.ModalConsumer>);
use_current_VariableDeclaration_ModalConsumer(
    get_old_VariableDeclaration_ModalConsumer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ModalConsumer": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_ModalConsumer():
    TypeOnly<typeof current.ModalConsumer>;
declare function use_old_VariableDeclaration_ModalConsumer(
    use: TypeOnly<typeof old.ModalConsumer>);
use_old_VariableDeclaration_ModalConsumer(
    get_current_VariableDeclaration_ModalConsumer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ModalContext": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_ModalContext():
    TypeOnly<typeof old.ModalContext>;
declare function use_current_VariableDeclaration_ModalContext(
    use: TypeOnly<typeof current.ModalContext>);
use_current_VariableDeclaration_ModalContext(
    get_old_VariableDeclaration_ModalContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ModalContext": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_ModalContext():
    TypeOnly<typeof current.ModalContext>;
declare function use_old_VariableDeclaration_ModalContext(
    use: TypeOnly<typeof old.ModalContext>);
use_old_VariableDeclaration_ModalContext(
    get_current_VariableDeclaration_ModalContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ModalManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ModalManager():
    TypeOnly<old.ModalManager>;
declare function use_current_ClassDeclaration_ModalManager(
    use: TypeOnly<current.ModalManager>);
use_current_ClassDeclaration_ModalManager(
    get_old_ClassDeclaration_ModalManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ModalManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ModalManager():
    TypeOnly<current.ModalManager>;
declare function use_old_ClassDeclaration_ModalManager(
    use: TypeOnly<old.ModalManager>);
use_old_ClassDeclaration_ModalManager(
    get_current_ClassDeclaration_ModalManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ModalRoot": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_ModalRoot():
    TypeOnly<typeof old.ModalRoot>;
declare function use_current_VariableDeclaration_ModalRoot(
    use: TypeOnly<typeof current.ModalRoot>);
use_current_VariableDeclaration_ModalRoot(
    get_old_VariableDeclaration_ModalRoot());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_ModalRoot": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_ModalRoot():
    TypeOnly<typeof current.ModalRoot>;
declare function use_old_VariableDeclaration_ModalRoot(
    use: TypeOnly<typeof old.ModalRoot>);
use_old_VariableDeclaration_ModalRoot(
    get_current_VariableDeclaration_ModalRoot());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_StyledInspectorTable": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_StyledInspectorTable():
    TypeOnly<typeof old.StyledInspectorTable>;
declare function use_current_VariableDeclaration_StyledInspectorTable(
    use: TypeOnly<typeof current.StyledInspectorTable>);
use_current_VariableDeclaration_StyledInspectorTable(
    get_old_VariableDeclaration_StyledInspectorTable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_StyledInspectorTable": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_StyledInspectorTable():
    TypeOnly<typeof current.StyledInspectorTable>;
declare function use_old_VariableDeclaration_StyledInspectorTable(
    use: TypeOnly<typeof old.StyledInspectorTable>);
use_old_VariableDeclaration_StyledInspectorTable(
    get_current_VariableDeclaration_StyledInspectorTable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_typeidToIconMap": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_typeidToIconMap():
    TypeOnly<typeof old.typeidToIconMap>;
declare function use_current_VariableDeclaration_typeidToIconMap(
    use: TypeOnly<typeof current.typeidToIconMap>);
use_current_VariableDeclaration_typeidToIconMap(
    get_old_VariableDeclaration_typeidToIconMap());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_typeidToIconMap": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_typeidToIconMap():
    TypeOnly<typeof current.typeidToIconMap>;
declare function use_old_VariableDeclaration_typeidToIconMap(
    use: TypeOnly<typeof old.typeidToIconMap>);
use_old_VariableDeclaration_typeidToIconMap(
    get_current_VariableDeclaration_typeidToIconMap());
