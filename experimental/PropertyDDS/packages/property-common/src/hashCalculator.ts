/* eslint-disable @typescript-eslint/unbound-method */
/* eslint-disable no-bitwise */
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * @fileoverview Utility class to compute an hash for a given set of variables
 * using the murmur3 hash (see https://code.google.com/p/smhasher/)
 *
 * This is a reimplementation of the original C++ code in JavaScript. The original
 * code is licensed under a MIT license.
 */

import { guidToUint32x4, uint32x4ToGUID } from "./guidUtils";

/**
 * The type to use when pushing values
 */
enum Type {
    /** Signed integer with 8 bits */
    Int8 = 0,
    /** Signed integer with 16 bits */
    Int16 = 1,
    /** Signed integer with 32 bits */
    Int32 = 2,
    /** Unsigned integer with 8 bits */
    Uint8 = 3,
    /** Unsigned integer with 16 bits */
    Uint16 = 4,
    /** Unsigned integer with 32 bits */
    Uint32 = 5,
    /** Floating point value with 32 bits */
    Float32 = 6,
    /** Floating point value with 64 bits */
    Float64 = 7,
}

class HashBuffer {
    hashBuffer: ArrayBuffer;
    dataView: DataView;
    Uint8HashArray: Uint8Array;
    Uint32HashArray: Uint32Array;
    pos: number;

    /**
     * Helper class to store the array buffers needed for the hash computation.
     *
     * TODO: should we cache these classes to avoid unnecessary reallocation
     *       of these buffers. Is it worth the effort?
     */
    constructor() {
        // This is the internal array buffer we are going to use for conversions
        this.hashBuffer = new ArrayBuffer(32);

        this.dataView = new DataView(this.hashBuffer);
        this.Uint8HashArray = new Uint8Array(this.hashBuffer, 0, 32);
        this.Uint32HashArray = new Uint32Array(this.hashBuffer, 0, 8);

        this.pos = 0;
    }

    /**
     * Shifts the buffers forward by 16 bytes
     */
    shiftBuffers() {
        this.Uint32HashArray[0] = this.Uint32HashArray[4];
        this.Uint32HashArray[1] = this.Uint32HashArray[5];
        this.Uint32HashArray[2] = this.Uint32HashArray[6];
        this.Uint32HashArray[3] = this.Uint32HashArray[7];
        this.Uint32HashArray[4] = 0;
        this.Uint32HashArray[5] = 0;
        this.Uint32HashArray[6] = 0;
        this.Uint32HashArray[7] = 0;
        this.pos -= 16;
    }
}

// If available, we use the browser imul function, otherwise we emulate it
// Emulation code is from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
// License: public domain, according to https://developer.mozilla.org/en-US/docs/MDN/About#Copyrights_and_licenses:
//   Code samples added on or after August 20, 2010 are in the public domain.
//   No licensing notice is necessary, but if you need one, you can use:
//   "Any copyright is dedicated to the Public Domain.
//    http://creativecommons.org/publicdomain/zero/1.0/".
const imul = Math.imul === undefined ? Math.imul : function(a, b) {
    const ah = (a >>> 16) & 0xffff;
    const al = a & 0xffff;
    const bh = (b >>> 16) & 0xffff;
    const bl = b & 0xffff;
    // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value
    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
};

// Helper functions for the hash computation
/**
 * ROT function required for the hash computation
 *
 * @param x - 32 bit integer
 * @param r - amount to shift
 * @returns Rotated 32-bit integer.
 */
const rotl32 = (x: number, r: number): number => (((x << r) >>> 0) | (x >>> (32 - r))) >>> 0;

/**
 * Mixing function for the finalization
 * @param x -32 bit integer
 * @returns The scrambled 32-bit integer.
 */
const fmix32 = function(x: number): number {
    let h = x;
    h = (h ^ (h >>> 16)) >>> 0;
    h = imul(h, 0x85ebca6b) >>> 0;
    h = (h ^ (h >>> 13)) >>> 0;
    h = imul(h, 0xc2b2ae35) >>> 0;
    h = (h ^ (h >>> 16)) >>> 0;

    return h;
};

// Constants
const c1 = 0x239b961b;
const c2 = 0xab0e9789;
const c3 = 0x38b34ae5;
const c4 = 0xa1e38b93;

/**
 * Helper class which computes a Murmur3 hash for binary data. The user
 * can successively push data in different binary types into the hash
 * computation function and will then get a hash computed over these fields.
 *
 * NOTE: By default JavaScript uses big-endian byte order. So the hashes
 *       generated by this class might correspond to those generated natively
 *       on a little-endian architecture.
*/
class HashCalculator {
    _h1: number;
    _h2: number;
    _h3: number;
    _h4: number;
    length: number;
    finalized: boolean;
    hashBuffer: HashBuffer;

    /**
     * @param seed- Seed value used for the hash computation
     */
    constructor(in_seed = 1) {
        // Initialize the hash computation with the seed value
        this._h1 = in_seed;
        this._h2 = in_seed;
        this._h3 = in_seed;
        this._h4 = in_seed;
        this.length = 0;
        this.finalized = false;

        this.hashBuffer = new HashBuffer();
    }

    /**
     * Pushes a single unsigned integer with 8 bits into the hash computation
     *
     * @param in_value - The value to push
     */
    pushUint8(in_value) {
        this.hashBuffer.dataView.setUint8(this.hashBuffer.pos, in_value);
        this.hashBuffer.pos++;

        if (this.hashBuffer.pos >= 16) {
            this._computeHashFor16ByteBlock();
        }
    }

    /**
     * Pushes a single unsigned integer with 16 bits into the hash computation
     *
     * @param in_value - The value to push
     */
    pushUint16(in_value) {
        this.hashBuffer.dataView.setUint16(this.hashBuffer.pos, in_value);
        this.hashBuffer.pos += 2;

        if (this.hashBuffer.pos >= 16) {
            this._computeHashFor16ByteBlock();
        }
    }

    /**
     * Pushes a single unsigned integer with 32 bits into the hash computation
     *
     * @param in_value - The value to push
     */
    pushUint32(in_value) {
        this.hashBuffer.dataView.setUint32(this.hashBuffer.pos, in_value);
        this.hashBuffer.pos += 4;

        if (this.hashBuffer.pos >= 16) {
            this._computeHashFor16ByteBlock();
        }
    }

    /**
     * Pushes a single signed integer with 8 bits into the hash computation
     *
     * @param in_value - The value to push
     */
    pushInt8(in_value) {
        this.hashBuffer.dataView.setInt8(this.hashBuffer.pos, in_value);
        this.hashBuffer.pos++;
        if (this.hashBuffer.pos >= 16) {
            this._computeHashFor16ByteBlock();
        }
    }

    /**
     * Pushes a single signed integer with 16 bits into the hash computation
     *
     * @param in_value - The value to push
     */
    pushInt16(in_value) {
        this.hashBuffer.dataView.setInt16(this.hashBuffer.pos, in_value);
        this.hashBuffer.pos += 2;

        if (this.hashBuffer.pos >= 16) {
            this._computeHashFor16ByteBlock();
        }
    }

    /**
     * Pushes a single signed integer with 32 bits into the hash computation
     *
     * @param in_value - The value to push
     */
    pushInt32(in_value) {
        this.hashBuffer.dataView.setInt32(this.hashBuffer.pos, in_value);
        this.hashBuffer.pos += 4;

        if (this.hashBuffer.pos >= 16) {
            this._computeHashFor16ByteBlock();
        }
    }

    /**
     * Pushes a single float with 32 bits into the hash computation
     *
     * @param in_value - The value to push
     */
    pushFloat32(in_value) {
        this.hashBuffer.dataView.setFloat32(this.hashBuffer.pos, in_value);
        this.hashBuffer.pos += 4;

        if (this.hashBuffer.pos >= 16) {
            this._computeHashFor16ByteBlock();
        }
    }

    /**
     * Pushes a single float with 64 bits into the hash computation
     *
     * @param in_value - The value to push
     */
    pushFloat64(in_value) {
        this.hashBuffer.dataView.setFloat64(this.hashBuffer.pos, in_value);
        this.hashBuffer.pos += 8;

        if (this.hashBuffer.pos >= 16) {
            this._computeHashFor16ByteBlock();
        }
    }

    /**
     * Pushes a GUID into the hash computation
     *
     * @param in_guid - The value to push
     */
    pushGUID(in_guid: string) {
        // Parse the GUID
        const array = guidToUint32x4(in_guid);

        // Add it as a uint32 values
        this.pushArray(array, Type.Uint32);
    }

    /**
     * Pushes a string into the hash computation
     *
     * @param in_string - The value to push
     */
    pushString(in_string: string) {
        // Push each character individually. We have to use uin16 here, as
        // JavaScript strings are UTF16
        for (let i = 0; i < in_string.length; i++) {
            this.pushUint16(in_string.charCodeAt(i));
        }
    }

    static _pushFunctions = [
        HashCalculator.prototype.pushInt8,
        HashCalculator.prototype.pushInt16,
        HashCalculator.prototype.pushInt32,
        HashCalculator.prototype.pushUint8,
        HashCalculator.prototype.pushUint16,
        HashCalculator.prototype.pushUint32,
        HashCalculator.prototype.pushFloat32,
        HashCalculator.prototype.pushFloat64,
    ];

    /**
     * Pushes an array into the hash computation
     *
     * @param array  - The array to include in the hash computation
     * @param type - The type to use to compute the hash
     * @param count - The number of entries to include in the computation.
     *                                                 If not supplied the whole array will be used
     */
    pushArray(array: Uint32Array, type: Type, count?: number) {
        const pushFun = HashCalculator._pushFunctions[type];
        const length = count !== undefined ? count : array.length;

        for (let i = 0; i < length; i++) {
            pushFun.call(this, array[i]);
        }
    }

    /**
     * @returns the computed Hash
     * Note: after calling this function you no longer may push more data!
     */
    getHash() {
        if (!this.finalized) {
            this._finalizeHash();
        }

        // Convert the hash to a string
        return uint32x4ToGUID([this._h1, this._h2, this._h3, this._h4]);
    }

    /**
     * Computes the murmur3 hash for a block of 16 bytes
     */
    private _computeHashFor16ByteBlock() {
        let k1 = this.hashBuffer.Uint32HashArray[0];
        let k2 = this.hashBuffer.Uint32HashArray[1];
        let k3 = this.hashBuffer.Uint32HashArray[2];
        let k4 = this.hashBuffer.Uint32HashArray[3];
        this.hashBuffer.shiftBuffers();

        k1 = imul(k1, c1) >>> 0; k1 = rotl32(k1, 15); k1 = imul(k1, c2) >>> 0; this._h1 = (this._h1 ^ k1) >>> 0;
        this._h1 = rotl32(this._h1, 19);
        this._h1 = (this._h1 + this._h2) >>> 0;
        this._h1 = ((imul(this._h1, 5) >>> 0) + 0x561ccd1b) >>> 0;

        k2 = imul(k2, c2) >>> 0; k2 = rotl32(k2, 16); k2 = imul(k2, c3) >>> 0; this._h2 = (this._h2 ^ k2) >>> 0;
        this._h2 = rotl32(this._h2, 17);
        this._h2 = (this._h2 + this._h3) >>> 0;
        this._h2 = ((imul(this._h2, 5) >>> 0) + 0x0bcaa747) >>> 0;

        k3 = imul(k3, c3) >>> 0; k3 = rotl32(k3, 17); k3 = imul(k3, c4) >>> 0; this._h3 = (this._h3 ^ k3) >>> 0;
        this._h3 = rotl32(this._h3, 15);
        this._h3 = (this._h3 + this._h4) >>> 0;
        this._h3 = ((imul(this._h3, 5) >>> 0) + 0x96cd1c35) >>> 0;

        k4 = imul(k4, c4) >>> 0; k4 = rotl32(k4, 18); k4 = imul(k4, c1) >>> 0; this._h4 = (this._h4 ^ k4) >>> 0;
        this._h4 = rotl32(this._h4, 13);
        this._h4 = (this._h4 + this._h1) >>> 0;
        this._h4 = ((imul(this._h4, 5) >>> 0) + 0x32ac3b17) >>> 0;

        this.length += 16;
    }

    /**
     * Finalizes the hash computation
     */
    private _finalizeHash() {
        let k1 = 0;
        let k2 = 0;
        let k3 = 0;
        let k4 = 0;

        // Compute the hash for the remaining bytes in the buffer
        const buffer = this.hashBuffer.Uint8HashArray;
        /* eslint-disable no-fallthrough */  // Allows cases to fallthrough without complaints.
        switch (this.hashBuffer.pos) {
            case 15: k4 = (k4 ^ (buffer[14] << 16)) >>> 0;
            case 14: k4 = (k4 ^ (buffer[13] << 8)) >>> 0;
            case 13: k4 = (k4 ^ (buffer[12] << 0)) >>> 0;
                k4 = imul(k4, c4) >>> 0;
                k4 = rotl32(k4, 18);
                k4 = imul(k4, c1) >>> 0;
                this._h4 = (this._h4 ^ k4) >>> 0;

            case 12: k3 = (k3 ^ (buffer[11] << 24)) >>> 0;
            case 11: k3 = (k3 ^ (buffer[10] << 16)) >>> 0;
            case 10: k3 = (k3 ^ (buffer[9] << 8)) >>> 0;
            case 9: k3 = (k3 ^ (buffer[8] << 0)) >>> 0;
                k3 = imul(k3, c3) >>> 0;
                k3 = rotl32(k3, 17);
                k3 = imul(k3, c4) >>> 0;
                this._h3 = (this._h3 ^ k3) >>> 0;

            case 8: k2 = (k2 ^ (buffer[7] << 24)) >>> 0;
            case 7: k2 = (k2 ^ (buffer[6] << 16)) >>> 0;
            case 6: k2 = (k2 ^ (buffer[5] << 8)) >>> 0;
            case 5: k2 = (k2 ^ (buffer[4] << 0)) >>> 0;
                k2 = imul(k2, c2) >>> 0;
                k2 = rotl32(k2, 16);
                k2 = imul(k2, c3) >>> 0;
                this._h2 = (this._h2 ^ k2) >>> 0;

            case 4: k1 = (k1 ^ (buffer[3] << 24)) >>> 0;
            case 3: k1 = (k1 ^ (buffer[2] << 16)) >>> 0;
            case 2: k1 = (k1 ^ (buffer[1] << 8)) >>> 0;
            case 1: k1 = (k1 ^ (buffer[0] << 0)) >>> 0;
                k1 = imul(k1, c1) >>> 0;
                k1 = rotl32(k1, 15);
                k1 = imul(k1, c2) >>> 0;
                this._h1 = (this._h1 ^ k1) >>> 0;
                break;
            case 0:
                // Bug fix for previously unhandled condition
                break;

            default:
                throw new Error("_finalizeHash: We should never get into the default case.");
        }
        /* eslint-enable no-fallthrough */

        // Perform the finalization
        const len = this.length + this.hashBuffer.pos;
        this._h1 = (this._h1 ^ len) >>> 0;
        this._h2 = (this._h2 ^ len) >>> 0;
        this._h3 = (this._h3 ^ len) >>> 0;
        this._h4 = (this._h4 ^ len) >>> 0;

        this._h1 = (this._h1 + this._h2) >>> 0;
        this._h1 = (this._h1 + this._h3) >>> 0;
        this._h1 = (this._h1 + this._h4) >>> 0;
        this._h2 = (this._h2 + this._h1) >>> 0;
        this._h3 = (this._h3 + this._h1) >>> 0;
        this._h4 = (this._h4 + this._h1) >>> 0;

        this._h1 = fmix32(this._h1);
        this._h2 = fmix32(this._h2);
        this._h3 = fmix32(this._h3);
        this._h4 = fmix32(this._h4);

        this._h1 = (this._h1 + this._h2) >>> 0;
        this._h1 = (this._h1 + this._h3) >>> 0;
        this._h1 = (this._h1 + this._h4) >>> 0;

        this._h2 = (this._h2 + this._h1) >>> 0;
        this._h3 = (this._h3 + this._h1) >>> 0;
        this._h4 = (this._h4 + this._h1) >>> 0;

        this.finalized = true;
    }
}

/**
 * Computes a hash for a 32 bit unsigned int value (using the FNV-1a algorithm
 * see http://www.isthe.com/chongo/tech/comp/fnv/)
 *
 * @param in_value - 32 bit unsigned integer for which the hash is computed
 * @param in_seed - result from a previous hash to chain the hash computation
 * @returns the computed hash key
 */
const UINT_32HASH_PRIME = 16777619;
const UINT_32HASH_OFFSET = 2166136261;

const fNV1aHashUint32 = function(in_value, in_seed) {
    let result = UINT_32HASH_OFFSET;
    if (in_seed !== undefined) {
        result = ((result ^ in_seed) * UINT_32HASH_PRIME) >>> 0;
    }

    result = (((result ^ (in_value & 0xFF)) >>> 0) * UINT_32HASH_PRIME) >>> 0;
    result = (((result ^ ((in_value >> 8) & 0xFF)) >>> 0) * UINT_32HASH_PRIME) >>> 0;
    result = (((result ^ ((in_value >> 16) & 0xFF)) >>> 0) * UINT_32HASH_PRIME) >>> 0;
    result = (((result ^ ((in_value >> 24) & 0xFF)) >>> 0) * UINT_32HASH_PRIME) >>> 0;
    return result;
};

/**
 * Compute a new 32-bit hash from a previous 32-bit hash and a new 32-bit "delta hash".
 * This function can be also be used for (slow) high quality hash combine of 32-bit numbers.
 *
 * @param in_newDeltaHash - the new hasH
 * @param in_previousHash - the previous hash
 * @returns the computed hash key
 */
const incrementalHashUint32 = (in_newDeltaHash, in_previousHash) => fNV1aHashUint32(in_newDeltaHash, in_previousHash);

/**
 * Compute a new hash array from a previous hash and a new "delta hash".
 * All hashes are assumed to be 4 x 32-bit uint arrays.
 * This function can be also be used for (slow) high quality hash combines.
 *
 * @param in_newDeltaHash - the new hash array
 * @param in_previousHash - the previous hash array
 * @param io_result - the computed hash key is returned
 *                                                   through this parameter if specified.
 * @returns the computed hash key
 */
const incrementalHash4xUint32 = function(
    in_newDeltaHash: Uint32Array,
    in_previousHash: Uint32Array,
    io_result: Uint32Array,
): Uint32Array {
    let accumulated = io_result;
    if (accumulated === undefined) {
        accumulated = new Uint32Array(4);
    }

    accumulated[0] = fNV1aHashUint32(in_newDeltaHash[0], in_previousHash[0]);
    accumulated[0] = fNV1aHashUint32(in_newDeltaHash[1], accumulated[0]);
    accumulated[0] = fNV1aHashUint32(in_newDeltaHash[2], accumulated[0]);
    accumulated[0] = fNV1aHashUint32(in_newDeltaHash[3], accumulated[0]);

    accumulated[1] = fNV1aHashUint32(in_newDeltaHash[0], in_previousHash[1]);
    accumulated[1] = fNV1aHashUint32(in_newDeltaHash[1], accumulated[1]);
    accumulated[1] = fNV1aHashUint32(in_newDeltaHash[2], accumulated[1]);
    accumulated[1] = fNV1aHashUint32(in_newDeltaHash[3], accumulated[1]);

    accumulated[2] = fNV1aHashUint32(in_newDeltaHash[0], in_previousHash[2]);
    accumulated[2] = fNV1aHashUint32(in_newDeltaHash[1], accumulated[2]);
    accumulated[2] = fNV1aHashUint32(in_newDeltaHash[2], accumulated[2]);
    accumulated[2] = fNV1aHashUint32(in_newDeltaHash[3], accumulated[2]);

    accumulated[3] = fNV1aHashUint32(in_newDeltaHash[0], in_previousHash[3]);
    accumulated[3] = fNV1aHashUint32(in_newDeltaHash[1], accumulated[3]);
    accumulated[3] = fNV1aHashUint32(in_newDeltaHash[2], accumulated[3]);
    accumulated[3] = fNV1aHashUint32(in_newDeltaHash[3], accumulated[3]);

    return accumulated;
};

export {
    incrementalHashUint32,
    incrementalHash4xUint32,
    HashCalculator,
};
