/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "@fluid-experimental/property-common-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BaseDataArray": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_BaseDataArray():
    TypeOnly<old.BaseDataArray>;
declare function use_current_ClassDeclaration_BaseDataArray(
    use: TypeOnly<current.BaseDataArray>);
use_current_ClassDeclaration_BaseDataArray(
    get_old_ClassDeclaration_BaseDataArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BaseDataArray": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_BaseDataArray():
    TypeOnly<current.BaseDataArray>;
declare function use_old_ClassDeclaration_BaseDataArray(
    use: TypeOnly<old.BaseDataArray>);
use_old_ClassDeclaration_BaseDataArray(
    get_current_ClassDeclaration_BaseDataArray());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BoolDataArray": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_BoolDataArray():
    TypeOnly<old.BoolDataArray>;
declare function use_current_ClassDeclaration_BoolDataArray(
    use: TypeOnly<current.BoolDataArray>);
use_current_ClassDeclaration_BoolDataArray(
    get_old_ClassDeclaration_BoolDataArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BoolDataArray": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_BoolDataArray():
    TypeOnly<current.BoolDataArray>;
declare function use_old_ClassDeclaration_BoolDataArray(
    use: TypeOnly<old.BoolDataArray>);
use_old_ClassDeclaration_BoolDataArray(
    get_current_ClassDeclaration_BoolDataArray());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_calculateHash": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_calculateHash():
    TypeOnly<typeof old.calculateHash>;
declare function use_current_FunctionDeclaration_calculateHash(
    use: TypeOnly<typeof current.calculateHash>);
use_current_FunctionDeclaration_calculateHash(
    get_old_FunctionDeclaration_calculateHash());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_calculateHash": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_calculateHash():
    TypeOnly<typeof current.calculateHash>;
declare function use_old_FunctionDeclaration_calculateHash(
    use: TypeOnly<typeof old.calculateHash>);
use_old_FunctionDeclaration_calculateHash(
    get_current_FunctionDeclaration_calculateHash());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Chronometer": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Chronometer():
    TypeOnly<old.Chronometer>;
declare function use_current_ClassDeclaration_Chronometer(
    use: TypeOnly<current.Chronometer>);
use_current_ClassDeclaration_Chronometer(
    get_old_ClassDeclaration_Chronometer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Chronometer": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Chronometer():
    TypeOnly<current.Chronometer>;
declare function use_old_ClassDeclaration_Chronometer(
    use: TypeOnly<old.Chronometer>);
use_old_ClassDeclaration_Chronometer(
    get_current_ClassDeclaration_Chronometer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Collection": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Collection():
    TypeOnly<old.Collection<any>>;
declare function use_current_ClassDeclaration_Collection(
    use: TypeOnly<current.Collection<any>>);
use_current_ClassDeclaration_Collection(
    get_old_ClassDeclaration_Collection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Collection": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Collection():
    TypeOnly<current.Collection<any>>;
declare function use_old_ClassDeclaration_Collection(
    use: TypeOnly<old.Collection<any>>);
use_old_ClassDeclaration_Collection(
    get_current_ClassDeclaration_Collection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ConsoleUtils": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ConsoleUtils():
    TypeOnly<old.ConsoleUtils>;
declare function use_current_ClassDeclaration_ConsoleUtils(
    use: TypeOnly<current.ConsoleUtils>);
use_current_ClassDeclaration_ConsoleUtils(
    get_old_ClassDeclaration_ConsoleUtils());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ConsoleUtils": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ConsoleUtils():
    TypeOnly<current.ConsoleUtils>;
declare function use_old_ClassDeclaration_ConsoleUtils(
    use: TypeOnly<old.ConsoleUtils>);
use_old_ClassDeclaration_ConsoleUtils(
    get_current_ClassDeclaration_ConsoleUtils());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_constants": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_constants():
    TypeOnly<typeof old.constants>;
declare function use_current_VariableDeclaration_constants(
    use: TypeOnly<typeof current.constants>);
use_current_VariableDeclaration_constants(
    get_old_VariableDeclaration_constants());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_constants": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_constants():
    TypeOnly<typeof current.constants>;
declare function use_old_VariableDeclaration_constants(
    use: TypeOnly<typeof old.constants>);
use_old_VariableDeclaration_constants(
    get_current_VariableDeclaration_constants());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeferredPromise": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DeferredPromise():
    TypeOnly<old.DeferredPromise<any>>;
declare function use_current_ClassDeclaration_DeferredPromise(
    use: TypeOnly<current.DeferredPromise<any>>);
use_current_ClassDeclaration_DeferredPromise(
    get_old_ClassDeclaration_DeferredPromise());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeferredPromise": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DeferredPromise():
    TypeOnly<current.DeferredPromise<any>>;
declare function use_old_ClassDeclaration_DeferredPromise(
    use: TypeOnly<old.DeferredPromise<any>>);
use_old_ClassDeclaration_DeferredPromise(
    get_current_ClassDeclaration_DeferredPromise());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeterministicRandomGenerator": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DeterministicRandomGenerator():
    TypeOnly<old.DeterministicRandomGenerator>;
declare function use_current_ClassDeclaration_DeterministicRandomGenerator(
    use: TypeOnly<current.DeterministicRandomGenerator>);
use_current_ClassDeclaration_DeterministicRandomGenerator(
    get_old_ClassDeclaration_DeterministicRandomGenerator());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeterministicRandomGenerator": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DeterministicRandomGenerator():
    TypeOnly<current.DeterministicRandomGenerator>;
declare function use_old_ClassDeclaration_DeterministicRandomGenerator(
    use: TypeOnly<old.DeterministicRandomGenerator>);
use_old_ClassDeclaration_DeterministicRandomGenerator(
    get_current_ClassDeclaration_DeterministicRandomGenerator());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EventEmitter": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_EventEmitter():
    TypeOnly<old.EventEmitter>;
declare function use_current_ClassDeclaration_EventEmitter(
    use: TypeOnly<current.EventEmitter>);
use_current_ClassDeclaration_EventEmitter(
    get_old_ClassDeclaration_EventEmitter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EventEmitter": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_EventEmitter():
    TypeOnly<current.EventEmitter>;
declare function use_old_ClassDeclaration_EventEmitter(
    use: TypeOnly<old.EventEmitter>);
use_old_ClassDeclaration_EventEmitter(
    get_current_ClassDeclaration_EventEmitter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_FlaggedError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_FlaggedError():
    TypeOnly<old.FlaggedError>;
declare function use_current_ClassDeclaration_FlaggedError(
    use: TypeOnly<current.FlaggedError>);
use_current_ClassDeclaration_FlaggedError(
    get_old_ClassDeclaration_FlaggedError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_FlaggedError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_FlaggedError():
    TypeOnly<current.FlaggedError>;
declare function use_old_ClassDeclaration_FlaggedError(
    use: TypeOnly<old.FlaggedError>);
use_old_ClassDeclaration_FlaggedError(
    get_current_ClassDeclaration_FlaggedError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Float32DataArray": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Float32DataArray():
    TypeOnly<old.Float32DataArray>;
declare function use_current_ClassDeclaration_Float32DataArray(
    use: TypeOnly<current.Float32DataArray>);
use_current_ClassDeclaration_Float32DataArray(
    get_old_ClassDeclaration_Float32DataArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Float32DataArray": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Float32DataArray():
    TypeOnly<current.Float32DataArray>;
declare function use_old_ClassDeclaration_Float32DataArray(
    use: TypeOnly<old.Float32DataArray>);
use_old_ClassDeclaration_Float32DataArray(
    get_current_ClassDeclaration_Float32DataArray());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Float64DataArray": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Float64DataArray():
    TypeOnly<old.Float64DataArray>;
declare function use_current_ClassDeclaration_Float64DataArray(
    use: TypeOnly<current.Float64DataArray>);
use_current_ClassDeclaration_Float64DataArray(
    get_old_ClassDeclaration_Float64DataArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Float64DataArray": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Float64DataArray():
    TypeOnly<current.Float64DataArray>;
declare function use_old_ClassDeclaration_Float64DataArray(
    use: TypeOnly<old.Float64DataArray>);
use_old_ClassDeclaration_Float64DataArray(
    get_current_ClassDeclaration_Float64DataArray());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GuidUtils": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_GuidUtils():
    TypeOnly<typeof old.GuidUtils>;
declare function use_current_VariableDeclaration_GuidUtils(
    use: TypeOnly<typeof current.GuidUtils>);
use_current_VariableDeclaration_GuidUtils(
    get_old_VariableDeclaration_GuidUtils());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_GuidUtils": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_GuidUtils():
    TypeOnly<typeof current.GuidUtils>;
declare function use_old_VariableDeclaration_GuidUtils(
    use: TypeOnly<typeof old.GuidUtils>);
use_old_VariableDeclaration_GuidUtils(
    get_current_VariableDeclaration_GuidUtils());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_HTTPError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_HTTPError():
    TypeOnly<old.HTTPError>;
declare function use_current_ClassDeclaration_HTTPError(
    use: TypeOnly<current.HTTPError>);
use_current_ClassDeclaration_HTTPError(
    get_old_ClassDeclaration_HTTPError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_HTTPError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_HTTPError():
    TypeOnly<current.HTTPError>;
declare function use_old_ClassDeclaration_HTTPError(
    use: TypeOnly<old.HTTPError>);
use_old_ClassDeclaration_HTTPError(
    get_current_ClassDeclaration_HTTPError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_HTTPErrorNoStack": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_HTTPErrorNoStack():
    TypeOnly<old.HTTPErrorNoStack>;
declare function use_current_ClassDeclaration_HTTPErrorNoStack(
    use: TypeOnly<current.HTTPErrorNoStack>);
use_current_ClassDeclaration_HTTPErrorNoStack(
    get_old_ClassDeclaration_HTTPErrorNoStack());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_HTTPErrorNoStack": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_HTTPErrorNoStack():
    TypeOnly<current.HTTPErrorNoStack>;
declare function use_old_ClassDeclaration_HTTPErrorNoStack(
    use: TypeOnly<old.HTTPErrorNoStack>);
use_old_ClassDeclaration_HTTPErrorNoStack(
    get_current_ClassDeclaration_HTTPErrorNoStack());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Int16DataArray": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Int16DataArray():
    TypeOnly<old.Int16DataArray>;
declare function use_current_ClassDeclaration_Int16DataArray(
    use: TypeOnly<current.Int16DataArray>);
use_current_ClassDeclaration_Int16DataArray(
    get_old_ClassDeclaration_Int16DataArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Int16DataArray": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Int16DataArray():
    TypeOnly<current.Int16DataArray>;
declare function use_old_ClassDeclaration_Int16DataArray(
    use: TypeOnly<old.Int16DataArray>);
use_old_ClassDeclaration_Int16DataArray(
    get_current_ClassDeclaration_Int16DataArray());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Int32DataArray": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Int32DataArray():
    TypeOnly<old.Int32DataArray>;
declare function use_current_ClassDeclaration_Int32DataArray(
    use: TypeOnly<current.Int32DataArray>);
use_current_ClassDeclaration_Int32DataArray(
    get_old_ClassDeclaration_Int32DataArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Int32DataArray": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Int32DataArray():
    TypeOnly<current.Int32DataArray>;
declare function use_old_ClassDeclaration_Int32DataArray(
    use: TypeOnly<old.Int32DataArray>);
use_old_ClassDeclaration_Int32DataArray(
    get_current_ClassDeclaration_Int32DataArray());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Int64": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Int64():
    TypeOnly<old.Int64>;
declare function use_current_ClassDeclaration_Int64(
    use: TypeOnly<current.Int64>);
use_current_ClassDeclaration_Int64(
    get_old_ClassDeclaration_Int64());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Int64": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Int64():
    TypeOnly<current.Int64>;
declare function use_old_ClassDeclaration_Int64(
    use: TypeOnly<old.Int64>);
use_old_ClassDeclaration_Int64(
    get_current_ClassDeclaration_Int64());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Int8DataArray": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Int8DataArray():
    TypeOnly<old.Int8DataArray>;
declare function use_current_ClassDeclaration_Int8DataArray(
    use: TypeOnly<current.Int8DataArray>);
use_current_ClassDeclaration_Int8DataArray(
    get_old_ClassDeclaration_Int8DataArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Int8DataArray": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Int8DataArray():
    TypeOnly<current.Int8DataArray>;
declare function use_old_ClassDeclaration_Int8DataArray(
    use: TypeOnly<old.Int8DataArray>);
use_old_ClassDeclaration_Int8DataArray(
    get_current_ClassDeclaration_Int8DataArray());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Integer64": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Integer64():
    TypeOnly<old.Integer64>;
declare function use_current_ClassDeclaration_Integer64(
    use: TypeOnly<current.Integer64>);
use_current_ClassDeclaration_Integer64(
    get_old_ClassDeclaration_Integer64());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Integer64": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Integer64():
    TypeOnly<current.Integer64>;
declare function use_old_ClassDeclaration_Integer64(
    use: TypeOnly<old.Integer64>);
use_old_ClassDeclaration_Integer64(
    get_current_ClassDeclaration_Integer64());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_joinPaths": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_joinPaths():
    TypeOnly<typeof old.joinPaths>;
declare function use_current_FunctionDeclaration_joinPaths(
    use: TypeOnly<typeof current.joinPaths>);
use_current_FunctionDeclaration_joinPaths(
    get_old_FunctionDeclaration_joinPaths());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_joinPaths": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_joinPaths():
    TypeOnly<typeof current.joinPaths>;
declare function use_old_FunctionDeclaration_joinPaths(
    use: TypeOnly<typeof old.joinPaths>);
use_old_FunctionDeclaration_joinPaths(
    get_current_FunctionDeclaration_joinPaths());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_OperationError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_OperationError():
    TypeOnly<old.OperationError>;
declare function use_current_ClassDeclaration_OperationError(
    use: TypeOnly<current.OperationError>);
use_current_ClassDeclaration_OperationError(
    get_old_ClassDeclaration_OperationError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_OperationError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_OperationError():
    TypeOnly<current.OperationError>;
declare function use_old_ClassDeclaration_OperationError(
    use: TypeOnly<old.OperationError>);
use_old_ClassDeclaration_OperationError(
    get_current_ClassDeclaration_OperationError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SortedCollection": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SortedCollection():
    TypeOnly<old.SortedCollection<any>>;
declare function use_current_ClassDeclaration_SortedCollection(
    use: TypeOnly<current.SortedCollection<any>>);
use_current_ClassDeclaration_SortedCollection(
    get_old_ClassDeclaration_SortedCollection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SortedCollection": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SortedCollection():
    TypeOnly<current.SortedCollection<any>>;
declare function use_old_ClassDeclaration_SortedCollection(
    use: TypeOnly<old.SortedCollection<any>>);
use_old_ClassDeclaration_SortedCollection(
    get_current_ClassDeclaration_SortedCollection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_StringDataArray": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_StringDataArray():
    TypeOnly<old.StringDataArray>;
declare function use_current_ClassDeclaration_StringDataArray(
    use: TypeOnly<current.StringDataArray>);
use_current_ClassDeclaration_StringDataArray(
    get_old_ClassDeclaration_StringDataArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_StringDataArray": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_StringDataArray():
    TypeOnly<current.StringDataArray>;
declare function use_old_ClassDeclaration_StringDataArray(
    use: TypeOnly<old.StringDataArray>);
use_old_ClassDeclaration_StringDataArray(
    get_current_ClassDeclaration_StringDataArray());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Uint16DataArray": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Uint16DataArray():
    TypeOnly<old.Uint16DataArray>;
declare function use_current_ClassDeclaration_Uint16DataArray(
    use: TypeOnly<current.Uint16DataArray>);
use_current_ClassDeclaration_Uint16DataArray(
    get_old_ClassDeclaration_Uint16DataArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Uint16DataArray": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Uint16DataArray():
    TypeOnly<current.Uint16DataArray>;
declare function use_old_ClassDeclaration_Uint16DataArray(
    use: TypeOnly<old.Uint16DataArray>);
use_old_ClassDeclaration_Uint16DataArray(
    get_current_ClassDeclaration_Uint16DataArray());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Uint32DataArray": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Uint32DataArray():
    TypeOnly<old.Uint32DataArray>;
declare function use_current_ClassDeclaration_Uint32DataArray(
    use: TypeOnly<current.Uint32DataArray>);
use_current_ClassDeclaration_Uint32DataArray(
    get_old_ClassDeclaration_Uint32DataArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Uint32DataArray": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Uint32DataArray():
    TypeOnly<current.Uint32DataArray>;
declare function use_old_ClassDeclaration_Uint32DataArray(
    use: TypeOnly<old.Uint32DataArray>);
use_old_ClassDeclaration_Uint32DataArray(
    get_current_ClassDeclaration_Uint32DataArray());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Uint64": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Uint64():
    TypeOnly<old.Uint64>;
declare function use_current_ClassDeclaration_Uint64(
    use: TypeOnly<current.Uint64>);
use_current_ClassDeclaration_Uint64(
    get_old_ClassDeclaration_Uint64());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Uint64": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Uint64():
    TypeOnly<current.Uint64>;
declare function use_old_ClassDeclaration_Uint64(
    use: TypeOnly<old.Uint64>);
use_old_ClassDeclaration_Uint64(
    get_current_ClassDeclaration_Uint64());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Uint8DataArray": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Uint8DataArray():
    TypeOnly<old.Uint8DataArray>;
declare function use_current_ClassDeclaration_Uint8DataArray(
    use: TypeOnly<current.Uint8DataArray>);
use_current_ClassDeclaration_Uint8DataArray(
    get_old_ClassDeclaration_Uint8DataArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Uint8DataArray": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Uint8DataArray():
    TypeOnly<current.Uint8DataArray>;
declare function use_old_ClassDeclaration_Uint8DataArray(
    use: TypeOnly<old.Uint8DataArray>);
use_old_ClassDeclaration_Uint8DataArray(
    get_current_ClassDeclaration_Uint8DataArray());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_UniversalDataArray": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_UniversalDataArray():
    TypeOnly<old.UniversalDataArray>;
declare function use_current_ClassDeclaration_UniversalDataArray(
    use: TypeOnly<current.UniversalDataArray>);
use_current_ClassDeclaration_UniversalDataArray(
    get_old_ClassDeclaration_UniversalDataArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_UniversalDataArray": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_UniversalDataArray():
    TypeOnly<current.UniversalDataArray>;
declare function use_old_ClassDeclaration_UniversalDataArray(
    use: TypeOnly<old.UniversalDataArray>);
use_old_ClassDeclaration_UniversalDataArray(
    get_current_ClassDeclaration_UniversalDataArray());
