/*!
 * Copyright (c) Autodesk, Inc. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * @fileoverview Utility class to compute an hash for a given set of variables
 * using the murmur3 hash (see https://code.google.com/p/smhasher/)
 *
 * This is a reimplementation of the original C++ code in JavaScript. The original
 * code is licensed under a MIT license.
 */
(function() {

  var { guidToUint32x4, uint32x4ToGUID } = require('./guid_utils');

  /**
   * Helper class to store the array buffers needed for the hash computation.
   *
   * TODO: should we cache these classes to avoid unnecessary reallocation
   *       of these buffers. Is it worth the effort?
   * @constructor
   */
  var HashBuffer = function() {
    // This is the internal array buffer we are going to use for conversions
    this.hashBuffer = new ArrayBuffer(32);

    this.dataView = new DataView(this.hashBuffer);
    this.Uint8HashArray = new Uint8Array(this.hashBuffer, 0, 32);
    this.Uint32HashArray = new Uint32Array(this.hashBuffer, 0, 8);

    this.pos = 0;
  };

  /**
   * Shifts the buffers forward by 16 bytes
   */
  HashBuffer.prototype.shiftBuffers = function() {
    this.Uint32HashArray[0] = this.Uint32HashArray[4];
    this.Uint32HashArray[1] = this.Uint32HashArray[5];
    this.Uint32HashArray[2] = this.Uint32HashArray[6];
    this.Uint32HashArray[3] = this.Uint32HashArray[7];
    this.Uint32HashArray[4] = 0;
    this.Uint32HashArray[5] = 0;
    this.Uint32HashArray[6] = 0;
    this.Uint32HashArray[7] = 0;
    this.pos -= 16;
  };

  // If available, we use the browser imul function, otherwise we emulate it
  // Emulation code is from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
  // License: public domain, according to https://developer.mozilla.org/en-US/docs/MDN/About#Copyrights_and_licenses:
  //   Code samples added on or after August 20, 2010 are in the public domain.
  //   No licensing notice is necessary, but if you need one, you can use:
  //   "Any copyright is dedicated to the Public Domain.
  //    http://creativecommons.org/publicdomain/zero/1.0/".
  var imul = Math.imul || function(a, b) {
    var ah = (a >>> 16) & 0xffff;
    var al = a & 0xffff;
    var bh = (b >>> 16) & 0xffff;
    var bl = b & 0xffff;
    // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value
    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
  };

  // Helper functions for the hash computation
  /**
   * ROT function required for the hash computation
   *
   * @param {number} x - 32 bit integer
   * @param {number} r - amount to shift
   * @return {number} Rotated 32-bit integer.
   */
  var rotl32 = function(x, r) {
    return (((x << r) >>> 0) | (x >>> (32 - r))) >>> 0;
  };

  /**
   * Mixing function for the finalization
   * @param {number} h - 32 bit integer
   * @return {number} The scrambled 32-bit integer.
   */
  var fmix32 = function(h) {
    h = (h ^ (h >>> 16)) >>> 0;
    h = imul(h, 0x85ebca6b) >>> 0;
    h = (h ^ (h >>> 13)) >>> 0;
    h = imul(h, 0xc2b2ae35) >>> 0;
    h = (h ^ (h >>> 16)) >>> 0;

    return h;
  };


  // Constants
  var c1 = 0x239b961b;
  var c2 = 0xab0e9789;
  var c3 = 0x38b34ae5;
  var c4 = 0xa1e38b93;

  /**
   * Helper class which computes a Murmur3 hash for binary data. The user
   * can successively push data in different binary types into the hash
   * computation function and will then get a hash computed over these fields.
   *
   * NOTE: By default JavaScript uses big-endian byte order. So the hashes
   *       generated by this class might correspond to those generated natively
   *       on a little-endian architecture.
   *
   * @param {number} [in_seed = 1] - Seed value used for the hash computation
   * @constructor
   * @alias property-common.HashCalculator
   * @private
   */
  var HashCalculator = function(in_seed = 1) {
    // Initialize the hash computation with the seed value
    this._h1 = in_seed;
    this._h2 = in_seed;
    this._h3 = in_seed;
    this._h4 = in_seed;
    this.length = 0;
    this.finalized = false;

    this.hashBuffer = new HashBuffer();
  };

  /**
   * Pushes a single unsigned integer with 8 bits into the hash computation
   *
   * @param {number} in_value - The value to push
   */
  HashCalculator.prototype.pushUint8 = function(in_value) {
    this.hashBuffer.dataView.setUint8(this.hashBuffer.pos, in_value);
    this.hashBuffer.pos++;

    if (this.hashBuffer.pos >= 16) {
      this._computeHashFor16ByteBlock();
    }
  };

  /**
   * Pushes a single unsigned integer with 16 bits into the hash computation
   *
   * @param {number} in_value - The value to push
   */
  HashCalculator.prototype.pushUint16 = function(in_value) {
    this.hashBuffer.dataView.setUint16(this.hashBuffer.pos, in_value);
    this.hashBuffer.pos += 2;

    if (this.hashBuffer.pos >= 16) {
      this._computeHashFor16ByteBlock();
    }
  };

  /**
   * Pushes a single unsigned integer with 32 bits into the hash computation
   *
   * @param {number} in_value - The value to push
   */
  HashCalculator.prototype.pushUint32 = function(in_value) {
    this.hashBuffer.dataView.setUint32(this.hashBuffer.pos, in_value);
    this.hashBuffer.pos += 4;

    if (this.hashBuffer.pos >= 16) {
      this._computeHashFor16ByteBlock();
    }
  };

  /**
   * Pushes a single signed integer with 8 bits into the hash computation
   *
   * @param {number} in_value - The value to push
   */
  HashCalculator.prototype.pushInt8 = function(in_value) {
    this.hashBuffer.dataView.setInt8(this.hashBuffer.pos, in_value);
    this.hashBuffer.pos++;
    if (this.hashBuffer.pos >= 16) {
      this._computeHashFor16ByteBlock();
    }
  };

  /**
   * Pushes a single signed integer with 16 bits into the hash computation
   *
   * @param {number} in_value - The value to push
   */
  HashCalculator.prototype.pushInt16 = function(in_value) {
    this.hashBuffer.dataView.setInt16(this.hashBuffer.pos, in_value);
    this.hashBuffer.pos += 2;

    if (this.hashBuffer.pos >= 16) {
      this._computeHashFor16ByteBlock();
    }
  };

  /**
   * Pushes a single signed integer with 32 bits into the hash computation
   *
   * @param {number} in_value - The value to push
   */
  HashCalculator.prototype.pushInt32 = function(in_value) {
    this.hashBuffer.dataView.setInt32(this.hashBuffer.pos, in_value);
    this.hashBuffer.pos += 4;

    if (this.hashBuffer.pos >= 16) {
      this._computeHashFor16ByteBlock();
    }
  };

  /**
   * Pushes a single float with 32 bits into the hash computation
   *
   * @param {number} in_value - The value to push
   */
  HashCalculator.prototype.pushFloat32 = function(in_value) {
    this.hashBuffer.dataView.setFloat32(this.hashBuffer.pos, in_value);
    this.hashBuffer.pos += 4;

    if (this.hashBuffer.pos >= 16) {
      this._computeHashFor16ByteBlock();
    }
  };

  /**
   * Pushes a single float with 64 bits into the hash computation
   *
   * @param {number} in_value - The value to push
   */
  HashCalculator.prototype.pushFloat64 = function(in_value) {
    this.hashBuffer.dataView.setFloat64(this.hashBuffer.pos, in_value);
    this.hashBuffer.pos += 8;

    if (this.hashBuffer.pos >= 16) {
      this._computeHashFor16ByteBlock();
    }
  };

  /**
   * Pushes a GUID into the hash computation
   *
   * @param {string} in_guid - The value to push
   */
  HashCalculator.prototype.pushGUID = function(in_guid) {
    // Parse the GUID
    var array = guidToUint32x4(in_guid);

    // Add it as a uint32 values
    this.pushArray(array, HashCalculator.Type.Uint32);
  };

  /**
   * Pushes a string into the hash computation
   *
   * @param {string} in_string - The value to push
   */
  HashCalculator.prototype.pushString = function(in_string) {

    // Push each character individually. We have to use uin16 here, as
    // JavaScript strings are UTF16
    for (var i = 0; i < in_string.length; i++) {
      this.pushUint16(in_string.charCodeAt(i));
    }
  };

  /**
   * The type to use when pushing values
   * @enum
   */
  HashCalculator.Type = {};

  /** Signed integer with 8 bits */
  HashCalculator.Type.Int8    = 0;
  /** Signed integer with 16 bits */
  HashCalculator.Type.Int16   = 1;
  /** Signed integer with 32 bits */
  HashCalculator.Type.Int32   = 2;
  /** Unsigned integer with 8 bits */
  HashCalculator.Type.Uint8   = 3;
  /** Unsigned integer with 16 bits */
  HashCalculator.Type.Uint16  = 4;
  /** Unsigned integer with 32 bits */
  HashCalculator.Type.Uint32  = 5;
  /** Floating point value with 32 bits */
  HashCalculator.Type.Float32 = 6;
  /** Floating point value with 64 bits */
  HashCalculator.Type.Float64 = 7;

  var _pushFunctions = [
    HashCalculator.prototype.pushInt8,
    HashCalculator.prototype.pushInt16,
    HashCalculator.prototype.pushInt32,
    HashCalculator.prototype.pushUint8,
    HashCalculator.prototype.pushUint16,
    HashCalculator.prototype.pushUint32,
    HashCalculator.prototype.pushFloat32,
    HashCalculator.prototype.pushFloat64
  ];

  /**
   * Pushes an array into the hash computation
   *
   * @param {number| TypedArray}             array  - The array to include in the hash computation
   * @param {HashCalculator.Type} type - The type to use to compute the hash
   * @param {number}                       [count] - The number of entries to include in the computation.
   *                                                 If not supplied the whole array will be used
   */
  HashCalculator.prototype.pushArray = function(array, type, count) {
    var pushFun = _pushFunctions[type];
    count = count !== undefined ? count : array.length;

    for (var i = 0; i < count; i++) {
      pushFun.call(this, array[i]);
    }
  };

  /**
   * @return {string} the computed Hash
   * Note: after calling this function you no longer may push more data!
   */
  HashCalculator.prototype.getHash = function() {
    if (!this.finalized) {
      this._finalizeHash();
    }

    // Convert the hash to a string
    return uint32x4ToGUID([this._h1, this._h2, this._h3, this._h4]);
  };

  /**
   * Computes the murmur3 hash for a block of 16 bytes
   * @private
   */
  HashCalculator.prototype._computeHashFor16ByteBlock = function() {
    var k1 = this.hashBuffer.Uint32HashArray[0];
    var k2 = this.hashBuffer.Uint32HashArray[1];
    var k3 = this.hashBuffer.Uint32HashArray[2];
    var k4 = this.hashBuffer.Uint32HashArray[3];
    this.hashBuffer.shiftBuffers();

    k1 = imul(k1, c1) >>> 0; k1 = rotl32(k1, 15); k1 = imul(k1, c2) >>> 0; this._h1 = (this._h1 ^ k1) >>> 0;
    this._h1 = rotl32(this._h1, 19);
    this._h1 = (this._h1 + this._h2) >>> 0;
    this._h1 = ((imul(this._h1, 5) >>> 0) + 0x561ccd1b) >>> 0;

    k2 = imul(k2, c2) >>> 0; k2 = rotl32(k2, 16); k2 = imul(k2, c3) >>> 0; this._h2 = (this._h2 ^ k2) >>> 0;
    this._h2 = rotl32(this._h2, 17);
    this._h2 = (this._h2 + this._h3) >>> 0;
    this._h2 = ((imul(this._h2, 5) >>> 0) + 0x0bcaa747) >>> 0;

    k3 = imul(k3, c3) >>> 0; k3 = rotl32(k3, 17); k3 = imul(k3, c4) >>> 0; this._h3 = (this._h3 ^ k3) >>> 0;
    this._h3 = rotl32(this._h3, 15);
    this._h3 = (this._h3 + this._h4) >>> 0;
    this._h3 = ((imul(this._h3, 5) >>> 0) + 0x96cd1c35) >>> 0;

    k4 = imul(k4, c4) >>> 0; k4 = rotl32(k4, 18); k4 = imul(k4, c1) >>> 0; this._h4 = (this._h4 ^ k4) >>> 0;
    this._h4 = rotl32(this._h4, 13);
    this._h4 = (this._h4 + this._h1) >>> 0;
    this._h4 = ((imul(this._h4, 5) >>> 0) + 0x32ac3b17) >>> 0;

    this.length += 16;
  };

  /**
   * Finalizes the hash computation
   * @private
   */
  HashCalculator.prototype._finalizeHash = function() {
    var k1 = 0;
    var k2 = 0;
    var k3 = 0;
    var k4 = 0;

    // Compute the hash for the remaining bytes in the buffer
    var buffer = this.hashBuffer.Uint8HashArray;
    /* eslint-disable no-fallthrough */  // Allows cases to fallthrough without complaints.
    switch (this.hashBuffer.pos) {

      case 15: k4 = (k4 ^ (buffer[14] << 16)) >>> 0;
      case 14: k4 = (k4 ^ (buffer[13] << 8)) >>> 0;
      case 13: k4 = (k4 ^ (buffer[12] << 0)) >>> 0;
        k4 = imul(k4, c4) >>> 0;
        k4 = rotl32(k4, 18);
        k4 = imul(k4, c1) >>> 0;
        this._h4 = (this._h4 ^ k4) >>> 0;

      case 12: k3 = (k3 ^ (buffer[11] << 24)) >>> 0;
      case 11: k3 = (k3 ^ (buffer[10] << 16)) >>> 0;
      case 10: k3 = (k3 ^ (buffer[ 9] << 8)) >>> 0;
      case  9: k3 = (k3 ^ (buffer[ 8] << 0)) >>> 0;
        k3 = imul(k3, c3) >>> 0;
        k3 = rotl32(k3, 17);
        k3 = imul(k3, c4) >>> 0;
        this._h3 = (this._h3 ^ k3) >>> 0;

      case  8: k2 = (k2 ^ (buffer[ 7] << 24)) >>> 0;
      case  7: k2 = (k2 ^ (buffer[ 6] << 16)) >>> 0;
      case  6: k2 = (k2 ^ (buffer[ 5] << 8)) >>> 0;
      case  5: k2 = (k2 ^ (buffer[ 4] << 0)) >>> 0;
        k2 = imul(k2, c2) >>> 0;
        k2 = rotl32(k2, 16);
        k2 = imul(k2, c3) >>> 0;
        this._h2 = (this._h2 ^ k2) >>> 0;

      case  4: k1 = (k1 ^ (buffer[ 3] << 24)) >>> 0;
      case  3: k1 = (k1 ^ (buffer[ 2] << 16)) >>> 0;
      case  2: k1 = (k1 ^ (buffer[ 1] << 8)) >>> 0;
      case  1: k1 = (k1 ^ (buffer[ 0] << 0)) >>> 0;
        k1 = imul(k1, c1) >>> 0;
        k1 = rotl32(k1, 15);
        k1 = imul(k1, c2) >>> 0;
        this._h1 = (this._h1 ^ k1) >>> 0;
        break;
      case  0:
        // Bug fix for previously unhandled condition
        break;

      default:
        throw new Error('_finalizeHash: We should never get into the default case.');
    }
    /* eslint-enable no-fallthrough */

    // Perform the finalization
    var len = this.length + this.hashBuffer.pos;
    this._h1 = (this._h1 ^ len) >>> 0;
    this._h2 = (this._h2 ^ len) >>> 0;
    this._h3 = (this._h3 ^ len) >>> 0;
    this._h4 = (this._h4 ^ len) >>> 0;

    this._h1 = (this._h1 + this._h2) >>> 0;
    this._h1 = (this._h1 + this._h3) >>> 0;
    this._h1 = (this._h1 + this._h4) >>> 0;
    this._h2 = (this._h2 + this._h1) >>> 0;
    this._h3 = (this._h3 + this._h1) >>> 0;
    this._h4 = (this._h4 + this._h1) >>> 0;

    this._h1 = fmix32(this._h1);
    this._h2 = fmix32(this._h2);
    this._h3 = fmix32(this._h3);
    this._h4 = fmix32(this._h4);

    this._h1 = (this._h1 + this._h2) >>> 0;
    this._h1 = (this._h1 + this._h3) >>> 0;
    this._h1 = (this._h1 + this._h4) >>> 0;

    this._h2 = (this._h2 + this._h1) >>> 0;
    this._h3 = (this._h3 + this._h1) >>> 0;
    this._h4 = (this._h4 + this._h1) >>> 0;

    this.finalized = true;
  };

  /**
   * Computes a hash for a 32 bit unsigned int value (using the FNV-1a algorithm
   * see http://www.isthe.com/chongo/tech/comp/fnv/)
   *
   * @param {number} in_value - 32 bit unsigned integer for which the hash is computed
   * @param {number} in_seed - result from a previous hash to chain the hash computation
   * @return {number} the computed hash key
   */
  var UINT_32HASH_PRIME = 16777619;
  var UINT_32HASH_OFFSET = 2166136261;

  var fNV1aHashUint32 = function(in_value, in_seed) {
    var result = UINT_32HASH_OFFSET;
    if (in_seed) {
      result = ((result ^ in_seed) * UINT_32HASH_PRIME) >>> 0;
    }

    result = (((result ^ (in_value & 0xFF)) >>> 0) * UINT_32HASH_PRIME) >>> 0;
    result = (((result ^ ((in_value >> 8) & 0xFF)) >>> 0) * UINT_32HASH_PRIME) >>> 0;
    result = (((result ^ ((in_value >> 16) & 0xFF)) >>> 0) * UINT_32HASH_PRIME) >>> 0;
    result = (((result ^ ((in_value >> 24) & 0xFF)) >>> 0) * UINT_32HASH_PRIME) >>> 0;
    return result;
  };

  /**
   * Compute a new 32-bit hash from a previous 32-bit hash and a new 32-bit "delta hash".
   * This function can be also be used for (slow) high quality hash combine of 32-bit numbers.
   *
   * @param {number} in_newDeltaHash - the new hasH
   * @param {number} in_previousHash - the previous hash
   * @return {number} the computed hash key
   * @alias property-common.incrementalHashUint32
   */
  var incrementalHashUint32 = function(in_newDeltaHash, in_previousHash) {
    return fNV1aHashUint32(in_newDeltaHash, in_previousHash);
  };

  /**
   * Compute a new hash array from a previous hash and a new "delta hash".
   * All hashes are assumed to be 4 x 32-bit uint arrays.
   * This function can be also be used for (slow) high quality hash combines.
   *
   * @param {Uint32Array | Array.<number>}  in_newDeltaHash - the new hash array
   * @param {Uint32Array | Array.<number>}  in_previousHash - the previous hash array
   * @param {Uint32Array | Array.<number>} io_result - the computed hash key is returned
   *                                                   through this parameter if specified.
   * @return {Uint32Array | Array.<number>}  the computed hash key
   * @alias property-common.incrementalHash4xUint32
   */
  var incrementalHash4xUint32 = function(in_newDeltaHash, in_previousHash, io_result) {
    var accumulated = io_result;
    if (accumulated === undefined) {
      accumulated = new Uint32Array(4);
    }

    accumulated[0] = fNV1aHashUint32(in_newDeltaHash[0], in_previousHash[0]);
    accumulated[0] = fNV1aHashUint32(in_newDeltaHash[1], accumulated[0]);
    accumulated[0] = fNV1aHashUint32(in_newDeltaHash[2], accumulated[0]);
    accumulated[0] = fNV1aHashUint32(in_newDeltaHash[3], accumulated[0]);

    accumulated[1] = fNV1aHashUint32(in_newDeltaHash[0], in_previousHash[1]);
    accumulated[1] = fNV1aHashUint32(in_newDeltaHash[1], accumulated[1]);
    accumulated[1] = fNV1aHashUint32(in_newDeltaHash[2], accumulated[1]);
    accumulated[1] = fNV1aHashUint32(in_newDeltaHash[3], accumulated[1]);

    accumulated[2] = fNV1aHashUint32(in_newDeltaHash[0], in_previousHash[2]);
    accumulated[2] = fNV1aHashUint32(in_newDeltaHash[1], accumulated[2]);
    accumulated[2] = fNV1aHashUint32(in_newDeltaHash[2], accumulated[2]);
    accumulated[2] = fNV1aHashUint32(in_newDeltaHash[3], accumulated[2]);

    accumulated[3] = fNV1aHashUint32(in_newDeltaHash[0], in_previousHash[3]);
    accumulated[3] = fNV1aHashUint32(in_newDeltaHash[1], accumulated[3]);
    accumulated[3] = fNV1aHashUint32(in_newDeltaHash[2], accumulated[3]);
    accumulated[3] = fNV1aHashUint32(in_newDeltaHash[3], accumulated[3]);

    return accumulated;
  };

  /**
   * Performs a hash combination operation on the two supplied Uint32 arrays of length 4 (using
   * a variant of the algorithm from boost::hash_combine
   *
   * @param {Uint32Array | Array.<number>} in_array1 - first hash array
   * @param {Uint32Array | Array.<number>} in_array2 - second hash array
   * @param {Uint32Array | Array.<number>} [io_result] optional array to write to
   *
   * @return {Uint32Array | Array.<number>}
   * @alias property-common.hashCombine4xUint32
   */

  var hashCombine4xUint32 = function(in_array1, in_array2, io_result) {

    var accumulated = io_result;
    if (accumulated === undefined) {
      accumulated = new Uint32Array(in_array2);
    } else {
      accumulated[0] = in_array2[0];
      accumulated[1] = in_array2[1];
      accumulated[2] = in_array2[2];
      accumulated[3] = in_array2[3];
    }

    accumulated[0] += 0x9e3779b9;
    accumulated[1] += 0x638f227;
    accumulated[2] += 0x1aff2bad;
    accumulated[3] += 0x3a8f05c5;

    accumulated[0] += in_array1[3] << 6;
    accumulated[1] += in_array1[0] << 6;
    accumulated[2] += in_array1[1] << 6;
    accumulated[3] += in_array1[2] << 6;

    accumulated[0] += in_array1[2] >> 2;
    accumulated[1] += in_array1[3] >> 2;
    accumulated[2] += in_array1[0] >> 2;
    accumulated[3] += in_array1[1] >> 2;

    accumulated[0] = ((accumulated[0] ^ in_array1[1]) * UINT_32HASH_PRIME) >>> 0;
    accumulated[1] = ((accumulated[1] ^ in_array1[2]) * UINT_32HASH_PRIME) >>> 0;
    accumulated[2] = ((accumulated[2] ^ in_array1[3]) * UINT_32HASH_PRIME) >>> 0;
    accumulated[3] = ((accumulated[3] ^ in_array1[0]) * UINT_32HASH_PRIME) >>> 0;

    return accumulated;
  };

  module.exports = { incrementalHashUint32, incrementalHash4xUint32, hashCombine4xUint32, HashCalculator };

})();
