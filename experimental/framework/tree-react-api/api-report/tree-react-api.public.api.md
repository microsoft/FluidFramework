## Public API Report File for "@fluid-experimental/tree-react-api"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export interface IReactTreeDataObject<TSchema extends ImplicitFieldSchema> {
    readonly config: TreeViewConfiguration<TSchema>;
    readonly treeView: TreeView<TSchema>;
    readonly TreeViewComponent: (props: TreeViewProps<TSchema>) => React_2.JSX.Element;
}

// @public
export type NodeRecord = Record<string, TreeNode | TreeLeafValue>;

// @public
export function objectIdNumber(object: object): number;

// @public
export interface PropTreeNode<T extends TreeNode> extends ErasedType<[T, "PropTreeNode"]> {
}

// @public
export type PropTreeNodeRecord = Record<string, TreeLeafValue | PropTreeNode<TreeNode> | undefined>;

// @public
export type PropTreeValue<T extends TreeNode | TreeLeafValue | undefined> = T extends TreeNode ? PropTreeNode<T> : T;

// @public
export interface SchemaIncompatibleProps {
    readonly compatibility: SchemaCompatibilityStatus;
    readonly upgradeSchema: () => void;
}

// @public
export function toPropTreeNode<T extends TreeNode | TreeLeafValue>(node: T): PropTreeValue<T>;

// @public
export function toPropTreeRecord<T extends NodeRecord>(node: T): WrapPropTreeNodeRecord<T>;

// @public
export function treeDataObject<TSchema extends ImplicitFieldSchema>(treeConfiguration: TreeViewConfiguration<TSchema>, createInitialTree: () => InsertableTreeFieldFromImplicitField<TSchema>): SharedObjectKind<IReactTreeDataObject<TSchema> & IFluidLoadable>;

// @public
export function TreeViewComponent<TSchema extends ImplicitFieldSchema>({ tree, ViewComponent, ErrorComponent, }: TreeViewProps<TSchema> & {
    tree: Pick<IReactTreeDataObject<TSchema>, "treeView">;
}): React_2.JSX.Element;

// @public
export interface TreeViewProps<TSchema extends ImplicitFieldSchema> {
    readonly ErrorComponent?: React_2.FC<SchemaIncompatibleProps>;
    readonly ViewComponent: React_2.FC<{
        root: PropTreeValue<TreeFieldFromImplicitField<TSchema>>;
    }>;
}

// @public
export type UnwrapPropTreeNode<T extends TreeLeafValue | PropTreeNode<TreeNode> | undefined> = T extends PropTreeNode<infer Node> ? Node : T;

// @public
export function unwrapPropTreeNode<T extends TreeNode | TreeLeafValue>(propNode: PropTreeValue<T> | T): T;

// @public
export type UnwrapPropTreeNodeRecord<T extends PropTreeNodeRecord> = {
    readonly [P in keyof T]: UnwrapPropTreeNode<T[P]>;
};

// @public
export function unwrapPropTreeRecord<T extends PropTreeNodeRecord>(props: T): UnwrapPropTreeNodeRecord<T>;

// @public
export function usePropTreeNode<T extends TreeNode | TreeLeafValue, TResult>(propNode: PropTreeValue<T> | T, trackDuring: (node: T) => TResult): WrapNodes<TResult>;

// @public
export function usePropTreeRecord<const T extends PropTreeNodeRecord, TResult>(props: T, f: (node: UnwrapPropTreeNodeRecord<T>) => TResult): WrapNodes<TResult>;

// @public
export function useTree(subtreeRoot: TreeNode): number;

// @public
export function useTreeObservations<TResult>(trackDuring: () => TResult, onInvalidation?: () => void): TResult;

// @public
export function withTreeObservations<TIn>(component: React_2.FC<TIn>, onInvalidation?: () => void): React_2.FC<TIn | WrapNodes<TIn>>;

// @public
export type WrapNodes<T> = T extends TreeNode ? PropTreeNode<T> : T extends readonly (infer U)[] ? readonly WrapNodes<U>[] : T extends NodeRecord ? WrapPropTreeNodeRecord<T> : T;

// @public
export type WrapPropTreeNodeRecord<T extends NodeRecord> = {
    readonly [P in keyof T]: PropTreeValue<T[P]>;
};

```
