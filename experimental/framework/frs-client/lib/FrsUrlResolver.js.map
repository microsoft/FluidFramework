{"version":3,"file":"FrsUrlResolver.js","sourceRoot":"","sources":["../src/FrsUrlResolver.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAMH,qFAAqF;AACrF,sFAAsF;AACtF,8FAA8F;AAC9F,2BAA2B;AAC3B,MAAM,OAAO,cAAc;IACvB,YACqB,QAAgB,EAChB,OAAe,EACf,OAAe,EACf,UAAkB,EAClB,aAA6B;QAJ7B,aAAQ,GAAR,QAAQ,CAAQ;QAChB,YAAO,GAAP,OAAO,CAAQ;QACf,YAAO,GAAP,OAAO,CAAQ;QACf,eAAU,GAAV,UAAU,CAAQ;QAClB,kBAAa,GAAb,aAAa,CAAgB;IAC9C,CAAC;IAEE,KAAK,CAAC,OAAO,CAAC,OAAiB;QAClC,MAAM,WAAW,GAAG,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAC9C,MAAM,KAAK,GAAG,CAAC,MAAM,IAAI,CAAC,aAAa,CAAC,iBAAiB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC;QAC/F,MAAM,WAAW,GAAG,GAAG,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,IAAI,WAAW,EAAE,CAAC;QACtE,OAAO,OAAO,CAAC,OAAO,CAAC;YACnB,SAAS,EAAE;gBACP,eAAe,EAAE,GAAG,IAAI,CAAC,OAAO,WAAW,IAAI,CAAC,QAAQ,IAAI,WAAW,EAAE;gBACzE,UAAU,EAAE,GAAG,IAAI,CAAC,OAAO,EAAE;gBAC7B,UAAU,EAAE,GAAG,IAAI,CAAC,OAAO,UAAU,IAAI,CAAC,QAAQ,EAAE;aACvD;YACD,EAAE,EAAE,WAAW;YACf,MAAM,EAAE,EAAE,GAAG,EAAE,KAAK,EAAE;YACtB,IAAI,EAAE,OAAO;YACb,GAAG,EAAE,WAAW;SACnB,CAAC,CAAC;IACP,CAAC;IACM,KAAK,CAAC,cAAc,CAAC,WAAyB,EAAE,WAAmB;QACtE,IAAI,WAAW,CAAC,IAAI,KAAK,OAAO,EAAE;YAC9B,MAAM,KAAK,CAAC,sBAAsB,CAAC,CAAC;SACvC;QACD,OAAO,GAAG,WAAW,CAAC,GAAG,IAAI,WAAW,EAAE,CAAC;IAC/C,CAAC;CACJ","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IRequest } from \"@fluidframework/core-interfaces\";\nimport { IUrlResolver, IFluidResolvedUrl, IResolvedUrl } from \"@fluidframework/driver-definitions\";\nimport { ITokenProvider } from \"@fluidframework/routerlicious-driver\";\n\n// Implementation of a URL resolver to resolve documents stored using the FRS service\n// based off of the orderer and storage URLs provide. The token provider here can be a\n// InsecureTokenProvider for basic scenarios or more robust, secure providers that fulfill the\n// ITokenProvider interface\nexport class FrsUrlResolver implements IUrlResolver {\n    constructor(\n        private readonly tenantId: string,\n        private readonly orderer: string,\n        private readonly storage: string,\n        private readonly documentId: string,\n        private readonly tokenProvider: ITokenProvider,\n    ) { }\n\n    public async resolve(request: IRequest): Promise<IFluidResolvedUrl> {\n        const containerId = request.url.split(\"/\")[0];\n        const token = (await this.tokenProvider.fetchOrdererToken(this.tenantId, this.documentId)).jwt;\n        const documentUrl = `${this.orderer}/${this.tenantId}/${containerId}`;\n        return Promise.resolve({\n            endpoints: {\n                deltaStorageUrl: `${this.orderer}/deltas/${this.tenantId}/${containerId}`,\n                ordererUrl: `${this.orderer}`,\n                storageUrl: `${this.storage}/repos/${this.tenantId}`,\n            },\n            id: containerId,\n            tokens: { jwt: token },\n            type: \"fluid\",\n            url: documentUrl,\n        });\n    }\n    public async getAbsoluteUrl(resolvedUrl: IResolvedUrl, relativeUrl: string): Promise<string> {\n        if (resolvedUrl.type !== \"fluid\") {\n            throw Error(\"Invalid Resolved Url\");\n        }\n        return `${resolvedUrl.url}/${relativeUrl}`;\n    }\n}\n"]}