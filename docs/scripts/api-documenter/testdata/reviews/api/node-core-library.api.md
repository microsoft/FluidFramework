## API Report File for "@rushstack/node-core-library"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as child_process from 'child_process';
import * as fs from 'fs';

// @public
export const enum AlreadyExistsBehavior {
    Error = "error",
    Ignore = "ignore",
    Overwrite = "overwrite"
}

// @beta
export class Colors {
    // (undocumented)
    static black(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static blackBackground(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static blink(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static blue(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static blueBackground(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static bold(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static cyan(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static cyanBackground(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static dim(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static gray(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static grayBackground(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static green(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static greenBackground(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static hidden(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static invertColor(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static magenta(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static magentaBackground(text: string | IColorableSequence): IColorableSequence;
    // @internal
    static _normalizeStringOrColorableSequence(value: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static red(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static redBackground(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static underline(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static white(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static whiteBackground(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static yellow(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static yellowBackground(text: string | IColorableSequence): IColorableSequence;
}

// @beta
export enum ColorValue {
    // (undocumented)
    Black = 0,
    // (undocumented)
    Blue = 4,
    // (undocumented)
    Cyan = 6,
    // (undocumented)
    Gray = 8,
    // (undocumented)
    Green = 2,
    // (undocumented)
    Magenta = 5,
    // (undocumented)
    Red = 1,
    // (undocumented)
    White = 7,
    // (undocumented)
    Yellow = 3
}

// @beta
export class ConsoleTerminalProvider implements ITerminalProvider {
    constructor(options?: Partial<IConsoleTerminalProviderOptions>);
    readonly eolCharacter: string;
    readonly supportsColor: boolean;
    verboseEnabled: boolean;
    write(data: string, severity: TerminalProviderSeverity): void;
}

// @public
export const enum Encoding {
    // (undocumented)
    Utf8 = "utf8"
}

// @public
export class Executable {
    static spawnSync(filename: string, args: string[], options?: IExecutableSpawnSyncOptions): child_process.SpawnSyncReturns<string>;
    static tryResolve(filename: string, options?: IExecutableResolveOptions): string | undefined;
    }

// @public
export type ExecutableStdioMapping = 'pipe' | 'ignore' | 'inherit' | ExecutableStdioStreamMapping[];

// @public
export type ExecutableStdioStreamMapping = 'pipe' | 'ignore' | 'inherit' | NodeJS.WritableStream | NodeJS.ReadableStream | number | undefined;

// @public
export const enum FileConstants {
    PackageJson = "package.json"
}

// @public
export class FileSystem {
    static appendToFile(filePath: string, contents: string | Buffer, options?: IFileSystemWriteFileOptions): void;
    static appendToFileAsync(filePath: string, contents: string | Buffer, options?: IFileSystemWriteFileOptions): Promise<void>;
    static changePosixModeBits(path: string, mode: PosixModeBits): void;
    static changePosixModeBitsAsync(path: string, mode: PosixModeBits): Promise<void>;
    static copyFile(options: IFileSystemCopyFileOptions): void;
    static copyFileAsync(options: IFileSystemCopyFileOptions): Promise<void>;
    static copyFiles(options: IFileSystemCopyFilesOptions): void;
    static copyFilesAsync(options: IFileSystemCopyFilesOptions): Promise<void>;
    static createHardLink(options: IFileSystemCreateLinkOptions): void;
    static createHardLinkAsync(options: IFileSystemCreateLinkOptions): Promise<void>;
    static createSymbolicLinkFile(options: IFileSystemCreateLinkOptions): void;
    static createSymbolicLinkFileAsync(options: IFileSystemCreateLinkOptions): Promise<void>;
    static createSymbolicLinkFolder(options: IFileSystemCreateLinkOptions): void;
    static createSymbolicLinkFolderAsync(options: IFileSystemCreateLinkOptions): Promise<void>;
    static createSymbolicLinkJunction(options: IFileSystemCreateLinkOptions): void;
    static createSymbolicLinkJunctionAsync(options: IFileSystemCreateLinkOptions): Promise<void>;
    static deleteFile(filePath: string, options?: IFileSystemDeleteFileOptions): void;
    static deleteFileAsync(filePath: string, options?: IFileSystemDeleteFileOptions): Promise<void>;
    static deleteFolder(folderPath: string): void;
    static deleteFolderAsync(folderPath: string): Promise<void>;
    static ensureEmptyFolder(folderPath: string): void;
    static ensureEmptyFolderAsync(folderPath: string): Promise<void>;
    static ensureFolder(folderPath: string): void;
    static ensureFolderAsync(folderPath: string): Promise<void>;
    static exists(path: string): boolean;
    static formatPosixModeBits(modeBits: PosixModeBits): string;
    static getLinkStatistics(path: string): FileSystemStats;
    static getLinkStatisticsAsync(path: string): Promise<FileSystemStats>;
    static getPosixModeBits(path: string): PosixModeBits;
    static getPosixModeBitsAsync(path: string): Promise<PosixModeBits>;
    static getRealPath(linkPath: string): string;
    static getRealPathAsync(linkPath: string): Promise<string>;
    static getStatistics(path: string): FileSystemStats;
    static getStatisticsAsync(path: string): Promise<FileSystemStats>;
    static isErrnoException(error: Error): error is NodeJS.ErrnoException;
    static isFileDoesNotExistError(error: Error): boolean;
    static isFolderDoesNotExistError(error: Error): boolean;
    static isNotExistError(error: Error): boolean;
    static move(options: IFileSystemMoveOptions): void;
    static moveAsync(options: IFileSystemMoveOptions): Promise<void>;
    static readFile(filePath: string, options?: IFileSystemReadFileOptions): string;
    static readFileAsync(filePath: string, options?: IFileSystemReadFileOptions): Promise<string>;
    static readFileToBuffer(filePath: string): Buffer;
    static readFileToBufferAsync(filePath: string): Promise<Buffer>;
    static readFolder(folderPath: string, options?: IFileSystemReadFolderOptions): string[];
    static readFolderAsync(folderPath: string, options?: IFileSystemReadFolderOptions): Promise<string[]>;
    static readLink(path: string): string;
    static readLinkAsync(path: string): Promise<string>;
    static updateTimes(path: string, times: IFileSystemUpdateTimeParameters): void;
    static updateTimesAsync(path: string, times: IFileSystemUpdateTimeParameters): Promise<void>;
    static writeFile(filePath: string, contents: string | Buffer, options?: IFileSystemWriteFileOptions): void;
    static writeFileAsync(filePath: string, contents: string | Buffer, options?: IFileSystemWriteFileOptions): Promise<void>;
}

// @public
export type FileSystemCopyFilesAsyncFilter = (sourcePath: string, destinationPath: string) => Promise<boolean>;

// @public
export type FileSystemCopyFilesFilter = (sourcePath: string, destinationPath: string) => boolean;

// @public
export type FileSystemStats = fs.Stats;

// @public
export class FileWriter {
    close(): void;
    static open(path: string, flags?: IFileWriterFlags): FileWriter;
    write(text: string): void;
}

// @public
export const enum FolderConstants {
    Git = ".git",
    NodeModules = "node_modules"
}

// @beta (undocumented)
export interface IColorableSequence {
    // (undocumented)
    backgroundColor?: ColorValue;
    // (undocumented)
    foregroundColor?: ColorValue;
    // (undocumented)
    isEol?: boolean;
    // (undocumented)
    text: string;
    // (undocumented)
    textAttributes?: TextAttribute[];
}

// @beta
export interface IConsoleTerminalProviderOptions {
    verboseEnabled: boolean;
}

// @public
export interface IExecutableResolveOptions {
    currentWorkingDirectory?: string;
    environment?: NodeJS.ProcessEnv;
}

// @public
export interface IExecutableSpawnSyncOptions extends IExecutableResolveOptions {
    input?: string;
    maxBuffer?: number;
    stdio?: ExecutableStdioMapping;
    timeoutMs?: number;
}

// @public
export interface IFileSystemCopyFileOptions {
    alreadyExistsBehavior?: AlreadyExistsBehavior;
    destinationPath: string;
    sourcePath: string;
}

// @public
export interface IFileSystemCopyFilesAsyncOptions {
    alreadyExistsBehavior?: AlreadyExistsBehavior;
    dereferenceSymlinks?: boolean;
    destinationPath: string;
    filter?: FileSystemCopyFilesAsyncFilter | FileSystemCopyFilesFilter;
    preserveTimestamps?: boolean;
    sourcePath: string;
}

// @public
export interface IFileSystemCopyFilesOptions extends IFileSystemCopyFilesAsyncOptions {
    filter?: FileSystemCopyFilesFilter;
}

// @public
export interface IFileSystemCreateLinkOptions {
    linkTargetPath: string;
    newLinkPath: string;
}

// @public
export interface IFileSystemDeleteFileOptions {
    throwIfNotExists?: boolean;
}

// @public
export interface IFileSystemMoveOptions {
    destinationPath: string;
    ensureFolderExists?: boolean;
    overwrite?: boolean;
    sourcePath: string;
}

// @public
export interface IFileSystemReadFileOptions {
    convertLineEndings?: NewlineKind;
    encoding?: Encoding;
}

// @public
export interface IFileSystemReadFolderOptions {
    absolutePaths?: boolean;
}

// @public
export interface IFileSystemUpdateTimeParameters {
    accessedTime: number | Date;
    modifiedTime: number | Date;
}

// @public
export interface IFileSystemWriteFileOptions {
    convertLineEndings?: NewlineKind;
    encoding?: Encoding;
    ensureFolderExists?: boolean;
}

// @public
export interface IFileWriterFlags {
    append?: boolean;
    exclusive?: boolean;
}

// @public
export interface IJsonFileSaveOptions extends IJsonFileStringifyOptions {
    ensureFolderExists?: boolean;
    onlyIfChanged?: boolean;
    updateExistingFile?: boolean;
}

// @public
export interface IJsonFileStringifyOptions {
    headerComment?: string;
    newlineConversion?: NewlineKind;
    prettyFormatting?: boolean;
}

// @public
export interface IJsonSchemaErrorInfo {
    details: string;
}

// @public
export interface IJsonSchemaFromFileOptions {
    dependentSchemas?: JsonSchema[];
}

// @public
export interface IJsonSchemaValidateOptions {
    customErrorHeader?: string;
}

// @public
export interface INodePackageJson {
    bin?: string;
    dependencies?: IPackageJsonDependencyTable;
    description?: string;
    devDependencies?: IPackageJsonDependencyTable;
    homepage?: string;
    license?: string;
    main?: string;
    name: string;
    optionalDependencies?: IPackageJsonDependencyTable;
    peerDependencies?: IPackageJsonDependencyTable;
    private?: boolean;
    repository?: string;
    scripts?: IPackageJsonScriptTable;
    // @beta
    tsdocMetadata?: string;
    types?: string;
    typings?: string;
    version?: string;
}

// @public
export class InternalError extends Error {
    constructor(message: string);
    static breakInDebugger: boolean;
    // @override (undocumented)
    toString(): string;
    readonly unformattedMessage: string;
}

// @public
export interface IPackageJson extends INodePackageJson {
    version: string;
}

// @public
export interface IPackageJsonDependencyTable {
    [dependencyName: string]: string;
}

// @public
export interface IPackageJsonLookupParameters {
    loadExtraFields?: boolean;
}

// @public
export interface IPackageJsonScriptTable {
    [scriptName: string]: string;
}

// @public
export interface IPackageNameParserOptions {
    allowUpperCase?: boolean;
}

// @public
export interface IParsedPackageName {
    scope: string;
    unscopedName: string;
}

// @public
export interface IParsedPackageNameOrError extends IParsedPackageName {
    error: string;
}

// @public
export interface IProtectableMapParameters<K, V> {
    onClear?: (source: ProtectableMap<K, V>) => void;
    onDelete?: (source: ProtectableMap<K, V>, key: K) => void;
    onSet?: (source: ProtectableMap<K, V>, key: K, value: V) => V;
}

// @public
export interface IStringBuilder {
    append(text: string): void;
    toString(): string;
}

// @beta
export interface ITerminalProvider {
    eolCharacter: string;
    supportsColor: boolean;
    write(data: string, severity: TerminalProviderSeverity): void;
}

// @public
export class JsonFile {
    static load(jsonFilename: string): JsonObject;
    static loadAndValidate(jsonFilename: string, jsonSchema: JsonSchema, options?: IJsonSchemaValidateOptions): JsonObject;
    static loadAndValidateAsync(jsonFilename: string, jsonSchema: JsonSchema, options?: IJsonSchemaValidateOptions): Promise<JsonObject>;
    static loadAndValidateWithCallback(jsonFilename: string, jsonSchema: JsonSchema, errorCallback: (errorInfo: IJsonSchemaErrorInfo) => void): JsonObject;
    static loadAndValidateWithCallbackAsync(jsonFilename: string, jsonSchema: JsonSchema, errorCallback: (errorInfo: IJsonSchemaErrorInfo) => void): Promise<JsonObject>;
    static loadAsync(jsonFilename: string): Promise<JsonObject>;
    static parseString(jsonContents: string): JsonObject;
    static save(jsonObject: JsonObject, jsonFilename: string, options?: IJsonFileSaveOptions): boolean;
    static saveAsync(jsonObject: JsonObject, jsonFilename: string, options?: IJsonFileSaveOptions): Promise<boolean>;
    static stringify(jsonObject: JsonObject, options?: IJsonFileStringifyOptions): string;
    static updateString(previousJson: string, newJsonObject: JsonObject, options?: IJsonFileStringifyOptions): string;
    static validateNoUndefinedMembers(jsonObject: JsonObject): void;
    }

// @public
export type JsonObject = any;

// @public
export class JsonSchema {
    ensureCompiled(): void;
    static fromFile(filename: string, options?: IJsonSchemaFromFileOptions): JsonSchema;
    static fromLoadedObject(schemaObject: JsonObject): JsonSchema;
    readonly shortName: string;
    validateObject(jsonObject: JsonObject, filenameForErrors: string, options?: IJsonSchemaValidateOptions): void;
    validateObjectWithCallback(jsonObject: JsonObject, errorCallback: (errorInfo: IJsonSchemaErrorInfo) => void): void;
    }

// @public
export class LegacyAdapters {
    static convertCallbackToPromise<TResult, TError>(fn: (cb: LegacyCallback<TResult, TError>) => void): Promise<TResult>;
    // (undocumented)
    static convertCallbackToPromise<TResult, TError, TArg1>(fn: (arg1: TArg1, cb: LegacyCallback<TResult, TError>) => void, arg1: TArg1): Promise<TResult>;
    // (undocumented)
    static convertCallbackToPromise<TResult, TError, TArg1, TArg2>(fn: (arg1: TArg1, arg2: TArg2, cb: LegacyCallback<TResult, TError>) => void, arg1: TArg1, arg2: TArg2): Promise<TResult>;
    // (undocumented)
    static convertCallbackToPromise<TResult, TError, TArg1, TArg2, TArg3>(fn: (arg1: TArg1, arg2: TArg2, arg3: TArg3, cb: LegacyCallback<TResult, TError>) => void, arg1: TArg1, arg2: TArg2, arg3: TArg3): Promise<TResult>;
    // (undocumented)
    static convertCallbackToPromise<TResult, TError, TArg1, TArg2, TArg3, TArg4>(fn: (arg1: TArg1, arg2: TArg2, arg3: TArg3, arg4: TArg4, cb: LegacyCallback<TResult, TError>) => void, arg1: TArg1, arg2: TArg2, arg3: TArg3, arg4: TArg4): Promise<TResult>;
    static scrubError(error: Error | string | any): Error;
    static sortStable<T>(array: T[], compare?: (a: T, b: T) => number): void;
    }

// @public
export type LegacyCallback<TResult, TError> = (error: TError | null | undefined, result: TResult) => void;

// @public
export class LockFile {
    static acquire(resourceFolder: string, resourceName: string, maxWaitMs?: number): Promise<LockFile>;
    readonly dirtyWhenAcquired: boolean;
    readonly filePath: string;
    static getLockFilePath(resourceFolder: string, resourceName: string, pid?: number): string;
    readonly isReleased: boolean;
    release(): void;
    static tryAcquire(resourceFolder: string, resourceName: string): LockFile | undefined;
    }

// @public
export class MapExtensions {
    static mergeFromMap<K, V>(targetMap: Map<K, V>, sourceMap: ReadonlyMap<K, V>): void;
    static toObject<TValue>(map: Map<string, TValue>): {
        [key: string]: TValue;
    };
}

// @public
export const enum NewlineKind {
    CrLf = "\r\n",
    Lf = "\n",
    OsDefault = "os"
}

// @public
export class PackageJsonLookup {
    constructor(parameters?: IPackageJsonLookupParameters);
    clearCache(): void;
    loadNodePackageJson(jsonFilename: string): INodePackageJson;
    static loadOwnPackageJson(dirnameOfCaller: string): IPackageJson;
    loadPackageJson(jsonFilename: string): IPackageJson;
    tryGetPackageFolderFor(fileOrFolderPath: string): string | undefined;
    tryGetPackageJsonFilePathFor(fileOrFolderPath: string): string | undefined;
    tryLoadNodePackageJsonFor(fileOrFolderPath: string): INodePackageJson | undefined;
    tryLoadPackageJsonFor(fileOrFolderPath: string): IPackageJson | undefined;
}

// @public
export class PackageName {
    static combineParts(scope: string, unscopedName: string): string;
    static getScope(packageName: string): string;
    static getUnscopedName(packageName: string): string;
    static isValidName(packageName: string): boolean;
    static parse(packageName: string): IParsedPackageName;
    static tryParse(packageName: string): IParsedPackageNameOrError;
    static validate(packageName: string): void;
}

// @public
export class PackageNameParser {
    constructor(options?: IPackageNameParserOptions);
    combineParts(scope: string, unscopedName: string): string;
    getScope(packageName: string): string;
    getUnscopedName(packageName: string): string;
    isValidName(packageName: string): boolean;
    parse(packageName: string): IParsedPackageName;
    tryParse(packageName: string): IParsedPackageNameOrError;
    validate(packageName: string): void;
}

// @public
export class Path {
    static isUnder(childPath: string, parentFolderPath: string): boolean;
    static isUnderOrEqual(childPath: string, parentFolderPath: string): boolean;
    }

// @public
export const enum PosixModeBits {
    AllExecute = 73,
    AllRead = 292,
    AllWrite = 146,
    GroupExecute = 8,
    GroupRead = 32,
    GroupWrite = 16,
    None = 0,
    OthersExecute = 1,
    OthersRead = 4,
    OthersWrite = 2,
    UserExecute = 64,
    UserRead = 256,
    UserWrite = 128
}

// @public
export class ProtectableMap<K, V> {
    constructor(parameters: IProtectableMapParameters<K, V>);
    clear(): void;
    delete(key: K): boolean;
    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;
    get(key: K): V | undefined;
    has(key: K): boolean;
    readonly protectedView: Map<K, V>;
    set(key: K, value: V): this;
    readonly size: number;
}

// @public
export class Sort {
    static compareByValue(x: any, y: any): number;
    static isSorted<T>(array: T[], comparer?: (x: any, y: any) => number): boolean;
    static isSortedBy<T>(array: T[], keySelector: (element: T) => any, comparer?: (x: any, y: any) => number): boolean;
    static sortBy<T>(array: T[], keySelector: (element: T) => any, comparer?: (x: any, y: any) => number): void;
    static sortMapKeys<K, V>(map: Map<K, V>, keyComparer?: (x: K, y: K) => number): void;
    static sortSet<T>(set: Set<T>, comparer?: (x: T, y: T) => number): void;
    static sortSetBy<T>(set: Set<T>, keySelector: (element: T) => any, keyComparer?: (x: T, y: T) => number): void;
}

// @beta
export class StringBufferTerminalProvider implements ITerminalProvider {
    constructor(supportsColor?: boolean);
    readonly eolCharacter: string;
    getErrorOutput(): string;
    getOutput(): string;
    getVerbose(): string;
    getWarningOutput(): string;
    readonly supportsColor: boolean;
    write(data: string, severity: TerminalProviderSeverity): void;
}

// @public
export class StringBuilder implements IStringBuilder {
    constructor();
    append(text: string): void;
    toString(): string;
}

// @beta
export class Terminal {
    constructor(provider: ITerminalProvider);
    registerProvider(provider: ITerminalProvider): void;
    unregisterProvider(provider: ITerminalProvider): void;
    write(...messageParts: (string | IColorableSequence)[]): void;
    writeError(...messageParts: (string | IColorableSequence)[]): void;
    writeErrorLine(...messageParts: (string | IColorableSequence)[]): void;
    writeLine(...messageParts: (string | IColorableSequence)[]): void;
    writeVerbose(...messageParts: (string | IColorableSequence)[]): void;
    writeVerboseLine(...messageParts: (string | IColorableSequence)[]): void;
    writeWarning(...messageParts: (string | IColorableSequence)[]): void;
    writeWarningLine(...messageParts: (string | IColorableSequence)[]): void;
}

// @beta (undocumented)
export enum TerminalProviderSeverity {
    // (undocumented)
    error = 2,
    // (undocumented)
    log = 0,
    // (undocumented)
    verbose = 3,
    // (undocumented)
    warning = 1
}

// @public
export class Text {
    static convertTo(input: string, newlineKind: NewlineKind): string;
    static convertToCrLf(input: string): string;
    static convertToLf(input: string): string;
    static ensureTrailingNewline(s: string, newlineKind?: NewlineKind): string;
    static padEnd(s: string, minimumLength: number, paddingCharacter?: string): string;
    static padStart(s: string, minimumLength: number, paddingCharacter?: string): string;
    static replaceAll(input: string, searchValue: string, replaceValue: string): string;
    static truncateWithEllipsis(s: string, maximumLength: number): string;
}

// @beta
export enum TextAttribute {
    // (undocumented)
    Blink = 3,
    // (undocumented)
    Bold = 0,
    // (undocumented)
    Dim = 1,
    // (undocumented)
    Hidden = 5,
    // (undocumented)
    InvertColor = 4,
    // (undocumented)
    Underline = 2
}


```
