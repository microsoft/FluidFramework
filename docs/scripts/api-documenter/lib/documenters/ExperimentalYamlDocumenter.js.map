{"version":3,"file":"ExperimentalYamlDocumenter.js","sourceRoot":"","sources":["../../src/documenters/ExperimentalYamlDocumenter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { DocComment, DocInlineTag } from '@microsoft/tsdoc';\r\nimport { ApiModel, ApiItem, ApiItemKind, ApiDocumentedItem } from '@microsoft/api-extractor-model';\r\n\r\nimport { IConfigTableOfContents } from './IConfigFile';\r\nimport { IYamlTocItem, IYamlTocFile } from '../yaml/IYamlTocFile';\r\nimport { YamlDocumenter } from './YamlDocumenter';\r\nimport { DocumenterConfig } from './DocumenterConfig';\r\n\r\n/**\r\n * EXPERIMENTAL - This documenter is a prototype of a new config file driven mode of operation for\r\n * API Documenter.  It is not ready for general usage yet.  Its design may change in the future.\r\n */\r\nexport class ExperimentalYamlDocumenter extends YamlDocumenter {\r\n  private _config: IConfigTableOfContents;\r\n  private _tocPointerMap: { [key: string]: IYamlTocItem };\r\n  private _catchAllPointer: IYamlTocItem;\r\n\r\n  public constructor(apiModel: ApiModel, documenterConfig: DocumenterConfig) {\r\n    super(apiModel, documenterConfig.configFile.newDocfxNamespaces);\r\n    this._config = documenterConfig.configFile.tableOfContents!;\r\n\r\n    this._tocPointerMap = {};\r\n\r\n    this._generateTocPointersMap(this._config.tocConfig);\r\n  }\r\n\r\n  /** @override */\r\n  protected buildYamlTocFile(apiItems: ReadonlyArray<ApiItem>): IYamlTocFile {\r\n    this._buildTocItems2(apiItems);\r\n    return this._config.tocConfig;\r\n  }\r\n\r\n  private _buildTocItems2(apiItems: ReadonlyArray<ApiItem>): IYamlTocItem[] {\r\n    const tocItems: IYamlTocItem[] = [];\r\n    for (const apiItem of apiItems) {\r\n      let tocItem: IYamlTocItem;\r\n      if (apiItem.kind === ApiItemKind.Namespace && !this.newDocfxNamespaces) {\r\n        tocItem = {\r\n          name: this._getTocItemName(apiItem)\r\n        };\r\n      } else {\r\n        if (this._shouldEmbed(apiItem.kind)) {\r\n          // Don't generate table of contents items for embedded definitions\r\n          continue;\r\n        }\r\n\r\n        tocItem = {\r\n          name: this._getTocItemName(apiItem),\r\n          uid: this._getUid(apiItem)\r\n        };\r\n\r\n        if (apiItem.kind !== ApiItemKind.Package) {\r\n          this._filterItem(apiItem, tocItem);\r\n        }\r\n      }\r\n\r\n      tocItems.push(tocItem);\r\n\r\n      const children: ApiItem[] = this._getLogicalChildren(apiItem);\r\n      const childItems: IYamlTocItem[] = this._buildTocItems2(children);\r\n      if (childItems.length > 0) {\r\n        tocItem.items = childItems;\r\n      }\r\n    }\r\n    return tocItems;\r\n  }\r\n\r\n  // Parses the tocConfig object to build a pointers map of nodes where we want to sort out the API items\r\n  private _generateTocPointersMap(tocConfig: IYamlTocFile | IYamlTocItem): void {\r\n    const { catchAllCategory } = this._config;\r\n\r\n    if (tocConfig.items) {\r\n      for (const tocItem of tocConfig.items) {\r\n        if (tocItem.items && tocItem.items.length > 0 && this._shouldNotIncludeInPointersMap(tocItem)) {\r\n          this._generateTocPointersMap(tocItem);\r\n        } else {\r\n          // check for presence of the `catchAllCategory` config option\r\n          if (catchAllCategory && tocItem.name === catchAllCategory) {\r\n            this._catchAllPointer = tocItem;\r\n          } else {\r\n            this._tocPointerMap[tocItem.name] = tocItem;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Filtering out the api-item by inlineTags or category name presence in the item name.\r\n   */\r\n  private _filterItem(apiItem: ApiItem, tocItem: IYamlTocItem): void {\r\n    const { categoryInlineTag, categorizeByName } = this._config;\r\n    const { name: itemName } = tocItem;\r\n    let filtered: boolean = false;\r\n\r\n    // First we attempt to filter by inline tag if provided.\r\n    if (apiItem instanceof ApiDocumentedItem) {\r\n      const docInlineTag: DocInlineTag | undefined = categoryInlineTag\r\n        ? this._findInlineTagByName(categoryInlineTag, apiItem.tsdocComment)\r\n        : undefined;\r\n\r\n      const tagContent: string | undefined =\r\n        docInlineTag && docInlineTag.tagContent && docInlineTag.tagContent.trim();\r\n\r\n      if (tagContent && this._tocPointerMap[tagContent]) {\r\n        // null assertion used because when pointer map was created we checked for presence of empty `items` array\r\n        this._tocPointerMap[tagContent].items!.push(tocItem);\r\n        filtered = true;\r\n      }\r\n    }\r\n\r\n    // If not filtered by inline tag and `categorizeByName` config is enabled attempt to filter it by category name.\r\n    if (!filtered && categorizeByName) {\r\n      const pointers: string[] = Object.keys(this._tocPointerMap);\r\n      for (let i: number = 0, length: number = pointers.length; i < length; i++) {\r\n        if (itemName.indexOf(pointers[i]) !== -1) {\r\n          // null assertion used because when pointer map was created we checked for presence of empty `items` array\r\n          this._tocPointerMap[pointers[i]].items!.push(tocItem);\r\n          filtered = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // If item still not filtered and a `catchAllCategory` config provided push it to it.\r\n    if (!filtered && this._catchAllPointer && this._catchAllPointer.items) {\r\n      this._catchAllPointer.items.push(tocItem);\r\n    }\r\n  }\r\n\r\n  // This is a direct copy of a @docCategory inline tag finder in office-ui-fabric-react,\r\n  // but is generic enough to be used for any inline tag\r\n  private _findInlineTagByName(\r\n    tagName: string,\r\n    docComment: DocComment | undefined\r\n  ): DocInlineTag | undefined {\r\n    const tagNameToCheck: string = `@${tagName}`;\r\n\r\n    if (docComment instanceof DocInlineTag) {\r\n      if (docComment.tagName === tagNameToCheck) {\r\n        return docComment;\r\n      }\r\n    }\r\n    if (docComment) {\r\n      for (const childNode of docComment.getChildNodes()) {\r\n        const result: DocInlineTag | undefined = this._findInlineTagByName(tagName, childNode as DocComment);\r\n        if (result !== undefined) {\r\n          return result;\r\n        }\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  private _shouldNotIncludeInPointersMap(item: IYamlTocItem): boolean {\r\n    const { nonEmptyCategoryNodeNames } = this._config;\r\n    if (nonEmptyCategoryNodeNames && nonEmptyCategoryNodeNames.length) {\r\n      return nonEmptyCategoryNodeNames.indexOf(item.name) === -1;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n"]}