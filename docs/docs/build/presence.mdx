---
title: Presence
sidebar_position: 10
---

## Overview

We are introducing a new way to power your ephemeral experiences with Fluid: the new Presence APIs (in beta as of version 2.42.0) that provide session-focused utilities for lightweight data sharing and messaging.
Collaborative features typically rely on each user maintaining their own temporary state, which is subsequently shared with others. For example, in applications featuring multiplayer cursors, the cursor position of each user signifies their state. This state can be further utilized for various purposes such as indicating typing activity or displaying a user's current selection. This concept is referred to as _presence_.

By leveraging this shared state, applications can provide a seamless and interactive collaborative experience, ensuring that users are always aware of each other's actions and selections in real-time.

The key scenarios for which the new Presence APIs are suitable include:

-   User presence
-   Collaborative cursors
-   Notifications

## Concepts

A session is a period of time when one or more clients are connected to a Fluid service. Session data and messages may be exchanged among clients, but will disappear once no clients remain. (More specifically once no clients remain that have acquired the session `Presence` interface.) Once fully implemented, no client will require container write permissions to use Presence features.

### Attendees

For the lifetime of a session, each client connecting will be established as a unique and stable `Attendee`. The representation is stable because it will remain the same `Attendee` instance independent of connection drops and reconnections.

Client IDs maintained by `Attendee` may be used to associate `Attendee` with quorum, audience, and service audience members.

### Workspaces

Within Presence data sharing and messaging is broken into workspaces with custom identifiers (workspace addresses). Clients must use the same address within a session to connect with others. Unique addresses enable logical components within a client runtime to remain isolated or work together (without other piping between those components).

There are two types of workspaces: States and Notifications.

#### States Workspace

A `StatesWorkspace` allows sharing of simple data across attendees where each attendee maintains their own data values that others may read, but not change. This is distinct from a Fluid DDS where data values might be manipulated by multiple clients and one ultimate value is derived. Shared, independent values are maintained by State objects that specialize in incrementality and history of values.

#### Notifications Workspace

A `NotificationsWorkspace` is similar to states workspace, but is dedicated to notification use-cases via `NotificationsManager`.

### State objects

#### Latest, LatestRaw

`Latest` and `LatestRaw` (unvalidated data) retain the most recent atomic value each attendee has shared.
Use `StateFactory.latest` to add one to `StatesWorkspace`.

#### LatestMap, LatestMapRaw

`LatestMap` and `LatestMapRaw` (unvalidated data) retain the most recent atomic value each attendee has shared under arbitrary keys (mimics `Map` data structure).
Values associated with a key may be set to `undefined` to represent deletion.
Use `StateFactory.latestMap` to add one to a `StatesWorkspace`.
(`LatestMap` support is pending.)

#### NotificationsManager

Notifications are a special case where no data is retained during a session and all interactions appear as events that are sent and received. Notifications may be mixed into a `StatesWorkspace` for convenience. `NotificationsManager` is the only presence object permitted in a `NotificationsWorkspace`. Use `Notifications` to add one to a `NotificationsWorkspace` or `StatesWorkspace`.

## Using Presence

### State object use

State objects have:

1. a `local` property representing local clients state data
1. an `events` property to listen for remote and local updates
1. several `get*` methods to access other attendees and their data

#### Latest, LatestRaw use

Simple assignment of new value (new object) initiates broadcast of new value to other attendees.

```typescript
function updateMyPosition(positionTracker: Latest<PointXY>, newPosition: PointXY): void {
	positionTracker.local = newPosition;
}
```

Updates from remote clients can be listened for using `events`.

```typescript
function startTrackingOthersPositions(positionTracker: Latest<PointXY>): (() => void) {
	const stop = positionTracker.events.on("remoteUpdated", (update) => {
		const pos = update.value();
		if (pos === undefined) {
			console.warn(`Attendee ${update.attendee.attendeeId} sent invalid position data`);
		} else {
			console.log(`Attendee ${update.attendee.attendeeId} now at (${pos.x}, ${pos.y})`);
		}
	});
	return stop;
}
```

Accumulated data can be enumerated using `getRemotes`.

```typescript
// Logs other attendees' current positions (includes now disconnected attendees)
function logOthersPositions(positionTracker: Latest<PointXY>): void {
	for (const { attendee, value } of positionTracker.getRemotes()) {
		const validated = value();
		const position = validated === undefined ? "<invalid>" : `(${validated.x}, ${validated.y})`;
		console.log(`${attendee.attendeeId} ${position} [${attendee.getConnectionStatus()}]:`);
	}
}
```

#### LatestMap, LatestMapRaw use

A change to the `local` property automatically initiates a broadcast of updates to other attendees.
`local` is a [StateMap](https://fluidframework.com/docs/api/presence/statemap-interface) that mimics `Map` though it only supports `string | number` as property keys.

```typescript
function updateCounter(counterTracker: LatestMapRaw<number, string>, counterName: string, value: number): void {
	counterTracker.local.set(counterName, value);
}
```

Updates from remote clients can be listened for using `events`.
`"remoteItemUpdated"` and `"remoteItemRemoved"` provide fine-grain updates and `"remoteUpdated"` (use not shown) notes any change but only provides complete new map.

```typescript
function startTrackingOthersCounters(counterTracker: LatestMapRaw<number, string>): (() => void) {
	const stopUpdated = counterTracker.events.on("remoteItemUpdated", (update) => {
		console.log(`Attendee ${update.attendee.attendeeId} updated counter ${update.key} to ${update.value}.`);
	});
	const stopRemoved = counterTracker.events.on("remoteItemRemoved", (update) => {
		console.log(`Attendee ${update.attendee.attendeeId} removed counter ${update.key}.`);
	});
	return () => { stopUpdated(); stopRemoved(); };
}
```

Accumulated data can be enumerated using `getRemotes`.

```typescript
// Logs other attendee's current counters (excludes now _disconnected_ attendees)
function logOthersCounters(counterTracker: LatestMapRaw<number, string>): void {
	function getOrCreateEntry<K extends string, V>(record: Map<K, V[]>, key: K): V[] {
		if (!record.has(key)) { record.set(key, []); }
		return record.get(key)!;
	}

	const counterMap = new Map<string, { attendee: Attendee; value: number }[]>();
	// Collect counters from all remote attendees
	for (const { attendee, items } of counterTracker.getRemotes()) {
		// Only collect from *connected* attendees
		if (attendee.getConnectionStatus() === AttendeeStatus.Connected) {
			// `items` is a simple `ReadonlyMap` of remote data
			for (const [counterName, value] of items.entries()) {
				getOrCreateEntry(counterMap, counterName).push({ attendee, value: value.value });
			}
		}
	}

	for (const [key, items] of counterMap.entries()) {
		console.log(`Counter ${key}:`);
		for (const { attendee, value } of items) {
			console.log(`  ${attendee.attendeeId}: ${value}`);
		}
	}
}
```

### Setup

To access Presence APIs, use `getPresence()` with any `IFluidContainer`.

```typescript
import { getPresence } from "@fluidframework/presence/beta";

function usePresence(container: IFluidContainer): void {
   const presence = getPresence(container);
}
```

#### Schema Definition and Workspace

```typescript
import type { LatestRaw, LatestMapRaw, Presence, StatesWorkspaceSchema } from "@fluidframework/presence/beta";
import { StatesFactory } from "@fluidframework/presence/beta";

interface PointXY { x: number; y: number }

// Basic custom type guard
function isPointXY(value: unknown): value is PointXY {
	return typeof value === "object" && value !== null && "x" in value && "y" in value &&
		typeof value.x === "number" && typeof value.y === "number";
}

// A Presence workspace schema with two State objects named "position" and "counters".
const PresenceSchemaV1 = {
	// This `Latest<PointXY>` state defaults all values to (0, 0).
	position: StateFactory.latest<PointXY>({
		local: { x: 0, y: 0 },
		validator: (v) => isPointXY(v) ? v : undefined
	}),
	// This `LatestMap<number, string>` state has `string` keys storing `number` values.
	counters: StateFactory.latestMap<number, string>({ }),
} as const satisfies StatesWorkspaceSchema;

// Creates our unique workspace with the State objects declared in above schema.
function getOurWorkspace(presence: Presence):
	{
		position: Latest<PointXY>;
		counters: LatestMapRaw<number, string>;
	} {
	return presence.states.getWorkspace("name:PointsAndCountersV1", PresenceSchemaV1).states;
}
```

## Other Capabilities

### Runtime data validation

Runtime data validation is partially implemented.
The StateFactory.latest API does accept a `validator` argument but StateFactory.latestMap API does not.
Passing a validator function is recommended to ensure data from other attendees conforms to expectations.
The validator will be invoked on the first attempt to read a remote value (always a `.value()` call) and validator may return data conforming to schema or `undefined`.
Whatever the result, it will be cached and returned immediately for future `.value()` calls.
**Passing the `validator` argument in version 2.43.0 will result in a runtime exception.**

## Limitations

### Data Supported

Only plain old data is supported.
If `JSON.parse(JSON.stringify(foo))` returns a deeply equal value, then that data is supported.
Large data is not recommended and if used may exceed system capacity.
A small image could be shared but sharing a URL to an image is recommended.

### Compatibility and Versioning

The schema of workspace address, states and notifications names, and their types will only be consistent when all
clients connected to the session are using the same types for a unique value/notification path (workspace address + name
within workspace). In other words, don't mix versions or make sure to change identifiers when changing types in a
non-compatible way.

For example:

```typescript
presence.states.getWorkspace("app:v1states", { myState: StateFactory.latest({ local: { x: 0 }}) });
```

is incompatible with

```typescript
presence.states.getWorkspace("app:v1states", { myState: StateFactory.latest({ local: { x: "text" }}) });
```

because "app:v1states"+"myState" have different value type expectations: `{x: number}` versus `{x: string}`.

```typescript
presence.states.getWorkspace("app:v1states", { myState2: StateFactory.latest({ local: { x: true }}) });
```

would be compatible with both of the prior schemas because "myState2" is a different name. Though in this situation none of the different clients would be able to observe each other.

### States Reliability

The current implementation relies on Fluid Framework's signal infrastructure instead of ops. This has advantages, but comes with some risk of unreliable messaging. The most common known case of unreliable signals occurs during reconnection periods and the current implementation attempts to account for that. Be aware that all clients are not guaranteed to arrive at eventual consistency. Please [file a new issue](https://github.com/microsoft/FluidFramework/issues/new?assignees=&labels=bug&projects=&template=bug_report.md&title=Presence:%20States:%20) if one is not found under [Presence States issues](https://github.com/microsoft/FluidFramework/issues?q=is%3Aissue+%22Presence%3A+States%3A%22).

### Notifications

Notifications API is partially implemented at alpha support level. All messages are always broadcast even if `unicast` API is used. Type inferences are not working even with a fully specified `initialSubscriptions` value provided to `Notifications`, and the schema type must be specified explicitly.

Notifications are fundamentally unreliable at this time as there are no built-in acknowledgements nor retained state. To prevent the most common loss of notifications, always check for connection before sending.

### Throttling / Grouping

Presence updates are grouped together and throttled to prevent flooding the network with messages when presence values are rapidly updated. This means the presence infrastructure will not immediately broadcast updates but will broadcast them after a configurable delay.

The `allowableUpdateLatencyMs` property configures how long a local update may be delayed under normal circumstances, enabling grouping with other updates. The default `allowableUpdateLatencyMs` is **60 milliseconds** but may be (1) specified during configuration of a [States Workspace](#states-workspace) or [States](#states) and/or (2) updated later using the `controls` member of Workspace or States. The [States Workspace](#states-workspace) configuration is used when States do not have their own setting.

Notifications are never queued; they effectively always have an `allowableUpdateLatencyMs` of 0. However, they may be grouped with other updates that were already queued.

Note that due to throttling, clients will not receive updates for every intermediate value set by another client. For example,
with `Latest` and `LatestMap`, the only value sent is the value at the time the outgoing grouped message is sent. Previous
values set by the client will not be broadcast or seen by other clients.

#### Example

You can configure the grouping and throttling behavior using the `allowableUpdateLatencyMs` property as in the following example:

```ts
// Configure a states workspace
const stateWorkspace = presence.states.getWorkspace(
	"app:v1states",
	{
		// This Latest state has an allowable latency of 100ms.
		position: StateFactory.latest({ local: { x: 0, y: 0 }, settings: { allowableUpdateLatencyMs: 100 }}),
		// This Latest state uses the workspace default.
		count: StateFactory.latest({ local: { num: 0 }}),
	},
	// Specify the default for all state in this workspace to 200ms,
	// overriding the default value of 60ms.
	{ allowableUpdateLatencyMs: 200 },
);

// Temporarily set count updates to send as soon as possible
const countState = stateWorkspace.states.count;
countState.controls.allowableUpdateLatencyMs = 0;
countState.local = { num: 5000 };

// Reset the update latency to the workspace default
countState.controls.allowableUpdateLatencyMs = undefined;
```
