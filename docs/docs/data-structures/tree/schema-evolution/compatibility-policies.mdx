---
title: Sample Compatibility Policies
sidebar_position: 3
---

# Sample Compatibility Policies

This guide outlines different compatibility policies you can implement to handle schema differences between your application's view schema and document stored schemas.
The right policy depends on your application's requirements and deployment patterns.

> **API Reference:** The examples below use [`ITree`](../../../api/fluid-framework/itree-interface), [`TreeViewConfiguration`](../../../api/fluid-framework/treeviewconfiguration-class), and [`SchemaCompatibilityStatus`](../../../api/fluid-framework/schemacompatibilitystatus-interface) interfaces.

**_WARNING_** Currently, `SharedTree` only supports the 'enforce equivalent schema' policy.
There are near-term plans (with the same API) to allow opening a document which has additional optional fields in its stored schema that are not present in the view schema, and longer-term plans to allow opening documents using older view schemas when a document's stored schema has been upgraded with other types of backward-compatible changes.

## Policy Overview

Application authors should use [`TreeView.compatibility`](../../../api/fluid-framework/treeview-interface#compatibility-property) and related APIs to implement policies that make sense for their ecosystem.
The main trade-offs are:

- **Stricter policies**: Simpler compatibility matrix, but require longer deployment cycles
- **More permissive policies**: Faster feature roll-out, but more complex compatibility considerations

## Policy 1: Enforce Equivalent Schema

The simplest approach is to only open documents that have schemas equivalent to your application's current view schema.

### Implementation

```typescript
function render(tree: ITree) {
	const view = tree.viewWith(configuration);
	const { compatibility } = view;
	if (!compatibility.isEquivalent) {
		if (compatibility.canUpgrade) {
			view.upgradeSchema();
		} else {
			renderError("This version of the application is unable to open the document.");
			return;
		}
	}

	view.events.on("schemaChanged", () => {
		if (!view.compatibility.isEquivalent) {
			renderError(
				"Document has been upgraded. This version of the application is unable to open the document.",
			);
			return;
		}

		// Schema changes invalidate the root of the tree. Real applications would want to react to that here.
	});

	// Application can open document!
	renderApplication(view.root);
}
```

### Use Cases

- **Rapid deployment cycles** where all clients update frequently
- **Controlled environments** with synchronized deployments
- **Simple applications** that don't need complex compatibility handling

### Trade-offs

**Advantages:**
- Simple: Easy to implement and reason about
- Predictable: Clear error conditions

**Disadvantages:**
- Restrictive: Clients can be locked out when documents are upgraded
- Deployment coupling: Schema changes require [staged rollouts](./index.mdx#staged-rollouts)

## Policy 2: Allow Optional Field Additions


**_WARNING:_** The policy outlined in this section is not currently implementable.
There are plans to extend the [`TreeView.compatibility`](../../../api/fluid-framework/treeview-interface#compatibility-property) API with information that allows implementing policies such as this, but the exact API is not finalized.

This policy allows collaboration when the stored schema has additional optional fields that aren't present in the view schema.

### Implementation

```typescript
// The only types of differences which are tolerated are where the stored schema has optional fields
// where the view schema has no field.
function isApplicationLogicCompatible(compatibility: SchemaCompatibilityStatus): boolean {
	for (const difference of compatibility.differences) {
		if (difference.mismatch === "nodeType") {
			return false;
		}

		for (const fieldDifference of difference.differences) {
			if (
				fieldDifference.mismatch !== "fieldKind" ||
				fieldDifference.view !== undefined ||
				fieldDifference.stored !== "optional"
			) {
				return false;
			}
		}
	}

	return true;
}

function render(tree: ITree) {
	const view = tree.viewWith(configuration);
	const { compatibility } = view;
	if (!compatibility.canView) {
		// View schema allows documents that stored schema does not.
		if (compatibility.canUpgrade) {
			view.upgradeSchema();
		} else {
			// Assuming well-formed rollout, this case should not happen: it means the current view schema
			// is neither a subset nor a superset of the stored schema.
			// It could happen in practice if application authors made a change breaking backward-compatibility of the view schema.
			renderError("This document cannot be opened.");
			return;
		}
	} else if (!isApplicationLogicCompatible(compatibility)) {
		// Surface to the user that this application version is unable to open this document / updating the application may help.
		renderError("This version of the application is unable to open the document.");
		return;
	}

	view.events.on("schemaChanged", () => {
		if (!view.compatibility.canView || !isApplicationLogicCompatible(view.compatibility)) {
			renderError(
				"Document has been upgraded. This version of the application is unable to open the document.",
			);
			return;
		}
		// Schema changes invalidate the root of the tree. Real applications would want to react to that here.
	});

	// Application can open document!
	renderApplication(view.root);
}
```

### Use Cases

- **Applications with frequent optional field additions**
- **Teams that want faster feature rollout**
- **Collaborative environments** with mixed client versions

### Trade-offs

**Advantages:**
- More flexible: Allows optional field evolution
- Better collaboration: Mixed client versions can work together

**Disadvantages:**
- Data loss risk: Old clients may lose optional field data during edits e.g. old client constructs a new object for insertion elsewhere in the tree by spread-copying fields from an existing one
- Complex: Requires careful consideration of edit scenarios

## Policy 3: No Explicit Policy (Default Behavior)

If you don't implement explicit compatibility checking, SharedTree provides default behavior that will work "as well as the application does," in the sense that `SharedTree` will successfully report data changes and allow collaboration within the limits of what is possible: optional fields can be added to object nodes over time and old clients will still be permitted to collaborate.
After other types of backward-compatible document upgrades, clients using older view schemas will fail to open the document with a clear error message (accessing `view.root` will throw).

### Implementation

```typescript
const view = tree.viewWith(configuration);

// Basic upgrade handling
if (view.compatibility.canUpgrade) {
    view.upgradeSchema();
}

view.events.on("schemaChanged", () => {
	// Invalidate root
});

renderApplication(view.root);
```

### Behavior

- **Compatible documents**: Open normally
- **Upgradeable documents**: Automatically upgrade and open
- **Incompatible documents**: Throw error when accessing `view.root`
- **Remote upgrades**: Fire `schemaChanged` event

### Use Cases

- **Rapid prototyping** where compatibility isn't critical
- **Single-developer scenarios** with controlled document creation
- **Learning/experimentation** with SharedTree

### Trade-offs

**Advantages:**
- Simple: Minimal code required
- Guidance: Errors guide you toward explicit policy

**Disadvantages:**
- Unpredictable: Behavior depends on specific schema differences
- Poor UX: Errors may not be user-friendly

## See Also

- [Schema Evolution](./index.mdx) - Overview and upgrade process
- [Types of Schema Changes](./types-of-changes) - Understanding safe vs breaking changes
- [Monitoring Schema Compatibility](./index.mdx#monitoring-schema-compatibility) - Using compatibility APIs
