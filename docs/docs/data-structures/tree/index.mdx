---
title: SharedTree
sidebar_position: 5
---

import { PackageLink } from "@site/src/components/shortLinks";

The `SharedTree` distributed data structure (DDS), available starting with Fluid Framework 2.0, is used to store most or all of your application's shared data in a hierarchical structure.

A `SharedTree` has the following characteristics:

-   It is accessed through a `TreeView` object that exposes all the functionality for reading and editing data within a `SharedTree`.
-   It has a root and can have several types of internal (i.e., non-leaf) nodes and several types of leaf nodes.
-   Although there are some exceptions, for the most part, each type of node closely mirrors a familiar JavaScript datatype, such as object, map, array, boolean, number, string, and null.
-   Again, with exceptions, your code accesses nodes with the syntax of JavaScript and TypeScript, such as dot notation, property assignment, and array indexes.
-   A `TreeView` will conform to a schema that your code creates so it has application-specific strong typing.
-   The various types of internal nodes can be nested (subject to the constraints of the schema).

To get started working with `SharedTree` in your application, read this [quick start guide](../../start/tree-start.mdx).
Provided below are links to more detailed information about `SharedTree` usage and its available APIs.

- [Node Types](./node-types.mdx): outlines the types that are stored by a `SharedTree`
- [Schema Definition](./schema-definition.mdx): how the structure of a `SharedTree` is defined
- [Reading and Editing](./reading-and-editing.mdx): how a `SharedTree` is read and edited through the APIs provided on the different node types



### Transactions

If you want the `SharedTree` to treat a set of changes atomically, wrap these changes in a transaction. Using a transaction guarantees that (if applied) all of the changes will be applied together synchronously (though, note that the Fluid Framework guarantees this already for any sequence of changes that are submitted synchronously). However, the changes may not be applied at all if the transaction is given one or more constraints. If any constraint on a transaction is not met, then the transaction and all its changes will ignored by all clients. Additionally, all changes in a transaction will be reverted together as a single unit by [undo/redo code](#undoredo-support), because changes within a transaction are exposed through a single `Revertible` object. It is also more efficient for SharedTree to process a large number of changes in a row as a transaction rather than as changes submitted separately.

To create a transaction use the `Tree.runTransaction()` method. You can cancel a transaction from within the callback function by returning the special "rollback object", available via `Tree.runTransaction.rollback`. Also, if an error occurs within the callback, the transaction will be canceled automatically before propagating the error.

In this example, myNode can be any node in the SharedTree. It will be optionally passed into the callback function.

```typescript
Tree.runTransaction(myNode, (node) => {
    // Make multiple changes to the tree.
    // This can be changes to the referenced node but is not limited to that scope.
    if (
        // Something is wrong here!
    ) return "rollback";
})
```

You can also pass a `TreeView` object to `runTransaction()`.

```typescript
Tree.runTransaction(myTreeView, (treeView) => {
	// Make multiple changes to the tree.
});
```

There are example transactions here: [Shared Tree Demo](https://github.com/microsoft/FluidExamples/tree/main/brainstorm).

### Node Information

```typescript
Tree.key(node: SharedTreeNode): number | string
```

Returns the key of the `node`. This is a string in all cases, except an array node, in which case it returns the index of the node.

```typescript
Tree.parent(node: SharedTreeNode): SharedTreeNode
```

Returns the parent node of `node`. The following snippet continues the sticky notes example. Suppose that you have a reference to a note object and you want to delete it if, and only if, it is a member of an array of notes in a group or it is a direct child of the root. You can get the parent node and test what its type is.

```typescript
const parent = Tree.parent(note);

if (Tree.is(parent, Notes) || Tree.is(parent, Items)) {
	const index = parent.indexOf(note);
	parent.removeAt(index);
}
```

```typescript
Tree.status(node: SharedTreeNode): TreeStatus
```

Returns the current status of `node`. Possible values are:

-   **InDocument**: The node is in the tree.
-   **Removed**: The node has been removed from the tree but is still restorable by undo.
-   **Deleted**: The node is deleted and unrestorable.

```typescript
Tree.schema(node: SharedTreeNode): TreeNodeSchema
```

Returns the object that defines the schema of the `node` object.

## API Documentation

For a comprehensive view of the `SharedTree` package's API documentation, see <PackageLink packageName="tree">the SharedTree API docs</PackageLink>.
