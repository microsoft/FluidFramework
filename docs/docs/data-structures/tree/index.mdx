---
title: SharedTree
sidebar_position: 5
---

import { PackageLink } from "@site/src/components/shortLinks";

## Introduction

The `SharedTree` distributed data structure (DDS), available starting with Fluid Framework 2.0, is used to store most or all of your application's shared data in a hierarchical structure.

A `SharedTree` has the following characteristics:

-   It is accessed through a `TreeView` object that exposes all the functionality for reading and editing data within a `SharedTree`.
-   It has a root and can have several types of internal (i.e., non-leaf) nodes and several types of leaf nodes.
-   Although there are some exceptions, for the most part, each type of node closely mirrors a familiar JavaScript datatype, such as object, map, array, boolean, number, string, and null.
-   Again, with exceptions, your code accesses nodes with the syntax of JavaScript and TypeScript, such as dot notation, property assignment, and array indexes.
-   A `TreeView` will conform to a schema that your code creates so it has application-specific strong typing.
-   The various types of internal nodes can be nested (subject to the constraints of the schema).

To get started working with `SharedTree` in your application, read this [quick start guide](../../start/tree-start.mdx).
The major programming tasks for using `SharedTree`s that are described in this doc are:

-   Defining a schema for the `SharedTree`. As you build out from prototype to full production application, you can add to this schema and create additional schemas for additional `ShareTree`s.
-   Initializing the `TreeView` object.
-   Creating code that reads and edits the nodes of the `SharedTree`.

### Usage

Provided below are links to more detailed information about `SharedTree` usage and its available APIs.

- [Node Types](./node-types.mdx): outlines the types that are stored by a `SharedTree`
	- [Schema Definition](./schema-definition.mdx): how the structure of a `SharedTree` is defined
	- [Reading and Editing](./reading-and-editing.mdx): how a `SharedTree` is read and edited through the APIs provided on the different node types

## Other

### TreeView Object

The `TreeView` object is accessed via the Fluid Framework `IFluidContainer` object (container). The `TreeView` contains a `root` node that provides access to the complete `SharedTree`. The `TreeView` also provides access to tree-level events.

### Events

`SharedTree` supports two node level events: `nodeChanged` and `treeChanged`.
Your code can create handlers for these events using the utility class `Tree`.
See [Tree utility APIs](#tree-utility-apis).

Additionally, the `TreeView` object includes 2 events that operate over the whole tree.
These are `rootChanged` and `commitApplied`.

`rootChanged` fires when the root field (the field that contains the root node) changes.
That is, if a new root node is assigned or the schema changes.
This will not fire when the node itself changes.

`changed` fires whenever a change is applied outside of a transaction or when a transaction is committed.
This is used to get `Revertible` objects to put on the undo or redo stacks.
See [Undo/Redo support](#undoredo-support) and [Transactions](#transactions).

### Undo/Redo Support

`SharedTree` makes creating an undo and redo stack very simple. By listening for the `commitApplied` event on the `TreeView` object, you can get a `Revertible` object from a `Commit`.
`Commit` objects come in three flavors:

-   Default: a normal commit made in the local client that would go on the undo stack
-   Undo: a commit that is the result of reverting a Default or Redo `Revertible` object that would go on the redo stack
-   Redo: a commit that is the result of reverting an Undo `Revertible` object that would go on the undo stack

To undo a change, call the `revert` method on the `Revertible` object. This will return the properties of the `TreeView` object last changed by the local client to the their previous state. If changes were made to those properties by other clients in the meantime these changes will be overwritten. For example, if the local client moves 3 items into an array, and then a remote client moves one of those items somewhere else, when the local client reverts their change, the item moved by the remote client will be returned to its original position.

There is an example of a working undo/redo stack here: [Shared Tree Demo](https://github.com/microsoft/FluidExamples/tree/main/brainstorm).

## Tree Utility APIs

The `Tree` class provides some static utility APIs for working with data in the `TreeView` object.

### Event Handling

```typescript
on<K extends keyof TreeChangeEvents>(
		node: TreeNode,
		eventName: K,
		listener: TreeChangeEvents[K],
	): () => void;
```

`Tree.on` assigns the specified `listener` function to the specified `eventName` for the specified `node`.
The `node` can be any node of the tree.
The `eventName` can be either "treeChanged" or "nodeChanged".
`nodeChanged` fires whenever one or more properties of the specified node change.
`treeChanged` fires whenever one or more properties of the specified node or any node in its subtree, change.
We recommend looking at the documentation of each of the events for more details.

The `Tree.on()` method returns a function that unsubscribes the handler from the event. This method is typically called in clean up code when the node is being removed. For example:

```typescript
const unsubscribe = Tree.on(myTreeNode, "nodeChanged", () => {...});

// Later at some point when the event subscription is not needed anymore
unsubscribe();

```

### Transactions

If you want the `SharedTree` to treat a set of changes atomically, wrap these changes in a transaction. Using a transaction guarantees that (if applied) all of the changes will be applied together synchronously (though, note that the Fluid Framework guarantees this already for any sequence of changes that are submitted synchronously). However, the changes may not be applied at all if the transaction is given one or more constraints. If any constraint on a transaction is not met, then the transaction and all its changes will ignored by all clients. Additionally, all changes in a transaction will be reverted together as a single unit by [undo/redo code](#undoredo-support), because changes within a transaction are exposed through a single `Revertible` object. It is also more efficient for SharedTree to process a large number of changes in a row as a transaction rather than as changes submitted separately.

To create a transaction use the `Tree.runTransaction()` method. You can cancel a transaction from within the callback function by returning the special "rollback object", available via `Tree.runTransaction.rollback`. Also, if an error occurs within the callback, the transaction will be canceled automatically before propagating the error.

In this example, myNode can be any node in the SharedTree. It will be optionally passed into the callback function.

```typescript
Tree.runTransaction(myNode, (node) => {
    // Make multiple changes to the tree.
    // This can be changes to the referenced node but is not limited to that scope.
    if (
        // Something is wrong here!
    ) return "rollback";
})
```

You can also pass a `TreeView` object to `runTransaction()`.

```typescript
Tree.runTransaction(myTreeView, (treeView) => {
	// Make multiple changes to the tree.
});
```

There are example transactions here: [Shared Tree Demo](https://github.com/microsoft/FluidExamples/tree/main/brainstorm).

### Node Information

```typescript
Tree.key(node: SharedTreeNode): number | string
```

Returns the key of the `node`. This is a string in all cases, except an array node, in which case it returns the index of the node.

```typescript
Tree.parent(node: SharedTreeNode): SharedTreeNode
```

Returns the parent node of `node`. The following snippet continues the sticky notes example. Suppose that you have a reference to a note object and you want to delete it if, and only if, it is a member of an array of notes in a group or it is a direct child of the root. You can get the parent node and test what its type is.

```typescript
const parent = Tree.parent(note);

if (Tree.is(parent, Notes) || Tree.is(parent, Items)) {
	const index = parent.indexOf(note);
	parent.removeAt(index);
}
```

```typescript
Tree.status(node: SharedTreeNode): TreeStatus
```

Returns the current status of `node`. Possible values are:

-   **InDocument**: The node is in the tree.
-   **Removed**: The node has been removed from the tree but is still restorable by undo.
-   **Deleted**: The node is deleted and unrestorable.

```typescript
Tree.schema(node: SharedTreeNode): TreeNodeSchema
```

Returns the object that defines the schema of the `node` object.

## API Documentation

For a comprehensive view of the `SharedTree` package's API documentation, see <PackageLink packageName="tree">the SharedTree API docs</PackageLink>.
