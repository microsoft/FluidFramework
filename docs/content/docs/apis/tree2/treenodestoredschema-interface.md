{
  "title": "TreeNodeStoredSchema Interface",
  "summary": "",
  "kind": "Interface",
  "members": {
    "PropertySignature": {
      "leafValue": "/docs/apis/tree2/treenodestoredschema-interface#leafvalue-propertysignature",
      "mapFields": "/docs/apis/tree2/treenodestoredschema-interface#mapfields-propertysignature",
      "objectNodeFields": "/docs/apis/tree2/treenodestoredschema-interface#objectnodefields-propertysignature"
    }
  },
  "package": "@fluid-experimental/tree2",
  "unscopedPackageName": "tree2"
}

[//]: # (Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter.)

WARNING: This API is provided as an alpha preview and may change without notice. Use at your own risk.

## Signature {#treenodestoredschema-signature}

```typescript
export interface TreeNodeStoredSchema
```

## Properties

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th>
        Property
      </th>
      <th>
        Alerts
      </th>
      <th>
        Modifiers
      </th>
      <th>
        Type
      </th>
      <th>
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree2/treenodestoredschema-interface#leafvalue-propertysignature'>leafValue</a>
      </td>
      <td>
        <code>ALPHA</code>
      </td>
      <td>
        <code>optional</code>, <code>readonly</code>
      </td>
      <td>
        <span><a href='/docs/apis/tree2/valueschema-enum'>ValueSchema</a></span>
      </td>
      <td>
        <p>
          There are several approaches for how to store actual data in the tree (special node types, special field contents, data on nodes etc.) as well as several options about how the data should be modeled at this level (byte sequence? javascript type? json?), as well as options for how much of this would be exposed in the schema language (ex: would all nodes with values be special built-ins, or could any schema add them?)
        </p>
        <p>
          A simple easy to do in javascript approach is taken here: this is not intended to be a suggestion of what approach to take, or what to expose in the schema language. This is simply one approach that can work for modeling them in the internal schema representation.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree2/treenodestoredschema-interface#mapfields-propertysignature'>mapFields</a>
      </td>
      <td>
        <code>ALPHA</code>
      </td>
      <td>
        <code>optional</code>, <code>readonly</code>
      </td>
      <td>
        <span><a href='/docs/apis/tree2/treefieldstoredschema-interface'>TreeFieldStoredSchema</a></span>
      </td>
      <td>
        <p>
          Constraint for fields not mentioned in <code>objectNodeFields</code>. If undefined, all such fields must be empty.
        </p>
        <p>
          Allows using using the fields as a map, with the keys being FieldKeys and the values being constrained by this TreeFieldStoredSchema.
        </p>
        <p>
          Usually <code>FieldKind.Value</code> should NOT be used here since no nodes can ever be in schema are in schema if you use <code>FieldKind.Value</code> here (that would require infinite children).
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree2/treenodestoredschema-interface#objectnodefields-propertysignature'>objectNodeFields</a>
      </td>
      <td>
        <code>ALPHA</code>
      </td>
      <td>
        <code>readonly</code>
      </td>
      <td>
        <span>ReadonlyMap&lt;<a href='/docs/apis/tree2#fieldkey-typealias'>FieldKey</a>, <a href='/docs/apis/tree2/treefieldstoredschema-interface'>TreeFieldStoredSchema</a>&gt;</span>
      </td>
      <td>
        <p>
          Schema for fields with keys scoped to this TreeNodeStoredSchema.
        </p>
        <p>
          This refers to the TreeFieldStoredSchema directly (as opposed to just supporting FieldSchemaIdentifier and having a central FieldKey -\> TreeFieldStoredSchema map). This allows os short friendly field keys which can ergonomically used as field names in code. It also interoperates well with mapFields being used as a map with arbitrary data as keys.
        </p>
      </td>
    </tr>
  </tbody>
</table>

## Property Details

### leafValue (ALPHA) {#leafvalue-propertysignature}

There are several approaches for how to store actual data in the tree (special node types, special field contents, data on nodes etc.) as well as several options about how the data should be modeled at this level (byte sequence? javascript type? json?), as well as options for how much of this would be exposed in the schema language (ex: would all nodes with values be special built-ins, or could any schema add them?)

A simple easy to do in javascript approach is taken here: this is not intended to be a suggestion of what approach to take, or what to expose in the schema language. This is simply one approach that can work for modeling them in the internal schema representation.

WARNING: This API is provided as an alpha preview and may change without notice. Use at your own risk.

#### Signature {#leafvalue-signature}

```typescript
readonly leafValue?: ValueSchema;
```

### mapFields (ALPHA) {#mapfields-propertysignature}

Constraint for fields not mentioned in `objectNodeFields`. If undefined, all such fields must be empty.

Allows using using the fields as a map, with the keys being FieldKeys and the values being constrained by this TreeFieldStoredSchema.

Usually `FieldKind.Value` should NOT be used here since no nodes can ever be in schema are in schema if you use `FieldKind.Value` here (that would require infinite children).

WARNING: This API is provided as an alpha preview and may change without notice. Use at your own risk.

#### Signature {#mapfields-signature}

```typescript
readonly mapFields?: TreeFieldStoredSchema;
```

### objectNodeFields (ALPHA) {#objectnodefields-propertysignature}

Schema for fields with keys scoped to this TreeNodeStoredSchema.

This refers to the TreeFieldStoredSchema directly (as opposed to just supporting FieldSchemaIdentifier and having a central FieldKey -\> TreeFieldStoredSchema map). This allows os short friendly field keys which can ergonomically used as field names in code. It also interoperates well with mapFields being used as a map with arbitrary data as keys.

WARNING: This API is provided as an alpha preview and may change without notice. Use at your own risk.

#### Signature {#objectnodefields-signature}

```typescript
readonly objectNodeFields: ReadonlyMap<FieldKey, TreeFieldStoredSchema>;
```
