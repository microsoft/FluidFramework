{
  "title": "Multiplicity",
  "kind": "Enum",
  "members": {
    "EnumMember": {
      "Forbidden": "/docs/apis/tree2/multiplicity-enum#forbidden-enummember",
      "Optional": "/docs/apis/tree2/multiplicity-enum#optional-enummember",
      "Sequence": "/docs/apis/tree2/multiplicity-enum#sequence-enummember",
      "Single": "/docs/apis/tree2/multiplicity-enum#single-enummember"
    }
  },
  "package": "@fluid-experimental/tree2",
  "unscopedPackageName": "tree2"
}

[//]: # (Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter.)

Describes how a particular field functions.

This determine its reading and editing APIs, multiplicity, and what merge resolution policies it will use.

WARNING: This API is provided as an alpha preview and may change without notice. Use at your own risk.

## Signature {#multiplicity-signature}

```typescript
export declare enum Multiplicity
```

## Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th>
        Flag
      </th>
      <th>
        Alerts
      </th>
      <th>
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree2/multiplicity-enum#forbidden-enummember'>Forbidden</a>
      </td>
      <td>
        <code>ALPHA</code>
      </td>
      <td>
        <p>
          Exactly 0 items.
        </p>
        <p>
          Using Forbidden makes what types are listed for allowed in a field irrelevant since the field will never have values in it.
        </p>
        <p>
          Using Forbidden is equivalent to picking a kind that permits empty (like sequence or optional) and having no allowed types (or only never types). Because of this, its possible to express everything constraint wise without Forbidden, but using Forbidden can be more semantically clear than optional with no allowed types.
        </p>
        <p>
          For view schema, this can be useful if you need to: - run a specific out of schema handler when a field is present, but otherwise are ignoring or tolerating (ex: via extra fields) unmentioned fields. - prevent a specific field from being used as an extra field (perhaps for some past of future compatibility reason) - keep a field in a schema for metadata purposes (ex: for improved error messaging, error handling or documentation) that is not used in this specific version of the schema (ex: to document what it was or will be used for).
        </p>
        <p>
          For stored schema, this can be useful if you need to: - have a field which can have its schema updated to Optional or Sequence of any type. - to exclude a field from extra fields - for the schema system to use as a default for fields which aren't declared (ex: when updating a field that did not exist into one that does)
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree2/multiplicity-enum#optional-enummember'>Optional</a>
      </td>
      <td>
        <code>ALPHA</code>
      </td>
      <td>
        0 or 1 items.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree2/multiplicity-enum#sequence-enummember'>Sequence</a>
      </td>
      <td>
        <code>ALPHA</code>
      </td>
      <td>
        0 or more items.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree2/multiplicity-enum#single-enummember'>Single</a>
      </td>
      <td>
        <code>ALPHA</code>
      </td>
      <td>
        Exactly one item.
      </td>
    </tr>
  </tbody>
</table>

### Forbidden (ALPHA) {#forbidden-enummember}

Exactly 0 items.

Using Forbidden makes what types are listed for allowed in a field irrelevant since the field will never have values in it.

Using Forbidden is equivalent to picking a kind that permits empty (like sequence or optional) and having no allowed types (or only never types). Because of this, its possible to express everything constraint wise without Forbidden, but using Forbidden can be more semantically clear than optional with no allowed types.

For view schema, this can be useful if you need to: - run a specific out of schema handler when a field is present, but otherwise are ignoring or tolerating (ex: via extra fields) unmentioned fields. - prevent a specific field from being used as an extra field (perhaps for some past of future compatibility reason) - keep a field in a schema for metadata purposes (ex: for improved error messaging, error handling or documentation) that is not used in this specific version of the schema (ex: to document what it was or will be used for).

For stored schema, this can be useful if you need to: - have a field which can have its schema updated to Optional or Sequence of any type. - to exclude a field from extra fields - for the schema system to use as a default for fields which aren't declared (ex: when updating a field that did not exist into one that does)

WARNING: This API is provided as an alpha preview and may change without notice. Use at your own risk.

#### Signature {#forbidden-signature}

```typescript
Forbidden = 3
```

### Optional (ALPHA) {#optional-enummember}

0 or 1 items.

WARNING: This API is provided as an alpha preview and may change without notice. Use at your own risk.

#### Signature {#optional-signature}

```typescript
Optional = 1
```

### Sequence (ALPHA) {#sequence-enummember}

0 or more items.

WARNING: This API is provided as an alpha preview and may change without notice. Use at your own risk.

#### Signature {#sequence-signature}

```typescript
Sequence = 2
```

### Single (ALPHA) {#single-enummember}

Exactly one item.

WARNING: This API is provided as an alpha preview and may change without notice. Use at your own risk.

#### Signature {#single-signature}

```typescript
Single = 0
```
