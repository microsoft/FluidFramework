{
  "title": "DataProcessingError Class",
  "summary": "DataProcessingError indicates we hit a fatal error while processing incoming data from the Fluid Service. The error will often originate in the dataStore or DDS implementation that is responding to incoming changes. This differs from DataCorruptionError in that this may be a transient error that will not repro in another client or session.",
  "kind": "Class",
  "members": {
    "Property": {
      "canRetry": "/docs/apis/container-utils/dataprocessingerror-class#canretry-property",
      "errorType": "/docs/apis/container-utils/dataprocessingerror-class#errortype-property"
    },
    "Method": {
      "create": "/docs/apis/container-utils/dataprocessingerror-class#create-method",
      "wrapIfUnrecognized": "/docs/apis/container-utils/dataprocessingerror-class#wrapifunrecognized-method"
    }
  },
  "package": "@fluidframework/container-utils",
  "unscopedPackageName": "container-utils"
}

[//]: # (Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter.)

[Packages](/docs/apis/) &gt; [@fluidframework/container-utils](/docs/apis/container-utils) &gt; [DataProcessingError](/docs/apis/container-utils/dataprocessingerror-class)

DataProcessingError indicates we hit a fatal error while processing incoming data from the Fluid Service. The error will often originate in the dataStore or DDS implementation that is responding to incoming changes. This differs from DataCorruptionError in that this may be a transient error that will not repro in another client or session.

## Signature {#dataprocessingerror-signature}

```typescript
export declare class DataProcessingError extends LoggingError implements IErrorBase, IFluidErrorBase
```

**Extends:** [LoggingError](/docs/apis/telemetry-utils/loggingerror-class)

**Implements:** IErrorBase, [IFluidErrorBase](/docs/apis/telemetry-utils/ifluiderrorbase-interface)

## Static Methods

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th>
        Method
      </th>
      <th>
        Return Type
      </th>
      <th>
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/container-utils/dataprocessingerror-class#create-method'>create</a>
      </td>
      <td>
        <span><a href='/docs/apis/telemetry-utils/ifluiderrorbase-interface'>IFluidErrorBase</a></span>
      </td>
      <td>
        Create a new DataProcessingError detected and raised with the FF code
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/container-utils/dataprocessingerror-class#wrapifunrecognized-method'>wrapIfUnrecognized</a>
      </td>
      <td>
        <span><a href='/docs/apis/telemetry-utils/ifluiderrorbase-interface'>IFluidErrorBase</a></span>
      </td>
      <td>
        Wrap the given error in a DataProcessingError, unless the error is already of a known type with the exception of a normalized LoggingError, which will still be wrapped. In either case, the error will have some relevant properties added for telemetry We wrap conditionally since known error types represent well-understood failure modes, and ideally one day we will move away from throwing these errors but rather we'll return them. But an unrecognized error needs to be classified as DataProcessingError.
      </td>
    </tr>
  </tbody>
</table>

## Properties

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th>
        Property
      </th>
      <th>
        Modifiers
      </th>
      <th>
        Type
      </th>
      <th>
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/container-utils/dataprocessingerror-class#canretry-property'>canRetry</a>
      </td>
      <td>
        <code>readonly</code>
      </td>
      <td>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/container-utils/dataprocessingerror-class#errortype-property'>errorType</a>
      </td>
      <td>
        <code>readonly</code>
      </td>
      <td>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Property Details

### canRetry {#canretry-property}

#### Signature {#canretry-signature}

```typescript
readonly canRetry = false;
```

### errorType {#errortype-property}

#### Signature {#errortype-signature}

```typescript
readonly errorType = ContainerErrorType.dataProcessingError;
```

## Method Details

### create {#create-method}

Create a new DataProcessingError detected and raised with the FF code

#### Signature {#create-signature}

```typescript
static create(errorMessage: string, dataProcessingCodepath: string, sequencedMessage?: ISequencedDocumentMessage, props?: ITelemetryProperties): IFluidErrorBase;
```

#### Parameters {#create-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th>
        Parameter
      </th>
      <th>
        Modifiers
      </th>
      <th>
        Type
      </th>
      <th>
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        errorMessage
      </td>
      <td>
      </td>
      <td>
        <span>string</span>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        dataProcessingCodepath
      </td>
      <td>
      </td>
      <td>
        <span>string</span>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        sequencedMessage
      </td>
      <td>
        optional
      </td>
      <td>
        <span><a href='/docs/apis/protocol-definitions/isequenceddocumentmessage-interface'>ISequencedDocumentMessage</a></span>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        props
      </td>
      <td>
        optional
      </td>
      <td>
        <span>ITelemetryProperties</span>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#create-returns}

**Return type:** [IFluidErrorBase](/docs/apis/telemetry-utils/ifluiderrorbase-interface)

### wrapIfUnrecognized {#wrapifunrecognized-method}

Wrap the given error in a DataProcessingError, unless the error is already of a known type with the exception of a normalized LoggingError, which will still be wrapped. In either case, the error will have some relevant properties added for telemetry We wrap conditionally since known error types represent well-understood failure modes, and ideally one day we will move away from throwing these errors but rather we'll return them. But an unrecognized error needs to be classified as DataProcessingError.

#### Signature {#wrapifunrecognized-signature}

```typescript
static wrapIfUnrecognized(originalError: any, dataProcessingCodepath: string, messageLike?: Partial<Pick<ISequencedDocumentMessage, "clientId" | "sequenceNumber" | "clientSequenceNumber" | "referenceSequenceNumber" | "minimumSequenceNumber" | "timestamp">>): IFluidErrorBase;
```

#### Parameters {#wrapifunrecognized-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th>
        Parameter
      </th>
      <th>
        Modifiers
      </th>
      <th>
        Type
      </th>
      <th>
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        originalError
      </td>
      <td>
      </td>
      <td>
        <span>any</span>
      </td>
      <td>
        error to be converted
      </td>
    </tr>
    <tr>
      <td>
        dataProcessingCodepath
      </td>
      <td>
      </td>
      <td>
        <span>string</span>
      </td>
      <td>
        which codepath failed while processing data
      </td>
    </tr>
    <tr>
      <td>
        messageLike
      </td>
      <td>
        optional
      </td>
      <td>
        <span>Partial&lt;Pick&lt;<a href='/docs/apis/protocol-definitions/isequenceddocumentmessage-interface'>ISequencedDocumentMessage</a>, &quot;clientId&quot; &#124; &quot;sequenceNumber&quot; &#124; &quot;clientSequenceNumber&quot; &#124; &quot;referenceSequenceNumber&quot; &#124; &quot;minimumSequenceNumber&quot; &#124; &quot;timestamp&quot;&gt;&gt;</span>
      </td>
      <td>
        Sequenced message to include info about via telemetry props
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#wrapifunrecognized-returns}

Either a new DataProcessingError, or (if wrapping is deemed unnecessary) the given error

**Return type:** [IFluidErrorBase](/docs/apis/telemetry-utils/ifluiderrorbase-interface)
