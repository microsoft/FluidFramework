{
  "title": "@fluidframework/register-collection Package",
  "kind": "Package",
  "members": {
    "Class": {
      "ConsensusRegisterCollection": "/docs/apis/register-collection/consensusregistercollection-class",
      "ConsensusRegisterCollectionFactory": "/docs/apis/register-collection/consensusregistercollectionfactory-class"
    },
    "Interface": {
      "IConsensusRegisterCollection": "/docs/apis/register-collection/iconsensusregistercollection-interface",
      "IConsensusRegisterCollectionEvents": "/docs/apis/register-collection/iconsensusregistercollectionevents-interface",
      "IConsensusRegisterCollectionFactory": "/docs/apis/register-collection/iconsensusregistercollectionfactory-interface"
    },
    "Enum": {
      "ReadPolicy": "/docs/apis/register-collection/readpolicy-enum"
    }
  },
  "package": "@fluidframework/register-collection",
  "unscopedPackageName": "register-collection"
}

[//]: # (Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter.)

## Interfaces

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th>
        Interface
      </th>
      <th>
        Alerts
      </th>
      <th>
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/register-collection/iconsensusregistercollection-interface'>IConsensusRegisterCollection</a>
      </td>
      <td>
        <code>ALPHA</code>
      </td>
      <td>
        <p>
          A distributed data structure that holds a set of registers with update versions. On concurrent updates, a register internally stores all possible versions of a value by using reference sequence number of the incoming update.
        </p>
        <p>
          Using all the stored versions, we can then distinguish amongst different read policies. Below are the policies we support:
        </p>
        <p>
          Atomic: Atomicity requires a linearizable register. A linearizable register behaves as if there is only a single copy of the data, and that every operation appears to take effect atomically at one point in time. This definition implies that operations are executed in an well-defined order. On a concurrent update, we perform a compare-and-set operation, where we compare a register sequence number with the incoming reference sequence number. The earliest operation overwriting prior sequence numbers wins since every client reaches to an agreement on the value. So we can safely return the first value.
        </p>
        <p>
          LWW: The last write to a key always wins.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/register-collection/iconsensusregistercollectionevents-interface'>IConsensusRegisterCollectionEvents</a>
      </td>
      <td>
        <code>ALPHA</code>
      </td>
      <td>
        Events emitted by <a href='/docs/apis/register-collection/iconsensusregistercollection-interface'>IConsensusRegisterCollection</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/register-collection/iconsensusregistercollectionfactory-interface'>IConsensusRegisterCollectionFactory</a>
      </td>
      <td>
        <code>ALPHA</code>
      </td>
      <td>
        <p>
          Consensus Register Collection channel factory interface
        </p>
        <p>
          Extends the base IChannelFactory to return a more definite type of IConsensusRegisterCollection Use for the runtime to create and load distributed data structure by type name of each channel.
        </p>
      </td>
    </tr>
  </tbody>
</table>

## Classes

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th>
        Class
      </th>
      <th>
        Alerts
      </th>
      <th>
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/register-collection/consensusregistercollection-class'>ConsensusRegisterCollection</a>
      </td>
      <td>
        <code>ALPHA</code>
      </td>
      <td>
        <p>
          A distributed data structure that holds a set of registers with update versions. On concurrent updates, a register internally stores all possible versions of a value by using reference sequence number of the incoming update.
        </p>
        <p>
          Using all the stored versions, we can then distinguish amongst different read policies. Below are the policies we support:
        </p>
        <p>
          Atomic: Atomicity requires a linearizable register. A linearizable register behaves as if there is only a single copy of the data, and that every operation appears to take effect atomically at one point in time. This definition implies that operations are executed in an well-defined order. On a concurrent update, we perform a compare-and-set operation, where we compare a register sequence number with the incoming reference sequence number. The earliest operation overwriting prior sequence numbers wins since every client reaches to an agreement on the value. So we can safely return the first value.
        </p>
        <p>
          LWW: The last write to a key always wins.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/register-collection/consensusregistercollectionfactory-class'>ConsensusRegisterCollectionFactory</a>
      </td>
      <td>
        <code>ALPHA</code>
      </td>
      <td>
        The factory that defines the consensus queue.
      </td>
    </tr>
  </tbody>
</table>

## Enumerations

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th>
        Enum
      </th>
      <th>
        Alerts
      </th>
      <th>
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/register-collection/readpolicy-enum'>ReadPolicy</a>
      </td>
      <td>
        <code>ALPHA</code>
      </td>
      <td>
        Read policies used when reading the map value.
      </td>
    </tr>
  </tbody>
</table>
