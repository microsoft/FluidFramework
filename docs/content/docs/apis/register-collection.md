{
  "title": "@fluidframework/register-collection Package",
  "kind": "Package",
  "members": {
    "Class": {
      "ConsensusRegisterCollection": "/docs/apis/register-collection/consensusregistercollection-class",
      "ConsensusRegisterCollectionFactory": "/docs/apis/register-collection/consensusregistercollectionfactory-class"
    },
    "Interface": {
      "IConsensusRegisterCollection": "/docs/apis/register-collection/iconsensusregistercollection-interface",
      "IConsensusRegisterCollectionEvents": "/docs/apis/register-collection/iconsensusregistercollectionevents-interface",
      "IConsensusRegisterCollectionFactory": "/docs/apis/register-collection/iconsensusregistercollectionfactory-interface"
    },
    "Enum": {
      "ReadPolicy": "/docs/apis/register-collection#readpolicy-enum"
    }
  },
  "package": "@fluidframework/register-collection",
  "unscopedPackageName": "register-collection"
}

[//]: # (Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter.)

[Packages](/docs/apis/) &gt; [@fluidframework/register-collection](/docs/apis/register-collection)

## Interfaces

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th>
        Interface
      </th>
      <th>
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/register-collection/iconsensusregistercollection-interface'>IConsensusRegisterCollection</a>
      </td>
      <td>
        <p>
          Consensus Register Collection.
        </p>
        <p>
          A consensus register collection is a distributed data structure, which holds a set of registers with update versions. On concurrent updates, a register internally stores all possible versions of a value by using reference sequence number of the incoming update.
        </p>
        <p>
          Using all the stored versions, we can then distinguish amongst different read policies. Below are the policies we support:
        </p>
        <p>
          Atomic: Atomicity requires a linearizable register. A linearizable register behaves as if there is only a single copy of the data, and that every operation appears to take effect atomically at one point in time. This definition implies that operations are executed in an well-defined order. On a concurrent update, we perform a compare-and-set operation, where we compare a register sequence number with the incoming reference sequence number. The earliest operation overwriting prior sequence numbers wins since every client reaches to an agreement on the value. So we can safely return the first value.
        </p>
        <p>
          LWW: The last write to a key always wins.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/register-collection/iconsensusregistercollectionevents-interface'>IConsensusRegisterCollectionEvents</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/register-collection/iconsensusregistercollectionfactory-interface'>IConsensusRegisterCollectionFactory</a>
      </td>
      <td>
        <p>
          Consensus Register Collection channel factory interface
        </p>
        <p>
          Extends the base IChannelFactory to return a more definite type of IConsensusRegisterCollection Use for the runtime to create and load distributed data structure by type name of each channel
        </p>
      </td>
    </tr>
  </tbody>
</table>

## Classes

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th>
        Class
      </th>
      <th>
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/register-collection/consensusregistercollection-class'>ConsensusRegisterCollection</a>
      </td>
      <td>
        Implementation of a consensus register collection
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/register-collection/consensusregistercollectionfactory-class'>ConsensusRegisterCollectionFactory</a>
      </td>
      <td>
        The factory that defines the consensus queue
      </td>
    </tr>
  </tbody>
</table>

## Enumerations

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th>
        Enum
      </th>
      <th>
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/register-collection#readpolicy-enum'>ReadPolicy</a>
      </td>
      <td>
        Read policies used when reading the map value.
      </td>
    </tr>
  </tbody>
</table>

## Enumeration Details

### ReadPolicy {#readpolicy-enum}

Read policies used when reading the map value.

#### Signature {#readpolicy-signature}

```typescript
export declare enum ReadPolicy
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th>
        Flag
      </th>
      <th>
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/register-collection#readpolicy-atomic-enummember'>Atomic</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/register-collection#readpolicy-lww-enummember'>LWW</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

##### Atomic {#readpolicy-atomic-enummember}

###### Signature {#atomic-signature}

```typescript
Atomic = 0
```

##### LWW {#readpolicy-lww-enummember}

###### Signature {#lww-signature}

```typescript
LWW = 1
```
