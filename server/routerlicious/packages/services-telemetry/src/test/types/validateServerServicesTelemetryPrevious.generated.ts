/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/server-services-telemetry-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BaseLumberjackSchemaValidator": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_BaseLumberjackSchemaValidator = requireAssignableTo<TypeOnly<old.BaseLumberjackSchemaValidator>, TypeOnly<current.BaseLumberjackSchemaValidator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BaseLumberjackSchemaValidator": {"backCompat": false}
 */
declare type current_as_old_for_Class_BaseLumberjackSchemaValidator = requireAssignableTo<TypeOnly<current.BaseLumberjackSchemaValidator>, TypeOnly<old.BaseLumberjackSchemaValidator>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BasePropertiesValidator": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_BasePropertiesValidator = requireAssignableTo<TypeOnly<old.BasePropertiesValidator>, TypeOnly<current.BasePropertiesValidator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BasePropertiesValidator": {"backCompat": false}
 */
declare type current_as_old_for_Class_BasePropertiesValidator = requireAssignableTo<TypeOnly<current.BasePropertiesValidator>, TypeOnly<old.BasePropertiesValidator>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BaseSanitizationLumberFormatter": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_BaseSanitizationLumberFormatter = requireAssignableTo<TypeOnly<old.BaseSanitizationLumberFormatter>, TypeOnly<current.BaseSanitizationLumberFormatter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BaseSanitizationLumberFormatter": {"backCompat": false}
 */
declare type current_as_old_for_Class_BaseSanitizationLumberFormatter = requireAssignableTo<TypeOnly<current.BaseSanitizationLumberFormatter>, TypeOnly<old.BaseSanitizationLumberFormatter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LambdaSchemaValidator": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_LambdaSchemaValidator = requireAssignableTo<TypeOnly<old.LambdaSchemaValidator>, TypeOnly<current.LambdaSchemaValidator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LambdaSchemaValidator": {"backCompat": false}
 */
declare type current_as_old_for_Class_LambdaSchemaValidator = requireAssignableTo<TypeOnly<current.LambdaSchemaValidator>, TypeOnly<old.LambdaSchemaValidator>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Lumber": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Lumber = requireAssignableTo<TypeOnly<old.Lumber>, TypeOnly<current.Lumber>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Lumber": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_Class_Lumber = requireAssignableTo<TypeOnly<current.Lumber>, TypeOnly<old.Lumber>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Lumberjack": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Lumberjack = requireAssignableTo<TypeOnly<old.Lumberjack>, TypeOnly<current.Lumberjack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Lumberjack": {"backCompat": false}
 */
declare type current_as_old_for_Class_Lumberjack = requireAssignableTo<TypeOnly<current.Lumberjack>, TypeOnly<old.Lumberjack>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SanitizationLumberFormatter": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SanitizationLumberFormatter = requireAssignableTo<TypeOnly<old.SanitizationLumberFormatter>, TypeOnly<current.SanitizationLumberFormatter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SanitizationLumberFormatter": {"backCompat": false}
 */
declare type current_as_old_for_Class_SanitizationLumberFormatter = requireAssignableTo<TypeOnly<current.SanitizationLumberFormatter>, TypeOnly<old.SanitizationLumberFormatter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestEngine1": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestEngine1 = requireAssignableTo<TypeOnly<old.TestEngine1>, TypeOnly<current.TestEngine1>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestEngine1": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestEngine1 = requireAssignableTo<TypeOnly<current.TestEngine1>, TypeOnly<old.TestEngine1>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestEngine2": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestEngine2 = requireAssignableTo<TypeOnly<old.TestEngine2>, TypeOnly<current.TestEngine2>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestEngine2": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestEngine2 = requireAssignableTo<TypeOnly<current.TestEngine2>, TypeOnly<old.TestEngine2>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestFormatter": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestFormatter = requireAssignableTo<TypeOnly<old.TestFormatter>, TypeOnly<current.TestFormatter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestFormatter": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestFormatter = requireAssignableTo<TypeOnly<current.TestFormatter>, TypeOnly<old.TestFormatter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestLumberjack": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestLumberjack = requireAssignableTo<TypeOnly<old.TestLumberjack>, TypeOnly<current.TestLumberjack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestLumberjack": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestLumberjack = requireAssignableTo<TypeOnly<current.TestLumberjack>, TypeOnly<old.TestLumberjack>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestSchemaValidator": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestSchemaValidator = requireAssignableTo<TypeOnly<old.TestSchemaValidator>, TypeOnly<current.TestSchemaValidator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestSchemaValidator": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestSchemaValidator = requireAssignableTo<TypeOnly<current.TestSchemaValidator>, TypeOnly<old.TestSchemaValidator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_BaseLumberjackSchemaValidator": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_BaseLumberjackSchemaValidator = requireAssignableTo<TypeOnly<typeof current.BaseLumberjackSchemaValidator>, TypeOnly<typeof old.BaseLumberjackSchemaValidator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_BasePropertiesValidator": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_BasePropertiesValidator = requireAssignableTo<TypeOnly<typeof current.BasePropertiesValidator>, TypeOnly<typeof old.BasePropertiesValidator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_BaseSanitizationLumberFormatter": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_BaseSanitizationLumberFormatter = requireAssignableTo<TypeOnly<typeof current.BaseSanitizationLumberFormatter>, TypeOnly<typeof old.BaseSanitizationLumberFormatter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_LambdaSchemaValidator": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_LambdaSchemaValidator = requireAssignableTo<TypeOnly<typeof current.LambdaSchemaValidator>, TypeOnly<typeof old.LambdaSchemaValidator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Lumber": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Lumber = requireAssignableTo<TypeOnly<typeof current.Lumber>, TypeOnly<typeof old.Lumber>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Lumberjack": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Lumberjack = requireAssignableTo<TypeOnly<typeof current.Lumberjack>, TypeOnly<typeof old.Lumberjack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SanitizationLumberFormatter": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SanitizationLumberFormatter = requireAssignableTo<TypeOnly<typeof current.SanitizationLumberFormatter>, TypeOnly<typeof old.SanitizationLumberFormatter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestEngine1": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestEngine1 = requireAssignableTo<TypeOnly<typeof current.TestEngine1>, TypeOnly<typeof old.TestEngine1>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestEngine2": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestEngine2 = requireAssignableTo<TypeOnly<typeof current.TestEngine2>, TypeOnly<typeof old.TestEngine2>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestFormatter": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestFormatter = requireAssignableTo<TypeOnly<typeof current.TestFormatter>, TypeOnly<typeof old.TestFormatter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestLumberjack": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestLumberjack = requireAssignableTo<TypeOnly<typeof current.TestLumberjack>, TypeOnly<typeof old.TestLumberjack>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestSchemaValidator": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestSchemaValidator = requireAssignableTo<TypeOnly<typeof current.TestSchemaValidator>, TypeOnly<typeof old.TestSchemaValidator>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_BaseTelemetryProperties": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_BaseTelemetryProperties = requireAssignableTo<TypeOnly<old.BaseTelemetryProperties>, TypeOnly<current.BaseTelemetryProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_BaseTelemetryProperties": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_Enum_BaseTelemetryProperties = requireAssignableTo<TypeOnly<current.BaseTelemetryProperties>, TypeOnly<old.BaseTelemetryProperties>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_CommonProperties": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_CommonProperties = requireAssignableTo<TypeOnly<old.CommonProperties>, TypeOnly<current.CommonProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_CommonProperties": {"backCompat": false}
 */
declare type current_as_old_for_Enum_CommonProperties = requireAssignableTo<TypeOnly<current.CommonProperties>, TypeOnly<old.CommonProperties>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_HttpProperties": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_HttpProperties = requireAssignableTo<TypeOnly<old.HttpProperties>, TypeOnly<current.HttpProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_HttpProperties": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_Enum_HttpProperties = requireAssignableTo<TypeOnly<current.HttpProperties>, TypeOnly<old.HttpProperties>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_LogLevel": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_LogLevel = requireAssignableTo<TypeOnly<old.LogLevel>, TypeOnly<current.LogLevel>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_LogLevel": {"backCompat": false}
 */
declare type current_as_old_for_Enum_LogLevel = requireAssignableTo<TypeOnly<current.LogLevel>, TypeOnly<old.LogLevel>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_LumberEventName": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_LumberEventName = requireAssignableTo<TypeOnly<old.LumberEventName>, TypeOnly<current.LumberEventName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_LumberEventName": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_Enum_LumberEventName = requireAssignableTo<TypeOnly<current.LumberEventName>, TypeOnly<old.LumberEventName>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_LumberType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_LumberType = requireAssignableTo<TypeOnly<old.LumberType>, TypeOnly<current.LumberType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_LumberType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_LumberType = requireAssignableTo<TypeOnly<current.LumberType>, TypeOnly<old.LumberType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_QueuedMessageProperties": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_QueuedMessageProperties = requireAssignableTo<TypeOnly<old.QueuedMessageProperties>, TypeOnly<current.QueuedMessageProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_QueuedMessageProperties": {"backCompat": false}
 */
declare type current_as_old_for_Enum_QueuedMessageProperties = requireAssignableTo<TypeOnly<current.QueuedMessageProperties>, TypeOnly<old.QueuedMessageProperties>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_SessionState": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_SessionState = requireAssignableTo<TypeOnly<old.SessionState>, TypeOnly<current.SessionState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_SessionState": {"backCompat": false}
 */
declare type current_as_old_for_Enum_SessionState = requireAssignableTo<TypeOnly<current.SessionState>, TypeOnly<old.SessionState>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ThrottlingTelemetryProperties": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_ThrottlingTelemetryProperties = requireAssignableTo<TypeOnly<old.ThrottlingTelemetryProperties>, TypeOnly<current.ThrottlingTelemetryProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ThrottlingTelemetryProperties": {"backCompat": false}
 */
declare type current_as_old_for_Enum_ThrottlingTelemetryProperties = requireAssignableTo<TypeOnly<current.ThrottlingTelemetryProperties>, TypeOnly<old.ThrottlingTelemetryProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_handleError": {"backCompat": false}
 */
declare type current_as_old_for_Function_handleError = requireAssignableTo<TypeOnly<typeof current.handleError>, TypeOnly<typeof old.handleError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILumberFormatter": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ILumberFormatter = requireAssignableTo<TypeOnly<old.ILumberFormatter>, TypeOnly<current.ILumberFormatter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILumberFormatter": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ILumberFormatter = requireAssignableTo<TypeOnly<current.ILumberFormatter>, TypeOnly<old.ILumberFormatter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILumberjackEngine": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ILumberjackEngine = requireAssignableTo<TypeOnly<old.ILumberjackEngine>, TypeOnly<current.ILumberjackEngine>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILumberjackEngine": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ILumberjackEngine = requireAssignableTo<TypeOnly<current.ILumberjackEngine>, TypeOnly<old.ILumberjackEngine>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILumberjackOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ILumberjackOptions = requireAssignableTo<TypeOnly<old.ILumberjackOptions>, TypeOnly<current.ILumberjackOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILumberjackOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ILumberjackOptions = requireAssignableTo<TypeOnly<current.ILumberjackOptions>, TypeOnly<old.ILumberjackOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILumberjackSchemaValidationResult": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ILumberjackSchemaValidationResult = requireAssignableTo<TypeOnly<old.ILumberjackSchemaValidationResult>, TypeOnly<current.ILumberjackSchemaValidationResult>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILumberjackSchemaValidationResult": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ILumberjackSchemaValidationResult = requireAssignableTo<TypeOnly<current.ILumberjackSchemaValidationResult>, TypeOnly<old.ILumberjackSchemaValidationResult>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILumberjackSchemaValidator": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ILumberjackSchemaValidator = requireAssignableTo<TypeOnly<old.ILumberjackSchemaValidator>, TypeOnly<current.ILumberjackSchemaValidator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILumberjackSchemaValidator": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ILumberjackSchemaValidator = requireAssignableTo<TypeOnly<current.ILumberjackSchemaValidator>, TypeOnly<old.ILumberjackSchemaValidator>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITelemetryContext = requireAssignableTo<TypeOnly<old.ITelemetryContext>, TypeOnly<current.ITelemetryContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryContext = requireAssignableTo<TypeOnly<current.ITelemetryContext>, TypeOnly<old.ITelemetryContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryContextProperties": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Interface_ITelemetryContextProperties = requireAssignableTo<TypeOnly<old.ITelemetryContextProperties>, TypeOnly<current.ITelemetryContextProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITelemetryContextProperties": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITelemetryContextProperties = requireAssignableTo<TypeOnly<current.ITelemetryContextProperties>, TypeOnly<old.ITelemetryContextProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_getGlobalTelemetryContext": {"backCompat": false}
 */
declare type current_as_old_for_Variable_getGlobalTelemetryContext = requireAssignableTo<TypeOnly<typeof current.getGlobalTelemetryContext>, TypeOnly<typeof old.getGlobalTelemetryContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_getLumberBaseProperties": {"backCompat": false}
 */
declare type current_as_old_for_Variable_getLumberBaseProperties = requireAssignableTo<TypeOnly<typeof current.getLumberBaseProperties>, TypeOnly<typeof old.getLumberBaseProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_setGlobalTelemetryContext": {"backCompat": false}
 */
declare type current_as_old_for_Variable_setGlobalTelemetryContext = requireAssignableTo<TypeOnly<typeof current.setGlobalTelemetryContext>, TypeOnly<typeof old.setGlobalTelemetryContext>>
