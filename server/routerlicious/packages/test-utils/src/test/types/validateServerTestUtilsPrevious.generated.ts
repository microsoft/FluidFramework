/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/server-test-utils-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DebugLogger": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DebugLogger = requireAssignableTo<TypeOnly<old.DebugLogger>, TypeOnly<current.DebugLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DebugLogger": {"backCompat": false}
 */
declare type current_as_old_for_Class_DebugLogger = requireAssignableTo<TypeOnly<current.DebugLogger>, TypeOnly<old.DebugLogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_KafkaMessageFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_KafkaMessageFactory = requireAssignableTo<TypeOnly<old.KafkaMessageFactory>, TypeOnly<current.KafkaMessageFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_KafkaMessageFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_KafkaMessageFactory = requireAssignableTo<TypeOnly<current.KafkaMessageFactory>, TypeOnly<old.KafkaMessageFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MessageFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MessageFactory = requireAssignableTo<TypeOnly<old.MessageFactory>, TypeOnly<current.MessageFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MessageFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_MessageFactory = requireAssignableTo<TypeOnly<current.MessageFactory>, TypeOnly<old.MessageFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestCache": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestCache = requireAssignableTo<TypeOnly<old.TestCache>, TypeOnly<current.TestCache>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestCache": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestCache = requireAssignableTo<TypeOnly<current.TestCache>, TypeOnly<old.TestCache>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestClientManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestClientManager = requireAssignableTo<TypeOnly<old.TestClientManager>, TypeOnly<current.TestClientManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestClientManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestClientManager = requireAssignableTo<TypeOnly<current.TestClientManager>, TypeOnly<old.TestClientManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestCollection = requireAssignableTo<TypeOnly<old.TestCollection>, TypeOnly<current.TestCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestCollection": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestCollection = requireAssignableTo<TypeOnly<current.TestCollection>, TypeOnly<old.TestCollection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestConsumer": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestConsumer = requireAssignableTo<TypeOnly<old.TestConsumer>, TypeOnly<current.TestConsumer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestConsumer": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestConsumer = requireAssignableTo<TypeOnly<current.TestConsumer>, TypeOnly<old.TestConsumer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestContext": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Class_TestContext = requireAssignableTo<TypeOnly<old.TestContext>, TypeOnly<current.TestContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestContext": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestContext = requireAssignableTo<TypeOnly<current.TestContext>, TypeOnly<old.TestContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestDb": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestDb = requireAssignableTo<TypeOnly<old.TestDb>, TypeOnly<current.TestDb>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestDb": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestDb = requireAssignableTo<TypeOnly<current.TestDb>, TypeOnly<old.TestDb>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestDbFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestDbFactory = requireAssignableTo<TypeOnly<old.TestDbFactory>, TypeOnly<current.TestDbFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestDbFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestDbFactory = requireAssignableTo<TypeOnly<current.TestDbFactory>, TypeOnly<old.TestDbFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestDeltaManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestDeltaManager = requireAssignableTo<TypeOnly<old.TestDeltaManager>, TypeOnly<current.TestDeltaManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestDeltaManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestDeltaManager = requireAssignableTo<TypeOnly<current.TestDeltaManager>, TypeOnly<old.TestDeltaManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestDocumentStorage": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestDocumentStorage = requireAssignableTo<TypeOnly<old.TestDocumentStorage>, TypeOnly<current.TestDocumentStorage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestDocumentStorage": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestDocumentStorage = requireAssignableTo<TypeOnly<current.TestDocumentStorage>, TypeOnly<old.TestDocumentStorage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestHistorian": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestHistorian = requireAssignableTo<TypeOnly<old.TestHistorian>, TypeOnly<current.TestHistorian>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestHistorian": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestHistorian = requireAssignableTo<TypeOnly<current.TestHistorian>, TypeOnly<old.TestHistorian>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestKafka": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestKafka = requireAssignableTo<TypeOnly<old.TestKafka>, TypeOnly<current.TestKafka>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestKafka": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestKafka = requireAssignableTo<TypeOnly<current.TestKafka>, TypeOnly<old.TestKafka>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestNotImplementedCheckpointRepository": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestNotImplementedCheckpointRepository = requireAssignableTo<TypeOnly<old.TestNotImplementedCheckpointRepository>, TypeOnly<current.TestNotImplementedCheckpointRepository>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestNotImplementedCheckpointRepository": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestNotImplementedCheckpointRepository = requireAssignableTo<TypeOnly<current.TestNotImplementedCheckpointRepository>, TypeOnly<old.TestNotImplementedCheckpointRepository>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestNotImplementedCheckpointService": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestNotImplementedCheckpointService = requireAssignableTo<TypeOnly<old.TestNotImplementedCheckpointService>, TypeOnly<current.TestNotImplementedCheckpointService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestNotImplementedCheckpointService": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestNotImplementedCheckpointService = requireAssignableTo<TypeOnly<current.TestNotImplementedCheckpointService>, TypeOnly<old.TestNotImplementedCheckpointService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestNotImplementedDocumentRepository": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestNotImplementedDocumentRepository = requireAssignableTo<TypeOnly<old.TestNotImplementedDocumentRepository>, TypeOnly<current.TestNotImplementedDocumentRepository>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestNotImplementedDocumentRepository": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestNotImplementedDocumentRepository = requireAssignableTo<TypeOnly<current.TestNotImplementedDocumentRepository>, TypeOnly<old.TestNotImplementedDocumentRepository>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestProducer": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Class_TestProducer = requireAssignableTo<TypeOnly<old.TestProducer>, TypeOnly<current.TestProducer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestProducer": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestProducer = requireAssignableTo<TypeOnly<current.TestProducer>, TypeOnly<old.TestProducer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestPublisher": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestPublisher = requireAssignableTo<TypeOnly<old.TestPublisher>, TypeOnly<current.TestPublisher>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestPublisher": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestPublisher = requireAssignableTo<TypeOnly<current.TestPublisher>, TypeOnly<old.TestPublisher>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestRedisClientConnectionManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestRedisClientConnectionManager = requireAssignableTo<TypeOnly<old.TestRedisClientConnectionManager>, TypeOnly<current.TestRedisClientConnectionManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestRedisClientConnectionManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestRedisClientConnectionManager = requireAssignableTo<TypeOnly<current.TestRedisClientConnectionManager>, TypeOnly<old.TestRedisClientConnectionManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestTenant": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestTenant = requireAssignableTo<TypeOnly<old.TestTenant>, TypeOnly<current.TestTenant>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestTenant": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestTenant = requireAssignableTo<TypeOnly<current.TestTenant>, TypeOnly<old.TestTenant>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestTenantManager": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Class_TestTenantManager = requireAssignableTo<TypeOnly<old.TestTenantManager>, TypeOnly<current.TestTenantManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestTenantManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestTenantManager = requireAssignableTo<TypeOnly<current.TestTenantManager>, TypeOnly<old.TestTenantManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestThrottleAndUsageStorageManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestThrottleAndUsageStorageManager = requireAssignableTo<TypeOnly<old.TestThrottleAndUsageStorageManager>, TypeOnly<current.TestThrottleAndUsageStorageManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestThrottleAndUsageStorageManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestThrottleAndUsageStorageManager = requireAssignableTo<TypeOnly<current.TestThrottleAndUsageStorageManager>, TypeOnly<old.TestThrottleAndUsageStorageManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestThrottler": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestThrottler = requireAssignableTo<TypeOnly<old.TestThrottler>, TypeOnly<current.TestThrottler>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestThrottler": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestThrottler = requireAssignableTo<TypeOnly<current.TestThrottler>, TypeOnly<old.TestThrottler>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestThrottlerHelper": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestThrottlerHelper = requireAssignableTo<TypeOnly<old.TestThrottlerHelper>, TypeOnly<current.TestThrottlerHelper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestThrottlerHelper": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestThrottlerHelper = requireAssignableTo<TypeOnly<current.TestThrottlerHelper>, TypeOnly<old.TestThrottlerHelper>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestTopic": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TestTopic = requireAssignableTo<TypeOnly<old.TestTopic>, TypeOnly<current.TestTopic>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TestTopic": {"backCompat": false}
 */
declare type current_as_old_for_Class_TestTopic = requireAssignableTo<TypeOnly<current.TestTopic>, TypeOnly<old.TestTopic>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DebugLogger": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DebugLogger = requireAssignableTo<TypeOnly<typeof current.DebugLogger>, TypeOnly<typeof old.DebugLogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_KafkaMessageFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_KafkaMessageFactory = requireAssignableTo<TypeOnly<typeof current.KafkaMessageFactory>, TypeOnly<typeof old.KafkaMessageFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MessageFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MessageFactory = requireAssignableTo<TypeOnly<typeof current.MessageFactory>, TypeOnly<typeof old.MessageFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestCache": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestCache = requireAssignableTo<TypeOnly<typeof current.TestCache>, TypeOnly<typeof old.TestCache>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestClientManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestClientManager = requireAssignableTo<TypeOnly<typeof current.TestClientManager>, TypeOnly<typeof old.TestClientManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestCollection = requireAssignableTo<TypeOnly<typeof current.TestCollection>, TypeOnly<typeof old.TestCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestConsumer": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestConsumer = requireAssignableTo<TypeOnly<typeof current.TestConsumer>, TypeOnly<typeof old.TestConsumer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestContext": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestContext = requireAssignableTo<TypeOnly<typeof current.TestContext>, TypeOnly<typeof old.TestContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestDb": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestDb = requireAssignableTo<TypeOnly<typeof current.TestDb>, TypeOnly<typeof old.TestDb>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestDbFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestDbFactory = requireAssignableTo<TypeOnly<typeof current.TestDbFactory>, TypeOnly<typeof old.TestDbFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestDeltaManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestDeltaManager = requireAssignableTo<TypeOnly<typeof current.TestDeltaManager>, TypeOnly<typeof old.TestDeltaManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestDocumentStorage": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestDocumentStorage = requireAssignableTo<TypeOnly<typeof current.TestDocumentStorage>, TypeOnly<typeof old.TestDocumentStorage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestHistorian": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestHistorian = requireAssignableTo<TypeOnly<typeof current.TestHistorian>, TypeOnly<typeof old.TestHistorian>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestKafka": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestKafka = requireAssignableTo<TypeOnly<typeof current.TestKafka>, TypeOnly<typeof old.TestKafka>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestNotImplementedCheckpointRepository": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestNotImplementedCheckpointRepository = requireAssignableTo<TypeOnly<typeof current.TestNotImplementedCheckpointRepository>, TypeOnly<typeof old.TestNotImplementedCheckpointRepository>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestNotImplementedCheckpointService": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestNotImplementedCheckpointService = requireAssignableTo<TypeOnly<typeof current.TestNotImplementedCheckpointService>, TypeOnly<typeof old.TestNotImplementedCheckpointService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestNotImplementedDocumentRepository": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestNotImplementedDocumentRepository = requireAssignableTo<TypeOnly<typeof current.TestNotImplementedDocumentRepository>, TypeOnly<typeof old.TestNotImplementedDocumentRepository>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestProducer": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestProducer = requireAssignableTo<TypeOnly<typeof current.TestProducer>, TypeOnly<typeof old.TestProducer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestPublisher": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestPublisher = requireAssignableTo<TypeOnly<typeof current.TestPublisher>, TypeOnly<typeof old.TestPublisher>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestRedisClientConnectionManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestRedisClientConnectionManager = requireAssignableTo<TypeOnly<typeof current.TestRedisClientConnectionManager>, TypeOnly<typeof old.TestRedisClientConnectionManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestTenant": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestTenant = requireAssignableTo<TypeOnly<typeof current.TestTenant>, TypeOnly<typeof old.TestTenant>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestTenantManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestTenantManager = requireAssignableTo<TypeOnly<typeof current.TestTenantManager>, TypeOnly<typeof old.TestTenantManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestThrottleAndUsageStorageManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestThrottleAndUsageStorageManager = requireAssignableTo<TypeOnly<typeof current.TestThrottleAndUsageStorageManager>, TypeOnly<typeof old.TestThrottleAndUsageStorageManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestThrottler": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestThrottler = requireAssignableTo<TypeOnly<typeof current.TestThrottler>, TypeOnly<typeof old.TestThrottler>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestThrottlerHelper": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestThrottlerHelper = requireAssignableTo<TypeOnly<typeof current.TestThrottlerHelper>, TypeOnly<typeof old.TestThrottlerHelper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TestTopic": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TestTopic = requireAssignableTo<TypeOnly<typeof current.TestTopic>, TypeOnly<typeof old.TestTopic>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_writeSummaryTree": {"backCompat": false}
 */
declare type current_as_old_for_Function_writeSummaryTree = requireAssignableTo<TypeOnly<typeof current.writeSummaryTree>, TypeOnly<typeof old.writeSummaryTree>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEvent": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IEvent = requireAssignableTo<TypeOnly<old.IEvent>, TypeOnly<current.IEvent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEvent": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IEvent = requireAssignableTo<TypeOnly<current.IEvent>, TypeOnly<old.IEvent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITestDbFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITestDbFactory = requireAssignableTo<TypeOnly<old.ITestDbFactory>, TypeOnly<current.ITestDbFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITestDbFactory": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITestDbFactory = requireAssignableTo<TypeOnly<current.ITestDbFactory>, TypeOnly<old.ITestDbFactory>>
