/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/server-services-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BasicWebServerFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_BasicWebServerFactory = requireAssignableTo<TypeOnly<old.BasicWebServerFactory>, TypeOnly<current.BasicWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BasicWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_BasicWebServerFactory = requireAssignableTo<TypeOnly<current.BasicWebServerFactory>, TypeOnly<old.BasicWebServerFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ClientManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ClientManager = requireAssignableTo<TypeOnly<old.ClientManager>, TypeOnly<current.ClientManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ClientManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_ClientManager = requireAssignableTo<TypeOnly<current.ClientManager>, TypeOnly<old.ClientManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DeltaManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DeltaManager = requireAssignableTo<TypeOnly<old.DeltaManager>, TypeOnly<current.DeltaManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DeltaManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_DeltaManager = requireAssignableTo<TypeOnly<current.DeltaManager>, TypeOnly<old.DeltaManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DocumentManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DocumentManager = requireAssignableTo<TypeOnly<old.DocumentManager>, TypeOnly<current.DocumentManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DocumentManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_DocumentManager = requireAssignableTo<TypeOnly<current.DocumentManager>, TypeOnly<old.DocumentManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DocumentStorage": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DocumentStorage = requireAssignableTo<TypeOnly<old.DocumentStorage>, TypeOnly<current.DocumentStorage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DocumentStorage": {"backCompat": false}
 */
declare type current_as_old_for_Class_DocumentStorage = requireAssignableTo<TypeOnly<current.DocumentStorage>, TypeOnly<old.DocumentStorage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_HttpServer": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_HttpServer = requireAssignableTo<TypeOnly<old.HttpServer>, TypeOnly<current.HttpServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_HttpServer": {"backCompat": false}
 */
declare type current_as_old_for_Class_HttpServer = requireAssignableTo<TypeOnly<current.HttpServer>, TypeOnly<old.HttpServer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MongoCollection": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MongoCollection = requireAssignableTo<TypeOnly<old.MongoCollection<never>>, TypeOnly<current.MongoCollection<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MongoCollection": {"backCompat": false}
 */
declare type current_as_old_for_Class_MongoCollection = requireAssignableTo<TypeOnly<current.MongoCollection<never>>, TypeOnly<old.MongoCollection<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MongoDb": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Class_MongoDb = requireAssignableTo<TypeOnly<old.MongoDb>, TypeOnly<current.MongoDb>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MongoDb": {"backCompat": false}
 */
declare type current_as_old_for_Class_MongoDb = requireAssignableTo<TypeOnly<current.MongoDb>, TypeOnly<old.MongoDb>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MongoDbFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MongoDbFactory = requireAssignableTo<TypeOnly<old.MongoDbFactory>, TypeOnly<current.MongoDbFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MongoDbFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_MongoDbFactory = requireAssignableTo<TypeOnly<current.MongoDbFactory>, TypeOnly<old.MongoDbFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NodeAllowList": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_NodeAllowList = requireAssignableTo<TypeOnly<old.NodeAllowList>, TypeOnly<current.NodeAllowList>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NodeAllowList": {"backCompat": false}
 */
declare type current_as_old_for_Class_NodeAllowList = requireAssignableTo<TypeOnly<current.NodeAllowList>, TypeOnly<old.NodeAllowList>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NodeClusterWebServerFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_NodeClusterWebServerFactory = requireAssignableTo<TypeOnly<old.NodeClusterWebServerFactory>, TypeOnly<current.NodeClusterWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NodeClusterWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_NodeClusterWebServerFactory = requireAssignableTo<TypeOnly<current.NodeClusterWebServerFactory>, TypeOnly<old.NodeClusterWebServerFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NodeCodeLoader": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_NodeCodeLoader = requireAssignableTo<TypeOnly<old.NodeCodeLoader>, TypeOnly<current.NodeCodeLoader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NodeCodeLoader": {"backCompat": false}
 */
declare type current_as_old_for_Class_NodeCodeLoader = requireAssignableTo<TypeOnly<current.NodeCodeLoader>, TypeOnly<old.NodeCodeLoader>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RedisCache": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RedisCache = requireAssignableTo<TypeOnly<old.RedisCache>, TypeOnly<current.RedisCache>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RedisCache": {"backCompat": false}
 */
declare type current_as_old_for_Class_RedisCache = requireAssignableTo<TypeOnly<current.RedisCache>, TypeOnly<old.RedisCache>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RedisSocketIoAdapter": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RedisSocketIoAdapter = requireAssignableTo<TypeOnly<old.RedisSocketIoAdapter>, TypeOnly<current.RedisSocketIoAdapter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RedisSocketIoAdapter": {"backCompat": false}
 */
declare type current_as_old_for_Class_RedisSocketIoAdapter = requireAssignableTo<TypeOnly<current.RedisSocketIoAdapter>, TypeOnly<old.RedisSocketIoAdapter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RedisThrottleAndUsageStorageManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RedisThrottleAndUsageStorageManager = requireAssignableTo<TypeOnly<old.RedisThrottleAndUsageStorageManager>, TypeOnly<current.RedisThrottleAndUsageStorageManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RedisThrottleAndUsageStorageManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_RedisThrottleAndUsageStorageManager = requireAssignableTo<TypeOnly<current.RedisThrottleAndUsageStorageManager>, TypeOnly<old.RedisThrottleAndUsageStorageManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RestLessServer": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RestLessServer = requireAssignableTo<TypeOnly<old.RestLessServer>, TypeOnly<current.RestLessServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RestLessServer": {"backCompat": false}
 */
declare type current_as_old_for_Class_RestLessServer = requireAssignableTo<TypeOnly<current.RestLessServer>, TypeOnly<old.RestLessServer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SecretManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SecretManager = requireAssignableTo<TypeOnly<old.SecretManager>, TypeOnly<current.SecretManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SecretManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_SecretManager = requireAssignableTo<TypeOnly<current.SecretManager>, TypeOnly<old.SecretManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SocketIoNodeClusterWebServerFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SocketIoNodeClusterWebServerFactory = requireAssignableTo<TypeOnly<old.SocketIoNodeClusterWebServerFactory>, TypeOnly<current.SocketIoNodeClusterWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SocketIoNodeClusterWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SocketIoNodeClusterWebServerFactory = requireAssignableTo<TypeOnly<current.SocketIoNodeClusterWebServerFactory>, TypeOnly<old.SocketIoNodeClusterWebServerFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SocketIoRedisPublisher": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SocketIoRedisPublisher = requireAssignableTo<TypeOnly<old.SocketIoRedisPublisher>, TypeOnly<current.SocketIoRedisPublisher>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SocketIoRedisPublisher": {"backCompat": false}
 */
declare type current_as_old_for_Class_SocketIoRedisPublisher = requireAssignableTo<TypeOnly<current.SocketIoRedisPublisher>, TypeOnly<old.SocketIoRedisPublisher>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SocketIoRedisTopic": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SocketIoRedisTopic = requireAssignableTo<TypeOnly<old.SocketIoRedisTopic>, TypeOnly<current.SocketIoRedisTopic>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SocketIoRedisTopic": {"backCompat": false}
 */
declare type current_as_old_for_Class_SocketIoRedisTopic = requireAssignableTo<TypeOnly<current.SocketIoRedisTopic>, TypeOnly<old.SocketIoRedisTopic>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SocketIoWebServerFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SocketIoWebServerFactory = requireAssignableTo<TypeOnly<old.SocketIoWebServerFactory>, TypeOnly<current.SocketIoWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SocketIoWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SocketIoWebServerFactory = requireAssignableTo<TypeOnly<current.SocketIoWebServerFactory>, TypeOnly<old.SocketIoWebServerFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_StorageNameRetriever": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_StorageNameRetriever = requireAssignableTo<TypeOnly<old.StorageNameRetriever>, TypeOnly<current.StorageNameRetriever>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_StorageNameRetriever": {"backCompat": false}
 */
declare type current_as_old_for_Class_StorageNameRetriever = requireAssignableTo<TypeOnly<current.StorageNameRetriever>, TypeOnly<old.StorageNameRetriever>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Tenant": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Tenant = requireAssignableTo<TypeOnly<old.Tenant>, TypeOnly<current.Tenant>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Tenant": {"backCompat": false}
 */
declare type current_as_old_for_Class_Tenant = requireAssignableTo<TypeOnly<current.Tenant>, TypeOnly<old.Tenant>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TenantManager": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Class_TenantManager = requireAssignableTo<TypeOnly<old.TenantManager>, TypeOnly<current.TenantManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TenantManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_TenantManager = requireAssignableTo<TypeOnly<current.TenantManager>, TypeOnly<old.TenantManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Throttler": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Throttler = requireAssignableTo<TypeOnly<old.Throttler>, TypeOnly<current.Throttler>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Throttler": {"backCompat": false}
 */
declare type current_as_old_for_Class_Throttler = requireAssignableTo<TypeOnly<current.Throttler>, TypeOnly<old.Throttler>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ThrottlerHelper": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ThrottlerHelper = requireAssignableTo<TypeOnly<old.ThrottlerHelper>, TypeOnly<current.ThrottlerHelper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ThrottlerHelper": {"backCompat": false}
 */
declare type current_as_old_for_Class_ThrottlerHelper = requireAssignableTo<TypeOnly<current.ThrottlerHelper>, TypeOnly<old.ThrottlerHelper>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WebServer": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_WebServer = requireAssignableTo<TypeOnly<old.WebServer>, TypeOnly<current.WebServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WebServer": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_Class_WebServer = requireAssignableTo<TypeOnly<current.WebServer>, TypeOnly<old.WebServer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WholeSummaryReadGitManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_WholeSummaryReadGitManager = requireAssignableTo<TypeOnly<old.WholeSummaryReadGitManager>, TypeOnly<current.WholeSummaryReadGitManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WholeSummaryReadGitManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_WholeSummaryReadGitManager = requireAssignableTo<TypeOnly<current.WholeSummaryReadGitManager>, TypeOnly<old.WholeSummaryReadGitManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WholeSummaryWriteGitManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_WholeSummaryWriteGitManager = requireAssignableTo<TypeOnly<old.WholeSummaryWriteGitManager>, TypeOnly<current.WholeSummaryWriteGitManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WholeSummaryWriteGitManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_WholeSummaryWriteGitManager = requireAssignableTo<TypeOnly<current.WholeSummaryWriteGitManager>, TypeOnly<old.WholeSummaryWriteGitManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_BasicWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_BasicWebServerFactory = requireAssignableTo<TypeOnly<typeof current.BasicWebServerFactory>, TypeOnly<typeof old.BasicWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ClientManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ClientManager = requireAssignableTo<TypeOnly<typeof current.ClientManager>, TypeOnly<typeof old.ClientManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DeltaManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DeltaManager = requireAssignableTo<TypeOnly<typeof current.DeltaManager>, TypeOnly<typeof old.DeltaManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DocumentManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DocumentManager = requireAssignableTo<TypeOnly<typeof current.DocumentManager>, TypeOnly<typeof old.DocumentManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DocumentStorage": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DocumentStorage = requireAssignableTo<TypeOnly<typeof current.DocumentStorage>, TypeOnly<typeof old.DocumentStorage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_HttpServer": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_HttpServer = requireAssignableTo<TypeOnly<typeof current.HttpServer>, TypeOnly<typeof old.HttpServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MongoCollection": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MongoCollection = requireAssignableTo<TypeOnly<typeof current.MongoCollection>, TypeOnly<typeof old.MongoCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MongoDb": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MongoDb = requireAssignableTo<TypeOnly<typeof current.MongoDb>, TypeOnly<typeof old.MongoDb>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MongoDbFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MongoDbFactory = requireAssignableTo<TypeOnly<typeof current.MongoDbFactory>, TypeOnly<typeof old.MongoDbFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_NodeAllowList": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_NodeAllowList = requireAssignableTo<TypeOnly<typeof current.NodeAllowList>, TypeOnly<typeof old.NodeAllowList>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_NodeClusterWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_NodeClusterWebServerFactory = requireAssignableTo<TypeOnly<typeof current.NodeClusterWebServerFactory>, TypeOnly<typeof old.NodeClusterWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_NodeCodeLoader": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_NodeCodeLoader = requireAssignableTo<TypeOnly<typeof current.NodeCodeLoader>, TypeOnly<typeof old.NodeCodeLoader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RedisCache": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RedisCache = requireAssignableTo<TypeOnly<typeof current.RedisCache>, TypeOnly<typeof old.RedisCache>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RedisSocketIoAdapter": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RedisSocketIoAdapter = requireAssignableTo<TypeOnly<typeof current.RedisSocketIoAdapter>, TypeOnly<typeof old.RedisSocketIoAdapter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RedisThrottleAndUsageStorageManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RedisThrottleAndUsageStorageManager = requireAssignableTo<TypeOnly<typeof current.RedisThrottleAndUsageStorageManager>, TypeOnly<typeof old.RedisThrottleAndUsageStorageManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RestLessServer": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RestLessServer = requireAssignableTo<TypeOnly<typeof current.RestLessServer>, TypeOnly<typeof old.RestLessServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SecretManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SecretManager = requireAssignableTo<TypeOnly<typeof current.SecretManager>, TypeOnly<typeof old.SecretManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SocketIoNodeClusterWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SocketIoNodeClusterWebServerFactory = requireAssignableTo<TypeOnly<typeof current.SocketIoNodeClusterWebServerFactory>, TypeOnly<typeof old.SocketIoNodeClusterWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SocketIoRedisPublisher": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SocketIoRedisPublisher = requireAssignableTo<TypeOnly<typeof current.SocketIoRedisPublisher>, TypeOnly<typeof old.SocketIoRedisPublisher>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SocketIoRedisTopic": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SocketIoRedisTopic = requireAssignableTo<TypeOnly<typeof current.SocketIoRedisTopic>, TypeOnly<typeof old.SocketIoRedisTopic>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SocketIoWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SocketIoWebServerFactory = requireAssignableTo<TypeOnly<typeof current.SocketIoWebServerFactory>, TypeOnly<typeof old.SocketIoWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_StorageNameRetriever": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_StorageNameRetriever = requireAssignableTo<TypeOnly<typeof current.StorageNameRetriever>, TypeOnly<typeof old.StorageNameRetriever>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Tenant": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Tenant = requireAssignableTo<TypeOnly<typeof current.Tenant>, TypeOnly<typeof old.Tenant>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TenantManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TenantManager = requireAssignableTo<TypeOnly<typeof current.TenantManager>, TypeOnly<typeof old.TenantManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Throttler": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Throttler = requireAssignableTo<TypeOnly<typeof current.Throttler>, TypeOnly<typeof old.Throttler>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ThrottlerHelper": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ThrottlerHelper = requireAssignableTo<TypeOnly<typeof current.ThrottlerHelper>, TypeOnly<typeof old.ThrottlerHelper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_WebServer": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_ClassStatics_WebServer = requireAssignableTo<TypeOnly<typeof current.WebServer>, TypeOnly<typeof old.WebServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_WholeSummaryReadGitManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_WholeSummaryReadGitManager = requireAssignableTo<TypeOnly<typeof current.WholeSummaryReadGitManager>, TypeOnly<typeof old.WholeSummaryReadGitManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_WholeSummaryWriteGitManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_WholeSummaryWriteGitManager = requireAssignableTo<TypeOnly<typeof current.WholeSummaryWriteGitManager>, TypeOnly<typeof old.WholeSummaryWriteGitManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_containsPathTraversal": {"backCompat": false}
 */
declare type current_as_old_for_Function_containsPathTraversal = requireAssignableTo<TypeOnly<typeof current.containsPathTraversal>, TypeOnly<typeof old.containsPathTraversal>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createMessageReceiver": {"backCompat": false}
 */
declare type current_as_old_for_Function_createMessageReceiver = requireAssignableTo<TypeOnly<typeof current.createMessageReceiver>, TypeOnly<typeof old.createMessageReceiver>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createMessageSender": {"backCompat": false}
 */
declare type current_as_old_for_Function_createMessageSender = requireAssignableTo<TypeOnly<typeof current.createMessageSender>, TypeOnly<typeof old.createMessageSender>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createMetricClient": {"backCompat": false}
 */
declare type current_as_old_for_Function_createMetricClient = requireAssignableTo<TypeOnly<typeof current.createMetricClient>, TypeOnly<typeof old.createMetricClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createProducer": {"backCompat": false}
 */
declare type current_as_old_for_Function_createProducer = requireAssignableTo<TypeOnly<typeof current.createProducer>, TypeOnly<typeof old.createProducer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getBooleanParam": {"backCompat": false}
 */
declare type current_as_old_for_Function_getBooleanParam = requireAssignableTo<TypeOnly<typeof current.getBooleanParam>, TypeOnly<typeof old.getBooleanParam>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getDbFactory": {"backCompat": false}
 */
declare type current_as_old_for_Function_getDbFactory = requireAssignableTo<TypeOnly<typeof current.getDbFactory>, TypeOnly<typeof old.getDbFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_handleResponse": {"backCompat": false}
 */
declare type current_as_old_for_Function_handleResponse = requireAssignableTo<TypeOnly<typeof current.handleResponse>, TypeOnly<typeof old.handleResponse>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_run": {"backCompat": false}
 */
declare type current_as_old_for_Function_run = requireAssignableTo<TypeOnly<typeof current.run>, TypeOnly<typeof old.run>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_runService": {"backCompat": false}
 */
declare type current_as_old_for_Function_runService = requireAssignableTo<TypeOnly<typeof current.runService>, TypeOnly<typeof old.runService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_validateRequestParams": {"backCompat": false}
 */
declare type current_as_old_for_Function_validateRequestParams = requireAssignableTo<TypeOnly<typeof current.validateRequestParams>, TypeOnly<typeof old.validateRequestParams>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IHttpServerConfig": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IHttpServerConfig = requireAssignableTo<TypeOnly<old.IHttpServerConfig>, TypeOnly<current.IHttpServerConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IHttpServerConfig": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IHttpServerConfig = requireAssignableTo<TypeOnly<current.IHttpServerConfig>, TypeOnly<old.IHttpServerConfig>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INodeClusterConfig": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_INodeClusterConfig = requireAssignableTo<TypeOnly<old.INodeClusterConfig>, TypeOnly<current.INodeClusterConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INodeClusterConfig": {"backCompat": false}
 */
declare type current_as_old_for_Interface_INodeClusterConfig = requireAssignableTo<TypeOnly<current.INodeClusterConfig>, TypeOnly<old.INodeClusterConfig>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISocketIoRedisConnection": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISocketIoRedisConnection = requireAssignableTo<TypeOnly<old.ISocketIoRedisConnection>, TypeOnly<current.ISocketIoRedisConnection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISocketIoRedisConnection": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISocketIoRedisConnection = requireAssignableTo<TypeOnly<current.ISocketIoRedisConnection>, TypeOnly<old.ISocketIoRedisConnection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISocketIoRedisOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISocketIoRedisOptions = requireAssignableTo<TypeOnly<old.ISocketIoRedisOptions>, TypeOnly<current.ISocketIoRedisOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISocketIoRedisOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISocketIoRedisOptions = requireAssignableTo<TypeOnly<current.ISocketIoRedisOptions>, TypeOnly<old.ISocketIoRedisOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISocketIoRedisSubscriptionConnection": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISocketIoRedisSubscriptionConnection = requireAssignableTo<TypeOnly<old.ISocketIoRedisSubscriptionConnection>, TypeOnly<current.ISocketIoRedisSubscriptionConnection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISocketIoRedisSubscriptionConnection": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISocketIoRedisSubscriptionConnection = requireAssignableTo<TypeOnly<current.ISocketIoRedisSubscriptionConnection>, TypeOnly<old.ISocketIoRedisSubscriptionConnection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ConnectionNotAvailableMode": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ConnectionNotAvailableMode = requireAssignableTo<TypeOnly<old.ConnectionNotAvailableMode>, TypeOnly<current.ConnectionNotAvailableMode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ConnectionNotAvailableMode": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ConnectionNotAvailableMode = requireAssignableTo<TypeOnly<current.ConnectionNotAvailableMode>, TypeOnly<old.ConnectionNotAvailableMode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RequestListener": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_RequestListener = requireAssignableTo<TypeOnly<old.RequestListener>, TypeOnly<current.RequestListener>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RequestListener": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_RequestListener = requireAssignableTo<TypeOnly<current.RequestListener>, TypeOnly<old.RequestListener>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_decodeHeader": {"backCompat": false}
 */
declare type current_as_old_for_Variable_decodeHeader = requireAssignableTo<TypeOnly<typeof current.decodeHeader>, TypeOnly<typeof old.decodeHeader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_defaultErrorMessage": {"backCompat": false}
 */
declare type current_as_old_for_Variable_defaultErrorMessage = requireAssignableTo<TypeOnly<typeof current.defaultErrorMessage>, TypeOnly<typeof old.defaultErrorMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IsEphemeralContainer": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IsEphemeralContainer = requireAssignableTo<TypeOnly<typeof current.IsEphemeralContainer>, TypeOnly<typeof old.IsEphemeralContainer>>
